{"version":3,"file":"SceneBuilder/SceneBuilder.min.js","mappings":"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","sources":["webpack://Autodesk.Extensions/./node_modules/bintrees/index.js","webpack://Autodesk.Extensions/./node_modules/bintrees/lib/bintree.js","webpack://Autodesk.Extensions/./node_modules/bintrees/lib/rbtree.js","webpack://Autodesk.Extensions/./node_modules/bintrees/lib/treebase.js","webpack://Autodesk.Extensions/webpack/bootstrap","webpack://Autodesk.Extensions/./extensions/SceneBuilder/reusableIds.js","webpack://Autodesk.Extensions/./extensions/SceneBuilder/modelBuilder.js","webpack://Autodesk.Extensions/./extensions/SceneBuilder/locales.js","webpack://Autodesk.Extensions/./extensions/SceneBuilder/sceneBuilder.js"],"sourcesContent":["module.exports = {\n    RBTree: require('./lib/rbtree'),\n    BinTree: require('./lib/bintree')\n};\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction BinTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nBinTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nBinTree.prototype.insert = function(data) {\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        this.size++;\n        return true;\n    }\n\n    var dir = 0;\n\n    // setup\n    var p = null; // parent\n    var node = this._root;\n\n    // search down\n    while(true) {\n        if(node === null) {\n            // insert new node at the bottom\n            node = new Node(data);\n            p.set_child(dir, node);\n            ret = true;\n            this.size++;\n            return true;\n        }\n\n        // stop if found\n        if(this._comparator(node.data, data) === 0) {\n            return false;\n        }\n\n        dir = this._comparator(node.data, data) < 0;\n\n        // update helpers\n        p = node;\n        node = node.get_child(dir);\n    }\n};\n\n// returns true if removed, false if not found\nBinTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        p = node;\n        node = node.get_child(dir);\n        var cmp = this._comparator(data, node.data);\n        dir = cmp > 0;\n\n        if(cmp === 0) {\n            found = node;\n        }\n    }\n\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n\n        this._root = head.right;\n        this.size--;\n        return true;\n    }\n    else {\n        return false;\n    }\n};\n\nmodule.exports = BinTree;\n\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n    this.red = true;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction RBTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nRBTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nRBTree.prototype.insert = function(data) {\n    var ret = false;\n\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        ret = true;\n        this.size++;\n    }\n    else {\n        var head = new Node(undefined); // fake tree root\n\n        var dir = 0;\n        var last = 0;\n\n        // setup\n        var gp = null; // grandparent\n        var ggp = head; // grand-grand-parent\n        var p = null; // parent\n        var node = this._root;\n        ggp.right = this._root;\n\n        // search down\n        while(true) {\n            if(node === null) {\n                // insert new node at the bottom\n                node = new Node(data);\n                p.set_child(dir, node);\n                ret = true;\n                this.size++;\n            }\n            else if(is_red(node.left) && is_red(node.right)) {\n                // color flip\n                node.red = true;\n                node.left.red = false;\n                node.right.red = false;\n            }\n\n            // fix red violation\n            if(is_red(node) && is_red(p)) {\n                var dir2 = ggp.right === gp;\n\n                if(node === p.get_child(last)) {\n                    ggp.set_child(dir2, single_rotate(gp, !last));\n                }\n                else {\n                    ggp.set_child(dir2, double_rotate(gp, !last));\n                }\n            }\n\n            var cmp = this._comparator(node.data, data);\n\n            // stop if found\n            if(cmp === 0) {\n                break;\n            }\n\n            last = dir;\n            dir = cmp < 0;\n\n            // update helpers\n            if(gp !== null) {\n                ggp = gp;\n            }\n            gp = p;\n            p = node;\n            node = node.get_child(dir);\n        }\n\n        // update root\n        this._root = head.right;\n    }\n\n    // make root black\n    this._root.red = false;\n\n    return ret;\n};\n\n// returns true if removed, false if not found\nRBTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var gp = null; // grand parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        var last = dir;\n\n        // update helpers\n        gp = p;\n        p = node;\n        node = node.get_child(dir);\n\n        var cmp = this._comparator(data, node.data);\n\n        dir = cmp > 0;\n\n        // save found node\n        if(cmp === 0) {\n            found = node;\n        }\n\n        // push the red node down\n        if(!is_red(node) && !is_red(node.get_child(dir))) {\n            if(is_red(node.get_child(!dir))) {\n                var sr = single_rotate(node, dir);\n                p.set_child(last, sr);\n                p = sr;\n            }\n            else if(!is_red(node.get_child(!dir))) {\n                var sibling = p.get_child(!last);\n                if(sibling !== null) {\n                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {\n                        // color flip\n                        p.red = false;\n                        sibling.red = true;\n                        node.red = true;\n                    }\n                    else {\n                        var dir2 = gp.right === p;\n\n                        if(is_red(sibling.get_child(last))) {\n                            gp.set_child(dir2, double_rotate(p, last));\n                        }\n                        else if(is_red(sibling.get_child(!last))) {\n                            gp.set_child(dir2, single_rotate(p, last));\n                        }\n\n                        // ensure correct coloring\n                        var gpc = gp.get_child(dir2);\n                        gpc.red = true;\n                        node.red = true;\n                        gpc.left.red = false;\n                        gpc.right.red = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // replace and remove if found\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n        this.size--;\n    }\n\n    // update root and make it black\n    this._root = head.right;\n    if(this._root !== null) {\n        this._root.red = false;\n    }\n\n    return found !== null;\n};\n\nfunction is_red(node) {\n    return node !== null && node.red;\n}\n\nfunction single_rotate(root, dir) {\n    var save = root.get_child(!dir);\n\n    root.set_child(!dir, save.get_child(dir));\n    save.set_child(dir, root);\n\n    root.red = true;\n    save.red = false;\n\n    return save;\n}\n\nfunction double_rotate(root, dir) {\n    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));\n    return single_rotate(root, dir);\n}\n\nmodule.exports = RBTree;\n","\nfunction TreeBase() {}\n\n// removes all nodes from the tree\nTreeBase.prototype.clear = function() {\n    this._root = null;\n    this.size = 0;\n};\n\n// returns node data if found, null otherwise\nTreeBase.prototype.find = function(data) {\n    var res = this._root;\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            return res.data;\n        }\n        else {\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// returns iterator to node if found, null otherwise\nTreeBase.prototype.findIter = function(data) {\n    var res = this._root;\n    var iter = this.iterator();\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            iter._cursor = res;\n            return iter;\n        }\n        else {\n            iter._ancestors.push(res);\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// Returns an iterator to the tree node at or immediately after the item\nTreeBase.prototype.lowerBound = function(item) {\n    var cur = this._root;\n    var iter = this.iterator();\n    var cmp = this._comparator;\n\n    while(cur !== null) {\n        var c = cmp(item, cur.data);\n        if(c === 0) {\n            iter._cursor = cur;\n            return iter;\n        }\n        iter._ancestors.push(cur);\n        cur = cur.get_child(c > 0);\n    }\n\n    for(var i=iter._ancestors.length - 1; i >= 0; --i) {\n        cur = iter._ancestors[i];\n        if(cmp(item, cur.data) < 0) {\n            iter._cursor = cur;\n            iter._ancestors.length = i;\n            return iter;\n        }\n    }\n\n    iter._ancestors.length = 0;\n    return iter;\n};\n\n// Returns an iterator to the tree node immediately after the item\nTreeBase.prototype.upperBound = function(item) {\n    var iter = this.lowerBound(item);\n    var cmp = this._comparator;\n\n    while(iter.data() !== null && cmp(iter.data(), item) === 0) {\n        iter.next();\n    }\n\n    return iter;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.min = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.left !== null) {\n        res = res.left;\n    }\n\n    return res.data;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.max = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.right !== null) {\n        res = res.right;\n    }\n\n    return res.data;\n};\n\n// returns a null iterator\n// call next() or prev() to point to an element\nTreeBase.prototype.iterator = function() {\n    return new Iterator(this);\n};\n\n// calls cb on each node's data, in order\nTreeBase.prototype.each = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.next()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n// calls cb on each node's data, in reverse order\nTreeBase.prototype.reach = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.prev()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n\nfunction Iterator(tree) {\n    this._tree = tree;\n    this._ancestors = [];\n    this._cursor = null;\n}\n\nIterator.prototype.data = function() {\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns first node\n// otherwise, returns next node\nIterator.prototype.next = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._minNode(root);\n        }\n    }\n    else {\n        if(this._cursor.right === null) {\n            // no greater node in subtree, go up to parent\n            // if coming from a right child, continue up the stack\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.right === save);\n        }\n        else {\n            // get the next node from the subtree\n            this._ancestors.push(this._cursor);\n            this._minNode(this._cursor.right);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns last node\n// otherwise, returns previous node\nIterator.prototype.prev = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._maxNode(root);\n        }\n    }\n    else {\n        if(this._cursor.left === null) {\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.left === save);\n        }\n        else {\n            this._ancestors.push(this._cursor);\n            this._maxNode(this._cursor.left);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\nIterator.prototype._minNode = function(start) {\n    while(start.left !== null) {\n        this._ancestors.push(start);\n        start = start.left;\n    }\n    this._cursor = start;\n};\n\nIterator.prototype._maxNode = function(start) {\n    while(start.right !== null) {\n        this._ancestors.push(start);\n        start = start.right;\n    }\n    this._cursor = start;\n};\n\nmodule.exports = TreeBase;\n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { RBTree } from 'bintrees';\n\nconst tmpRange = [0, 1];\n\n/**\n * Table to manage ids that can be  reserved and released and keep the\n * id values as compact as possible.\n */\nexport class ReusableIds {\n  /**\n   * Construct the id table\n   */\n  constructor(lowId, highId, reserve) {\n    this._lowId = lowId === undefined ? 0 : (lowId | 0);\n    this._highId = highId === undefined ? 4 * 1024 * 1024 * 1024 - 1 : (highId | 0);\n    this._availableIds = new RBTree(function(a, b) { return a[0] - b[0]; });\n    this._availableIds.insert([this._lowId + (reserve | 0), this._highId]);\n  }\n\n  /**\n   * Get next id\n   * @return {number|undefined} The next id or undefined if there aren't any more ids.\n   */\n  reserveId() {\n    const range = this._availableIds.min();\n    if (range === null)\n      return undefined;\n    const id = range[0];\n    if (id >= range[1]) {\n      // Remove the empty range.\n      this._availableIds.remove(range);\n    } else {\n      // Updating the key of the RBTree without removing and inserting it\n      // is probably not correct, but the ranges are all disjoint and so it should be OK\n      ++range[0];\n    }\n    return id;\n  }\n\n  /**\n   * Make an id available again\n   * @param {number} id The id\n   * @return {Boolean} True if the id can be released.\n   */\n  releaseId(id) {\n    if (id < this._lowId || id > this._highId)\n      return false;\n\n    tmpRange[0] = id;   // Only the first\n    let ranges = this._availableIds.lowerBound(tmpRange);\n    const upper = ranges.data();\n    if (upper !== null) {\n      // Make sure the id isn't already in a range\n      if (upper[0] <= id && upper[1] >= id) {\n        return false;\n      }\n\n      ranges.prev();\n      const lower = ranges.data();\n      if (id + 1 === upper[0]) {\n        if (lower === null || id - 1 > lower[1]) {\n          // Extend the upper range to include id\n          // Updating the key of the RBTree without removing and inserting it\n          // is probably not correct, but the ranges are all disjoint and so it should be OK\n          upper[0] = id;\n        } else {\n          // Combine upper and lower ranges\n          this._availableIds.remove(upper);\n          this._availableIds.remove(lower);\n          upper[0] = lower[0];\n          this._availableIds.insert(upper);\n        }\n      } else if (lower === null || id - 1 > lower[1]) {\n        // Add a new single id range\n        this._availableIds.insert([id, id]);\n      } else {\n        // Extend the lower range\n        // Updating the key of the RBTree without removing and inserting it\n        // is probably not correct, but the ranges are all disjoint and so it should be OK\n        lower[1] = id;\n      }\n    }\n\n    return true;\n  }\n\n  isIdReserved(id) {\n    if (id < this._lowId || id > this._highId)\n      return false;\n\n    tmpRange[0] = id;   // Only the first\n    const upper = this._availableIds.upperBound(tmpRange).prev();\n    return !upper || id < upper[0] || id > upper[1];\n  }\n}\n","import { ReusableIds } from \"./reusableIds\";\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\n\nconst tmpMatrix = new THREE.Matrix4();\nconst tmpBox = new THREE.Box3();\nconst tmpMin = new THREE.Vector3();\nconst tmpMax = new THREE.Vector3();\nconst missingGeometry = { svfid: 0, boundingBox: new THREE.Box3() };\nconst meshInfo = {\n    geometry: null,\n    material: undefined,\n    matrix: tmpMatrix,\n    isLine: false,\n    isWideLine: false,\n    isPoint: false\n};\nconst isLines = avp.MeshFlags.MESH_ISLINE;\nconst isWideLines = avp.MeshFlags.MESH_ISWIDELINE;\nconst isPoints = avp.MeshFlags.MESH_ISPOINT;\nconst clearFlags = ~(isLines | isWideLines | isPoints);\nconst defaultMtlName = \"__defaultMaterial__\";\nconst REMOVED_EVENT = { type: \"removed\" };\n\nconst ROOT_NODE_ID = -1e9;   // Large negative number for root node id\nconst START_FRAG_ID = -100;  // Place where fragments without dbids are put\n\n// See InstanceTreeAccess in src/wgs/scene/InstanceTreeStorage.js\nclass SceneBuilderNodeAccess {\n    constructor() {\n        this.rootId = ROOT_NODE_ID;\n        this.nodeIndices = new ReusableIds(1);\n        this.dbIdToIndex = { [ROOT_NODE_ID]: 0};\n        this._nodeCount = 1;\n        this._maxIndex = 0;\n        this._nodeFlags = [0];\n        this._indexToFragId = [];\n        this._rootName = av.i18n.translate(\"Root\");\n    }\n\n    dtor() {\n        this.nodeIndices = null;\n    }\n\n    getIndex(id) {\n        return this.dbIdToIndex[id];\n    }\n\n    getNumNodes() {\n        // Use _maxIndex + 1 instead of _nodeCount. The ModelBrowserPanel get indices from the\n        // instance tree and assumes that they are < getNumNodes(). This guarantees that\n        // is true. _maxIndex + 1 will be >= _nodeCount and <= the fragment count.\n        return this._maxIndex + 1;\n    }\n\n    getParentId(nodeId) {\n        return nodeId === this.rootId ? undefined : this.rootId;\n    }\n\n    getNodeFlags(dbId) {\n        const index = this.dbIdToIndex[dbId];\n        return index >= 0 ? this._nodeFlags[index] : undefined;\n    }\n\n    setNodeFlags(dbId, flags) {\n        const index = this.dbIdToIndex[dbId];\n        if (index !== undefined)\n            this._nodeFlags[index] = flags;\n    }\n\n    name(nodeId, includeCount) {\n        return nodeId === this.rootId ?\n            ((includeCount && this._nodeCount > 1) ? `${this._rootName}(${this._nodeCount - 1})` : this._rootName) :\n            av.i18n.translate(\"Object %(nodeId)\", {\n                nodeId:     nodeId,\n            });\n    }\n\n    getNodeBox(dbId, dst) {\n        dst.setEmpty();\n    }\n\n    getNumChildren(nodeId) {\n        return nodeId == this.rootId ? this._nodeCount - 1 : 0;\n    }\n\n    getNumFragments(nodeId) {\n        if (nodeId === this.rootId)\n            return 0;\n        const index = this.dbIdToIndex[nodeId];\n        if (index === undefined)\n            return 0;\n        const frags = this._indexToFragId[index];\n        return Array.isArray(frags) ? frags.length : 1;\n    }\n\n    enumNodeFragments(node, callback) {\n        if (node === this.rootId)\n            return;\n        const index = this.dbIdToIndex[node];\n        if (index === undefined)\n            return;\n        const frags = this._indexToFragId[index];\n        let res;\n        if (Array.isArray(frags)) {\n            for (let i = 0; i < frags.length && !res; ++i)\n                res = callback(frags[i], node, index);\n        } else\n            res = callback(frags, node, index);\n\n        return res;\n    }\n\n    enumNodeChildren(dbId, callback) {\n        if (dbId !== this.rootId)\n            return;\n        const dbids = Object.keys(this.dbIdToIndex);\n        for (let i = 0; i < dbids.length; ++i) {\n            const child = parseInt(dbids[i]);\n            if (child !== this.rootId) {\n                if (callback(child, dbId, 0))\n                    return dbId;\n            }\n        }\n    }\n\n    addFragment(nodeId, fragId) {\n        let index = this.dbIdToIndex[nodeId];\n        if (index === undefined) {\n            index = this.nodeIndices.reserveId();\n            this.dbIdToIndex[nodeId] = index;\n            this._nodeFlags[index] = 0;\n            ++this._nodeCount;\n            if (index > this._maxIndex)\n                this._maxIndex = index;\n        }\n        const frags = this._indexToFragId[index];\n        if (frags === undefined)\n            this._indexToFragId[index] = fragId;\n        else if (Array.isArray(frags))\n            frags.push(fragId);\n        else\n            this._indexToFragId[index] = [frags, fragId];\n    }\n\n    removeFragment(nodeId, fragId) {\n        let index = this.dbIdToIndex[nodeId];\n        if (index !== undefined) {\n            const frags = this._indexToFragId[index];\n            if (Array.isArray(frags)) {\n                const i = frags.indexOf(fragId);\n                if (i >= 0 && frags.length === 2)\n                    this._indexToFragId[index] = frags[1 - i];\n                else\n                    frags.splice(i, 1);\n            } else {\n                this.nodeIndices.releaseId();\n                delete this.dbIdToIndex[nodeId];\n                delete this._indexToFragId[index];\n                --this._nodeCount;\n            }\n        }\n    }\n}\n\nclass EmptyModelLoader {\n    constructor(viewer) {\n        this.viewer3DImpl = viewer;\n    }\n\n    loadFile(url, options, onDone, onWorkerStart) {\n        onWorkerStart && onWorkerStart();\n        //Make the initial blank model\n        const initialSize = options.conserveMemory ? 1 : 0;\n        let svf = {\n            bbox : new THREE.Box3().set(options.globalOffset, options.globalOffset),\n            fragments: {\n                length: initialSize,\n                fragId2dbId: [0],\n                transforms: initialSize ? new Float32Array(initialSize * 12) : null,\n                boxes: initialSize ? new Float32Array(initialSize * 6) : null\n            },\n            is2d: false,\n            loadOptions: options || {},\n            isSceneBuilder: true,\n            loadDone: true, // True as model is empty\n            instanceTree: new avp.InstanceTree(new SceneBuilderNodeAccess(), 0, 1),\n            metadata: {}\n        };\n        let model = new av.Model(svf);\n\n        let name;\n        if (options && options.modelNameOverride) {\n            name = options.modelNameOverride;\n            // Undefine this in the options so the model browser panel will use\n            // the same name we copy to the instance tree. The instance tree will\n            // append the object count to the model name, but not if the name\n            // is take directly from the options.\n            options.modelNameOverride = undefined;\n        } else {\n            name = av.i18n.translate('Scene Builder %(modelId)', {\n                modelId:    model.getModelId()\n            });\n        }\n\n        svf.instanceTree.nodeAccess._rootName = name;\n        svf.urn = btoa(`Scene Builder ${model.getModelId()}`);\n        this.svf = svf;\n\n        model.initialize();\n        model.loader = this;\n        this.model = model;\n        model.getFragmentList().isFixedSize = false;\n        onDone(null, model);\n        this.viewer3DImpl.api.dispatchEvent({type:av.MODEL_ROOT_LOADED_EVENT, svf:svf, model:model});\n        this.viewer3DImpl.onLoadComplete(model);\n    }\n\n    dtor() {\n    }\n\n    is3d() {\n        return true;\n    }\n}\n\n/**\n * @param transform\n * @param dstMatrix\n * @private\n */\nfunction convertMatrix(transform, dstMatrix) {\n    if (!transform) {\n        dstMatrix.identity();\n    } else if (transform instanceof THREE.Matrix4) {\n        dstMatrix.copy(transform);\n    } else {\n        const dst = dstMatrix.elements;\n        dst[0] = transform[0];\n        dst[1] = transform[1];\n        dst[2] = transform[2];\n        dst[3] = 0;\n        dst[4] = transform[3];\n        dst[5] = transform[4];\n        dst[6] = transform[5];\n        dst[7] = 0;\n        dst[8] = transform[6];\n        dst[9] = transform[7];\n        dst[10] = transform[8];\n        dst[11] = 0;\n        dst[12] = transform[9];\n        dst[13] = transform[10];\n        dst[14] = transform[11];\n        dst[15] = 1;\n    }\n\n    return dstMatrix;\n}\n\n/**\n * Get the fragment id for a fragment\n *\n * @param {number|THREE.Mesh} fragment The mesh or the fragment id for a fragment.\n * @returns {number} The id of the fragment\n * @private\n */\nfunction getFragmentId(fragment) {\n    return (fragment instanceof THREE.Mesh) ? fragment.fragId : fragment;\n}\n\n/**\n * @param modelBuilder\n * @param fragment\n * @param geometry\n * @param material\n * @param transform\n * @param bbox\n * @private\n */\nfunction changeFragmentGeometry(modelBuilder, fragment, geometry, material, transform, bbox) {\n    // get the fragment id\n    const fragId = getFragmentId(fragment);\n\n    const model = modelBuilder.model;\n    const fragList = modelBuilder.fragList;\n\n    // Get the geometry\n    missingGeometry.geometry = (geometry === undefined ? modelBuilder.fragList.getGeometryId(fragId) :\n        (geometry instanceof THREE.BufferGeometry ? geometry.svfid : geometry)) || 0;\n    geometry = geometry === undefined ? modelBuilder.fragList.getGeometry(fragId) : modelBuilder._getGeometry(geometry);\n\n    // Get the material\n    const mtl = material === undefined ? modelBuilder.fragList.getMaterial(fragId) : modelBuilder._getMaterial(material);\n\n    let mesh = !modelBuilder.conserveMemory && model.getFragmentList().getVizmesh(fragId);\n    if (mesh) {\n        mesh.dispatchEvent(REMOVED_EVENT);\n    } else\n        mesh = meshInfo;\n\n    // Get the material\n    mesh.material = mtl;\n    // Clear the vizflags, that may be left over.\n    if (fragId < fragList.vizflags.length)\n        fragList.setFlagFragment(fragId, clearFlags);\n    // We need to mark whether the fragment is a line, wideline, or points\n    // If we don't have geometry, assume false, which will get fixed when\n    // the geometry is available.\n    mesh.geometry = geometry;\n    if (geometry) {\n        mesh.isLine = geometry.isLines;\n        mesh.isWideLine = geometry.isWideLines;\n        mesh.isPoint = geometry.isPoints;\n    } else {\n        mesh.geometry = missingGeometry;\n        mesh.isLine = false;\n        mesh.isWideLine = false;\n        mesh.isPoint = false;\n    }\n    // Get the transform\n    mesh.matrix = convertMatrix(transform, mesh === meshInfo ? tmpMatrix : mesh.matrix);\n    // Get the bounding box, if it is provided by the caller. Use meshInfo because\n    // bbox doesn't work when conserveMemory is false.\n    meshInfo.bbox = bbox && (bbox instanceof THREE.Box3 ? bbox :\n        tmpBox.set(tmpMin.fromArray(bbox, 0), tmpMax.fromArray(bbox, 3)));\n    fragList.fragments.fragId2dbId[fragId] = START_FRAG_ID - fragId;\n    modelBuilder.instanceTree.nodeAccess.addFragment(START_FRAG_ID - fragId, fragId);\n    model.setFragment(fragId, mesh, mesh !== meshInfo);\n    if (fragList.useThreeMesh && !geometry)\n        fragList.getVizmesh(fragId).geometry = null;\n\n    modelBuilder.sceneUpdated(true);\n    return true;\n}\n\n/**\n * @param geometry\n * @param dst\n * @private\n */\nfunction calculateBBox(geometry, dst) {\n    dst.makeEmpty();\n    avp.VertexEnumerator.enumMeshVertices(geometry, function(pos) {\n        dst.expandByPoint(pos);\n    });\n    return dst;\n}\n\n/**\n * @param matman\n * @param hash\n * @param material\n * @private\n */\nfunction addMaterial(matman, hash, material) {\n    if (material instanceof THREE.MeshPhongMaterial ||\n        (material instanceof THREE.ShaderMaterial && material.isPrismMaterial)) {\n        matman.addMaterial(hash, material, true);\n    } else\n        matman.addMaterialNonHDR(hash, material);\n}\n\n/**\n * @param newDbId\n * @param fragId\n * @param fragId2dbId\n * @param instanceTree\n * @private\n */\nfunction changeDbId(newDbId, fragId, fragId2dbId, instanceTree) {\n    const oldDbId = fragId2dbId[fragId] | 0;\n    newDbId = newDbId || START_FRAG_ID - fragId;\n    fragId2dbId[fragId] = newDbId;\n    if (newDbId === oldDbId)\n        return;\n\n    instanceTree.nodeAccess.removeFragment(oldDbId, fragId);\n    instanceTree.nodeAccess.addFragment(newDbId, fragId);\n}\n\n/**\n * Class that implements the API for building models dynamically.\n * An instance of this class can be obtained after the Promise returned by {@link Autodesk.Viewing.Extensions.SceneBuilder#addNewModel}\n * is resolved.\n *\n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.ModelBuilder\n *\n * @property {Autodesk.Viewing.Model} model The model instance being manipulated.\n */\nclass ModelBuilder {\n\n    /**\n     * The constructor is invoked automatically by {@link Autodesk.Viewing.Extensions.SceneBuilder}.\n     *\n     * @class\n     * @param {Autodesk.Viewing.Model} model The model this build works on\n     * @param {object} [options] Options for the ModelBuilder\n     * @param {boolean} [options.conserveMemory=false] Set to true to turn on memory conservation mode.\n     *  In this mode [addMesh()]{@link Autodesk.Viewing.Extensions.ModelBuilder#addMesh} is not available because\n     *  a single mesh is shared among all of the fragments in the model.\n     */\n    constructor(model, options) {\n        this.model = model;\n        this.geomList = model.getGeometryList();\n        this.fragList = model.getFragmentList();\n        // Initialize the ids we use for geometry and fragments.\n        this.geomIds = new ReusableIds(1);\n        this.fragmentIds = new ReusableIds(Math.max(model.getData().fragments.length, 1));\n        this.conserveMemory = !!(options && options.conserveMemory);\n        this.instanceTree = model.getData().instanceTree;\n        this.instanceTree.setFragmentList(this.fragList);\n        this.createWireframe = !!(options && options.createWireframe);\n    }\n\n    /**\n     * @returns {boolean} true when the model being manipulated is using the memory-optimized code path.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory\n     */\n    isConservingMemory() {\n        return this.conserveMemory;\n    }\n\n    /**\n     * Add geometry to the model.\n     *\n     * @param {THREE.BufferGeometry} geometry The geometry to add. This can be null or\n     *  undefined to allocate a geometry id without geometry.\n     * @param {number} [numFragments] The number of fragments you expect this geometry\n     *  to be used in. Default is 1. This is used to prioritize placing geometry on the\n     *  GPU. Geometry used by more fragments gets a higher priority.\n     * @returns {number} The id of the added geometry, or 0 if there was an error.\n     *\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#addGeometry\n     */\n    addGeometry(geometry, numFragments) {\n        // Must have geometry and it must not be in a model\n        if (geometry && geometry.svfid !== undefined)\n            return 0;\n\n        // Get the new geometry id\n        const geomId = this.geomIds.reserveId();\n        if (geomId === undefined)\n            return 0;   // 4 billion fragments? not likely\n\n        if (geometry) {\n            if (this.createWireframe) {\n\n                avp.createWireframe(geometry);\n\n                // createWireframe might add iblines (Uint16Array) to the geometry if not present already.\n                // If required, iblines are configured correctly as indexlines attribute:\n\n                if (!geometry.attributes.indexlines) {\n                    // add attribute for edge rendering\n                    const attrIndexLines = new THREE.BufferAttribute(undefined, 1);\n                    attrIndexLines.bytesPerItem = geometry.iblines instanceof Uint32Array ? 4 : 2;\n                    geometry.setAttribute( 'indexlines', attrIndexLines);\n                    geometry.iblinesbuffer = undefined;\n                }\n\n                // Add index for the renderer to draw the lines\n                if (!geometry.index) {\n                    const indices = new Uint16Array(geometry.attributes.position.length / 3);\n                    for (let i = 0; i < indices.length; ++i) {\n                        indices[i] = i;\n                    }\n                    const iba = new THREE.BufferAttribute(indices, 1);\n                    iba.bytesPerItem = 2;\n                    geometry.setIndex(iba);\n                }\n            }\n            // Sort of ugly - the geometry list will set geometry.boundingBox to null,\n            // but if we aren't conserving memory we need to keep the bounding box.\n            var bbox = geometry.boundingBox = geometry.boundingBox ||\n                calculateBBox(geometry, this.conserveMemory ? tmpBox : new THREE.Box3());\n            this.geomList.addGeometry(this.packNormals(geometry), numFragments, geomId);\n            if (!this.conserveMemory)\n                geometry.boundingBox = bbox;\n        }\n\n        return geomId;\n    }\n\n    /**\n     * Update fragments to use a new geometry id.\n     *\n     * @param {object.<number,boolean>} oldGeomIds Existing geometry ids\n     * @param {number} newGeomId New geometry id\n     * @private\n     */\n    _updateGeometry(oldGeomIds, newGeomId) {\n        const fragList = this.fragList;\n        let update = false;\n        if (this.conserveMemory) {\n            const geomids = fragList.geomids;\n            for (let i = 0; i < geomids.length; ++i) {\n                if (oldGeomIds[geomids[i]]) {\n                    this.changeFragmentGeometry(i, newGeomId);\n                    update = true;\n                }\n            }\n        } else {\n            const meshes = fragList.vizmeshes;\n            for (let i = 0; i < meshes.length; ++i) {\n                const mesh = meshes[i];\n                if (mesh && mesh.geometry && oldGeomIds[mesh.geometry.svfid]) {\n                    this.changeFragmentGeometry(i, newGeomId);\n                    update = true;\n                }\n            }\n        }\n\n        if (update)\n            this.sceneUpdated(true);\n    }\n\n    /**\n     * Validate geometry from caller\n     *\n     * @param {number|THREE.BufferGeometry|Array<number|THREE.BufferGeometry>} geometry The geometry or ids of the geometry\n     *  to validate.\n     * @returns {object.<string, boolean>} A map from id to true for the validated geometry. Null is returned if any\n     *  of the geometry is invalid.\n     * @private\n     */\n    _validateGeometry(geometry) {\n        if (!Array.isArray(geometry))\n            geometry = [geometry];\n\n        const search = {};\n        const geomList = this.geomList;\n        for (let i = 0; i < geometry.length; ++i) {\n            // Make sure geometry is valid\n            let id = geometry[i];\n            if (id instanceof THREE.BufferGeometry) {\n                // The geometry is a BufferGeometry make sure it is right\n                if (geomList.getGeometry(id.svfid) != id)\n                    return null;\n                id = id.svfid;\n            }\n            if (!this.geomIds.isIdReserved(id))\n                return null;\n            search[id] = true;\n        }\n\n        return search;\n    }\n\n    /**\n     * Change geometry in a model.\n     *\n     * @param {number|THREE.BufferGeometry} existingGeom The geometry or the id of the geometry to change\n     * @param {THREE.BufferGeometry} geometry Geometry that replaces the existing geometry\n     * @param {number} [numFragments] The number of fragments using this geometry.\n     *  If not given, then we will count the number in the model. This is used to\n     *  prioritize placing geometry on the GPU. Geometry used by more fragments\n     *  gets a higher priority.\n     * @returns {boolean} True if the existing geometry is valid and the geometry was changed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeGeometry\n     */\n    changeGeometry(existingGeom, geometry, numFragments) {\n        const result = this._validateGeometry(existingGeom);\n        if (!result)\n            return false;\n        const geomId = parseInt(Object.keys(result)[0]);\n        const geomList = this.geomList;\n        // Make sure existing geomId and the new geometry are valid\n        if (!geometry || (geometry && geometry.svfid !== undefined))\n            return false;\n\n        // remove the geometry\n        let oldGeom = geomList.getGeometry(geomId);\n        geomList.removeGeometry(geomId);\n\n        // Count the number of fragment using geomId\n        if (numFragments === undefined) {\n            numFragments = 0;\n            const fragList = this.fragList;\n            if (fragList.useThreeMesh) {\n                // Using THREE.Mesh directly, need to look there for the geometry\n                if (oldGeom) {\n                    const meshes = fragList.vizmeshes;\n                    for (let i = 0; i < meshes.length; ++i) {\n                        if (meshes[i] && meshes[i].geometry === oldGeom)\n                            ++numFragments;\n                    }\n                }\n            } else {\n                // Using geomIds, so look and fragment to geomId map\n                const frag2geom = fragList.geomids;\n                for (let i = 0; i < frag2geom.length; ++i) {\n                    if (frag2geom[i] === geomId)\n                        ++numFragments;\n                }\n            }\n            numFragments = numFragments || 1;\n        }\n\n\n        // Sort of ugly - the geometry list will set geometry.boundingBox to null,\n        // but if we aren't conserving memory we need to keep the bounding box.\n        var bbox = geometry.boundingBox = geometry.boundingBox ||\n            calculateBBox(geometry, this.conserveMemory ? tmpBox : new THREE.Box3());\n        geomList.addGeometry(this.packNormals(geometry), numFragments, geomId);\n        if (!this.conserveMemory)\n            geometry.boundingBox = bbox;\n\n        this._updateGeometry(result, geomId);\n        // clear old geomId\n        if (oldGeom)\n            oldGeom.svfid = undefined;\n        return true;\n    }\n\n    /**\n     * Find fragments using a specific geometry.\n     *\n     * @param {number|THREE.BufferGeometry|Array<number|THREE.BufferGeometry>} geometry The geometry\n     *  or id(s) of the geometry to use in the search\n     * @returns {number[]} An array with the fragment ids for all fragments that were using\n     *  the geometry. Null is returned if any geometry is invalid.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#findGeometryFragments\n     */\n    findGeometryFragments(geometry) {\n        const search = this._validateGeometry(geometry);\n\n        const frags = [];\n        const fragList = this.fragList;\n        if (fragList.useThreeMesh) {\n            // Using THREE.Mesh for the fragments, look there for the objects\n            const meshes = fragList.vizmeshes;\n            for (let i = 0; i < meshes.length; ++i) {\n                const id = meshes[i] && meshes[i].geometry && meshes[i].geometry.svfid;\n                if (search[id])\n                    frags.push(i);\n            }\n        } else {\n            // Using geom ids for the fragments, look and the fragment to geom id map\n            const geomids = fragList.geomids;\n            for (let i = 0; i < geomids.length; ++i) {\n                if (search[geomids[i]])\n                    frags.push(i);\n            }\n        }\n\n        return frags;\n    }\n\n    /**\n     * Remove geometry from the model.\n     *\n     * @param {number|THREE.BufferGeometry|Array<number|THREE.BufferGeometry>} geometry The geometry or id(s) of the geometry to remomve\n     * @returns {boolean} True if all of the ids are valid and the geometry is removed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#removeGeometry\n     */\n    removeGeometry(geometry) {\n\n        const delMap = this._validateGeometry(geometry);\n        if (!delMap)\n            return false;\n        const geomList = this.geomList;\n\n        this._updateGeometry(delMap, 0);\n\n        const delIds = Object.keys(delMap);\n        for (let i = 0; i < delIds.length; ++i) {\n            const geomId = parseInt(delIds[i]);\n            const geometry = geomList.getGeometry(geomId);\n            if (geometry)\n                geometry.svfid = undefined;\n            geomList.removeGeometry(geomId);\n            this.geomIds.releaseId(geomId);\n        }\n\n        return true;\n    }\n\n    /**\n     * Add a material that can be used by a mesh in the model.\n     *\n     * @param {string} name The name used for the material. This name must not be\n     *  used for an existing material in the model.\n     * @param {THREE.Material} material The material to add. This material must not\n     *  be used in the model.\n     * @returns {boolean} True if the material was added.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#addMaterial\n     */\n    addMaterial(name, material) {\n        if (!material || material.materialManagerName)\n            return false;\n        name = name || \"!!mtl-\" + material.id;\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const hash = matman._getMaterialHash(this.model, name);\n        // Name must not be used and material must be valid.\n        if (name === defaultMtlName || matman._materials[hash] || matman._materialsNonHDR[hash])\n            return false;\n        if (!material.packedNormals) {\n            material.packedNormals = true;\n            material.needsUpdate = true;\n        }\n\n        addMaterial(matman, hash, material);\n\n        material.materialManagerName = name;\n\n        return true;\n    }\n\n    /**\n     * Validate materials from caller\n     *\n     * @param {number|THREE.Material|Array<number|THREE.Material>} materials The materials or namess of the materials\n     *  to validate.\n     * @returns {string[]} An array of the hashes of the validated materials. Null is returned if any\n     *  of the materials are invalid.\n     * @private\n     */\n    _validateMaterials(materials) {\n        if (!Array.isArray(materials))\n            materials = [materials];\n\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const mtls = [];\n        for (let i = 0; i < materials.length; ++i) {\n            let name = materials[i];\n            let oldMat;\n            let hash;\n            if (name instanceof THREE.Material) {\n                oldMat = name;\n                name = name.materialManagerName;\n                hash = matman._getMaterialHash(this.model, name);\n                // Name must be the right material\n                if (oldMat !== (matman._materials[hash] || matman._materialsNonHDR[hash]))\n                    return null;\n            } else {\n                hash = matman._getMaterialHash(this.model, name);\n                // Name must be used\n                const oldMat = matman._materials[hash] || matman._materialsNonHDR[hash];\n                if (!oldMat)\n                    return null;\n            }\n\n            mtls.push(hash);\n        }\n\n        return mtls;\n    }\n\n    /**\n     * Replaces an existing material with another one.\n     *\n     * @param {string|THREE.Material} existingMaterial The material or name of the material to change. The material\n     *  must be in the model.\n     * @param {THREE.Material} material The material to replace the existing material. This material\n     *  must not be used in the model.\n     * @returns {boolean} True if the material is valid and the material was changed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeMaterial\n     */\n    changeMaterial(existingMaterial, material) {\n        if (!material || material.materialManagerName)\n            return false;\n        const mtls = this._validateMaterials(existingMaterial);\n        if (!mtls)\n            return false;\n\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const hash = mtls[0];\n        const oldMat = matman._materials[hash] || matman._materialsNonHDR[hash];\n        const name = oldMat.materialManagerName;\n        if (!material.packedNormals) {\n            material.packedNormals = true;\n            material.needsUpdate = true;\n        }\n\n        addMaterial(matman, hash, material);\n        oldMat.materialManagerName = undefined;\n        material.materialManagerName = name;\n\n        const fragList = this.fragList;\n        if (fragList.useThreeMesh) {\n            // Using meshes, need to replace the material in each mesh\n            const meshes = fragList.vizmeshes;\n            for (let i = 0; i < meshes.length; ++i) {\n                if (meshes[i] && meshes[i].material === oldMat)\n                    meshes[i].material = material;\n            }\n        } else {\n            // This is easier, because we just need to update the material\n            // at the right id\n            const matId = fragList.materialmap[oldMat.id];\n            if (matId !== undefined) {\n                fragList.materialmap[material.id] = matId;\n                fragList.materialIdMap[matId] = material;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Find a material\n     *\n     * @param {string} name The name of the material\n     */\n    findMaterial(name) {\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const hash = matman._getMaterialHash(this.model, name);\n        return matman._materials[hash] || matman._materialsNonHDR[hash];\n    }\n\n    /**\n     * Return the fragments that are using materials.\n     *\n     * @param {string|THREE.Material|Array<string|THREE.Material>} materials The materials or names of the materials to use in the search.\n     * @returns {number[]} An array with the fragment ids for all\n     *  fragments that were using the materials. Null is returned\n     *  if any material name is invalid or all of the materials were not removed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#findMaterialFragments\n     */\n    findMaterialFragments(materials) {\n        const hashes = this._validateMaterials(materials);\n        if (!hashes)\n            return null;\n\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const fragList = this.fragList;\n        const useThreeMesh = fragList.useThreeMesh;\n        let findFrags = false;\n        const matIds = {};\n        for (let i = 0; i < hashes.length; ++i) {\n            const oldMat = matman._materials[hashes[i]] || matman._materialsNonHDR[hashes[i]];\n            const matId = useThreeMesh ? oldMat.id : fragList.materialmap[oldMat.id];\n            if (matId !== undefined) {\n                matIds[matId] = true;\n                findFrags = true;\n            }\n        }\n\n        const frags = [];\n        if (findFrags) {\n            if (useThreeMesh) {\n                // Nees to seach the meshes for the material\n                const meshes = fragList.vizmeshes;\n                const fragCount = meshes.length;\n                for (let i = 0; i < fragCount; ++i) {\n                    const id = meshes[i] && meshes[i].material && meshes[i].material.id;\n                    if (matIds[id])\n                        frags.push(i);\n                }\n            } else {\n                // Need to search to the frag id to material id map\n                const frag2MatId = fragList.materialids;\n                const fragCount = frag2MatId.length;\n                for (let i = 0; i < fragCount; ++i) {\n                    if (matIds[frag2MatId[i]])\n                        frags.push(i);\n                }\n            }\n        }\n\n        return frags;\n    }\n\n    /**\n     * Remove a material from the model.\n     * The caller should dispose the material if needed.\n     *\n     * @param {string|THREE.Material|Array<string|THREE.Material>} materials The materials or names of the materials to remove. All of the\n     *  names must be used for materials in the model.\n     * @returns {boolean} True if all of the names are valid and all of the materials are removed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#removeMaterial\n     */\n    removeMaterial(materials) {\n        const hashes = this._validateMaterials(materials);\n        if (!hashes)\n            return false;\n\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const fragList = this.fragList;\n        const useThreeMesh = fragList.useThreeMesh;\n        const idMap = {};\n        let findFrags = false;\n\n        for (let i = 0; i < hashes.length; ++i) {\n            const oldMat = matman._materials[hashes[i]] || matman._materialsNonHDR[hashes[i]];\n            delete matman._materials[hashes[i]];\n            delete matman._materialsNonHDR[hashes[i]];\n\n            if (useThreeMesh) {\n                idMap[oldMat.id] = true;\n                findFrags = true;\n            } else {\n                const matId = fragList.materialmap[oldMat.id];\n                if (matId !== undefined) {\n                    delete fragList.materialmap[oldMat.id];\n                    delete fragList.materialIdMap[matId];\n                    idMap[matId] = true;\n                    findFrags = true;\n                }\n            }\n        }\n\n        // Map all fragments using this material to the default.\n        if (findFrags) {\n            if (useThreeMesh) {\n                // Using THREE.Mesh for the fragments, search the mesh list\n                const meshes = fragList.vizmeshes;\n                for (let i = 0; i < meshes.length; ++i) {\n                    const id = meshes[i] && meshes[i].material && meshes[i].material.id;\n                    if (idMap[id]) {\n                        fragList.setMaterial(i, this._getDefaultMaterial());\n                    }\n                }\n            } else {\n                // Use the frag to material id map to find materials to change\n                const fragToMtlId = fragList.materialids;\n                for (let i = 0; i < fragToMtlId.length; ++i) {\n                    if (idMap[fragToMtlId[i]]) {\n                        fragList.setMaterial(i, this._getDefaultMaterial());\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Add a fragment to the model using a mesh.\n     * Meshes can only be added to the model when {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is false.\n     * Note the following restrictions:\n     * - A mesh cannot be used multiple times.\n     * - The geometry for a mesh cannot be used in different models.\n     * - The material for a mesh cannot be used in different models.\n     *\n     * @param {THREE.Mesh} mesh The mesh to be added.\n     * @param {boolean} [mesh.isLine=false] Optional bool to mark line geometry\n     * @param {boolean} [mesh.isWideLine=false] Optional bool to mark wide line geometry\n     * @param {boolean} [mesh.isPoint=false] Optional bool to mark point geometry\n     * @param {number} [mesh.fragId] The fragment id for the mesh. This must not be defined\n     *  when addMesh() is called and the Viewer sets this property to the new fragment id.\n     * @param {number} [mesh.modeId] The id of the model. This must not be defined when\n     *  addMesh() is called and the Viewer will set this to the id of the model for this ModelBuilder.\n     * @param {number} [mesh.dbId] An optional object id for the mesh. Meshes with the same object id\n     *  are selected as a unit. Internal tables are maintained to link fragments and dbIds. If a mesh is\n     *  in the scene you shouldn't change this value direcly. Call\n     *  {@link Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentsDbId} to change it to insure\n     *  the tables are updated.\n     * @returns {boolean} True if the mesh was added.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#addMesh\n     */\n    addMesh(mesh) {\n        if (!mesh || this.conserveMemory || mesh.modelId !== undefined || mesh.fragId !== undefined)\n            return false;\n        if (!mesh.geometry || !mesh.material)\n            return false;\n\n        // Add the geometry, if it wasn't already added\n        const svfid = mesh.geometry.svfid;\n        if (svfid) {\n            if (this.geomList.getGeometry(svfid) !== mesh.geometry)\n                return false;\n        } else if (!this.addGeometry(mesh.geometry))\n            return false;\n\n        // Add the material, if it wasn't already added\n        const mtlName = mesh.material.materialManagerName;\n        if (mtlName) {\n            if (this.findMaterial(mtlName) !== mesh.material)\n                return false;\n        } else if (!this.addMaterial(undefined, mesh.material)) {\n            svfid && this.removeGeometry(svfid);\n            return false;\n        }\n\n        const fragId = this.fragmentIds.reserveId();\n        mesh.dbId = mesh.dbId || START_FRAG_ID - fragId;\n        this.model.setFragment(fragId, mesh, true);\n        const fragments = this.fragList.fragments;\n        fragments.fragId2dbId[fragId] = mesh.dbId;\n        this.instanceTree.nodeAccess.addFragment(mesh.dbId, fragId);\n        this.sceneUpdated(true);\n        return true;\n    }\n\n    /**\n     * Remove a mesh from the model.\n     * Meshes can only be removed from the model when {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is false.\n     *\n     * @param {THREE.Mesh|THREE.Mesh[]} meshes The meshes to be removed.\n     * @returns {boolean} True if the mesh was removed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#removeMesh\n     */\n    removeMesh(meshes) {\n        if (this.conserveMemory)\n            return false;\n\n        return this.removeFragment(meshes);\n    }\n\n    /**\n     * Use this method to inform the Viewer when you directly update a mesh you added\n     * to the model. If you change a mesh directly without calling this method,\n     * it may not display properly. You don't need to call this if you use the\n     * ModelBuilder API to update a mesh.\n     *\n     * @param {THREE.Mesh|THREE.Mesh[]} meshes The meshes that were changed.\n     * @param {boolean} [skipGeom=false] Set to true if the geometry in the meshes wasn't updated\n     * @param {boolean} [skipTransform=false] Set to true if the tranforms in the meshes weren't update\n     * @returns {boolean} True if the viewer was updated\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#updateMesh\n     */\n    updateMesh(meshes, skipGeom, skipTransform) {\n        // Did anything important change\n        if (skipGeom && skipTransform)\n            return true;    // No, return success\n\n        if (!Array.isArray(meshes))\n            meshes = [meshes];\n\n        let i = 0;\n        let mesh;\n        // Skip falsey meshes\n        while (!(mesh = meshes[i])) {\n            // No meshes in the input, return success;\n            if (++i >= meshes.length)\n                return true;\n        }\n\n        do {\n            if (mesh) {\n                if (!skipGeom) {\n                    this.packNormals(mesh.geometry);\n                    mesh.dispatchEvent(REMOVED_EVENT);\n                }\n                if (!skipTransform) {\n                    mesh.matrixWorld.copy(mesh.matrix);\n                }\n            }\n            mesh = meshes[++i];\n        } while (i < meshes.length);\n\n        this.sceneUpdated(!(skipGeom && skipTransform));\n        return true;\n    }\n\n    /**\n     * Signal viewer that scene was modified.\n     *\n     * @param {boolean} [objectsMoved=false] True if transforms or geometry was changed\n     * @param {boolean} [skipRepaint=false] True to skip repainting because of this change\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#sceneUpdated\n     */\n    sceneUpdated(objectsMoved, skipRepaint) {\n        this.model.loader.viewer3DImpl.sceneUpdated(objectsMoved, skipRepaint);\n    }\n\n    /**\n     * Validate the parameters for a fragment\n     *\n     * @param {number|THREE.Mesh} fragment The mesh or fragment id whose geometry is to be set.\n     * @param {number|THREE.BufferGeometry} geometry - The geometry or the id of the geometry for the fragment.\n     *  Use a falsey value if the geometry for the fragment isn't ready. If the geometry hasn't been added\n     *  to the model, this method will add it. Geometry must not be used in a different model.\n     * @param {string|THREE.material} material The material or the name of the material for the fragment.\n     *  A material name must be used by a material in the model, but a material will be added to the model\n     *  if it hasn't been.\n     * @returns {boolean} True if all parameters are valid\n     * @private\n     */\n    _validateFragment(fragment, geometry, material) {\n        if (fragment instanceof THREE.Mesh) {\n            if (!this.fragList.useThreeMesh || this.fragList.getVizmesh(fragment.fragId) !== fragment)\n                return false;\n        } else if (!this.fragmentIds.isIdReserved(fragment))\n            return false;\n\n        if (geometry) {\n            if (geometry instanceof THREE.BufferGeometry) {\n                if (geometry.svfid && this.geomList.getGeometry(geometry.svfid) !== geometry)\n                    return false;\n            } else if (!this.geomIds.isIdReserved(geometry))\n                return false;\n        }\n\n        if (material) {\n            if (material instanceof THREE.Material) {\n                if (material.materialManagerName &&\n                    this.findMaterial(material.materialManagerName) !== material) {\n                    return false;\n                }\n            } else if (!this.findMaterial(material))\n                return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the geometry id for some geometry\n     *\n     * @param {number|THREE.BufferGeometry} geometry The geometry or the geometry id. If this is geometry\n     *  it will be added to the model if it hasn't been.\n     * @returns {number|null} The id of the geometry, or null if the geometry is in a different model\n     * @private\n     */\n    _getGeometry(geometry) {\n        return (geometry instanceof THREE.BufferGeometry) ?\n            ((geometry.svfid || this.addGeometry(geometry)), geometry) :\n            this.geomList.getGeometry(geometry);\n    }\n\n    /**\n     * Get the material name for a material\n     *\n     * @param {number|THREE.Material} material The material or the material name. If this is a material\n     *  it will be added to the model if it hasn't been.\n     * @returns {string|null} The name of the material, or null if the material is in a different model\n     * @private\n     */\n    _getMaterial(material) {\n        if (material instanceof THREE.Material) {\n            if (material.materialManagerName) {\n                return material;\n            }\n            this.addMaterial(undefined, material);\n            return material;\n        }\n\n        return this.findMaterial(material);\n    }\n\n    /**\n     * Add a fragment to a model.\n     * A fragment is the combination of a geometry, a material, and a transform.\n     *\n     * @param {number|THREE.BufferGeometry} geometry - The geometry or the id of the geometry for the fragment.\n     *  Use a falsey value if the geometry for the fragment isn't ready. If the geometry hasn't been added\n     *  to the model, this method will add it. Geometry must not be used in a different model.\n     * @param {string|THREE.material} material The material or the name of the material instance for the fragment.\n     *  A material name must be used by a material in the model, but a material will be added to the model\n     *  if it hasn't already.\n     * @param {THREE.Matrix|number[]} [transform] The transform for the fragment. Default\n     *  is the identity transform. If an array is used it is a 4x3 matrix in column major order.\n     * @param {THREE.Box3|number[]} [bbox] Bounding box for the fragment. Default is\n     *  calculated from the geometry bounding box and the transform.\n     *  When {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is true\n     *  then this argument is ignored and the default is used. If an array is used\n     *  it contains the minimum x, y, z followed by the maximum x, y, z.\n     * @returns {number} The fragment id added or 0 if there was an error.\n     *\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#addFragment\n     */\n    addFragment(geometry, material, transform, bbox) {\n        const fragIds = this.fragmentIds;\n        const fragId = fragIds.reserveId();\n        if (fragId === undefined || !this._validateFragment(fragId, geometry, material))\n            return 0;\n        if (changeFragmentGeometry(this, fragId, geometry, material, transform, bbox))\n            return fragId;\n        fragIds.releaseId(fragId);\n        return 0;\n    }\n\n    /**\n     * Change the geometry and transform for a fragment.\n     *\n     * @param {number|THREE.Mesh} fragment The mesh or fragment id whose geometry is to be set.\n     * @param {number|THREE.BufferGeometry} geometry - The geometry or the id of the geometry for the fragment.\n     *  Use a falsey value if the geometry for the fragment isn't ready. If the geometry hasn't been added\n     *  to the model, this method will add it. Geometry must not be used in a different model.\n     * @param {THREE.Matrix|number[]} [transform] The transform for the fragment. If not\n     *  present the transform isn't changed. If an array is used it is a 4x3 matrix in column major order.\n     * @param {THREE.Box3|number[]} [bbox] Bounding box for the fragment. Default is\n     *  calculated from the geometry bounding box and the transform.\n     *  When {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is true\n     *  then this argument is ignored and the default is used. If an array is used\n     *  it contains the minimum x, y, z followed by the maximum x, y, z.\n     * @returns {boolean} True if the geometry id is valid and the fragment is changed.\n     *\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentGeometry\n     */\n    changeFragmentGeometry(fragment, geometry, transform, bbox) {\n        if (!this._validateFragment(fragment, geometry))\n            return false;\n        const fragId = getFragmentId(fragment);\n        transform = transform || (this.fragList.getOriginalWorldMatrix(fragId, tmpMatrix), tmpMatrix);\n        if (!changeFragmentGeometry(this, fragment, geometry, undefined, transform, bbox))\n            return false;\n        return true;\n    }\n\n    /**\n     * Get the default material\n     *\n     * @returns {THREE.Material} The default material\n     * @private\n     */\n    _getDefaultMaterial() {\n        // If already have default material, then use it\n        if (this._defaultMaterial)\n            return this._defaultMaterial;\n\n        // Clone the matman default.\n        const matman = this.model.loader.viewer3DImpl.matman();\n        const mtl = matman.defaultMaterial.clone();\n\n        // Make sure packed normals is true.\n        mtl.packedNormals = true;\n        mtl.needsUpdate = true;\n\n        // Add it to the material manager\n        matman.addMaterial(matman._getMaterialHash(this.model, defaultMtlName), mtl);\n        this._defaultMaterial = mtl;\n        mtl.materialManagerName = defaultMtlName;\n        return mtl;\n    }\n\n    /**\n     * Change the material for a fragment.\n     *\n     * @param {number|THREE.Mesh} fragment The mesh or fragment id whose material is to be set.\n     * @param {string|THREE.material} material The material or the name of the material for the fragment.\n     *  A material name must be used by a material in the model, but a material will be added to the model\n     *  if it hasn't been.\n     * @returns {boolean} True if the material id is valid and the fragment is changed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentMaterial\n     */\n    changeFragmentMaterial(fragment, material) {\n        if (!this._validateFragment(fragment, undefined, material))\n            return false;\n\n        // get the Material and set it for the fragment\n        const mtl = this._getMaterial(material) || this._getDefaultMaterial();\n        this.fragList.setMaterial(getFragmentId(fragment), mtl);\n        this.sceneUpdated(false);\n        return true;\n    }\n\n    /**\n     * Change the transform for a fragment.\n     *\n     * @param {number|THREE.Mesh} fragment The mesh or fragment id whose material is to be set.\n     * @param {THREE.Matrix|number[]} transform The transform for the fragment.\n     *  If an array is used it is a 4x3 matrix in column major order.\n     * @param {THREE.Box3|number[]} [bbox] [bbox] Bounding box for the fragment. Default is\n     *  calculated from the geometry bounding box and the transform.\n     *  When {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is true\n     *  then this argument is ignored and the default is used. If an array is used\n     *  it contains the minimum x, y, z followed by the maximum x, y, z.\n     * @returns {boolean} True if the fragId is valid and the transform was changed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentTransform\n     */\n    changeFragmentTransform(fragment, transform, bbox) {\n        if (! transform || !this._validateFragment(fragment))\n            return false;\n\n        // Need to replace the geometry with the same id to change\n        // the transform.\n        const id = getFragmentId(fragment);\n        if (!this.changeFragmentGeometry(id, this.fragList.getGeometryId(id),\n            transform, bbox)) {\n            return false;\n        }\n        this.sceneUpdated(true);\n        return true;\n    }\n\n    /**\n     * Change the dbId of one or more fragments\n     *\n     * @param {number|THREE.Mesh|Array<number|THREE.Mesh>} fragments The meshes or ids of the fragments to be changed\n     * @param {number} dbId The new dbId of the fragments. A 0 dbId will prevent an object from being selected.\n     *  All fragments with the same dbId are selected as a single object. Changing the dbids on fragments will\n     *  not change the display of objects that are already selected.\n     * @returns {boolean} True if all of the fragment ids were valid and all of the\n     *  fragments were changed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#changeFragmentsDbId\n     */\n    changeFragmentsDbId(fragments, dbId) {\n        if (!Array.isArray(fragments))\n            fragments = [fragments];\n\n        dbId = dbId | 0;    // Force dbId to integer\n        for (let i = 0; i < fragments.length; ++i) {\n            // Make sure the fragId is valid;\n            if (!this._validateFragment(fragments[i]))\n                return false;\n        }\n\n        const frags = this.fragList.fragments;\n        const instanceTree = this.instanceTree;\n        const fragId2dbId = frags.fragId2dbId;\n        if (this.conserveMemory) {\n            for (let i = 0; i < fragments.length; ++i) {\n                const id = getFragmentId(fragments[i]);\n                changeDbId(dbId, id, fragId2dbId, instanceTree);\n            }\n        } else {\n            const array = this.fragList.vizmeshes;\n            for (let i = 0; i < fragments.length; ++i) {\n                const id = getFragmentId(fragments[i]);\n                changeDbId(dbId, id, fragId2dbId, instanceTree);\n                array[id].dbId = dbId;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Remove fragments from the model\n     *\n     * @param {number|THREE.Mesh|Array<number|THREE.Mesh>} fragments The meshes or ids of the fragments to be removed\n     * @returns {boolean} True if all of the fragment ids were valid and all of the\n     *  fragments were removed.\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#removeFragment\n     */\n    removeFragment(fragments) {\n        if (!Array.isArray(fragments))\n            fragments = [fragments];\n\n        for (let i = 0; i < fragments.length; ++i) {\n            // Make sure the fragId is valid;\n            if (!this._validateFragment(fragments[i]))\n                return false;\n        }\n\n        const frags = this.fragList.fragments;\n        const instanceTree = this.instanceTree;\n        const array = this.conserveMemory ? this.fragList.geomids : this.fragList.vizmeshes;\n        const clear = this.conserveMemory ? 0 : null;\n        for (let i = 0; i < fragments.length; ++i) {\n            const id = getFragmentId(fragments[i]);\n            this.fragmentIds.releaseId(id);\n            instanceTree.nodeAccess.removeFragment(frags.fragId2dbId[id], id);\n            frags.fragId2dbId[id] = 0;\n            if (!this.conserveMemory && array[id]) {\n                array[id].dispatchEvent(REMOVED_EVENT);\n                array[id].fragId = array[id].modelId = undefined;\n            }\n            array[id] = clear;\n        }\n        this.sceneUpdated(true);\n\n        return true;\n    }\n\n    /**\n     * Pack normals for geometry.\n     * Utility method automatically used when {@link Autodesk.Viewing.Extensions.ModelBuilder#isConservingMemory} is true.\n     *\n     * @param {THREE.BufferGeometry} geometry\n     * @returns {THREE.BufferGeometry} The geometry argument is returned\n     *\n     * @alias Autodesk.Viewing.Extensions.ModelBuilder#packNormals\n     */\n    packNormals(geometry) {\n        const attributes = geometry.attributes;\n        const normal = attributes.normal;\n        // If no normals or normals are already packed, then skip this\n        if (!normal || normal.itemSize !== 3)\n            return geometry;\n\n        /**\n         * @param src\n         * @param srcOff\n         * @param srcStride\n         * @param dst\n         * @param dstOff\n         * @param dstStride\n         * @private\n         */\n        function cvt(src, srcOff, srcStride, dst, dstOff, dstStride) {\n            const atan2 = Math.atan2;\n            const INV_PI = 1 / Math.PI;\n            for ( ; srcOff < src.length; srcOff += srcStride, dstOff += dstStride) {\n                var pnx = (atan2(src[srcOff + 1], src[srcOff]) * INV_PI + 1.0) * 0.5;\n                var pny = (src[srcOff + 2] + 1.0) * 0.5;\n\n                dst[dstOff] = (pnx * 65535)|0;\n                dst[dstOff + 1] = (pny * 65535)|0;\n            }\n        }\n\n        if (!normal.array) {\n            // The normals are part of an interleaved buffer\n            // First copy all of the data that isn't normal to the new buffer\n            const vbstride = geometry.vbstride;\n            const vb = geometry.vb;\n            const vcount = Math.floor(vb.length / vbstride);\n\n            // ALlocate the new buffer. The normals shrink from 3 floats to\n            // 2 UInt16s which is 1 float. So reduce the vbstride by 2\n            const dst = new Float32Array((vbstride - 2) * vcount);\n            const srcOff = normal.offset;\n\n            if (srcOff <= 0 || srcOff + 3 >= vbstride) {\n                // Normals are at start or end of interleaved buffer\n                let from = srcOff <= 0 ? 3 : 0;\n                let to = srcOff <= 0 ? 1 : 0;\n                const length = vbstride - 3;\n                for (let i = 0; i < vcount; ++i, from += 3, to += 1) {\n                    for (let j = 0; j < length; ++j) {\n                        dst[to++] = vb[from++];\n                    }\n                }\n            } else {\n                // Normals are in the middle of interleaved buffer\n                // Normals are at start or end of interleaved buffer\n                let from = 0;\n                let to = 0;\n                const length1 = srcOff;\n                const length2 = vbstride - srcOff - 3;\n                for (let i = 0; i < vcount; ++i) {\n                    for (let j = 0; j < length1; ++j) {\n                        dst[to++] = vb[from++];\n                    }\n                    from += 3;\n                    to += 1;\n                    for (let j = 0; j < length2; ++j) {\n                        dst[to++] = vb[from++];\n                    }\n                }\n            }\n\n            // Pack the normals, Recast the interleaved buffer as 16 bit ints\n            cvt(vb, srcOff, vbstride, new Uint16Array(dst.buffer), srcOff * 2, (vbstride - 2) * 2);\n            geometry.vbstride -= 2;\n            geometry.vb = dst;\n            geometry.vbNeedsUpdate = true;\n            // For interleaved case, the attributes are cached and shared, so we need\n            // to find the attribute with the proper description.\n            attributes.normal = avp.BufferGeometryUtils.findBufferAttribute('normal', {\n                array: null,\n                bytesPerItem: 2,\n                itemSize: 2,\n                normalized: true,\n                isPattern: normal.isPattern,\n                divisor: normal.divisor,\n                offset: normal.offset\n            }, geometry.numInstances);\n\n            // Adjust all of the offsets for the packed buffers\n            const keys = Object.keys(attributes);\n            for (let i = 0; i < keys.length; ++i) {\n                const attr = attributes[keys[i]];\n                if (!attr.array && attr.offset > srcOff) {\n                    // For interleaved case, the attributes are cached and shared, so we need\n                    // to find the attribute with the proper description.\n                    attributes[keys[i]] = avp.BufferGeometryUtils.findBufferAttribute(keys[i], {\n                        array: null,\n                        bytesPerItem: attr.bytesPerItem,\n                        itemSize: attr.itemSize,\n                        normalized: attr.normalized,\n                        isPattern: attr.isPattern,\n                        divisor: attr.divisor,\n                        offset: attr.offset - 2\n                    }, geometry.numInstances);\n                }\n            }\n            return geometry;\n        }\n\n        // The normals are not LMV's interleaved attribute\n        const vcount = Math.floor(normal.array.length / normal.itemSize);\n        const dst = new Uint16Array(vcount * 2);\n        cvt(normal.array, 0, 3, dst, 0, 2);\n\n        normal.itemSize = 2;\n        normal.array = dst;\n        normal.normalized = true;\n        normal.bytesPerItem = 2;\n\n        return geometry;\n    }\n\n    /**\n     * Add a new model to the viewer\n     *\n     * @param {Autodesk.Extensions.SceneBuilder.SceneBuilder} sceneBuilder The SceneBuilder asking for the model\n     * @param {any} options Options for adding the model.\n     * @param {boolean} [options.conserveMemory] Set to true to turn on memory conservation mode.\n     *  In this mode [addMesh()]{@link Extensions.SceneBuilder.ModelBuilder#addMesh} is not available because a single mesh is shared among\n     *  all of the fragments in the model.\n     * @param {boolean} [options.createWireframe] Set to true to turn on edge generation for geometry.\n     * @returns {Promise<Autodesk.Extensions.SceneBuilder.ModelBuilder>} A promise that resolves to the ModelBuilder for the new model.\n     * @private\n     */\n    static addNewModel(sceneBuilder, options) {\n        return new Promise(function(resolve, reject) {\n            //Set up overrides for Fluent\n            var loadOptions = Object.assign({}, options);\n            loadOptions.fileLoader = EmptyModelLoader;\n            loadOptions.globalOffset = loadOptions.globalOffset || {x: 0, y: 0, z: 0}; //Make camera operations more sane by not having to offset everything\n\n            sceneBuilder.viewer.loadModel(\"Dummy\", loadOptions, function(model) {\n                resolve(new ModelBuilder(model, loadOptions));\n            }, function(error) {\n                reject(error);\n            });\n        });\n    }\n}\n\nexport { ModelBuilder };\n","/**\n * Include each locale json file and return it in an object\n * that can be consumed by i18n\n */\n\nimport json_en from '../../res/locales/en/nobundle-scene-builder.loc.json';\nimport json_en_GB from '../../res/locales/en-GB/nobundle-scene-builder.loc.json';\nimport json_cs from '../../res/locales/cs/nobundle-scene-builder.loc.json';\nimport json_de from '../../res/locales/de/nobundle-scene-builder.loc.json';\nimport json_es from '../../res/locales/es/nobundle-scene-builder.loc.json';\nimport json_fr from '../../res/locales/fr/nobundle-scene-builder.loc.json';\nimport json_fr_CA from '../../res/locales/fr-CA/nobundle-scene-builder.loc.json';\nimport json_it from '../../res/locales/it/nobundle-scene-builder.loc.json';\nimport json_ja from '../../res/locales/ja/nobundle-scene-builder.loc.json';\nimport json_ko from '../../res/locales/ko/nobundle-scene-builder.loc.json';\nimport json_pl from '../../res/locales/pl/nobundle-scene-builder.loc.json';\nimport json_pt_BR from '../../res/locales/pt-BR/nobundle-scene-builder.loc.json';\nimport json_ru from '../../res/locales/ru/nobundle-scene-builder.loc.json';\nimport json_tr from '../../res/locales/tr/nobundle-scene-builder.loc.json';\nimport json_zh_Hans from '../../res/locales/zh-Hans/nobundle-scene-builder.loc.json';\nimport json_zh_Hant from '../../res/locales/zh-Hant/nobundle-scene-builder.loc.json';\nimport json_zh_HK from '../../res/locales/zh-HK/nobundle-scene-builder.loc.json';\nimport json_nl from '../../res/locales/nl/nobundle-scene-builder.loc.json';\nimport json_sv from '../../res/locales/sv/nobundle-scene-builder.loc.json';\nimport json_da from '../../res/locales/da/nobundle-scene-builder.loc.json';\nimport json_no from '../../res/locales/no/nobundle-scene-builder.loc.json';\n\nexport const locales = {\n    en: json_en,\n    \"en-GB\": json_en_GB,\n    cs: json_cs,\n    de: json_de,\n    es: json_es,\n    fr: json_fr,\n    \"fr-CA\": json_fr_CA,\n    it: json_it,\n    ja: json_ja,\n    ko: json_ko,\n    pl: json_pl,\n    \"pt-BR\": json_pt_BR,\n    ru: json_ru,\n    tr: json_tr,\n    \"zh-Hans\": json_zh_Hans,\n    \"zh-Hant\": json_zh_Hant,\n    \"zh-HK\": json_zh_HK,\n    nl: json_nl,\n    sv: json_sv,\n    da: json_da,\n    no: json_no,\n};\n","import { ModelBuilder } from './modelBuilder';\nimport { locales } from './locales';\n\nconst av = Autodesk.Viewing;\nconst SCENE_BUILD_EXTENSION_ID = \"Autodesk.Viewing.SceneBuilder\";\n\n/**\n * Scene Builder extension provides an API for building scenes without\n * loading them from a URL.\n *\n * The extension id is: `Autodesk.Viewing.SceneBuilder`\n *\n * @example\n *  viewer.loadExtension('Autodesk.Viewing.SceneBuilder');\n *\n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.SceneBuilder\n */\nclass SceneBuilder extends av.Extension {\n\n    /**\n     * @class\n     * @param {Autodesk.Viewing.Viewer3D} viewer The viewer instance loading the extension\n     * @param {object} [options] Default options used when calling addNewModel\n     * @param {boolean} [options.conserveMemory=false] Set to true to turn on memory conservation mode.\n     *  In this mode [addMesh()]{@link Autodesk.Viewing.Extensions.SceneBuilder#addMesh} is not available because a single mesh is shared among\n     *  all of the fragments in the model.\n     */\n    constructor(viewer, options) {\n        super(viewer, options);\n        this._loaded = false;\n        this.extendLocalization(locales);\n    }\n\n    /**\n     * Extension interface method - loads the extension\n     *\n     * @alias Autodesk.Viewing.Extensions.SceneBuilder#load\n     * @returns {boolean}\n     */\n    load() {\n        this._loaded = true;\n        return true;\n    }\n\n    /**\n     * Extension interface method - unloads the extension\n     * Method {@link Autodesk.Viewing.Extensions.SceneBuilder#addNewModel} will fail if the extension is unloaded.\n     *\n     * @alias Autodesk.Viewing.Extensions.SceneBuilder#unload\n     */\n    unload() {\n        this._loaded = false;\n        return true;\n    }\n\n     /**\n      * Add a new empty model into the scene. The model can be manipulated only by its associated\n      * ModelBuilder instance.\n      *\n      * @param {object} [options] Options combined with the options used  when the\n      *  extension is loaded with loadExtension(). The combined options are\n      *  put in the loadOptions property in the object returned by model.getData().\n      * @param {boolean} [options.conserveMemory=false] Set to true to turn on memory conservation mode.\n      *  In this mode [addMesh()]{@link Autodesk.Viewing.Extensions.SceneBuilder#addMesh} is not available because a single mesh is shared among\n      *  all of the fragments in the model.\n      * @param {boolean} [options.createWireframe] Set to true to turn on edge generation for geometry.\n      * @returns {Promise.<Autodesk.Viewing.Extensions.ModelBuilder>} A Promise that resolves with a ModelBuilder instance for the new model.\n      *\n      * @alias Autodesk.Viewing.Extensions.SceneBuilder#addNewModel\n      */\n    addNewModel(options) {\n        if (!this._loaded) {\n            return Promise.reject(new Error(\"SceneBuilder extension not loaded\"));\n        }\n\n        return ModelBuilder.addNewModel(this, Object.assign({}, this.options, options));\n    }\n}\n\nav.theExtensionManager.registerExtension(SCENE_BUILD_EXTENSION_ID, SceneBuilder);\n"],"names":["module","exports","RBTree","BinTree","TreeBase","Node","data","this","left","right","comparator","_root","_comparator","size","prototype","get_child","dir","set_child","val","insert","p","node","ret","remove","head","undefined","found","cmp","red","is_red","single_rotate","root","save","double_rotate","last","gp","ggp","dir2","sr","sibling","gpc","Iterator","tree","_tree","_ancestors","_cursor","clear","find","res","c","findIter","iter","iterator","push","lowerBound","item","cur","i","length","upperBound","next","min","max","each","cb","it","reach","prev","_minNode","pop","_maxNode","start","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","tmpRange","ReusableIds","constructor","lowId","highId","reserve","_lowId","_highId","_availableIds","a","b","reserveId","range","id","releaseId","ranges","upper","lower","isIdReserved","av","Autodesk","Viewing","avp","Private","tmpMatrix","THREE","Matrix4","tmpBox","Box3","tmpMin","Vector3","tmpMax","missingGeometry","svfid","boundingBox","meshInfo","geometry","material","matrix","isLine","isWideLine","isPoint","clearFlags","MeshFlags","MESH_ISLINE","MESH_ISWIDELINE","MESH_ISPOINT","defaultMtlName","REMOVED_EVENT","type","ROOT_NODE_ID","START_FRAG_ID","SceneBuilderNodeAccess","rootId","nodeIndices","dbIdToIndex","_nodeCount","_maxIndex","_nodeFlags","_indexToFragId","_rootName","i18n","translate","dtor","getIndex","getNumNodes","getParentId","nodeId","getNodeFlags","dbId","index","setNodeFlags","flags","name","includeCount","getNodeBox","dst","setEmpty","getNumChildren","getNumFragments","frags","Array","isArray","enumNodeFragments","callback","enumNodeChildren","dbids","Object","keys","child","parseInt","addFragment","fragId","removeFragment","indexOf","splice","EmptyModelLoader","viewer","viewer3DImpl","loadFile","url","options","onDone","onWorkerStart","initialSize","conserveMemory","svf","bbox","set","globalOffset","fragments","fragId2dbId","transforms","Float32Array","boxes","is2d","loadOptions","isSceneBuilder","loadDone","instanceTree","InstanceTree","metadata","model","Model","modelNameOverride","modelId","getModelId","nodeAccess","urn","btoa","initialize","loader","getFragmentList","isFixedSize","api","dispatchEvent","MODEL_ROOT_LOADED_EVENT","onLoadComplete","is3d","getFragmentId","fragment","Mesh","changeFragmentGeometry","modelBuilder","transform","fragList","getGeometryId","BufferGeometry","getGeometry","_getGeometry","mtl","getMaterial","_getMaterial","mesh","getVizmesh","vizflags","setFlagFragment","isLines","isWideLines","isPoints","dstMatrix","copy","elements","identity","convertMatrix","fromArray","setFragment","useThreeMesh","sceneUpdated","calculateBBox","makeEmpty","VertexEnumerator","enumMeshVertices","pos","expandByPoint","addMaterial","matman","hash","MeshPhongMaterial","ShaderMaterial","isPrismMaterial","addMaterialNonHDR","changeDbId","newDbId","oldDbId","ModelBuilder","geomList","getGeometryList","geomIds","fragmentIds","Math","getData","setFragmentList","createWireframe","isConservingMemory","addGeometry","numFragments","geomId","attributes","indexlines","attrIndexLines","BufferAttribute","bytesPerItem","iblines","Uint32Array","setAttribute","iblinesbuffer","indices","Uint16Array","position","iba","setIndex","packNormals","_updateGeometry","oldGeomIds","newGeomId","update","geomids","meshes","vizmeshes","_validateGeometry","search","changeGeometry","existingGeom","result","oldGeom","removeGeometry","frag2geom","findGeometryFragments","delMap","delIds","materialManagerName","_getMaterialHash","_materials","_materialsNonHDR","packedNormals","needsUpdate","_validateMaterials","materials","mtls","oldMat","Material","changeMaterial","existingMaterial","matId","materialmap","materialIdMap","findMaterial","findMaterialFragments","hashes","findFrags","matIds","fragCount","frag2MatId","materialids","removeMaterial","idMap","setMaterial","_getDefaultMaterial","fragToMtlId","addMesh","mtlName","removeMesh","updateMesh","skipGeom","skipTransform","matrixWorld","objectsMoved","skipRepaint","_validateFragment","fragIds","getOriginalWorldMatrix","_defaultMaterial","defaultMaterial","clone","changeFragmentMaterial","changeFragmentTransform","changeFragmentsDbId","array","normal","itemSize","cvt","src","srcOff","srcStride","dstOff","dstStride","atan2","INV_PI","PI","pnx","pny","vbstride","vb","vcount","floor","offset","from","to","j","length1","length2","buffer","vbNeedsUpdate","BufferGeometryUtils","findBufferAttribute","normalized","isPattern","divisor","numInstances","attr","addNewModel","sceneBuilder","Promise","resolve","reject","assign","fileLoader","x","y","z","loadModel","error","locales","en","cs","de","es","fr","ja","ko","pl","ru","tr","nl","sv","da","no","SceneBuilder","Extension","super","_loaded","extendLocalization","load","unload","Error","theExtensionManager","registerExtension"],"sourceRoot":""}