/*!
 * LMV v7.105.0
 *
 * Copyright 2025 Autodesk, Inc.
 * All rights reserved.
 *
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 *
 * Autodesk Viewer SDK Usage Limitations:
 *
 * The Autodesk Viewer SDK JavaScript must be delivered from an
 * Autodesk-hosted URL.
 */
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	// runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ 	var __webpack_modules__ = ({

/***/ "./extensions/CrossFadeEffects/CrossFadeEffects.js":
/*!*********************************************************!*\
  !*** ./extensions/CrossFadeEffects/CrossFadeEffects.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CrossFadeEffects)\n/* harmony export */ });\n/* harmony import */ var _TargetCrossFade__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TargetCrossFade */ \"./extensions/CrossFadeEffects/TargetCrossFade.js\");\n\n\nconst myExtensionName = 'Autodesk.CrossFadeEffects';\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\n\n\n\n/** CrossFadeEffects extension provides API for implementing smooth fading effects in LMV, e.g.\n *  - CrossFading between models or model configurations (e.g. color theming, hiding objects etc.)\n *  - Image-based \"ghosting\" effect, i.e. showing a semitransparent snapshot of a model on top of another one.\n *\n * The extension id is: `Autodesk.CrossFadeEffects`\n *\n * Note:\n *  - Note that CrossFadeEffects require 2 extra RenderTargets. So, they should only be used for optional effects that can be skipped on weak devices.\n *  - CrossFade effects can only be used for one purpose at a time. When using them for a new feature, you have to make sure\n *    that they don't conflict with existing features.\n *\n * @example\n *   viewer.loadExtension('Autodesk.CrossFadeEffects')\n *\n * @memberof Autodesk.Viewing.Extensions\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @alias Autodesk.Viewing.Extensions.CrossFadeEffects\n * @class\n */\nclass CrossFadeEffects extends av.Extension {\n  constructor(viewer, options) {\n\n    super(viewer, options);\n    this.crossFade = null;\n\n    // Used to handle conflicts if this extension is used for different purposes\n    this.clientId = null;\n    this.onClientChanged = null;\n  }\n\n  /**\n   * Enables cross frade effects.\n   *\n   * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#load\n   */\n  load() {\n    this.setCrossFadeEnabled(true);\n    return true;\n  }\n\n  /**\n   * Disables cross frade effects.\n   *\n   * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#unload\n   */\n  unload() {\n    this.setCrossFadeEnabled(false);\n  }\n\n  /**\n   * Fading targets may be used by different clients for different purposes. That's okay as long\n   * as it does not happen concurrently.\n   *\n   * In case of conflicts, the last caller takes precedence.\n   *\n   * If you start an effect using this extension, always call this function to notify client\n   * code that was using it before. Vice versa, provide an onClientChanged() callback to handle the case\n   * that someone else overtakes.\n   *\n   * Example: If start a fading effect while the ghost floors of the LevelsExtension are fading\n   * out, the LevelsExtension will be notified to skip the fade-out anim to avoid conflicts.\n   *\n   * @param {string} clientId - Some identifier unique for the code component using the effect, e.g. the name of an extension.\n   * @param {Function} [onClientChanged] - Will be called if another client called acquireControl.\n   * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#acquireControl\n   */\n  acquireControl(clientId, onClientChanged) {\n    this.clientId = clientId;\n    this.onClientChanged && this.onClientChanged(); // let previous client code now that we took control\n    this.onClientChanged = onClientChanged; // call onClientChanged if someone else overtakes later\n  }\n\n  /**\n   * Only allowed if modelCrossFade is enabled. Determines to which target a RenderModel will be rendered.\n   *\n   *  @param {number} modelId - The model id\n   *  @param {undefined|0|1} targetIndex - index of the crossFade target or undefined (default) to use default color buffer\n   *\n   * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setModelTargetIndex\n   */\n  setModelTargetIndex(modelId, targetIndex) {\n    this.crossFade.setModelTargetIndex(modelId, targetIndex);\n    this.viewer.impl.invalidate(true);\n  }\n\n  /**\n   * Only allowed if modelCrossFade is enabled. Determines to which target a RenderModel will be rendered.\n   *\n   * @param {undefined|0|1} index - index of the crossFade target or undefined (default) to use default color buffer\n   * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setModelTargetIndexForAll\n   */\n  setModelTargetIndexForAll(index) {\n    const models = this.viewer.getVisibleModels();\n    for (let i = 0; i < models.length; i++) {\n      const model = models[i];\n      this.setModelTargetIndex(model.id, index);\n    }\n  }\n\n  /**\n   * Only allowed if modelCrossFade is enabled. Assigns a blending opacity to a cross-fading\n   * extra target.\n   *\n   *  @param {number} targetIndex - must be >0\n   *  @param {number} opacity     - in [0,1]\n   *\n   * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setCrossFadeOpacity\n   */\n  setCrossFadeOpacity(targetIndex, opacity) {var _this$viewer$impl;\n    this.crossFade.setCrossFadeOpacity(targetIndex, opacity);\n    (_this$viewer$impl = this.viewer.impl) === null || _this$viewer$impl === void 0 || _this$viewer$impl.invalidate(true);\n  }\n\n  /*\n   * @param {number} targetIndex - must be >0\n   * @returns {number} opacity\n   *\n   * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#getCrossFadeOpacity\n   */\n  getCrossFadeOpacity(targetIndex) {\n    return this.crossFade.getCrossFadeOpacity(targetIndex);\n  }\n\n  /**\n   * Enable/Disable model cross-fading. Must be enabled in order to render models to different render targets\n   * for cross-fading effects (see below). If no cross-fading effects are used, it should be disabled to save\n   * GPU memory and performance.\n   *\n   * @param {boolean} enable - Whether to enable(true) or disable(false) cross fade effects.\n   *\n   * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setCrossFadeEnabled\n   */\n  setCrossFadeEnabled(enable) {\n    if (enable === Boolean(this.crossFade)) {\n      return;\n    }\n\n    let renderer = this.viewer.impl.renderer();\n    if (enable) {\n      let blendPass = renderer.getBlendPass();\n      this.crossFade = new _TargetCrossFade__WEBPACK_IMPORTED_MODULE_0__.TargetCrossFade(blendPass);\n      renderer.setCrossFade(this.crossFade);\n    } else {\n      this.crossFade.dtor();\n      renderer.setCrossFade(null);\n    }\n\n    // If targets have been created already, call resize to make sure that\n    //   1. crossFade targets are created and have correct size/format\n    //   2. colorTarget/idTarget are reallocated with correct format\n    //      Note that toggling crossFade affects color/id target format as well, because\n    //      RGB and RGBA targets cannot be used at once when using MRT.\n    let colorTarget = renderer.getColorTarget();\n    if (colorTarget) {\n      const pixelRatio = this.viewer.impl.glrenderer().getPixelRatio(); //setSize expects the size without pixelRatio\n      renderer.setSize(colorTarget.width / pixelRatio, colorTarget.height / pixelRatio);\n    }\n  }\n\n  /*\n   * Renders a frame into a fading target, so that we can use it for a static-image fade.\n   * The target will be protected from cleaning, so that it will overdraw the main scene.\n   * To go back to normal rendering, call releaseFadingImage(fadeTargetIndex) afterwards.\n   *  @param {0|1} fadeTargetIndex\n   *  @param {number} [frameBudget] - time budget in ms that can be used for rendering this image.\n   *                                  Only relevant if progressive rendering is on.\n   *                                  Default value is the current this.targetFrameBudget setting.\n   *\n   * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#renderFadingImage\n   */\n  renderFadingImage(fadeTargetIndex, frameBudget) {\n    // Make sure last frame was rendered to main target.\n    // This is needed in case there were changes made (like cutplanes applied), before the viewer was able to render them.\n    let timestamp = performance.now();\n    this.viewer.impl.tick(timestamp);\n\n    // make RenderContext render into fadeTarget\n    let renderer = this.viewer.impl.renderer();\n    this.crossFade.beginRenderToFadeTarget(fadeTargetIndex, renderer);\n\n    // start new frame\n    this.viewer.impl.invalidate(true, true, true);\n\n    // temporarily overload rendering budget (if wanted)\n    let originalFrameBudget = this.viewer.impl.targetFrameBudget;\n    if (frameBudget) {\n      this.viewer.impl.targetFrameBudget = frameBudget;\n    }\n\n    timestamp = performance.now();\n    this.viewer.impl.tick(timestamp);\n\n    // recover original frame budget\n    this.targetFrameBudget = originalFrameBudget;\n\n    // make RenderContext render to the main scene canvas again\n    this.crossFade.endRenderFadeTarget(renderer);\n  }\n\n  /* Must be called when a baked fading image (see renderFadingImage) is not needed anymore. */\n  releaseFadingImage(fadeTargetIndex) {\n    this.setClearEnabled(fadeTargetIndex, true);\n  }\n\n  setClearEnabled(targetIndex, enabled) {\n    this.crossFade.setClearEnabled(targetIndex, enabled);\n  }\n\n  /**\n   * Runs a fading-animation on a cross-fading target.\n   *\n   *  @param {number}        targetIndex        - see setModelTargetIndex()\n   *  @param {number}        startOpacity       - in [0,1]\n   *  @param {number}        endOpacity         - in [0,1]\n   *  @param {number}       [duration=5]        - in seconds\n   *  @param {Function}     [onFinished]        - optional callback triggered when animation is finished\n   *  @returns {object}     AnimControl instance\n   *\n   * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#fadeTarget\n   */\n  fadeTarget(targetIndex, startOpacity, endOpacity, duration, onFinished) {\n\n    let setTargetOpacity = (val) => {\n      this.setCrossFadeOpacity(targetIndex, val);\n    };\n    return avp.fadeValue(startOpacity, endOpacity, duration, setTargetOpacity, onFinished);\n  }\n\n  // Performs an image cross-fade between fade-target 0 and 1, assuming that the main scene is not visible.\n  fadeImage(startVal, endVal, duration, onFinished) {\n\n    // Temporarily hide all models during the image fade. They would be overdrawn anyway, so rendering them would just waste time.\n    let mq = this.viewer.impl.modelQueue();\n    let models = mq.getModels().slice(); // We have to copy - otherwise the array would be empty after hiding the models\n    for (let i = 0; i < models.length; i++) {\n      let model = models[i];\n      mq.hideModel(model.id);\n    }\n\n    let onFadeDone = () => {\n\n      // Set fading mode back to the default (independent decal of both targets)\n      this.crossFade.setFadeMode(_TargetCrossFade__WEBPACK_IMPORTED_MODULE_0__.TargetCrossFade.FadeMode.CROSSFADE);\n\n      // Reactivate all temporarily hidden models\n      for (let i = 0; i < models.length; i++) {\n        let model = models[i];\n        mq.showModel(model.id);\n      }\n\n      if (onFinished) {\n        onFinished();\n      }\n    };\n\n    // fade between both targets\n    let setTargetOpacity = (val) => {\n\n      // Fade opacity of cross-fade target 1\n      this.setCrossFadeOpacity(0, 1.0 - val);\n      this.setCrossFadeOpacity(1, val);\n\n      // Viewer3DImpl skips the present step if scene is empty. Therefore, we enforce\n      // present from outside when cross-fading images.\n      let renderer = this.viewer.impl.renderer();\n      renderer.presentBuffer();\n    };\n\n    // For static image fading, we use the cross-fade mode. This ensures that identical pixels between both\n    // images do not vary during transition.\n    this.crossFade.setFadeMode(_TargetCrossFade__WEBPACK_IMPORTED_MODULE_0__.TargetCrossFade.FadeMode.CROSSFADE);\n\n    return avp.fadeValue(startVal, endVal, duration, setTargetOpacity, onFadeDone);\n  }\n\n  /**\n   * Runs a static image fade between the current view and a modified view.\n   * (e.g. with changed model/fragment visiblity, ghosting etc.)\n   * The modified view is specified via function applyState.\n   *\n   *  @param {Function} applyState - applied after rendering the fading start image.\n   *  @param {number} duration - in seconds\n   *\n   * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#fadeToViewerState\n   */\n  fadeToViewerState(applyState, duration) {\n\n    // time-limit in ms that we allow for rendering static images\n    var renderBudget = 300;\n\n    // Render \"before\" state into target 0\n    this.renderFadingImage(0, renderBudget);\n\n    // apply viewer state modification\n    applyState();\n\n    // render image that we fade to\n    this.renderFadingImage(1, renderBudget);\n\n    // remember if SAO was enabled before image fade, because we temporarily disable it, because\n    // AO is already baked into the images that we fade.\n    var rc = this.viewer.impl.renderer();\n    var aoEnabled = rc.getAOEnabled();\n\n    let onFadeDone = () => {\n      // unlock targets again, so that we see the main color target again (instead of the static images)\n      this.releaseFadingImage(0);\n      this.releaseFadingImage(1);\n\n      // recover original AO-enabled state\n      rc.setAOEnabled(aoEnabled);\n    };\n\n    // disable SAO during fading\n    rc.setAOEnabled(false);\n\n    // run image fading\n    this.fadeImage(0.0, 1.0, duration, onFadeDone);\n  }\n}\n\n// Register the extension with the extension manager.\nAutodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, CrossFadeEffects);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL0Nyb3NzRmFkZUVmZmVjdHMvQ3Jvc3NGYWRlRWZmZWN0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRUEsTUFBTUEsZUFBZSxHQUFHLDJCQUEyQjs7QUFFbkQsTUFBTUMsRUFBRSxHQUFHQyxRQUFRLENBQUNDLE9BQU87QUFDM0IsTUFBTUMsR0FBRyxHQUFHSCxFQUFFLENBQUNJLE9BQU87O0FBRThCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLE1BQU1FLGdCQUFnQixTQUFTTixFQUFFLENBQUNPLFNBQVMsQ0FBQztFQUN2REMsV0FBV0EsQ0FBQ0MsTUFBTSxFQUFFQyxPQUFPLEVBQUU7O0lBRXpCLEtBQUssQ0FBQ0QsTUFBTSxFQUFFQyxPQUFPLENBQUM7SUFDdEIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSTs7SUFFckI7SUFDQSxJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJO0lBQ3BCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUk7RUFDL0I7O0VBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxJQUFJQSxDQUFBLEVBQUc7SUFDSCxJQUFJLENBQUNDLG1CQUFtQixDQUFDLElBQUksQ0FBQztJQUM5QixPQUFPLElBQUk7RUFDZjs7RUFFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLE1BQU1BLENBQUEsRUFBRztJQUNMLElBQUksQ0FBQ0QsbUJBQW1CLENBQUMsS0FBSyxDQUFDO0VBQ25DOztFQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUUsY0FBY0EsQ0FBQ0wsUUFBUSxFQUFFQyxlQUFlLEVBQUU7SUFDdEMsSUFBSSxDQUFDRCxRQUFRLEdBQUdBLFFBQVE7SUFDeEIsSUFB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QUNBO0FBQ0E7QUFDQTtFQUNJTSxpQkFBaUJBLENBQUNDLFVBQVUsRUFBRXBCLFFBQVEsRUFBRTs7SUFFcEM7SUFDQSxJQUFJcUIsWUFBWSxHQUFHLEdBQUc7O0lBRXRCO0lBQ0EsSUFBSSxDQUFDdEMsaUJBQWlCLENBQUMsQ0FBQyxFQUFFc0MsWUFBWSxDQUFDOztJQUV2QztJQUNBRCxVQUFVLENBQUMsQ0FBQzs7SUFFWjtJQUNBLElBQUksQ0FBQ3JDLGlCQUFpQixDQUFDLENBQUMsRUFBRXNDLFlBQVksQ0FBQzs7SUFFdkM7SUFDQTtJQUNBLElBQUlDLEVBQUUsR0FBRyxJQUFJLENBQUNoRixNQUFNLENBQUNZLElBQUksQ0FBQ2dCLFFBQVEsQ0FBQyxDQUFDO0lBQ3BDLElBQUlxRCxTQUFTLEdBQUdELEVBQUUsQ0FBQ0UsWUFBWSxDQUFDLENBQUM7O0lBRWpDLElBQUlYLFVBQVUsR0FBR0EsQ0FBQSxLQUFNO01BQ25CO01BQ0EsSUFBSSxDQUFDbkIsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO01BQzFCLElBQUksQ0FBQ0Esa0JBQWtCLENBQUMsQ0FBQyxDQUFDOztNQUUxQjtNQUNBNEIsRUFBRSxDQUFDRyxZQUFZLENBQUNGLFNBQVMsQ0FBQztJQUM5QixDQUFDOztJQUVEO0lBQ0FELEVBQUUsQ0FBQ0csWUFBWSxDQUFDLEtBQUssQ0FBQzs7SUFFdEI7SUFDQSxJQUFJLENBQUNwQixTQUFTLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRUwsUUFBUSxFQUFFYSxVQUFVLENBQUM7RUFDbEQ7QUFDSjs7QUFFQTtBQUNBL0UsUUFBUSxDQUFDQyxPQUFPLENBQUMyRixtQkFBbUIsQ0FBQ0MsaUJBQWlCLENBQUMvRixlQUFlLEVBQUVPLGdCQUFnQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQXV0b2Rlc2suRXh0ZW5zaW9ucy8uL2V4dGVuc2lvbnMvQ3Jvc3NGYWRlRWZmZWN0cy9Dcm9zc0ZhZGVFZmZlY3RzLmpzPzY5YTAiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbmNvbnN0IG15RXh0ZW5zaW9uTmFtZSA9ICdBdXRvZGVzay5Dcm9zc0ZhZGVFZmZlY3RzJztcblxuY29uc3QgYXYgPSBBdXRvZGVzay5WaWV3aW5nO1xuY29uc3QgYXZwID0gYXYuUHJpdmF0ZTtcblxuaW1wb3J0IHsgVGFyZ2V0Q3Jvc3NGYWRlIH0gZnJvbSAnLi9UYXJnZXRDcm9zc0ZhZGUnO1xuXG4vKiogQ3Jvc3NGYWRlRWZmZWN0cyBleHRlbnNpb24gcHJvdmlkZXMgQVBJIGZvciBpbXBsZW1lbnRpbmcgc21vb3RoIGZhZGluZyBlZmZlY3RzIGluIExNViwgZS5nLlxuICogIC0gQ3Jvc3NGYWRpbmcgYmV0d2VlbiBtb2RlbHMgb3IgbW9kZWwgY29uZmlndXJhdGlvbnMgKGUuZy4gY29sb3IgdGhlbWluZywgaGlkaW5nIG9iamVjdHMgZXRjLilcbiAqICAtIEltYWdlLWJhc2VkIFwiZ2hvc3RpbmdcIiBlZmZlY3QsIGkuZS4gc2hvd2luZyBhIHNlbWl0cmFuc3BhcmVudCBzbmFwc2hvdCBvZiBhIG1vZGVsIG9uIHRvcCBvZiBhbm90aGVyIG9uZS5cbiAqXG4gKiBUaGUgZXh0ZW5zaW9uIGlkIGlzOiBgQXV0b2Rlc2suQ3Jvc3NGYWRlRWZmZWN0c2BcbiAqXG4gKiBOb3RlOlxuICogIC0gTm90ZSB0aGF0IENyb3NzRmFkZUVmZmVjdHMgcmVxdWlyZSAyIGV4dHJhIFJlbmRlclRhcmdldHMuIFNvLCB0aGV5IHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIG9wdGlvbmFsIGVmZmVjdHMgdGhhdCBjYW4gYmUgc2tpcHBlZCBvbiB3ZWFrIGRldmljZXMuXG4gKiAgLSBDcm9zc0ZhZGUgZWZmZWN0cyBjYW4gb25seSBiZSB1c2VkIGZvciBvbmUgcHVycG9zZSBhdCBhIHRpbWUuIFdoZW4gdXNpbmcgdGhlbSBmb3IgYSBuZXcgZmVhdHVyZSwgeW91IGhhdmUgdG8gbWFrZSBzdXJlXG4gKiAgICB0aGF0IHRoZXkgZG9uJ3QgY29uZmxpY3Qgd2l0aCBleGlzdGluZyBmZWF0dXJlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogICB2aWV3ZXIubG9hZEV4dGVuc2lvbignQXV0b2Rlc2suQ3Jvc3NGYWRlRWZmZWN0cycpXG4gKlxuICogQG1lbWJlcm9mIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9uc1xuICogQHNlZSB7QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb259IGZvciBjb21tb24gaW5oZXJpdGVkIG1ldGhvZHMuXG4gKiBAYWxpYXMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLkNyb3NzRmFkZUVmZmVjdHNcbiAqIEBjbGFzc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDcm9zc0ZhZGVFZmZlY3RzIGV4dGVuZHMgYXYuRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3ZXIsIG9wdGlvbnMpIHtcblxuICAgICAgICBzdXBlcih2aWV3ZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNyb3NzRmFkZSA9IG51bGw7XG5cbiAgICAgICAgLy8gVXNlZCB0byBoYW5kbGUgY29uZmxpY3RzIGlmIHRoaXMgZXh0ZW5zaW9uIGlzIHVzZWQgZm9yIGRpZmZlcmVudCBwdXJwb3Nlc1xuICAgICAgICB0aGlzLmNsaWVudElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkNsaWVudENoYW5nZWQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgY3Jvc3MgZnJhZGUgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqIEBhbGlhcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuQ3Jvc3NGYWRlRWZmZWN0cyNsb2FkXG4gICAgICovXG4gICAgbG9hZCgpIHtcbiAgICAgICAgdGhpcy5zZXRDcm9zc0ZhZGVFbmFibGVkKHRydWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyBjcm9zcyBmcmFkZSBlZmZlY3RzLlxuICAgICAqXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5Dcm9zc0ZhZGVFZmZlY3RzI3VubG9hZFxuICAgICAqL1xuICAgIHVubG9hZCgpIHtcbiAgICAgICAgdGhpcy5zZXRDcm9zc0ZhZGVFbmFibGVkKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGYWRpbmcgdGFyZ2V0cyBtYXkgYmUgdXNlZCBieSBkaWZmZXJlbnQgY2xpZW50cyBmb3IgZGlmZmVyZW50IHB1cnBvc2VzLiBUaGF0J3Mgb2theSBhcyBsb25nXG4gICAgICogYXMgaXQgZG9lcyBub3QgaGFwcGVuIGNvbmN1cnJlbnRseS5cbiAgICAgKlxuICAgICAqIEluIGNhc2Ugb2YgY29uZmxpY3RzLCB0aGUgbGFzdCBjYWxsZXIgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBzdGFydCBhbiBlZmZlY3QgdXNpbmcgdGhpcyBleHRlbnNpb24sIGFsd2F5cyBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gbm90aWZ5IGNsaWVudFxuICAgICAqIGNvZGUgdGhhdCB3YXMgdXNpbmcgaXQgYmVmb3JlLiBWaWNlIHZlcnNhLCBwcm92aWRlIGFuIG9uQ2xpZW50Q2hhbmdlZCgpIGNhbGxiYWNrIHRvIGhhbmRsZSB0aGUgY2FzZVxuICAgICAqIHRoYXQgc29tZW9uZSBlbHNlIG92ZXJ0YWtlcy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6IElmIHN0YXJ0IGEgZmFkaW5nIGVmZmVjdCB3aGlsZSB0aGUgZ2hvc3QgZmxvb3JzIG9mIHRoZSBMZXZlbHNFeHRlbnNpb24gYXJlIGZhZGluZ1xuICAgICAqIG91dCwgdGhlIExldmVsc0V4dGVuc2lvbiB3aWxsIGJlIG5vdGlmaWVkIHRvIHNraXAgdGhlIGZhZGUtb3V0IGFuaW0gdG8gYXZvaWQgY29uZmxpY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsaWVudElkIC0gU29tZSBpZGVudGlmaWVyIHVuaXF1ZSBmb3IgdGhlIGNvZGUgY29tcG9uZW50IHVzaW5nIHRoZSBlZmZlY3QsIGUuZy4gdGhlIG5hbWUgb2YgYW4gZXh0ZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkNsaWVudENoYW5nZWRdIC0gV2lsbCBiZSBjYWxsZWQgaWYgYW5vdGhlciBjbGllbnQgY2FsbGVkIGFjcXVpcmVDb250cm9sLlxuICAgICAqIEBhbGlhcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuQ3Jvc3NGYWRlRWZmZWN0cyNhY3F1aXJlQ29udHJvbFxuICAgICAqL1xuICAgIGFjcXVpcmVDb250cm9sKGNsaWVudElkLCBvbkNsaWVudENoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICB0aGlzLm9uQ2xpZW50Q2hhbmdlZCAmJiB0aGlzLm9uQ2xpZW50Q2hhbmdlZCgpOyAvLyBsZXQgcHJldmlvdXMgY2xpZW50IGNvZGUgbm93IHRoYXQgd2UgdG9vayBjb250cm9sXG4gICAgICAgIHRoaXMub25DbGllbnRDaGFuZ2VkID0gb25DbGllbnRDaGFuZ2VkOyAgICAgICAgIC8vIGNhbGwgb25DbGllbnRDaGFuZ2VkIGlmIHNvbWVvbmUgZWxzZSBvdmVydGFrZXMgbGF0ZXJcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmx5IGFsbG93ZWQgaWYgbW9kZWxDcm9zc0ZhZGUgaXMgZW5hYmxlZC4gRGV0ZXJtaW5lcyB0byB3aGljaCB0YXJnZXQgYSBSZW5kZXJNb2RlbCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSBtb2RlbElkIC0gVGhlIG1vZGVsIGlkXG4gICAgICogIEBwYXJhbSB7dW5kZWZpbmVkfDB8MX0gdGFyZ2V0SW5kZXggLSBpbmRleCBvZiB0aGUgY3Jvc3NGYWRlIHRhcmdldCBvciB1bmRlZmluZWQgKGRlZmF1bHQpIHRvIHVzZSBkZWZhdWx0IGNvbG9yIGJ1ZmZlclxuICAgICAqXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5Dcm9zc0ZhZGVFZmZlY3RzI3NldE1vZGVsVGFyZ2V0SW5kZXhcbiAgICAgKi9cbiAgICBzZXRNb2RlbFRhcmdldEluZGV4KG1vZGVsSWQsIHRhcmdldEluZGV4KSB7XG4gICAgICAgIHRoaXMuY3Jvc3NGYWRlLnNldE1vZGVsVGFyZ2V0SW5kZXgobW9kZWxJZCwgdGFyZ2V0SW5kZXgpO1xuICAgICAgICB0aGlzLnZpZXdlci5pbXBsLmludmFsaWRhdGUodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25seSBhbGxvd2VkIGlmIG1vZGVsQ3Jvc3NGYWRlIGlzIGVuYWJsZWQuIERldGVybWluZXMgdG8gd2hpY2ggdGFyZ2V0IGEgUmVuZGVyTW9kZWwgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfDB8MX0gaW5kZXggLSBpbmRleCBvZiB0aGUgY3Jvc3NGYWRlIHRhcmdldCBvciB1bmRlZmluZWQgKGRlZmF1bHQpIHRvIHVzZSBkZWZhdWx0IGNvbG9yIGJ1ZmZlclxuICAgICAqIEBhbGlhcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuQ3Jvc3NGYWRlRWZmZWN0cyNzZXRNb2RlbFRhcmdldEluZGV4Rm9yQWxsXG4gICAgICovXG4gICAgc2V0TW9kZWxUYXJnZXRJbmRleEZvckFsbChpbmRleCkge1xuICAgICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLnZpZXdlci5nZXRWaXNpYmxlTW9kZWxzKCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxtb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gbW9kZWxzW2ldO1xuICAgICAgICAgICAgdGhpcy5zZXRNb2RlbFRhcmdldEluZGV4KG1vZGVsLmlkLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmx5IGFsbG93ZWQgaWYgbW9kZWxDcm9zc0ZhZGUgaXMgZW5hYmxlZC4gQXNzaWducyBhIGJsZW5kaW5nIG9wYWNpdHkgdG8gYSBjcm9zcy1mYWRpbmdcbiAgICAgKiBleHRyYSB0YXJnZXQuXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IHRhcmdldEluZGV4IC0gbXVzdCBiZSA+MFxuICAgICAqICBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSAgICAgLSBpbiBbMCwxXVxuICAgICAqXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5Dcm9zc0ZhZGVFZmZlY3RzI3NldENyb3NzRmFkZU9wYWNpdHlcbiAgICAgKi9cbiAgICBzZXRDcm9zc0ZhZGVPcGFjaXR5KHRhcmdldEluZGV4LCBvcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuY3Jvc3NGYWRlLnNldENyb3NzRmFkZU9wYWNpdHkodGFyZ2V0SW5kZXgsIG9wYWNpdHkpO1xuICAgICAgICB0aGlzLnZpZXdlci5pbXBsPy5pbnZhbGlkYXRlKHRydWUpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldEluZGV4IC0gbXVzdCBiZSA+MFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG9wYWNpdHlcbiAgICAgKlxuICAgICAqIEBhbGlhcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuQ3Jvc3NGYWRlRWZmZWN0cyNnZXRDcm9zc0ZhZGVPcGFjaXR5XG4gICAgICovXG4gICAgZ2V0Q3Jvc3NGYWRlT3BhY2l0eSh0YXJnZXRJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcm9zc0ZhZGUuZ2V0Q3Jvc3NGYWRlT3BhY2l0eSh0YXJnZXRJbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlL0Rpc2FibGUgbW9kZWwgY3Jvc3MtZmFkaW5nLiBNdXN0IGJlIGVuYWJsZWQgaW4gb3JkZXIgdG8gcmVuZGVyIG1vZGVscyB0byBkaWZmZXJlbnQgcmVuZGVyIHRhcmdldHNcbiAgICAgKiBmb3IgY3Jvc3MtZmFkaW5nIGVmZmVjdHMgKHNlZSBiZWxvdykuIElmIG5vIGNyb3NzLWZhZGluZyBlZmZlY3RzIGFyZSB1c2VkLCBpdCBzaG91bGQgYmUgZGlzYWJsZWQgdG8gc2F2ZVxuICAgICAqIEdQVSBtZW1vcnkgYW5kIHBlcmZvcm1hbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGUgLSBXaGV0aGVyIHRvIGVuYWJsZSh0cnVlKSBvciBkaXNhYmxlKGZhbHNlKSBjcm9zcyBmYWRlIGVmZmVjdHMuXG4gICAgICpcbiAgICAgKiBAYWxpYXMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLkNyb3NzRmFkZUVmZmVjdHMjc2V0Q3Jvc3NGYWRlRW5hYmxlZFxuICAgICAqL1xuICAgIHNldENyb3NzRmFkZUVuYWJsZWQoZW5hYmxlKSB7XG4gICAgICAgIGlmIChlbmFibGUgPT09IEJvb2xlYW4odGhpcy5jcm9zc0ZhZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVuZGVyZXIgPSB0aGlzLnZpZXdlci5pbXBsLnJlbmRlcmVyKCk7XG4gICAgICAgIGlmIChlbmFibGUpIHtcbiAgICAgICAgICAgIGxldCBibGVuZFBhc3MgPSByZW5kZXJlci5nZXRCbGVuZFBhc3MoKTtcbiAgICAgICAgICAgIHRoaXMuY3Jvc3NGYWRlID0gbmV3IFRhcmdldENyb3NzRmFkZShibGVuZFBhc3MpO1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0Q3Jvc3NGYWRlKHRoaXMuY3Jvc3NGYWRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3Jvc3NGYWRlLmR0b3IoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldENyb3NzRmFkZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRhcmdldHMgaGF2ZSBiZWVuIGNyZWF0ZWQgYWxyZWFkeSwgY2FsbCByZXNpemUgdG8gbWFrZSBzdXJlIHRoYXRcbiAgICAgICAgLy8gICAxLiBjcm9zc0ZhZGUgdGFyZ2V0cyBhcmUgY3JlYXRlZCBhbmQgaGF2ZSBjb3JyZWN0IHNpemUvZm9ybWF0XG4gICAgICAgIC8vICAgMi4gY29sb3JUYXJnZXQvaWRUYXJnZXQgYXJlIHJlYWxsb2NhdGVkIHdpdGggY29ycmVjdCBmb3JtYXRcbiAgICAgICAgLy8gICAgICBOb3RlIHRoYXQgdG9nZ2xpbmcgY3Jvc3NGYWRlIGFmZmVjdHMgY29sb3IvaWQgdGFyZ2V0IGZvcm1hdCBhcyB3ZWxsLCBiZWNhdXNlXG4gICAgICAgIC8vICAgICAgUkdCIGFuZCBSR0JBIHRhcmdldHMgY2Fubm90IGJlIHVzZWQgYXQgb25jZSB3aGVuIHVzaW5nIE1SVC5cbiAgICAgICAgbGV0IGNvbG9yVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0Q29sb3JUYXJnZXQoKTtcbiAgICAgICAgaWYgKGNvbG9yVGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy52aWV3ZXIuaW1wbC5nbHJlbmRlcmVyKCkuZ2V0UGl4ZWxSYXRpbygpOyAvL3NldFNpemUgZXhwZWN0cyB0aGUgc2l6ZSB3aXRob3V0IHBpeGVsUmF0aW9cbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFNpemUoY29sb3JUYXJnZXQud2lkdGggLyBwaXhlbFJhdGlvLCBjb2xvclRhcmdldC5oZWlnaHQgLyBwaXhlbFJhdGlvKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogUmVuZGVycyBhIGZyYW1lIGludG8gYSBmYWRpbmcgdGFyZ2V0LCBzbyB0aGF0IHdlIGNhbiB1c2UgaXQgZm9yIGEgc3RhdGljLWltYWdlIGZhZGUuXG4gICAgICogVGhlIHRhcmdldCB3aWxsIGJlIHByb3RlY3RlZCBmcm9tIGNsZWFuaW5nLCBzbyB0aGF0IGl0IHdpbGwgb3ZlcmRyYXcgdGhlIG1haW4gc2NlbmUuXG4gICAgICogVG8gZ28gYmFjayB0byBub3JtYWwgcmVuZGVyaW5nLCBjYWxsIHJlbGVhc2VGYWRpbmdJbWFnZShmYWRlVGFyZ2V0SW5kZXgpIGFmdGVyd2FyZHMuXG4gICAgICogIEBwYXJhbSB7MHwxfSBmYWRlVGFyZ2V0SW5kZXhcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IFtmcmFtZUJ1ZGdldF0gLSB0aW1lIGJ1ZGdldCBpbiBtcyB0aGF0IGNhbiBiZSB1c2VkIGZvciByZW5kZXJpbmcgdGhpcyBpbWFnZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHJlbGV2YW50IGlmIHByb2dyZXNzaXZlIHJlbmRlcmluZyBpcyBvbi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlIGlzIHRoZSBjdXJyZW50IHRoaXMudGFyZ2V0RnJhbWVCdWRnZXQgc2V0dGluZy5cbiAgICAgKlxuICAgICAqIEBhbGlhcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuQ3Jvc3NGYWRlRWZmZWN0cyNyZW5kZXJGYWRpbmdJbWFnZVxuICAgICAqL1xuICAgIHJlbmRlckZhZGluZ0ltYWdlKGZhZGVUYXJnZXRJbmRleCwgZnJhbWVCdWRnZXQpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGxhc3QgZnJhbWUgd2FzIHJlbmRlcmVkIHRvIG1haW4gdGFyZ2V0LlxuICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCBpbiBjYXNlIHRoZXJlIHdlcmUgY2hhbmdlcyBtYWRlIChsaWtlIGN1dHBsYW5lcyBhcHBsaWVkKSwgYmVmb3JlIHRoZSB2aWV3ZXIgd2FzIGFibGUgdG8gcmVuZGVyIHRoZW0uXG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy52aWV3ZXIuaW1wbC50aWNrKHRpbWVzdGFtcCk7XG5cbiAgICAgICAgLy8gbWFrZSBSZW5kZXJDb250ZXh0IHJlbmRlciBpbnRvIGZhZGVUYXJnZXRcbiAgICAgICAgbGV0IHJlbmRlcmVyID0gdGhpcy52aWV3ZXIuaW1wbC5yZW5kZXJlcigpO1xuICAgICAgICB0aGlzLmNyb3NzRmFkZS5iZWdpblJlbmRlclRvRmFkZVRhcmdldChmYWRlVGFyZ2V0SW5kZXgsIHJlbmRlcmVyKTtcblxuICAgICAgICAvLyBzdGFydCBuZXcgZnJhbWVcbiAgICAgICAgdGhpcy52aWV3ZXIuaW1wbC5pbnZhbGlkYXRlKHRydWUsIHRydWUsIHRydWUpO1xuXG4gICAgICAgIC8vIHRlbXBvcmFyaWx5IG92ZXJsb2FkIHJlbmRlcmluZyBidWRnZXQgKGlmIHdhbnRlZClcbiAgICAgICAgbGV0IG9yaWdpbmFsRnJhbWVCdWRnZXQgPSB0aGlzLnZpZXdlci5pbXBsLnRhcmdldEZyYW1lQnVkZ2V0O1xuICAgICAgICBpZiAoZnJhbWVCdWRnZXQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld2VyLmltcGwudGFyZ2V0RnJhbWVCdWRnZXQgPSBmcmFtZUJ1ZGdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWVzdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLnZpZXdlci5pbXBsLnRpY2sodGltZXN0YW1wKTtcblxuICAgICAgICAvLyByZWNvdmVyIG9yaWdpbmFsIGZyYW1lIGJ1ZGdldFxuICAgICAgICB0aGlzLnRhcmdldEZyYW1lQnVkZ2V0ID0gb3JpZ2luYWxGcmFtZUJ1ZGdldDtcblxuICAgICAgICAvLyBtYWtlIFJlbmRlckNvbnRleHQgcmVuZGVyIHRvIHRoZSBtYWluIHNjZW5lIGNhbnZhcyBhZ2FpblxuICAgICAgICB0aGlzLmNyb3NzRmFkZS5lbmRSZW5kZXJGYWRlVGFyZ2V0KHJlbmRlcmVyKTtcbiAgICB9XG5cbiAgICAvKiBNdXN0IGJlIGNhbGxlZCB3aGVuIGEgYmFrZWQgZmFkaW5nIGltYWdlIChzZWUgcmVuZGVyRmFkaW5nSW1hZ2UpIGlzIG5vdCBuZWVkZWQgYW55bW9yZS4gKi9cbiAgICByZWxlYXNlRmFkaW5nSW1hZ2UoZmFkZVRhcmdldEluZGV4KSB7XG4gICAgICAgIHRoaXMuc2V0Q2xlYXJFbmFibGVkKGZhZGVUYXJnZXRJbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgc2V0Q2xlYXJFbmFibGVkKHRhcmdldEluZGV4LCBlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuY3Jvc3NGYWRlLnNldENsZWFyRW5hYmxlZCh0YXJnZXRJbmRleCwgZW5hYmxlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIGZhZGluZy1hbmltYXRpb24gb24gYSBjcm9zcy1mYWRpbmcgdGFyZ2V0LlxuICAgICAqXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgdGFyZ2V0SW5kZXggICAgICAgIC0gc2VlIHNldE1vZGVsVGFyZ2V0SW5kZXgoKVxuICAgICAqICBAcGFyYW0ge251bWJlcn0gICAgICAgIHN0YXJ0T3BhY2l0eSAgICAgICAtIGluIFswLDFdXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgZW5kT3BhY2l0eSAgICAgICAgIC0gaW4gWzAsMV1cbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9ICAgICAgIFtkdXJhdGlvbj01XSAgICAgICAgLSBpbiBzZWNvbmRzXG4gICAgICogIEBwYXJhbSB7RnVuY3Rpb259ICAgICBbb25GaW5pc2hlZF0gICAgICAgIC0gb3B0aW9uYWwgY2FsbGJhY2sgdHJpZ2dlcmVkIHdoZW4gYW5pbWF0aW9uIGlzIGZpbmlzaGVkXG4gICAgICogIEByZXR1cm5zIHtvYmplY3R9ICAgICBBbmltQ29udHJvbCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5Dcm9zc0ZhZGVFZmZlY3RzI2ZhZGVUYXJnZXRcbiAgICAgKi9cbiAgICBmYWRlVGFyZ2V0KHRhcmdldEluZGV4LCBzdGFydE9wYWNpdHksIGVuZE9wYWNpdHksIGR1cmF0aW9uLCBvbkZpbmlzaGVkKSB7XG5cbiAgICAgICAgbGV0IHNldFRhcmdldE9wYWNpdHkgPSAodmFsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldENyb3NzRmFkZU9wYWNpdHkodGFyZ2V0SW5kZXgsIHZhbCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhdnAuZmFkZVZhbHVlKHN0YXJ0T3BhY2l0eSwgZW5kT3BhY2l0eSwgZHVyYXRpb24sIHNldFRhcmdldE9wYWNpdHksIG9uRmluaXNoZWQpO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm1zIGFuIGltYWdlIGNyb3NzLWZhZGUgYmV0d2VlbiBmYWRlLXRhcmdldCAwIGFuZCAxLCBhc3N1bWluZyB0aGF0IHRoZSBtYWluIHNjZW5lIGlzIG5vdCB2aXNpYmxlLlxuICAgIGZhZGVJbWFnZShzdGFydFZhbCwgZW5kVmFsLCBkdXJhdGlvbiwgb25GaW5pc2hlZCkge1xuXG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IGhpZGUgYWxsIG1vZGVscyBkdXJpbmcgdGhlIGltYWdlIGZhZGUuIFRoZXkgd291bGQgYmUgb3ZlcmRyYXduIGFueXdheSwgc28gcmVuZGVyaW5nIHRoZW0gd291bGQganVzdCB3YXN0ZSB0aW1lLlxuICAgICAgICBsZXQgbXEgPSB0aGlzLnZpZXdlci5pbXBsLm1vZGVsUXVldWUoKTtcbiAgICAgICAgbGV0IG1vZGVscyA9IG1xLmdldE1vZGVscygpLnNsaWNlKCk7IC8vIFdlIGhhdmUgdG8gY29weSAtIG90aGVyd2lzZSB0aGUgYXJyYXkgd291bGQgYmUgZW1wdHkgYWZ0ZXIgaGlkaW5nIHRoZSBtb2RlbHNcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1vZGVsID0gbW9kZWxzW2ldO1xuICAgICAgICAgICAgbXEuaGlkZU1vZGVsKG1vZGVsLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvbkZhZGVEb25lID0gKCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBTZXQgZmFkaW5nIG1vZGUgYmFjayB0byB0aGUgZGVmYXVsdCAoaW5kZXBlbmRlbnQgZGVjYWwgb2YgYm90aCB0YXJnZXRzKVxuICAgICAgICAgICAgdGhpcy5jcm9zc0ZhZGUuc2V0RmFkZU1vZGUoVGFyZ2V0Q3Jvc3NGYWRlLkZhZGVNb2RlLkNST1NTRkFERSk7XG5cbiAgICAgICAgICAgIC8vIFJlYWN0aXZhdGUgYWxsIHRlbXBvcmFyaWx5IGhpZGRlbiBtb2RlbHNcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxtb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbW9kZWwgPSBtb2RlbHNbaV07XG4gICAgICAgICAgICAgICAgbXEuc2hvd01vZGVsKG1vZGVsLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9uRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBvbkZpbmlzaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZmFkZSBiZXR3ZWVuIGJvdGggdGFyZ2V0c1xuICAgICAgICBsZXQgc2V0VGFyZ2V0T3BhY2l0eSA9ICh2YWwpID0+IHtcblxuICAgICAgICAgICAgLy8gRmFkZSBvcGFjaXR5IG9mIGNyb3NzLWZhZGUgdGFyZ2V0IDFcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Jvc3NGYWRlT3BhY2l0eSgwLCAxLjAgLSB2YWwpO1xuICAgICAgICAgICAgdGhpcy5zZXRDcm9zc0ZhZGVPcGFjaXR5KDEsIHZhbCk7XG5cbiAgICAgICAgICAgIC8vIFZpZXdlcjNESW1wbCBza2lwcyB0aGUgcHJlc2VudCBzdGVwIGlmIHNjZW5lIGlzIGVtcHR5LiBUaGVyZWZvcmUsIHdlIGVuZm9yY2VcbiAgICAgICAgICAgIC8vIHByZXNlbnQgZnJvbSBvdXRzaWRlIHdoZW4gY3Jvc3MtZmFkaW5nIGltYWdlcy5cbiAgICAgICAgICAgIGxldCByZW5kZXJlciA9IHRoaXMudmlld2VyLmltcGwucmVuZGVyZXIoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnByZXNlbnRCdWZmZXIoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGb3Igc3RhdGljIGltYWdlIGZhZGluZywgd2UgdXNlIHRoZSBjcm9zcy1mYWRlIG1vZGUuIFRoaXMgZW5zdXJlcyB0aGF0IGlkZW50aWNhbCBwaXhlbHMgYmV0d2VlbiBib3RoXG4gICAgICAgIC8vIGltYWdlcyBkbyBub3QgdmFyeSBkdXJpbmcgdHJhbnNpdGlvbi5cbiAgICAgICAgdGhpcy5jcm9zc0ZhZGUuc2V0RmFkZU1vZGUoVGFyZ2V0Q3Jvc3NGYWRlLkZhZGVNb2RlLkNST1NTRkFERSk7XG5cbiAgICAgICAgcmV0dXJuIGF2cC5mYWRlVmFsdWUoc3RhcnRWYWwsIGVuZFZhbCwgZHVyYXRpb24sIHNldFRhcmdldE9wYWNpdHksIG9uRmFkZURvbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBzdGF0aWMgaW1hZ2UgZmFkZSBiZXR3ZWVuIHRoZSBjdXJyZW50IHZpZXcgYW5kIGEgbW9kaWZpZWQgdmlldy5cbiAgICAgKiAoZS5nLiB3aXRoIGNoYW5nZWQgbW9kZWwvZnJhZ21lbnQgdmlzaWJsaXR5LCBnaG9zdGluZyBldGMuKVxuICAgICAqIFRoZSBtb2RpZmllZCB2aWV3IGlzIHNwZWNpZmllZCB2aWEgZnVuY3Rpb24gYXBwbHlTdGF0ZS5cbiAgICAgKlxuICAgICAqICBAcGFyYW0ge0Z1bmN0aW9ufSBhcHBseVN0YXRlIC0gYXBwbGllZCBhZnRlciByZW5kZXJpbmcgdGhlIGZhZGluZyBzdGFydCBpbWFnZS5cbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIC0gaW4gc2Vjb25kc1xuICAgICAqXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5Dcm9zc0ZhZGVFZmZlY3RzI2ZhZGVUb1ZpZXdlclN0YXRlXG4gICAgICovXG4gICAgZmFkZVRvVmlld2VyU3RhdGUoYXBwbHlTdGF0ZSwgZHVyYXRpb24pIHtcblxuICAgICAgICAvLyB0aW1lLWxpbWl0IGluIG1zIHRoYXQgd2UgYWxsb3cgZm9yIHJlbmRlcmluZyBzdGF0aWMgaW1hZ2VzXG4gICAgICAgIHZhciByZW5kZXJCdWRnZXQgPSAzMDA7XG5cbiAgICAgICAgLy8gUmVuZGVyIFwiYmVmb3JlXCIgc3RhdGUgaW50byB0YXJnZXQgMFxuICAgICAgICB0aGlzLnJlbmRlckZhZGluZ0ltYWdlKDAsIHJlbmRlckJ1ZGdldCk7XG5cbiAgICAgICAgLy8gYXBwbHkgdmlld2VyIHN0YXRlIG1vZGlmaWNhdGlvblxuICAgICAgICBhcHBseVN0YXRlKCk7XG5cbiAgICAgICAgLy8gcmVuZGVyIGltYWdlIHRoYXQgd2UgZmFkZSB0b1xuICAgICAgICB0aGlzLnJlbmRlckZhZGluZ0ltYWdlKDEsIHJlbmRlckJ1ZGdldCk7XG5cbiAgICAgICAgLy8gcmVtZW1iZXIgaWYgU0FPIHdhcyBlbmFibGVkIGJlZm9yZSBpbWFnZSBmYWRlLCBiZWNhdXNlIHdlIHRlbXBvcmFyaWx5IGRpc2FibGUgaXQsIGJlY2F1c2VcbiAgICAgICAgLy8gQU8gaXMgYWxyZWFkeSBiYWtlZCBpbnRvIHRoZSBpbWFnZXMgdGhhdCB3ZSBmYWRlLlxuICAgICAgICB2YXIgcmMgPSB0aGlzLnZpZXdlci5pbXBsLnJlbmRlcmVyKCk7XG4gICAgICAgIHZhciBhb0VuYWJsZWQgPSByYy5nZXRBT0VuYWJsZWQoKTtcblxuICAgICAgICBsZXQgb25GYWRlRG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHVubG9jayB0YXJnZXRzIGFnYWluLCBzbyB0aGF0IHdlIHNlZSB0aGUgbWFpbiBjb2xvciB0YXJnZXQgYWdhaW4gKGluc3RlYWQgb2YgdGhlIHN0YXRpYyBpbWFnZXMpXG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VGYWRpbmdJbWFnZSgwKTtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZUZhZGluZ0ltYWdlKDEpO1xuXG4gICAgICAgICAgICAvLyByZWNvdmVyIG9yaWdpbmFsIEFPLWVuYWJsZWQgc3RhdGVcbiAgICAgICAgICAgIHJjLnNldEFPRW5hYmxlZChhb0VuYWJsZWQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRpc2FibGUgU0FPIGR1cmluZyBmYWRpbmdcbiAgICAgICAgcmMuc2V0QU9FbmFibGVkKGZhbHNlKTtcblxuICAgICAgICAvLyBydW4gaW1hZ2UgZmFkaW5nXG4gICAgICAgIHRoaXMuZmFkZUltYWdlKDAuMCwgMS4wLCBkdXJhdGlvbiwgb25GYWRlRG9uZSk7XG4gICAgfVxufVxuXG4vLyBSZWdpc3RlciB0aGUgZXh0ZW5zaW9uIHdpdGggdGhlIGV4dGVuc2lvbiBtYW5hZ2VyLlxuQXV0b2Rlc2suVmlld2luZy50aGVFeHRlbnNpb25NYW5hZ2VyLnJlZ2lzdGVyRXh0ZW5zaW9uKG15RXh0ZW5zaW9uTmFtZSwgQ3Jvc3NGYWRlRWZmZWN0cyk7XG4iXSwibmFtZXMiOlsibXlFeHRlbnNpb25OYW1lIiwiYXYiLCJBdXRvZGVzayIsIlZpZXdpbmciLCJhdnAiLCJQcml2YXRlIiwiVGFyZ2V0Q3Jvc3NGYWRlIiwiQ3Jvc3NGYWRlRWZmZWN0cyIsIkV4dGVuc2lvbiIsImNvbnN0cnVjdG9yIiwidmlld2VyIiwib3B0aW9ucyIsImNyb3NzRmFkZSIsImNsaWVudElkIiwib25DbGllbnRDaGFuZ2VkIiwibG9hZCIsInNldENyb3NzRmFkZUVuYWJsZWQiLCJ1bmxvYWQiLCJhY3F1aXJlQ29udHJvbCIsInNldE1vZGVsVGFyZ2V0SW5kZXgiLCJtb2RlbElkIiwidGFyZ2V0SW5kZXgiLCJpbXBsIiwiaW52YWxpZGF0ZSIsInNldE1vZGVsVGFyZ2V0SW5kZXhGb3JBbGwiLCJpbmRleCIsIm1vZGVscyIsImdldFZpc2libGVNb2RlbHMiLCJpIiwibGVuZ3RoIiwibW9kZWwiLCJpZCIsInNldENyb3NzRmFkZU9wYWNpdHkiLCJvcGFjaXR5IiwiX3RoaXMkdmlld2VyJGltcGwiLCJnZXRDcm9zc0ZhZGVPcGFjaXR5IiwiZW5hYmxlIiwiQm9vbGVhbiIsInJlbmRlcmVyIiwiYmxlbmRQYXNzIiwiZ2V0QmxlbmRQYXNzIiwic2V0Q3Jvc3NGYWRlIiwiZHRvciIsImNvbG9yVGFyZ2V0IiwiZ2V0Q29sb3JUYXJnZXQiLCJwaXhlbFJhdGlvIiwiZ2xyZW5kZXJlciIsImdldFBpeGVsUmF0aW8iLCJzZXRTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJyZW5kZXJGYWRpbmdJbWFnZSIsImZhZGVUYXJnZXRJbmRleCIsImZyYW1lQnVkZ2V0IiwidGltZXN0YW1wIiwicGVyZm9ybWFuY2UiLCJub3ciLCJ0aWNrIiwiYmVnaW5SZW5kZXJUb0ZhZGVUYXJnZXQiLCJvcmlnaW5hbEZyYW1lQnVkZ2V0IiwidGFyZ2V0RnJhbWVCdWRnZXQiLCJlbmRSZW5kZXJGYWRlVGFyZ2V0IiwicmVsZWFzZUZhZGluZ0ltYWdlIiwic2V0Q2xlYXJFbmFibGVkIiwiZW5hYmxlZCIsImZhZGVUYXJnZXQiLCJzdGFydE9wYWNpdHkiLCJlbmRPcGFjaXR5IiwiZHVyYXRpb24iLCJvbkZpbmlzaGVkIiwic2V0VGFyZ2V0T3BhY2l0eSIsInZhbCIsImZhZGVWYWx1ZSIsImZhZGVJbWFnZSIsInN0YXJ0VmFsIiwiZW5kVmFsIiwibXEiLCJtb2RlbFF1ZXVlIiwiZ2V0TW9kZWxzIiwic2xpY2UiLCJoaWRlTW9kZWwiLCJvbkZhZGVEb25lIiwic2V0RmFkZU1vZGUiLCJGYWRlTW9kZSIsIkNST1NTRkFERSIsInNob3dNb2RlbCIsInByZXNlbnRCdWZmZXIiLCJmYWRlVG9WaWV3ZXJTdGF0ZSIsImFwcGx5U3RhdGUiLCJyZW5kZXJCdWRnZXQiLCJyYyIsImFvRW5hYmxlZCIsImdldEFPRW5hYmxlZCIsInNldEFPRW5hYmxlZCIsInRoZUV4dGVuc2lvbk1hbmFnZXIiLCJyZWdpc3RlckV4dGVuc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./extensions/CrossFadeEffects/CrossFadeEffects.js\n");

/***/ }),

/***/ "./extensions/CrossFadeEffects/TargetCrossFade.js":
/*!********************************************************!*\
  !*** ./extensions/CrossFadeEffects/TargetCrossFade.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FadeMode: () => (/* binding */ FadeMode),\n/* harmony export */   TargetCrossFade: () => (/* binding */ TargetCrossFade)\n/* harmony export */ });\n\n// Controls the way in which fading targets are applied in the blend shader\nconst FadeMode = {\n  // Just blend each target independently on top of main color target (default)\n  DECAL: 0,\n\n  // Crossfades between target 0 and 1 using crossFadeOpacity1 as mix param.\n  // crossFadeOpacity0 is not used in this mode. Advantage is that colors keep\n  // more consistent when fading between two images.\n  CROSSFADE: 1\n};\n\n\n/**\n * @class TargetCrossFade is used by RenderContext to implement optional cross-fading\n * between different render targets. By default (no cross-fading), all scenes are rendered\n * to the default color buffer by RenderContext. When using targetCrossFade, a scene may\n * be rendered to a separate target, which is blended with the default color target in the blend pass.\n *  @param {LmvShaderPass} blendPass      - see RenderContext\n */\nfunction TargetCrossFade(blendPass) {\n\n  // {THREE.WebGLRenderTarget} of type RGBA with own depth buffer. Selected scenes are rendered into this target\n  // and overlayed on top of the main scene.\n  var _fadeTargets = [];\n  var _numFadeTargets = 2;\n  var _enableClear = [true, true]; // Clear may be disabled when fading to static images\n\n  var _blendPass = blendPass;\n\n  var _clearColor = new THREE.Color();\n\n  // {number[]} Indexed by modelId. Defines the index of the Render target to which a RenderModel is rendered.\n  //           0/undefined: default color buffer, 1:\n  var _modelId2TargetIndex = [];\n\n  var _fadeMode = FadeMode.DECAL;\n\n  // see setSaoHeuristicEnabled() comment\n  var _enableSaoHeuristic = true;\n\n  this.setModelTargetIndex = function (modelId, targetIndex) {\n    _modelId2TargetIndex[modelId] = targetIndex;\n  };\n\n  // By default (true), we exclude models from depth buffer rendering (used for SAO) if they have reduced opacity.\n  // Disabling it makes sure that models are always rendered to the depth target - no matter which opacity they have.\n  this.setSaoHeuristicEnabled = function (enabled) {\n    _enableSaoHeuristic = enabled;\n  };\n\n  //which model is used for AO (i.e. which one is more opaque)\n  this.getRenderSao = function (scene) {\n\n    if (!_enableSaoHeuristic) {\n      // Never suppress depth-writing - independent of target opacity.\n      return true;\n    }\n\n    var index = scene.modelId && _modelId2TargetIndex[scene.modelId];\n\n    if (index === undefined)\n    return true;\n\n    var idx = index;\n    var maxOpacity = this.getCrossFadeOpacity(index);\n\n    var numTargets = 2;\n    for (var i = 0; i < numTargets; i++) {\n      var op = this.getCrossFadeOpacity(i);\n      if (op > maxOpacity) {\n        idx = i;\n        maxOpacity = op;\n      }\n    }\n\n    return idx == index;\n  };\n\n  this.setCrossFadeOpacity = function (targetIndex, opacity) {\n    var uniformName = 'crossFadeOpacity' + targetIndex;\n    _blendPass.uniforms[uniformName].value = opacity;\n  };\n\n  this.getCrossFadeOpacity = function (targetIndex) {\n    var uniformName = 'crossFadeOpacity' + targetIndex;\n    return _blendPass.uniforms[uniformName].value;\n  };\n\n  // Activate target-blending for blendPass and assigns current _blendTarget as source\n  this.updateBlendPass = function (numFadeTargets) {\n\n    if (numFadeTargets === undefined) {\n      numFadeTargets = _fadeTargets.length;\n    }\n\n    // Update NUM_CROSSFADE_TARGETS shader-define if necessary\n    var macroName = 'NUM_CROSSFADE_TARGETS';\n    var oldMacroVal = _blendPass.material.defines[macroName];\n    var newMacroVal = numFadeTargets ? numFadeTargets : undefined;\n    if (oldMacroVal !== newMacroVal) {\n\n      if (numFadeTargets) {\n        _blendPass.material.defines[macroName] = newMacroVal;\n      } else {\n        // remove define from blend pass. Note that setting to 'undefined' would not work here,\n        // because the macro would still exist and would have the text value 'undefined'\n        delete _blendPass.material.defines[macroName];\n      }\n      _blendPass.material.needsUpdate = true;\n    }\n\n    for (var i = 0; i < numFadeTargets; i++) {\n      var uniformName = 'tCrossFadeTex' + i;\n      _blendPass.uniforms[uniformName].value = _fadeTargets[i];\n    }\n\n    // Update fade-mode macro\n    var modeMacroName = 'TARGET_FADE_MODE';\n    var prevMode = _blendPass.material.defines[modeMacroName];\n    if (prevMode !== _fadeMode) {\n      _blendPass.material.defines[modeMacroName] = _fadeMode;\n      _blendPass.material.needsUpdate = true;\n    }\n  };\n\n  /* @param {number} mode - See FadeMode enum above. */\n  this.setFadeMode = function (mode) {\n    if (mode !== FadeMode.DECAL && mode !== FadeMode.CROSSFADE) {\n      // A wrong value causes a shader compile error - so it's better to check here.\n      console.error(\"Unexpected fade mode enum\");\n      return;\n    }\n    _fadeMode = mode;\n    this.updateBlendPass();\n  };\n\n  /** Clear with opacity 0.0 */\n  this.clearTarget = function (renderer) {\n    // clear RGBA blend target with black + opacity 0.0 and default clearDepth\n    // Note that the blend target needs an own z-buffer.\n    renderer.setClearColor(_clearColor, 0.0);\n\n    for (var i = 0; i < _fadeTargets.length; i++) {\n      if (_enableClear[i]) {\n        renderer.setRenderTarget(_fadeTargets[i]);\n        renderer.clear(true, true, false);\n      }\n    }\n  };\n\n  // Clear can be temporarily disabled when using targets for static image fading.\n  this.setClearEnabled = function (targetIndex, enabled) {\n    _enableClear[targetIndex] = enabled;\n  };\n\n  this.disposeTargets = function () {\n    for (var i = 0; i < _fadeTargets.length; i++) {\n      var target = _fadeTargets[i];\n      if (target) {\n        target.dispose();\n      }\n      _fadeTargets[i] = null;\n    }\n  };\n\n  this.dtor = function () {\n    this.disposeTargets();\n    this.updateBlendPass();\n\n    this.setCrossFadeOpacity(0, 0);\n    this.setCrossFadeOpacity(1, 0);\n  };\n\n  /* Determines to which color target a scene will be rendered.\n   *  @param {THREE.Scene|RenderBatch} scene         - scene to be rendered\n   *  @param {THREE.WebGLRenderTarget} defaultTarget - color target that RenderContext would use by default\n   */\n  this.chooseColorTarget = function (scene, defaultTarget) {\n\n    // Check if scene is associated with a render model that is assigned to a cross-fade target\n    var index = scene.modelId && _modelId2TargetIndex[scene.modelId];\n\n    // use default target if nothing else is assigned\n    if (index === undefined) {\n      return defaultTarget;\n    }\n\n    // use cross-fade target\n    return _fadeTargets[index];\n  };\n\n  /* Called by RenderContext if target sizes or formats may change. Makes sure that\n   * the blendTarget exists and has matching size.\n   *  @param {number} width          - render target width\n   *  @param {number} height         - ...\n   *  @param {bool}   [useHdrTarget] - if true, we use a float-type target\n   *  @param {bool}   [force]        - force reallocate, even if width/height keep the same\n   */\n  this.updateTargets = function (width, height, force, useHdrTarget) {\n\n    for (var i = 0; i < _numFadeTargets; i++) {\n\n      var target = _fadeTargets[i];\n\n      // skip if no update is needed\n      if (!force && target && target.width === width && target.height === height) {\n        continue;\n      }\n\n      // dispose any old target\n      if (target) {\n        target.dispose();\n      }\n\n      target = new THREE.WebGLRenderTarget(width, height,\n      { minFilter: THREE.LinearFilter,\n        magFilter: THREE.LinearFilter,\n        format: THREE.RGBAFormat,\n        type: useHdrTarget ? THREE.FloatType : THREE.UnsignedByteType,\n        //anisotropy: Math.min(this.getMaxAnisotropy(), 4),\n        stencilBuffer: false\n      });\n      // three.js has a flaw in its constructor: the generateMipmaps value is always initialized to true\n      target.texture.generateMipmaps = false;\n\n      _fadeTargets[i] = target;\n    }\n  };\n\n  /**\n   * Starts offscreen rendering into one of the cross-fade targets.\n   * Frames rendered between beginRenderFadeImage(i) and endRenderFadeImage() are rendered into a fading target\n   * instead of the canvas. In this way, static images can be pre-rendered and faded.\n   *  @param {number}        fadeTargetIndex - must be 0 or 1.\n   *  @param {RenderContext} renderContext\n   */\n  this.beginRenderToFadeTarget = function (fadeTargetIndex, renderContext) {\n\n    // Make sure that blend pass does not use the fadingTargets for reading while we are writing to one of them\n    this.updateBlendPass(0);\n\n    // make presentBuffer calls write into _offscreenTarget\n    var target = _fadeTargets[fadeTargetIndex];\n    renderContext.setOffscreenTarget(target);\n\n    // protect fade-target from clear, so that the image will not be overwritten in subsequent frames\n    this.setClearEnabled(fadeTargetIndex, false);\n  };\n\n  /**\n   * Finish offscreen rendering into fading target. The rendered result is now overlayed on top of\n   * the normal rendering result.\n   *\n   * @param {RenderContext} renderContext\n   */\n  this.endRenderFadeTarget = function (renderContext) {\n\n    // render to canvas again\n    renderContext.setOffscreenTarget(null);\n\n    // make blend pass use fade targets again\n    this.updateBlendPass();\n  };\n}\n\n// expose enum\nTargetCrossFade.FadeMode = FadeMode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL0Nyb3NzRmFkZUVmZmVjdHMvVGFyZ2V0Q3Jvc3NGYWRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUNBO0FBQ08sTUFBTUEsUUFBUSxHQUFHO0VBQ3BCO0VBQ0FDLEtBQUssRUFBRSxDQUFDOztFQUVSO0VBQ0E7RUFDQTtFQUNBQyxTQUFTLEVBQUU7QUFDZixDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNDLGVBQWVBLENBQUNDLFNBQVMsRUFBRTs7RUFFdkM7RUFDQTtFQUNBLElBQUlDLFlBQVksR0FBTSxFQUFFO0VBQ3hCLElBQUlDLGVBQWUsR0FBRyxDQUFDO0VBQ3ZCLElBQUlDLFlBQVksR0FBTSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDOztFQUVwQyxJQUFJQyxVQUFVLEdBQUdKLFNBQVM7O0VBRTFCLElBQUlLLFdBQVcsR0FBRyxJQUFJQyxLQUFLLENBQUNDLEtBQUssQ0FBQyxDQUFDOztFQUVuQztFQUNBO0VBQ0EsSUFBSUMsb0JBQW9CLEdBQUcsRUFBRTs7RUFFN0IsSUFBSUMsU0FBUyxHQUFHYixRQUFRLENBQUNDLEtBQUs7O0VBRTlCO0VBQ0EsSUFBSWEsbUJBQW1CLEdBQUcsSUFBSTs7RUFFOUIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRyxVQUFTQyxPQUFPLEVBQUVDLFdBQVcsRUFBRTtJQUN0REwsb0JBQW9CLENBQUNJLE9BQU8sQ0FBQyxHQUFHQyxXQUFXO0VBQy9DLENBQUM7O0VBRUQ7RUFDQTtFQUNBLElBQUksQ0FBQ0Msc0JBQXNCLEdBQUcsVUFBU0MsT0FBTyxFQUFFO0lBQzVDTCxtQkFBbUIsR0FBR0ssT0FBTztFQUNqQyxDQUFDOztFQUVEO0VBQ0EsSUFBSSxDQUFDQyxZQUFZLEdBQUcsVUFBU0MsS0FBSyxFQUFFOztJQUVoQyxJQUFJLENBQUNQLG1CQUFtQixFQUFFO01BQ3RCO01BQ0EsT0FBTyxJQUFJO0lBQ2Y7O0lBRUEsSUFBSVEsS0FBSyxHQUFH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L0M7SUFDQUEsYUFBYSxDQUFDQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUM7O0lBRXRDO0lBQ0EsSUFBSSxDQUFDL0MsZUFBZSxDQUFDLENBQUM7RUFDMUIsQ0FBQztBQUNMOztBQUVBO0FBQ0FoQyxlQUFlLENBQUNILFFBQVEsR0FBR0EsUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL0F1dG9kZXNrLkV4dGVuc2lvbnMvLi9leHRlbnNpb25zL0Nyb3NzRmFkZUVmZmVjdHMvVGFyZ2V0Q3Jvc3NGYWRlLmpzPzQ4NGEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBDb250cm9scyB0aGUgd2F5IGluIHdoaWNoIGZhZGluZyB0YXJnZXRzIGFyZSBhcHBsaWVkIGluIHRoZSBibGVuZCBzaGFkZXJcbmV4cG9ydCBjb25zdCBGYWRlTW9kZSA9IHtcbiAgICAvLyBKdXN0IGJsZW5kIGVhY2ggdGFyZ2V0IGluZGVwZW5kZW50bHkgb24gdG9wIG9mIG1haW4gY29sb3IgdGFyZ2V0IChkZWZhdWx0KVxuICAgIERFQ0FMOiAwLFxuXG4gICAgLy8gQ3Jvc3NmYWRlcyBiZXR3ZWVuIHRhcmdldCAwIGFuZCAxIHVzaW5nIGNyb3NzRmFkZU9wYWNpdHkxIGFzIG1peCBwYXJhbS5cbiAgICAvLyBjcm9zc0ZhZGVPcGFjaXR5MCBpcyBub3QgdXNlZCBpbiB0aGlzIG1vZGUuIEFkdmFudGFnZSBpcyB0aGF0IGNvbG9ycyBrZWVwXG4gICAgLy8gbW9yZSBjb25zaXN0ZW50IHdoZW4gZmFkaW5nIGJldHdlZW4gdHdvIGltYWdlcy5cbiAgICBDUk9TU0ZBREU6IDFcbn07XG5cblxuLyoqXG4gKiBAY2xhc3MgVGFyZ2V0Q3Jvc3NGYWRlIGlzIHVzZWQgYnkgUmVuZGVyQ29udGV4dCB0byBpbXBsZW1lbnQgb3B0aW9uYWwgY3Jvc3MtZmFkaW5nXG4gKiBiZXR3ZWVuIGRpZmZlcmVudCByZW5kZXIgdGFyZ2V0cy4gQnkgZGVmYXVsdCAobm8gY3Jvc3MtZmFkaW5nKSwgYWxsIHNjZW5lcyBhcmUgcmVuZGVyZWRcbiAqIHRvIHRoZSBkZWZhdWx0IGNvbG9yIGJ1ZmZlciBieSBSZW5kZXJDb250ZXh0LiBXaGVuIHVzaW5nIHRhcmdldENyb3NzRmFkZSwgYSBzY2VuZSBtYXlcbiAqIGJlIHJlbmRlcmVkIHRvIGEgc2VwYXJhdGUgdGFyZ2V0LCB3aGljaCBpcyBibGVuZGVkIHdpdGggdGhlIGRlZmF1bHQgY29sb3IgdGFyZ2V0IGluIHRoZSBibGVuZCBwYXNzLlxuICogIEBwYXJhbSB7TG12U2hhZGVyUGFzc30gYmxlbmRQYXNzICAgICAgLSBzZWUgUmVuZGVyQ29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gVGFyZ2V0Q3Jvc3NGYWRlKGJsZW5kUGFzcykge1xuXG4gICAgLy8ge1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0fSBvZiB0eXBlIFJHQkEgd2l0aCBvd24gZGVwdGggYnVmZmVyLiBTZWxlY3RlZCBzY2VuZXMgYXJlIHJlbmRlcmVkIGludG8gdGhpcyB0YXJnZXRcbiAgICAvLyBhbmQgb3ZlcmxheWVkIG9uIHRvcCBvZiB0aGUgbWFpbiBzY2VuZS5cbiAgICB2YXIgX2ZhZGVUYXJnZXRzICAgID0gW107XG4gICAgdmFyIF9udW1GYWRlVGFyZ2V0cyA9IDI7XG4gICAgdmFyIF9lbmFibGVDbGVhciAgICA9IFt0cnVlLCB0cnVlXTsgLy8gQ2xlYXIgbWF5IGJlIGRpc2FibGVkIHdoZW4gZmFkaW5nIHRvIHN0YXRpYyBpbWFnZXNcblxuICAgIHZhciBfYmxlbmRQYXNzID0gYmxlbmRQYXNzO1xuXG4gICAgdmFyIF9jbGVhckNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCk7XG5cbiAgICAvLyB7bnVtYmVyW119IEluZGV4ZWQgYnkgbW9kZWxJZC4gRGVmaW5lcyB0aGUgaW5kZXggb2YgdGhlIFJlbmRlciB0YXJnZXQgdG8gd2hpY2ggYSBSZW5kZXJNb2RlbCBpcyByZW5kZXJlZC5cbiAgICAvLyAgICAgICAgICAgMC91bmRlZmluZWQ6IGRlZmF1bHQgY29sb3IgYnVmZmVyLCAxOlxuICAgIHZhciBfbW9kZWxJZDJUYXJnZXRJbmRleCA9IFtdO1xuXG4gICAgdmFyIF9mYWRlTW9kZSA9IEZhZGVNb2RlLkRFQ0FMO1xuXG4gICAgLy8gc2VlIHNldFNhb0hldXJpc3RpY0VuYWJsZWQoKSBjb21tZW50XG4gICAgdmFyIF9lbmFibGVTYW9IZXVyaXN0aWMgPSB0cnVlO1xuXG4gICAgdGhpcy5zZXRNb2RlbFRhcmdldEluZGV4ID0gZnVuY3Rpb24obW9kZWxJZCwgdGFyZ2V0SW5kZXgpIHtcbiAgICAgICAgX21vZGVsSWQyVGFyZ2V0SW5kZXhbbW9kZWxJZF0gPSB0YXJnZXRJbmRleDtcbiAgICB9O1xuXG4gICAgLy8gQnkgZGVmYXVsdCAodHJ1ZSksIHdlIGV4Y2x1ZGUgbW9kZWxzIGZyb20gZGVwdGggYnVmZmVyIHJlbmRlcmluZyAodXNlZCBmb3IgU0FPKSBpZiB0aGV5IGhhdmUgcmVkdWNlZCBvcGFjaXR5LlxuICAgIC8vIERpc2FibGluZyBpdCBtYWtlcyBzdXJlIHRoYXQgbW9kZWxzIGFyZSBhbHdheXMgcmVuZGVyZWQgdG8gdGhlIGRlcHRoIHRhcmdldCAtIG5vIG1hdHRlciB3aGljaCBvcGFjaXR5IHRoZXkgaGF2ZS5cbiAgICB0aGlzLnNldFNhb0hldXJpc3RpY0VuYWJsZWQgPSBmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgIF9lbmFibGVTYW9IZXVyaXN0aWMgPSBlbmFibGVkO1xuICAgIH07XG5cbiAgICAvL3doaWNoIG1vZGVsIGlzIHVzZWQgZm9yIEFPIChpLmUuIHdoaWNoIG9uZSBpcyBtb3JlIG9wYXF1ZSlcbiAgICB0aGlzLmdldFJlbmRlclNhbyA9IGZ1bmN0aW9uKHNjZW5lKSB7XG5cbiAgICAgICAgaWYgKCFfZW5hYmxlU2FvSGV1cmlzdGljKSB7XG4gICAgICAgICAgICAvLyBOZXZlciBzdXBwcmVzcyBkZXB0aC13cml0aW5nIC0gaW5kZXBlbmRlbnQgb2YgdGFyZ2V0IG9wYWNpdHkuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHNjZW5lLm1vZGVsSWQgJiYgX21vZGVsSWQyVGFyZ2V0SW5kZXhbc2NlbmUubW9kZWxJZF07XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB2YXIgaWR4ID0gaW5kZXg7XG4gICAgICAgIHZhciBtYXhPcGFjaXR5ID0gdGhpcy5nZXRDcm9zc0ZhZGVPcGFjaXR5KGluZGV4KTtcblxuICAgICAgICB2YXIgbnVtVGFyZ2V0cyA9IDI7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxudW1UYXJnZXRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvcCA9IHRoaXMuZ2V0Q3Jvc3NGYWRlT3BhY2l0eShpKTtcbiAgICAgICAgICAgIGlmIChvcCA+IG1heE9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgICAgIG1heE9wYWNpdHkgPSBvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZHggPT0gaW5kZXg7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0Q3Jvc3NGYWRlT3BhY2l0eSA9IGZ1bmN0aW9uKHRhcmdldEluZGV4LCBvcGFjaXR5KSB7XG4gICAgICAgIHZhciB1bmlmb3JtTmFtZSA9ICdjcm9zc0ZhZGVPcGFjaXR5JyArIHRhcmdldEluZGV4O1xuICAgICAgICBfYmxlbmRQYXNzLnVuaWZvcm1zW3VuaWZvcm1OYW1lXS52YWx1ZSA9IG9wYWNpdHk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0Q3Jvc3NGYWRlT3BhY2l0eSA9IGZ1bmN0aW9uKHRhcmdldEluZGV4KSB7XG4gICAgICAgIHZhciB1bmlmb3JtTmFtZSA9ICdjcm9zc0ZhZGVPcGFjaXR5JyArIHRhcmdldEluZGV4O1xuICAgICAgICByZXR1cm4gX2JsZW5kUGFzcy51bmlmb3Jtc1t1bmlmb3JtTmFtZV0udmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEFjdGl2YXRlIHRhcmdldC1ibGVuZGluZyBmb3IgYmxlbmRQYXNzIGFuZCBhc3NpZ25zIGN1cnJlbnQgX2JsZW5kVGFyZ2V0IGFzIHNvdXJjZVxuICAgIHRoaXMudXBkYXRlQmxlbmRQYXNzID0gZnVuY3Rpb24obnVtRmFkZVRhcmdldHMpIHtcblxuICAgICAgICBpZiAobnVtRmFkZVRhcmdldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbnVtRmFkZVRhcmdldHMgPSBfZmFkZVRhcmdldHMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIE5VTV9DUk9TU0ZBREVfVEFSR0VUUyBzaGFkZXItZGVmaW5lIGlmIG5lY2Vzc2FyeVxuICAgICAgICB2YXIgbWFjcm9OYW1lICAgPSAnTlVNX0NST1NTRkFERV9UQVJHRVRTJztcbiAgICAgICAgdmFyIG9sZE1hY3JvVmFsID0gX2JsZW5kUGFzcy5tYXRlcmlhbC5kZWZpbmVzW21hY3JvTmFtZV07XG4gICAgICAgIHZhciBuZXdNYWNyb1ZhbCA9IChudW1GYWRlVGFyZ2V0cyA/IG51bUZhZGVUYXJnZXRzIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG9sZE1hY3JvVmFsICE9PSBuZXdNYWNyb1ZhbCkge1xuXG4gICAgICAgICAgICBpZiAobnVtRmFkZVRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICBfYmxlbmRQYXNzLm1hdGVyaWFsLmRlZmluZXNbbWFjcm9OYW1lXSA9IG5ld01hY3JvVmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZGVmaW5lIGZyb20gYmxlbmQgcGFzcy4gTm90ZSB0aGF0IHNldHRpbmcgdG8gJ3VuZGVmaW5lZCcgd291bGQgbm90IHdvcmsgaGVyZSxcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBtYWNybyB3b3VsZCBzdGlsbCBleGlzdCBhbmQgd291bGQgaGF2ZSB0aGUgdGV4dCB2YWx1ZSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfYmxlbmRQYXNzLm1hdGVyaWFsLmRlZmluZXNbbWFjcm9OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9ibGVuZFBhc3MubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPG51bUZhZGVUYXJnZXRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB1bmlmb3JtTmFtZSA9ICd0Q3Jvc3NGYWRlVGV4JyArIGk7XG4gICAgICAgICAgICBfYmxlbmRQYXNzLnVuaWZvcm1zW3VuaWZvcm1OYW1lXS52YWx1ZSA9IF9mYWRlVGFyZ2V0c1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBmYWRlLW1vZGUgbWFjcm9cbiAgICAgICAgdmFyIG1vZGVNYWNyb05hbWUgPSAnVEFSR0VUX0ZBREVfTU9ERSc7XG4gICAgICAgIHZhciBwcmV2TW9kZSA9IF9ibGVuZFBhc3MubWF0ZXJpYWwuZGVmaW5lc1ttb2RlTWFjcm9OYW1lXTtcbiAgICAgICAgaWYgKHByZXZNb2RlICE9PSBfZmFkZU1vZGUpIHtcbiAgICAgICAgICAgIF9ibGVuZFBhc3MubWF0ZXJpYWwuZGVmaW5lc1ttb2RlTWFjcm9OYW1lXSA9IF9mYWRlTW9kZTtcbiAgICAgICAgICAgIF9ibGVuZFBhc3MubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qIEBwYXJhbSB7bnVtYmVyfSBtb2RlIC0gU2VlIEZhZGVNb2RlIGVudW0gYWJvdmUuICovXG4gICAgdGhpcy5zZXRGYWRlTW9kZSA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgICAgaWYgKG1vZGUgIT09IEZhZGVNb2RlLkRFQ0FMICYmIG1vZGUgIT09IEZhZGVNb2RlLkNST1NTRkFERSkge1xuICAgICAgICAgICAgLy8gQSB3cm9uZyB2YWx1ZSBjYXVzZXMgYSBzaGFkZXIgY29tcGlsZSBlcnJvciAtIHNvIGl0J3MgYmV0dGVyIHRvIGNoZWNrIGhlcmUuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBmYWRlIG1vZGUgZW51bVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfZmFkZU1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLnVwZGF0ZUJsZW5kUGFzcygpO1xuICAgIH07XG5cbiAgICAvKiogQ2xlYXIgd2l0aCBvcGFjaXR5IDAuMCAqL1xuICAgIHRoaXMuY2xlYXJUYXJnZXQgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICAgICAgICAvLyBjbGVhciBSR0JBIGJsZW5kIHRhcmdldCB3aXRoIGJsYWNrICsgb3BhY2l0eSAwLjAgYW5kIGRlZmF1bHQgY2xlYXJEZXB0aFxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIGJsZW5kIHRhcmdldCBuZWVkcyBhbiBvd24gei1idWZmZXIuXG4gICAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoX2NsZWFyQ29sb3IsIDAuMCk7XG5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPF9mYWRlVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9lbmFibGVDbGVhcltpXSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggX2ZhZGVUYXJnZXRzW2ldICk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuY2xlYXIoIHRydWUsIHRydWUsIGZhbHNlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2xlYXIgY2FuIGJlIHRlbXBvcmFyaWx5IGRpc2FibGVkIHdoZW4gdXNpbmcgdGFyZ2V0cyBmb3Igc3RhdGljIGltYWdlIGZhZGluZy5cbiAgICB0aGlzLnNldENsZWFyRW5hYmxlZCA9IGZ1bmN0aW9uKHRhcmdldEluZGV4LCBlbmFibGVkKSB7XG4gICAgICAgIF9lbmFibGVDbGVhclt0YXJnZXRJbmRleF0gPSBlbmFibGVkO1xuICAgIH07XG5cbiAgICB0aGlzLmRpc3Bvc2VUYXJnZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxfZmFkZVRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfZmFkZVRhcmdldHNbaV07XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9mYWRlVGFyZ2V0c1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5kdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZVRhcmdldHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVCbGVuZFBhc3MoKTtcblxuICAgICAgICB0aGlzLnNldENyb3NzRmFkZU9wYWNpdHkoMCwgMCk7XG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NGYWRlT3BhY2l0eSgxLCAwKTtcbiAgICB9O1xuXG4gICAgLyogRGV0ZXJtaW5lcyB0byB3aGljaCBjb2xvciB0YXJnZXQgYSBzY2VuZSB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqICBAcGFyYW0ge1RIUkVFLlNjZW5lfFJlbmRlckJhdGNofSBzY2VuZSAgICAgICAgIC0gc2NlbmUgdG8gYmUgcmVuZGVyZWRcbiAgICAgKiAgQHBhcmFtIHtUSFJFRS5XZWJHTFJlbmRlclRhcmdldH0gZGVmYXVsdFRhcmdldCAtIGNvbG9yIHRhcmdldCB0aGF0IFJlbmRlckNvbnRleHQgd291bGQgdXNlIGJ5IGRlZmF1bHRcbiAgICAgKi9cbiAgICB0aGlzLmNob29zZUNvbG9yVGFyZ2V0ID0gZnVuY3Rpb24oc2NlbmUsIGRlZmF1bHRUYXJnZXQpIHtcblxuICAgICAgICAvLyBDaGVjayBpZiBzY2VuZSBpcyBhc3NvY2lhdGVkIHdpdGggYSByZW5kZXIgbW9kZWwgdGhhdCBpcyBhc3NpZ25lZCB0byBhIGNyb3NzLWZhZGUgdGFyZ2V0XG4gICAgICAgIHZhciBpbmRleCA9IHNjZW5lLm1vZGVsSWQgJiYgX21vZGVsSWQyVGFyZ2V0SW5kZXhbc2NlbmUubW9kZWxJZF07XG5cbiAgICAgICAgLy8gdXNlIGRlZmF1bHQgdGFyZ2V0IGlmIG5vdGhpbmcgZWxzZSBpcyBhc3NpZ25lZFxuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRUYXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1c2UgY3Jvc3MtZmFkZSB0YXJnZXRcbiAgICAgICAgcmV0dXJuIF9mYWRlVGFyZ2V0c1tpbmRleF07XG4gICAgfTtcblxuICAgIC8qIENhbGxlZCBieSBSZW5kZXJDb250ZXh0IGlmIHRhcmdldCBzaXplcyBvciBmb3JtYXRzIG1heSBjaGFuZ2UuIE1ha2VzIHN1cmUgdGhhdFxuICAgICAqIHRoZSBibGVuZFRhcmdldCBleGlzdHMgYW5kIGhhcyBtYXRjaGluZyBzaXplLlxuICAgICAqICBAcGFyYW0ge251bWJlcn0gd2lkdGggICAgICAgICAgLSByZW5kZXIgdGFyZ2V0IHdpZHRoXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgICAgICAgICAtIC4uLlxuICAgICAqICBAcGFyYW0ge2Jvb2x9ICAgW3VzZUhkclRhcmdldF0gLSBpZiB0cnVlLCB3ZSB1c2UgYSBmbG9hdC10eXBlIHRhcmdldFxuICAgICAqICBAcGFyYW0ge2Jvb2x9ICAgW2ZvcmNlXSAgICAgICAgLSBmb3JjZSByZWFsbG9jYXRlLCBldmVuIGlmIHdpZHRoL2hlaWdodCBrZWVwIHRoZSBzYW1lXG4gICAgICovXG4gICAgdGhpcy51cGRhdGVUYXJnZXRzID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgZm9yY2UsIHVzZUhkclRhcmdldCkge1xuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxfbnVtRmFkZVRhcmdldHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX2ZhZGVUYXJnZXRzW2ldO1xuXG4gICAgICAgICAgICAvLyBza2lwIGlmIG5vIHVwZGF0ZSBpcyBuZWVkZWRcbiAgICAgICAgICAgIGlmICghZm9yY2UgJiYgdGFyZ2V0ICYmIHRhcmdldC53aWR0aCA9PT0gd2lkdGggJiYgdGFyZ2V0LmhlaWdodCA9PT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRpc3Bvc2UgYW55IG9sZCB0YXJnZXRcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgICAgICB7ICAgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFRIUkVFLlJHQkFGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHVzZUhkclRhcmdldCA/IFRIUkVFLkZsb2F0VHlwZSA6IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIC8vYW5pc290cm9weTogTWF0aC5taW4odGhpcy5nZXRNYXhBbmlzb3Ryb3B5KCksIDQpLFxuICAgICAgICAgICAgICAgICAgICBzdGVuY2lsQnVmZmVyOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdGhyZWUuanMgaGFzIGEgZmxhdyBpbiBpdHMgY29uc3RydWN0b3I6IHRoZSBnZW5lcmF0ZU1pcG1hcHMgdmFsdWUgaXMgYWx3YXlzIGluaXRpYWxpemVkIHRvIHRydWVcbiAgICAgICAgICAgIHRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBfZmFkZVRhcmdldHNbaV0gPSB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIG9mZnNjcmVlbiByZW5kZXJpbmcgaW50byBvbmUgb2YgdGhlIGNyb3NzLWZhZGUgdGFyZ2V0cy5cbiAgICAgKiBGcmFtZXMgcmVuZGVyZWQgYmV0d2VlbiBiZWdpblJlbmRlckZhZGVJbWFnZShpKSBhbmQgZW5kUmVuZGVyRmFkZUltYWdlKCkgYXJlIHJlbmRlcmVkIGludG8gYSBmYWRpbmcgdGFyZ2V0XG4gICAgICogaW5zdGVhZCBvZiB0aGUgY2FudmFzLiBJbiB0aGlzIHdheSwgc3RhdGljIGltYWdlcyBjYW4gYmUgcHJlLXJlbmRlcmVkIGFuZCBmYWRlZC5cbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9ICAgICAgICBmYWRlVGFyZ2V0SW5kZXggLSBtdXN0IGJlIDAgb3IgMS5cbiAgICAgKiAgQHBhcmFtIHtSZW5kZXJDb250ZXh0fSByZW5kZXJDb250ZXh0XG4gICAgICovXG4gICAgdGhpcy5iZWdpblJlbmRlclRvRmFkZVRhcmdldCA9IGZ1bmN0aW9uKGZhZGVUYXJnZXRJbmRleCwgcmVuZGVyQ29udGV4dCkge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGJsZW5kIHBhc3MgZG9lcyBub3QgdXNlIHRoZSBmYWRpbmdUYXJnZXRzIGZvciByZWFkaW5nIHdoaWxlIHdlIGFyZSB3cml0aW5nIHRvIG9uZSBvZiB0aGVtXG4gICAgICAgIHRoaXMudXBkYXRlQmxlbmRQYXNzKDApO1xuXG4gICAgICAgIC8vIG1ha2UgcHJlc2VudEJ1ZmZlciBjYWxscyB3cml0ZSBpbnRvIF9vZmZzY3JlZW5UYXJnZXRcbiAgICAgICAgdmFyIHRhcmdldCA9IF9mYWRlVGFyZ2V0c1tmYWRlVGFyZ2V0SW5kZXhdO1xuICAgICAgICByZW5kZXJDb250ZXh0LnNldE9mZnNjcmVlblRhcmdldCh0YXJnZXQpO1xuXG4gICAgICAgIC8vIHByb3RlY3QgZmFkZS10YXJnZXQgZnJvbSBjbGVhciwgc28gdGhhdCB0aGUgaW1hZ2Ugd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gaW4gc3Vic2VxdWVudCBmcmFtZXNcbiAgICAgICAgdGhpcy5zZXRDbGVhckVuYWJsZWQoZmFkZVRhcmdldEluZGV4LCBmYWxzZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmlzaCBvZmZzY3JlZW4gcmVuZGVyaW5nIGludG8gZmFkaW5nIHRhcmdldC4gVGhlIHJlbmRlcmVkIHJlc3VsdCBpcyBub3cgb3ZlcmxheWVkIG9uIHRvcCBvZlxuICAgICAqIHRoZSBub3JtYWwgcmVuZGVyaW5nIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVuZGVyQ29udGV4dH0gcmVuZGVyQ29udGV4dFxuICAgICAqL1xuICAgIHRoaXMuZW5kUmVuZGVyRmFkZVRhcmdldCA9IGZ1bmN0aW9uKHJlbmRlckNvbnRleHQpIHtcblxuICAgICAgICAvLyByZW5kZXIgdG8gY2FudmFzIGFnYWluXG4gICAgICAgIHJlbmRlckNvbnRleHQuc2V0T2Zmc2NyZWVuVGFyZ2V0KG51bGwpO1xuXG4gICAgICAgIC8vIG1ha2UgYmxlbmQgcGFzcyB1c2UgZmFkZSB0YXJnZXRzIGFnYWluXG4gICAgICAgIHRoaXMudXBkYXRlQmxlbmRQYXNzKCk7XG4gICAgfTtcbn1cblxuLy8gZXhwb3NlIGVudW1cblRhcmdldENyb3NzRmFkZS5GYWRlTW9kZSA9IEZhZGVNb2RlO1xuXG4iXSwibmFtZXMiOlsiRmFkZU1vZGUiLCJERUNBTCIsIkNST1NTRkFERSIsIlRhcmdldENyb3NzRmFkZSIsImJsZW5kUGFzcyIsIl9mYWRlVGFyZ2V0cyIsIl9udW1GYWRlVGFyZ2V0cyIsIl9lbmFibGVDbGVhciIsIl9ibGVuZFBhc3MiLCJfY2xlYXJDb2xvciIsIlRIUkVFIiwiQ29sb3IiLCJfbW9kZWxJZDJUYXJnZXRJbmRleCIsIl9mYWRlTW9kZSIsIl9lbmFibGVTYW9IZXVyaXN0aWMiLCJzZXRNb2RlbFRhcmdldEluZGV4IiwibW9kZWxJZCIsInRhcmdldEluZGV4Iiwic2V0U2FvSGV1cmlzdGljRW5hYmxlZCIsImVuYWJsZWQiLCJnZXRSZW5kZXJTYW8iLCJzY2VuZSIsImluZGV4IiwidW5kZWZpbmVkIiwiaWR4IiwibWF4T3BhY2l0eSIsImdldENyb3NzRmFkZU9wYWNpdHkiLCJudW1UYXJnZXRzIiwiaSIsIm9wIiwic2V0Q3Jvc3NGYWRlT3BhY2l0eSIsIm9wYWNpdHkiLCJ1bmlmb3JtTmFtZSIsInVuaWZvcm1zIiwidmFsdWUiLCJ1cGRhdGVCbGVuZFBhc3MiLCJudW1GYWRlVGFyZ2V0cyIsImxlbmd0aCIsIm1hY3JvTmFtZSIsIm9sZE1hY3JvVmFsIiwibWF0ZXJpYWwiLCJkZWZpbmVzIiwibmV3TWFjcm9WYWwiLCJuZWVkc1VwZGF0ZSIsIm1vZGVNYWNyb05hbWUiLCJwcmV2TW9kZSIsInNldEZhZGVNb2RlIiwibW9kZSIsImNvbnNvbGUiLCJlcnJvciIsImNsZWFyVGFyZ2V0IiwicmVuZGVyZXIiLCJzZXRDbGVhckNvbG9yIiwic2V0UmVuZGVyVGFyZ2V0IiwiY2xlYXIiLCJzZXRDbGVhckVuYWJsZWQiLCJkaXNwb3NlVGFyZ2V0cyIsInRhcmdldCIsImRpc3Bvc2UiLCJkdG9yIiwiY2hvb3NlQ29sb3JUYXJnZXQiLCJkZWZhdWx0VGFyZ2V0IiwidXBkYXRlVGFyZ2V0cyIsIndpZHRoIiwiaGVpZ2h0IiwiZm9yY2UiLCJ1c2VIZHJUYXJnZXQiLCJXZWJHTFJlbmRlclRhcmdldCIsIm1pbkZpbHRlciIsIkxpbmVhckZpbHRlciIsIm1hZ0ZpbHRlciIsImZvcm1hdCIsIlJHQkFGb3JtYXQiLCJ0eXBlIiwiRmxvYXRUeXBlIiwiVW5zaWduZWRCeXRlVHlwZSIsInN0ZW5jaWxCdWZmZXIiLCJ0ZXh0dXJlIiwiZ2VuZXJhdGVNaXBtYXBzIiwiYmVnaW5SZW5kZXJUb0ZhZGVUYXJnZXQiLCJmYWRlVGFyZ2V0SW5kZXgiLCJyZW5kZXJDb250ZXh0Iiwic2V0T2Zmc2NyZWVuVGFyZ2V0IiwiZW5kUmVuZGVyRmFkZVRhcmdldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./extensions/CrossFadeEffects/TargetCrossFade.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./extensions/CrossFadeEffects/CrossFadeEffects.js");
/******/ 	Autodesk.Extensions.CrossFadeEffects = __webpack_exports__;
/******/ 	
/******/ })()
;