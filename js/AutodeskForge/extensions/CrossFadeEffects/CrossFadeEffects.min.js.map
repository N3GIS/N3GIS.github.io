{"version":3,"file":"CrossFadeEffects/CrossFadeEffects.min.js","mappings":"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","sources":["webpack://Autodesk.Extensions/webpack/bootstrap","webpack://Autodesk.Extensions/webpack/runtime/define property getters","webpack://Autodesk.Extensions/webpack/runtime/hasOwnProperty shorthand","webpack://Autodesk.Extensions/webpack/runtime/make namespace object","webpack://Autodesk.Extensions/./extensions/CrossFadeEffects/TargetCrossFade.js","webpack://Autodesk.Extensions/./extensions/CrossFadeEffects/CrossFadeEffects.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\n// Controls the way in which fading targets are applied in the blend shader\nexport const FadeMode = {\n    // Just blend each target independently on top of main color target (default)\n    DECAL: 0,\n\n    // Crossfades between target 0 and 1 using crossFadeOpacity1 as mix param.\n    // crossFadeOpacity0 is not used in this mode. Advantage is that colors keep\n    // more consistent when fading between two images.\n    CROSSFADE: 1\n};\n\n\n/**\n * @class TargetCrossFade is used by RenderContext to implement optional cross-fading\n * between different render targets. By default (no cross-fading), all scenes are rendered\n * to the default color buffer by RenderContext. When using targetCrossFade, a scene may\n * be rendered to a separate target, which is blended with the default color target in the blend pass.\n *  @param {LmvShaderPass} blendPass      - see RenderContext\n */\nexport function TargetCrossFade(blendPass) {\n\n    // {THREE.WebGLRenderTarget} of type RGBA with own depth buffer. Selected scenes are rendered into this target\n    // and overlayed on top of the main scene.\n    var _fadeTargets    = [];\n    var _numFadeTargets = 2;\n    var _enableClear    = [true, true]; // Clear may be disabled when fading to static images\n\n    var _blendPass = blendPass;\n\n    var _clearColor = new THREE.Color();\n\n    // {number[]} Indexed by modelId. Defines the index of the Render target to which a RenderModel is rendered.\n    //           0/undefined: default color buffer, 1:\n    var _modelId2TargetIndex = [];\n\n    var _fadeMode = FadeMode.DECAL;\n\n    // see setSaoHeuristicEnabled() comment\n    var _enableSaoHeuristic = true;\n\n    this.setModelTargetIndex = function(modelId, targetIndex) {\n        _modelId2TargetIndex[modelId] = targetIndex;\n    };\n\n    // By default (true), we exclude models from depth buffer rendering (used for SAO) if they have reduced opacity.\n    // Disabling it makes sure that models are always rendered to the depth target - no matter which opacity they have.\n    this.setSaoHeuristicEnabled = function(enabled) {\n        _enableSaoHeuristic = enabled;\n    };\n\n    //which model is used for AO (i.e. which one is more opaque)\n    this.getRenderSao = function(scene) {\n\n        if (!_enableSaoHeuristic) {\n            // Never suppress depth-writing - independent of target opacity.\n            return true;\n        }\n\n        var index = scene.modelId && _modelId2TargetIndex[scene.modelId];\n\n        if (index === undefined)\n            return true;\n\n        var idx = index;\n        var maxOpacity = this.getCrossFadeOpacity(index);\n\n        var numTargets = 2;\n        for (var i=0; i<numTargets; i++) {\n            var op = this.getCrossFadeOpacity(i);\n            if (op > maxOpacity) {\n                idx = i;\n                maxOpacity = op;\n            }\n        }\n\n        return idx == index;\n    };\n\n    this.setCrossFadeOpacity = function(targetIndex, opacity) {\n        var uniformName = 'crossFadeOpacity' + targetIndex;\n        _blendPass.uniforms[uniformName].value = opacity;\n    };\n\n    this.getCrossFadeOpacity = function(targetIndex) {\n        var uniformName = 'crossFadeOpacity' + targetIndex;\n        return _blendPass.uniforms[uniformName].value;\n    };\n\n    // Activate target-blending for blendPass and assigns current _blendTarget as source\n    this.updateBlendPass = function(numFadeTargets) {\n\n        if (numFadeTargets === undefined) {\n            numFadeTargets = _fadeTargets.length;\n        }\n\n        // Update NUM_CROSSFADE_TARGETS shader-define if necessary\n        var macroName   = 'NUM_CROSSFADE_TARGETS';\n        var oldMacroVal = _blendPass.material.defines[macroName];\n        var newMacroVal = (numFadeTargets ? numFadeTargets : undefined);\n        if (oldMacroVal !== newMacroVal) {\n\n            if (numFadeTargets) {\n                _blendPass.material.defines[macroName] = newMacroVal;\n            } else {\n                // remove define from blend pass. Note that setting to 'undefined' would not work here,\n                // because the macro would still exist and would have the text value 'undefined'\n                delete _blendPass.material.defines[macroName];\n            }\n            _blendPass.material.needsUpdate = true;\n        }\n\n        for (var i=0; i<numFadeTargets; i++) {\n            var uniformName = 'tCrossFadeTex' + i;\n            _blendPass.uniforms[uniformName].value = _fadeTargets[i];\n        }\n\n        // Update fade-mode macro\n        var modeMacroName = 'TARGET_FADE_MODE';\n        var prevMode = _blendPass.material.defines[modeMacroName];\n        if (prevMode !== _fadeMode) {\n            _blendPass.material.defines[modeMacroName] = _fadeMode;\n            _blendPass.material.needsUpdate = true;\n        }\n    };\n\n    /* @param {number} mode - See FadeMode enum above. */\n    this.setFadeMode = function(mode) {\n        if (mode !== FadeMode.DECAL && mode !== FadeMode.CROSSFADE) {\n            // A wrong value causes a shader compile error - so it's better to check here.\n            console.error(\"Unexpected fade mode enum\");\n            return;\n        }\n        _fadeMode = mode;\n        this.updateBlendPass();\n    };\n\n    /** Clear with opacity 0.0 */\n    this.clearTarget = function(renderer) {\n        // clear RGBA blend target with black + opacity 0.0 and default clearDepth\n        // Note that the blend target needs an own z-buffer.\n        renderer.setClearColor(_clearColor, 0.0);\n\n        for (var i=0; i<_fadeTargets.length; i++) {\n            if (_enableClear[i]) {\n                renderer.setRenderTarget( _fadeTargets[i] );\n                renderer.clear( true, true, false );\n            }\n        }\n    };\n\n    // Clear can be temporarily disabled when using targets for static image fading.\n    this.setClearEnabled = function(targetIndex, enabled) {\n        _enableClear[targetIndex] = enabled;\n    };\n\n    this.disposeTargets = function() {\n        for (var i=0; i<_fadeTargets.length; i++) {\n            var target = _fadeTargets[i];\n            if (target) {\n                target.dispose();\n            }\n            _fadeTargets[i] = null;\n        }\n    };\n\n    this.dtor = function() {\n        this.disposeTargets();\n        this.updateBlendPass();\n\n        this.setCrossFadeOpacity(0, 0);\n        this.setCrossFadeOpacity(1, 0);\n    };\n\n    /* Determines to which color target a scene will be rendered.\n     *  @param {THREE.Scene|RenderBatch} scene         - scene to be rendered\n     *  @param {THREE.WebGLRenderTarget} defaultTarget - color target that RenderContext would use by default\n     */\n    this.chooseColorTarget = function(scene, defaultTarget) {\n\n        // Check if scene is associated with a render model that is assigned to a cross-fade target\n        var index = scene.modelId && _modelId2TargetIndex[scene.modelId];\n\n        // use default target if nothing else is assigned\n        if (index === undefined) {\n            return defaultTarget;\n        }\n\n        // use cross-fade target\n        return _fadeTargets[index];\n    };\n\n    /* Called by RenderContext if target sizes or formats may change. Makes sure that\n     * the blendTarget exists and has matching size.\n     *  @param {number} width          - render target width\n     *  @param {number} height         - ...\n     *  @param {bool}   [useHdrTarget] - if true, we use a float-type target\n     *  @param {bool}   [force]        - force reallocate, even if width/height keep the same\n     */\n    this.updateTargets = function(width, height, force, useHdrTarget) {\n\n        for (var i=0; i<_numFadeTargets; i++) {\n\n            var target = _fadeTargets[i];\n\n            // skip if no update is needed\n            if (!force && target && target.width === width && target.height === height) {\n                continue;\n            }\n\n            // dispose any old target\n            if (target) {\n                target.dispose();\n            }\n\n            target = new THREE.WebGLRenderTarget(width, height,\n                {   minFilter: THREE.LinearFilter,\n                    magFilter: THREE.LinearFilter,\n                    format: THREE.RGBAFormat,\n                    type: useHdrTarget ? THREE.FloatType : THREE.UnsignedByteType,\n                    //anisotropy: Math.min(this.getMaxAnisotropy(), 4),\n                    stencilBuffer: false\n                });\n            // three.js has a flaw in its constructor: the generateMipmaps value is always initialized to true\n            target.texture.generateMipmaps = false;\n\n            _fadeTargets[i] = target;\n        }\n    };\n\n    /**\n     * Starts offscreen rendering into one of the cross-fade targets.\n     * Frames rendered between beginRenderFadeImage(i) and endRenderFadeImage() are rendered into a fading target\n     * instead of the canvas. In this way, static images can be pre-rendered and faded.\n     *  @param {number}        fadeTargetIndex - must be 0 or 1.\n     *  @param {RenderContext} renderContext\n     */\n    this.beginRenderToFadeTarget = function(fadeTargetIndex, renderContext) {\n\n        // Make sure that blend pass does not use the fadingTargets for reading while we are writing to one of them\n        this.updateBlendPass(0);\n\n        // make presentBuffer calls write into _offscreenTarget\n        var target = _fadeTargets[fadeTargetIndex];\n        renderContext.setOffscreenTarget(target);\n\n        // protect fade-target from clear, so that the image will not be overwritten in subsequent frames\n        this.setClearEnabled(fadeTargetIndex, false);\n    };\n\n    /**\n     * Finish offscreen rendering into fading target. The rendered result is now overlayed on top of\n     * the normal rendering result.\n     *\n     * @param {RenderContext} renderContext\n     */\n    this.endRenderFadeTarget = function(renderContext) {\n\n        // render to canvas again\n        renderContext.setOffscreenTarget(null);\n\n        // make blend pass use fade targets again\n        this.updateBlendPass();\n    };\n}\n\n// expose enum\nTargetCrossFade.FadeMode = FadeMode;\n\n","\n\nconst myExtensionName = 'Autodesk.CrossFadeEffects';\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\n\nimport { TargetCrossFade } from './TargetCrossFade';\n\n/** CrossFadeEffects extension provides API for implementing smooth fading effects in LMV, e.g.\n *  - CrossFading between models or model configurations (e.g. color theming, hiding objects etc.)\n *  - Image-based \"ghosting\" effect, i.e. showing a semitransparent snapshot of a model on top of another one.\n *\n * The extension id is: `Autodesk.CrossFadeEffects`\n *\n * Note:\n *  - Note that CrossFadeEffects require 2 extra RenderTargets. So, they should only be used for optional effects that can be skipped on weak devices.\n *  - CrossFade effects can only be used for one purpose at a time. When using them for a new feature, you have to make sure\n *    that they don't conflict with existing features.\n *\n * @example\n *   viewer.loadExtension('Autodesk.CrossFadeEffects')\n *\n * @memberof Autodesk.Viewing.Extensions\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @alias Autodesk.Viewing.Extensions.CrossFadeEffects\n * @class\n */\nexport default class CrossFadeEffects extends av.Extension {\n    constructor(viewer, options) {\n\n        super(viewer, options);\n        this.crossFade = null;\n\n        // Used to handle conflicts if this extension is used for different purposes\n        this.clientId = null;\n        this.onClientChanged = null;\n    }\n\n    /**\n     * Enables cross frade effects.\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#load\n     */\n    load() {\n        this.setCrossFadeEnabled(true);\n        return true;\n    }\n\n    /**\n     * Disables cross frade effects.\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#unload\n     */\n    unload() {\n        this.setCrossFadeEnabled(false);\n    }\n\n    /**\n     * Fading targets may be used by different clients for different purposes. That's okay as long\n     * as it does not happen concurrently.\n     *\n     * In case of conflicts, the last caller takes precedence.\n     *\n     * If you start an effect using this extension, always call this function to notify client\n     * code that was using it before. Vice versa, provide an onClientChanged() callback to handle the case\n     * that someone else overtakes.\n     *\n     * Example: If start a fading effect while the ghost floors of the LevelsExtension are fading\n     * out, the LevelsExtension will be notified to skip the fade-out anim to avoid conflicts.\n     *\n     * @param {string} clientId - Some identifier unique for the code component using the effect, e.g. the name of an extension.\n     * @param {Function} [onClientChanged] - Will be called if another client called acquireControl.\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#acquireControl\n     */\n    acquireControl(clientId, onClientChanged) {\n        this.clientId = clientId;\n        this.onClientChanged && this.onClientChanged(); // let previous client code now that we took control\n        this.onClientChanged = onClientChanged;         // call onClientChanged if someone else overtakes later\n    }\n\n    /**\n     * Only allowed if modelCrossFade is enabled. Determines to which target a RenderModel will be rendered.\n     *\n     *  @param {number} modelId - The model id\n     *  @param {undefined|0|1} targetIndex - index of the crossFade target or undefined (default) to use default color buffer\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setModelTargetIndex\n     */\n    setModelTargetIndex(modelId, targetIndex) {\n        this.crossFade.setModelTargetIndex(modelId, targetIndex);\n        this.viewer.impl.invalidate(true);\n    }\n\n    /**\n     * Only allowed if modelCrossFade is enabled. Determines to which target a RenderModel will be rendered.\n     *\n     * @param {undefined|0|1} index - index of the crossFade target or undefined (default) to use default color buffer\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setModelTargetIndexForAll\n     */\n    setModelTargetIndexForAll(index) {\n        const models = this.viewer.getVisibleModels();\n        for (let i=0; i<models.length; i++) {\n            const model = models[i];\n            this.setModelTargetIndex(model.id, index);\n        }\n    }\n\n    /**\n     * Only allowed if modelCrossFade is enabled. Assigns a blending opacity to a cross-fading\n     * extra target.\n     *\n     *  @param {number} targetIndex - must be >0\n     *  @param {number} opacity     - in [0,1]\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setCrossFadeOpacity\n     */\n    setCrossFadeOpacity(targetIndex, opacity) {\n        this.crossFade.setCrossFadeOpacity(targetIndex, opacity);\n        this.viewer.impl?.invalidate(true);\n    }\n\n    /*\n     * @param {number} targetIndex - must be >0\n     * @returns {number} opacity\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#getCrossFadeOpacity\n     */\n    getCrossFadeOpacity(targetIndex) {\n        return this.crossFade.getCrossFadeOpacity(targetIndex);\n    }\n\n    /**\n     * Enable/Disable model cross-fading. Must be enabled in order to render models to different render targets\n     * for cross-fading effects (see below). If no cross-fading effects are used, it should be disabled to save\n     * GPU memory and performance.\n     *\n     * @param {boolean} enable - Whether to enable(true) or disable(false) cross fade effects.\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#setCrossFadeEnabled\n     */\n    setCrossFadeEnabled(enable) {\n        if (enable === Boolean(this.crossFade)) {\n            return;\n        }\n\n        let renderer = this.viewer.impl.renderer();\n        if (enable) {\n            let blendPass = renderer.getBlendPass();\n            this.crossFade = new TargetCrossFade(blendPass);\n            renderer.setCrossFade(this.crossFade);\n        } else {\n            this.crossFade.dtor();\n            renderer.setCrossFade(null);\n        }\n\n        // If targets have been created already, call resize to make sure that\n        //   1. crossFade targets are created and have correct size/format\n        //   2. colorTarget/idTarget are reallocated with correct format\n        //      Note that toggling crossFade affects color/id target format as well, because\n        //      RGB and RGBA targets cannot be used at once when using MRT.\n        let colorTarget = renderer.getColorTarget();\n        if (colorTarget) {\n            const pixelRatio = this.viewer.impl.glrenderer().getPixelRatio(); //setSize expects the size without pixelRatio\n            renderer.setSize(colorTarget.width / pixelRatio, colorTarget.height / pixelRatio);\n        }\n    }\n\n    /*\n     * Renders a frame into a fading target, so that we can use it for a static-image fade.\n     * The target will be protected from cleaning, so that it will overdraw the main scene.\n     * To go back to normal rendering, call releaseFadingImage(fadeTargetIndex) afterwards.\n     *  @param {0|1} fadeTargetIndex\n     *  @param {number} [frameBudget] - time budget in ms that can be used for rendering this image.\n     *                                  Only relevant if progressive rendering is on.\n     *                                  Default value is the current this.targetFrameBudget setting.\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#renderFadingImage\n     */\n    renderFadingImage(fadeTargetIndex, frameBudget) {\n        // Make sure last frame was rendered to main target.\n        // This is needed in case there were changes made (like cutplanes applied), before the viewer was able to render them.\n        let timestamp = performance.now();\n        this.viewer.impl.tick(timestamp);\n\n        // make RenderContext render into fadeTarget\n        let renderer = this.viewer.impl.renderer();\n        this.crossFade.beginRenderToFadeTarget(fadeTargetIndex, renderer);\n\n        // start new frame\n        this.viewer.impl.invalidate(true, true, true);\n\n        // temporarily overload rendering budget (if wanted)\n        let originalFrameBudget = this.viewer.impl.targetFrameBudget;\n        if (frameBudget) {\n            this.viewer.impl.targetFrameBudget = frameBudget;\n        }\n\n        timestamp = performance.now();\n        this.viewer.impl.tick(timestamp);\n\n        // recover original frame budget\n        this.targetFrameBudget = originalFrameBudget;\n\n        // make RenderContext render to the main scene canvas again\n        this.crossFade.endRenderFadeTarget(renderer);\n    }\n\n    /* Must be called when a baked fading image (see renderFadingImage) is not needed anymore. */\n    releaseFadingImage(fadeTargetIndex) {\n        this.setClearEnabled(fadeTargetIndex, true);\n    }\n\n    setClearEnabled(targetIndex, enabled) {\n        this.crossFade.setClearEnabled(targetIndex, enabled);\n    }\n\n    /**\n     * Runs a fading-animation on a cross-fading target.\n     *\n     *  @param {number}        targetIndex        - see setModelTargetIndex()\n     *  @param {number}        startOpacity       - in [0,1]\n     *  @param {number}        endOpacity         - in [0,1]\n     *  @param {number}       [duration=5]        - in seconds\n     *  @param {Function}     [onFinished]        - optional callback triggered when animation is finished\n     *  @returns {object}     AnimControl instance\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#fadeTarget\n     */\n    fadeTarget(targetIndex, startOpacity, endOpacity, duration, onFinished) {\n\n        let setTargetOpacity = (val) => {\n            this.setCrossFadeOpacity(targetIndex, val);\n        };\n        return avp.fadeValue(startOpacity, endOpacity, duration, setTargetOpacity, onFinished);\n    }\n\n    // Performs an image cross-fade between fade-target 0 and 1, assuming that the main scene is not visible.\n    fadeImage(startVal, endVal, duration, onFinished) {\n\n        // Temporarily hide all models during the image fade. They would be overdrawn anyway, so rendering them would just waste time.\n        let mq = this.viewer.impl.modelQueue();\n        let models = mq.getModels().slice(); // We have to copy - otherwise the array would be empty after hiding the models\n        for (let i=0; i<models.length; i++) {\n            let model = models[i];\n            mq.hideModel(model.id);\n        }\n\n        let onFadeDone = () => {\n\n            // Set fading mode back to the default (independent decal of both targets)\n            this.crossFade.setFadeMode(TargetCrossFade.FadeMode.CROSSFADE);\n\n            // Reactivate all temporarily hidden models\n            for (let i=0; i<models.length; i++) {\n                let model = models[i];\n                mq.showModel(model.id);\n            }\n\n            if (onFinished) {\n                onFinished();\n            }\n        };\n\n        // fade between both targets\n        let setTargetOpacity = (val) => {\n\n            // Fade opacity of cross-fade target 1\n            this.setCrossFadeOpacity(0, 1.0 - val);\n            this.setCrossFadeOpacity(1, val);\n\n            // Viewer3DImpl skips the present step if scene is empty. Therefore, we enforce\n            // present from outside when cross-fading images.\n            let renderer = this.viewer.impl.renderer();\n            renderer.presentBuffer();\n        };\n\n        // For static image fading, we use the cross-fade mode. This ensures that identical pixels between both\n        // images do not vary during transition.\n        this.crossFade.setFadeMode(TargetCrossFade.FadeMode.CROSSFADE);\n\n        return avp.fadeValue(startVal, endVal, duration, setTargetOpacity, onFadeDone);\n    }\n\n    /**\n     * Runs a static image fade between the current view and a modified view.\n     * (e.g. with changed model/fragment visiblity, ghosting etc.)\n     * The modified view is specified via function applyState.\n     *\n     *  @param {Function} applyState - applied after rendering the fading start image.\n     *  @param {number} duration - in seconds\n     *\n     * @alias Autodesk.Viewing.Extensions.CrossFadeEffects#fadeToViewerState\n     */\n    fadeToViewerState(applyState, duration) {\n\n        // time-limit in ms that we allow for rendering static images\n        var renderBudget = 300;\n\n        // Render \"before\" state into target 0\n        this.renderFadingImage(0, renderBudget);\n\n        // apply viewer state modification\n        applyState();\n\n        // render image that we fade to\n        this.renderFadingImage(1, renderBudget);\n\n        // remember if SAO was enabled before image fade, because we temporarily disable it, because\n        // AO is already baked into the images that we fade.\n        var rc = this.viewer.impl.renderer();\n        var aoEnabled = rc.getAOEnabled();\n\n        let onFadeDone = () => {\n            // unlock targets again, so that we see the main color target again (instead of the static images)\n            this.releaseFadingImage(0);\n            this.releaseFadingImage(1);\n\n            // recover original AO-enabled state\n            rc.setAOEnabled(aoEnabled);\n        };\n\n        // disable SAO during fading\n        rc.setAOEnabled(false);\n\n        // run image fading\n        this.fadeImage(0.0, 1.0, duration, onFadeDone);\n    }\n}\n\n// Register the extension with the extension manager.\nAutodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, CrossFadeEffects);\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","FadeMode","DECAL","CROSSFADE","TargetCrossFade","blendPass","_fadeTargets","_enableClear","_blendPass","_clearColor","THREE","Color","_modelId2TargetIndex","_fadeMode","_enableSaoHeuristic","this","setModelTargetIndex","modelId","targetIndex","setSaoHeuristicEnabled","enabled","getRenderSao","scene","index","undefined","idx","maxOpacity","getCrossFadeOpacity","i","op","setCrossFadeOpacity","opacity","uniformName","uniforms","updateBlendPass","numFadeTargets","length","macroName","newMacroVal","material","defines","needsUpdate","modeMacroName","setFadeMode","mode","console","error","clearTarget","renderer","setClearColor","setRenderTarget","clear","setClearEnabled","disposeTargets","target","dispose","dtor","chooseColorTarget","defaultTarget","updateTargets","width","height","force","useHdrTarget","WebGLRenderTarget","minFilter","LinearFilter","magFilter","format","RGBAFormat","type","FloatType","UnsignedByteType","stencilBuffer","texture","generateMipmaps","beginRenderToFadeTarget","fadeTargetIndex","renderContext","setOffscreenTarget","endRenderFadeTarget","av","Autodesk","Viewing","avp","Private","CrossFadeEffects","Extension","constructor","viewer","options","super","crossFade","clientId","onClientChanged","load","setCrossFadeEnabled","unload","acquireControl","impl","invalidate","setModelTargetIndexForAll","models","getVisibleModels","model","id","_this$viewer$impl","enable","Boolean","getBlendPass","setCrossFade","colorTarget","getColorTarget","pixelRatio","glrenderer","getPixelRatio","setSize","renderFadingImage","frameBudget","timestamp","performance","now","tick","originalFrameBudget","targetFrameBudget","releaseFadingImage","fadeTarget","startOpacity","endOpacity","duration","onFinished","fadeValue","val","fadeImage","startVal","endVal","mq","modelQueue","getModels","slice","hideModel","presentBuffer","onFadeDone","showModel","fadeToViewerState","applyState","rc","aoEnabled","getAOEnabled","setAOEnabled","theExtensionManager","registerExtension"],"sourceRoot":""}