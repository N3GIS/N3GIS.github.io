/*!
 * LMV v7.105.0
 *
 * Copyright 2025 Autodesk, Inc.
 * All rights reserved.
 *
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 *
 * Autodesk Viewer SDK Usage Limitations:
 *
 * The Autodesk Viewer SDK JavaScript must be delivered from an
 * Autodesk-hosted URL.
 */
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@adsk/pdfjs-dist/legacy/build/pdf.js":
/*!***********************************************************!*\
  !*** ./node_modules/@adsk/pdfjs-dist/legacy/build/pdf.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * @licstart The following is the entire license notice for the\n * Javascript code in this page\n *\n * Copyright 2020 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * Javascript code in this page\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"addLinkAttributes\", ({\n  enumerable: true,\n  get: function get() {\n    return _display_utils.addLinkAttributes;\n  }\n}));\nObject.defineProperty(exports, \"getFilenameFromUrl\", ({\n  enumerable: true,\n  get: function get() {\n    return _display_utils.getFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"LinkTarget\", ({\n  enumerable: true,\n  get: function get() {\n    return _display_utils.LinkTarget;\n  }\n}));\nObject.defineProperty(exports, \"loadScript\", ({\n  enumerable: true,\n  get: function get() {\n    return _display_utils.loadScript;\n  }\n}));\nObject.defineProperty(exports, \"PDFDateString\", ({\n  enumerable: true,\n  get: function get() {\n    return _display_utils.PDFDateString;\n  }\n}));\nObject.defineProperty(exports, \"RenderingCancelledException\", ({\n  enumerable: true,\n  get: function get() {\n    return _display_utils.RenderingCancelledException;\n  }\n}));\nObject.defineProperty(exports, \"build\", ({\n  enumerable: true,\n  get: function get() {\n    return _api.build;\n  }\n}));\nObject.defineProperty(exports, \"getDocument\", ({\n  enumerable: true,\n  get: function get() {\n    return _api.getDocument;\n  }\n}));\nObject.defineProperty(exports, \"LoopbackPort\", ({\n  enumerable: true,\n  get: function get() {\n    return _api.LoopbackPort;\n  }\n}));\nObject.defineProperty(exports, \"PDFDataRangeTransport\", ({\n  enumerable: true,\n  get: function get() {\n    return _api.PDFDataRangeTransport;\n  }\n}));\nObject.defineProperty(exports, \"PDFWorker\", ({\n  enumerable: true,\n  get: function get() {\n    return _api.PDFWorker;\n  }\n}));\nObject.defineProperty(exports, \"putBinaryImageData\", ({\n  enumerable: true,\n  get: function get() {\n    return _api.putBinaryImageData;\n  }\n}));\nObject.defineProperty(exports, \"version\", ({\n  enumerable: true,\n  get: function get() {\n    return _api.version;\n  }\n}));\nObject.defineProperty(exports, \"CMapCompressionType\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.CMapCompressionType;\n  }\n}));\nObject.defineProperty(exports, \"createObjectURL\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.createObjectURL;\n  }\n}));\nObject.defineProperty(exports, \"createPromiseCapability\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.createPromiseCapability;\n  }\n}));\nObject.defineProperty(exports, \"createValidAbsoluteUrl\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.createValidAbsoluteUrl;\n  }\n}));\nObject.defineProperty(exports, \"InvalidPDFException\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.InvalidPDFException;\n  }\n}));\nObject.defineProperty(exports, \"MissingPDFException\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.MissingPDFException;\n  }\n}));\nObject.defineProperty(exports, \"OPS\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.OPS;\n  }\n}));\nObject.defineProperty(exports, \"PasswordResponses\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.PasswordResponses;\n  }\n}));\nObject.defineProperty(exports, \"PermissionFlag\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.PermissionFlag;\n  }\n}));\nObject.defineProperty(exports, \"removeNullCharacters\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.removeNullCharacters;\n  }\n}));\nObject.defineProperty(exports, \"shadow\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.shadow;\n  }\n}));\nObject.defineProperty(exports, \"UnexpectedResponseException\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.UnexpectedResponseException;\n  }\n}));\nObject.defineProperty(exports, \"UNSUPPORTED_FEATURES\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.UNSUPPORTED_FEATURES;\n  }\n}));\nObject.defineProperty(exports, \"Util\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.Util;\n  }\n}));\nObject.defineProperty(exports, \"VerbosityLevel\", ({\n  enumerable: true,\n  get: function get() {\n    return _util.VerbosityLevel;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationLayer\", ({\n  enumerable: true,\n  get: function get() {\n    return _annotation_layer.AnnotationLayer;\n  }\n}));\nObject.defineProperty(exports, \"apiCompatibilityParams\", ({\n  enumerable: true,\n  get: function get() {\n    return _api_compatibility.apiCompatibilityParams;\n  }\n}));\nObject.defineProperty(exports, \"GlobalWorkerOptions\", ({\n  enumerable: true,\n  get: function get() {\n    return _worker_options.GlobalWorkerOptions;\n  }\n}));\nObject.defineProperty(exports, \"renderTextLayer\", ({\n  enumerable: true,\n  get: function get() {\n    return _text_layer.renderTextLayer;\n  }\n}));\nObject.defineProperty(exports, \"SVGGraphics\", ({\n  enumerable: true,\n  get: function get() {\n    return _svg.SVGGraphics;\n  }\n}));\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _api = __w_pdfjs_require__(135);\n\nvar _util = __w_pdfjs_require__(4);\n\nvar _annotation_layer = __w_pdfjs_require__(149);\n\nvar _api_compatibility = __w_pdfjs_require__(139);\n\nvar _worker_options = __w_pdfjs_require__(142);\n\nvar _text_layer = __w_pdfjs_require__(151);\n\nvar _svg = __w_pdfjs_require__(152);\n\nvar pdfjsVersion = '2.8.173';\nvar pdfjsBuild = 'bc834d510';\n{\n  var _require = __w_pdfjs_require__(6),\n      isNodeJS = _require.isNodeJS;\n\n  if (isNodeJS) {\n    var PDFNodeStream = __w_pdfjs_require__(153).PDFNodeStream;\n\n    (0, _api.setPDFNetworkStreamFactory)(function (params) {\n      return new PDFNodeStream(params);\n    });\n  } else {\n    var PDFNetworkStream = __w_pdfjs_require__(156).PDFNetworkStream;\n\n    var PDFFetchStream;\n\n    if ((0, _display_utils.isFetchSupported)()) {\n      PDFFetchStream = __w_pdfjs_require__(157).PDFFetchStream;\n    }\n\n    (0, _api.setPDFNetworkStreamFactory)(function (params) {\n      if (PDFFetchStream && (0, _display_utils.isValidFetchUrl)(params.url)) {\n        return new PDFFetchStream(params);\n      }\n\n      return new PDFNetworkStream(params);\n    });\n  }\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.addLinkAttributes = addLinkAttributes;\nexports.deprecated = deprecated;\nexports.getFilenameFromUrl = getFilenameFromUrl;\nexports.isFetchSupported = isFetchSupported;\nexports.isValidFetchUrl = isValidFetchUrl;\nexports.loadScript = loadScript;\nexports.StatTimer = exports.RenderingCancelledException = exports.PDFDateString = exports.PageViewport = exports.LinkTarget = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = exports.DEFAULT_LINK_REL = exports.BaseCMapReaderFactory = exports.BaseCanvasFactory = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DEFAULT_LINK_REL = \"noopener noreferrer nofollow\";\nexports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;\nvar SVG_NS = \"http://www.w3.org/2000/svg\";\n\nvar BaseCanvasFactory = /*#__PURE__*/function () {\n  function BaseCanvasFactory() {\n    _classCallCheck(this, BaseCanvasFactory);\n\n    if (this.constructor === BaseCanvasFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n    }\n  }\n\n  _createClass(BaseCanvasFactory, [{\n    key: \"create\",\n    value: function create(width, height) {\n      (0, _util.unreachable)(\"Abstract method `create` called.\");\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(canvasAndContext, width, height) {\n      if (!canvasAndContext.canvas) {\n        throw new Error(\"Canvas is not specified\");\n      }\n\n      if (width <= 0 || height <= 0) {\n        throw new Error(\"Invalid canvas size\");\n      }\n\n      canvasAndContext.canvas.width = width;\n      canvasAndContext.canvas.height = height;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(canvasAndContext) {\n      if (!canvasAndContext.canvas) {\n        throw new Error(\"Canvas is not specified\");\n      }\n\n      canvasAndContext.canvas.width = 0;\n      canvasAndContext.canvas.height = 0;\n      canvasAndContext.canvas = null;\n      canvasAndContext.context = null;\n    }\n  }]);\n\n  return BaseCanvasFactory;\n}();\n\nexports.BaseCanvasFactory = BaseCanvasFactory;\n\nvar DOMCanvasFactory = /*#__PURE__*/function (_BaseCanvasFactory) {\n  _inherits(DOMCanvasFactory, _BaseCanvasFactory);\n\n  var _super = _createSuper(DOMCanvasFactory);\n\n  function DOMCanvasFactory() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$ownerDocument = _ref.ownerDocument,\n        ownerDocument = _ref$ownerDocument === void 0 ? globalThis.document : _ref$ownerDocument;\n\n    _classCallCheck(this, DOMCanvasFactory);\n\n    _this = _super.call(this);\n    _this._document = ownerDocument;\n    return _this;\n  }\n\n  _createClass(DOMCanvasFactory, [{\n    key: \"create\",\n    value: function create(width, height) {\n      if (width <= 0 || height <= 0) {\n        throw new Error(\"Invalid canvas size\");\n      }\n\n      var canvas = this._document.createElement(\"canvas\");\n\n      var context = canvas.getContext(\"2d\");\n      canvas.width = width;\n      canvas.height = height;\n      return {\n        canvas: canvas,\n        context: context\n      };\n    }\n  }]);\n\n  return DOMCanvasFactory;\n}(BaseCanvasFactory);\n\nexports.DOMCanvasFactory = DOMCanvasFactory;\n\nvar BaseCMapReaderFactory = /*#__PURE__*/function () {\n  function BaseCMapReaderFactory(_ref2) {\n    var _ref2$baseUrl = _ref2.baseUrl,\n        baseUrl = _ref2$baseUrl === void 0 ? null : _ref2$baseUrl,\n        _ref2$isCompressed = _ref2.isCompressed,\n        isCompressed = _ref2$isCompressed === void 0 ? false : _ref2$isCompressed;\n\n    _classCallCheck(this, BaseCMapReaderFactory);\n\n    if (this.constructor === BaseCMapReaderFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n    }\n\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n\n  _createClass(BaseCMapReaderFactory, [{\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(_ref3) {\n        var _this2 = this;\n\n        var name, url, compressionType;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                name = _ref3.name;\n\n                if (this.baseUrl) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n\n              case 3:\n                if (name) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error(\"CMap name must be specified.\");\n\n              case 5:\n                url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n                compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n                return _context.abrupt(\"return\", this._fetchData(url, compressionType)[\"catch\"](function (reason) {\n                  throw new Error(\"Unable to load \".concat(_this2.isCompressed ? \"binary \" : \"\", \"CMap at: \").concat(url));\n                }));\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function fetch(_x) {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n  }, {\n    key: \"_fetchData\",\n    value: function _fetchData(url, compressionType) {\n      (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n    }\n  }]);\n\n  return BaseCMapReaderFactory;\n}();\n\nexports.BaseCMapReaderFactory = BaseCMapReaderFactory;\n\nvar DOMCMapReaderFactory = /*#__PURE__*/function (_BaseCMapReaderFactor) {\n  _inherits(DOMCMapReaderFactory, _BaseCMapReaderFactor);\n\n  var _super2 = _createSuper(DOMCMapReaderFactory);\n\n  function DOMCMapReaderFactory() {\n    _classCallCheck(this, DOMCMapReaderFactory);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(DOMCMapReaderFactory, [{\n    key: \"_fetchData\",\n    value: function _fetchData(url, compressionType) {\n      var _this3 = this;\n\n      if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) {\n        return fetch(url).then( /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(response) {\n            var cMapData;\n            return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    if (response.ok) {\n                      _context2.next = 2;\n                      break;\n                    }\n\n                    throw new Error(response.statusText);\n\n                  case 2:\n                    if (!_this3.isCompressed) {\n                      _context2.next = 10;\n                      break;\n                    }\n\n                    _context2.t0 = Uint8Array;\n                    _context2.next = 6;\n                    return response.arrayBuffer();\n\n                  case 6:\n                    _context2.t1 = _context2.sent;\n                    cMapData = new _context2.t0(_context2.t1);\n                    _context2.next = 15;\n                    break;\n\n                  case 10:\n                    _context2.t2 = _util.stringToBytes;\n                    _context2.next = 13;\n                    return response.text();\n\n                  case 13:\n                    _context2.t3 = _context2.sent;\n                    cMapData = (0, _context2.t2)(_context2.t3);\n\n                  case 15:\n                    return _context2.abrupt(\"return\", {\n                      cMapData: cMapData,\n                      compressionType: compressionType\n                    });\n\n                  case 16:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }));\n\n          return function (_x2) {\n            return _ref4.apply(this, arguments);\n          };\n        }());\n      }\n\n      return new Promise(function (resolve, reject) {\n        var request = new XMLHttpRequest();\n        request.open(\"GET\", url, true);\n\n        if (_this3.isCompressed) {\n          request.responseType = \"arraybuffer\";\n        }\n\n        request.onreadystatechange = function () {\n          if (request.readyState !== XMLHttpRequest.DONE) {\n            return;\n          }\n\n          if (request.status === 200 || request.status === 0) {\n            var cMapData;\n\n            if (_this3.isCompressed && request.response) {\n              cMapData = new Uint8Array(request.response);\n            } else if (!_this3.isCompressed && request.responseText) {\n              cMapData = (0, _util.stringToBytes)(request.responseText);\n            }\n\n            if (cMapData) {\n              resolve({\n                cMapData: cMapData,\n                compressionType: compressionType\n              });\n              return;\n            }\n          }\n\n          reject(new Error(request.statusText));\n        };\n\n        request.send(null);\n      });\n    }\n  }]);\n\n  return DOMCMapReaderFactory;\n}(BaseCMapReaderFactory);\n\nexports.DOMCMapReaderFactory = DOMCMapReaderFactory;\n\nvar DOMSVGFactory = /*#__PURE__*/function () {\n  function DOMSVGFactory() {\n    _classCallCheck(this, DOMSVGFactory);\n  }\n\n  _createClass(DOMSVGFactory, [{\n    key: \"create\",\n    value: function create(width, height) {\n      (0, _util.assert)(width > 0 && height > 0, \"Invalid SVG dimensions\");\n      var svg = document.createElementNS(SVG_NS, \"svg:svg\");\n      svg.setAttribute(\"version\", \"1.1\");\n      svg.setAttribute(\"width\", width + \"px\");\n      svg.setAttribute(\"height\", height + \"px\");\n      svg.setAttribute(\"preserveAspectRatio\", \"none\");\n      svg.setAttribute(\"viewBox\", \"0 0 \" + width + \" \" + height);\n      return svg;\n    }\n  }, {\n    key: \"createElement\",\n    value: function createElement(type) {\n      (0, _util.assert)(typeof type === \"string\", \"Invalid SVG element type\");\n      return document.createElementNS(SVG_NS, type);\n    }\n  }]);\n\n  return DOMSVGFactory;\n}();\n\nexports.DOMSVGFactory = DOMSVGFactory;\n\nvar PageViewport = /*#__PURE__*/function () {\n  function PageViewport(_ref5) {\n    var viewBox = _ref5.viewBox,\n        scale = _ref5.scale,\n        rotation = _ref5.rotation,\n        _ref5$offsetX = _ref5.offsetX,\n        offsetX = _ref5$offsetX === void 0 ? 0 : _ref5$offsetX,\n        _ref5$offsetY = _ref5.offsetY,\n        offsetY = _ref5$offsetY === void 0 ? 0 : _ref5$offsetY,\n        _ref5$dontFlip = _ref5.dontFlip,\n        dontFlip = _ref5$dontFlip === void 0 ? false : _ref5$dontFlip;\n\n    _classCallCheck(this, PageViewport);\n\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    var centerX = (viewBox[2] + viewBox[0]) / 2;\n    var centerY = (viewBox[3] + viewBox[1]) / 2;\n    var rotateA, rotateB, rotateC, rotateD;\n    rotation = rotation % 360;\n    rotation = rotation < 0 ? rotation + 360 : rotation;\n\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n\n      default:\n        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n    }\n\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n\n    var offsetCanvasX, offsetCanvasY;\n    var width, height;\n\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n      height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n      height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n    }\n\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n    this.width = width;\n    this.height = height;\n  }\n\n  _createClass(PageViewport, [{\n    key: \"clone\",\n    value: function clone() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref6$scale = _ref6.scale,\n          scale = _ref6$scale === void 0 ? this.scale : _ref6$scale,\n          _ref6$rotation = _ref6.rotation,\n          rotation = _ref6$rotation === void 0 ? this.rotation : _ref6$rotation,\n          _ref6$offsetX = _ref6.offsetX,\n          offsetX = _ref6$offsetX === void 0 ? this.offsetX : _ref6$offsetX,\n          _ref6$offsetY = _ref6.offsetY,\n          offsetY = _ref6$offsetY === void 0 ? this.offsetY : _ref6$offsetY,\n          _ref6$dontFlip = _ref6.dontFlip,\n          dontFlip = _ref6$dontFlip === void 0 ? false : _ref6$dontFlip;\n\n      return new PageViewport({\n        viewBox: this.viewBox.slice(),\n        scale: scale,\n        rotation: rotation,\n        offsetX: offsetX,\n        offsetY: offsetY,\n        dontFlip: dontFlip\n      });\n    }\n  }, {\n    key: \"convertToViewportPoint\",\n    value: function convertToViewportPoint(x, y) {\n      return _util.Util.applyTransform([x, y], this.transform);\n    }\n  }, {\n    key: \"convertToViewportRectangle\",\n    value: function convertToViewportRectangle(rect) {\n      var topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\n\n      var bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\n\n      return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n    }\n  }, {\n    key: \"convertToPdfPoint\",\n    value: function convertToPdfPoint(x, y) {\n      return _util.Util.applyInverseTransform([x, y], this.transform);\n    }\n  }]);\n\n  return PageViewport;\n}();\n\nexports.PageViewport = PageViewport;\n\nvar RenderingCancelledException = /*#__PURE__*/function (_BaseException) {\n  _inherits(RenderingCancelledException, _BaseException);\n\n  var _super3 = _createSuper(RenderingCancelledException);\n\n  function RenderingCancelledException(msg, type) {\n    var _this4;\n\n    _classCallCheck(this, RenderingCancelledException);\n\n    _this4 = _super3.call(this, msg);\n    _this4.type = type;\n    return _this4;\n  }\n\n  return RenderingCancelledException;\n}(_util.BaseException);\n\nexports.RenderingCancelledException = RenderingCancelledException;\nvar LinkTarget = {\n  NONE: 0,\n  SELF: 1,\n  BLANK: 2,\n  PARENT: 3,\n  TOP: 4\n};\nexports.LinkTarget = LinkTarget;\n\nfunction addLinkAttributes(link) {\n  var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      url = _ref7.url,\n      target = _ref7.target,\n      rel = _ref7.rel,\n      _ref7$enabled = _ref7.enabled,\n      enabled = _ref7$enabled === void 0 ? true : _ref7$enabled;\n\n  (0, _util.assert)(url && typeof url === \"string\", 'addLinkAttributes: A valid \"url\" parameter must provided.');\n  var urlNullRemoved = (0, _util.removeNullCharacters)(url);\n\n  if (enabled) {\n    link.href = link.title = urlNullRemoved;\n  } else {\n    link.href = \"\";\n    link.title = \"Disabled: \".concat(urlNullRemoved);\n\n    link.onclick = function () {\n      return false;\n    };\n  }\n\n  var targetStr = \"\";\n\n  switch (target) {\n    case LinkTarget.NONE:\n      break;\n\n    case LinkTarget.SELF:\n      targetStr = \"_self\";\n      break;\n\n    case LinkTarget.BLANK:\n      targetStr = \"_blank\";\n      break;\n\n    case LinkTarget.PARENT:\n      targetStr = \"_parent\";\n      break;\n\n    case LinkTarget.TOP:\n      targetStr = \"_top\";\n      break;\n  }\n\n  link.target = targetStr;\n  link.rel = typeof rel === \"string\" ? rel : DEFAULT_LINK_REL;\n}\n\nfunction getFilenameFromUrl(url) {\n  var anchor = url.indexOf(\"#\");\n  var query = url.indexOf(\"?\");\n  var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\n  return url.substring(url.lastIndexOf(\"/\", end) + 1, end);\n}\n\nvar StatTimer = /*#__PURE__*/function () {\n  function StatTimer() {\n    _classCallCheck(this, StatTimer);\n\n    this.started = Object.create(null);\n    this.times = [];\n  }\n\n  _createClass(StatTimer, [{\n    key: \"time\",\n    value: function time(name) {\n      if (name in this.started) {\n        (0, _util.warn)(\"Timer is already running for \".concat(name));\n      }\n\n      this.started[name] = Date.now();\n    }\n  }, {\n    key: \"timeEnd\",\n    value: function timeEnd(name) {\n      if (!(name in this.started)) {\n        (0, _util.warn)(\"Timer has not been started for \".concat(name));\n      }\n\n      this.times.push({\n        name: name,\n        start: this.started[name],\n        end: Date.now()\n      });\n      delete this.started[name];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var outBuf = [];\n      var longest = 0;\n\n      var _iterator = _createForOfIteratorHelper(this.times),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var time = _step.value;\n          var name = time.name;\n\n          if (name.length > longest) {\n            longest = name.length;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this.times),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _time = _step2.value;\n          var duration = _time.end - _time.start;\n          outBuf.push(\"\".concat(_time.name.padEnd(longest), \" \").concat(duration, \"ms\\n\"));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return outBuf.join(\"\");\n    }\n  }]);\n\n  return StatTimer;\n}();\n\nexports.StatTimer = StatTimer;\n\nfunction isFetchSupported() {\n  return typeof fetch !== \"undefined\" && typeof Response !== \"undefined\" && \"body\" in Response.prototype && typeof ReadableStream !== \"undefined\";\n}\n\nfunction isValidFetchUrl(url, baseUrl) {\n  try {\n    var _ref8 = baseUrl ? new URL(url, baseUrl) : new URL(url),\n        protocol = _ref8.protocol;\n\n    return protocol === \"http:\" || protocol === \"https:\";\n  } catch (ex) {\n    return false;\n  }\n}\n\nfunction loadScript(src) {\n  var removeScriptElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return new Promise(function (resolve, reject) {\n    var script = document.createElement(\"script\");\n    script.src = src;\n\n    script.onload = function (evt) {\n      if (removeScriptElement) {\n        script.remove();\n      }\n\n      resolve(evt);\n    };\n\n    script.onerror = function () {\n      reject(new Error(\"Cannot load script at: \".concat(script.src)));\n    };\n\n    (document.head || document.documentElement).appendChild(script);\n  });\n}\n\nfunction deprecated(details) {\n  console.log(\"Deprecated API usage: \" + details);\n}\n\nvar pdfDateStringRegex;\n\nvar PDFDateString = /*#__PURE__*/function () {\n  function PDFDateString() {\n    _classCallCheck(this, PDFDateString);\n  }\n\n  _createClass(PDFDateString, null, [{\n    key: \"toDateObject\",\n    value: function toDateObject(input) {\n      if (!input || !(0, _util.isString)(input)) {\n        return null;\n      }\n\n      if (!pdfDateStringRegex) {\n        pdfDateStringRegex = new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n      }\n\n      var matches = pdfDateStringRegex.exec(input);\n\n      if (!matches) {\n        return null;\n      }\n\n      var year = parseInt(matches[1], 10);\n      var month = parseInt(matches[2], 10);\n      month = month >= 1 && month <= 12 ? month - 1 : 0;\n      var day = parseInt(matches[3], 10);\n      day = day >= 1 && day <= 31 ? day : 1;\n      var hour = parseInt(matches[4], 10);\n      hour = hour >= 0 && hour <= 23 ? hour : 0;\n      var minute = parseInt(matches[5], 10);\n      minute = minute >= 0 && minute <= 59 ? minute : 0;\n      var second = parseInt(matches[6], 10);\n      second = second >= 0 && second <= 59 ? second : 0;\n      var universalTimeRelation = matches[7] || \"Z\";\n      var offsetHour = parseInt(matches[8], 10);\n      offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n      var offsetMinute = parseInt(matches[9], 10) || 0;\n      offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n\n      if (universalTimeRelation === \"-\") {\n        hour += offsetHour;\n        minute += offsetMinute;\n      } else if (universalTimeRelation === \"+\") {\n        hour -= offsetHour;\n        minute -= offsetMinute;\n      }\n\n      return new Date(Date.UTC(year, month, day, hour, minute, second));\n    }\n  }]);\n\n  return PDFDateString;\n}();\n\nexports.PDFDateString = PDFDateString;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __w_pdfjs_require__(3);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n/* module decorator */ module = __w_pdfjs_require__.nmd(module);\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar runtime = function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined;\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  exports.wrap = wrap;\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n  var ContinueSentinel = {};\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {}\n\n  var IteratorPrototype = {};\n\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && _typeof(value) === \"object\" && hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    }\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n\n  exports.AsyncIterator = AsyncIterator;\n\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === \"normal\") {\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator[\"return\"]) {\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      context[delegate.resultName] = info.value;\n      context.next = delegate.nextLoc;\n\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      return info;\n    }\n\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  defineIteratorMethods(Gp);\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  Gp[iteratorSymbol] = function () {\n    return this;\n  };\n\n  Gp.toString = function () {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse();\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    return {\n      next: doneResult\n    };\n  }\n\n  exports.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function stop() {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      }\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n  return exports;\n}((  false ? 0 : _typeof(module)) === \"object\" ? module.exports : {});\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n\n/***/ }),\n/* 4 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.arrayByteLength = arrayByteLength;\nexports.arraysToBytes = arraysToBytes;\nexports.assert = assert;\nexports.bytesToString = bytesToString;\nexports.createPromiseCapability = createPromiseCapability;\nexports.createValidAbsoluteUrl = createValidAbsoluteUrl;\nexports.encodeToXmlString = encodeToXmlString;\nexports.escapeString = escapeString;\nexports.getModificationDate = getModificationDate;\nexports.getVerbosityLevel = getVerbosityLevel;\nexports.info = info;\nexports.isArrayBuffer = isArrayBuffer;\nexports.isArrayEqual = isArrayEqual;\nexports.isAscii = isAscii;\nexports.isBool = isBool;\nexports.isNum = isNum;\nexports.isSameOrigin = isSameOrigin;\nexports.isString = isString;\nexports.objectFromEntries = objectFromEntries;\nexports.objectSize = objectSize;\nexports.removeNullCharacters = removeNullCharacters;\nexports.setVerbosityLevel = setVerbosityLevel;\nexports.shadow = shadow;\nexports.string32 = string32;\nexports.stringToBytes = stringToBytes;\nexports.stringToPDFString = stringToPDFString;\nexports.stringToUTF16BEString = stringToUTF16BEString;\nexports.stringToUTF8String = stringToUTF8String;\nexports.unreachable = unreachable;\nexports.utf8StringToString = utf8StringToString;\nexports.warn = warn;\nexports.VerbosityLevel = exports.Util = exports.UNSUPPORTED_FEATURES = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.createObjectURL = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;\n\n__w_pdfjs_require__(5);\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\nexports.IDENTITY_MATRIX = IDENTITY_MATRIX;\nvar FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nexports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\nvar PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nexports.PermissionFlag = PermissionFlag;\nvar TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nexports.TextRenderingMode = TextRenderingMode;\nvar ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nexports.ImageKind = ImageKind;\nvar AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nexports.AnnotationType = AnnotationType;\nvar AnnotationStateModelType = {\n  MARKED: \"Marked\",\n  REVIEW: \"Review\"\n};\nexports.AnnotationStateModelType = AnnotationStateModelType;\nvar AnnotationMarkedState = {\n  MARKED: \"Marked\",\n  UNMARKED: \"Unmarked\"\n};\nexports.AnnotationMarkedState = AnnotationMarkedState;\nvar AnnotationReviewState = {\n  ACCEPTED: \"Accepted\",\n  REJECTED: \"Rejected\",\n  CANCELLED: \"Cancelled\",\n  COMPLETED: \"Completed\",\n  NONE: \"None\"\n};\nexports.AnnotationReviewState = AnnotationReviewState;\nvar AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\"\n};\nexports.AnnotationReplyType = AnnotationReplyType;\nvar AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nexports.AnnotationFlag = AnnotationFlag;\nvar AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nexports.AnnotationFieldFlag = AnnotationFieldFlag;\nvar AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nexports.AnnotationBorderStyleType = AnnotationBorderStyleType;\nvar AnnotationActionEventType = {\n  E: \"Mouse Enter\",\n  X: \"Mouse Exit\",\n  D: \"Mouse Down\",\n  U: \"Mouse Up\",\n  Fo: \"Focus\",\n  Bl: \"Blur\",\n  PO: \"PageOpen\",\n  PC: \"PageClose\",\n  PV: \"PageVisible\",\n  PI: \"PageInvisible\",\n  K: \"Keystroke\",\n  F: \"Format\",\n  V: \"Validate\",\n  C: \"Calculate\"\n};\nexports.AnnotationActionEventType = AnnotationActionEventType;\nvar DocumentActionEventType = {\n  WC: \"WillClose\",\n  WS: \"WillSave\",\n  DS: \"DidSave\",\n  WP: \"WillPrint\",\n  DP: \"DidPrint\"\n};\nexports.DocumentActionEventType = DocumentActionEventType;\nvar PageActionEventType = {\n  O: \"PageOpen\",\n  C: \"PageClose\"\n};\nexports.PageActionEventType = PageActionEventType;\nvar StreamType = {\n  UNKNOWN: \"UNKNOWN\",\n  FLATE: \"FLATE\",\n  LZW: \"LZW\",\n  DCT: \"DCT\",\n  JPX: \"JPX\",\n  JBIG: \"JBIG\",\n  A85: \"A85\",\n  AHX: \"AHX\",\n  CCF: \"CCF\",\n  RLX: \"RLX\"\n};\nexports.StreamType = StreamType;\nvar FontType = {\n  UNKNOWN: \"UNKNOWN\",\n  TYPE1: \"TYPE1\",\n  TYPE1C: \"TYPE1C\",\n  CIDFONTTYPE0: \"CIDFONTTYPE0\",\n  CIDFONTTYPE0C: \"CIDFONTTYPE0C\",\n  TRUETYPE: \"TRUETYPE\",\n  CIDFONTTYPE2: \"CIDFONTTYPE2\",\n  TYPE3: \"TYPE3\",\n  OPENTYPE: \"OPENTYPE\",\n  TYPE0: \"TYPE0\",\n  MMTYPE1: \"MMTYPE1\"\n};\nexports.FontType = FontType;\nvar VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nexports.VerbosityLevel = VerbosityLevel;\nvar CMapCompressionType = {\n  NONE: 0,\n  BINARY: 1,\n  STREAM: 2\n};\nexports.CMapCompressionType = CMapCompressionType;\nvar OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotations: 78,\n  endAnnotations: 79,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintJpegXObject: 82,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91\n};\nexports.OPS = OPS;\nvar UNSUPPORTED_FEATURES = {\n  unknown: \"unknown\",\n  forms: \"forms\",\n  javaScript: \"javaScript\",\n  smask: \"smask\",\n  shadingPattern: \"shadingPattern\",\n  font: \"font\",\n  errorTilingPattern: \"errorTilingPattern\",\n  errorExtGState: \"errorExtGState\",\n  errorXObject: \"errorXObject\",\n  errorFontLoadType3: \"errorFontLoadType3\",\n  errorFontState: \"errorFontState\",\n  errorFontMissing: \"errorFontMissing\",\n  errorFontTranslate: \"errorFontTranslate\",\n  errorColorSpace: \"errorColorSpace\",\n  errorOperatorList: \"errorOperatorList\",\n  errorFontToUnicode: \"errorFontToUnicode\",\n  errorFontLoadNative: \"errorFontLoadNative\",\n  errorFontGetPath: \"errorFontGetPath\",\n  errorMarkedContent: \"errorMarkedContent\"\n};\nexports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;\nvar PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nexports.PasswordResponses = PasswordResponses;\nvar verbosity = VerbosityLevel.WARNINGS;\n\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\n\nfunction getVerbosityLevel() {\n  return verbosity;\n}\n\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(\"Info: \".concat(msg));\n  }\n}\n\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(\"Warning: \".concat(msg));\n  }\n}\n\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\n\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\n\nfunction isSameOrigin(baseUrl, otherUrl) {\n  var base;\n\n  try {\n    base = new URL(baseUrl);\n\n    if (!base.origin || base.origin === \"null\") {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n\n  var other = new URL(otherUrl, base);\n  return base.origin === other.origin;\n}\n\nfunction _isValidProtocol(url) {\n  if (!url) {\n    return false;\n  }\n\n  switch (url.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction createValidAbsoluteUrl(url, baseUrl) {\n  if (!url) {\n    return null;\n  }\n\n  try {\n    var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n\n    if (_isValidProtocol(absoluteUrl)) {\n      return absoluteUrl;\n    }\n  } catch (ex) {}\n\n  return null;\n}\n\nfunction shadow(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    value: value,\n    enumerable: true,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\n\nvar BaseException = function BaseExceptionClosure() {\n  function BaseException(message) {\n    if (this.constructor === BaseException) {\n      unreachable(\"Cannot initialize BaseException.\");\n    }\n\n    this.message = message;\n    this.name = this.constructor.name;\n  }\n\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\n\nexports.BaseException = BaseException;\n\nvar PasswordException = /*#__PURE__*/function (_BaseException) {\n  _inherits(PasswordException, _BaseException);\n\n  var _super = _createSuper(PasswordException);\n\n  function PasswordException(msg, code) {\n    var _this;\n\n    _classCallCheck(this, PasswordException);\n\n    _this = _super.call(this, msg);\n    _this.code = code;\n    return _this;\n  }\n\n  return PasswordException;\n}(BaseException);\n\nexports.PasswordException = PasswordException;\n\nvar UnknownErrorException = /*#__PURE__*/function (_BaseException2) {\n  _inherits(UnknownErrorException, _BaseException2);\n\n  var _super2 = _createSuper(UnknownErrorException);\n\n  function UnknownErrorException(msg, details) {\n    var _this2;\n\n    _classCallCheck(this, UnknownErrorException);\n\n    _this2 = _super2.call(this, msg);\n    _this2.details = details;\n    return _this2;\n  }\n\n  return UnknownErrorException;\n}(BaseException);\n\nexports.UnknownErrorException = UnknownErrorException;\n\nvar InvalidPDFException = /*#__PURE__*/function (_BaseException3) {\n  _inherits(InvalidPDFException, _BaseException3);\n\n  var _super3 = _createSuper(InvalidPDFException);\n\n  function InvalidPDFException() {\n    _classCallCheck(this, InvalidPDFException);\n\n    return _super3.apply(this, arguments);\n  }\n\n  return InvalidPDFException;\n}(BaseException);\n\nexports.InvalidPDFException = InvalidPDFException;\n\nvar MissingPDFException = /*#__PURE__*/function (_BaseException4) {\n  _inherits(MissingPDFException, _BaseException4);\n\n  var _super4 = _createSuper(MissingPDFException);\n\n  function MissingPDFException() {\n    _classCallCheck(this, MissingPDFException);\n\n    return _super4.apply(this, arguments);\n  }\n\n  return MissingPDFException;\n}(BaseException);\n\nexports.MissingPDFException = MissingPDFException;\n\nvar UnexpectedResponseException = /*#__PURE__*/function (_BaseException5) {\n  _inherits(UnexpectedResponseException, _BaseException5);\n\n  var _super5 = _createSuper(UnexpectedResponseException);\n\n  function UnexpectedResponseException(msg, status) {\n    var _this3;\n\n    _classCallCheck(this, UnexpectedResponseException);\n\n    _this3 = _super5.call(this, msg);\n    _this3.status = status;\n    return _this3;\n  }\n\n  return UnexpectedResponseException;\n}(BaseException);\n\nexports.UnexpectedResponseException = UnexpectedResponseException;\n\nvar FormatError = /*#__PURE__*/function (_BaseException6) {\n  _inherits(FormatError, _BaseException6);\n\n  var _super6 = _createSuper(FormatError);\n\n  function FormatError() {\n    _classCallCheck(this, FormatError);\n\n    return _super6.apply(this, arguments);\n  }\n\n  return FormatError;\n}(BaseException);\n\nexports.FormatError = FormatError;\n\nvar AbortException = /*#__PURE__*/function (_BaseException7) {\n  _inherits(AbortException, _BaseException7);\n\n  var _super7 = _createSuper(AbortException);\n\n  function AbortException() {\n    _classCallCheck(this, AbortException);\n\n    return _super7.apply(this, arguments);\n  }\n\n  return AbortException;\n}(BaseException);\n\nexports.AbortException = AbortException;\nvar NullCharactersRegExp = /\\x00/g;\n\nfunction removeNullCharacters(str) {\n  if (typeof str !== \"string\") {\n    warn(\"The argument for removeNullCharacters must be a string.\");\n    return str;\n  }\n\n  return str.replace(NullCharactersRegExp, \"\");\n}\n\nfunction bytesToString(bytes) {\n  assert(bytes !== null && _typeof(bytes) === \"object\" && bytes.length !== undefined, \"Invalid argument for bytesToString\");\n  var length = bytes.length;\n  var MAX_ARGUMENT_COUNT = 8192;\n\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n\n  var strBuf = [];\n\n  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    var chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n\n  return strBuf.join(\"\");\n}\n\nfunction stringToBytes(str) {\n  assert(typeof str === \"string\", \"Invalid argument for stringToBytes\");\n  var length = str.length;\n  var bytes = new Uint8Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n\n  return bytes;\n}\n\nfunction arrayByteLength(arr) {\n  if (arr.length !== undefined) {\n    return arr.length;\n  }\n\n  assert(arr.byteLength !== undefined, \"arrayByteLength - invalid argument.\");\n  return arr.byteLength;\n}\n\nfunction arraysToBytes(arr) {\n  var length = arr.length;\n\n  if (length === 1 && arr[0] instanceof Uint8Array) {\n    return arr[0];\n  }\n\n  var resultLength = 0;\n\n  for (var i = 0; i < length; i++) {\n    resultLength += arrayByteLength(arr[i]);\n  }\n\n  var pos = 0;\n  var data = new Uint8Array(resultLength);\n\n  for (var _i = 0; _i < length; _i++) {\n    var item = arr[_i];\n\n    if (!(item instanceof Uint8Array)) {\n      if (typeof item === \"string\") {\n        item = stringToBytes(item);\n      } else {\n        item = new Uint8Array(item);\n      }\n    }\n\n    var itemLength = item.byteLength;\n    data.set(item, pos);\n    pos += itemLength;\n  }\n\n  return data;\n}\n\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\n\nfunction objectSize(obj) {\n  return Object.keys(obj).length;\n}\n\nfunction objectFromEntries(iterable) {\n  return Object.assign(Object.create(null), Object.fromEntries(iterable));\n}\n\nfunction isLittleEndian() {\n  var buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  var view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\n\nvar IsLittleEndianCached = {\n  get value() {\n    return shadow(this, \"value\", isLittleEndian());\n  }\n\n};\nexports.IsLittleEndianCached = IsLittleEndianCached;\n\nfunction isEvalSupported() {\n  try {\n    new Function(\"\");\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar IsEvalSupportedCached = {\n  get value() {\n    return shadow(this, \"value\", isEvalSupported());\n  }\n\n};\nexports.IsEvalSupportedCached = IsEvalSupportedCached;\n\nvar hexNumbers = _toConsumableArray(Array(256).keys()).map(function (n) {\n  return n.toString(16).padStart(2, \"0\");\n});\n\nvar Util = /*#__PURE__*/function () {\n  function Util() {\n    _classCallCheck(this, Util);\n  }\n\n  _createClass(Util, null, [{\n    key: \"makeHexColor\",\n    value: function makeHexColor(r, g, b) {\n      return \"#\".concat(hexNumbers[r]).concat(hexNumbers[g]).concat(hexNumbers[b]);\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(m1, m2) {\n      return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n    }\n  }, {\n    key: \"applyTransform\",\n    value: function applyTransform(p, m) {\n      var xt = p[0] * m[0] + p[1] * m[2] + m[4];\n      var yt = p[0] * m[1] + p[1] * m[3] + m[5];\n      return [xt, yt];\n    }\n  }, {\n    key: \"applyInverseTransform\",\n    value: function applyInverseTransform(p, m) {\n      var d = m[0] * m[3] - m[1] * m[2];\n      var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n      var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n      return [xt, yt];\n    }\n  }, {\n    key: \"getAxialAlignedBoundingBox\",\n    value: function getAxialAlignedBoundingBox(r, m) {\n      var p1 = Util.applyTransform(r, m);\n      var p2 = Util.applyTransform(r.slice(2, 4), m);\n      var p3 = Util.applyTransform([r[0], r[3]], m);\n      var p4 = Util.applyTransform([r[2], r[1]], m);\n      return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n    }\n  }, {\n    key: \"inverseTransform\",\n    value: function inverseTransform(m) {\n      var d = m[0] * m[3] - m[1] * m[2];\n      return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n    }\n  }, {\n    key: \"apply3dTransform\",\n    value: function apply3dTransform(m, v) {\n      return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n    }\n  }, {\n    key: \"singularValueDecompose2dScale\",\n    value: function singularValueDecompose2dScale(m) {\n      var transpose = [m[0], m[2], m[1], m[3]];\n      var a = m[0] * transpose[0] + m[1] * transpose[2];\n      var b = m[0] * transpose[1] + m[1] * transpose[3];\n      var c = m[2] * transpose[0] + m[3] * transpose[2];\n      var d = m[2] * transpose[1] + m[3] * transpose[3];\n      var first = (a + d) / 2;\n      var second = Math.sqrt(Math.pow(a + d, 2) - 4 * (a * d - c * b)) / 2;\n      var sx = first + second || 1;\n      var sy = first - second || 1;\n      return [Math.sqrt(sx), Math.sqrt(sy)];\n    }\n  }, {\n    key: \"normalizeRect\",\n    value: function normalizeRect(rect) {\n      var r = rect.slice(0);\n\n      if (rect[0] > rect[2]) {\n        r[0] = rect[2];\n        r[2] = rect[0];\n      }\n\n      if (rect[1] > rect[3]) {\n        r[1] = rect[3];\n        r[3] = rect[1];\n      }\n\n      return r;\n    }\n  }, {\n    key: \"intersect\",\n    value: function intersect(rect1, rect2) {\n      function compare(a, b) {\n        return a - b;\n      }\n\n      var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);\n      var orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);\n      var result = [];\n      rect1 = Util.normalizeRect(rect1);\n      rect2 = Util.normalizeRect(rect2);\n\n      if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {\n        result[0] = orderedX[1];\n        result[2] = orderedX[2];\n      } else {\n        return null;\n      }\n\n      if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {\n        result[1] = orderedY[1];\n        result[3] = orderedY[2];\n      } else {\n        return null;\n      }\n\n      return result;\n    }\n  }]);\n\n  return Util;\n}();\n\nexports.Util = Util;\nvar PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];\n\nfunction stringToPDFString(str) {\n  var length = str.length,\n      strBuf = [];\n\n  if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n    for (var i = 2; i < length; i += 2) {\n      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));\n    }\n  } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n    for (var _i2 = 2; _i2 < length; _i2 += 2) {\n      strBuf.push(String.fromCharCode(str.charCodeAt(_i2 + 1) << 8 | str.charCodeAt(_i2)));\n    }\n  } else {\n    for (var _i3 = 0; _i3 < length; ++_i3) {\n      var code = PDFStringTranslateTable[str.charCodeAt(_i3)];\n      strBuf.push(code ? String.fromCharCode(code) : str.charAt(_i3));\n    }\n  }\n\n  return strBuf.join(\"\");\n}\n\nfunction escapeString(str) {\n  return str.replace(/([()\\\\\\n\\r])/g, function (match) {\n    if (match === \"\\n\") {\n      return \"\\\\n\";\n    } else if (match === \"\\r\") {\n      return \"\\\\r\";\n    }\n\n    return \"\\\\\".concat(match);\n  });\n}\n\nfunction isAscii(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\n\nfunction stringToUTF16BEString(str) {\n  var buf = [\"\\xFE\\xFF\"];\n\n  for (var i = 0, ii = str.length; i < ii; i++) {\n    var _char = str.charCodeAt(i);\n\n    buf.push(String.fromCharCode(_char >> 8 & 0xff));\n    buf.push(String.fromCharCode(_char & 0xff));\n  }\n\n  return buf.join(\"\");\n}\n\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\n\nfunction isBool(v) {\n  return typeof v === \"boolean\";\n}\n\nfunction isNum(v) {\n  return typeof v === \"number\";\n}\n\nfunction isString(v) {\n  return typeof v === \"string\";\n}\n\nfunction isArrayBuffer(v) {\n  return _typeof(v) === \"object\" && v !== null && v.byteLength !== undefined;\n}\n\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  return arr1.every(function (element, index) {\n    return element === arr2[index];\n  });\n}\n\nfunction getModificationDate() {\n  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n  var buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n  return buffer.join(\"\");\n}\n\nfunction createPromiseCapability() {\n  var capability = Object.create(null);\n  var isSettled = false;\n  Object.defineProperty(capability, \"settled\", {\n    get: function get() {\n      return isSettled;\n    }\n  });\n  capability.promise = new Promise(function (resolve, reject) {\n    capability.resolve = function (data) {\n      isSettled = true;\n      resolve(data);\n    };\n\n    capability.reject = function (reason) {\n      isSettled = true;\n      reject(reason);\n    };\n  });\n  return capability;\n}\n\nvar createObjectURL = function createObjectURLClosure() {\n  var digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  return function createObjectURL(data, contentType) {\n    var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!forceDataSchema && URL.createObjectURL) {\n      var blob = new Blob([data], {\n        type: contentType\n      });\n      return URL.createObjectURL(blob);\n    }\n\n    var buffer = \"data:\".concat(contentType, \";base64,\");\n\n    for (var i = 0, ii = data.length; i < ii; i += 3) {\n      var b1 = data[i] & 0xff;\n      var b2 = data[i + 1] & 0xff;\n      var b3 = data[i + 2] & 0xff;\n      var d1 = b1 >> 2,\n          d2 = (b1 & 3) << 4 | b2 >> 4;\n      var d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n      var d4 = i + 2 < ii ? b3 & 0x3f : 64;\n      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n    }\n\n    return buffer;\n  };\n}();\n\nexports.createObjectURL = createObjectURL;\nvar XMLEntities = {\n  0x3c: \"&lt;\",\n  0x3e: \"&gt;\",\n  0x26: \"&amp;\",\n  0x22: \"&quot;\",\n  0x27: \"&apos;\"\n};\n\nfunction encodeToXmlString(str) {\n  var buffer = [];\n  var start = 0;\n\n  for (var i = 0, ii = str.length; i < ii; i++) {\n    var _char2 = str.codePointAt(i);\n\n    if (0x20 <= _char2 && _char2 <= 0x7e) {\n      var entity = XMLEntities[_char2];\n\n      if (entity) {\n        if (start < i) {\n          buffer.push(str.substring(start, i));\n        }\n\n        buffer.push(entity);\n        start = i + 1;\n      }\n    } else {\n      if (start < i) {\n        buffer.push(str.substring(start, i));\n      }\n\n      buffer.push(\"&#x\".concat(_char2.toString(16).toUpperCase(), \";\"));\n\n      if (_char2 > 0xd7ff && (_char2 < 0xe000 || _char2 > 0xfffd)) {\n        i++;\n      }\n\n      start = i + 1;\n    }\n  }\n\n  if (buffer.length === 0) {\n    return str;\n  }\n\n  if (start < str.length) {\n    buffer.push(str.substring(start, str.length));\n  }\n\n  return buffer.join(\"\");\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nvar _is_node = __w_pdfjs_require__(6);\n\nif (typeof globalThis === \"undefined\" || !globalThis._pdfjsCompatibilityChecked) {\n  if (typeof globalThis === \"undefined\" || globalThis.Math !== Math) {\n    globalThis = __w_pdfjs_require__(7);\n  }\n\n  globalThis._pdfjsCompatibilityChecked = true;\n\n  (function checkNodeBtoa() {\n    if (globalThis.btoa || !_is_node.isNodeJS) {\n      return;\n    }\n\n    globalThis.btoa = function (chars) {\n      return Buffer.from(chars, \"binary\").toString(\"base64\");\n    };\n  })();\n\n  (function checkNodeAtob() {\n    if (globalThis.atob || !_is_node.isNodeJS) {\n      return;\n    }\n\n    globalThis.atob = function (input) {\n      return Buffer.from(input, \"base64\").toString(\"binary\");\n    };\n  })();\n\n  (function checkObjectFromEntries() {\n    if (Object.fromEntries) {\n      return;\n    }\n\n    __w_pdfjs_require__(52);\n  })();\n\n  (function checkPromise() {\n    if (globalThis.Promise.allSettled) {\n      return;\n    }\n\n    globalThis.Promise = __w_pdfjs_require__(82);\n  })();\n\n  (function checkURL() {\n    globalThis.URL = __w_pdfjs_require__(111);\n  })();\n\n  (function checkReadableStream() {\n    var isReadableStreamSupported = false;\n\n    if (typeof ReadableStream !== \"undefined\") {\n      try {\n        new ReadableStream({\n          start: function start(controller) {\n            controller.close();\n          }\n        });\n        isReadableStreamSupported = true;\n      } catch (e) {}\n    }\n\n    if (isReadableStreamSupported) {\n      return;\n    }\n\n    globalThis.ReadableStream = __w_pdfjs_require__(121).ReadableStream;\n  })();\n\n  (function checkStringPadStart() {\n    if (String.prototype.padStart) {\n      return;\n    }\n\n    __w_pdfjs_require__(122);\n  })();\n\n  (function checkStringPadEnd() {\n    if (String.prototype.padEnd) {\n      return;\n    }\n\n    __w_pdfjs_require__(128);\n  })();\n\n  (function checkObjectValues() {\n    if (Object.values) {\n      return;\n    }\n\n    Object.values = __w_pdfjs_require__(130);\n  })();\n\n  (function checkObjectEntries() {\n    if (Object.entries) {\n      return;\n    }\n\n    Object.entries = __w_pdfjs_require__(133);\n  })();\n}\n\n/***/ }),\n/* 6 */\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isNodeJS = void 0;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar isNodeJS = (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nexports.isNodeJS = isNodeJS;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(8);\nmodule.exports = __w_pdfjs_require__(10);\n\n/***/ }),\n/* 8 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(9);\nvar global = __w_pdfjs_require__(10);\n$({ global: true }, { globalThis: global });\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nvar getOwnPropertyDescriptor = __w_pdfjs_require__(11).f;\nvar createNonEnumerableProperty = __w_pdfjs_require__(25);\nvar redefine = __w_pdfjs_require__(28);\nvar setGlobal = __w_pdfjs_require__(29);\nvar copyConstructorProperties = __w_pdfjs_require__(39);\nvar isForced = __w_pdfjs_require__(51);\nmodule.exports = function (options, source) {\n var TARGET = options.target;\n var GLOBAL = options.global;\n var STATIC = options.stat;\n var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n if (GLOBAL) {\n  target = global;\n } else if (STATIC) {\n  target = global[TARGET] || setGlobal(TARGET, {});\n } else {\n  target = (global[TARGET] || {}).prototype;\n }\n if (target)\n  for (key in source) {\n   sourceProperty = source[key];\n   if (options.noTargetGet) {\n    descriptor = getOwnPropertyDescriptor(target, key);\n    targetProperty = descriptor && descriptor.value;\n   } else\n    targetProperty = target[key];\n   FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n   if (!FORCED && targetProperty !== undefined) {\n    if (typeof sourceProperty === typeof targetProperty)\n     continue;\n    copyConstructorProperties(sourceProperty, targetProperty);\n   }\n   if (options.sham || targetProperty && targetProperty.sham) {\n    createNonEnumerableProperty(sourceProperty, 'sham', true);\n   }\n   redefine(target, key, sourceProperty, options);\n  }\n};\n\n/***/ }),\n/* 10 */\n/***/ (function(module) {\n\nvar check = function (it) {\n return it && it.Math == Math && it;\n};\nmodule.exports = check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) || function () {\n return this;\n}() || Function('return this')();\n\n/***/ }),\n/* 11 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(12);\nvar propertyIsEnumerableModule = __w_pdfjs_require__(14);\nvar createPropertyDescriptor = __w_pdfjs_require__(15);\nvar toIndexedObject = __w_pdfjs_require__(16);\nvar toPrimitive = __w_pdfjs_require__(20);\nvar has = __w_pdfjs_require__(22);\nvar IE8_DOM_DEFINE = __w_pdfjs_require__(23);\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nexports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n O = toIndexedObject(O);\n P = toPrimitive(P, true);\n if (IE8_DOM_DEFINE)\n  try {\n   return nativeGetOwnPropertyDescriptor(O, P);\n  } catch (error) {\n  }\n if (has(O, P))\n  return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(13);\nmodule.exports = !fails(function () {\n return Object.defineProperty({}, 1, {\n  get: function () {\n   return 7;\n  }\n })[1] != 7;\n});\n\n/***/ }),\n/* 13 */\n/***/ (function(module) {\n\nmodule.exports = function (exec) {\n try {\n  return !!exec();\n } catch (error) {\n  return true;\n }\n};\n\n/***/ }),\n/* 14 */\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\nvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n var descriptor = getOwnPropertyDescriptor(this, V);\n return !!descriptor && descriptor.enumerable;\n} : nativePropertyIsEnumerable;\n\n/***/ }),\n/* 15 */\n/***/ (function(module) {\n\nmodule.exports = function (bitmap, value) {\n return {\n  enumerable: !(bitmap & 1),\n  configurable: !(bitmap & 2),\n  writable: !(bitmap & 4),\n  value: value\n };\n};\n\n/***/ }),\n/* 16 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar IndexedObject = __w_pdfjs_require__(17);\nvar requireObjectCoercible = __w_pdfjs_require__(19);\nmodule.exports = function (it) {\n return IndexedObject(requireObjectCoercible(it));\n};\n\n/***/ }),\n/* 17 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(13);\nvar classof = __w_pdfjs_require__(18);\nvar split = ''.split;\nmodule.exports = fails(function () {\n return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n\n/***/ }),\n/* 18 */\n/***/ (function(module) {\n\nvar toString = {}.toString;\nmodule.exports = function (it) {\n return toString.call(it).slice(8, -1);\n};\n\n/***/ }),\n/* 19 */\n/***/ (function(module) {\n\nmodule.exports = function (it) {\n if (it == undefined)\n  throw TypeError(\"Can't call method on \" + it);\n return it;\n};\n\n/***/ }),\n/* 20 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar isObject = __w_pdfjs_require__(21);\nmodule.exports = function (input, PREFERRED_STRING) {\n if (!isObject(input))\n  return input;\n var fn, val;\n if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input)))\n  return val;\n if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input)))\n  return val;\n if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input)))\n  return val;\n throw TypeError(\"Can't convert object to primitive value\");\n};\n\n/***/ }),\n/* 21 */\n/***/ (function(module) {\n\nmodule.exports = function (it) {\n return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n/***/ }),\n/* 22 */\n/***/ (function(module) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n return hasOwnProperty.call(it, key);\n};\n\n/***/ }),\n/* 23 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(12);\nvar fails = __w_pdfjs_require__(13);\nvar createElement = __w_pdfjs_require__(24);\nmodule.exports = !DESCRIPTORS && !fails(function () {\n return Object.defineProperty(createElement('div'), 'a', {\n  get: function () {\n   return 7;\n  }\n }).a != 7;\n});\n\n/***/ }),\n/* 24 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nvar isObject = __w_pdfjs_require__(21);\nvar document = global.document;\nvar EXISTS = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n return EXISTS ? document.createElement(it) : {};\n};\n\n/***/ }),\n/* 25 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(12);\nvar definePropertyModule = __w_pdfjs_require__(26);\nvar createPropertyDescriptor = __w_pdfjs_require__(15);\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n object[key] = value;\n return object;\n};\n\n/***/ }),\n/* 26 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(12);\nvar IE8_DOM_DEFINE = __w_pdfjs_require__(23);\nvar anObject = __w_pdfjs_require__(27);\nvar toPrimitive = __w_pdfjs_require__(20);\nvar nativeDefineProperty = Object.defineProperty;\nexports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n anObject(O);\n P = toPrimitive(P, true);\n anObject(Attributes);\n if (IE8_DOM_DEFINE)\n  try {\n   return nativeDefineProperty(O, P, Attributes);\n  } catch (error) {\n  }\n if ('get' in Attributes || 'set' in Attributes)\n  throw TypeError('Accessors not supported');\n if ('value' in Attributes)\n  O[P] = Attributes.value;\n return O;\n};\n\n/***/ }),\n/* 27 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar isObject = __w_pdfjs_require__(21);\nmodule.exports = function (it) {\n if (!isObject(it)) {\n  throw TypeError(String(it) + ' is not an object');\n }\n return it;\n};\n\n/***/ }),\n/* 28 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nvar createNonEnumerableProperty = __w_pdfjs_require__(25);\nvar has = __w_pdfjs_require__(22);\nvar setGlobal = __w_pdfjs_require__(29);\nvar inspectSource = __w_pdfjs_require__(30);\nvar InternalStateModule = __w_pdfjs_require__(32);\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(String).split('String');\n(module.exports = function (O, key, value, options) {\n var unsafe = options ? !!options.unsafe : false;\n var simple = options ? !!options.enumerable : false;\n var noTargetGet = options ? !!options.noTargetGet : false;\n var state;\n if (typeof value == 'function') {\n  if (typeof key == 'string' && !has(value, 'name')) {\n   createNonEnumerableProperty(value, 'name', key);\n  }\n  state = enforceInternalState(value);\n  if (!state.source) {\n   state.source = TEMPLATE.join(typeof key == 'string' ? key : '');\n  }\n }\n if (O === global) {\n  if (simple)\n   O[key] = value;\n  else\n   setGlobal(key, value);\n  return;\n } else if (!unsafe) {\n  delete O[key];\n } else if (!noTargetGet && O[key]) {\n  simple = true;\n }\n if (simple)\n  O[key] = value;\n else\n  createNonEnumerableProperty(O, key, value);\n})(Function.prototype, 'toString', function toString() {\n return typeof this == 'function' && getInternalState(this).source || inspectSource(this);\n});\n\n/***/ }),\n/* 29 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nvar createNonEnumerableProperty = __w_pdfjs_require__(25);\nmodule.exports = function (key, value) {\n try {\n  createNonEnumerableProperty(global, key, value);\n } catch (error) {\n  global[key] = value;\n }\n return value;\n};\n\n/***/ }),\n/* 30 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar store = __w_pdfjs_require__(31);\nvar functionToString = Function.toString;\nif (typeof store.inspectSource != 'function') {\n store.inspectSource = function (it) {\n  return functionToString.call(it);\n };\n}\nmodule.exports = store.inspectSource;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nvar setGlobal = __w_pdfjs_require__(29);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\nmodule.exports = store;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar NATIVE_WEAK_MAP = __w_pdfjs_require__(33);\nvar global = __w_pdfjs_require__(10);\nvar isObject = __w_pdfjs_require__(21);\nvar createNonEnumerableProperty = __w_pdfjs_require__(25);\nvar objectHas = __w_pdfjs_require__(22);\nvar shared = __w_pdfjs_require__(31);\nvar sharedKey = __w_pdfjs_require__(34);\nvar hiddenKeys = __w_pdfjs_require__(38);\nvar WeakMap = global.WeakMap;\nvar set, get, has;\nvar enforce = function (it) {\n return has(it) ? get(it) : set(it, {});\n};\nvar getterFor = function (TYPE) {\n return function (it) {\n  var state;\n  if (!isObject(it) || (state = get(it)).type !== TYPE) {\n   throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n  }\n  return state;\n };\n};\nif (NATIVE_WEAK_MAP) {\n var store = shared.state || (shared.state = new WeakMap());\n var wmget = store.get;\n var wmhas = store.has;\n var wmset = store.set;\n set = function (it, metadata) {\n  metadata.facade = it;\n  wmset.call(store, it, metadata);\n  return metadata;\n };\n get = function (it) {\n  return wmget.call(store, it) || {};\n };\n has = function (it) {\n  return wmhas.call(store, it);\n };\n} else {\n var STATE = sharedKey('state');\n hiddenKeys[STATE] = true;\n set = function (it, metadata) {\n  metadata.facade = it;\n  createNonEnumerableProperty(it, STATE, metadata);\n  return metadata;\n };\n get = function (it) {\n  return objectHas(it, STATE) ? it[STATE] : {};\n };\n has = function (it) {\n  return objectHas(it, STATE);\n };\n}\nmodule.exports = {\n set: set,\n get: get,\n has: has,\n enforce: enforce,\n getterFor: getterFor\n};\n\n/***/ }),\n/* 33 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nvar inspectSource = __w_pdfjs_require__(30);\nvar WeakMap = global.WeakMap;\nmodule.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));\n\n/***/ }),\n/* 34 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar shared = __w_pdfjs_require__(35);\nvar uid = __w_pdfjs_require__(37);\nvar keys = shared('keys');\nmodule.exports = function (key) {\n return keys[key] || (keys[key] = uid(key));\n};\n\n/***/ }),\n/* 35 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar IS_PURE = __w_pdfjs_require__(36);\nvar store = __w_pdfjs_require__(31);\n(module.exports = function (key, value) {\n return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n version: '3.8.3',\n mode: IS_PURE ? 'pure' : 'global',\n copyright: ' 2021 Denis Pushkarev (zloirock.ru)'\n});\n\n/***/ }),\n/* 36 */\n/***/ (function(module) {\n\nmodule.exports = false;\n\n/***/ }),\n/* 37 */\n/***/ (function(module) {\n\nvar id = 0;\nvar postfix = Math.random();\nmodule.exports = function (key) {\n return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n\n/***/ }),\n/* 38 */\n/***/ (function(module) {\n\nmodule.exports = {};\n\n/***/ }),\n/* 39 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar has = __w_pdfjs_require__(22);\nvar ownKeys = __w_pdfjs_require__(40);\nvar getOwnPropertyDescriptorModule = __w_pdfjs_require__(11);\nvar definePropertyModule = __w_pdfjs_require__(26);\nmodule.exports = function (target, source) {\n var keys = ownKeys(source);\n var defineProperty = definePropertyModule.f;\n var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n for (var i = 0; i < keys.length; i++) {\n  var key = keys[i];\n  if (!has(target, key))\n   defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n }\n};\n\n/***/ }),\n/* 40 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar getBuiltIn = __w_pdfjs_require__(41);\nvar getOwnPropertyNamesModule = __w_pdfjs_require__(43);\nvar getOwnPropertySymbolsModule = __w_pdfjs_require__(50);\nvar anObject = __w_pdfjs_require__(27);\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n var keys = getOwnPropertyNamesModule.f(anObject(it));\n var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n\n/***/ }),\n/* 41 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar path = __w_pdfjs_require__(42);\nvar global = __w_pdfjs_require__(10);\nvar aFunction = function (variable) {\n return typeof variable == 'function' ? variable : undefined;\n};\nmodule.exports = function (namespace, method) {\n return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];\n};\n\n/***/ }),\n/* 42 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nmodule.exports = global;\n\n/***/ }),\n/* 43 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\nvar internalObjectKeys = __w_pdfjs_require__(44);\nvar enumBugKeys = __w_pdfjs_require__(49);\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n return internalObjectKeys(O, hiddenKeys);\n};\n\n/***/ }),\n/* 44 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar has = __w_pdfjs_require__(22);\nvar toIndexedObject = __w_pdfjs_require__(16);\nvar indexOf = __w_pdfjs_require__(45).indexOf;\nvar hiddenKeys = __w_pdfjs_require__(38);\nmodule.exports = function (object, names) {\n var O = toIndexedObject(object);\n var i = 0;\n var result = [];\n var key;\n for (key in O)\n  !has(hiddenKeys, key) && has(O, key) && result.push(key);\n while (names.length > i)\n  if (has(O, key = names[i++])) {\n   ~indexOf(result, key) || result.push(key);\n  }\n return result;\n};\n\n/***/ }),\n/* 45 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar toIndexedObject = __w_pdfjs_require__(16);\nvar toLength = __w_pdfjs_require__(46);\nvar toAbsoluteIndex = __w_pdfjs_require__(48);\nvar createMethod = function (IS_INCLUDES) {\n return function ($this, el, fromIndex) {\n  var O = toIndexedObject($this);\n  var length = toLength(O.length);\n  var index = toAbsoluteIndex(fromIndex, length);\n  var value;\n  if (IS_INCLUDES && el != el)\n   while (length > index) {\n    value = O[index++];\n    if (value != value)\n     return true;\n   }\n  else\n   for (; length > index; index++) {\n    if ((IS_INCLUDES || index in O) && O[index] === el)\n     return IS_INCLUDES || index || 0;\n   }\n  return !IS_INCLUDES && -1;\n };\n};\nmodule.exports = {\n includes: createMethod(true),\n indexOf: createMethod(false)\n};\n\n/***/ }),\n/* 46 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar toInteger = __w_pdfjs_require__(47);\nvar min = Math.min;\nmodule.exports = function (argument) {\n return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0;\n};\n\n/***/ }),\n/* 47 */\n/***/ (function(module) {\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (argument) {\n return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n\n/***/ }),\n/* 48 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar toInteger = __w_pdfjs_require__(47);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n var integer = toInteger(index);\n return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n/***/ }),\n/* 49 */\n/***/ (function(module) {\n\nmodule.exports = [\n 'constructor',\n 'hasOwnProperty',\n 'isPrototypeOf',\n 'propertyIsEnumerable',\n 'toLocaleString',\n 'toString',\n 'valueOf'\n];\n\n/***/ }),\n/* 50 */\n/***/ (function(__unused_webpack_module, exports) {\n\nexports.f = Object.getOwnPropertySymbols;\n\n/***/ }),\n/* 51 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(13);\nvar replacement = /#|\\.prototype\\./;\nvar isForced = function (feature, detection) {\n var value = data[normalize(feature)];\n return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;\n};\nvar normalize = isForced.normalize = function (string) {\n return String(string).replace(replacement, '.').toLowerCase();\n};\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\nmodule.exports = isForced;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(53);\n__w_pdfjs_require__(72);\nvar path = __w_pdfjs_require__(42);\nmodule.exports = path.Object.fromEntries;\n\n/***/ }),\n/* 53 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar toIndexedObject = __w_pdfjs_require__(16);\nvar addToUnscopables = __w_pdfjs_require__(54);\nvar Iterators = __w_pdfjs_require__(62);\nvar InternalStateModule = __w_pdfjs_require__(32);\nvar defineIterator = __w_pdfjs_require__(63);\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\nmodule.exports = defineIterator(Array, 'Array', function (iterated, kind) {\n setInternalState(this, {\n  type: ARRAY_ITERATOR,\n  target: toIndexedObject(iterated),\n  index: 0,\n  kind: kind\n });\n}, function () {\n var state = getInternalState(this);\n var target = state.target;\n var kind = state.kind;\n var index = state.index++;\n if (!target || index >= target.length) {\n  state.target = undefined;\n  return {\n   value: undefined,\n   done: true\n  };\n }\n if (kind == 'keys')\n  return {\n   value: index,\n   done: false\n  };\n if (kind == 'values')\n  return {\n   value: target[index],\n   done: false\n  };\n return {\n  value: [\n   index,\n   target[index]\n  ],\n  done: false\n };\n}, 'values');\nIterators.Arguments = Iterators.Array;\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n/***/ }),\n/* 54 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar create = __w_pdfjs_require__(58);\nvar definePropertyModule = __w_pdfjs_require__(26);\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\nvar ArrayPrototype = Array.prototype;\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {\n  configurable: true,\n  value: create(null)\n });\n}\nmodule.exports = function (key) {\n ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\n/***/ }),\n/* 55 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nvar shared = __w_pdfjs_require__(35);\nvar has = __w_pdfjs_require__(22);\nvar uid = __w_pdfjs_require__(37);\nvar NATIVE_SYMBOL = __w_pdfjs_require__(56);\nvar USE_SYMBOL_AS_UID = __w_pdfjs_require__(57);\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\nmodule.exports = function (name) {\n if (!has(WellKnownSymbolsStore, name)) {\n  if (NATIVE_SYMBOL && has(Symbol, name))\n   WellKnownSymbolsStore[name] = Symbol[name];\n  else\n   WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n }\n return WellKnownSymbolsStore[name];\n};\n\n/***/ }),\n/* 56 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(13);\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n return !String(Symbol());\n});\n\n/***/ }),\n/* 57 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar NATIVE_SYMBOL = __w_pdfjs_require__(56);\nmodule.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';\n\n/***/ }),\n/* 58 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(27);\nvar defineProperties = __w_pdfjs_require__(59);\nvar enumBugKeys = __w_pdfjs_require__(49);\nvar hiddenKeys = __w_pdfjs_require__(38);\nvar html = __w_pdfjs_require__(61);\nvar documentCreateElement = __w_pdfjs_require__(24);\nvar sharedKey = __w_pdfjs_require__(34);\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar EmptyConstructor = function () {\n};\nvar scriptTag = function (content) {\n return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n activeXDocument.write(scriptTag(''));\n activeXDocument.close();\n var temp = activeXDocument.parentWindow.Object;\n activeXDocument = null;\n return temp;\n};\nvar NullProtoObjectViaIFrame = function () {\n var iframe = documentCreateElement('iframe');\n var JS = 'java' + SCRIPT + ':';\n var iframeDocument;\n iframe.style.display = 'none';\n html.appendChild(iframe);\n iframe.src = String(JS);\n iframeDocument = iframe.contentWindow.document;\n iframeDocument.open();\n iframeDocument.write(scriptTag('document.F=Object'));\n iframeDocument.close();\n return iframeDocument.F;\n};\nvar activeXDocument;\nvar NullProtoObject = function () {\n try {\n  activeXDocument = document.domain && new ActiveXObject('htmlfile');\n } catch (error) {\n }\n NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n var length = enumBugKeys.length;\n while (length--)\n  delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n return NullProtoObject();\n};\nhiddenKeys[IE_PROTO] = true;\nmodule.exports = Object.create || function create(O, Properties) {\n var result;\n if (O !== null) {\n  EmptyConstructor[PROTOTYPE] = anObject(O);\n  result = new EmptyConstructor();\n  EmptyConstructor[PROTOTYPE] = null;\n  result[IE_PROTO] = O;\n } else\n  result = NullProtoObject();\n return Properties === undefined ? result : defineProperties(result, Properties);\n};\n\n/***/ }),\n/* 59 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(12);\nvar definePropertyModule = __w_pdfjs_require__(26);\nvar anObject = __w_pdfjs_require__(27);\nvar objectKeys = __w_pdfjs_require__(60);\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n anObject(O);\n var keys = objectKeys(Properties);\n var length = keys.length;\n var index = 0;\n var key;\n while (length > index)\n  definePropertyModule.f(O, key = keys[index++], Properties[key]);\n return O;\n};\n\n/***/ }),\n/* 60 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar internalObjectKeys = __w_pdfjs_require__(44);\nvar enumBugKeys = __w_pdfjs_require__(49);\nmodule.exports = Object.keys || function keys(O) {\n return internalObjectKeys(O, enumBugKeys);\n};\n\n/***/ }),\n/* 61 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar getBuiltIn = __w_pdfjs_require__(41);\nmodule.exports = getBuiltIn('document', 'documentElement');\n\n/***/ }),\n/* 62 */\n/***/ (function(module) {\n\nmodule.exports = {};\n\n/***/ }),\n/* 63 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(9);\nvar createIteratorConstructor = __w_pdfjs_require__(64);\nvar getPrototypeOf = __w_pdfjs_require__(66);\nvar setPrototypeOf = __w_pdfjs_require__(70);\nvar setToStringTag = __w_pdfjs_require__(69);\nvar createNonEnumerableProperty = __w_pdfjs_require__(25);\nvar redefine = __w_pdfjs_require__(28);\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar IS_PURE = __w_pdfjs_require__(36);\nvar Iterators = __w_pdfjs_require__(62);\nvar IteratorsCore = __w_pdfjs_require__(65);\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR = wellKnownSymbol('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\nvar returnThis = function () {\n return this;\n};\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n createIteratorConstructor(IteratorConstructor, NAME, next);\n var getIterationMethod = function (KIND) {\n  if (KIND === DEFAULT && defaultIterator)\n   return defaultIterator;\n  if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)\n   return IterablePrototype[KIND];\n  switch (KIND) {\n  case KEYS:\n   return function keys() {\n    return new IteratorConstructor(this, KIND);\n   };\n  case VALUES:\n   return function values() {\n    return new IteratorConstructor(this, KIND);\n   };\n  case ENTRIES:\n   return function entries() {\n    return new IteratorConstructor(this, KIND);\n   };\n  }\n  return function () {\n   return new IteratorConstructor(this);\n  };\n };\n var TO_STRING_TAG = NAME + ' Iterator';\n var INCORRECT_VALUES_NAME = false;\n var IterablePrototype = Iterable.prototype;\n var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];\n var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n var CurrentIteratorPrototype, methods, KEY;\n if (anyNativeIterator) {\n  CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n  if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n   if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n    if (setPrototypeOf) {\n     setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n    } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {\n     createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);\n    }\n   }\n   setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n   if (IS_PURE)\n    Iterators[TO_STRING_TAG] = returnThis;\n  }\n }\n if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n  INCORRECT_VALUES_NAME = true;\n  defaultIterator = function values() {\n   return nativeIterator.call(this);\n  };\n }\n if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n  createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);\n }\n Iterators[NAME] = defaultIterator;\n if (DEFAULT) {\n  methods = {\n   values: getIterationMethod(VALUES),\n   keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n   entries: getIterationMethod(ENTRIES)\n  };\n  if (FORCED)\n   for (KEY in methods) {\n    if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n     redefine(IterablePrototype, KEY, methods[KEY]);\n    }\n   }\n  else\n   $({\n    target: NAME,\n    proto: true,\n    forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME\n   }, methods);\n }\n return methods;\n};\n\n/***/ }),\n/* 64 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar IteratorPrototype = __w_pdfjs_require__(65).IteratorPrototype;\nvar create = __w_pdfjs_require__(58);\nvar createPropertyDescriptor = __w_pdfjs_require__(15);\nvar setToStringTag = __w_pdfjs_require__(69);\nvar Iterators = __w_pdfjs_require__(62);\nvar returnThis = function () {\n return this;\n};\nmodule.exports = function (IteratorConstructor, NAME, next) {\n var TO_STRING_TAG = NAME + ' Iterator';\n IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });\n setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n Iterators[TO_STRING_TAG] = returnThis;\n return IteratorConstructor;\n};\n\n/***/ }),\n/* 65 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar fails = __w_pdfjs_require__(13);\nvar getPrototypeOf = __w_pdfjs_require__(66);\nvar createNonEnumerableProperty = __w_pdfjs_require__(25);\nvar has = __w_pdfjs_require__(22);\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar IS_PURE = __w_pdfjs_require__(36);\nvar ITERATOR = wellKnownSymbol('iterator');\nvar BUGGY_SAFARI_ITERATORS = false;\nvar returnThis = function () {\n return this;\n};\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\nif ([].keys) {\n arrayIterator = [].keys();\n if (!('next' in arrayIterator))\n  BUGGY_SAFARI_ITERATORS = true;\n else {\n  PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n  if (PrototypeOfArrayIteratorPrototype !== Object.prototype)\n   IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n }\n}\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {\n var test = {};\n return IteratorPrototype[ITERATOR].call(test) !== test;\n});\nif (NEW_ITERATOR_PROTOTYPE)\n IteratorPrototype = {};\nif ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {\n createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n}\nmodule.exports = {\n IteratorPrototype: IteratorPrototype,\n BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\n\n/***/ }),\n/* 66 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar has = __w_pdfjs_require__(22);\nvar toObject = __w_pdfjs_require__(67);\nvar sharedKey = __w_pdfjs_require__(34);\nvar CORRECT_PROTOTYPE_GETTER = __w_pdfjs_require__(68);\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar ObjectPrototype = Object.prototype;\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {\n O = toObject(O);\n if (has(O, IE_PROTO))\n  return O[IE_PROTO];\n if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n  return O.constructor.prototype;\n }\n return O instanceof Object ? ObjectPrototype : null;\n};\n\n/***/ }),\n/* 67 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar requireObjectCoercible = __w_pdfjs_require__(19);\nmodule.exports = function (argument) {\n return Object(requireObjectCoercible(argument));\n};\n\n/***/ }),\n/* 68 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(13);\nmodule.exports = !fails(function () {\n function F() {\n }\n F.prototype.constructor = null;\n return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n/***/ }),\n/* 69 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar defineProperty = __w_pdfjs_require__(26).f;\nvar has = __w_pdfjs_require__(22);\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nmodule.exports = function (it, TAG, STATIC) {\n if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n  defineProperty(it, TO_STRING_TAG, {\n   configurable: true,\n   value: TAG\n  });\n }\n};\n\n/***/ }),\n/* 70 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(27);\nvar aPossiblePrototype = __w_pdfjs_require__(71);\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n var CORRECT_SETTER = false;\n var test = {};\n var setter;\n try {\n  setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n  setter.call(test, []);\n  CORRECT_SETTER = test instanceof Array;\n } catch (error) {\n }\n return function setPrototypeOf(O, proto) {\n  anObject(O);\n  aPossiblePrototype(proto);\n  if (CORRECT_SETTER)\n   setter.call(O, proto);\n  else\n   O.__proto__ = proto;\n  return O;\n };\n}() : undefined);\n\n/***/ }),\n/* 71 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar isObject = __w_pdfjs_require__(21);\nmodule.exports = function (it) {\n if (!isObject(it) && it !== null) {\n  throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n }\n return it;\n};\n\n/***/ }),\n/* 72 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(9);\nvar iterate = __w_pdfjs_require__(73);\nvar createProperty = __w_pdfjs_require__(81);\n$({\n target: 'Object',\n stat: true\n}, {\n fromEntries: function fromEntries(iterable) {\n  var obj = {};\n  iterate(iterable, function (k, v) {\n   createProperty(obj, k, v);\n  }, { AS_ENTRIES: true });\n  return obj;\n }\n});\n\n/***/ }),\n/* 73 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(27);\nvar isArrayIteratorMethod = __w_pdfjs_require__(74);\nvar toLength = __w_pdfjs_require__(46);\nvar bind = __w_pdfjs_require__(75);\nvar getIteratorMethod = __w_pdfjs_require__(77);\nvar iteratorClose = __w_pdfjs_require__(80);\nvar Result = function (stopped, result) {\n this.stopped = stopped;\n this.result = result;\n};\nmodule.exports = function (iterable, unboundFunction, options) {\n var that = options && options.that;\n var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n var INTERRUPTED = !!(options && options.INTERRUPTED);\n var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);\n var iterator, iterFn, index, length, result, next, step;\n var stop = function (condition) {\n  if (iterator)\n   iteratorClose(iterator);\n  return new Result(true, condition);\n };\n var callFn = function (value) {\n  if (AS_ENTRIES) {\n   anObject(value);\n   return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n  }\n  return INTERRUPTED ? fn(value, stop) : fn(value);\n };\n if (IS_ITERATOR) {\n  iterator = iterable;\n } else {\n  iterFn = getIteratorMethod(iterable);\n  if (typeof iterFn != 'function')\n   throw TypeError('Target is not iterable');\n  if (isArrayIteratorMethod(iterFn)) {\n   for (index = 0, length = toLength(iterable.length); length > index; index++) {\n    result = callFn(iterable[index]);\n    if (result && result instanceof Result)\n     return result;\n   }\n   return new Result(false);\n  }\n  iterator = iterFn.call(iterable);\n }\n next = iterator.next;\n while (!(step = next.call(iterator)).done) {\n  try {\n   result = callFn(step.value);\n  } catch (error) {\n   iteratorClose(iterator);\n   throw error;\n  }\n  if (typeof result == 'object' && result && result instanceof Result)\n   return result;\n }\n return new Result(false);\n};\n\n/***/ }),\n/* 74 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar Iterators = __w_pdfjs_require__(62);\nvar ITERATOR = wellKnownSymbol('iterator');\nvar ArrayPrototype = Array.prototype;\nmodule.exports = function (it) {\n return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n};\n\n/***/ }),\n/* 75 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar aFunction = __w_pdfjs_require__(76);\nmodule.exports = function (fn, that, length) {\n aFunction(fn);\n if (that === undefined)\n  return fn;\n switch (length) {\n case 0:\n  return function () {\n   return fn.call(that);\n  };\n case 1:\n  return function (a) {\n   return fn.call(that, a);\n  };\n case 2:\n  return function (a, b) {\n   return fn.call(that, a, b);\n  };\n case 3:\n  return function (a, b, c) {\n   return fn.call(that, a, b, c);\n  };\n }\n return function () {\n  return fn.apply(that, arguments);\n };\n};\n\n/***/ }),\n/* 76 */\n/***/ (function(module) {\n\nmodule.exports = function (it) {\n if (typeof it != 'function') {\n  throw TypeError(String(it) + ' is not a function');\n }\n return it;\n};\n\n/***/ }),\n/* 77 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar classof = __w_pdfjs_require__(78);\nvar Iterators = __w_pdfjs_require__(62);\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar ITERATOR = wellKnownSymbol('iterator');\nmodule.exports = function (it) {\n if (it != undefined)\n  return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];\n};\n\n/***/ }),\n/* 78 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(79);\nvar classofRaw = __w_pdfjs_require__(18);\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar CORRECT_ARGUMENTS = classofRaw(function () {\n return arguments;\n}()) == 'Arguments';\nvar tryGet = function (it, key) {\n try {\n  return it[key];\n } catch (error) {\n }\n};\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n var O, tag, result;\n return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n};\n\n/***/ }),\n/* 79 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\ntest[TO_STRING_TAG] = 'z';\nmodule.exports = String(test) === '[object z]';\n\n/***/ }),\n/* 80 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(27);\nmodule.exports = function (iterator) {\n var returnMethod = iterator['return'];\n if (returnMethod !== undefined) {\n  return anObject(returnMethod.call(iterator)).value;\n }\n};\n\n/***/ }),\n/* 81 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar toPrimitive = __w_pdfjs_require__(20);\nvar definePropertyModule = __w_pdfjs_require__(26);\nvar createPropertyDescriptor = __w_pdfjs_require__(15);\nmodule.exports = function (object, key, value) {\n var propertyKey = toPrimitive(key);\n if (propertyKey in object)\n  definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n else\n  object[propertyKey] = value;\n};\n\n/***/ }),\n/* 82 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(83);\n__w_pdfjs_require__(84);\n__w_pdfjs_require__(86);\n__w_pdfjs_require__(104);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(106);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\nvar path = __w_pdfjs_require__(42);\nmodule.exports = path.Promise;\n\n/***/ }),\n/* 83 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(9);\nvar getPrototypeOf = __w_pdfjs_require__(66);\nvar setPrototypeOf = __w_pdfjs_require__(70);\nvar create = __w_pdfjs_require__(58);\nvar createNonEnumerableProperty = __w_pdfjs_require__(25);\nvar createPropertyDescriptor = __w_pdfjs_require__(15);\nvar iterate = __w_pdfjs_require__(73);\nvar $AggregateError = function AggregateError(errors, message) {\n var that = this;\n if (!(that instanceof $AggregateError))\n  return new $AggregateError(errors, message);\n if (setPrototypeOf) {\n  that = setPrototypeOf(new Error(undefined), getPrototypeOf(that));\n }\n if (message !== undefined)\n  createNonEnumerableProperty(that, 'message', String(message));\n var errorsArray = [];\n iterate(errors, errorsArray.push, { that: errorsArray });\n createNonEnumerableProperty(that, 'errors', errorsArray);\n return that;\n};\n$AggregateError.prototype = create(Error.prototype, {\n constructor: createPropertyDescriptor(5, $AggregateError),\n message: createPropertyDescriptor(5, ''),\n name: createPropertyDescriptor(5, 'AggregateError')\n});\n$({ global: true }, { AggregateError: $AggregateError });\n\n/***/ }),\n/* 84 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(79);\nvar redefine = __w_pdfjs_require__(28);\nvar toString = __w_pdfjs_require__(85);\nif (!TO_STRING_TAG_SUPPORT) {\n redefine(Object.prototype, 'toString', toString, { unsafe: true });\n}\n\n/***/ }),\n/* 85 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(79);\nvar classof = __w_pdfjs_require__(78);\nmodule.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {\n return '[object ' + classof(this) + ']';\n};\n\n/***/ }),\n/* 86 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(9);\nvar IS_PURE = __w_pdfjs_require__(36);\nvar global = __w_pdfjs_require__(10);\nvar getBuiltIn = __w_pdfjs_require__(41);\nvar NativePromise = __w_pdfjs_require__(87);\nvar redefine = __w_pdfjs_require__(28);\nvar redefineAll = __w_pdfjs_require__(88);\nvar setToStringTag = __w_pdfjs_require__(69);\nvar setSpecies = __w_pdfjs_require__(89);\nvar isObject = __w_pdfjs_require__(21);\nvar aFunction = __w_pdfjs_require__(76);\nvar anInstance = __w_pdfjs_require__(90);\nvar inspectSource = __w_pdfjs_require__(30);\nvar iterate = __w_pdfjs_require__(73);\nvar checkCorrectnessOfIteration = __w_pdfjs_require__(91);\nvar speciesConstructor = __w_pdfjs_require__(92);\nvar task = __w_pdfjs_require__(93).set;\nvar microtask = __w_pdfjs_require__(97);\nvar promiseResolve = __w_pdfjs_require__(99);\nvar hostReportErrors = __w_pdfjs_require__(101);\nvar newPromiseCapabilityModule = __w_pdfjs_require__(100);\nvar perform = __w_pdfjs_require__(102);\nvar InternalStateModule = __w_pdfjs_require__(32);\nvar isForced = __w_pdfjs_require__(51);\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar IS_NODE = __w_pdfjs_require__(96);\nvar V8_VERSION = __w_pdfjs_require__(103);\nvar SPECIES = wellKnownSymbol('species');\nvar PROMISE = 'Promise';\nvar getInternalState = InternalStateModule.get;\nvar setInternalState = InternalStateModule.set;\nvar getInternalPromiseState = InternalStateModule.getterFor(PROMISE);\nvar PromiseConstructor = NativePromise;\nvar TypeError = global.TypeError;\nvar document = global.document;\nvar process = global.process;\nvar $fetch = getBuiltIn('fetch');\nvar newPromiseCapability = newPromiseCapabilityModule.f;\nvar newGenericPromiseCapability = newPromiseCapability;\nvar DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);\nvar NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\nvar FORCED = isForced(PROMISE, function () {\n var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);\n if (!GLOBAL_CORE_JS_PROMISE) {\n  if (V8_VERSION === 66)\n   return true;\n  if (!IS_NODE && !NATIVE_REJECTION_EVENT)\n   return true;\n }\n if (IS_PURE && !PromiseConstructor.prototype['finally'])\n  return true;\n if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor))\n  return false;\n var promise = PromiseConstructor.resolve(1);\n var FakePromise = function (exec) {\n  exec(function () {\n  }, function () {\n  });\n };\n var constructor = promise.constructor = {};\n constructor[SPECIES] = FakePromise;\n return !(promise.then(function () {\n }) instanceof FakePromise);\n});\nvar INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {\n PromiseConstructor.all(iterable)['catch'](function () {\n });\n});\nvar isThenable = function (it) {\n var then;\n return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (state, isReject) {\n if (state.notified)\n  return;\n state.notified = true;\n var chain = state.reactions;\n microtask(function () {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var index = 0;\n  while (chain.length > index) {\n   var reaction = chain[index++];\n   var handler = ok ? reaction.ok : reaction.fail;\n   var resolve = reaction.resolve;\n   var reject = reaction.reject;\n   var domain = reaction.domain;\n   var result, then, exited;\n   try {\n    if (handler) {\n     if (!ok) {\n      if (state.rejection === UNHANDLED)\n       onHandleUnhandled(state);\n      state.rejection = HANDLED;\n     }\n     if (handler === true)\n      result = value;\n     else {\n      if (domain)\n       domain.enter();\n      result = handler(value);\n      if (domain) {\n       domain.exit();\n       exited = true;\n      }\n     }\n     if (result === reaction.promise) {\n      reject(TypeError('Promise-chain cycle'));\n     } else if (then = isThenable(result)) {\n      then.call(result, resolve, reject);\n     } else\n      resolve(result);\n    } else\n     reject(value);\n   } catch (error) {\n    if (domain && !exited)\n     domain.exit();\n    reject(error);\n   }\n  }\n  state.reactions = [];\n  state.notified = false;\n  if (isReject && !state.rejection)\n   onUnhandled(state);\n });\n};\nvar dispatchEvent = function (name, promise, reason) {\n var event, handler;\n if (DISPATCH_EVENT) {\n  event = document.createEvent('Event');\n  event.promise = promise;\n  event.reason = reason;\n  event.initEvent(name, false, true);\n  global.dispatchEvent(event);\n } else\n  event = {\n   promise: promise,\n   reason: reason\n  };\n if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name]))\n  handler(event);\n else if (name === UNHANDLED_REJECTION)\n  hostReportErrors('Unhandled promise rejection', reason);\n};\nvar onUnhandled = function (state) {\n task.call(global, function () {\n  var promise = state.facade;\n  var value = state.value;\n  var IS_UNHANDLED = isUnhandled(state);\n  var result;\n  if (IS_UNHANDLED) {\n   result = perform(function () {\n    if (IS_NODE) {\n     process.emit('unhandledRejection', value, promise);\n    } else\n     dispatchEvent(UNHANDLED_REJECTION, promise, value);\n   });\n   state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;\n   if (result.error)\n    throw result.value;\n  }\n });\n};\nvar isUnhandled = function (state) {\n return state.rejection !== HANDLED && !state.parent;\n};\nvar onHandleUnhandled = function (state) {\n task.call(global, function () {\n  var promise = state.facade;\n  if (IS_NODE) {\n   process.emit('rejectionHandled', promise);\n  } else\n   dispatchEvent(REJECTION_HANDLED, promise, state.value);\n });\n};\nvar bind = function (fn, state, unwrap) {\n return function (value) {\n  fn(state, value, unwrap);\n };\n};\nvar internalReject = function (state, value, unwrap) {\n if (state.done)\n  return;\n state.done = true;\n if (unwrap)\n  state = unwrap;\n state.value = value;\n state.state = REJECTED;\n notify(state, true);\n};\nvar internalResolve = function (state, value, unwrap) {\n if (state.done)\n  return;\n state.done = true;\n if (unwrap)\n  state = unwrap;\n try {\n  if (state.facade === value)\n   throw TypeError(\"Promise can't be resolved itself\");\n  var then = isThenable(value);\n  if (then) {\n   microtask(function () {\n    var wrapper = { done: false };\n    try {\n     then.call(value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));\n    } catch (error) {\n     internalReject(wrapper, error, state);\n    }\n   });\n  } else {\n   state.value = value;\n   state.state = FULFILLED;\n   notify(state, false);\n  }\n } catch (error) {\n  internalReject({ done: false }, error, state);\n }\n};\nif (FORCED) {\n PromiseConstructor = function Promise(executor) {\n  anInstance(this, PromiseConstructor, PROMISE);\n  aFunction(executor);\n  Internal.call(this);\n  var state = getInternalState(this);\n  try {\n   executor(bind(internalResolve, state), bind(internalReject, state));\n  } catch (error) {\n   internalReject(state, error);\n  }\n };\n Internal = function Promise(executor) {\n  setInternalState(this, {\n   type: PROMISE,\n   done: false,\n   notified: false,\n   parent: false,\n   reactions: [],\n   rejection: false,\n   state: PENDING,\n   value: undefined\n  });\n };\n Internal.prototype = redefineAll(PromiseConstructor.prototype, {\n  then: function then(onFulfilled, onRejected) {\n   var state = getInternalPromiseState(this);\n   var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));\n   reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n   reaction.fail = typeof onRejected == 'function' && onRejected;\n   reaction.domain = IS_NODE ? process.domain : undefined;\n   state.parent = true;\n   state.reactions.push(reaction);\n   if (state.state != PENDING)\n    notify(state, false);\n   return reaction.promise;\n  },\n  'catch': function (onRejected) {\n   return this.then(undefined, onRejected);\n  }\n });\n OwnPromiseCapability = function () {\n  var promise = new Internal();\n  var state = getInternalState(promise);\n  this.promise = promise;\n  this.resolve = bind(internalResolve, state);\n  this.reject = bind(internalReject, state);\n };\n newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n  return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);\n };\n if (!IS_PURE && typeof NativePromise == 'function') {\n  nativeThen = NativePromise.prototype.then;\n  redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {\n   var that = this;\n   return new PromiseConstructor(function (resolve, reject) {\n    nativeThen.call(that, resolve, reject);\n   }).then(onFulfilled, onRejected);\n  }, { unsafe: true });\n  if (typeof $fetch == 'function')\n   $({\n    global: true,\n    enumerable: true,\n    forced: true\n   }, {\n    fetch: function fetch(input) {\n     return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));\n    }\n   });\n }\n}\n$({\n global: true,\n wrap: true,\n forced: FORCED\n}, { Promise: PromiseConstructor });\nsetToStringTag(PromiseConstructor, PROMISE, false, true);\nsetSpecies(PROMISE);\nPromiseWrapper = getBuiltIn(PROMISE);\n$({\n target: PROMISE,\n stat: true,\n forced: FORCED\n}, {\n reject: function reject(r) {\n  var capability = newPromiseCapability(this);\n  capability.reject.call(undefined, r);\n  return capability.promise;\n }\n});\n$({\n target: PROMISE,\n stat: true,\n forced: IS_PURE || FORCED\n}, {\n resolve: function resolve(x) {\n  return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);\n }\n});\n$({\n target: PROMISE,\n stat: true,\n forced: INCORRECT_ITERATION\n}, {\n all: function all(iterable) {\n  var C = this;\n  var capability = newPromiseCapability(C);\n  var resolve = capability.resolve;\n  var reject = capability.reject;\n  var result = perform(function () {\n   var $promiseResolve = aFunction(C.resolve);\n   var values = [];\n   var counter = 0;\n   var remaining = 1;\n   iterate(iterable, function (promise) {\n    var index = counter++;\n    var alreadyCalled = false;\n    values.push(undefined);\n    remaining++;\n    $promiseResolve.call(C, promise).then(function (value) {\n     if (alreadyCalled)\n      return;\n     alreadyCalled = true;\n     values[index] = value;\n     --remaining || resolve(values);\n    }, reject);\n   });\n   --remaining || resolve(values);\n  });\n  if (result.error)\n   reject(result.value);\n  return capability.promise;\n },\n race: function race(iterable) {\n  var C = this;\n  var capability = newPromiseCapability(C);\n  var reject = capability.reject;\n  var result = perform(function () {\n   var $promiseResolve = aFunction(C.resolve);\n   iterate(iterable, function (promise) {\n    $promiseResolve.call(C, promise).then(capability.resolve, reject);\n   });\n  });\n  if (result.error)\n   reject(result.value);\n  return capability.promise;\n }\n});\n\n/***/ }),\n/* 87 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nmodule.exports = global.Promise;\n\n/***/ }),\n/* 88 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar redefine = __w_pdfjs_require__(28);\nmodule.exports = function (target, src, options) {\n for (var key in src)\n  redefine(target, key, src[key], options);\n return target;\n};\n\n/***/ }),\n/* 89 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar getBuiltIn = __w_pdfjs_require__(41);\nvar definePropertyModule = __w_pdfjs_require__(26);\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar DESCRIPTORS = __w_pdfjs_require__(12);\nvar SPECIES = wellKnownSymbol('species');\nmodule.exports = function (CONSTRUCTOR_NAME) {\n var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\n var defineProperty = definePropertyModule.f;\n if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {\n  defineProperty(Constructor, SPECIES, {\n   configurable: true,\n   get: function () {\n    return this;\n   }\n  });\n }\n};\n\n/***/ }),\n/* 90 */\n/***/ (function(module) {\n\nmodule.exports = function (it, Constructor, name) {\n if (!(it instanceof Constructor)) {\n  throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');\n }\n return it;\n};\n\n/***/ }),\n/* 91 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar ITERATOR = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\ntry {\n var called = 0;\n var iteratorWithReturn = {\n  next: function () {\n   return { done: !!called++ };\n  },\n  'return': function () {\n   SAFE_CLOSING = true;\n  }\n };\n iteratorWithReturn[ITERATOR] = function () {\n  return this;\n };\n Array.from(iteratorWithReturn, function () {\n  throw 2;\n });\n} catch (error) {\n}\nmodule.exports = function (exec, SKIP_CLOSING) {\n if (!SKIP_CLOSING && !SAFE_CLOSING)\n  return false;\n var ITERATION_SUPPORT = false;\n try {\n  var object = {};\n  object[ITERATOR] = function () {\n   return {\n    next: function () {\n     return { done: ITERATION_SUPPORT = true };\n    }\n   };\n  };\n  exec(object);\n } catch (error) {\n }\n return ITERATION_SUPPORT;\n};\n\n/***/ }),\n/* 92 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(27);\nvar aFunction = __w_pdfjs_require__(76);\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar SPECIES = wellKnownSymbol('species');\nmodule.exports = function (O, defaultConstructor) {\n var C = anObject(O).constructor;\n var S;\n return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);\n};\n\n/***/ }),\n/* 93 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nvar fails = __w_pdfjs_require__(13);\nvar bind = __w_pdfjs_require__(75);\nvar html = __w_pdfjs_require__(61);\nvar createElement = __w_pdfjs_require__(24);\nvar IS_IOS = __w_pdfjs_require__(94);\nvar IS_NODE = __w_pdfjs_require__(96);\nvar location = global.location;\nvar set = global.setImmediate;\nvar clear = global.clearImmediate;\nvar process = global.process;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function (id) {\n if (queue.hasOwnProperty(id)) {\n  var fn = queue[id];\n  delete queue[id];\n  fn();\n }\n};\nvar runner = function (id) {\n return function () {\n  run(id);\n };\n};\nvar listener = function (event) {\n run(event.data);\n};\nvar post = function (id) {\n global.postMessage(id + '', location.protocol + '//' + location.host);\n};\nif (!set || !clear) {\n set = function setImmediate(fn) {\n  var args = [];\n  var i = 1;\n  while (arguments.length > i)\n   args.push(arguments[i++]);\n  queue[++counter] = function () {\n   (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);\n  };\n  defer(counter);\n  return counter;\n };\n clear = function clearImmediate(id) {\n  delete queue[id];\n };\n if (IS_NODE) {\n  defer = function (id) {\n   process.nextTick(runner(id));\n  };\n } else if (Dispatch && Dispatch.now) {\n  defer = function (id) {\n   Dispatch.now(runner(id));\n  };\n } else if (MessageChannel && !IS_IOS) {\n  channel = new MessageChannel();\n  port = channel.port2;\n  channel.port1.onmessage = listener;\n  defer = bind(port.postMessage, port, 1);\n } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && location && location.protocol !== 'file:' && !fails(post)) {\n  defer = post;\n  global.addEventListener('message', listener, false);\n } else if (ONREADYSTATECHANGE in createElement('script')) {\n  defer = function (id) {\n   html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n    html.removeChild(this);\n    run(id);\n   };\n  };\n } else {\n  defer = function (id) {\n   setTimeout(runner(id), 0);\n  };\n }\n}\nmodule.exports = {\n set: set,\n clear: clear\n};\n\n/***/ }),\n/* 94 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar userAgent = __w_pdfjs_require__(95);\nmodule.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);\n\n/***/ }),\n/* 95 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar getBuiltIn = __w_pdfjs_require__(41);\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n\n/***/ }),\n/* 96 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar classof = __w_pdfjs_require__(18);\nvar global = __w_pdfjs_require__(10);\nmodule.exports = classof(global.process) == 'process';\n\n/***/ }),\n/* 97 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nvar getOwnPropertyDescriptor = __w_pdfjs_require__(11).f;\nvar macrotask = __w_pdfjs_require__(93).set;\nvar IS_IOS = __w_pdfjs_require__(94);\nvar IS_WEBOS_WEBKIT = __w_pdfjs_require__(98);\nvar IS_NODE = __w_pdfjs_require__(96);\nvar MutationObserver = global.MutationObserver || global.WebKitMutationObserver;\nvar document = global.document;\nvar process = global.process;\nvar Promise = global.Promise;\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\nvar flush, head, last, notify, toggle, node, promise, then;\nif (!queueMicrotask) {\n flush = function () {\n  var parent, fn;\n  if (IS_NODE && (parent = process.domain))\n   parent.exit();\n  while (head) {\n   fn = head.fn;\n   head = head.next;\n   try {\n    fn();\n   } catch (error) {\n    if (head)\n     notify();\n    else\n     last = undefined;\n    throw error;\n   }\n  }\n  last = undefined;\n  if (parent)\n   parent.enter();\n };\n if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {\n  toggle = true;\n  node = document.createTextNode('');\n  new MutationObserver(flush).observe(node, { characterData: true });\n  notify = function () {\n   node.data = toggle = !toggle;\n  };\n } else if (Promise && Promise.resolve) {\n  promise = Promise.resolve(undefined);\n  then = promise.then;\n  notify = function () {\n   then.call(promise, flush);\n  };\n } else if (IS_NODE) {\n  notify = function () {\n   process.nextTick(flush);\n  };\n } else {\n  notify = function () {\n   macrotask.call(global, flush);\n  };\n }\n}\nmodule.exports = queueMicrotask || function (fn) {\n var task = {\n  fn: fn,\n  next: undefined\n };\n if (last)\n  last.next = task;\n if (!head) {\n  head = task;\n  notify();\n }\n last = task;\n};\n\n/***/ }),\n/* 98 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar userAgent = __w_pdfjs_require__(95);\nmodule.exports = /web0s(?!.*chrome)/i.test(userAgent);\n\n/***/ }),\n/* 99 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(27);\nvar isObject = __w_pdfjs_require__(21);\nvar newPromiseCapability = __w_pdfjs_require__(100);\nmodule.exports = function (C, x) {\n anObject(C);\n if (isObject(x) && x.constructor === C)\n  return x;\n var promiseCapability = newPromiseCapability.f(C);\n var resolve = promiseCapability.resolve;\n resolve(x);\n return promiseCapability.promise;\n};\n\n/***/ }),\n/* 100 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar aFunction = __w_pdfjs_require__(76);\nvar PromiseCapability = function (C) {\n var resolve, reject;\n this.promise = new C(function ($$resolve, $$reject) {\n  if (resolve !== undefined || reject !== undefined)\n   throw TypeError('Bad Promise constructor');\n  resolve = $$resolve;\n  reject = $$reject;\n });\n this.resolve = aFunction(resolve);\n this.reject = aFunction(reject);\n};\nmodule.exports.f = function (C) {\n return new PromiseCapability(C);\n};\n\n/***/ }),\n/* 101 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nmodule.exports = function (a, b) {\n var console = global.console;\n if (console && console.error) {\n  arguments.length === 1 ? console.error(a) : console.error(a, b);\n }\n};\n\n/***/ }),\n/* 102 */\n/***/ (function(module) {\n\nmodule.exports = function (exec) {\n try {\n  return {\n   error: false,\n   value: exec()\n  };\n } catch (error) {\n  return {\n   error: true,\n   value: error\n  };\n }\n};\n\n/***/ }),\n/* 103 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nvar userAgent = __w_pdfjs_require__(95);\nvar process = global.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8;\nvar match, version;\nif (v8) {\n match = v8.split('.');\n version = match[0] + match[1];\n} else if (userAgent) {\n match = userAgent.match(/Edge\\/(\\d+)/);\n if (!match || match[1] >= 74) {\n  match = userAgent.match(/Chrome\\/(\\d+)/);\n  if (match)\n   version = match[1];\n }\n}\nmodule.exports = version && +version;\n\n/***/ }),\n/* 104 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(9);\nvar aFunction = __w_pdfjs_require__(76);\nvar newPromiseCapabilityModule = __w_pdfjs_require__(100);\nvar perform = __w_pdfjs_require__(102);\nvar iterate = __w_pdfjs_require__(73);\n$({\n target: 'Promise',\n stat: true\n}, {\n allSettled: function allSettled(iterable) {\n  var C = this;\n  var capability = newPromiseCapabilityModule.f(C);\n  var resolve = capability.resolve;\n  var reject = capability.reject;\n  var result = perform(function () {\n   var promiseResolve = aFunction(C.resolve);\n   var values = [];\n   var counter = 0;\n   var remaining = 1;\n   iterate(iterable, function (promise) {\n    var index = counter++;\n    var alreadyCalled = false;\n    values.push(undefined);\n    remaining++;\n    promiseResolve.call(C, promise).then(function (value) {\n     if (alreadyCalled)\n      return;\n     alreadyCalled = true;\n     values[index] = {\n      status: 'fulfilled',\n      value: value\n     };\n     --remaining || resolve(values);\n    }, function (error) {\n     if (alreadyCalled)\n      return;\n     alreadyCalled = true;\n     values[index] = {\n      status: 'rejected',\n      reason: error\n     };\n     --remaining || resolve(values);\n    });\n   });\n   --remaining || resolve(values);\n  });\n  if (result.error)\n   reject(result.value);\n  return capability.promise;\n }\n});\n\n/***/ }),\n/* 105 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(9);\nvar aFunction = __w_pdfjs_require__(76);\nvar getBuiltIn = __w_pdfjs_require__(41);\nvar newPromiseCapabilityModule = __w_pdfjs_require__(100);\nvar perform = __w_pdfjs_require__(102);\nvar iterate = __w_pdfjs_require__(73);\nvar PROMISE_ANY_ERROR = 'No one promise resolved';\n$({\n target: 'Promise',\n stat: true\n}, {\n any: function any(iterable) {\n  var C = this;\n  var capability = newPromiseCapabilityModule.f(C);\n  var resolve = capability.resolve;\n  var reject = capability.reject;\n  var result = perform(function () {\n   var promiseResolve = aFunction(C.resolve);\n   var errors = [];\n   var counter = 0;\n   var remaining = 1;\n   var alreadyResolved = false;\n   iterate(iterable, function (promise) {\n    var index = counter++;\n    var alreadyRejected = false;\n    errors.push(undefined);\n    remaining++;\n    promiseResolve.call(C, promise).then(function (value) {\n     if (alreadyRejected || alreadyResolved)\n      return;\n     alreadyResolved = true;\n     resolve(value);\n    }, function (error) {\n     if (alreadyRejected || alreadyResolved)\n      return;\n     alreadyRejected = true;\n     errors[index] = error;\n     --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));\n    });\n   });\n   --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));\n  });\n  if (result.error)\n   reject(result.value);\n  return capability.promise;\n }\n});\n\n/***/ }),\n/* 106 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(9);\nvar IS_PURE = __w_pdfjs_require__(36);\nvar NativePromise = __w_pdfjs_require__(87);\nvar fails = __w_pdfjs_require__(13);\nvar getBuiltIn = __w_pdfjs_require__(41);\nvar speciesConstructor = __w_pdfjs_require__(92);\nvar promiseResolve = __w_pdfjs_require__(99);\nvar redefine = __w_pdfjs_require__(28);\nvar NON_GENERIC = !!NativePromise && fails(function () {\n NativePromise.prototype['finally'].call({\n  then: function () {\n  }\n }, function () {\n });\n});\n$({\n target: 'Promise',\n proto: true,\n real: true,\n forced: NON_GENERIC\n}, {\n 'finally': function (onFinally) {\n  var C = speciesConstructor(this, getBuiltIn('Promise'));\n  var isFunction = typeof onFinally == 'function';\n  return this.then(isFunction ? function (x) {\n   return promiseResolve(C, onFinally()).then(function () {\n    return x;\n   });\n  } : onFinally, isFunction ? function (e) {\n   return promiseResolve(C, onFinally()).then(function () {\n    throw e;\n   });\n  } : onFinally);\n }\n});\nif (!IS_PURE && typeof NativePromise == 'function' && !NativePromise.prototype['finally']) {\n redefine(NativePromise.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);\n}\n\n/***/ }),\n/* 107 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar charAt = __w_pdfjs_require__(108).charAt;\nvar InternalStateModule = __w_pdfjs_require__(32);\nvar defineIterator = __w_pdfjs_require__(63);\nvar STRING_ITERATOR = 'String Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\ndefineIterator(String, 'String', function (iterated) {\n setInternalState(this, {\n  type: STRING_ITERATOR,\n  string: String(iterated),\n  index: 0\n });\n}, function next() {\n var state = getInternalState(this);\n var string = state.string;\n var index = state.index;\n var point;\n if (index >= string.length)\n  return {\n   value: undefined,\n   done: true\n  };\n point = charAt(string, index);\n state.index += point.length;\n return {\n  value: point,\n  done: false\n };\n});\n\n/***/ }),\n/* 108 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar toInteger = __w_pdfjs_require__(47);\nvar requireObjectCoercible = __w_pdfjs_require__(19);\nvar createMethod = function (CONVERT_TO_STRING) {\n return function ($this, pos) {\n  var S = String(requireObjectCoercible($this));\n  var position = toInteger(pos);\n  var size = S.length;\n  var first, second;\n  if (position < 0 || position >= size)\n   return CONVERT_TO_STRING ? '' : undefined;\n  first = S.charCodeAt(position);\n  return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n };\n};\nmodule.exports = {\n codeAt: createMethod(false),\n charAt: createMethod(true)\n};\n\n/***/ }),\n/* 109 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nvar DOMIterables = __w_pdfjs_require__(110);\nvar ArrayIteratorMethods = __w_pdfjs_require__(53);\nvar createNonEnumerableProperty = __w_pdfjs_require__(25);\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar ITERATOR = wellKnownSymbol('iterator');\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\nfor (var COLLECTION_NAME in DOMIterables) {\n var Collection = global[COLLECTION_NAME];\n var CollectionPrototype = Collection && Collection.prototype;\n if (CollectionPrototype) {\n  if (CollectionPrototype[ITERATOR] !== ArrayValues)\n   try {\n    createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);\n   } catch (error) {\n    CollectionPrototype[ITERATOR] = ArrayValues;\n   }\n  if (!CollectionPrototype[TO_STRING_TAG]) {\n   createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n  }\n  if (DOMIterables[COLLECTION_NAME])\n   for (var METHOD_NAME in ArrayIteratorMethods) {\n    if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])\n     try {\n      createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n     } catch (error) {\n      CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n     }\n   }\n }\n}\n\n/***/ }),\n/* 110 */\n/***/ (function(module) {\n\nmodule.exports = {\n CSSRuleList: 0,\n CSSStyleDeclaration: 0,\n CSSValueList: 0,\n ClientRectList: 0,\n DOMRectList: 0,\n DOMStringList: 0,\n DOMTokenList: 1,\n DataTransferItemList: 0,\n FileList: 0,\n HTMLAllCollection: 0,\n HTMLCollection: 0,\n HTMLFormElement: 0,\n HTMLSelectElement: 0,\n MediaList: 0,\n MimeTypeArray: 0,\n NamedNodeMap: 0,\n NodeList: 1,\n PaintRequestList: 0,\n Plugin: 0,\n PluginArray: 0,\n SVGLengthList: 0,\n SVGNumberList: 0,\n SVGPathSegList: 0,\n SVGPointList: 0,\n SVGStringList: 0,\n SVGTransformList: 0,\n SourceBufferList: 0,\n StyleSheetList: 0,\n TextTrackCueList: 0,\n TextTrackList: 0,\n TouchList: 0\n};\n\n/***/ }),\n/* 111 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(112);\n__w_pdfjs_require__(120);\n__w_pdfjs_require__(118);\nvar path = __w_pdfjs_require__(42);\nmodule.exports = path.URL;\n\n/***/ }),\n/* 112 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n__w_pdfjs_require__(107);\nvar $ = __w_pdfjs_require__(9);\nvar DESCRIPTORS = __w_pdfjs_require__(12);\nvar USE_NATIVE_URL = __w_pdfjs_require__(113);\nvar global = __w_pdfjs_require__(10);\nvar defineProperties = __w_pdfjs_require__(59);\nvar redefine = __w_pdfjs_require__(28);\nvar anInstance = __w_pdfjs_require__(90);\nvar has = __w_pdfjs_require__(22);\nvar assign = __w_pdfjs_require__(114);\nvar arrayFrom = __w_pdfjs_require__(115);\nvar codeAt = __w_pdfjs_require__(108).codeAt;\nvar toASCII = __w_pdfjs_require__(117);\nvar setToStringTag = __w_pdfjs_require__(69);\nvar URLSearchParamsModule = __w_pdfjs_require__(118);\nvar InternalStateModule = __w_pdfjs_require__(32);\nvar NativeURL = global.URL;\nvar URLSearchParams = URLSearchParamsModule.URLSearchParams;\nvar getInternalSearchParamsState = URLSearchParamsModule.getState;\nvar setInternalState = InternalStateModule.set;\nvar getInternalURLState = InternalStateModule.getterFor('URL');\nvar floor = Math.floor;\nvar pow = Math.pow;\nvar INVALID_AUTHORITY = 'Invalid authority';\nvar INVALID_SCHEME = 'Invalid scheme';\nvar INVALID_HOST = 'Invalid host';\nvar INVALID_PORT = 'Invalid port';\nvar ALPHA = /[A-Za-z]/;\nvar ALPHANUMERIC = /[\\d+-.A-Za-z]/;\nvar DIGIT = /\\d/;\nvar HEX_START = /^(0x|0X)/;\nvar OCT = /^[0-7]+$/;\nvar DEC = /^\\d+$/;\nvar HEX = /^[\\dA-Fa-f]+$/;\nvar FORBIDDEN_HOST_CODE_POINT = /[\\u0000\\u0009\\u000A\\u000D #%/:?@[\\\\]]/;\nvar FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\\u0000\\u0009\\u000A\\u000D #/:?@[\\\\]]/;\nvar LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\\u0000-\\u001F ]+|[\\u0000-\\u001F ]+$/g;\nvar TAB_AND_NEW_LINE = /[\\u0009\\u000A\\u000D]/g;\nvar EOF;\nvar parseHost = function (url, input) {\n var result, codePoints, index;\n if (input.charAt(0) == '[') {\n  if (input.charAt(input.length - 1) != ']')\n   return INVALID_HOST;\n  result = parseIPv6(input.slice(1, -1));\n  if (!result)\n   return INVALID_HOST;\n  url.host = result;\n } else if (!isSpecial(url)) {\n  if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input))\n   return INVALID_HOST;\n  result = '';\n  codePoints = arrayFrom(input);\n  for (index = 0; index < codePoints.length; index++) {\n   result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);\n  }\n  url.host = result;\n } else {\n  input = toASCII(input);\n  if (FORBIDDEN_HOST_CODE_POINT.test(input))\n   return INVALID_HOST;\n  result = parseIPv4(input);\n  if (result === null)\n   return INVALID_HOST;\n  url.host = result;\n }\n};\nvar parseIPv4 = function (input) {\n var parts = input.split('.');\n var partsLength, numbers, index, part, radix, number, ipv4;\n if (parts.length && parts[parts.length - 1] == '') {\n  parts.pop();\n }\n partsLength = parts.length;\n if (partsLength > 4)\n  return input;\n numbers = [];\n for (index = 0; index < partsLength; index++) {\n  part = parts[index];\n  if (part == '')\n   return input;\n  radix = 10;\n  if (part.length > 1 && part.charAt(0) == '0') {\n   radix = HEX_START.test(part) ? 16 : 8;\n   part = part.slice(radix == 8 ? 1 : 2);\n  }\n  if (part === '') {\n   number = 0;\n  } else {\n   if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part))\n    return input;\n   number = parseInt(part, radix);\n  }\n  numbers.push(number);\n }\n for (index = 0; index < partsLength; index++) {\n  number = numbers[index];\n  if (index == partsLength - 1) {\n   if (number >= pow(256, 5 - partsLength))\n    return null;\n  } else if (number > 255)\n   return null;\n }\n ipv4 = numbers.pop();\n for (index = 0; index < numbers.length; index++) {\n  ipv4 += numbers[index] * pow(256, 3 - index);\n }\n return ipv4;\n};\nvar parseIPv6 = function (input) {\n var address = [\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0\n ];\n var pieceIndex = 0;\n var compress = null;\n var pointer = 0;\n var value, length, numbersSeen, ipv4Piece, number, swaps, swap;\n var char = function () {\n  return input.charAt(pointer);\n };\n if (char() == ':') {\n  if (input.charAt(1) != ':')\n   return;\n  pointer += 2;\n  pieceIndex++;\n  compress = pieceIndex;\n }\n while (char()) {\n  if (pieceIndex == 8)\n   return;\n  if (char() == ':') {\n   if (compress !== null)\n    return;\n   pointer++;\n   pieceIndex++;\n   compress = pieceIndex;\n   continue;\n  }\n  value = length = 0;\n  while (length < 4 && HEX.test(char())) {\n   value = value * 16 + parseInt(char(), 16);\n   pointer++;\n   length++;\n  }\n  if (char() == '.') {\n   if (length == 0)\n    return;\n   pointer -= length;\n   if (pieceIndex > 6)\n    return;\n   numbersSeen = 0;\n   while (char()) {\n    ipv4Piece = null;\n    if (numbersSeen > 0) {\n     if (char() == '.' && numbersSeen < 4)\n      pointer++;\n     else\n      return;\n    }\n    if (!DIGIT.test(char()))\n     return;\n    while (DIGIT.test(char())) {\n     number = parseInt(char(), 10);\n     if (ipv4Piece === null)\n      ipv4Piece = number;\n     else if (ipv4Piece == 0)\n      return;\n     else\n      ipv4Piece = ipv4Piece * 10 + number;\n     if (ipv4Piece > 255)\n      return;\n     pointer++;\n    }\n    address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;\n    numbersSeen++;\n    if (numbersSeen == 2 || numbersSeen == 4)\n     pieceIndex++;\n   }\n   if (numbersSeen != 4)\n    return;\n   break;\n  } else if (char() == ':') {\n   pointer++;\n   if (!char())\n    return;\n  } else if (char())\n   return;\n  address[pieceIndex++] = value;\n }\n if (compress !== null) {\n  swaps = pieceIndex - compress;\n  pieceIndex = 7;\n  while (pieceIndex != 0 && swaps > 0) {\n   swap = address[pieceIndex];\n   address[pieceIndex--] = address[compress + swaps - 1];\n   address[compress + --swaps] = swap;\n  }\n } else if (pieceIndex != 8)\n  return;\n return address;\n};\nvar findLongestZeroSequence = function (ipv6) {\n var maxIndex = null;\n var maxLength = 1;\n var currStart = null;\n var currLength = 0;\n var index = 0;\n for (; index < 8; index++) {\n  if (ipv6[index] !== 0) {\n   if (currLength > maxLength) {\n    maxIndex = currStart;\n    maxLength = currLength;\n   }\n   currStart = null;\n   currLength = 0;\n  } else {\n   if (currStart === null)\n    currStart = index;\n   ++currLength;\n  }\n }\n if (currLength > maxLength) {\n  maxIndex = currStart;\n  maxLength = currLength;\n }\n return maxIndex;\n};\nvar serializeHost = function (host) {\n var result, index, compress, ignore0;\n if (typeof host == 'number') {\n  result = [];\n  for (index = 0; index < 4; index++) {\n   result.unshift(host % 256);\n   host = floor(host / 256);\n  }\n  return result.join('.');\n } else if (typeof host == 'object') {\n  result = '';\n  compress = findLongestZeroSequence(host);\n  for (index = 0; index < 8; index++) {\n   if (ignore0 && host[index] === 0)\n    continue;\n   if (ignore0)\n    ignore0 = false;\n   if (compress === index) {\n    result += index ? ':' : '::';\n    ignore0 = true;\n   } else {\n    result += host[index].toString(16);\n    if (index < 7)\n     result += ':';\n   }\n  }\n  return '[' + result + ']';\n }\n return host;\n};\nvar C0ControlPercentEncodeSet = {};\nvar fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {\n ' ': 1,\n '\"': 1,\n '<': 1,\n '>': 1,\n '`': 1\n});\nvar pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {\n '#': 1,\n '?': 1,\n '{': 1,\n '}': 1\n});\nvar userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {\n '/': 1,\n ':': 1,\n ';': 1,\n '=': 1,\n '@': 1,\n '[': 1,\n '\\\\': 1,\n ']': 1,\n '^': 1,\n '|': 1\n});\nvar percentEncode = function (char, set) {\n var code = codeAt(char, 0);\n return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);\n};\nvar specialSchemes = {\n ftp: 21,\n file: null,\n http: 80,\n https: 443,\n ws: 80,\n wss: 443\n};\nvar isSpecial = function (url) {\n return has(specialSchemes, url.scheme);\n};\nvar includesCredentials = function (url) {\n return url.username != '' || url.password != '';\n};\nvar cannotHaveUsernamePasswordPort = function (url) {\n return !url.host || url.cannotBeABaseURL || url.scheme == 'file';\n};\nvar isWindowsDriveLetter = function (string, normalized) {\n var second;\n return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ':' || !normalized && second == '|');\n};\nvar startsWithWindowsDriveLetter = function (string) {\n var third;\n return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || ((third = string.charAt(2)) === '/' || third === '\\\\' || third === '?' || third === '#'));\n};\nvar shortenURLsPath = function (url) {\n var path = url.path;\n var pathSize = path.length;\n if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {\n  path.pop();\n }\n};\nvar isSingleDot = function (segment) {\n return segment === '.' || segment.toLowerCase() === '%2e';\n};\nvar isDoubleDot = function (segment) {\n segment = segment.toLowerCase();\n return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';\n};\nvar SCHEME_START = {};\nvar SCHEME = {};\nvar NO_SCHEME = {};\nvar SPECIAL_RELATIVE_OR_AUTHORITY = {};\nvar PATH_OR_AUTHORITY = {};\nvar RELATIVE = {};\nvar RELATIVE_SLASH = {};\nvar SPECIAL_AUTHORITY_SLASHES = {};\nvar SPECIAL_AUTHORITY_IGNORE_SLASHES = {};\nvar AUTHORITY = {};\nvar HOST = {};\nvar HOSTNAME = {};\nvar PORT = {};\nvar FILE = {};\nvar FILE_SLASH = {};\nvar FILE_HOST = {};\nvar PATH_START = {};\nvar PATH = {};\nvar CANNOT_BE_A_BASE_URL_PATH = {};\nvar QUERY = {};\nvar FRAGMENT = {};\nvar parseURL = function (url, input, stateOverride, base) {\n var state = stateOverride || SCHEME_START;\n var pointer = 0;\n var buffer = '';\n var seenAt = false;\n var seenBracket = false;\n var seenPasswordToken = false;\n var codePoints, char, bufferCodePoints, failure;\n if (!stateOverride) {\n  url.scheme = '';\n  url.username = '';\n  url.password = '';\n  url.host = null;\n  url.port = null;\n  url.path = [];\n  url.query = null;\n  url.fragment = null;\n  url.cannotBeABaseURL = false;\n  input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');\n }\n input = input.replace(TAB_AND_NEW_LINE, '');\n codePoints = arrayFrom(input);\n while (pointer <= codePoints.length) {\n  char = codePoints[pointer];\n  switch (state) {\n  case SCHEME_START:\n   if (char && ALPHA.test(char)) {\n    buffer += char.toLowerCase();\n    state = SCHEME;\n   } else if (!stateOverride) {\n    state = NO_SCHEME;\n    continue;\n   } else\n    return INVALID_SCHEME;\n   break;\n  case SCHEME:\n   if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {\n    buffer += char.toLowerCase();\n   } else if (char == ':') {\n    if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == 'file' && (includesCredentials(url) || url.port !== null) || url.scheme == 'file' && !url.host))\n     return;\n    url.scheme = buffer;\n    if (stateOverride) {\n     if (isSpecial(url) && specialSchemes[url.scheme] == url.port)\n      url.port = null;\n     return;\n    }\n    buffer = '';\n    if (url.scheme == 'file') {\n     state = FILE;\n    } else if (isSpecial(url) && base && base.scheme == url.scheme) {\n     state = SPECIAL_RELATIVE_OR_AUTHORITY;\n    } else if (isSpecial(url)) {\n     state = SPECIAL_AUTHORITY_SLASHES;\n    } else if (codePoints[pointer + 1] == '/') {\n     state = PATH_OR_AUTHORITY;\n     pointer++;\n    } else {\n     url.cannotBeABaseURL = true;\n     url.path.push('');\n     state = CANNOT_BE_A_BASE_URL_PATH;\n    }\n   } else if (!stateOverride) {\n    buffer = '';\n    state = NO_SCHEME;\n    pointer = 0;\n    continue;\n   } else\n    return INVALID_SCHEME;\n   break;\n  case NO_SCHEME:\n   if (!base || base.cannotBeABaseURL && char != '#')\n    return INVALID_SCHEME;\n   if (base.cannotBeABaseURL && char == '#') {\n    url.scheme = base.scheme;\n    url.path = base.path.slice();\n    url.query = base.query;\n    url.fragment = '';\n    url.cannotBeABaseURL = true;\n    state = FRAGMENT;\n    break;\n   }\n   state = base.scheme == 'file' ? FILE : RELATIVE;\n   continue;\n  case SPECIAL_RELATIVE_OR_AUTHORITY:\n   if (char == '/' && codePoints[pointer + 1] == '/') {\n    state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n    pointer++;\n   } else {\n    state = RELATIVE;\n    continue;\n   }\n   break;\n  case PATH_OR_AUTHORITY:\n   if (char == '/') {\n    state = AUTHORITY;\n    break;\n   } else {\n    state = PATH;\n    continue;\n   }\n  case RELATIVE:\n   url.scheme = base.scheme;\n   if (char == EOF) {\n    url.username = base.username;\n    url.password = base.password;\n    url.host = base.host;\n    url.port = base.port;\n    url.path = base.path.slice();\n    url.query = base.query;\n   } else if (char == '/' || char == '\\\\' && isSpecial(url)) {\n    state = RELATIVE_SLASH;\n   } else if (char == '?') {\n    url.username = base.username;\n    url.password = base.password;\n    url.host = base.host;\n    url.port = base.port;\n    url.path = base.path.slice();\n    url.query = '';\n    state = QUERY;\n   } else if (char == '#') {\n    url.username = base.username;\n    url.password = base.password;\n    url.host = base.host;\n    url.port = base.port;\n    url.path = base.path.slice();\n    url.query = base.query;\n    url.fragment = '';\n    state = FRAGMENT;\n   } else {\n    url.username = base.username;\n    url.password = base.password;\n    url.host = base.host;\n    url.port = base.port;\n    url.path = base.path.slice();\n    url.path.pop();\n    state = PATH;\n    continue;\n   }\n   break;\n  case RELATIVE_SLASH:\n   if (isSpecial(url) && (char == '/' || char == '\\\\')) {\n    state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n   } else if (char == '/') {\n    state = AUTHORITY;\n   } else {\n    url.username = base.username;\n    url.password = base.password;\n    url.host = base.host;\n    url.port = base.port;\n    state = PATH;\n    continue;\n   }\n   break;\n  case SPECIAL_AUTHORITY_SLASHES:\n   state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n   if (char != '/' || buffer.charAt(pointer + 1) != '/')\n    continue;\n   pointer++;\n   break;\n  case SPECIAL_AUTHORITY_IGNORE_SLASHES:\n   if (char != '/' && char != '\\\\') {\n    state = AUTHORITY;\n    continue;\n   }\n   break;\n  case AUTHORITY:\n   if (char == '@') {\n    if (seenAt)\n     buffer = '%40' + buffer;\n    seenAt = true;\n    bufferCodePoints = arrayFrom(buffer);\n    for (var i = 0; i < bufferCodePoints.length; i++) {\n     var codePoint = bufferCodePoints[i];\n     if (codePoint == ':' && !seenPasswordToken) {\n      seenPasswordToken = true;\n      continue;\n     }\n     var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);\n     if (seenPasswordToken)\n      url.password += encodedCodePoints;\n     else\n      url.username += encodedCodePoints;\n    }\n    buffer = '';\n   } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\\\' && isSpecial(url)) {\n    if (seenAt && buffer == '')\n     return INVALID_AUTHORITY;\n    pointer -= arrayFrom(buffer).length + 1;\n    buffer = '';\n    state = HOST;\n   } else\n    buffer += char;\n   break;\n  case HOST:\n  case HOSTNAME:\n   if (stateOverride && url.scheme == 'file') {\n    state = FILE_HOST;\n    continue;\n   } else if (char == ':' && !seenBracket) {\n    if (buffer == '')\n     return INVALID_HOST;\n    failure = parseHost(url, buffer);\n    if (failure)\n     return failure;\n    buffer = '';\n    state = PORT;\n    if (stateOverride == HOSTNAME)\n     return;\n   } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\\\' && isSpecial(url)) {\n    if (isSpecial(url) && buffer == '')\n     return INVALID_HOST;\n    if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null))\n     return;\n    failure = parseHost(url, buffer);\n    if (failure)\n     return failure;\n    buffer = '';\n    state = PATH_START;\n    if (stateOverride)\n     return;\n    continue;\n   } else {\n    if (char == '[')\n     seenBracket = true;\n    else if (char == ']')\n     seenBracket = false;\n    buffer += char;\n   }\n   break;\n  case PORT:\n   if (DIGIT.test(char)) {\n    buffer += char;\n   } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\\\' && isSpecial(url) || stateOverride) {\n    if (buffer != '') {\n     var port = parseInt(buffer, 10);\n     if (port > 0xFFFF)\n      return INVALID_PORT;\n     url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;\n     buffer = '';\n    }\n    if (stateOverride)\n     return;\n    state = PATH_START;\n    continue;\n   } else\n    return INVALID_PORT;\n   break;\n  case FILE:\n   url.scheme = 'file';\n   if (char == '/' || char == '\\\\')\n    state = FILE_SLASH;\n   else if (base && base.scheme == 'file') {\n    if (char == EOF) {\n     url.host = base.host;\n     url.path = base.path.slice();\n     url.query = base.query;\n    } else if (char == '?') {\n     url.host = base.host;\n     url.path = base.path.slice();\n     url.query = '';\n     state = QUERY;\n    } else if (char == '#') {\n     url.host = base.host;\n     url.path = base.path.slice();\n     url.query = base.query;\n     url.fragment = '';\n     state = FRAGMENT;\n    } else {\n     if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {\n      url.host = base.host;\n      url.path = base.path.slice();\n      shortenURLsPath(url);\n     }\n     state = PATH;\n     continue;\n    }\n   } else {\n    state = PATH;\n    continue;\n   }\n   break;\n  case FILE_SLASH:\n   if (char == '/' || char == '\\\\') {\n    state = FILE_HOST;\n    break;\n   }\n   if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {\n    if (isWindowsDriveLetter(base.path[0], true))\n     url.path.push(base.path[0]);\n    else\n     url.host = base.host;\n   }\n   state = PATH;\n   continue;\n  case FILE_HOST:\n   if (char == EOF || char == '/' || char == '\\\\' || char == '?' || char == '#') {\n    if (!stateOverride && isWindowsDriveLetter(buffer)) {\n     state = PATH;\n    } else if (buffer == '') {\n     url.host = '';\n     if (stateOverride)\n      return;\n     state = PATH_START;\n    } else {\n     failure = parseHost(url, buffer);\n     if (failure)\n      return failure;\n     if (url.host == 'localhost')\n      url.host = '';\n     if (stateOverride)\n      return;\n     buffer = '';\n     state = PATH_START;\n    }\n    continue;\n   } else\n    buffer += char;\n   break;\n  case PATH_START:\n   if (isSpecial(url)) {\n    state = PATH;\n    if (char != '/' && char != '\\\\')\n     continue;\n   } else if (!stateOverride && char == '?') {\n    url.query = '';\n    state = QUERY;\n   } else if (!stateOverride && char == '#') {\n    url.fragment = '';\n    state = FRAGMENT;\n   } else if (char != EOF) {\n    state = PATH;\n    if (char != '/')\n     continue;\n   }\n   break;\n  case PATH:\n   if (char == EOF || char == '/' || char == '\\\\' && isSpecial(url) || !stateOverride && (char == '?' || char == '#')) {\n    if (isDoubleDot(buffer)) {\n     shortenURLsPath(url);\n     if (char != '/' && !(char == '\\\\' && isSpecial(url))) {\n      url.path.push('');\n     }\n    } else if (isSingleDot(buffer)) {\n     if (char != '/' && !(char == '\\\\' && isSpecial(url))) {\n      url.path.push('');\n     }\n    } else {\n     if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {\n      if (url.host)\n       url.host = '';\n      buffer = buffer.charAt(0) + ':';\n     }\n     url.path.push(buffer);\n    }\n    buffer = '';\n    if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {\n     while (url.path.length > 1 && url.path[0] === '') {\n      url.path.shift();\n     }\n    }\n    if (char == '?') {\n     url.query = '';\n     state = QUERY;\n    } else if (char == '#') {\n     url.fragment = '';\n     state = FRAGMENT;\n    }\n   } else {\n    buffer += percentEncode(char, pathPercentEncodeSet);\n   }\n   break;\n  case CANNOT_BE_A_BASE_URL_PATH:\n   if (char == '?') {\n    url.query = '';\n    state = QUERY;\n   } else if (char == '#') {\n    url.fragment = '';\n    state = FRAGMENT;\n   } else if (char != EOF) {\n    url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);\n   }\n   break;\n  case QUERY:\n   if (!stateOverride && char == '#') {\n    url.fragment = '';\n    state = FRAGMENT;\n   } else if (char != EOF) {\n    if (char == \"'\" && isSpecial(url))\n     url.query += '%27';\n    else if (char == '#')\n     url.query += '%23';\n    else\n     url.query += percentEncode(char, C0ControlPercentEncodeSet);\n   }\n   break;\n  case FRAGMENT:\n   if (char != EOF)\n    url.fragment += percentEncode(char, fragmentPercentEncodeSet);\n   break;\n  }\n  pointer++;\n }\n};\nvar URLConstructor = function URL(url) {\n var that = anInstance(this, URLConstructor, 'URL');\n var base = arguments.length > 1 ? arguments[1] : undefined;\n var urlString = String(url);\n var state = setInternalState(that, { type: 'URL' });\n var baseState, failure;\n if (base !== undefined) {\n  if (base instanceof URLConstructor)\n   baseState = getInternalURLState(base);\n  else {\n   failure = parseURL(baseState = {}, String(base));\n   if (failure)\n    throw TypeError(failure);\n  }\n }\n failure = parseURL(state, urlString, null, baseState);\n if (failure)\n  throw TypeError(failure);\n var searchParams = state.searchParams = new URLSearchParams();\n var searchParamsState = getInternalSearchParamsState(searchParams);\n searchParamsState.updateSearchParams(state.query);\n searchParamsState.updateURL = function () {\n  state.query = String(searchParams) || null;\n };\n if (!DESCRIPTORS) {\n  that.href = serializeURL.call(that);\n  that.origin = getOrigin.call(that);\n  that.protocol = getProtocol.call(that);\n  that.username = getUsername.call(that);\n  that.password = getPassword.call(that);\n  that.host = getHost.call(that);\n  that.hostname = getHostname.call(that);\n  that.port = getPort.call(that);\n  that.pathname = getPathname.call(that);\n  that.search = getSearch.call(that);\n  that.searchParams = getSearchParams.call(that);\n  that.hash = getHash.call(that);\n }\n};\nvar URLPrototype = URLConstructor.prototype;\nvar serializeURL = function () {\n var url = getInternalURLState(this);\n var scheme = url.scheme;\n var username = url.username;\n var password = url.password;\n var host = url.host;\n var port = url.port;\n var path = url.path;\n var query = url.query;\n var fragment = url.fragment;\n var output = scheme + ':';\n if (host !== null) {\n  output += '//';\n  if (includesCredentials(url)) {\n   output += username + (password ? ':' + password : '') + '@';\n  }\n  output += serializeHost(host);\n  if (port !== null)\n   output += ':' + port;\n } else if (scheme == 'file')\n  output += '//';\n output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';\n if (query !== null)\n  output += '?' + query;\n if (fragment !== null)\n  output += '#' + fragment;\n return output;\n};\nvar getOrigin = function () {\n var url = getInternalURLState(this);\n var scheme = url.scheme;\n var port = url.port;\n if (scheme == 'blob')\n  try {\n   return new URL(scheme.path[0]).origin;\n  } catch (error) {\n   return 'null';\n  }\n if (scheme == 'file' || !isSpecial(url))\n  return 'null';\n return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');\n};\nvar getProtocol = function () {\n return getInternalURLState(this).scheme + ':';\n};\nvar getUsername = function () {\n return getInternalURLState(this).username;\n};\nvar getPassword = function () {\n return getInternalURLState(this).password;\n};\nvar getHost = function () {\n var url = getInternalURLState(this);\n var host = url.host;\n var port = url.port;\n return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;\n};\nvar getHostname = function () {\n var host = getInternalURLState(this).host;\n return host === null ? '' : serializeHost(host);\n};\nvar getPort = function () {\n var port = getInternalURLState(this).port;\n return port === null ? '' : String(port);\n};\nvar getPathname = function () {\n var url = getInternalURLState(this);\n var path = url.path;\n return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';\n};\nvar getSearch = function () {\n var query = getInternalURLState(this).query;\n return query ? '?' + query : '';\n};\nvar getSearchParams = function () {\n return getInternalURLState(this).searchParams;\n};\nvar getHash = function () {\n var fragment = getInternalURLState(this).fragment;\n return fragment ? '#' + fragment : '';\n};\nvar accessorDescriptor = function (getter, setter) {\n return {\n  get: getter,\n  set: setter,\n  configurable: true,\n  enumerable: true\n };\n};\nif (DESCRIPTORS) {\n defineProperties(URLPrototype, {\n  href: accessorDescriptor(serializeURL, function (href) {\n   var url = getInternalURLState(this);\n   var urlString = String(href);\n   var failure = parseURL(url, urlString);\n   if (failure)\n    throw TypeError(failure);\n   getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);\n  }),\n  origin: accessorDescriptor(getOrigin),\n  protocol: accessorDescriptor(getProtocol, function (protocol) {\n   var url = getInternalURLState(this);\n   parseURL(url, String(protocol) + ':', SCHEME_START);\n  }),\n  username: accessorDescriptor(getUsername, function (username) {\n   var url = getInternalURLState(this);\n   var codePoints = arrayFrom(String(username));\n   if (cannotHaveUsernamePasswordPort(url))\n    return;\n   url.username = '';\n   for (var i = 0; i < codePoints.length; i++) {\n    url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);\n   }\n  }),\n  password: accessorDescriptor(getPassword, function (password) {\n   var url = getInternalURLState(this);\n   var codePoints = arrayFrom(String(password));\n   if (cannotHaveUsernamePasswordPort(url))\n    return;\n   url.password = '';\n   for (var i = 0; i < codePoints.length; i++) {\n    url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);\n   }\n  }),\n  host: accessorDescriptor(getHost, function (host) {\n   var url = getInternalURLState(this);\n   if (url.cannotBeABaseURL)\n    return;\n   parseURL(url, String(host), HOST);\n  }),\n  hostname: accessorDescriptor(getHostname, function (hostname) {\n   var url = getInternalURLState(this);\n   if (url.cannotBeABaseURL)\n    return;\n   parseURL(url, String(hostname), HOSTNAME);\n  }),\n  port: accessorDescriptor(getPort, function (port) {\n   var url = getInternalURLState(this);\n   if (cannotHaveUsernamePasswordPort(url))\n    return;\n   port = String(port);\n   if (port == '')\n    url.port = null;\n   else\n    parseURL(url, port, PORT);\n  }),\n  pathname: accessorDescriptor(getPathname, function (pathname) {\n   var url = getInternalURLState(this);\n   if (url.cannotBeABaseURL)\n    return;\n   url.path = [];\n   parseURL(url, pathname + '', PATH_START);\n  }),\n  search: accessorDescriptor(getSearch, function (search) {\n   var url = getInternalURLState(this);\n   search = String(search);\n   if (search == '') {\n    url.query = null;\n   } else {\n    if ('?' == search.charAt(0))\n     search = search.slice(1);\n    url.query = '';\n    parseURL(url, search, QUERY);\n   }\n   getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);\n  }),\n  searchParams: accessorDescriptor(getSearchParams),\n  hash: accessorDescriptor(getHash, function (hash) {\n   var url = getInternalURLState(this);\n   hash = String(hash);\n   if (hash == '') {\n    url.fragment = null;\n    return;\n   }\n   if ('#' == hash.charAt(0))\n    hash = hash.slice(1);\n   url.fragment = '';\n   parseURL(url, hash, FRAGMENT);\n  })\n });\n}\nredefine(URLPrototype, 'toJSON', function toJSON() {\n return serializeURL.call(this);\n}, { enumerable: true });\nredefine(URLPrototype, 'toString', function toString() {\n return serializeURL.call(this);\n}, { enumerable: true });\nif (NativeURL) {\n var nativeCreateObjectURL = NativeURL.createObjectURL;\n var nativeRevokeObjectURL = NativeURL.revokeObjectURL;\n if (nativeCreateObjectURL)\n  redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {\n   return nativeCreateObjectURL.apply(NativeURL, arguments);\n  });\n if (nativeRevokeObjectURL)\n  redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {\n   return nativeRevokeObjectURL.apply(NativeURL, arguments);\n  });\n}\nsetToStringTag(URLConstructor, 'URL');\n$({\n global: true,\n forced: !USE_NATIVE_URL,\n sham: !DESCRIPTORS\n}, { URL: URLConstructor });\n\n/***/ }),\n/* 113 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(13);\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar IS_PURE = __w_pdfjs_require__(36);\nvar ITERATOR = wellKnownSymbol('iterator');\nmodule.exports = !fails(function () {\n var url = new URL('b?a=1&b=2&c=3', 'http://a');\n var searchParams = url.searchParams;\n var result = '';\n url.pathname = 'c%20d';\n searchParams.forEach(function (value, key) {\n  searchParams['delete']('b');\n  result += key + value;\n });\n return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR] || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b' || new URL('http://').host !== 'xn--e1aybc' || new URL('http://a#').hash !== '#%D0%B1' || result !== 'a1c3' || new URL('http://x', undefined).host !== 'x';\n});\n\n/***/ }),\n/* 114 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar DESCRIPTORS = __w_pdfjs_require__(12);\nvar fails = __w_pdfjs_require__(13);\nvar objectKeys = __w_pdfjs_require__(60);\nvar getOwnPropertySymbolsModule = __w_pdfjs_require__(50);\nvar propertyIsEnumerableModule = __w_pdfjs_require__(14);\nvar toObject = __w_pdfjs_require__(67);\nvar IndexedObject = __w_pdfjs_require__(17);\nvar nativeAssign = Object.assign;\nvar defineProperty = Object.defineProperty;\nmodule.exports = !nativeAssign || fails(function () {\n if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, 'a', {\n   enumerable: true,\n   get: function () {\n    defineProperty(this, 'b', {\n     value: 3,\n     enumerable: false\n    });\n   }\n  }), { b: 2 })).b !== 1)\n  return true;\n var A = {};\n var B = {};\n var symbol = Symbol();\n var alphabet = 'abcdefghijklmnopqrst';\n A[symbol] = 7;\n alphabet.split('').forEach(function (chr) {\n  B[chr] = chr;\n });\n return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) {\n var T = toObject(target);\n var argumentsLength = arguments.length;\n var index = 1;\n var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n var propertyIsEnumerable = propertyIsEnumerableModule.f;\n while (argumentsLength > index) {\n  var S = IndexedObject(arguments[index++]);\n  var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n  var length = keys.length;\n  var j = 0;\n  var key;\n  while (length > j) {\n   key = keys[j++];\n   if (!DESCRIPTORS || propertyIsEnumerable.call(S, key))\n    T[key] = S[key];\n  }\n }\n return T;\n} : nativeAssign;\n\n/***/ }),\n/* 115 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar bind = __w_pdfjs_require__(75);\nvar toObject = __w_pdfjs_require__(67);\nvar callWithSafeIterationClosing = __w_pdfjs_require__(116);\nvar isArrayIteratorMethod = __w_pdfjs_require__(74);\nvar toLength = __w_pdfjs_require__(46);\nvar createProperty = __w_pdfjs_require__(81);\nvar getIteratorMethod = __w_pdfjs_require__(77);\nmodule.exports = function from(arrayLike) {\n var O = toObject(arrayLike);\n var C = typeof this == 'function' ? this : Array;\n var argumentsLength = arguments.length;\n var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n var mapping = mapfn !== undefined;\n var iteratorMethod = getIteratorMethod(O);\n var index = 0;\n var length, result, step, iterator, next, value;\n if (mapping)\n  mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);\n if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n  iterator = iteratorMethod.call(O);\n  next = iterator.next;\n  result = new C();\n  for (; !(step = next.call(iterator)).done; index++) {\n   value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [\n    step.value,\n    index\n   ], true) : step.value;\n   createProperty(result, index, value);\n  }\n } else {\n  length = toLength(O.length);\n  result = new C(length);\n  for (; length > index; index++) {\n   value = mapping ? mapfn(O[index], index) : O[index];\n   createProperty(result, index, value);\n  }\n }\n result.length = index;\n return result;\n};\n\n/***/ }),\n/* 116 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(27);\nvar iteratorClose = __w_pdfjs_require__(80);\nmodule.exports = function (iterator, fn, value, ENTRIES) {\n try {\n  return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n } catch (error) {\n  iteratorClose(iterator);\n  throw error;\n }\n};\n\n/***/ }),\n/* 117 */\n/***/ (function(module) {\n\n\"use strict\";\n\nvar maxInt = 2147483647;\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128;\nvar delimiter = '-';\nvar regexNonASCII = /[^\\0-\\u007E]/;\nvar regexSeparators = /[.\\u3002\\uFF0E\\uFF61]/g;\nvar OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\nvar ucs2decode = function (string) {\n var output = [];\n var counter = 0;\n var length = string.length;\n while (counter < length) {\n  var value = string.charCodeAt(counter++);\n  if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n   var extra = string.charCodeAt(counter++);\n   if ((extra & 0xFC00) == 0xDC00) {\n    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n   } else {\n    output.push(value);\n    counter--;\n   }\n  } else {\n   output.push(value);\n  }\n }\n return output;\n};\nvar digitToBasic = function (digit) {\n return digit + 22 + 75 * (digit < 26);\n};\nvar adapt = function (delta, numPoints, firstTime) {\n var k = 0;\n delta = firstTime ? floor(delta / damp) : delta >> 1;\n delta += floor(delta / numPoints);\n for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n  delta = floor(delta / baseMinusTMin);\n }\n return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\nvar encode = function (input) {\n var output = [];\n input = ucs2decode(input);\n var inputLength = input.length;\n var n = initialN;\n var delta = 0;\n var bias = initialBias;\n var i, currentValue;\n for (i = 0; i < input.length; i++) {\n  currentValue = input[i];\n  if (currentValue < 0x80) {\n   output.push(stringFromCharCode(currentValue));\n  }\n }\n var basicLength = output.length;\n var handledCPCount = basicLength;\n if (basicLength) {\n  output.push(delimiter);\n }\n while (handledCPCount < inputLength) {\n  var m = maxInt;\n  for (i = 0; i < input.length; i++) {\n   currentValue = input[i];\n   if (currentValue >= n && currentValue < m) {\n    m = currentValue;\n   }\n  }\n  var handledCPCountPlusOne = handledCPCount + 1;\n  if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n   throw RangeError(OVERFLOW_ERROR);\n  }\n  delta += (m - n) * handledCPCountPlusOne;\n  n = m;\n  for (i = 0; i < input.length; i++) {\n   currentValue = input[i];\n   if (currentValue < n && ++delta > maxInt) {\n    throw RangeError(OVERFLOW_ERROR);\n   }\n   if (currentValue == n) {\n    var q = delta;\n    for (var k = base;; k += base) {\n     var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n     if (q < t)\n      break;\n     var qMinusT = q - t;\n     var baseMinusT = base - t;\n     output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));\n     q = floor(qMinusT / baseMinusT);\n    }\n    output.push(stringFromCharCode(digitToBasic(q)));\n    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n    delta = 0;\n    ++handledCPCount;\n   }\n  }\n  ++delta;\n  ++n;\n }\n return output.join('');\n};\nmodule.exports = function (input) {\n var encoded = [];\n var labels = input.toLowerCase().replace(regexSeparators, '\\u002E').split('.');\n var i, label;\n for (i = 0; i < labels.length; i++) {\n  label = labels[i];\n  encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);\n }\n return encoded.join('.');\n};\n\n/***/ }),\n/* 118 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n__w_pdfjs_require__(53);\nvar $ = __w_pdfjs_require__(9);\nvar getBuiltIn = __w_pdfjs_require__(41);\nvar USE_NATIVE_URL = __w_pdfjs_require__(113);\nvar redefine = __w_pdfjs_require__(28);\nvar redefineAll = __w_pdfjs_require__(88);\nvar setToStringTag = __w_pdfjs_require__(69);\nvar createIteratorConstructor = __w_pdfjs_require__(64);\nvar InternalStateModule = __w_pdfjs_require__(32);\nvar anInstance = __w_pdfjs_require__(90);\nvar hasOwn = __w_pdfjs_require__(22);\nvar bind = __w_pdfjs_require__(75);\nvar classof = __w_pdfjs_require__(78);\nvar anObject = __w_pdfjs_require__(27);\nvar isObject = __w_pdfjs_require__(21);\nvar create = __w_pdfjs_require__(58);\nvar createPropertyDescriptor = __w_pdfjs_require__(15);\nvar getIterator = __w_pdfjs_require__(119);\nvar getIteratorMethod = __w_pdfjs_require__(77);\nvar wellKnownSymbol = __w_pdfjs_require__(55);\nvar $fetch = getBuiltIn('fetch');\nvar Headers = getBuiltIn('Headers');\nvar ITERATOR = wellKnownSymbol('iterator');\nvar URL_SEARCH_PARAMS = 'URLSearchParams';\nvar URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);\nvar getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);\nvar plus = /\\+/g;\nvar sequences = Array(4);\nvar percentSequence = function (bytes) {\n return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\\\da-f]{2}){' + bytes + '})', 'gi'));\n};\nvar percentDecode = function (sequence) {\n try {\n  return decodeURIComponent(sequence);\n } catch (error) {\n  return sequence;\n }\n};\nvar deserialize = function (it) {\n var result = it.replace(plus, ' ');\n var bytes = 4;\n try {\n  return decodeURIComponent(result);\n } catch (error) {\n  while (bytes) {\n   result = result.replace(percentSequence(bytes--), percentDecode);\n  }\n  return result;\n }\n};\nvar find = /[!'()~]|%20/g;\nvar replace = {\n '!': '%21',\n \"'\": '%27',\n '(': '%28',\n ')': '%29',\n '~': '%7E',\n '%20': '+'\n};\nvar replacer = function (match) {\n return replace[match];\n};\nvar serialize = function (it) {\n return encodeURIComponent(it).replace(find, replacer);\n};\nvar parseSearchParams = function (result, query) {\n if (query) {\n  var attributes = query.split('&');\n  var index = 0;\n  var attribute, entry;\n  while (index < attributes.length) {\n   attribute = attributes[index++];\n   if (attribute.length) {\n    entry = attribute.split('=');\n    result.push({\n     key: deserialize(entry.shift()),\n     value: deserialize(entry.join('='))\n    });\n   }\n  }\n }\n};\nvar updateSearchParams = function (query) {\n this.entries.length = 0;\n parseSearchParams(this.entries, query);\n};\nvar validateArgumentsLength = function (passed, required) {\n if (passed < required)\n  throw TypeError('Not enough arguments');\n};\nvar URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {\n setInternalState(this, {\n  type: URL_SEARCH_PARAMS_ITERATOR,\n  iterator: getIterator(getInternalParamsState(params).entries),\n  kind: kind\n });\n}, 'Iterator', function next() {\n var state = getInternalIteratorState(this);\n var kind = state.kind;\n var step = state.iterator.next();\n var entry = step.value;\n if (!step.done) {\n  step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [\n   entry.key,\n   entry.value\n  ];\n }\n return step;\n});\nvar URLSearchParamsConstructor = function URLSearchParams() {\n anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);\n var init = arguments.length > 0 ? arguments[0] : undefined;\n var that = this;\n var entries = [];\n var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;\n setInternalState(that, {\n  type: URL_SEARCH_PARAMS,\n  entries: entries,\n  updateURL: function () {\n  },\n  updateSearchParams: updateSearchParams\n });\n if (init !== undefined) {\n  if (isObject(init)) {\n   iteratorMethod = getIteratorMethod(init);\n   if (typeof iteratorMethod === 'function') {\n    iterator = iteratorMethod.call(init);\n    next = iterator.next;\n    while (!(step = next.call(iterator)).done) {\n     entryIterator = getIterator(anObject(step.value));\n     entryNext = entryIterator.next;\n     if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done)\n      throw TypeError('Expected sequence with length 2');\n     entries.push({\n      key: first.value + '',\n      value: second.value + ''\n     });\n    }\n   } else\n    for (key in init)\n     if (hasOwn(init, key))\n      entries.push({\n       key: key,\n       value: init[key] + ''\n      });\n  } else {\n   parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');\n  }\n }\n};\nvar URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;\nredefineAll(URLSearchParamsPrototype, {\n append: function append(name, value) {\n  validateArgumentsLength(arguments.length, 2);\n  var state = getInternalParamsState(this);\n  state.entries.push({\n   key: name + '',\n   value: value + ''\n  });\n  state.updateURL();\n },\n 'delete': function (name) {\n  validateArgumentsLength(arguments.length, 1);\n  var state = getInternalParamsState(this);\n  var entries = state.entries;\n  var key = name + '';\n  var index = 0;\n  while (index < entries.length) {\n   if (entries[index].key === key)\n    entries.splice(index, 1);\n   else\n    index++;\n  }\n  state.updateURL();\n },\n get: function get(name) {\n  validateArgumentsLength(arguments.length, 1);\n  var entries = getInternalParamsState(this).entries;\n  var key = name + '';\n  var index = 0;\n  for (; index < entries.length; index++) {\n   if (entries[index].key === key)\n    return entries[index].value;\n  }\n  return null;\n },\n getAll: function getAll(name) {\n  validateArgumentsLength(arguments.length, 1);\n  var entries = getInternalParamsState(this).entries;\n  var key = name + '';\n  var result = [];\n  var index = 0;\n  for (; index < entries.length; index++) {\n   if (entries[index].key === key)\n    result.push(entries[index].value);\n  }\n  return result;\n },\n has: function has(name) {\n  validateArgumentsLength(arguments.length, 1);\n  var entries = getInternalParamsState(this).entries;\n  var key = name + '';\n  var index = 0;\n  while (index < entries.length) {\n   if (entries[index++].key === key)\n    return true;\n  }\n  return false;\n },\n set: function set(name, value) {\n  validateArgumentsLength(arguments.length, 1);\n  var state = getInternalParamsState(this);\n  var entries = state.entries;\n  var found = false;\n  var key = name + '';\n  var val = value + '';\n  var index = 0;\n  var entry;\n  for (; index < entries.length; index++) {\n   entry = entries[index];\n   if (entry.key === key) {\n    if (found)\n     entries.splice(index--, 1);\n    else {\n     found = true;\n     entry.value = val;\n    }\n   }\n  }\n  if (!found)\n   entries.push({\n    key: key,\n    value: val\n   });\n  state.updateURL();\n },\n sort: function sort() {\n  var state = getInternalParamsState(this);\n  var entries = state.entries;\n  var slice = entries.slice();\n  var entry, entriesIndex, sliceIndex;\n  entries.length = 0;\n  for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {\n   entry = slice[sliceIndex];\n   for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {\n    if (entries[entriesIndex].key > entry.key) {\n     entries.splice(entriesIndex, 0, entry);\n     break;\n    }\n   }\n   if (entriesIndex === sliceIndex)\n    entries.push(entry);\n  }\n  state.updateURL();\n },\n forEach: function forEach(callback) {\n  var entries = getInternalParamsState(this).entries;\n  var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);\n  var index = 0;\n  var entry;\n  while (index < entries.length) {\n   entry = entries[index++];\n   boundFunction(entry.value, entry.key, this);\n  }\n },\n keys: function keys() {\n  return new URLSearchParamsIterator(this, 'keys');\n },\n values: function values() {\n  return new URLSearchParamsIterator(this, 'values');\n },\n entries: function entries() {\n  return new URLSearchParamsIterator(this, 'entries');\n }\n}, { enumerable: true });\nredefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);\nredefine(URLSearchParamsPrototype, 'toString', function toString() {\n var entries = getInternalParamsState(this).entries;\n var result = [];\n var index = 0;\n var entry;\n while (index < entries.length) {\n  entry = entries[index++];\n  result.push(serialize(entry.key) + '=' + serialize(entry.value));\n }\n return result.join('&');\n}, { enumerable: true });\nsetToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);\n$({\n global: true,\n forced: !USE_NATIVE_URL\n}, { URLSearchParams: URLSearchParamsConstructor });\nif (!USE_NATIVE_URL && typeof $fetch == 'function' && typeof Headers == 'function') {\n $({\n  global: true,\n  enumerable: true,\n  forced: true\n }, {\n  fetch: function fetch(input) {\n   var args = [input];\n   var init, body, headers;\n   if (arguments.length > 1) {\n    init = arguments[1];\n    if (isObject(init)) {\n     body = init.body;\n     if (classof(body) === URL_SEARCH_PARAMS) {\n      headers = init.headers ? new Headers(init.headers) : new Headers();\n      if (!headers.has('content-type')) {\n       headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n      }\n      init = create(init, {\n       body: createPropertyDescriptor(0, String(body)),\n       headers: createPropertyDescriptor(0, headers)\n      });\n     }\n    }\n    args.push(init);\n   }\n   return $fetch.apply(this, args);\n  }\n });\n}\nmodule.exports = {\n URLSearchParams: URLSearchParamsConstructor,\n getState: getInternalParamsState\n};\n\n/***/ }),\n/* 119 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(27);\nvar getIteratorMethod = __w_pdfjs_require__(77);\nmodule.exports = function (it) {\n var iteratorMethod = getIteratorMethod(it);\n if (typeof iteratorMethod != 'function') {\n  throw TypeError(String(it) + ' is not iterable');\n }\n return anObject(iteratorMethod.call(it));\n};\n\n/***/ }),\n/* 120 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(9);\n$({\n target: 'URL',\n proto: true,\n enumerable: true\n}, {\n toJSON: function toJSON() {\n  return URL.prototype.toString.call(this);\n }\n});\n\n/***/ }),\n/* 121 */\n/***/ (function(__unused_webpack_module, exports) {\n\n(function (global, factory) {\n   true ? factory(exports) : 0;\n}(this, function (exports) {\n 'use strict';\n var SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : function (description) {\n  return \"Symbol(\" + description + \")\";\n };\n function noop() {\n }\n function getGlobals() {\n  if (typeof self !== 'undefined') {\n   return self;\n  } else if (typeof window !== 'undefined') {\n   return window;\n  } else if (typeof __webpack_require__.g !== 'undefined') {\n   return __webpack_require__.g;\n  }\n  return undefined;\n }\n var globals = getGlobals();\n function typeIsObject(x) {\n  return typeof x === 'object' && x !== null || typeof x === 'function';\n }\n var rethrowAssertionErrorRejection = noop;\n var originalPromise = Promise;\n var originalPromiseThen = Promise.prototype.then;\n var originalPromiseResolve = Promise.resolve.bind(originalPromise);\n var originalPromiseReject = Promise.reject.bind(originalPromise);\n function newPromise(executor) {\n  return new originalPromise(executor);\n }\n function promiseResolvedWith(value) {\n  return originalPromiseResolve(value);\n }\n function promiseRejectedWith(reason) {\n  return originalPromiseReject(reason);\n }\n function PerformPromiseThen(promise, onFulfilled, onRejected) {\n  return originalPromiseThen.call(promise, onFulfilled, onRejected);\n }\n function uponPromise(promise, onFulfilled, onRejected) {\n  PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n }\n function uponFulfillment(promise, onFulfilled) {\n  uponPromise(promise, onFulfilled);\n }\n function uponRejection(promise, onRejected) {\n  uponPromise(promise, undefined, onRejected);\n }\n function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n }\n function setPromiseIsHandledToTrue(promise) {\n  PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n }\n var queueMicrotask = function () {\n  var globalQueueMicrotask = globals && globals.queueMicrotask;\n  if (typeof globalQueueMicrotask === 'function') {\n   return globalQueueMicrotask;\n  }\n  var resolvedPromise = promiseResolvedWith(undefined);\n  return function (fn) {\n   return PerformPromiseThen(resolvedPromise, fn);\n  };\n }();\n function reflectCall(F, V, args) {\n  if (typeof F !== 'function') {\n   throw new TypeError('Argument is not a function');\n  }\n  return Function.prototype.apply.call(F, V, args);\n }\n function promiseCall(F, V, args) {\n  try {\n   return promiseResolvedWith(reflectCall(F, V, args));\n  } catch (value) {\n   return promiseRejectedWith(value);\n  }\n }\n var QUEUE_MAX_ARRAY_SIZE = 16384;\n var SimpleQueue = function () {\n  function SimpleQueue() {\n   this._cursor = 0;\n   this._size = 0;\n   this._front = {\n    _elements: [],\n    _next: undefined\n   };\n   this._back = this._front;\n   this._cursor = 0;\n   this._size = 0;\n  }\n  Object.defineProperty(SimpleQueue.prototype, \"length\", {\n   get: function () {\n    return this._size;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  SimpleQueue.prototype.push = function (element) {\n   var oldBack = this._back;\n   var newBack = oldBack;\n   if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n    newBack = {\n     _elements: [],\n     _next: undefined\n    };\n   }\n   oldBack._elements.push(element);\n   if (newBack !== oldBack) {\n    this._back = newBack;\n    oldBack._next = newBack;\n   }\n   ++this._size;\n  };\n  SimpleQueue.prototype.shift = function () {\n   var oldFront = this._front;\n   var newFront = oldFront;\n   var oldCursor = this._cursor;\n   var newCursor = oldCursor + 1;\n   var elements = oldFront._elements;\n   var element = elements[oldCursor];\n   if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n    newFront = oldFront._next;\n    newCursor = 0;\n   }\n   --this._size;\n   this._cursor = newCursor;\n   if (oldFront !== newFront) {\n    this._front = newFront;\n   }\n   elements[oldCursor] = undefined;\n   return element;\n  };\n  SimpleQueue.prototype.forEach = function (callback) {\n   var i = this._cursor;\n   var node = this._front;\n   var elements = node._elements;\n   while (i !== elements.length || node._next !== undefined) {\n    if (i === elements.length) {\n     node = node._next;\n     elements = node._elements;\n     i = 0;\n     if (elements.length === 0) {\n      break;\n     }\n    }\n    callback(elements[i]);\n    ++i;\n   }\n  };\n  SimpleQueue.prototype.peek = function () {\n   var front = this._front;\n   var cursor = this._cursor;\n   return front._elements[cursor];\n  };\n  return SimpleQueue;\n }();\n function ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n  if (stream._state === 'readable') {\n   defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n   defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n   defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  }\n }\n function ReadableStreamReaderGenericCancel(reader, reason) {\n  var stream = reader._ownerReadableStream;\n  return ReadableStreamCancel(stream, reason);\n }\n function ReadableStreamReaderGenericRelease(reader) {\n  if (reader._ownerReadableStream._state === 'readable') {\n   defaultReaderClosedPromiseReject(reader, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\"));\n  } else {\n   defaultReaderClosedPromiseResetToRejected(reader, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\"));\n  }\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n }\n function readerLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n }\n function defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = newPromise(function (resolve, reject) {\n   reader._closedPromise_resolve = resolve;\n   reader._closedPromise_reject = reject;\n  });\n }\n function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseReject(reader, reason);\n }\n function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseResolve(reader);\n }\n function defaultReaderClosedPromiseReject(reader, reason) {\n  if (reader._closedPromise_reject === undefined) {\n   return;\n  }\n  setPromiseIsHandledToTrue(reader._closedPromise);\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n }\n function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n }\n function defaultReaderClosedPromiseResolve(reader) {\n  if (reader._closedPromise_resolve === undefined) {\n   return;\n  }\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n }\n var AbortSteps = SymbolPolyfill('[[AbortSteps]]');\n var ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\n var CancelSteps = SymbolPolyfill('[[CancelSteps]]');\n var PullSteps = SymbolPolyfill('[[PullSteps]]');\n var NumberIsFinite = Number.isFinite || function (x) {\n  return typeof x === 'number' && isFinite(x);\n };\n var MathTrunc = Math.trunc || function (v) {\n  return v < 0 ? Math.ceil(v) : Math.floor(v);\n };\n function isDictionary(x) {\n  return typeof x === 'object' || typeof x === 'function';\n }\n function assertDictionary(obj, context) {\n  if (obj !== undefined && !isDictionary(obj)) {\n   throw new TypeError(context + \" is not an object.\");\n  }\n }\n function assertFunction(x, context) {\n  if (typeof x !== 'function') {\n   throw new TypeError(context + \" is not a function.\");\n  }\n }\n function isObject(x) {\n  return typeof x === 'object' && x !== null || typeof x === 'function';\n }\n function assertObject(x, context) {\n  if (!isObject(x)) {\n   throw new TypeError(context + \" is not an object.\");\n  }\n }\n function assertRequiredArgument(x, position, context) {\n  if (x === undefined) {\n   throw new TypeError(\"Parameter \" + position + \" is required in '\" + context + \"'.\");\n  }\n }\n function assertRequiredField(x, field, context) {\n  if (x === undefined) {\n   throw new TypeError(field + \" is required in '\" + context + \"'.\");\n  }\n }\n function convertUnrestrictedDouble(value) {\n  return Number(value);\n }\n function censorNegativeZero(x) {\n  return x === 0 ? 0 : x;\n }\n function integerPart(x) {\n  return censorNegativeZero(MathTrunc(x));\n }\n function convertUnsignedLongLongWithEnforceRange(value, context) {\n  var lowerBound = 0;\n  var upperBound = Number.MAX_SAFE_INTEGER;\n  var x = Number(value);\n  x = censorNegativeZero(x);\n  if (!NumberIsFinite(x)) {\n   throw new TypeError(context + \" is not a finite number\");\n  }\n  x = integerPart(x);\n  if (x < lowerBound || x > upperBound) {\n   throw new TypeError(context + \" is outside the accepted range of \" + lowerBound + \" to \" + upperBound + \", inclusive\");\n  }\n  if (!NumberIsFinite(x) || x === 0) {\n   return 0;\n  }\n  return x;\n }\n function assertReadableStream(x, context) {\n  if (!IsReadableStream(x)) {\n   throw new TypeError(context + \" is not a ReadableStream.\");\n  }\n }\n function AcquireReadableStreamDefaultReader(stream) {\n  return new ReadableStreamDefaultReader(stream);\n }\n function ReadableStreamAddReadRequest(stream, readRequest) {\n  stream._reader._readRequests.push(readRequest);\n }\n function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  var reader = stream._reader;\n  var readRequest = reader._readRequests.shift();\n  if (done) {\n   readRequest._closeSteps();\n  } else {\n   readRequest._chunkSteps(chunk);\n  }\n }\n function ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n }\n function ReadableStreamHasDefaultReader(stream) {\n  var reader = stream._reader;\n  if (reader === undefined) {\n   return false;\n  }\n  if (!IsReadableStreamDefaultReader(reader)) {\n   return false;\n  }\n  return true;\n }\n var ReadableStreamDefaultReader = function () {\n  function ReadableStreamDefaultReader(stream) {\n   assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n   assertReadableStream(stream, 'First parameter');\n   if (IsReadableStreamLocked(stream)) {\n    throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n   }\n   ReadableStreamReaderGenericInitialize(this, stream);\n   this._readRequests = new SimpleQueue();\n  }\n  Object.defineProperty(ReadableStreamDefaultReader.prototype, \"closed\", {\n   get: function () {\n    if (!IsReadableStreamDefaultReader(this)) {\n     return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n    }\n    return this._closedPromise;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  ReadableStreamDefaultReader.prototype.cancel = function (reason) {\n   if (reason === void 0) {\n    reason = undefined;\n   }\n   if (!IsReadableStreamDefaultReader(this)) {\n    return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n   }\n   if (this._ownerReadableStream === undefined) {\n    return promiseRejectedWith(readerLockException('cancel'));\n   }\n   return ReadableStreamReaderGenericCancel(this, reason);\n  };\n  ReadableStreamDefaultReader.prototype.read = function () {\n   if (!IsReadableStreamDefaultReader(this)) {\n    return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n   }\n   if (this._ownerReadableStream === undefined) {\n    return promiseRejectedWith(readerLockException('read from'));\n   }\n   var resolvePromise;\n   var rejectPromise;\n   var promise = newPromise(function (resolve, reject) {\n    resolvePromise = resolve;\n    rejectPromise = reject;\n   });\n   var readRequest = {\n    _chunkSteps: function (chunk) {\n     return resolvePromise({\n      value: chunk,\n      done: false\n     });\n    },\n    _closeSteps: function () {\n     return resolvePromise({\n      value: undefined,\n      done: true\n     });\n    },\n    _errorSteps: function (e) {\n     return rejectPromise(e);\n    }\n   };\n   ReadableStreamDefaultReaderRead(this, readRequest);\n   return promise;\n  };\n  ReadableStreamDefaultReader.prototype.releaseLock = function () {\n   if (!IsReadableStreamDefaultReader(this)) {\n    throw defaultReaderBrandCheckException('releaseLock');\n   }\n   if (this._ownerReadableStream === undefined) {\n    return;\n   }\n   if (this._readRequests.length > 0) {\n    throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n   }\n   ReadableStreamReaderGenericRelease(this);\n  };\n  return ReadableStreamDefaultReader;\n }();\n Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n   value: 'ReadableStreamDefaultReader',\n   configurable: true\n  });\n }\n function IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n   return false;\n  }\n  return true;\n }\n function ReadableStreamDefaultReaderRead(reader, readRequest) {\n  var stream = reader._ownerReadableStream;\n  stream._disturbed = true;\n  if (stream._state === 'closed') {\n   readRequest._closeSteps();\n  } else if (stream._state === 'errored') {\n   readRequest._errorSteps(stream._storedError);\n  } else {\n   stream._readableStreamController[PullSteps](readRequest);\n  }\n }\n function defaultReaderBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamDefaultReader.prototype.\" + name + \" can only be used on a ReadableStreamDefaultReader\");\n }\n var _a;\n var AsyncIteratorPrototype;\n if (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n  AsyncIteratorPrototype = (_a = {}, _a[SymbolPolyfill.asyncIterator] = function () {\n   return this;\n  }, _a);\n  Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });\n }\n var ReadableStreamAsyncIteratorImpl = function () {\n  function ReadableStreamAsyncIteratorImpl(reader, preventCancel) {\n   this._ongoingPromise = undefined;\n   this._isFinished = false;\n   this._reader = reader;\n   this._preventCancel = preventCancel;\n  }\n  ReadableStreamAsyncIteratorImpl.prototype.next = function () {\n   var _this = this;\n   var nextSteps = function () {\n    return _this._nextSteps();\n   };\n   this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();\n   return this._ongoingPromise;\n  };\n  ReadableStreamAsyncIteratorImpl.prototype.return = function (value) {\n   var _this = this;\n   var returnSteps = function () {\n    return _this._returnSteps(value);\n   };\n   return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();\n  };\n  ReadableStreamAsyncIteratorImpl.prototype._nextSteps = function () {\n   var _this = this;\n   if (this._isFinished) {\n    return Promise.resolve({\n     value: undefined,\n     done: true\n    });\n   }\n   var reader = this._reader;\n   if (reader._ownerReadableStream === undefined) {\n    return promiseRejectedWith(readerLockException('iterate'));\n   }\n   var resolvePromise;\n   var rejectPromise;\n   var promise = newPromise(function (resolve, reject) {\n    resolvePromise = resolve;\n    rejectPromise = reject;\n   });\n   var readRequest = {\n    _chunkSteps: function (chunk) {\n     _this._ongoingPromise = undefined;\n     queueMicrotask(function () {\n      return resolvePromise({\n       value: chunk,\n       done: false\n      });\n     });\n    },\n    _closeSteps: function () {\n     _this._ongoingPromise = undefined;\n     _this._isFinished = true;\n     ReadableStreamReaderGenericRelease(reader);\n     resolvePromise({\n      value: undefined,\n      done: true\n     });\n    },\n    _errorSteps: function (reason) {\n     _this._ongoingPromise = undefined;\n     _this._isFinished = true;\n     ReadableStreamReaderGenericRelease(reader);\n     rejectPromise(reason);\n    }\n   };\n   ReadableStreamDefaultReaderRead(reader, readRequest);\n   return promise;\n  };\n  ReadableStreamAsyncIteratorImpl.prototype._returnSteps = function (value) {\n   if (this._isFinished) {\n    return Promise.resolve({\n     value: value,\n     done: true\n    });\n   }\n   this._isFinished = true;\n   var reader = this._reader;\n   if (reader._ownerReadableStream === undefined) {\n    return promiseRejectedWith(readerLockException('finish iterating'));\n   }\n   if (!this._preventCancel) {\n    var result = ReadableStreamReaderGenericCancel(reader, value);\n    ReadableStreamReaderGenericRelease(reader);\n    return transformPromiseWith(result, function () {\n     return {\n      value: value,\n      done: true\n     };\n    });\n   }\n   ReadableStreamReaderGenericRelease(reader);\n   return promiseResolvedWith({\n    value: value,\n    done: true\n   });\n  };\n  return ReadableStreamAsyncIteratorImpl;\n }();\n var ReadableStreamAsyncIteratorPrototype = {\n  next: function () {\n   if (!IsReadableStreamAsyncIterator(this)) {\n    return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n   }\n   return this._asyncIteratorImpl.next();\n  },\n  return: function (value) {\n   if (!IsReadableStreamAsyncIterator(this)) {\n    return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n   }\n   return this._asyncIteratorImpl.return(value);\n  }\n };\n if (AsyncIteratorPrototype !== undefined) {\n  Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n }\n function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n  var reader = AcquireReadableStreamDefaultReader(stream);\n  var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n  iterator._asyncIteratorImpl = impl;\n  return iterator;\n }\n function IsReadableStreamAsyncIterator(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n   return false;\n  }\n  return true;\n }\n function streamAsyncIteratorBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamAsyncIterator.\" + name + \" can only be used on a ReadableSteamAsyncIterator\");\n }\n var NumberIsNaN = Number.isNaN || function (x) {\n  return x !== x;\n };\n function IsFiniteNonNegativeNumber(v) {\n  if (!IsNonNegativeNumber(v)) {\n   return false;\n  }\n  if (v === Infinity) {\n   return false;\n  }\n  return true;\n }\n function IsNonNegativeNumber(v) {\n  if (typeof v !== 'number') {\n   return false;\n  }\n  if (NumberIsNaN(v)) {\n   return false;\n  }\n  if (v < 0) {\n   return false;\n  }\n  return true;\n }\n function DequeueValue(container) {\n  var pair = container._queue.shift();\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n   container._queueTotalSize = 0;\n  }\n  return pair.value;\n }\n function EnqueueValueWithSize(container, value, size) {\n  size = Number(size);\n  if (!IsFiniteNonNegativeNumber(size)) {\n   throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n  container._queue.push({\n   value: value,\n   size: size\n  });\n  container._queueTotalSize += size;\n }\n function PeekQueueValue(container) {\n  var pair = container._queue.peek();\n  return pair.value;\n }\n function ResetQueue(container) {\n  container._queue = new SimpleQueue();\n  container._queueTotalSize = 0;\n }\n function CreateArrayFromList(elements) {\n  return elements.slice();\n }\n function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n }\n function TransferArrayBuffer(O) {\n  return O;\n }\n function IsDetachedBuffer(O) {\n  return false;\n }\n var ReadableStreamBYOBRequest = function () {\n  function ReadableStreamBYOBRequest() {\n   throw new TypeError('Illegal constructor');\n  }\n  Object.defineProperty(ReadableStreamBYOBRequest.prototype, \"view\", {\n   get: function () {\n    if (!IsReadableStreamBYOBRequest(this)) {\n     throw byobRequestBrandCheckException('view');\n    }\n    return this._view;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  ReadableStreamBYOBRequest.prototype.respond = function (bytesWritten) {\n   if (!IsReadableStreamBYOBRequest(this)) {\n    throw byobRequestBrandCheckException('respond');\n   }\n   assertRequiredArgument(bytesWritten, 1, 'respond');\n   bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n   if (this._associatedReadableByteStreamController === undefined) {\n    throw new TypeError('This BYOB request has been invalidated');\n   }\n   if (IsDetachedBuffer(this._view.buffer));\n   ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  };\n  ReadableStreamBYOBRequest.prototype.respondWithNewView = function (view) {\n   if (!IsReadableStreamBYOBRequest(this)) {\n    throw byobRequestBrandCheckException('respondWithNewView');\n   }\n   assertRequiredArgument(view, 1, 'respondWithNewView');\n   if (!ArrayBuffer.isView(view)) {\n    throw new TypeError('You can only respond with array buffer views');\n   }\n   if (view.byteLength === 0) {\n    throw new TypeError('chunk must have non-zero byteLength');\n   }\n   if (view.buffer.byteLength === 0) {\n    throw new TypeError(\"chunk's buffer must have non-zero byteLength\");\n   }\n   if (this._associatedReadableByteStreamController === undefined) {\n    throw new TypeError('This BYOB request has been invalidated');\n   }\n   ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  };\n  return ReadableStreamBYOBRequest;\n }();\n Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n  respond: { enumerable: true },\n  respondWithNewView: { enumerable: true },\n  view: { enumerable: true }\n });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n   value: 'ReadableStreamBYOBRequest',\n   configurable: true\n  });\n }\n var ReadableByteStreamController = function () {\n  function ReadableByteStreamController() {\n   throw new TypeError('Illegal constructor');\n  }\n  Object.defineProperty(ReadableByteStreamController.prototype, \"byobRequest\", {\n   get: function () {\n    if (!IsReadableByteStreamController(this)) {\n     throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n    if (this._byobRequest === null && this._pendingPullIntos.length > 0) {\n     var firstDescriptor = this._pendingPullIntos.peek();\n     var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n     var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n     SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n     this._byobRequest = byobRequest;\n    }\n    return this._byobRequest;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  Object.defineProperty(ReadableByteStreamController.prototype, \"desiredSize\", {\n   get: function () {\n    if (!IsReadableByteStreamController(this)) {\n     throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n    return ReadableByteStreamControllerGetDesiredSize(this);\n   },\n   enumerable: false,\n   configurable: true\n  });\n  ReadableByteStreamController.prototype.close = function () {\n   if (!IsReadableByteStreamController(this)) {\n    throw byteStreamControllerBrandCheckException('close');\n   }\n   if (this._closeRequested) {\n    throw new TypeError('The stream has already been closed; do not close it again!');\n   }\n   var state = this._controlledReadableByteStream._state;\n   if (state !== 'readable') {\n    throw new TypeError(\"The stream (in \" + state + \" state) is not in the readable state and cannot be closed\");\n   }\n   ReadableByteStreamControllerClose(this);\n  };\n  ReadableByteStreamController.prototype.enqueue = function (chunk) {\n   if (!IsReadableByteStreamController(this)) {\n    throw byteStreamControllerBrandCheckException('enqueue');\n   }\n   assertRequiredArgument(chunk, 1, 'enqueue');\n   if (!ArrayBuffer.isView(chunk)) {\n    throw new TypeError('chunk must be an array buffer view');\n   }\n   if (chunk.byteLength === 0) {\n    throw new TypeError('chunk must have non-zero byteLength');\n   }\n   if (chunk.buffer.byteLength === 0) {\n    throw new TypeError(\"chunk's buffer must have non-zero byteLength\");\n   }\n   if (this._closeRequested) {\n    throw new TypeError('stream is closed or draining');\n   }\n   var state = this._controlledReadableByteStream._state;\n   if (state !== 'readable') {\n    throw new TypeError(\"The stream (in \" + state + \" state) is not in the readable state and cannot be enqueued to\");\n   }\n   ReadableByteStreamControllerEnqueue(this, chunk);\n  };\n  ReadableByteStreamController.prototype.error = function (e) {\n   if (e === void 0) {\n    e = undefined;\n   }\n   if (!IsReadableByteStreamController(this)) {\n    throw byteStreamControllerBrandCheckException('error');\n   }\n   ReadableByteStreamControllerError(this, e);\n  };\n  ReadableByteStreamController.prototype[CancelSteps] = function (reason) {\n   if (this._pendingPullIntos.length > 0) {\n    var firstDescriptor = this._pendingPullIntos.peek();\n    firstDescriptor.bytesFilled = 0;\n   }\n   ResetQueue(this);\n   var result = this._cancelAlgorithm(reason);\n   ReadableByteStreamControllerClearAlgorithms(this);\n   return result;\n  };\n  ReadableByteStreamController.prototype[PullSteps] = function (readRequest) {\n   var stream = this._controlledReadableByteStream;\n   if (this._queueTotalSize > 0) {\n    var entry = this._queue.shift();\n    this._queueTotalSize -= entry.byteLength;\n    ReadableByteStreamControllerHandleQueueDrain(this);\n    var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n    readRequest._chunkSteps(view);\n    return;\n   }\n   var autoAllocateChunkSize = this._autoAllocateChunkSize;\n   if (autoAllocateChunkSize !== undefined) {\n    var buffer = void 0;\n    try {\n     buffer = new ArrayBuffer(autoAllocateChunkSize);\n    } catch (bufferE) {\n     readRequest._errorSteps(bufferE);\n     return;\n    }\n    var pullIntoDescriptor = {\n     buffer: buffer,\n     byteOffset: 0,\n     byteLength: autoAllocateChunkSize,\n     bytesFilled: 0,\n     elementSize: 1,\n     viewConstructor: Uint8Array,\n     readerType: 'default'\n    };\n    this._pendingPullIntos.push(pullIntoDescriptor);\n   }\n   ReadableStreamAddReadRequest(stream, readRequest);\n   ReadableByteStreamControllerCallPullIfNeeded(this);\n  };\n  return ReadableByteStreamController;\n }();\n Object.defineProperties(ReadableByteStreamController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  byobRequest: { enumerable: true },\n  desiredSize: { enumerable: true }\n });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n   value: 'ReadableByteStreamController',\n   configurable: true\n  });\n }\n function IsReadableByteStreamController(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n   return false;\n  }\n  return true;\n }\n function IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n   return false;\n  }\n  return true;\n }\n function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (!shouldPull) {\n   return;\n  }\n  if (controller._pulling) {\n   controller._pullAgain = true;\n   return;\n  }\n  controller._pulling = true;\n  var pullPromise = controller._pullAlgorithm();\n  uponPromise(pullPromise, function () {\n   controller._pulling = false;\n   if (controller._pullAgain) {\n    controller._pullAgain = false;\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n   }\n  }, function (e) {\n   ReadableByteStreamControllerError(controller, e);\n  });\n }\n function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = new SimpleQueue();\n }\n function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  var done = false;\n  if (stream._state === 'closed') {\n   done = true;\n  }\n  var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n   ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n   ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n }\n function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  var bytesFilled = pullIntoDescriptor.bytesFilled;\n  var elementSize = pullIntoDescriptor.elementSize;\n  return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n }\n function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({\n   buffer: buffer,\n   byteOffset: byteOffset,\n   byteLength: byteLength\n  });\n  controller._queueTotalSize += byteLength;\n }\n function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  var elementSize = pullIntoDescriptor.elementSize;\n  var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n  var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n  var totalBytesToCopyRemaining = maxBytesToCopy;\n  var ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n   totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n   ready = true;\n  }\n  var queue = controller._queue;\n  while (totalBytesToCopyRemaining > 0) {\n   var headOfQueue = queue.peek();\n   var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n   var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n   CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n   if (headOfQueue.byteLength === bytesToCopy) {\n    queue.shift();\n   } else {\n    headOfQueue.byteOffset += bytesToCopy;\n    headOfQueue.byteLength -= bytesToCopy;\n   }\n   controller._queueTotalSize -= bytesToCopy;\n   ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n   totalBytesToCopyRemaining -= bytesToCopy;\n  }\n  return ready;\n }\n function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n }\n function ReadableByteStreamControllerHandleQueueDrain(controller) {\n  if (controller._queueTotalSize === 0 && controller._closeRequested) {\n   ReadableByteStreamControllerClearAlgorithms(controller);\n   ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n   ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n }\n function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === null) {\n   return;\n  }\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = null;\n  controller._byobRequest = null;\n }\n function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  while (controller._pendingPullIntos.length > 0) {\n   if (controller._queueTotalSize === 0) {\n    return;\n   }\n   var pullIntoDescriptor = controller._pendingPullIntos.peek();\n   if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n   }\n  }\n }\n function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n  var stream = controller._controlledReadableByteStream;\n  var elementSize = 1;\n  if (view.constructor !== DataView) {\n   elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n  var ctor = view.constructor;\n  var buffer = TransferArrayBuffer(view.buffer);\n  var pullIntoDescriptor = {\n   buffer: buffer,\n   byteOffset: view.byteOffset,\n   byteLength: view.byteLength,\n   bytesFilled: 0,\n   elementSize: elementSize,\n   viewConstructor: ctor,\n   readerType: 'byob'\n  };\n  if (controller._pendingPullIntos.length > 0) {\n   controller._pendingPullIntos.push(pullIntoDescriptor);\n   ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n   return;\n  }\n  if (stream._state === 'closed') {\n   var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n   readIntoRequest._closeSteps(emptyView);\n   return;\n  }\n  if (controller._queueTotalSize > 0) {\n   if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n    ReadableByteStreamControllerHandleQueueDrain(controller);\n    readIntoRequest._chunkSteps(filledView);\n    return;\n   }\n   if (controller._closeRequested) {\n    var e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n    ReadableByteStreamControllerError(controller, e);\n    readIntoRequest._errorSteps(e);\n    return;\n   }\n  }\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n  ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n }\n function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n  var stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream)) {\n   while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n    ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n   }\n  }\n }\n function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n   throw new RangeError('bytesWritten out of range');\n  }\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n   return;\n  }\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n  var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n   var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n   var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n   ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n }\n function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  var firstDescriptor = controller._pendingPullIntos.peek();\n  var state = controller._controlledReadableByteStream._state;\n  if (state === 'closed') {\n   if (bytesWritten !== 0) {\n    throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n   }\n   ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n   ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n }\n function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  var descriptor = controller._pendingPullIntos.shift();\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n }\n function ReadableByteStreamControllerShouldCallPull(controller) {\n  var stream = controller._controlledReadableByteStream;\n  if (stream._state !== 'readable') {\n   return false;\n  }\n  if (controller._closeRequested) {\n   return false;\n  }\n  if (!controller._started) {\n   return false;\n  }\n  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n   return true;\n  }\n  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n   return true;\n  }\n  var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  if (desiredSize > 0) {\n   return true;\n  }\n  return false;\n }\n function ReadableByteStreamControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n }\n function ReadableByteStreamControllerClose(controller) {\n  var stream = controller._controlledReadableByteStream;\n  if (controller._closeRequested || stream._state !== 'readable') {\n   return;\n  }\n  if (controller._queueTotalSize > 0) {\n   controller._closeRequested = true;\n   return;\n  }\n  if (controller._pendingPullIntos.length > 0) {\n   var firstPendingPullInto = controller._pendingPullIntos.peek();\n   if (firstPendingPullInto.bytesFilled > 0) {\n    var e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n    ReadableByteStreamControllerError(controller, e);\n    throw e;\n   }\n  }\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n }\n function ReadableByteStreamControllerEnqueue(controller, chunk) {\n  var stream = controller._controlledReadableByteStream;\n  if (controller._closeRequested || stream._state !== 'readable') {\n   return;\n  }\n  var buffer = chunk.buffer;\n  var byteOffset = chunk.byteOffset;\n  var byteLength = chunk.byteLength;\n  var transferredBuffer = TransferArrayBuffer(buffer);\n  if (ReadableStreamHasDefaultReader(stream)) {\n   if (ReadableStreamGetNumReadRequests(stream) === 0) {\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n   } else {\n    var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n    ReadableStreamFulfillReadRequest(stream, transferredView, false);\n   }\n  } else if (ReadableStreamHasBYOBReader(stream)) {\n   ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n   ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n   ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n }\n function ReadableByteStreamControllerError(controller, e) {\n  var stream = controller._controlledReadableByteStream;\n  if (stream._state !== 'readable') {\n   return;\n  }\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n }\n function ReadableByteStreamControllerGetDesiredSize(controller) {\n  var state = controller._controlledReadableByteStream._state;\n  if (state === 'errored') {\n   return null;\n  }\n  if (state === 'closed') {\n   return 0;\n  }\n  return controller._strategyHWM - controller._queueTotalSize;\n }\n function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n  if (!IsFiniteNonNegativeNumber(bytesWritten)) {\n   throw new RangeError('bytesWritten must be a finite');\n  }\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n }\n function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  var firstDescriptor = controller._pendingPullIntos.peek();\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n   throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.byteLength !== view.byteLength) {\n   throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n  firstDescriptor.buffer = view.buffer;\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n }\n function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n  controller._controlledReadableByteStream = stream;\n  controller._pullAgain = false;\n  controller._pulling = false;\n  controller._byobRequest = null;\n  controller._queue = controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n  controller._closeRequested = false;\n  controller._started = false;\n  controller._strategyHWM = highWaterMark;\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n  controller._pendingPullIntos = new SimpleQueue();\n  stream._readableStreamController = controller;\n  var startResult = startAlgorithm();\n  uponPromise(promiseResolvedWith(startResult), function () {\n   controller._started = true;\n   ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }, function (r) {\n   ReadableByteStreamControllerError(controller, r);\n  });\n }\n function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n  var controller = Object.create(ReadableByteStreamController.prototype);\n  var startAlgorithm = function () {\n   return undefined;\n  };\n  var pullAlgorithm = function () {\n   return promiseResolvedWith(undefined);\n  };\n  var cancelAlgorithm = function () {\n   return promiseResolvedWith(undefined);\n  };\n  if (underlyingByteSource.start !== undefined) {\n   startAlgorithm = function () {\n    return underlyingByteSource.start(controller);\n   };\n  }\n  if (underlyingByteSource.pull !== undefined) {\n   pullAlgorithm = function () {\n    return underlyingByteSource.pull(controller);\n   };\n  }\n  if (underlyingByteSource.cancel !== undefined) {\n   cancelAlgorithm = function (reason) {\n    return underlyingByteSource.cancel(reason);\n   };\n  }\n  var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize === 0) {\n   throw new TypeError('autoAllocateChunkSize must be greater than 0');\n  }\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n }\n function SetUpReadableStreamBYOBRequest(request, controller, view) {\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n }\n function byobRequestBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamBYOBRequest.prototype.\" + name + \" can only be used on a ReadableStreamBYOBRequest\");\n }\n function byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\"ReadableByteStreamController.prototype.\" + name + \" can only be used on a ReadableByteStreamController\");\n }\n function AcquireReadableStreamBYOBReader(stream) {\n  return new ReadableStreamBYOBReader(stream);\n }\n function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n  stream._reader._readIntoRequests.push(readIntoRequest);\n }\n function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  var reader = stream._reader;\n  var readIntoRequest = reader._readIntoRequests.shift();\n  if (done) {\n   readIntoRequest._closeSteps(chunk);\n  } else {\n   readIntoRequest._chunkSteps(chunk);\n  }\n }\n function ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n }\n function ReadableStreamHasBYOBReader(stream) {\n  var reader = stream._reader;\n  if (reader === undefined) {\n   return false;\n  }\n  if (!IsReadableStreamBYOBReader(reader)) {\n   return false;\n  }\n  return true;\n }\n var ReadableStreamBYOBReader = function () {\n  function ReadableStreamBYOBReader(stream) {\n   assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n   assertReadableStream(stream, 'First parameter');\n   if (IsReadableStreamLocked(stream)) {\n    throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n   }\n   if (!IsReadableByteStreamController(stream._readableStreamController)) {\n    throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');\n   }\n   ReadableStreamReaderGenericInitialize(this, stream);\n   this._readIntoRequests = new SimpleQueue();\n  }\n  Object.defineProperty(ReadableStreamBYOBReader.prototype, \"closed\", {\n   get: function () {\n    if (!IsReadableStreamBYOBReader(this)) {\n     return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n    }\n    return this._closedPromise;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  ReadableStreamBYOBReader.prototype.cancel = function (reason) {\n   if (reason === void 0) {\n    reason = undefined;\n   }\n   if (!IsReadableStreamBYOBReader(this)) {\n    return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n   }\n   if (this._ownerReadableStream === undefined) {\n    return promiseRejectedWith(readerLockException('cancel'));\n   }\n   return ReadableStreamReaderGenericCancel(this, reason);\n  };\n  ReadableStreamBYOBReader.prototype.read = function (view) {\n   if (!IsReadableStreamBYOBReader(this)) {\n    return promiseRejectedWith(byobReaderBrandCheckException('read'));\n   }\n   if (!ArrayBuffer.isView(view)) {\n    return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n   }\n   if (view.byteLength === 0) {\n    return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n   }\n   if (view.buffer.byteLength === 0) {\n    return promiseRejectedWith(new TypeError(\"view's buffer must have non-zero byteLength\"));\n   }\n   if (this._ownerReadableStream === undefined) {\n    return promiseRejectedWith(readerLockException('read from'));\n   }\n   var resolvePromise;\n   var rejectPromise;\n   var promise = newPromise(function (resolve, reject) {\n    resolvePromise = resolve;\n    rejectPromise = reject;\n   });\n   var readIntoRequest = {\n    _chunkSteps: function (chunk) {\n     return resolvePromise({\n      value: chunk,\n      done: false\n     });\n    },\n    _closeSteps: function (chunk) {\n     return resolvePromise({\n      value: chunk,\n      done: true\n     });\n    },\n    _errorSteps: function (e) {\n     return rejectPromise(e);\n    }\n   };\n   ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n   return promise;\n  };\n  ReadableStreamBYOBReader.prototype.releaseLock = function () {\n   if (!IsReadableStreamBYOBReader(this)) {\n    throw byobReaderBrandCheckException('releaseLock');\n   }\n   if (this._ownerReadableStream === undefined) {\n    return;\n   }\n   if (this._readIntoRequests.length > 0) {\n    throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n   }\n   ReadableStreamReaderGenericRelease(this);\n  };\n  return ReadableStreamBYOBReader;\n }();\n Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n   value: 'ReadableStreamBYOBReader',\n   configurable: true\n  });\n }\n function IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n   return false;\n  }\n  return true;\n }\n function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n  var stream = reader._ownerReadableStream;\n  stream._disturbed = true;\n  if (stream._state === 'errored') {\n   readIntoRequest._errorSteps(stream._storedError);\n  } else {\n   ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n  }\n }\n function byobReaderBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamBYOBReader.prototype.\" + name + \" can only be used on a ReadableStreamBYOBReader\");\n }\n function ExtractHighWaterMark(strategy, defaultHWM) {\n  var highWaterMark = strategy.highWaterMark;\n  if (highWaterMark === undefined) {\n   return defaultHWM;\n  }\n  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n   throw new RangeError('Invalid highWaterMark');\n  }\n  return highWaterMark;\n }\n function ExtractSizeAlgorithm(strategy) {\n  var size = strategy.size;\n  if (!size) {\n   return function () {\n    return 1;\n   };\n  }\n  return size;\n }\n function convertQueuingStrategy(init, context) {\n  assertDictionary(init, context);\n  var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n  var size = init === null || init === void 0 ? void 0 : init.size;\n  return {\n   highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n   size: size === undefined ? undefined : convertQueuingStrategySize(size, context + \" has member 'size' that\")\n  };\n }\n function convertQueuingStrategySize(fn, context) {\n  assertFunction(fn, context);\n  return function (chunk) {\n   return convertUnrestrictedDouble(fn(chunk));\n  };\n }\n function convertUnderlyingSink(original, context) {\n  assertDictionary(original, context);\n  var abort = original === null || original === void 0 ? void 0 : original.abort;\n  var close = original === null || original === void 0 ? void 0 : original.close;\n  var start = original === null || original === void 0 ? void 0 : original.start;\n  var type = original === null || original === void 0 ? void 0 : original.type;\n  var write = original === null || original === void 0 ? void 0 : original.write;\n  return {\n   abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, context + \" has member 'abort' that\"),\n   close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, context + \" has member 'close' that\"),\n   start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, context + \" has member 'start' that\"),\n   write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, context + \" has member 'write' that\"),\n   type: type\n  };\n }\n function convertUnderlyingSinkAbortCallback(fn, original, context) {\n  assertFunction(fn, context);\n  return function (reason) {\n   return promiseCall(fn, original, [reason]);\n  };\n }\n function convertUnderlyingSinkCloseCallback(fn, original, context) {\n  assertFunction(fn, context);\n  return function () {\n   return promiseCall(fn, original, []);\n  };\n }\n function convertUnderlyingSinkStartCallback(fn, original, context) {\n  assertFunction(fn, context);\n  return function (controller) {\n   return reflectCall(fn, original, [controller]);\n  };\n }\n function convertUnderlyingSinkWriteCallback(fn, original, context) {\n  assertFunction(fn, context);\n  return function (chunk, controller) {\n   return promiseCall(fn, original, [\n    chunk,\n    controller\n   ]);\n  };\n }\n function assertWritableStream(x, context) {\n  if (!IsWritableStream(x)) {\n   throw new TypeError(context + \" is not a WritableStream.\");\n  }\n }\n var WritableStream = function () {\n  function WritableStream(rawUnderlyingSink, rawStrategy) {\n   if (rawUnderlyingSink === void 0) {\n    rawUnderlyingSink = {};\n   }\n   if (rawStrategy === void 0) {\n    rawStrategy = {};\n   }\n   if (rawUnderlyingSink === undefined) {\n    rawUnderlyingSink = null;\n   } else {\n    assertObject(rawUnderlyingSink, 'First parameter');\n   }\n   var strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n   var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n   InitializeWritableStream(this);\n   var type = underlyingSink.type;\n   if (type !== undefined) {\n    throw new RangeError('Invalid type is specified');\n   }\n   var sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n   var highWaterMark = ExtractHighWaterMark(strategy, 1);\n   SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n  Object.defineProperty(WritableStream.prototype, \"locked\", {\n   get: function () {\n    if (!IsWritableStream(this)) {\n     throw streamBrandCheckException('locked');\n    }\n    return IsWritableStreamLocked(this);\n   },\n   enumerable: false,\n   configurable: true\n  });\n  WritableStream.prototype.abort = function (reason) {\n   if (reason === void 0) {\n    reason = undefined;\n   }\n   if (!IsWritableStream(this)) {\n    return promiseRejectedWith(streamBrandCheckException('abort'));\n   }\n   if (IsWritableStreamLocked(this)) {\n    return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n   }\n   return WritableStreamAbort(this, reason);\n  };\n  WritableStream.prototype.close = function () {\n   if (!IsWritableStream(this)) {\n    return promiseRejectedWith(streamBrandCheckException('close'));\n   }\n   if (IsWritableStreamLocked(this)) {\n    return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n   }\n   if (WritableStreamCloseQueuedOrInFlight(this)) {\n    return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n   }\n   return WritableStreamClose(this);\n  };\n  WritableStream.prototype.getWriter = function () {\n   if (!IsWritableStream(this)) {\n    throw streamBrandCheckException('getWriter');\n   }\n   return AcquireWritableStreamDefaultWriter(this);\n  };\n  return WritableStream;\n }();\n Object.defineProperties(WritableStream.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  getWriter: { enumerable: true },\n  locked: { enumerable: true }\n });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n   value: 'WritableStream',\n   configurable: true\n  });\n }\n function AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n }\n function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  if (highWaterMark === void 0) {\n   highWaterMark = 1;\n  }\n  if (sizeAlgorithm === void 0) {\n   sizeAlgorithm = function () {\n    return 1;\n   };\n  }\n  var stream = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n  var controller = Object.create(WritableStreamDefaultController.prototype);\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n }\n function InitializeWritableStream(stream) {\n  stream._state = 'writable';\n  stream._storedError = undefined;\n  stream._writer = undefined;\n  stream._writableStreamController = undefined;\n  stream._writeRequests = new SimpleQueue();\n  stream._inFlightWriteRequest = undefined;\n  stream._closeRequest = undefined;\n  stream._inFlightCloseRequest = undefined;\n  stream._pendingAbortRequest = undefined;\n  stream._backpressure = false;\n }\n function IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n   return false;\n  }\n  return true;\n }\n function IsWritableStreamLocked(stream) {\n  if (stream._writer === undefined) {\n   return false;\n  }\n  return true;\n }\n function WritableStreamAbort(stream, reason) {\n  var state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n   return promiseResolvedWith(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n   return stream._pendingAbortRequest._promise;\n  }\n  var wasAlreadyErroring = false;\n  if (state === 'erroring') {\n   wasAlreadyErroring = true;\n   reason = undefined;\n  }\n  var promise = newPromise(function (resolve, reject) {\n   stream._pendingAbortRequest = {\n    _promise: undefined,\n    _resolve: resolve,\n    _reject: reject,\n    _reason: reason,\n    _wasAlreadyErroring: wasAlreadyErroring\n   };\n  });\n  stream._pendingAbortRequest._promise = promise;\n  if (!wasAlreadyErroring) {\n   WritableStreamStartErroring(stream, reason);\n  }\n  return promise;\n }\n function WritableStreamClose(stream) {\n  var state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n   return promiseRejectedWith(new TypeError(\"The stream (in \" + state + \" state) is not in the writable state and cannot be closed\"));\n  }\n  var promise = newPromise(function (resolve, reject) {\n   var closeRequest = {\n    _resolve: resolve,\n    _reject: reject\n   };\n   stream._closeRequest = closeRequest;\n  });\n  var writer = stream._writer;\n  if (writer !== undefined && stream._backpressure && state === 'writable') {\n   defaultWriterReadyPromiseResolve(writer);\n  }\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n  return promise;\n }\n function WritableStreamAddWriteRequest(stream) {\n  var promise = newPromise(function (resolve, reject) {\n   var writeRequest = {\n    _resolve: resolve,\n    _reject: reject\n   };\n   stream._writeRequests.push(writeRequest);\n  });\n  return promise;\n }\n function WritableStreamDealWithRejection(stream, error) {\n  var state = stream._state;\n  if (state === 'writable') {\n   WritableStreamStartErroring(stream, error);\n   return;\n  }\n  WritableStreamFinishErroring(stream);\n }\n function WritableStreamStartErroring(stream, reason) {\n  var controller = stream._writableStreamController;\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  var writer = stream._writer;\n  if (writer !== undefined) {\n   WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n  if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n   WritableStreamFinishErroring(stream);\n  }\n }\n function WritableStreamFinishErroring(stream) {\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n  var storedError = stream._storedError;\n  stream._writeRequests.forEach(function (writeRequest) {\n   writeRequest._reject(storedError);\n  });\n  stream._writeRequests = new SimpleQueue();\n  if (stream._pendingAbortRequest === undefined) {\n   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n   return;\n  }\n  var abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n  if (abortRequest._wasAlreadyErroring) {\n   abortRequest._reject(storedError);\n   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n   return;\n  }\n  var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  uponPromise(promise, function () {\n   abortRequest._resolve();\n   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n  }, function (reason) {\n   abortRequest._reject(reason);\n   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n  });\n }\n function WritableStreamFinishInFlightWrite(stream) {\n  stream._inFlightWriteRequest._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n }\n function WritableStreamFinishInFlightWriteWithError(stream, error) {\n  stream._inFlightWriteRequest._reject(error);\n  stream._inFlightWriteRequest = undefined;\n  WritableStreamDealWithRejection(stream, error);\n }\n function WritableStreamFinishInFlightClose(stream) {\n  stream._inFlightCloseRequest._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n  var state = stream._state;\n  if (state === 'erroring') {\n   stream._storedError = undefined;\n   if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._resolve();\n    stream._pendingAbortRequest = undefined;\n   }\n  }\n  stream._state = 'closed';\n  var writer = stream._writer;\n  if (writer !== undefined) {\n   defaultWriterClosedPromiseResolve(writer);\n  }\n }\n function WritableStreamFinishInFlightCloseWithError(stream, error) {\n  stream._inFlightCloseRequest._reject(error);\n  stream._inFlightCloseRequest = undefined;\n  if (stream._pendingAbortRequest !== undefined) {\n   stream._pendingAbortRequest._reject(error);\n   stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n }\n function WritableStreamCloseQueuedOrInFlight(stream) {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n   return false;\n  }\n  return true;\n }\n function WritableStreamHasOperationMarkedInFlight(stream) {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n   return false;\n  }\n  return true;\n }\n function WritableStreamMarkCloseRequestInFlight(stream) {\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n }\n function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n }\n function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  if (stream._closeRequest !== undefined) {\n   stream._closeRequest._reject(stream._storedError);\n   stream._closeRequest = undefined;\n  }\n  var writer = stream._writer;\n  if (writer !== undefined) {\n   defaultWriterClosedPromiseReject(writer, stream._storedError);\n  }\n }\n function WritableStreamUpdateBackpressure(stream, backpressure) {\n  var writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n   if (backpressure) {\n    defaultWriterReadyPromiseReset(writer);\n   } else {\n    defaultWriterReadyPromiseResolve(writer);\n   }\n  }\n  stream._backpressure = backpressure;\n }\n var WritableStreamDefaultWriter = function () {\n  function WritableStreamDefaultWriter(stream) {\n   assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n   assertWritableStream(stream, 'First parameter');\n   if (IsWritableStreamLocked(stream)) {\n    throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n   }\n   this._ownerWritableStream = stream;\n   stream._writer = this;\n   var state = stream._state;\n   if (state === 'writable') {\n    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n     defaultWriterReadyPromiseInitialize(this);\n    } else {\n     defaultWriterReadyPromiseInitializeAsResolved(this);\n    }\n    defaultWriterClosedPromiseInitialize(this);\n   } else if (state === 'erroring') {\n    defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n    defaultWriterClosedPromiseInitialize(this);\n   } else if (state === 'closed') {\n    defaultWriterReadyPromiseInitializeAsResolved(this);\n    defaultWriterClosedPromiseInitializeAsResolved(this);\n   } else {\n    var storedError = stream._storedError;\n    defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n    defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n   }\n  }\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, \"closed\", {\n   get: function () {\n    if (!IsWritableStreamDefaultWriter(this)) {\n     return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n    }\n    return this._closedPromise;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, \"desiredSize\", {\n   get: function () {\n    if (!IsWritableStreamDefaultWriter(this)) {\n     throw defaultWriterBrandCheckException('desiredSize');\n    }\n    if (this._ownerWritableStream === undefined) {\n     throw defaultWriterLockException('desiredSize');\n    }\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n   },\n   enumerable: false,\n   configurable: true\n  });\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, \"ready\", {\n   get: function () {\n    if (!IsWritableStreamDefaultWriter(this)) {\n     return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n    }\n    return this._readyPromise;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  WritableStreamDefaultWriter.prototype.abort = function (reason) {\n   if (reason === void 0) {\n    reason = undefined;\n   }\n   if (!IsWritableStreamDefaultWriter(this)) {\n    return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n   }\n   if (this._ownerWritableStream === undefined) {\n    return promiseRejectedWith(defaultWriterLockException('abort'));\n   }\n   return WritableStreamDefaultWriterAbort(this, reason);\n  };\n  WritableStreamDefaultWriter.prototype.close = function () {\n   if (!IsWritableStreamDefaultWriter(this)) {\n    return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n   }\n   var stream = this._ownerWritableStream;\n   if (stream === undefined) {\n    return promiseRejectedWith(defaultWriterLockException('close'));\n   }\n   if (WritableStreamCloseQueuedOrInFlight(stream)) {\n    return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n   }\n   return WritableStreamDefaultWriterClose(this);\n  };\n  WritableStreamDefaultWriter.prototype.releaseLock = function () {\n   if (!IsWritableStreamDefaultWriter(this)) {\n    throw defaultWriterBrandCheckException('releaseLock');\n   }\n   var stream = this._ownerWritableStream;\n   if (stream === undefined) {\n    return;\n   }\n   WritableStreamDefaultWriterRelease(this);\n  };\n  WritableStreamDefaultWriter.prototype.write = function (chunk) {\n   if (chunk === void 0) {\n    chunk = undefined;\n   }\n   if (!IsWritableStreamDefaultWriter(this)) {\n    return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n   }\n   if (this._ownerWritableStream === undefined) {\n    return promiseRejectedWith(defaultWriterLockException('write to'));\n   }\n   return WritableStreamDefaultWriterWrite(this, chunk);\n  };\n  return WritableStreamDefaultWriter;\n }();\n Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  releaseLock: { enumerable: true },\n  write: { enumerable: true },\n  closed: { enumerable: true },\n  desiredSize: { enumerable: true },\n  ready: { enumerable: true }\n });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n   value: 'WritableStreamDefaultWriter',\n   configurable: true\n  });\n }\n function IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n   return false;\n  }\n  return true;\n }\n function WritableStreamDefaultWriterAbort(writer, reason) {\n  var stream = writer._ownerWritableStream;\n  return WritableStreamAbort(stream, reason);\n }\n function WritableStreamDefaultWriterClose(writer) {\n  var stream = writer._ownerWritableStream;\n  return WritableStreamClose(stream);\n }\n function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  var stream = writer._ownerWritableStream;\n  var state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n   return promiseResolvedWith(undefined);\n  }\n  if (state === 'errored') {\n   return promiseRejectedWith(stream._storedError);\n  }\n  return WritableStreamDefaultWriterClose(writer);\n }\n function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (writer._closedPromiseState === 'pending') {\n   defaultWriterClosedPromiseReject(writer, error);\n  } else {\n   defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n }\n function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  if (writer._readyPromiseState === 'pending') {\n   defaultWriterReadyPromiseReject(writer, error);\n  } else {\n   defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n }\n function WritableStreamDefaultWriterGetDesiredSize(writer) {\n  var stream = writer._ownerWritableStream;\n  var state = stream._state;\n  if (state === 'errored' || state === 'erroring') {\n   return null;\n  }\n  if (state === 'closed') {\n   return 0;\n  }\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n }\n function WritableStreamDefaultWriterRelease(writer) {\n  var stream = writer._ownerWritableStream;\n  var releasedError = new TypeError(\"Writer was released and can no longer be used to monitor the stream's closedness\");\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n }\n function WritableStreamDefaultWriterWrite(writer, chunk) {\n  var stream = writer._ownerWritableStream;\n  var controller = stream._writableStreamController;\n  var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n  if (stream !== writer._ownerWritableStream) {\n   return promiseRejectedWith(defaultWriterLockException('write to'));\n  }\n  var state = stream._state;\n  if (state === 'errored') {\n   return promiseRejectedWith(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n   return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n   return promiseRejectedWith(stream._storedError);\n  }\n  var promise = WritableStreamAddWriteRequest(stream);\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n  return promise;\n }\n var closeSentinel = {};\n var WritableStreamDefaultController = function () {\n  function WritableStreamDefaultController() {\n   throw new TypeError('Illegal constructor');\n  }\n  WritableStreamDefaultController.prototype.error = function (e) {\n   if (e === void 0) {\n    e = undefined;\n   }\n   if (!IsWritableStreamDefaultController(this)) {\n    throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n   }\n   var state = this._controlledWritableStream._state;\n   if (state !== 'writable') {\n    return;\n   }\n   WritableStreamDefaultControllerError(this, e);\n  };\n  WritableStreamDefaultController.prototype[AbortSteps] = function (reason) {\n   var result = this._abortAlgorithm(reason);\n   WritableStreamDefaultControllerClearAlgorithms(this);\n   return result;\n  };\n  WritableStreamDefaultController.prototype[ErrorSteps] = function () {\n   ResetQueue(this);\n  };\n  return WritableStreamDefaultController;\n }();\n Object.defineProperties(WritableStreamDefaultController.prototype, { error: { enumerable: true } });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n   value: 'WritableStreamDefaultController',\n   configurable: true\n  });\n }\n function IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n   return false;\n  }\n  return true;\n }\n function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n  controller._started = false;\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n  var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n  var startResult = startAlgorithm();\n  var startPromise = promiseResolvedWith(startResult);\n  uponPromise(startPromise, function () {\n   controller._started = true;\n   WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n  }, function (r) {\n   controller._started = true;\n   WritableStreamDealWithRejection(stream, r);\n  });\n }\n function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n  var controller = Object.create(WritableStreamDefaultController.prototype);\n  var startAlgorithm = function () {\n   return undefined;\n  };\n  var writeAlgorithm = function () {\n   return promiseResolvedWith(undefined);\n  };\n  var closeAlgorithm = function () {\n   return promiseResolvedWith(undefined);\n  };\n  var abortAlgorithm = function () {\n   return promiseResolvedWith(undefined);\n  };\n  if (underlyingSink.start !== undefined) {\n   startAlgorithm = function () {\n    return underlyingSink.start(controller);\n   };\n  }\n  if (underlyingSink.write !== undefined) {\n   writeAlgorithm = function (chunk) {\n    return underlyingSink.write(chunk, controller);\n   };\n  }\n  if (underlyingSink.close !== undefined) {\n   closeAlgorithm = function () {\n    return underlyingSink.close();\n   };\n  }\n  if (underlyingSink.abort !== undefined) {\n   abortAlgorithm = function (reason) {\n    return underlyingSink.abort(reason);\n   };\n  }\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n }\n function WritableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._writeAlgorithm = undefined;\n  controller._closeAlgorithm = undefined;\n  controller._abortAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n }\n function WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize(controller, closeSentinel, 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n }\n function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n   return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n   WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n   return 1;\n  }\n }\n function WritableStreamDefaultControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._queueTotalSize;\n }\n function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  try {\n   EnqueueValueWithSize(controller, chunk, chunkSize);\n  } catch (enqueueE) {\n   WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n   return;\n  }\n  var stream = controller._controlledWritableStream;\n  if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n   var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n   WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n }\n function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  var stream = controller._controlledWritableStream;\n  if (!controller._started) {\n   return;\n  }\n  if (stream._inFlightWriteRequest !== undefined) {\n   return;\n  }\n  var state = stream._state;\n  if (state === 'erroring') {\n   WritableStreamFinishErroring(stream);\n   return;\n  }\n  if (controller._queue.length === 0) {\n   return;\n  }\n  var value = PeekQueueValue(controller);\n  if (value === closeSentinel) {\n   WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n   WritableStreamDefaultControllerProcessWrite(controller, value);\n  }\n }\n function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  if (controller._controlledWritableStream._state === 'writable') {\n   WritableStreamDefaultControllerError(controller, error);\n  }\n }\n function WritableStreamDefaultControllerProcessClose(controller) {\n  var stream = controller._controlledWritableStream;\n  WritableStreamMarkCloseRequestInFlight(stream);\n  DequeueValue(controller);\n  var sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  uponPromise(sinkClosePromise, function () {\n   WritableStreamFinishInFlightClose(stream);\n  }, function (reason) {\n   WritableStreamFinishInFlightCloseWithError(stream, reason);\n  });\n }\n function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  var stream = controller._controlledWritableStream;\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n  var sinkWritePromise = controller._writeAlgorithm(chunk);\n  uponPromise(sinkWritePromise, function () {\n   WritableStreamFinishInFlightWrite(stream);\n   var state = stream._state;\n   DequeueValue(controller);\n   if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n   }\n   WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n  }, function (reason) {\n   if (stream._state === 'writable') {\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n   }\n   WritableStreamFinishInFlightWriteWithError(stream, reason);\n  });\n }\n function WritableStreamDefaultControllerGetBackpressure(controller) {\n  var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n }\n function WritableStreamDefaultControllerError(controller, error) {\n  var stream = controller._controlledWritableStream;\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n }\n function streamBrandCheckException(name) {\n  return new TypeError(\"WritableStream.prototype.\" + name + \" can only be used on a WritableStream\");\n }\n function defaultWriterBrandCheckException(name) {\n  return new TypeError(\"WritableStreamDefaultWriter.prototype.\" + name + \" can only be used on a WritableStreamDefaultWriter\");\n }\n function defaultWriterLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n }\n function defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = newPromise(function (resolve, reject) {\n   writer._closedPromise_resolve = resolve;\n   writer._closedPromise_reject = reject;\n   writer._closedPromiseState = 'pending';\n  });\n }\n function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseReject(writer, reason);\n }\n function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseResolve(writer);\n }\n function defaultWriterClosedPromiseReject(writer, reason) {\n  if (writer._closedPromise_reject === undefined) {\n   return;\n  }\n  setPromiseIsHandledToTrue(writer._closedPromise);\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n }\n function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n }\n function defaultWriterClosedPromiseResolve(writer) {\n  if (writer._closedPromise_resolve === undefined) {\n   return;\n  }\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n }\n function defaultWriterReadyPromiseInitialize(writer) {\n  writer._readyPromise = newPromise(function (resolve, reject) {\n   writer._readyPromise_resolve = resolve;\n   writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n }\n function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseReject(writer, reason);\n }\n function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseResolve(writer);\n }\n function defaultWriterReadyPromiseReject(writer, reason) {\n  if (writer._readyPromise_reject === undefined) {\n   return;\n  }\n  setPromiseIsHandledToTrue(writer._readyPromise);\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n }\n function defaultWriterReadyPromiseReset(writer) {\n  defaultWriterReadyPromiseInitialize(writer);\n }\n function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n }\n function defaultWriterReadyPromiseResolve(writer) {\n  if (writer._readyPromise_resolve === undefined) {\n   return;\n  }\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n }\n function isAbortSignal(value) {\n  if (typeof value !== 'object' || value === null) {\n   return false;\n  }\n  try {\n   return typeof value.aborted === 'boolean';\n  } catch (_a) {\n   return false;\n  }\n }\n var NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;\n function isDOMExceptionConstructor(ctor) {\n  if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n   return false;\n  }\n  try {\n   new ctor();\n   return true;\n  } catch (_a) {\n   return false;\n  }\n }\n function createDOMExceptionPolyfill() {\n  var ctor = function DOMException(message, name) {\n   this.message = message || '';\n   this.name = name || 'Error';\n   if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n   }\n  };\n  ctor.prototype = Object.create(Error.prototype);\n  Object.defineProperty(ctor.prototype, 'constructor', {\n   value: ctor,\n   writable: true,\n   configurable: true\n  });\n  return ctor;\n }\n var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n  var reader = AcquireReadableStreamDefaultReader(source);\n  var writer = AcquireWritableStreamDefaultWriter(dest);\n  source._disturbed = true;\n  var shuttingDown = false;\n  var currentWrite = promiseResolvedWith(undefined);\n  return newPromise(function (resolve, reject) {\n   var abortAlgorithm;\n   if (signal !== undefined) {\n    abortAlgorithm = function () {\n     var error = new DOMException$1('Aborted', 'AbortError');\n     var actions = [];\n     if (!preventAbort) {\n      actions.push(function () {\n       if (dest._state === 'writable') {\n        return WritableStreamAbort(dest, error);\n       }\n       return promiseResolvedWith(undefined);\n      });\n     }\n     if (!preventCancel) {\n      actions.push(function () {\n       if (source._state === 'readable') {\n        return ReadableStreamCancel(source, error);\n       }\n       return promiseResolvedWith(undefined);\n      });\n     }\n     shutdownWithAction(function () {\n      return Promise.all(actions.map(function (action) {\n       return action();\n      }));\n     }, true, error);\n    };\n    if (signal.aborted) {\n     abortAlgorithm();\n     return;\n    }\n    signal.addEventListener('abort', abortAlgorithm);\n   }\n   function pipeLoop() {\n    return newPromise(function (resolveLoop, rejectLoop) {\n     function next(done) {\n      if (done) {\n       resolveLoop();\n      } else {\n       PerformPromiseThen(pipeStep(), next, rejectLoop);\n      }\n     }\n     next(false);\n    });\n   }\n   function pipeStep() {\n    if (shuttingDown) {\n     return promiseResolvedWith(true);\n    }\n    return PerformPromiseThen(writer._readyPromise, function () {\n     return newPromise(function (resolveRead, rejectRead) {\n      ReadableStreamDefaultReaderRead(reader, {\n       _chunkSteps: function (chunk) {\n        currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n        resolveRead(false);\n       },\n       _closeSteps: function () {\n        return resolveRead(true);\n       },\n       _errorSteps: rejectRead\n      });\n     });\n    });\n   }\n   isOrBecomesErrored(source, reader._closedPromise, function (storedError) {\n    if (!preventAbort) {\n     shutdownWithAction(function () {\n      return WritableStreamAbort(dest, storedError);\n     }, true, storedError);\n    } else {\n     shutdown(true, storedError);\n    }\n   });\n   isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {\n    if (!preventCancel) {\n     shutdownWithAction(function () {\n      return ReadableStreamCancel(source, storedError);\n     }, true, storedError);\n    } else {\n     shutdown(true, storedError);\n    }\n   });\n   isOrBecomesClosed(source, reader._closedPromise, function () {\n    if (!preventClose) {\n     shutdownWithAction(function () {\n      return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);\n     });\n    } else {\n     shutdown();\n    }\n   });\n   if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n    var destClosed_1 = new TypeError('the destination writable stream closed before all data could be piped to it');\n    if (!preventCancel) {\n     shutdownWithAction(function () {\n      return ReadableStreamCancel(source, destClosed_1);\n     }, true, destClosed_1);\n    } else {\n     shutdown(true, destClosed_1);\n    }\n   }\n   setPromiseIsHandledToTrue(pipeLoop());\n   function waitForWritesToFinish() {\n    var oldCurrentWrite = currentWrite;\n    return PerformPromiseThen(currentWrite, function () {\n     return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;\n    });\n   }\n   function isOrBecomesErrored(stream, promise, action) {\n    if (stream._state === 'errored') {\n     action(stream._storedError);\n    } else {\n     uponRejection(promise, action);\n    }\n   }\n   function isOrBecomesClosed(stream, promise, action) {\n    if (stream._state === 'closed') {\n     action();\n    } else {\n     uponFulfillment(promise, action);\n    }\n   }\n   function shutdownWithAction(action, originalIsError, originalError) {\n    if (shuttingDown) {\n     return;\n    }\n    shuttingDown = true;\n    if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n     uponFulfillment(waitForWritesToFinish(), doTheRest);\n    } else {\n     doTheRest();\n    }\n    function doTheRest() {\n     uponPromise(action(), function () {\n      return finalize(originalIsError, originalError);\n     }, function (newError) {\n      return finalize(true, newError);\n     });\n    }\n   }\n   function shutdown(isError, error) {\n    if (shuttingDown) {\n     return;\n    }\n    shuttingDown = true;\n    if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n     uponFulfillment(waitForWritesToFinish(), function () {\n      return finalize(isError, error);\n     });\n    } else {\n     finalize(isError, error);\n    }\n   }\n   function finalize(isError, error) {\n    WritableStreamDefaultWriterRelease(writer);\n    ReadableStreamReaderGenericRelease(reader);\n    if (signal !== undefined) {\n     signal.removeEventListener('abort', abortAlgorithm);\n    }\n    if (isError) {\n     reject(error);\n    } else {\n     resolve(undefined);\n    }\n   }\n  });\n }\n var ReadableStreamDefaultController = function () {\n  function ReadableStreamDefaultController() {\n   throw new TypeError('Illegal constructor');\n  }\n  Object.defineProperty(ReadableStreamDefaultController.prototype, \"desiredSize\", {\n   get: function () {\n    if (!IsReadableStreamDefaultController(this)) {\n     throw defaultControllerBrandCheckException('desiredSize');\n    }\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n   },\n   enumerable: false,\n   configurable: true\n  });\n  ReadableStreamDefaultController.prototype.close = function () {\n   if (!IsReadableStreamDefaultController(this)) {\n    throw defaultControllerBrandCheckException('close');\n   }\n   if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n    throw new TypeError('The stream is not in a state that permits close');\n   }\n   ReadableStreamDefaultControllerClose(this);\n  };\n  ReadableStreamDefaultController.prototype.enqueue = function (chunk) {\n   if (chunk === void 0) {\n    chunk = undefined;\n   }\n   if (!IsReadableStreamDefaultController(this)) {\n    throw defaultControllerBrandCheckException('enqueue');\n   }\n   if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n    throw new TypeError('The stream is not in a state that permits enqueue');\n   }\n   return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  };\n  ReadableStreamDefaultController.prototype.error = function (e) {\n   if (e === void 0) {\n    e = undefined;\n   }\n   if (!IsReadableStreamDefaultController(this)) {\n    throw defaultControllerBrandCheckException('error');\n   }\n   ReadableStreamDefaultControllerError(this, e);\n  };\n  ReadableStreamDefaultController.prototype[CancelSteps] = function (reason) {\n   ResetQueue(this);\n   var result = this._cancelAlgorithm(reason);\n   ReadableStreamDefaultControllerClearAlgorithms(this);\n   return result;\n  };\n  ReadableStreamDefaultController.prototype[PullSteps] = function (readRequest) {\n   var stream = this._controlledReadableStream;\n   if (this._queue.length > 0) {\n    var chunk = DequeueValue(this);\n    if (this._closeRequested && this._queue.length === 0) {\n     ReadableStreamDefaultControllerClearAlgorithms(this);\n     ReadableStreamClose(stream);\n    } else {\n     ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    }\n    readRequest._chunkSteps(chunk);\n   } else {\n    ReadableStreamAddReadRequest(stream, readRequest);\n    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n   }\n  };\n  return ReadableStreamDefaultController;\n }();\n Object.defineProperties(ReadableStreamDefaultController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  desiredSize: { enumerable: true }\n });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n   value: 'ReadableStreamDefaultController',\n   configurable: true\n  });\n }\n function IsReadableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n   return false;\n  }\n  return true;\n }\n function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (!shouldPull) {\n   return;\n  }\n  if (controller._pulling) {\n   controller._pullAgain = true;\n   return;\n  }\n  controller._pulling = true;\n  var pullPromise = controller._pullAlgorithm();\n  uponPromise(pullPromise, function () {\n   controller._pulling = false;\n   if (controller._pullAgain) {\n    controller._pullAgain = false;\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n   }\n  }, function (e) {\n   ReadableStreamDefaultControllerError(controller, e);\n  });\n }\n function ReadableStreamDefaultControllerShouldCallPull(controller) {\n  var stream = controller._controlledReadableStream;\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n   return false;\n  }\n  if (!controller._started) {\n   return false;\n  }\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n   return true;\n  }\n  var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  if (desiredSize > 0) {\n   return true;\n  }\n  return false;\n }\n function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n }\n function ReadableStreamDefaultControllerClose(controller) {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n   return;\n  }\n  var stream = controller._controlledReadableStream;\n  controller._closeRequested = true;\n  if (controller._queue.length === 0) {\n   ReadableStreamDefaultControllerClearAlgorithms(controller);\n   ReadableStreamClose(stream);\n  }\n }\n function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n   return;\n  }\n  var stream = controller._controlledReadableStream;\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n   ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n   var chunkSize = void 0;\n   try {\n    chunkSize = controller._strategySizeAlgorithm(chunk);\n   } catch (chunkSizeE) {\n    ReadableStreamDefaultControllerError(controller, chunkSizeE);\n    throw chunkSizeE;\n   }\n   try {\n    EnqueueValueWithSize(controller, chunk, chunkSize);\n   } catch (enqueueE) {\n    ReadableStreamDefaultControllerError(controller, enqueueE);\n    throw enqueueE;\n   }\n  }\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n }\n function ReadableStreamDefaultControllerError(controller, e) {\n  var stream = controller._controlledReadableStream;\n  if (stream._state !== 'readable') {\n   return;\n  }\n  ResetQueue(controller);\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n }\n function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  var state = controller._controlledReadableStream._state;\n  if (state === 'errored') {\n   return null;\n  }\n  if (state === 'closed') {\n   return 0;\n  }\n  return controller._strategyHWM - controller._queueTotalSize;\n }\n function ReadableStreamDefaultControllerHasBackpressure(controller) {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n   return false;\n  }\n  return true;\n }\n function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  var state = controller._controlledReadableStream._state;\n  if (!controller._closeRequested && state === 'readable') {\n   return true;\n  }\n  return false;\n }\n function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  controller._controlledReadableStream = stream;\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n  stream._readableStreamController = controller;\n  var startResult = startAlgorithm();\n  uponPromise(promiseResolvedWith(startResult), function () {\n   controller._started = true;\n   ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n  }, function (r) {\n   ReadableStreamDefaultControllerError(controller, r);\n  });\n }\n function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n  var controller = Object.create(ReadableStreamDefaultController.prototype);\n  var startAlgorithm = function () {\n   return undefined;\n  };\n  var pullAlgorithm = function () {\n   return promiseResolvedWith(undefined);\n  };\n  var cancelAlgorithm = function () {\n   return promiseResolvedWith(undefined);\n  };\n  if (underlyingSource.start !== undefined) {\n   startAlgorithm = function () {\n    return underlyingSource.start(controller);\n   };\n  }\n  if (underlyingSource.pull !== undefined) {\n   pullAlgorithm = function () {\n    return underlyingSource.pull(controller);\n   };\n  }\n  if (underlyingSource.cancel !== undefined) {\n   cancelAlgorithm = function (reason) {\n    return underlyingSource.cancel(reason);\n   };\n  }\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n }\n function defaultControllerBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamDefaultController.prototype.\" + name + \" can only be used on a ReadableStreamDefaultController\");\n }\n function ReadableStreamTee(stream, cloneForBranch2) {\n  var reader = AcquireReadableStreamDefaultReader(stream);\n  var reading = false;\n  var canceled1 = false;\n  var canceled2 = false;\n  var reason1;\n  var reason2;\n  var branch1;\n  var branch2;\n  var resolveCancelPromise;\n  var cancelPromise = newPromise(function (resolve) {\n   resolveCancelPromise = resolve;\n  });\n  function pullAlgorithm() {\n   if (reading) {\n    return promiseResolvedWith(undefined);\n   }\n   reading = true;\n   var readRequest = {\n    _chunkSteps: function (value) {\n     queueMicrotask(function () {\n      reading = false;\n      var value1 = value;\n      var value2 = value;\n      if (!canceled1) {\n       ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n      }\n      if (!canceled2) {\n       ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n      }\n      resolveCancelPromise(undefined);\n     });\n    },\n    _closeSteps: function () {\n     reading = false;\n     if (!canceled1) {\n      ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n     }\n     if (!canceled2) {\n      ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n     }\n    },\n    _errorSteps: function () {\n     reading = false;\n    }\n   };\n   ReadableStreamDefaultReaderRead(reader, readRequest);\n   return promiseResolvedWith(undefined);\n  }\n  function cancel1Algorithm(reason) {\n   canceled1 = true;\n   reason1 = reason;\n   if (canceled2) {\n    var compositeReason = CreateArrayFromList([\n     reason1,\n     reason2\n    ]);\n    var cancelResult = ReadableStreamCancel(stream, compositeReason);\n    resolveCancelPromise(cancelResult);\n   }\n   return cancelPromise;\n  }\n  function cancel2Algorithm(reason) {\n   canceled2 = true;\n   reason2 = reason;\n   if (canceled1) {\n    var compositeReason = CreateArrayFromList([\n     reason1,\n     reason2\n    ]);\n    var cancelResult = ReadableStreamCancel(stream, compositeReason);\n    resolveCancelPromise(cancelResult);\n   }\n   return cancelPromise;\n  }\n  function startAlgorithm() {\n  }\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n  uponRejection(reader._closedPromise, function (r) {\n   ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n   ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n   resolveCancelPromise(undefined);\n  });\n  return [\n   branch1,\n   branch2\n  ];\n }\n function convertUnderlyingDefaultOrByteSource(source, context) {\n  assertDictionary(source, context);\n  var original = source;\n  var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n  var cancel = original === null || original === void 0 ? void 0 : original.cancel;\n  var pull = original === null || original === void 0 ? void 0 : original.pull;\n  var start = original === null || original === void 0 ? void 0 : original.start;\n  var type = original === null || original === void 0 ? void 0 : original.type;\n  return {\n   autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + \" has member 'autoAllocateChunkSize' that\"),\n   cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, context + \" has member 'cancel' that\"),\n   pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, context + \" has member 'pull' that\"),\n   start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, context + \" has member 'start' that\"),\n   type: type === undefined ? undefined : convertReadableStreamType(type, context + \" has member 'type' that\")\n  };\n }\n function convertUnderlyingSourceCancelCallback(fn, original, context) {\n  assertFunction(fn, context);\n  return function (reason) {\n   return promiseCall(fn, original, [reason]);\n  };\n }\n function convertUnderlyingSourcePullCallback(fn, original, context) {\n  assertFunction(fn, context);\n  return function (controller) {\n   return promiseCall(fn, original, [controller]);\n  };\n }\n function convertUnderlyingSourceStartCallback(fn, original, context) {\n  assertFunction(fn, context);\n  return function (controller) {\n   return reflectCall(fn, original, [controller]);\n  };\n }\n function convertReadableStreamType(type, context) {\n  type = \"\" + type;\n  if (type !== 'bytes') {\n   throw new TypeError(context + \" '\" + type + \"' is not a valid enumeration value for ReadableStreamType\");\n  }\n  return type;\n }\n function convertReaderOptions(options, context) {\n  assertDictionary(options, context);\n  var mode = options === null || options === void 0 ? void 0 : options.mode;\n  return { mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, context + \" has member 'mode' that\") };\n }\n function convertReadableStreamReaderMode(mode, context) {\n  mode = \"\" + mode;\n  if (mode !== 'byob') {\n   throw new TypeError(context + \" '\" + mode + \"' is not a valid enumeration value for ReadableStreamReaderMode\");\n  }\n  return mode;\n }\n function convertIteratorOptions(options, context) {\n  assertDictionary(options, context);\n  var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n  return { preventCancel: Boolean(preventCancel) };\n }\n function convertPipeOptions(options, context) {\n  assertDictionary(options, context);\n  var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n  var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n  var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n  var signal = options === null || options === void 0 ? void 0 : options.signal;\n  if (signal !== undefined) {\n   assertAbortSignal(signal, context + \" has member 'signal' that\");\n  }\n  return {\n   preventAbort: Boolean(preventAbort),\n   preventCancel: Boolean(preventCancel),\n   preventClose: Boolean(preventClose),\n   signal: signal\n  };\n }\n function assertAbortSignal(signal, context) {\n  if (!isAbortSignal(signal)) {\n   throw new TypeError(context + \" is not an AbortSignal.\");\n  }\n }\n function convertReadableWritablePair(pair, context) {\n  assertDictionary(pair, context);\n  var readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n  assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n  assertReadableStream(readable, context + \" has member 'readable' that\");\n  var writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n  assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n  assertWritableStream(writable, context + \" has member 'writable' that\");\n  return {\n   readable: readable,\n   writable: writable\n  };\n }\n var ReadableStream = function () {\n  function ReadableStream(rawUnderlyingSource, rawStrategy) {\n   if (rawUnderlyingSource === void 0) {\n    rawUnderlyingSource = {};\n   }\n   if (rawStrategy === void 0) {\n    rawStrategy = {};\n   }\n   if (rawUnderlyingSource === undefined) {\n    rawUnderlyingSource = null;\n   } else {\n    assertObject(rawUnderlyingSource, 'First parameter');\n   }\n   var strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n   var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n   InitializeReadableStream(this);\n   if (underlyingSource.type === 'bytes') {\n    if (strategy.size !== undefined) {\n     throw new RangeError('The strategy for a byte stream cannot have a size function');\n    }\n    var highWaterMark = ExtractHighWaterMark(strategy, 0);\n    SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n   } else {\n    var sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n    var highWaterMark = ExtractHighWaterMark(strategy, 1);\n    SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n   }\n  }\n  Object.defineProperty(ReadableStream.prototype, \"locked\", {\n   get: function () {\n    if (!IsReadableStream(this)) {\n     throw streamBrandCheckException$1('locked');\n    }\n    return IsReadableStreamLocked(this);\n   },\n   enumerable: false,\n   configurable: true\n  });\n  ReadableStream.prototype.cancel = function (reason) {\n   if (reason === void 0) {\n    reason = undefined;\n   }\n   if (!IsReadableStream(this)) {\n    return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n   }\n   if (IsReadableStreamLocked(this)) {\n    return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n   }\n   return ReadableStreamCancel(this, reason);\n  };\n  ReadableStream.prototype.getReader = function (rawOptions) {\n   if (rawOptions === void 0) {\n    rawOptions = undefined;\n   }\n   if (!IsReadableStream(this)) {\n    throw streamBrandCheckException$1('getReader');\n   }\n   var options = convertReaderOptions(rawOptions, 'First parameter');\n   if (options.mode === undefined) {\n    return AcquireReadableStreamDefaultReader(this);\n   }\n   return AcquireReadableStreamBYOBReader(this);\n  };\n  ReadableStream.prototype.pipeThrough = function (rawTransform, rawOptions) {\n   if (rawOptions === void 0) {\n    rawOptions = {};\n   }\n   if (!IsReadableStream(this)) {\n    throw streamBrandCheckException$1('pipeThrough');\n   }\n   assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n   var transform = convertReadableWritablePair(rawTransform, 'First parameter');\n   var options = convertPipeOptions(rawOptions, 'Second parameter');\n   if (IsReadableStreamLocked(this)) {\n    throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n   }\n   if (IsWritableStreamLocked(transform.writable)) {\n    throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n   }\n   var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n   setPromiseIsHandledToTrue(promise);\n   return transform.readable;\n  };\n  ReadableStream.prototype.pipeTo = function (destination, rawOptions) {\n   if (rawOptions === void 0) {\n    rawOptions = {};\n   }\n   if (!IsReadableStream(this)) {\n    return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n   }\n   if (destination === undefined) {\n    return promiseRejectedWith(\"Parameter 1 is required in 'pipeTo'.\");\n   }\n   if (!IsWritableStream(destination)) {\n    return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo's first argument must be a WritableStream\"));\n   }\n   var options;\n   try {\n    options = convertPipeOptions(rawOptions, 'Second parameter');\n   } catch (e) {\n    return promiseRejectedWith(e);\n   }\n   if (IsReadableStreamLocked(this)) {\n    return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n   }\n   if (IsWritableStreamLocked(destination)) {\n    return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n   }\n   return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n  };\n  ReadableStream.prototype.tee = function () {\n   if (!IsReadableStream(this)) {\n    throw streamBrandCheckException$1('tee');\n   }\n   var branches = ReadableStreamTee(this);\n   return CreateArrayFromList(branches);\n  };\n  ReadableStream.prototype.values = function (rawOptions) {\n   if (rawOptions === void 0) {\n    rawOptions = undefined;\n   }\n   if (!IsReadableStream(this)) {\n    throw streamBrandCheckException$1('values');\n   }\n   var options = convertIteratorOptions(rawOptions, 'First parameter');\n   return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n  };\n  return ReadableStream;\n }();\n Object.defineProperties(ReadableStream.prototype, {\n  cancel: { enumerable: true },\n  getReader: { enumerable: true },\n  pipeThrough: { enumerable: true },\n  pipeTo: { enumerable: true },\n  tee: { enumerable: true },\n  values: { enumerable: true },\n  locked: { enumerable: true }\n });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n   value: 'ReadableStream',\n   configurable: true\n  });\n }\n if (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n   value: ReadableStream.prototype.values,\n   writable: true,\n   configurable: true\n  });\n }\n function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  if (highWaterMark === void 0) {\n   highWaterMark = 1;\n  }\n  if (sizeAlgorithm === void 0) {\n   sizeAlgorithm = function () {\n    return 1;\n   };\n  }\n  var stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n  var controller = Object.create(ReadableStreamDefaultController.prototype);\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n }\n function InitializeReadableStream(stream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n }\n function IsReadableStream(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n   return false;\n  }\n  return true;\n }\n function IsReadableStreamLocked(stream) {\n  if (stream._reader === undefined) {\n   return false;\n  }\n  return true;\n }\n function ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n  if (stream._state === 'closed') {\n   return promiseResolvedWith(undefined);\n  }\n  if (stream._state === 'errored') {\n   return promiseRejectedWith(stream._storedError);\n  }\n  ReadableStreamClose(stream);\n  var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return transformPromiseWith(sourceCancelPromise, noop);\n }\n function ReadableStreamClose(stream) {\n  stream._state = 'closed';\n  var reader = stream._reader;\n  if (reader === undefined) {\n   return;\n  }\n  defaultReaderClosedPromiseResolve(reader);\n  if (IsReadableStreamDefaultReader(reader)) {\n   reader._readRequests.forEach(function (readRequest) {\n    readRequest._closeSteps();\n   });\n   reader._readRequests = new SimpleQueue();\n  }\n }\n function ReadableStreamError(stream, e) {\n  stream._state = 'errored';\n  stream._storedError = e;\n  var reader = stream._reader;\n  if (reader === undefined) {\n   return;\n  }\n  defaultReaderClosedPromiseReject(reader, e);\n  if (IsReadableStreamDefaultReader(reader)) {\n   reader._readRequests.forEach(function (readRequest) {\n    readRequest._errorSteps(e);\n   });\n   reader._readRequests = new SimpleQueue();\n  } else {\n   reader._readIntoRequests.forEach(function (readIntoRequest) {\n    readIntoRequest._errorSteps(e);\n   });\n   reader._readIntoRequests = new SimpleQueue();\n  }\n }\n function streamBrandCheckException$1(name) {\n  return new TypeError(\"ReadableStream.prototype.\" + name + \" can only be used on a ReadableStream\");\n }\n function convertQueuingStrategyInit(init, context) {\n  assertDictionary(init, context);\n  var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n  assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n  return { highWaterMark: convertUnrestrictedDouble(highWaterMark) };\n }\n var byteLengthSizeFunction = function size(chunk) {\n  return chunk.byteLength;\n };\n var ByteLengthQueuingStrategy = function () {\n  function ByteLengthQueuingStrategy(options) {\n   assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n   options = convertQueuingStrategyInit(options, 'First parameter');\n   this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n  Object.defineProperty(ByteLengthQueuingStrategy.prototype, \"highWaterMark\", {\n   get: function () {\n    if (!IsByteLengthQueuingStrategy(this)) {\n     throw byteLengthBrandCheckException('highWaterMark');\n    }\n    return this._byteLengthQueuingStrategyHighWaterMark;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  Object.defineProperty(ByteLengthQueuingStrategy.prototype, \"size\", {\n   get: function () {\n    if (!IsByteLengthQueuingStrategy(this)) {\n     throw byteLengthBrandCheckException('size');\n    }\n    return byteLengthSizeFunction;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  return ByteLengthQueuingStrategy;\n }();\n Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n   value: 'ByteLengthQueuingStrategy',\n   configurable: true\n  });\n }\n function byteLengthBrandCheckException(name) {\n  return new TypeError(\"ByteLengthQueuingStrategy.prototype.\" + name + \" can only be used on a ByteLengthQueuingStrategy\");\n }\n function IsByteLengthQueuingStrategy(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n   return false;\n  }\n  return true;\n }\n var countSizeFunction = function size() {\n  return 1;\n };\n var CountQueuingStrategy = function () {\n  function CountQueuingStrategy(options) {\n   assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n   options = convertQueuingStrategyInit(options, 'First parameter');\n   this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n  Object.defineProperty(CountQueuingStrategy.prototype, \"highWaterMark\", {\n   get: function () {\n    if (!IsCountQueuingStrategy(this)) {\n     throw countBrandCheckException('highWaterMark');\n    }\n    return this._countQueuingStrategyHighWaterMark;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  Object.defineProperty(CountQueuingStrategy.prototype, \"size\", {\n   get: function () {\n    if (!IsCountQueuingStrategy(this)) {\n     throw countBrandCheckException('size');\n    }\n    return countSizeFunction;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  return CountQueuingStrategy;\n }();\n Object.defineProperties(CountQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n   value: 'CountQueuingStrategy',\n   configurable: true\n  });\n }\n function countBrandCheckException(name) {\n  return new TypeError(\"CountQueuingStrategy.prototype.\" + name + \" can only be used on a CountQueuingStrategy\");\n }\n function IsCountQueuingStrategy(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n   return false;\n  }\n  return true;\n }\n function convertTransformer(original, context) {\n  assertDictionary(original, context);\n  var flush = original === null || original === void 0 ? void 0 : original.flush;\n  var readableType = original === null || original === void 0 ? void 0 : original.readableType;\n  var start = original === null || original === void 0 ? void 0 : original.start;\n  var transform = original === null || original === void 0 ? void 0 : original.transform;\n  var writableType = original === null || original === void 0 ? void 0 : original.writableType;\n  return {\n   flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, context + \" has member 'flush' that\"),\n   readableType: readableType,\n   start: start === undefined ? undefined : convertTransformerStartCallback(start, original, context + \" has member 'start' that\"),\n   transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, context + \" has member 'transform' that\"),\n   writableType: writableType\n  };\n }\n function convertTransformerFlushCallback(fn, original, context) {\n  assertFunction(fn, context);\n  return function (controller) {\n   return promiseCall(fn, original, [controller]);\n  };\n }\n function convertTransformerStartCallback(fn, original, context) {\n  assertFunction(fn, context);\n  return function (controller) {\n   return reflectCall(fn, original, [controller]);\n  };\n }\n function convertTransformerTransformCallback(fn, original, context) {\n  assertFunction(fn, context);\n  return function (chunk, controller) {\n   return promiseCall(fn, original, [\n    chunk,\n    controller\n   ]);\n  };\n }\n var TransformStream = function () {\n  function TransformStream(rawTransformer, rawWritableStrategy, rawReadableStrategy) {\n   if (rawTransformer === void 0) {\n    rawTransformer = {};\n   }\n   if (rawWritableStrategy === void 0) {\n    rawWritableStrategy = {};\n   }\n   if (rawReadableStrategy === void 0) {\n    rawReadableStrategy = {};\n   }\n   if (rawTransformer === undefined) {\n    rawTransformer = null;\n   }\n   var writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n   var readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n   var transformer = convertTransformer(rawTransformer, 'First parameter');\n   if (transformer.readableType !== undefined) {\n    throw new RangeError('Invalid readableType specified');\n   }\n   if (transformer.writableType !== undefined) {\n    throw new RangeError('Invalid writableType specified');\n   }\n   var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n   var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n   var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n   var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n   var startPromise_resolve;\n   var startPromise = newPromise(function (resolve) {\n    startPromise_resolve = resolve;\n   });\n   InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n   SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n   if (transformer.start !== undefined) {\n    startPromise_resolve(transformer.start(this._transformStreamController));\n   } else {\n    startPromise_resolve(undefined);\n   }\n  }\n  Object.defineProperty(TransformStream.prototype, \"readable\", {\n   get: function () {\n    if (!IsTransformStream(this)) {\n     throw streamBrandCheckException$2('readable');\n    }\n    return this._readable;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  Object.defineProperty(TransformStream.prototype, \"writable\", {\n   get: function () {\n    if (!IsTransformStream(this)) {\n     throw streamBrandCheckException$2('writable');\n    }\n    return this._writable;\n   },\n   enumerable: false,\n   configurable: true\n  });\n  return TransformStream;\n }();\n Object.defineProperties(TransformStream.prototype, {\n  readable: { enumerable: true },\n  writable: { enumerable: true }\n });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n   value: 'TransformStream',\n   configurable: true\n  });\n }\n function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n  function startAlgorithm() {\n   return startPromise;\n  }\n  function writeAlgorithm(chunk) {\n   return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n  function abortAlgorithm(reason) {\n   return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n  function closeAlgorithm() {\n   return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n  function pullAlgorithm() {\n   return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n  function cancelAlgorithm(reason) {\n   TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n   return promiseResolvedWith(undefined);\n  }\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n  stream._backpressure = undefined;\n  stream._backpressureChangePromise = undefined;\n  stream._backpressureChangePromise_resolve = undefined;\n  TransformStreamSetBackpressure(stream, true);\n  stream._transformStreamController = undefined;\n }\n function IsTransformStream(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n   return false;\n  }\n  return true;\n }\n function TransformStreamError(stream, e) {\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n }\n function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  if (stream._backpressure) {\n   TransformStreamSetBackpressure(stream, false);\n  }\n }\n function TransformStreamSetBackpressure(stream, backpressure) {\n  if (stream._backpressureChangePromise !== undefined) {\n   stream._backpressureChangePromise_resolve();\n  }\n  stream._backpressureChangePromise = newPromise(function (resolve) {\n   stream._backpressureChangePromise_resolve = resolve;\n  });\n  stream._backpressure = backpressure;\n }\n var TransformStreamDefaultController = function () {\n  function TransformStreamDefaultController() {\n   throw new TypeError('Illegal constructor');\n  }\n  Object.defineProperty(TransformStreamDefaultController.prototype, \"desiredSize\", {\n   get: function () {\n    if (!IsTransformStreamDefaultController(this)) {\n     throw defaultControllerBrandCheckException$1('desiredSize');\n    }\n    var readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n   },\n   enumerable: false,\n   configurable: true\n  });\n  TransformStreamDefaultController.prototype.enqueue = function (chunk) {\n   if (chunk === void 0) {\n    chunk = undefined;\n   }\n   if (!IsTransformStreamDefaultController(this)) {\n    throw defaultControllerBrandCheckException$1('enqueue');\n   }\n   TransformStreamDefaultControllerEnqueue(this, chunk);\n  };\n  TransformStreamDefaultController.prototype.error = function (reason) {\n   if (reason === void 0) {\n    reason = undefined;\n   }\n   if (!IsTransformStreamDefaultController(this)) {\n    throw defaultControllerBrandCheckException$1('error');\n   }\n   TransformStreamDefaultControllerError(this, reason);\n  };\n  TransformStreamDefaultController.prototype.terminate = function () {\n   if (!IsTransformStreamDefaultController(this)) {\n    throw defaultControllerBrandCheckException$1('terminate');\n   }\n   TransformStreamDefaultControllerTerminate(this);\n  };\n  return TransformStreamDefaultController;\n }();\n Object.defineProperties(TransformStreamDefaultController.prototype, {\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  terminate: { enumerable: true },\n  desiredSize: { enumerable: true }\n });\n if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n   value: 'TransformStreamDefaultController',\n   configurable: true\n  });\n }\n function IsTransformStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n   return false;\n  }\n  return true;\n }\n function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n }\n function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n  var controller = Object.create(TransformStreamDefaultController.prototype);\n  var transformAlgorithm = function (chunk) {\n   try {\n    TransformStreamDefaultControllerEnqueue(controller, chunk);\n    return promiseResolvedWith(undefined);\n   } catch (transformResultE) {\n    return promiseRejectedWith(transformResultE);\n   }\n  };\n  var flushAlgorithm = function () {\n   return promiseResolvedWith(undefined);\n  };\n  if (transformer.transform !== undefined) {\n   transformAlgorithm = function (chunk) {\n    return transformer.transform(chunk, controller);\n   };\n  }\n  if (transformer.flush !== undefined) {\n   flushAlgorithm = function () {\n    return transformer.flush(controller);\n   };\n  }\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n }\n function TransformStreamDefaultControllerClearAlgorithms(controller) {\n  controller._transformAlgorithm = undefined;\n  controller._flushAlgorithm = undefined;\n }\n function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  var stream = controller._controlledTransformStream;\n  var readableController = stream._readable._readableStreamController;\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n   throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n  try {\n   ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n   TransformStreamErrorWritableAndUnblockWrite(stream, e);\n   throw stream._readable._storedError;\n  }\n  var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n   TransformStreamSetBackpressure(stream, true);\n  }\n }\n function TransformStreamDefaultControllerError(controller, e) {\n  TransformStreamError(controller._controlledTransformStream, e);\n }\n function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n  var transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromiseWith(transformPromise, undefined, function (r) {\n   TransformStreamError(controller._controlledTransformStream, r);\n   throw r;\n  });\n }\n function TransformStreamDefaultControllerTerminate(controller) {\n  var stream = controller._controlledTransformStream;\n  var readableController = stream._readable._readableStreamController;\n  ReadableStreamDefaultControllerClose(readableController);\n  var error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n }\n function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  var controller = stream._transformStreamController;\n  if (stream._backpressure) {\n   var backpressureChangePromise = stream._backpressureChangePromise;\n   return transformPromiseWith(backpressureChangePromise, function () {\n    var writable = stream._writable;\n    var state = writable._state;\n    if (state === 'erroring') {\n     throw writable._storedError;\n    }\n    return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n   });\n  }\n  return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n }\n function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n  TransformStreamError(stream, reason);\n  return promiseResolvedWith(undefined);\n }\n function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n  var readable = stream._readable;\n  var controller = stream._transformStreamController;\n  var flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n  return transformPromiseWith(flushPromise, function () {\n   if (readable._state === 'errored') {\n    throw readable._storedError;\n   }\n   ReadableStreamDefaultControllerClose(readable._readableStreamController);\n  }, function (r) {\n   TransformStreamError(stream, r);\n   throw readable._storedError;\n  });\n }\n function TransformStreamDefaultSourcePullAlgorithm(stream) {\n  TransformStreamSetBackpressure(stream, false);\n  return stream._backpressureChangePromise;\n }\n function defaultControllerBrandCheckException$1(name) {\n  return new TypeError(\"TransformStreamDefaultController.prototype.\" + name + \" can only be used on a TransformStreamDefaultController\");\n }\n function streamBrandCheckException$2(name) {\n  return new TypeError(\"TransformStream.prototype.\" + name + \" can only be used on a TransformStream\");\n }\n exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n exports.CountQueuingStrategy = CountQueuingStrategy;\n exports.ReadableByteStreamController = ReadableByteStreamController;\n exports.ReadableStream = ReadableStream;\n exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n exports.ReadableStreamDefaultController = ReadableStreamDefaultController;\n exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n exports.TransformStream = TransformStream;\n exports.TransformStreamDefaultController = TransformStreamDefaultController;\n exports.WritableStream = WritableStream;\n exports.WritableStreamDefaultController = WritableStreamDefaultController;\n exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n/***/ }),\n/* 122 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(123);\nvar entryUnbind = __w_pdfjs_require__(127);\nmodule.exports = entryUnbind('String', 'padStart');\n\n/***/ }),\n/* 123 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(9);\nvar $padStart = __w_pdfjs_require__(124).start;\nvar WEBKIT_BUG = __w_pdfjs_require__(126);\n$({\n target: 'String',\n proto: true,\n forced: WEBKIT_BUG\n}, {\n padStart: function padStart(maxLength) {\n  return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);\n }\n});\n\n/***/ }),\n/* 124 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar toLength = __w_pdfjs_require__(46);\nvar repeat = __w_pdfjs_require__(125);\nvar requireObjectCoercible = __w_pdfjs_require__(19);\nvar ceil = Math.ceil;\nvar createMethod = function (IS_END) {\n return function ($this, maxLength, fillString) {\n  var S = String(requireObjectCoercible($this));\n  var stringLength = S.length;\n  var fillStr = fillString === undefined ? ' ' : String(fillString);\n  var intMaxLength = toLength(maxLength);\n  var fillLen, stringFiller;\n  if (intMaxLength <= stringLength || fillStr == '')\n   return S;\n  fillLen = intMaxLength - stringLength;\n  stringFiller = repeat.call(fillStr, ceil(fillLen / fillStr.length));\n  if (stringFiller.length > fillLen)\n   stringFiller = stringFiller.slice(0, fillLen);\n  return IS_END ? S + stringFiller : stringFiller + S;\n };\n};\nmodule.exports = {\n start: createMethod(false),\n end: createMethod(true)\n};\n\n/***/ }),\n/* 125 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar toInteger = __w_pdfjs_require__(47);\nvar requireObjectCoercible = __w_pdfjs_require__(19);\nmodule.exports = ''.repeat || function repeat(count) {\n var str = String(requireObjectCoercible(this));\n var result = '';\n var n = toInteger(count);\n if (n < 0 || n == Infinity)\n  throw RangeError('Wrong number of repetitions');\n for (; n > 0; (n >>>= 1) && (str += str))\n  if (n & 1)\n   result += str;\n return result;\n};\n\n/***/ }),\n/* 126 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar userAgent = __w_pdfjs_require__(95);\nmodule.exports = /Version\\/10\\.\\d+(\\.\\d+)?( Mobile\\/\\w+)? Safari\\//.test(userAgent);\n\n/***/ }),\n/* 127 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(10);\nvar bind = __w_pdfjs_require__(75);\nvar call = Function.call;\nmodule.exports = function (CONSTRUCTOR, METHOD, length) {\n return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);\n};\n\n/***/ }),\n/* 128 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(129);\nvar entryUnbind = __w_pdfjs_require__(127);\nmodule.exports = entryUnbind('String', 'padEnd');\n\n/***/ }),\n/* 129 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(9);\nvar $padEnd = __w_pdfjs_require__(124).end;\nvar WEBKIT_BUG = __w_pdfjs_require__(126);\n$({\n target: 'String',\n proto: true,\n forced: WEBKIT_BUG\n}, {\n padEnd: function padEnd(maxLength) {\n  return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);\n }\n});\n\n/***/ }),\n/* 130 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(131);\nvar path = __w_pdfjs_require__(42);\nmodule.exports = path.Object.values;\n\n/***/ }),\n/* 131 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(9);\nvar $values = __w_pdfjs_require__(132).values;\n$({\n target: 'Object',\n stat: true\n}, {\n values: function values(O) {\n  return $values(O);\n }\n});\n\n/***/ }),\n/* 132 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(12);\nvar objectKeys = __w_pdfjs_require__(60);\nvar toIndexedObject = __w_pdfjs_require__(16);\nvar propertyIsEnumerable = __w_pdfjs_require__(14).f;\nvar createMethod = function (TO_ENTRIES) {\n return function (it) {\n  var O = toIndexedObject(it);\n  var keys = objectKeys(O);\n  var length = keys.length;\n  var i = 0;\n  var result = [];\n  var key;\n  while (length > i) {\n   key = keys[i++];\n   if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {\n    result.push(TO_ENTRIES ? [\n     key,\n     O[key]\n    ] : O[key]);\n   }\n  }\n  return result;\n };\n};\nmodule.exports = {\n entries: createMethod(true),\n values: createMethod(false)\n};\n\n/***/ }),\n/* 133 */\n/***/ (function(module, __unused_webpack_exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(134);\nvar path = __w_pdfjs_require__(42);\nmodule.exports = path.Object.entries;\n\n/***/ }),\n/* 134 */\n/***/ (function(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(9);\nvar $entries = __w_pdfjs_require__(132).entries;\n$({\n target: 'Object',\n stat: true\n}, {\n entries: function entries(O) {\n  return $entries(O);\n }\n});\n\n/***/ }),\n/* 135 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getDocument = getDocument;\nexports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;\nexports.version = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.putBinaryImageData = exports.DefaultCMapReaderFactory = exports.DefaultCanvasFactory = exports.build = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(4);\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _font_loader = __w_pdfjs_require__(136);\n\nvar _node_utils = __w_pdfjs_require__(137);\n\nvar _annotation_storage = __w_pdfjs_require__(138);\n\nvar _api_compatibility = __w_pdfjs_require__(139);\n\nvar _canvas = __w_pdfjs_require__(140);\n\nvar _worker_options = __w_pdfjs_require__(142);\n\nvar _is_node = __w_pdfjs_require__(6);\n\nvar _message_handler = __w_pdfjs_require__(143);\n\nvar _metadata = __w_pdfjs_require__(144);\n\nvar _optional_content_config = __w_pdfjs_require__(146);\n\nvar _transport_stream = __w_pdfjs_require__(147);\n\nvar _webgl = __w_pdfjs_require__(148);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar DEFAULT_RANGE_CHUNK_SIZE = 65536;\nvar RENDERING_CANCELLED_TIMEOUT = 100;\nvar DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\nexports.DefaultCanvasFactory = DefaultCanvasFactory;\nvar DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\nexports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\nvar createPDFNetworkStream;\n\nfunction setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {\n  createPDFNetworkStream = pdfNetworkStreamFactory;\n}\n\nfunction getDocument(src) {\n  var task = new PDFDocumentLoadingTask();\n  var source;\n\n  if (typeof src === \"string\") {\n    source = {\n      url: src\n    };\n  } else if ((0, _util.isArrayBuffer)(src)) {\n    source = {\n      data: src\n    };\n  } else if (src instanceof PDFDataRangeTransport) {\n    source = {\n      range: src\n    };\n  } else {\n    if (_typeof(src) !== \"object\") {\n      throw new Error(\"Invalid parameter in getDocument, \" + \"need either Uint8Array, string or a parameter object\");\n    }\n\n    if (!src.url && !src.data && !src.range) {\n      throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n    }\n\n    source = src;\n  }\n\n  var params = Object.create(null);\n  var rangeTransport = null,\n      worker = null;\n\n  for (var key in source) {\n    if (key === \"url\" && typeof window !== \"undefined\") {\n      params[key] = new URL(source[key], window.location).href;\n      continue;\n    } else if (key === \"range\") {\n      rangeTransport = source[key];\n      continue;\n    } else if (key === \"worker\") {\n      worker = source[key];\n      continue;\n    } else if (key === \"data\" && !(source[key] instanceof Uint8Array)) {\n      var pdfBytes = source[key];\n\n      if (typeof pdfBytes === \"string\") {\n        params[key] = (0, _util.stringToBytes)(pdfBytes);\n      } else if (_typeof(pdfBytes) === \"object\" && pdfBytes !== null && !isNaN(pdfBytes.length)) {\n        params[key] = new Uint8Array(pdfBytes);\n      } else if ((0, _util.isArrayBuffer)(pdfBytes)) {\n        params[key] = new Uint8Array(pdfBytes);\n      } else {\n        throw new Error(\"Invalid PDF binary data: either typed array, \" + \"string or array-like object is expected in the \" + \"data property.\");\n      }\n\n      continue;\n    }\n\n    params[key] = source[key];\n  }\n\n  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;\n  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;\n  params.ignoreErrors = params.stopAtErrors !== true;\n  params.fontExtraProperties = params.fontExtraProperties === true;\n  params.pdfBug = params.pdfBug === true;\n\n  if (!Number.isInteger(params.maxImageSize)) {\n    params.maxImageSize = -1;\n  }\n\n  if (typeof params.isEvalSupported !== \"boolean\") {\n    params.isEvalSupported = true;\n  }\n\n  if (typeof params.disableFontFace !== \"boolean\") {\n    params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;\n  }\n\n  if (typeof params.ownerDocument === \"undefined\") {\n    params.ownerDocument = globalThis.document;\n  }\n\n  if (typeof params.disableRange !== \"boolean\") {\n    params.disableRange = false;\n  }\n\n  if (typeof params.disableStream !== \"boolean\") {\n    params.disableStream = false;\n  }\n\n  if (typeof params.disableAutoFetch !== \"boolean\") {\n    params.disableAutoFetch = false;\n  }\n\n  (0, _util.setVerbosityLevel)(params.verbosity);\n\n  if (!worker) {\n    var workerParams = {\n      verbosity: params.verbosity,\n      port: _worker_options.GlobalWorkerOptions.workerPort\n    };\n    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n    task._worker = worker;\n  }\n\n  var docId = task.docId;\n  worker.promise.then(function () {\n    if (task.destroyed) {\n      throw new Error(\"Loading aborted\");\n    }\n\n    var workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);\n\n    var networkStreamPromise = new Promise(function (resolve) {\n      var networkStream;\n\n      if (rangeTransport) {\n        networkStream = new _transport_stream.PDFDataTransportStream({\n          length: params.length,\n          initialData: params.initialData,\n          progressiveDone: params.progressiveDone,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        }, rangeTransport);\n      } else if (!params.data) {\n        networkStream = createPDFNetworkStream({\n          url: params.url,\n          length: params.length,\n          httpHeaders: params.httpHeaders,\n          withCredentials: params.withCredentials,\n          rangeChunkSize: params.rangeChunkSize,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        });\n      }\n\n      resolve(networkStream);\n    });\n    return Promise.all([workerIdPromise, networkStreamPromise]).then(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          workerId = _ref2[0],\n          networkStream = _ref2[1];\n\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n\n      var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n      messageHandler.postMessageTransfers = worker.postMessageTransfers;\n      var transport = new WorkerTransport(messageHandler, task, networkStream, params);\n      task._transport = transport;\n      messageHandler.send(\"Ready\", null);\n    });\n  })[\"catch\"](task._capability.reject);\n  return task;\n}\n\nfunction _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\n  if (worker.destroyed) {\n    return Promise.reject(new Error(\"Worker was destroyed\"));\n  }\n\n  if (pdfDataRangeTransport) {\n    source.length = pdfDataRangeTransport.length;\n    source.initialData = pdfDataRangeTransport.initialData;\n    source.progressiveDone = pdfDataRangeTransport.progressiveDone;\n  }\n\n  return worker.messageHandler.sendWithPromise(\"GetDocRequest\", {\n    docId: docId,\n    apiVersion: '2.8.173',\n    source: {\n      data: source.data,\n      url: source.url,\n      password: source.password,\n      disableAutoFetch: source.disableAutoFetch,\n      rangeChunkSize: source.rangeChunkSize,\n      length: source.length\n    },\n    maxImageSize: source.maxImageSize,\n    disableFontFace: source.disableFontFace,\n    postMessageTransfers: worker.postMessageTransfers,\n    docBaseUrl: source.docBaseUrl,\n    ignoreErrors: source.ignoreErrors,\n    isEvalSupported: source.isEvalSupported,\n    fontExtraProperties: source.fontExtraProperties\n  }).then(function (workerId) {\n    if (worker.destroyed) {\n      throw new Error(\"Worker was destroyed\");\n    }\n\n    return workerId;\n  });\n}\n\nvar PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {\n  var nextDocumentId = 0;\n\n  var PDFDocumentLoadingTask = /*#__PURE__*/function () {\n    function PDFDocumentLoadingTask() {\n      _classCallCheck(this, PDFDocumentLoadingTask);\n\n      this._capability = (0, _util.createPromiseCapability)();\n      this._transport = null;\n      this._worker = null;\n      this.docId = \"d\" + nextDocumentId++;\n      this.destroyed = false;\n      this.onPassword = null;\n      this.onProgress = null;\n      this.onUnsupportedFeature = null;\n    }\n\n    _createClass(PDFDocumentLoadingTask, [{\n      key: \"promise\",\n      get: function get() {\n        return this._capability.promise;\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        var _this = this;\n\n        this.destroyed = true;\n        var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();\n        return transportDestroyed.then(function () {\n          _this._transport = null;\n\n          if (_this._worker) {\n            _this._worker.destroy();\n\n            _this._worker = null;\n          }\n        });\n      }\n    }]);\n\n    return PDFDocumentLoadingTask;\n  }();\n\n  return PDFDocumentLoadingTask;\n}();\n\nvar PDFDataRangeTransport = /*#__PURE__*/function () {\n  function PDFDataRangeTransport(length, initialData) {\n    var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, PDFDataRangeTransport);\n\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this._rangeListeners = [];\n    this._progressListeners = [];\n    this._progressiveReadListeners = [];\n    this._progressiveDoneListeners = [];\n    this._readyCapability = (0, _util.createPromiseCapability)();\n  }\n\n  _createClass(PDFDataRangeTransport, [{\n    key: \"addRangeListener\",\n    value: function addRangeListener(listener) {\n      this._rangeListeners.push(listener);\n    }\n  }, {\n    key: \"addProgressListener\",\n    value: function addProgressListener(listener) {\n      this._progressListeners.push(listener);\n    }\n  }, {\n    key: \"addProgressiveReadListener\",\n    value: function addProgressiveReadListener(listener) {\n      this._progressiveReadListeners.push(listener);\n    }\n  }, {\n    key: \"addProgressiveDoneListener\",\n    value: function addProgressiveDoneListener(listener) {\n      this._progressiveDoneListeners.push(listener);\n    }\n  }, {\n    key: \"onDataRange\",\n    value: function onDataRange(begin, chunk) {\n      var _iterator = _createForOfIteratorHelper(this._rangeListeners),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var listener = _step.value;\n          listener(begin, chunk);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"onDataProgress\",\n    value: function onDataProgress(loaded, total) {\n      var _this2 = this;\n\n      this._readyCapability.promise.then(function () {\n        var _iterator2 = _createForOfIteratorHelper(_this2._progressListeners),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var listener = _step2.value;\n            listener(loaded, total);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      });\n    }\n  }, {\n    key: \"onDataProgressiveRead\",\n    value: function onDataProgressiveRead(chunk) {\n      var _this3 = this;\n\n      this._readyCapability.promise.then(function () {\n        var _iterator3 = _createForOfIteratorHelper(_this3._progressiveReadListeners),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var listener = _step3.value;\n            listener(chunk);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      });\n    }\n  }, {\n    key: \"onDataProgressiveDone\",\n    value: function onDataProgressiveDone() {\n      var _this4 = this;\n\n      this._readyCapability.promise.then(function () {\n        var _iterator4 = _createForOfIteratorHelper(_this4._progressiveDoneListeners),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var listener = _step4.value;\n            listener();\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      });\n    }\n  }, {\n    key: \"transportReady\",\n    value: function transportReady() {\n      this._readyCapability.resolve();\n    }\n  }, {\n    key: \"requestDataRange\",\n    value: function requestDataRange(begin, end) {\n      (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {}\n  }]);\n\n  return PDFDataRangeTransport;\n}();\n\nexports.PDFDataRangeTransport = PDFDataRangeTransport;\n\nvar PDFDocumentProxy = /*#__PURE__*/function () {\n  function PDFDocumentProxy(pdfInfo, transport) {\n    _classCallCheck(this, PDFDocumentProxy);\n\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n  }\n\n  _createClass(PDFDocumentProxy, [{\n    key: \"annotationStorage\",\n    get: function get() {\n      return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n    }\n  }, {\n    key: \"numPages\",\n    get: function get() {\n      return this._pdfInfo.numPages;\n    }\n  }, {\n    key: \"fingerprint\",\n    get: function get() {\n      return this._pdfInfo.fingerprint;\n    }\n  }, {\n    key: \"getPage\",\n    value: function getPage(pageNumber) {\n      return this._transport.getPage(pageNumber);\n    }\n  }, {\n    key: \"getPageIndex\",\n    value: function getPageIndex(ref) {\n      return this._transport.getPageIndex(ref);\n    }\n  }, {\n    key: \"getPageOCGNames\",\n    value: function getPageOCGNames(ref) {\n      return this._transport.getPageOCGNames(ref);\n    }\n  }, {\n    key: \"getObject\",\n    value: function getObject(ref) {\n      return this._transport.getObject(ref);\n    }\n  }, {\n    key: \"getDestinations\",\n    value: function getDestinations() {\n      return this._transport.getDestinations();\n    }\n  }, {\n    key: \"getDestination\",\n    value: function getDestination(id) {\n      return this._transport.getDestination(id);\n    }\n  }, {\n    key: \"getPageLabels\",\n    value: function getPageLabels() {\n      return this._transport.getPageLabels();\n    }\n  }, {\n    key: \"getPageLayout\",\n    value: function getPageLayout() {\n      return this._transport.getPageLayout();\n    }\n  }, {\n    key: \"getPageMode\",\n    value: function getPageMode() {\n      return this._transport.getPageMode();\n    }\n  }, {\n    key: \"getViewerPreferences\",\n    value: function getViewerPreferences() {\n      return this._transport.getViewerPreferences();\n    }\n  }, {\n    key: \"getOpenAction\",\n    value: function getOpenAction() {\n      return this._transport.getOpenAction();\n    }\n  }, {\n    key: \"getAttachments\",\n    value: function getAttachments() {\n      return this._transport.getAttachments();\n    }\n  }, {\n    key: \"getJavaScript\",\n    value: function getJavaScript() {\n      return this._transport.getJavaScript();\n    }\n  }, {\n    key: \"getJSActions\",\n    value: function getJSActions() {\n      return this._transport.getDocJSActions();\n    }\n  }, {\n    key: \"getOutline\",\n    value: function getOutline() {\n      return this._transport.getOutline();\n    }\n  }, {\n    key: \"getOptionalContentConfig\",\n    value: function getOptionalContentConfig() {\n      return this._transport.getOptionalContentConfig();\n    }\n  }, {\n    key: \"getPermissions\",\n    value: function getPermissions() {\n      return this._transport.getPermissions();\n    }\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata() {\n      return this._transport.getMetadata();\n    }\n  }, {\n    key: \"getMarkInfo\",\n    value: function getMarkInfo() {\n      return this._transport.getMarkInfo();\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this._transport.getData();\n    }\n  }, {\n    key: \"getDownloadInfo\",\n    value: function getDownloadInfo() {\n      return this._transport.downloadInfoCapability.promise;\n    }\n  }, {\n    key: \"getStats\",\n    value: function getStats() {\n      return this._transport.getStats();\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      return this._transport.startCleanup();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      return this.loadingTask.destroy();\n    }\n  }, {\n    key: \"loadingParams\",\n    get: function get() {\n      return this._transport.loadingParams;\n    }\n  }, {\n    key: \"loadingTask\",\n    get: function get() {\n      return this._transport.loadingTask;\n    }\n  }, {\n    key: \"saveDocument\",\n    value: function saveDocument(annotationStorage) {\n      return this._transport.saveDocument(annotationStorage);\n    }\n  }, {\n    key: \"getFieldObjects\",\n    value: function getFieldObjects() {\n      return this._transport.getFieldObjects();\n    }\n  }, {\n    key: \"hasJSActions\",\n    value: function hasJSActions() {\n      return this._transport.hasJSActions();\n    }\n  }, {\n    key: \"getCalculationOrderIds\",\n    value: function getCalculationOrderIds() {\n      return this._transport.getCalculationOrderIds();\n    }\n  }]);\n\n  return PDFDocumentProxy;\n}();\n\nexports.PDFDocumentProxy = PDFDocumentProxy;\n\nvar PDFPageProxy = /*#__PURE__*/function () {\n  function PDFPageProxy(pageIndex, pageInfo, transport, ownerDocument) {\n    var pdfBug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    _classCallCheck(this, PDFPageProxy);\n\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._ownerDocument = ownerDocument;\n    this._transport = transport;\n    this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this.cleanupAfterRender = false;\n    this.pendingCleanup = false;\n    this._intentStates = new Map();\n    this.destroyed = false;\n  }\n\n  _createClass(PDFPageProxy, [{\n    key: \"pageNumber\",\n    get: function get() {\n      return this._pageIndex + 1;\n    }\n  }, {\n    key: \"rotate\",\n    get: function get() {\n      return this._pageInfo.rotate;\n    }\n  }, {\n    key: \"ref\",\n    get: function get() {\n      return this._pageInfo.ref;\n    }\n  }, {\n    key: \"userUnit\",\n    get: function get() {\n      return this._pageInfo.userUnit;\n    }\n  }, {\n    key: \"view\",\n    get: function get() {\n      return this._pageInfo.view;\n    }\n  }, {\n    key: \"getViewport\",\n    value: function getViewport() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          scale = _ref3.scale,\n          _ref3$rotation = _ref3.rotation,\n          rotation = _ref3$rotation === void 0 ? this.rotate : _ref3$rotation,\n          _ref3$offsetX = _ref3.offsetX,\n          offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX,\n          _ref3$offsetY = _ref3.offsetY,\n          offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY,\n          _ref3$dontFlip = _ref3.dontFlip,\n          dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip;\n\n      return new _display_utils.PageViewport({\n        viewBox: this.view,\n        scale: scale,\n        rotation: rotation,\n        offsetX: offsetX,\n        offsetY: offsetY,\n        dontFlip: dontFlip\n      });\n    }\n  }, {\n    key: \"getAnnotations\",\n    value: function getAnnotations() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$intent = _ref4.intent,\n          intent = _ref4$intent === void 0 ? null : _ref4$intent;\n\n      if (!this.annotationsPromise || this.annotationsIntent !== intent) {\n        this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);\n        this.annotationsIntent = intent;\n      }\n\n      return this.annotationsPromise;\n    }\n  }, {\n    key: \"getJSActions\",\n    value: function getJSActions() {\n      return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));\n    }\n  }, {\n    key: \"render\",\n    value: function render(_ref5) {\n      var _this5 = this;\n\n      var canvasContext = _ref5.canvasContext,\n          viewport = _ref5.viewport,\n          _ref5$intent = _ref5.intent,\n          intent = _ref5$intent === void 0 ? \"display\" : _ref5$intent,\n          _ref5$enableWebGL = _ref5.enableWebGL,\n          enableWebGL = _ref5$enableWebGL === void 0 ? false : _ref5$enableWebGL,\n          _ref5$renderInteracti = _ref5.renderInteractiveForms,\n          renderInteractiveForms = _ref5$renderInteracti === void 0 ? false : _ref5$renderInteracti,\n          _ref5$transform = _ref5.transform,\n          transform = _ref5$transform === void 0 ? null : _ref5$transform,\n          _ref5$imageLayer = _ref5.imageLayer,\n          imageLayer = _ref5$imageLayer === void 0 ? null : _ref5$imageLayer,\n          _ref5$canvasFactory = _ref5.canvasFactory,\n          canvasFactory = _ref5$canvasFactory === void 0 ? null : _ref5$canvasFactory,\n          _ref5$background = _ref5.background,\n          background = _ref5$background === void 0 ? null : _ref5$background,\n          _ref5$annotationStora = _ref5.annotationStorage,\n          annotationStorage = _ref5$annotationStora === void 0 ? null : _ref5$annotationStora,\n          _ref5$optionalContent = _ref5.optionalContentConfigPromise,\n          optionalContentConfigPromise = _ref5$optionalContent === void 0 ? null : _ref5$optionalContent;\n\n      if (this._stats) {\n        this._stats.time(\"Overall\");\n      }\n\n      var renderingIntent = intent === \"print\" ? \"print\" : \"display\";\n      this.pendingCleanup = false;\n\n      if (!optionalContentConfigPromise) {\n        optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n      }\n\n      var intentState = this._intentStates.get(renderingIntent);\n\n      if (!intentState) {\n        intentState = Object.create(null);\n\n        this._intentStates.set(renderingIntent, intentState);\n      }\n\n      if (intentState.streamReaderCancelTimeout) {\n        clearTimeout(intentState.streamReaderCancelTimeout);\n        intentState.streamReaderCancelTimeout = null;\n      }\n\n      var canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({\n        ownerDocument: this._ownerDocument\n      });\n      var webGLContext = new _webgl.WebGLContext({\n        enable: enableWebGL\n      });\n\n      if (!intentState.displayReadyCapability) {\n        intentState.displayReadyCapability = (0, _util.createPromiseCapability)();\n        intentState.operatorList = {\n          fnArray: [],\n          argsArray: [],\n          lastChunk: false\n        };\n\n        if (this._stats) {\n          this._stats.time(\"Page Request\");\n        }\n\n        this._pumpOperatorList({\n          pageIndex: this._pageIndex,\n          intent: renderingIntent,\n          renderInteractiveForms: renderInteractiveForms === true,\n          annotationStorage: (annotationStorage === null || annotationStorage === void 0 ? void 0 : annotationStorage.getAll()) || null\n        });\n      }\n\n      var complete = function complete(error) {\n        var i = intentState.renderTasks.indexOf(internalRenderTask);\n\n        if (i >= 0) {\n          intentState.renderTasks.splice(i, 1);\n        }\n\n        if (_this5.cleanupAfterRender || renderingIntent === \"print\") {\n          _this5.pendingCleanup = true;\n        }\n\n        _this5._tryCleanup();\n\n        if (error) {\n          internalRenderTask.capability.reject(error);\n\n          _this5._abortOperatorList({\n            intentState: intentState,\n            reason: error\n          });\n        } else {\n          internalRenderTask.capability.resolve();\n        }\n\n        if (_this5._stats) {\n          _this5._stats.timeEnd(\"Rendering\");\n\n          _this5._stats.timeEnd(\"Overall\");\n        }\n      };\n\n      var internalRenderTask = new InternalRenderTask({\n        callback: complete,\n        params: {\n          canvasContext: canvasContext,\n          viewport: viewport,\n          transform: transform,\n          imageLayer: imageLayer,\n          background: background\n        },\n        objs: this.objs,\n        commonObjs: this.commonObjs,\n        operatorList: intentState.operatorList,\n        pageIndex: this._pageIndex,\n        canvasFactory: canvasFactoryInstance,\n        webGLContext: webGLContext,\n        useRequestAnimationFrame: renderingIntent !== \"print\",\n        pdfBug: this._pdfBug\n      });\n\n      if (!intentState.renderTasks) {\n        intentState.renderTasks = [];\n      }\n\n      intentState.renderTasks.push(internalRenderTask);\n      var renderTask = internalRenderTask.task;\n      Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 2),\n            transparency = _ref7[0],\n            optionalContentConfig = _ref7[1];\n\n        if (_this5.pendingCleanup) {\n          complete();\n          return;\n        }\n\n        if (_this5._stats) {\n          _this5._stats.time(\"Rendering\");\n        }\n\n        internalRenderTask.initializeGraphics({\n          transparency: transparency,\n          optionalContentConfig: optionalContentConfig\n        });\n        internalRenderTask.operatorListChanged();\n      })[\"catch\"](complete);\n      return renderTask;\n    }\n  }, {\n    key: \"getOperatorList\",\n    value: function getOperatorList(intent) {\n      function operatorListChanged() {\n        if (intentState.operatorList.lastChunk) {\n          intentState.opListReadCapability.resolve(intentState.operatorList);\n          var i = intentState.renderTasks.indexOf(opListTask);\n\n          if (i >= 0) {\n            intentState.renderTasks.splice(i, 1);\n          }\n        }\n      }\n\n      var renderingIntent = intent || \"oplist\";\n\n      var intentState = this._intentStates.get(renderingIntent);\n\n      if (!intentState) {\n        intentState = Object.create(null);\n\n        this._intentStates.set(renderingIntent, intentState);\n      }\n\n      var opListTask;\n\n      if (!intentState.displayReadyCapability) {\n        intentState.displayReadyCapability = (0, _util.createPromiseCapability)();\n        intentState.operatorList = {\n          fnArray: [],\n          argsArray: [],\n          lastChunk: false\n        };\n\n        if (this._stats) {\n          this._stats.time(\"Page Request\");\n        }\n\n        this._pumpOperatorList({\n          pageIndex: this._pageIndex,\n          intent: renderingIntent\n        });\n      }\n\n      if (!intentState.opListReadCapability) {\n        intentState.opListReadCapability = (0, _util.createPromiseCapability)();\n\n        if (!intentState.renderTasks) {\n          intentState.renderTasks = [];\n        }\n\n        opListTask = Object.create(null);\n        opListTask.operatorListChanged = operatorListChanged;\n        intentState.renderTasks.push(opListTask);\n        operatorListChanged();\n      }\n\n      return intentState.opListReadCapability.promise;\n    }\n  }, {\n    key: \"streamTextContent\",\n    value: function streamTextContent() {\n      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref8$normalizeWhites = _ref8.normalizeWhitespace,\n          normalizeWhitespace = _ref8$normalizeWhites === void 0 ? false : _ref8$normalizeWhites,\n          _ref8$disableCombineT = _ref8.disableCombineTextItems,\n          disableCombineTextItems = _ref8$disableCombineT === void 0 ? false : _ref8$disableCombineT;\n\n      var TEXT_CONTENT_CHUNK_SIZE = 100;\n      return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n        pageIndex: this._pageIndex,\n        normalizeWhitespace: normalizeWhitespace === true,\n        combineTextItems: disableCombineTextItems !== true\n      }, {\n        highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n        size: function size(textContent) {\n          return textContent.items.length;\n        }\n      });\n    }\n  }, {\n    key: \"getTextContent\",\n    value: function getTextContent() {\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var readableStream = this.streamTextContent(params);\n      return new Promise(function (resolve, reject) {\n        function pump() {\n          reader.read().then(function (_ref9) {\n            var _textContent$items;\n\n            var value = _ref9.value,\n                done = _ref9.done;\n\n            if (done) {\n              resolve(textContent);\n              return;\n            }\n\n            Object.assign(textContent.styles, value.styles);\n\n            (_textContent$items = textContent.items).push.apply(_textContent$items, _toConsumableArray(value.items));\n\n            pump();\n          }, reject);\n        }\n\n        var reader = readableStream.getReader();\n        var textContent = {\n          items: [],\n          styles: Object.create(null)\n        };\n        pump();\n      });\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.destroyed = true;\n      this._transport.pageCache[this._pageIndex] = null;\n      var waitOn = [];\n\n      var _iterator5 = _createForOfIteratorHelper(this._intentStates),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              intent = _step5$value[0],\n              intentState = _step5$value[1];\n\n          this._abortOperatorList({\n            intentState: intentState,\n            reason: new Error(\"Page was destroyed.\"),\n            force: true\n          });\n\n          if (intent === \"oplist\") {\n            continue;\n          }\n\n          var _iterator6 = _createForOfIteratorHelper(intentState.renderTasks),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var internalRenderTask = _step6.value;\n              waitOn.push(internalRenderTask.completed);\n              internalRenderTask.cancel();\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      this.objs.clear();\n      this.annotationsPromise = null;\n      this._jsActionsPromise = null;\n      this.pendingCleanup = false;\n      return Promise.all(waitOn);\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.pendingCleanup = true;\n      return this._tryCleanup(resetStats);\n    }\n  }, {\n    key: \"_tryCleanup\",\n    value: function _tryCleanup() {\n      var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (!this.pendingCleanup) {\n        return false;\n      }\n\n      var _iterator7 = _createForOfIteratorHelper(this._intentStates.values()),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _step7.value,\n              renderTasks = _step7$value.renderTasks,\n              operatorList = _step7$value.operatorList;\n\n          if (renderTasks.length !== 0 || !operatorList.lastChunk) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      this._intentStates.clear();\n\n      this.objs.clear();\n      this.annotationsPromise = null;\n      this._jsActionsPromise = null;\n\n      if (resetStats && this._stats) {\n        this._stats = new _display_utils.StatTimer();\n      }\n\n      this.pendingCleanup = false;\n      return true;\n    }\n  }, {\n    key: \"_startRenderPage\",\n    value: function _startRenderPage(transparency, intent) {\n      var intentState = this._intentStates.get(intent);\n\n      if (!intentState) {\n        return;\n      }\n\n      if (this._stats) {\n        this._stats.timeEnd(\"Page Request\");\n      }\n\n      if (intentState.displayReadyCapability) {\n        intentState.displayReadyCapability.resolve(transparency);\n      }\n    }\n  }, {\n    key: \"_renderPageChunk\",\n    value: function _renderPageChunk(operatorListChunk, intentState) {\n      for (var i = 0, ii = operatorListChunk.length; i < ii; i++) {\n        intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n        intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n      }\n\n      intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n\n      for (var _i2 = 0; _i2 < intentState.renderTasks.length; _i2++) {\n        intentState.renderTasks[_i2].operatorListChanged();\n      }\n\n      if (operatorListChunk.lastChunk) {\n        this._tryCleanup();\n      }\n    }\n  }, {\n    key: \"_pumpOperatorList\",\n    value: function _pumpOperatorList(args) {\n      var _this6 = this;\n\n      (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected \"intent\" argument.');\n\n      var readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", args);\n\n      var reader = readableStream.getReader();\n\n      var intentState = this._intentStates.get(args.intent);\n\n      intentState.streamReader = reader;\n\n      var pump = function pump() {\n        reader.read().then(function (_ref10) {\n          var value = _ref10.value,\n              done = _ref10.done;\n\n          if (done) {\n            intentState.streamReader = null;\n            return;\n          }\n\n          if (_this6._transport.destroyed) {\n            return;\n          }\n\n          _this6._renderPageChunk(value, intentState);\n\n          pump();\n        }, function (reason) {\n          intentState.streamReader = null;\n\n          if (_this6._transport.destroyed) {\n            return;\n          }\n\n          if (intentState.operatorList) {\n            intentState.operatorList.lastChunk = true;\n\n            for (var i = 0; i < intentState.renderTasks.length; i++) {\n              intentState.renderTasks[i].operatorListChanged();\n            }\n\n            _this6._tryCleanup();\n          }\n\n          if (intentState.displayReadyCapability) {\n            intentState.displayReadyCapability.reject(reason);\n          } else if (intentState.opListReadCapability) {\n            intentState.opListReadCapability.reject(reason);\n          } else {\n            throw reason;\n          }\n        });\n      };\n\n      pump();\n    }\n  }, {\n    key: \"_abortOperatorList\",\n    value: function _abortOperatorList(_ref11) {\n      var _this7 = this;\n\n      var intentState = _ref11.intentState,\n          reason = _ref11.reason,\n          _ref11$force = _ref11.force,\n          force = _ref11$force === void 0 ? false : _ref11$force;\n      (0, _util.assert)(reason instanceof Error || _typeof(reason) === \"object\" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected \"reason\" argument.');\n\n      if (!intentState.streamReader) {\n        return;\n      }\n\n      if (!force) {\n        if (intentState.renderTasks.length !== 0) {\n          return;\n        }\n\n        if (reason instanceof _display_utils.RenderingCancelledException) {\n          intentState.streamReaderCancelTimeout = setTimeout(function () {\n            _this7._abortOperatorList({\n              intentState: intentState,\n              reason: reason,\n              force: true\n            });\n\n            intentState.streamReaderCancelTimeout = null;\n          }, RENDERING_CANCELLED_TIMEOUT);\n          return;\n        }\n      }\n\n      intentState.streamReader.cancel(new _util.AbortException(reason === null || reason === void 0 ? void 0 : reason.message));\n      intentState.streamReader = null;\n\n      if (this._transport.destroyed) {\n        return;\n      }\n\n      var _iterator8 = _createForOfIteratorHelper(this._intentStates),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _step8$value = _slicedToArray(_step8.value, 2),\n              intent = _step8$value[0],\n              curIntentState = _step8$value[1];\n\n          if (curIntentState === intentState) {\n            this._intentStates[\"delete\"](intent);\n\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      this.cleanup();\n    }\n  }, {\n    key: \"stats\",\n    get: function get() {\n      return this._stats;\n    }\n  }]);\n\n  return PDFPageProxy;\n}();\n\nexports.PDFPageProxy = PDFPageProxy;\n\nvar LoopbackPort = /*#__PURE__*/function () {\n  function LoopbackPort() {\n    var defer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    _classCallCheck(this, LoopbackPort);\n\n    this._listeners = [];\n    this._defer = defer;\n    this._deferred = Promise.resolve(undefined);\n  }\n\n  _createClass(LoopbackPort, [{\n    key: \"postMessage\",\n    value: function postMessage(obj, transfers) {\n      var _this8 = this;\n\n      function cloneValue(value) {\n        if (_typeof(value) !== \"object\" || value === null) {\n          return value;\n        }\n\n        if (cloned.has(value)) {\n          return cloned.get(value);\n        }\n\n        var buffer, result;\n\n        if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {\n          if (transfers !== null && transfers !== void 0 && transfers.includes(buffer)) {\n            result = new value.constructor(buffer, value.byteOffset, value.byteLength);\n          } else {\n            result = new value.constructor(value);\n          }\n\n          cloned.set(value, result);\n          return result;\n        }\n\n        result = Array.isArray(value) ? [] : {};\n        cloned.set(value, result);\n\n        for (var i in value) {\n          var desc = void 0,\n              p = value;\n\n          while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {\n            p = Object.getPrototypeOf(p);\n          }\n\n          if (typeof desc.value === \"undefined\") {\n            continue;\n          }\n\n          if (typeof desc.value === \"function\") {\n            if (value.hasOwnProperty && value.hasOwnProperty(i)) {\n              throw new Error(\"LoopbackPort.postMessage - cannot clone: \".concat(value[i]));\n            }\n\n            continue;\n          }\n\n          result[i] = cloneValue(desc.value);\n        }\n\n        return result;\n      }\n\n      if (!this._defer) {\n        this._listeners.forEach(function (listener) {\n          listener.call(_this8, {\n            data: obj\n          });\n        });\n\n        return;\n      }\n\n      var cloned = new WeakMap();\n      var e = {\n        data: cloneValue(obj)\n      };\n\n      this._deferred.then(function () {\n        _this8._listeners.forEach(function (listener) {\n          listener.call(_this8, e);\n        });\n      });\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(name, listener) {\n      this._listeners.push(listener);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(name, listener) {\n      var i = this._listeners.indexOf(listener);\n\n      this._listeners.splice(i, 1);\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      this._listeners.length = 0;\n    }\n  }]);\n\n  return LoopbackPort;\n}();\n\nexports.LoopbackPort = LoopbackPort;\n\nvar PDFWorker = function PDFWorkerClosure() {\n  var pdfWorkerPorts = new WeakMap();\n  var isWorkerDisabled = false;\n  var fallbackWorkerSrc;\n  var nextFakeWorkerId = 0;\n  var fakeWorkerCapability;\n\n  if (_is_node.isNodeJS && \"function\" === \"function\") {\n    isWorkerDisabled = true;\n    fallbackWorkerSrc = \"./pdf.worker.js\";\n  } else if ((typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) === \"object\" && \"currentScript\" in document) {\n    var _document$currentScri;\n\n    var pdfjsFilePath = (_document$currentScri = document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src;\n\n    if (pdfjsFilePath) {\n      fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n    }\n  }\n\n  function _getWorkerSrc() {\n    if (_worker_options.GlobalWorkerOptions.workerSrc) {\n      return _worker_options.GlobalWorkerOptions.workerSrc;\n    }\n\n    if (typeof fallbackWorkerSrc !== \"undefined\") {\n      if (!_is_node.isNodeJS) {\n        (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n      }\n\n      return fallbackWorkerSrc;\n    }\n\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n  }\n\n  function getMainThreadWorkerMessageHandler() {\n    var mainWorkerMessageHandler;\n\n    try {\n      var _globalThis$pdfjsWork;\n\n      mainWorkerMessageHandler = (_globalThis$pdfjsWork = globalThis.pdfjsWorker) === null || _globalThis$pdfjsWork === void 0 ? void 0 : _globalThis$pdfjsWork.WorkerMessageHandler;\n    } catch (ex) {}\n\n    return mainWorkerMessageHandler || null;\n  }\n\n  function setupFakeWorkerGlobal() {\n    if (fakeWorkerCapability) {\n      return fakeWorkerCapability.promise;\n    }\n\n    fakeWorkerCapability = (0, _util.createPromiseCapability)();\n\n    var loader = /*#__PURE__*/function () {\n      var _ref12 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var mainWorkerMessageHandler, worker;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();\n\n                if (!mainWorkerMessageHandler) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", mainWorkerMessageHandler);\n\n              case 3:\n                if (!(_is_node.isNodeJS && \"function\" === \"function\")) {\n                  _context.next = 6;\n                  break;\n                }\n\n                worker = eval(\"require\")(_getWorkerSrc());\n                return _context.abrupt(\"return\", worker.WorkerMessageHandler);\n\n              case 6:\n                _context.next = 8;\n                return (0, _display_utils.loadScript)(_getWorkerSrc());\n\n              case 8:\n                return _context.abrupt(\"return\", window.pdfjsWorker.WorkerMessageHandler);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function loader() {\n        return _ref12.apply(this, arguments);\n      };\n    }();\n\n    loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);\n    return fakeWorkerCapability.promise;\n  }\n\n  function createCDNWrapper(url) {\n    var wrapper = \"importScripts('\" + url + \"');\";\n    return URL.createObjectURL(new Blob([wrapper]));\n  }\n\n  var PDFWorker = /*#__PURE__*/function () {\n    function PDFWorker() {\n      var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref13$name = _ref13.name,\n          name = _ref13$name === void 0 ? null : _ref13$name,\n          _ref13$port = _ref13.port,\n          port = _ref13$port === void 0 ? null : _ref13$port,\n          _ref13$verbosity = _ref13.verbosity,\n          verbosity = _ref13$verbosity === void 0 ? (0, _util.getVerbosityLevel)() : _ref13$verbosity;\n\n      _classCallCheck(this, PDFWorker);\n\n      if (port && pdfWorkerPorts.has(port)) {\n        throw new Error(\"Cannot use more than one PDFWorker per port\");\n      }\n\n      this.name = name;\n      this.destroyed = false;\n      this.postMessageTransfers = true;\n      this.verbosity = verbosity;\n      this._readyCapability = (0, _util.createPromiseCapability)();\n      this._port = null;\n      this._webWorker = null;\n      this._messageHandler = null;\n\n      if (port) {\n        pdfWorkerPorts.set(port, this);\n\n        this._initializeFromPort(port);\n\n        return;\n      }\n\n      this._initialize();\n    }\n\n    _createClass(PDFWorker, [{\n      key: \"promise\",\n      get: function get() {\n        return this._readyCapability.promise;\n      }\n    }, {\n      key: \"port\",\n      get: function get() {\n        return this._port;\n      }\n    }, {\n      key: \"messageHandler\",\n      get: function get() {\n        return this._messageHandler;\n      }\n    }, {\n      key: \"_initializeFromPort\",\n      value: function _initializeFromPort(port) {\n        this._port = port;\n        this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n\n        this._messageHandler.on(\"ready\", function () {});\n\n        this._readyCapability.resolve();\n      }\n    }, {\n      key: \"_initialize\",\n      value: function _initialize() {\n        var _this9 = this;\n\n        if (typeof Worker !== \"undefined\" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {\n          var workerSrc = _getWorkerSrc();\n\n          try {\n            if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {\n              workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);\n            }\n\n            var worker = new Worker(workerSrc);\n            var messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n\n            var terminateEarly = function terminateEarly() {\n              worker.removeEventListener(\"error\", onWorkerError);\n              messageHandler.destroy();\n              worker.terminate();\n\n              if (_this9.destroyed) {\n                _this9._readyCapability.reject(new Error(\"Worker was destroyed\"));\n              } else {\n                _this9._setupFakeWorker();\n              }\n            };\n\n            var onWorkerError = function onWorkerError() {\n              if (!_this9._webWorker) {\n                terminateEarly();\n              }\n            };\n\n            worker.addEventListener(\"error\", onWorkerError);\n            messageHandler.on(\"test\", function (data) {\n              worker.removeEventListener(\"error\", onWorkerError);\n\n              if (_this9.destroyed) {\n                terminateEarly();\n                return;\n              }\n\n              if (data) {\n                _this9._messageHandler = messageHandler;\n                _this9._port = worker;\n                _this9._webWorker = worker;\n\n                if (!data.supportTransfers) {\n                  _this9.postMessageTransfers = false;\n                }\n\n                _this9._readyCapability.resolve();\n\n                messageHandler.send(\"configure\", {\n                  verbosity: _this9.verbosity\n                });\n              } else {\n                _this9._setupFakeWorker();\n\n                messageHandler.destroy();\n                worker.terminate();\n              }\n            });\n            messageHandler.on(\"ready\", function (data) {\n              worker.removeEventListener(\"error\", onWorkerError);\n\n              if (_this9.destroyed) {\n                terminateEarly();\n                return;\n              }\n\n              try {\n                sendTest();\n              } catch (e) {\n                _this9._setupFakeWorker();\n              }\n            });\n\n            var sendTest = function sendTest() {\n              var testObj = new Uint8Array([_this9.postMessageTransfers ? 255 : 0]);\n\n              try {\n                messageHandler.send(\"test\", testObj, [testObj.buffer]);\n              } catch (ex) {\n                (0, _util.warn)(\"Cannot use postMessage transfers.\");\n                testObj[0] = 0;\n                messageHandler.send(\"test\", testObj);\n              }\n            };\n\n            sendTest();\n            return;\n          } catch (e) {\n            (0, _util.info)(\"The worker has been disabled.\");\n          }\n        }\n\n        this._setupFakeWorker();\n      }\n    }, {\n      key: \"_setupFakeWorker\",\n      value: function _setupFakeWorker() {\n        var _this10 = this;\n\n        if (!isWorkerDisabled) {\n          (0, _util.warn)(\"Setting up fake worker.\");\n          isWorkerDisabled = true;\n        }\n\n        setupFakeWorkerGlobal().then(function (WorkerMessageHandler) {\n          if (_this10.destroyed) {\n            _this10._readyCapability.reject(new Error(\"Worker was destroyed\"));\n\n            return;\n          }\n\n          var port = new LoopbackPort();\n          _this10._port = port;\n          var id = \"fake\" + nextFakeWorkerId++;\n          var workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n          WorkerMessageHandler.setup(workerHandler, port);\n          var messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n          _this10._messageHandler = messageHandler;\n\n          _this10._readyCapability.resolve();\n\n          messageHandler.send(\"configure\", {\n            verbosity: _this10.verbosity\n          });\n        })[\"catch\"](function (reason) {\n          _this10._readyCapability.reject(new Error(\"Setting up fake worker failed: \\\"\".concat(reason.message, \"\\\".\")));\n        });\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.destroyed = true;\n\n        if (this._webWorker) {\n          this._webWorker.terminate();\n\n          this._webWorker = null;\n        }\n\n        pdfWorkerPorts[\"delete\"](this._port);\n        this._port = null;\n\n        if (this._messageHandler) {\n          this._messageHandler.destroy();\n\n          this._messageHandler = null;\n        }\n      }\n    }], [{\n      key: \"fromPort\",\n      value: function fromPort(params) {\n        if (!params || !params.port) {\n          throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n        }\n\n        if (pdfWorkerPorts.has(params.port)) {\n          return pdfWorkerPorts.get(params.port);\n        }\n\n        return new PDFWorker(params);\n      }\n    }, {\n      key: \"getWorkerSrc\",\n      value: function getWorkerSrc() {\n        return _getWorkerSrc();\n      }\n    }]);\n\n    return PDFWorker;\n  }();\n\n  return PDFWorker;\n}();\n\nexports.PDFWorker = PDFWorker;\n\nvar WorkerTransport = /*#__PURE__*/function () {\n  function WorkerTransport(messageHandler, loadingTask, networkStream, params) {\n    _classCallCheck(this, WorkerTransport);\n\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new _font_loader.FontLoader({\n      docId: loadingTask.docId,\n      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n      ownerDocument: params.ownerDocument\n    });\n    this._params = params;\n    this.CMapReaderFactory = new params.CMapReaderFactory({\n      baseUrl: params.cMapUrl,\n      isCompressed: params.cMapPacked\n    });\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._passwordCapability = null;\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.pageCache = [];\n    this.pagePromises = [];\n    this.downloadInfoCapability = (0, _util.createPromiseCapability)();\n    this.setupMessageHandler();\n  }\n\n  _createClass(WorkerTransport, [{\n    key: \"loadingTaskSettled\",\n    get: function get() {\n      return this.loadingTask._capability.settled;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this11 = this;\n\n      if (this.destroyCapability) {\n        return this.destroyCapability.promise;\n      }\n\n      this.destroyed = true;\n      this.destroyCapability = (0, _util.createPromiseCapability)();\n\n      if (this._passwordCapability) {\n        this._passwordCapability.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n      }\n\n      var waitOn = [];\n      this.pageCache.forEach(function (page) {\n        if (page) {\n          waitOn.push(page._destroy());\n        }\n      });\n      this.pageCache.length = 0;\n      this.pagePromises.length = 0;\n      var terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n      waitOn.push(terminated);\n\n      if (this.loadingTaskSettled) {\n        var annotationStorageResetModified = this.loadingTask.promise.then(function (pdfDocument) {\n          if (pdfDocument.hasOwnProperty(\"annotationStorage\")) {\n            pdfDocument.annotationStorage.resetModified();\n          }\n        })[\"catch\"](function () {});\n        waitOn.push(annotationStorageResetModified);\n      }\n\n      Promise.all(waitOn).then(function () {\n        _this11.commonObjs.clear();\n\n        _this11.fontLoader.clear();\n\n        _this11._hasJSActionsPromise = null;\n\n        if (_this11._networkStream) {\n          _this11._networkStream.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n        }\n\n        if (_this11.messageHandler) {\n          _this11.messageHandler.destroy();\n\n          _this11.messageHandler = null;\n        }\n\n        _this11.destroyCapability.resolve();\n      }, this.destroyCapability.reject);\n      return this.destroyCapability.promise;\n    }\n  }, {\n    key: \"setupMessageHandler\",\n    value: function setupMessageHandler() {\n      var _this12 = this;\n\n      var messageHandler = this.messageHandler,\n          loadingTask = this.loadingTask;\n      messageHandler.on(\"GetReader\", function (data, sink) {\n        (0, _util.assert)(_this12._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n        _this12._fullReader = _this12._networkStream.getFullReader();\n\n        _this12._fullReader.onProgress = function (evt) {\n          _this12._lastProgress = {\n            loaded: evt.loaded,\n            total: evt.total\n          };\n        };\n\n        sink.onPull = function () {\n          _this12._fullReader.read().then(function (_ref14) {\n            var value = _ref14.value,\n                done = _ref14.done;\n\n            if (done) {\n              sink.close();\n              return;\n            }\n\n            (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetReader - expected an ArrayBuffer.\");\n            sink.enqueue(new Uint8Array(value), 1, [value]);\n          })[\"catch\"](function (reason) {\n            sink.error(reason);\n          });\n        };\n\n        sink.onCancel = function (reason) {\n          _this12._fullReader.cancel(reason);\n\n          sink.ready[\"catch\"](function (readyReason) {\n            if (_this12.destroyed) {\n              return;\n            }\n\n            throw readyReason;\n          });\n        };\n      });\n      messageHandler.on(\"ReaderHeadersReady\", function (data) {\n        var headersCapability = (0, _util.createPromiseCapability)();\n        var fullReader = _this12._fullReader;\n        fullReader.headersReady.then(function () {\n          if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n            if (_this12._lastProgress && loadingTask.onProgress) {\n              loadingTask.onProgress(_this12._lastProgress);\n            }\n\n            fullReader.onProgress = function (evt) {\n              if (loadingTask.onProgress) {\n                loadingTask.onProgress({\n                  loaded: evt.loaded,\n                  total: evt.total\n                });\n              }\n            };\n          }\n\n          headersCapability.resolve({\n            isStreamingSupported: fullReader.isStreamingSupported,\n            isRangeSupported: fullReader.isRangeSupported,\n            contentLength: fullReader.contentLength\n          });\n        }, headersCapability.reject);\n        return headersCapability.promise;\n      });\n      messageHandler.on(\"GetRangeReader\", function (data, sink) {\n        (0, _util.assert)(_this12._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n\n        var rangeReader = _this12._networkStream.getRangeReader(data.begin, data.end);\n\n        if (!rangeReader) {\n          sink.close();\n          return;\n        }\n\n        sink.onPull = function () {\n          rangeReader.read().then(function (_ref15) {\n            var value = _ref15.value,\n                done = _ref15.done;\n\n            if (done) {\n              sink.close();\n              return;\n            }\n\n            (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetRangeReader - expected an ArrayBuffer.\");\n            sink.enqueue(new Uint8Array(value), 1, [value]);\n          })[\"catch\"](function (reason) {\n            sink.error(reason);\n          });\n        };\n\n        sink.onCancel = function (reason) {\n          rangeReader.cancel(reason);\n          sink.ready[\"catch\"](function (readyReason) {\n            if (_this12.destroyed) {\n              return;\n            }\n\n            throw readyReason;\n          });\n        };\n      });\n      messageHandler.on(\"GetDoc\", function (_ref16) {\n        var pdfInfo = _ref16.pdfInfo;\n        _this12._numPages = pdfInfo.numPages;\n\n        loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, _this12));\n      });\n      messageHandler.on(\"DocException\", function (ex) {\n        var reason;\n\n        switch (ex.name) {\n          case \"PasswordException\":\n            reason = new _util.PasswordException(ex.message, ex.code);\n            break;\n\n          case \"InvalidPDFException\":\n            reason = new _util.InvalidPDFException(ex.message);\n            break;\n\n          case \"MissingPDFException\":\n            reason = new _util.MissingPDFException(ex.message);\n            break;\n\n          case \"UnexpectedResponseException\":\n            reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n            break;\n\n          case \"UnknownErrorException\":\n            reason = new _util.UnknownErrorException(ex.message, ex.details);\n            break;\n        }\n\n        if (!(reason instanceof Error)) {\n          var msg = \"DocException - expected a valid Error.\";\n          (0, _util.warn)(msg);\n        }\n\n        loadingTask._capability.reject(reason);\n      });\n      messageHandler.on(\"PasswordRequest\", function (exception) {\n        _this12._passwordCapability = (0, _util.createPromiseCapability)();\n\n        if (loadingTask.onPassword) {\n          var updatePassword = function updatePassword(password) {\n            _this12._passwordCapability.resolve({\n              password: password\n            });\n          };\n\n          try {\n            loadingTask.onPassword(updatePassword, exception.code);\n          } catch (ex) {\n            _this12._passwordCapability.reject(ex);\n          }\n        } else {\n          _this12._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n        }\n\n        return _this12._passwordCapability.promise;\n      });\n      messageHandler.on(\"DataLoaded\", function (data) {\n        if (loadingTask.onProgress) {\n          loadingTask.onProgress({\n            loaded: data.length,\n            total: data.length\n          });\n        }\n\n        _this12.downloadInfoCapability.resolve(data);\n      });\n      messageHandler.on(\"StartRenderPage\", function (data) {\n        if (_this12.destroyed) {\n          return;\n        }\n\n        var page = _this12.pageCache[data.pageIndex];\n\n        page._startRenderPage(data.transparency, data.intent);\n      });\n      messageHandler.on(\"commonobj\", function (data) {\n        var _globalThis$FontInspe;\n\n        if (_this12.destroyed) {\n          return;\n        }\n\n        var _data = _slicedToArray(data, 3),\n            id = _data[0],\n            type = _data[1],\n            exportedData = _data[2];\n\n        if (_this12.commonObjs.has(id)) {\n          return;\n        }\n\n        switch (type) {\n          case \"Font\":\n            var params = _this12._params;\n\n            if (\"error\" in exportedData) {\n              var exportedError = exportedData.error;\n              (0, _util.warn)(\"Error during font loading: \".concat(exportedError));\n\n              _this12.commonObjs.resolve(id, exportedError);\n\n              break;\n            }\n\n            var fontRegistry = null;\n\n            if (params.pdfBug && (_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled) {\n              fontRegistry = {\n                registerFont: function registerFont(font, url) {\n                  globalThis.FontInspector.fontAdded(font, url);\n                }\n              };\n            }\n\n            var font = new _font_loader.FontFaceObject(exportedData, {\n              isEvalSupported: params.isEvalSupported,\n              disableFontFace: params.disableFontFace,\n              ignoreErrors: params.ignoreErrors,\n              onUnsupportedFeature: _this12._onUnsupportedFeature.bind(_this12),\n              fontRegistry: fontRegistry\n            });\n\n            _this12.fontLoader.bind(font)[\"catch\"](function (reason) {\n              return messageHandler.sendWithPromise(\"FontFallback\", {\n                id: id\n              });\n            })[\"finally\"](function () {\n              if (!params.fontExtraProperties && font.data) {\n                font.data = null;\n              }\n\n              _this12.commonObjs.resolve(id, font);\n            });\n\n            break;\n\n          case \"FontPath\":\n          case \"Image\":\n            _this12.commonObjs.resolve(id, exportedData);\n\n            break;\n\n          default:\n            throw new Error(\"Got unknown common object type \".concat(type));\n        }\n      });\n      messageHandler.on(\"obj\", function (data) {\n        var _imageData$data;\n\n        if (_this12.destroyed) {\n          return undefined;\n        }\n\n        var _data2 = _slicedToArray(data, 4),\n            id = _data2[0],\n            pageIndex = _data2[1],\n            type = _data2[2],\n            imageData = _data2[3];\n\n        var pageProxy = _this12.pageCache[pageIndex];\n\n        if (pageProxy.objs.has(id)) {\n          return undefined;\n        }\n\n        switch (type) {\n          case \"Image\":\n            pageProxy.objs.resolve(id, imageData);\n            var MAX_IMAGE_SIZE_TO_STORE = 8000000;\n\n            if ((imageData === null || imageData === void 0 ? void 0 : (_imageData$data = imageData.data) === null || _imageData$data === void 0 ? void 0 : _imageData$data.length) > MAX_IMAGE_SIZE_TO_STORE) {\n              pageProxy.cleanupAfterRender = true;\n            }\n\n            break;\n\n          default:\n            throw new Error(\"Got unknown object type \".concat(type));\n        }\n\n        return undefined;\n      });\n      messageHandler.on(\"DocProgress\", function (data) {\n        if (_this12.destroyed) {\n          return;\n        }\n\n        if (loadingTask.onProgress) {\n          loadingTask.onProgress({\n            loaded: data.loaded,\n            total: data.total\n          });\n        }\n      });\n      messageHandler.on(\"UnsupportedFeature\", this._onUnsupportedFeature.bind(this));\n      messageHandler.on(\"FetchBuiltInCMap\", function (data, sink) {\n        if (_this12.destroyed) {\n          sink.error(new Error(\"Worker was destroyed\"));\n          return;\n        }\n\n        var fetched = false;\n\n        sink.onPull = function () {\n          if (fetched) {\n            sink.close();\n            return;\n          }\n\n          fetched = true;\n\n          _this12.CMapReaderFactory.fetch(data).then(function (builtInCMap) {\n            sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);\n          })[\"catch\"](function (reason) {\n            sink.error(reason);\n          });\n        };\n      });\n    }\n  }, {\n    key: \"_onUnsupportedFeature\",\n    value: function _onUnsupportedFeature(_ref17) {\n      var featureId = _ref17.featureId;\n\n      if (this.destroyed) {\n        return;\n      }\n\n      if (this.loadingTask.onUnsupportedFeature) {\n        this.loadingTask.onUnsupportedFeature(featureId);\n      }\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.messageHandler.sendWithPromise(\"GetData\", null);\n    }\n  }, {\n    key: \"getPage\",\n    value: function getPage(pageNumber) {\n      var _this13 = this;\n\n      if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n        return Promise.reject(new Error(\"Invalid page request\"));\n      }\n\n      var pageIndex = pageNumber - 1;\n\n      if (pageIndex in this.pagePromises) {\n        return this.pagePromises[pageIndex];\n      }\n\n      var promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n        pageIndex: pageIndex\n      }).then(function (pageInfo) {\n        if (_this13.destroyed) {\n          throw new Error(\"Transport destroyed\");\n        }\n\n        var page = new PDFPageProxy(pageIndex, pageInfo, _this13, _this13._params.ownerDocument, _this13._params.pdfBug);\n        _this13.pageCache[pageIndex] = page;\n        return page;\n      });\n      this.pagePromises[pageIndex] = promise;\n      return promise;\n    }\n  }, {\n    key: \"getPageIndex\",\n    value: function getPageIndex(ref) {\n      return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n        ref: ref\n      })[\"catch\"](function (reason) {\n        return Promise.reject(new Error(reason));\n      });\n    }\n  }, {\n    key: \"getPageOCGNames\",\n    value: function getPageOCGNames(ref) {\n      return this.messageHandler.sendWithPromise(\"GetPageOCGNames\", {\n        ref: ref\n      })[\"catch\"](function (reason) {\n        return Promise.reject(new Error(reason));\n      });\n    }\n  }, {\n    key: \"getObject\",\n    value: function getObject(ref) {\n      return this.messageHandler.sendWithPromise(\"GetObject\", {\n        ref: ref\n      })[\"catch\"](function (reason) {\n        return Promise.reject(new Error(reason));\n      });\n    }\n  }, {\n    key: \"getAnnotations\",\n    value: function getAnnotations(pageIndex, intent) {\n      return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n        pageIndex: pageIndex,\n        intent: intent\n      });\n    }\n  }, {\n    key: \"saveDocument\",\n    value: function saveDocument(annotationStorage) {\n      var _this$_fullReader$fil, _this$_fullReader;\n\n      return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n        numPages: this._numPages,\n        annotationStorage: (annotationStorage === null || annotationStorage === void 0 ? void 0 : annotationStorage.getAll()) || null,\n        filename: (_this$_fullReader$fil = (_this$_fullReader = this._fullReader) === null || _this$_fullReader === void 0 ? void 0 : _this$_fullReader.filename) !== null && _this$_fullReader$fil !== void 0 ? _this$_fullReader$fil : null\n      })[\"finally\"](function () {\n        if (annotationStorage) {\n          annotationStorage.resetModified();\n        }\n      });\n    }\n  }, {\n    key: \"getFieldObjects\",\n    value: function getFieldObjects() {\n      return this.messageHandler.sendWithPromise(\"GetFieldObjects\", null);\n    }\n  }, {\n    key: \"hasJSActions\",\n    value: function hasJSActions() {\n      return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise(\"HasJSActions\", null));\n    }\n  }, {\n    key: \"getCalculationOrderIds\",\n    value: function getCalculationOrderIds() {\n      return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n    }\n  }, {\n    key: \"getDestinations\",\n    value: function getDestinations() {\n      return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n    }\n  }, {\n    key: \"getDestination\",\n    value: function getDestination(id) {\n      if (typeof id !== \"string\") {\n        return Promise.reject(new Error(\"Invalid destination request.\"));\n      }\n\n      return this.messageHandler.sendWithPromise(\"GetDestination\", {\n        id: id\n      });\n    }\n  }, {\n    key: \"getPageLabels\",\n    value: function getPageLabels() {\n      return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n    }\n  }, {\n    key: \"getPageLayout\",\n    value: function getPageLayout() {\n      return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n    }\n  }, {\n    key: \"getPageMode\",\n    value: function getPageMode() {\n      return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n    }\n  }, {\n    key: \"getViewerPreferences\",\n    value: function getViewerPreferences() {\n      return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n    }\n  }, {\n    key: \"getOpenAction\",\n    value: function getOpenAction() {\n      return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n    }\n  }, {\n    key: \"getAttachments\",\n    value: function getAttachments() {\n      return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n    }\n  }, {\n    key: \"getJavaScript\",\n    value: function getJavaScript() {\n      return this.messageHandler.sendWithPromise(\"GetJavaScript\", null);\n    }\n  }, {\n    key: \"getDocJSActions\",\n    value: function getDocJSActions() {\n      return this.messageHandler.sendWithPromise(\"GetDocJSActions\", null);\n    }\n  }, {\n    key: \"getPageJSActions\",\n    value: function getPageJSActions(pageIndex) {\n      return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n        pageIndex: pageIndex\n      });\n    }\n  }, {\n    key: \"getOutline\",\n    value: function getOutline() {\n      return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n    }\n  }, {\n    key: \"getOptionalContentConfig\",\n    value: function getOptionalContentConfig() {\n      return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(function (results) {\n        return new _optional_content_config.OptionalContentConfig(results);\n      });\n    }\n  }, {\n    key: \"getPermissions\",\n    value: function getPermissions() {\n      return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n    }\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata() {\n      var _this14 = this;\n\n      return this.messageHandler.sendWithPromise(\"GetMetadata\", null).then(function (results) {\n        var _this14$_fullReader$f, _this14$_fullReader, _this14$_fullReader$c, _this14$_fullReader2;\n\n        return {\n          info: results[0],\n          metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n          contentDispositionFilename: (_this14$_fullReader$f = (_this14$_fullReader = _this14._fullReader) === null || _this14$_fullReader === void 0 ? void 0 : _this14$_fullReader.filename) !== null && _this14$_fullReader$f !== void 0 ? _this14$_fullReader$f : null,\n          contentLength: (_this14$_fullReader$c = (_this14$_fullReader2 = _this14._fullReader) === null || _this14$_fullReader2 === void 0 ? void 0 : _this14$_fullReader2.contentLength) !== null && _this14$_fullReader$c !== void 0 ? _this14$_fullReader$c : null\n        };\n      });\n    }\n  }, {\n    key: \"getMarkInfo\",\n    value: function getMarkInfo() {\n      return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n    }\n  }, {\n    key: \"getStats\",\n    value: function getStats() {\n      return this.messageHandler.sendWithPromise(\"GetStats\", null);\n    }\n  }, {\n    key: \"startCleanup\",\n    value: function startCleanup() {\n      var _this15 = this;\n\n      return this.messageHandler.sendWithPromise(\"Cleanup\", null).then(function () {\n        for (var i = 0, ii = _this15.pageCache.length; i < ii; i++) {\n          var page = _this15.pageCache[i];\n\n          if (page) {\n            var cleanupSuccessful = page.cleanup();\n\n            if (!cleanupSuccessful) {\n              throw new Error(\"startCleanup: Page \".concat(i + 1, \" is currently rendering.\"));\n            }\n          }\n        }\n\n        _this15.commonObjs.clear();\n\n        _this15.fontLoader.clear();\n\n        _this15._hasJSActionsPromise = null;\n      });\n    }\n  }, {\n    key: \"loadingParams\",\n    get: function get() {\n      var params = this._params;\n      return (0, _util.shadow)(this, \"loadingParams\", {\n        disableAutoFetch: params.disableAutoFetch,\n        disableFontFace: params.disableFontFace\n      });\n    }\n  }]);\n\n  return WorkerTransport;\n}();\n\nvar PDFObjects = /*#__PURE__*/function () {\n  function PDFObjects() {\n    _classCallCheck(this, PDFObjects);\n\n    this._objs = Object.create(null);\n  }\n\n  _createClass(PDFObjects, [{\n    key: \"_ensureObj\",\n    value: function _ensureObj(objId) {\n      if (this._objs[objId]) {\n        return this._objs[objId];\n      }\n\n      return this._objs[objId] = {\n        capability: (0, _util.createPromiseCapability)(),\n        data: null,\n        resolved: false\n      };\n    }\n  }, {\n    key: \"get\",\n    value: function get(objId) {\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (callback) {\n        this._ensureObj(objId).capability.promise.then(callback);\n\n        return null;\n      }\n\n      var obj = this._objs[objId];\n\n      if (!obj || !obj.resolved) {\n        throw new Error(\"Requesting object that isn't resolved yet \".concat(objId, \".\"));\n      }\n\n      return obj.data;\n    }\n  }, {\n    key: \"has\",\n    value: function has(objId) {\n      var obj = this._objs[objId];\n      return (obj === null || obj === void 0 ? void 0 : obj.resolved) || false;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(objId, data) {\n      var obj = this._ensureObj(objId);\n\n      obj.resolved = true;\n      obj.data = data;\n      obj.capability.resolve(data);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._objs = Object.create(null);\n    }\n  }]);\n\n  return PDFObjects;\n}();\n\nvar RenderTask = /*#__PURE__*/function () {\n  function RenderTask(internalRenderTask) {\n    _classCallCheck(this, RenderTask);\n\n    this._internalRenderTask = internalRenderTask;\n    this.onContinue = null;\n  }\n\n  _createClass(RenderTask, [{\n    key: \"promise\",\n    get: function get() {\n      return this._internalRenderTask.capability.promise;\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this._internalRenderTask.cancel();\n    }\n  }]);\n\n  return RenderTask;\n}();\n\nvar InternalRenderTask = function InternalRenderTaskClosure() {\n  var canvasInRendering = new WeakSet();\n\n  var InternalRenderTask = /*#__PURE__*/function () {\n    function InternalRenderTask(_ref18) {\n      var callback = _ref18.callback,\n          params = _ref18.params,\n          objs = _ref18.objs,\n          commonObjs = _ref18.commonObjs,\n          operatorList = _ref18.operatorList,\n          pageIndex = _ref18.pageIndex,\n          canvasFactory = _ref18.canvasFactory,\n          webGLContext = _ref18.webGLContext,\n          _ref18$useRequestAnim = _ref18.useRequestAnimationFrame,\n          useRequestAnimationFrame = _ref18$useRequestAnim === void 0 ? false : _ref18$useRequestAnim,\n          _ref18$pdfBug = _ref18.pdfBug,\n          pdfBug = _ref18$pdfBug === void 0 ? false : _ref18$pdfBug;\n\n      _classCallCheck(this, InternalRenderTask);\n\n      this.callback = callback;\n      this.params = params;\n      this.objs = objs;\n      this.commonObjs = commonObjs;\n      this.operatorListIdx = null;\n      this.operatorList = operatorList;\n      this._pageIndex = pageIndex;\n      this.canvasFactory = canvasFactory;\n      this.webGLContext = webGLContext;\n      this._pdfBug = pdfBug;\n      this.running = false;\n      this.graphicsReadyCallback = null;\n      this.graphicsReady = false;\n      this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n      this.cancelled = false;\n      this.capability = (0, _util.createPromiseCapability)();\n      this.task = new RenderTask(this);\n      this._continueBound = this._continue.bind(this);\n      this._scheduleNextBound = this._scheduleNext.bind(this);\n      this._nextBound = this._next.bind(this);\n      this._canvas = params.canvasContext.canvas;\n    }\n\n    _createClass(InternalRenderTask, [{\n      key: \"completed\",\n      get: function get() {\n        return this.capability.promise[\"catch\"](function () {});\n      }\n    }, {\n      key: \"initializeGraphics\",\n      value: function initializeGraphics(_ref19) {\n        var _globalThis$StepperMa;\n\n        var _ref19$transparency = _ref19.transparency,\n            transparency = _ref19$transparency === void 0 ? false : _ref19$transparency,\n            optionalContentConfig = _ref19.optionalContentConfig;\n\n        if (this.cancelled) {\n          return;\n        }\n\n        if (this._canvas) {\n          if (canvasInRendering.has(this._canvas)) {\n            throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n          }\n\n          canvasInRendering.add(this._canvas);\n        }\n\n        if (this._pdfBug && (_globalThis$StepperMa = globalThis.StepperManager) !== null && _globalThis$StepperMa !== void 0 && _globalThis$StepperMa.enabled) {\n          this.stepper = globalThis.StepperManager.create(this._pageIndex);\n          this.stepper.init(this.operatorList);\n          this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n        }\n\n        var _this$params = this.params,\n            canvasContext = _this$params.canvasContext,\n            viewport = _this$params.viewport,\n            transform = _this$params.transform,\n            imageLayer = _this$params.imageLayer,\n            background = _this$params.background;\n        this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer, optionalContentConfig);\n        this.gfx.beginDrawing({\n          transform: transform,\n          viewport: viewport,\n          transparency: transparency,\n          background: background\n        });\n        this.operatorListIdx = 0;\n        this.graphicsReady = true;\n\n        if (this.graphicsReadyCallback) {\n          this.graphicsReadyCallback();\n        }\n      }\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        this.running = false;\n        this.cancelled = true;\n\n        if (this.gfx) {\n          this.gfx.endDrawing();\n        }\n\n        if (this._canvas) {\n          canvasInRendering[\"delete\"](this._canvas);\n        }\n\n        this.callback(error || new _display_utils.RenderingCancelledException(\"Rendering cancelled, page \".concat(this._pageIndex + 1), \"canvas\"));\n      }\n    }, {\n      key: \"operatorListChanged\",\n      value: function operatorListChanged() {\n        if (!this.graphicsReady) {\n          if (!this.graphicsReadyCallback) {\n            this.graphicsReadyCallback = this._continueBound;\n          }\n\n          return;\n        }\n\n        if (this.stepper) {\n          this.stepper.updateOperatorList(this.operatorList);\n        }\n\n        if (this.running) {\n          return;\n        }\n\n        this._continue();\n      }\n    }, {\n      key: \"_continue\",\n      value: function _continue() {\n        this.running = true;\n\n        if (this.cancelled) {\n          return;\n        }\n\n        if (this.task.onContinue) {\n          this.task.onContinue(this._scheduleNextBound);\n        } else {\n          this._scheduleNext();\n        }\n      }\n    }, {\n      key: \"_scheduleNext\",\n      value: function _scheduleNext() {\n        var _this16 = this;\n\n        if (this._useRequestAnimationFrame) {\n          window.requestAnimationFrame(function () {\n            _this16._nextBound()[\"catch\"](_this16.cancel.bind(_this16));\n          });\n        } else {\n          Promise.resolve().then(this._nextBound)[\"catch\"](this.cancel.bind(this));\n        }\n      }\n    }, {\n      key: \"_next\",\n      value: function () {\n        var _next2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n          return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!this.cancelled) {\n                    _context2.next = 2;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 2:\n                  this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n\n                  if (this.operatorListIdx === this.operatorList.argsArray.length) {\n                    this.running = false;\n\n                    if (this.operatorList.lastChunk) {\n                      this.gfx.endDrawing();\n\n                      if (this._canvas) {\n                        canvasInRendering[\"delete\"](this._canvas);\n                      }\n\n                      this.callback();\n                    }\n                  }\n\n                case 4:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function _next() {\n          return _next2.apply(this, arguments);\n        }\n\n        return _next;\n      }()\n    }]);\n\n    return InternalRenderTask;\n  }();\n\n  return InternalRenderTask;\n}();\n\nvar version = '2.8.173';\nexports.version = version;\nvar build = 'bc834d510';\nexports.build = build;\nvar putBinaryImageData = _canvas.CanvasGraphics.putBinaryImageData;\nexports.putBinaryImageData = putBinaryImageData;\n\n/***/ }),\n/* 136 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FontLoader = exports.FontFaceObject = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar BaseFontLoader = /*#__PURE__*/function () {\n  function BaseFontLoader(_ref) {\n    var docId = _ref.docId,\n        onUnsupportedFeature = _ref.onUnsupportedFeature,\n        _ref$ownerDocument = _ref.ownerDocument,\n        ownerDocument = _ref$ownerDocument === void 0 ? globalThis.document : _ref$ownerDocument;\n\n    _classCallCheck(this, BaseFontLoader);\n\n    if (this.constructor === BaseFontLoader) {\n      (0, _util.unreachable)(\"Cannot initialize BaseFontLoader.\");\n    }\n\n    this.docId = docId;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this._document = ownerDocument;\n    this.nativeFontFaces = [];\n    this.styleElement = null;\n  }\n\n  _createClass(BaseFontLoader, [{\n    key: \"addNativeFontFace\",\n    value: function addNativeFontFace(nativeFontFace) {\n      this.nativeFontFaces.push(nativeFontFace);\n\n      this._document.fonts.add(nativeFontFace);\n    }\n  }, {\n    key: \"insertRule\",\n    value: function insertRule(rule) {\n      var styleElement = this.styleElement;\n\n      if (!styleElement) {\n        styleElement = this.styleElement = this._document.createElement(\"style\");\n        styleElement.id = \"PDFJS_FONT_STYLE_TAG_\".concat(this.docId);\n\n        this._document.documentElement.getElementsByTagName(\"head\")[0].appendChild(styleElement);\n      }\n\n      var styleSheet = styleElement.sheet;\n      styleSheet.insertRule(rule, styleSheet.cssRules.length);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this = this;\n\n      this.nativeFontFaces.forEach(function (nativeFontFace) {\n        _this._document.fonts[\"delete\"](nativeFontFace);\n      });\n      this.nativeFontFaces.length = 0;\n\n      if (this.styleElement) {\n        this.styleElement.remove();\n        this.styleElement = null;\n      }\n    }\n  }, {\n    key: \"bind\",\n    value: function () {\n      var _bind = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(font) {\n        var _this2 = this;\n\n        var nativeFontFace, rule;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(font.attached || font.missingFile)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                font.attached = true;\n\n                if (!this.isFontLoadingAPISupported) {\n                  _context.next = 19;\n                  break;\n                }\n\n                nativeFontFace = font.createNativeFontFace();\n\n                if (!nativeFontFace) {\n                  _context.next = 18;\n                  break;\n                }\n\n                this.addNativeFontFace(nativeFontFace);\n                _context.prev = 7;\n                _context.next = 10;\n                return nativeFontFace.loaded;\n\n              case 10:\n                _context.next = 18;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](7);\n\n                this._onUnsupportedFeature({\n                  featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative\n                });\n\n                (0, _util.warn)(\"Failed to load font '\".concat(nativeFontFace.family, \"': '\").concat(_context.t0, \"'.\"));\n                font.disableFontFace = true;\n                throw _context.t0;\n\n              case 18:\n                return _context.abrupt(\"return\");\n\n              case 19:\n                rule = font.createFontFaceRule();\n\n                if (!rule) {\n                  _context.next = 26;\n                  break;\n                }\n\n                this.insertRule(rule);\n\n                if (!this.isSyncFontLoadingSupported) {\n                  _context.next = 24;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 24:\n                _context.next = 26;\n                return new Promise(function (resolve) {\n                  var request = _this2._queueLoadingCallback(resolve);\n\n                  _this2._prepareFontLoadEvent([rule], [font], request);\n                });\n\n              case 26:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 12]]);\n      }));\n\n      function bind(_x) {\n        return _bind.apply(this, arguments);\n      }\n\n      return bind;\n    }()\n  }, {\n    key: \"_queueLoadingCallback\",\n    value: function _queueLoadingCallback(callback) {\n      (0, _util.unreachable)(\"Abstract method `_queueLoadingCallback`.\");\n    }\n  }, {\n    key: \"isFontLoadingAPISupported\",\n    get: function get() {\n      var _this$_document;\n\n      return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", !!((_this$_document = this._document) !== null && _this$_document !== void 0 && _this$_document.fonts));\n    }\n  }, {\n    key: \"isSyncFontLoadingSupported\",\n    get: function get() {\n      (0, _util.unreachable)(\"Abstract method `isSyncFontLoadingSupported`.\");\n    }\n  }, {\n    key: \"_loadTestFont\",\n    get: function get() {\n      (0, _util.unreachable)(\"Abstract method `_loadTestFont`.\");\n    }\n  }, {\n    key: \"_prepareFontLoadEvent\",\n    value: function _prepareFontLoadEvent(rules, fontsToLoad, request) {\n      (0, _util.unreachable)(\"Abstract method `_prepareFontLoadEvent`.\");\n    }\n  }]);\n\n  return BaseFontLoader;\n}();\n\nvar FontLoader;\nexports.FontLoader = FontLoader;\n{\n  exports.FontLoader = FontLoader = /*#__PURE__*/function (_BaseFontLoader) {\n    _inherits(GenericFontLoader, _BaseFontLoader);\n\n    var _super = _createSuper(GenericFontLoader);\n\n    function GenericFontLoader(params) {\n      var _this3;\n\n      _classCallCheck(this, GenericFontLoader);\n\n      _this3 = _super.call(this, params);\n      _this3.loadingContext = {\n        requests: [],\n        nextRequestId: 0\n      };\n      _this3.loadTestFontId = 0;\n      return _this3;\n    }\n\n    _createClass(GenericFontLoader, [{\n      key: \"isSyncFontLoadingSupported\",\n      get: function get() {\n        var supported = false;\n\n        if (typeof navigator === \"undefined\") {\n          supported = true;\n        } else {\n          var m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent);\n\n          if ((m === null || m === void 0 ? void 0 : m[1]) >= 14) {\n            supported = true;\n          }\n        }\n\n        return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n      }\n    }, {\n      key: \"_queueLoadingCallback\",\n      value: function _queueLoadingCallback(callback) {\n        function completeRequest() {\n          (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n          request.done = true;\n\n          while (context.requests.length > 0 && context.requests[0].done) {\n            var otherRequest = context.requests.shift();\n            setTimeout(otherRequest.callback, 0);\n          }\n        }\n\n        var context = this.loadingContext;\n        var request = {\n          id: \"pdfjs-font-loading-\".concat(context.nextRequestId++),\n          done: false,\n          complete: completeRequest,\n          callback: callback\n        };\n        context.requests.push(request);\n        return request;\n      }\n    }, {\n      key: \"_loadTestFont\",\n      get: function get() {\n        var getLoadTestFont = function getLoadTestFont() {\n          return atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n        };\n\n        return (0, _util.shadow)(this, \"_loadTestFont\", getLoadTestFont());\n      }\n    }, {\n      key: \"_prepareFontLoadEvent\",\n      value: function _prepareFontLoadEvent(rules, fonts, request) {\n        var _this4 = this;\n\n        function int32(data, offset) {\n          return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n        }\n\n        function spliceString(s, offset, remove, insert) {\n          var chunk1 = s.substring(0, offset);\n          var chunk2 = s.substring(offset + remove);\n          return chunk1 + insert + chunk2;\n        }\n\n        var i, ii;\n\n        var canvas = this._document.createElement(\"canvas\");\n\n        canvas.width = 1;\n        canvas.height = 1;\n        var ctx = canvas.getContext(\"2d\");\n        var called = 0;\n\n        function isFontReady(name, callback) {\n          called++;\n\n          if (called > 30) {\n            (0, _util.warn)(\"Load test font never loaded.\");\n            callback();\n            return;\n          }\n\n          ctx.font = \"30px \" + name;\n          ctx.fillText(\".\", 0, 20);\n          var imageData = ctx.getImageData(0, 0, 1, 1);\n\n          if (imageData.data[3] > 0) {\n            callback();\n            return;\n          }\n\n          setTimeout(isFontReady.bind(null, name, callback));\n        }\n\n        var loadTestFontId = \"lt\".concat(Date.now()).concat(this.loadTestFontId++);\n        var data = this._loadTestFont;\n        var COMMENT_OFFSET = 976;\n        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n        var CFF_CHECKSUM_OFFSET = 16;\n        var XXXX_VALUE = 0x58585858;\n        var checksum = int32(data, CFF_CHECKSUM_OFFSET);\n\n        for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n          checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n        }\n\n        if (i < loadTestFontId.length) {\n          checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n        }\n\n        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n        var url = \"url(data:font/opentype;base64,\".concat(btoa(data), \");\");\n        var rule = \"@font-face {font-family:\\\"\".concat(loadTestFontId, \"\\\";src:\").concat(url, \"}\");\n        this.insertRule(rule);\n        var names = [];\n\n        for (i = 0, ii = fonts.length; i < ii; i++) {\n          names.push(fonts[i].loadedName);\n        }\n\n        names.push(loadTestFontId);\n\n        var div = this._document.createElement(\"div\");\n\n        div.style.visibility = \"hidden\";\n        div.style.width = div.style.height = \"10px\";\n        div.style.position = \"absolute\";\n        div.style.top = div.style.left = \"0px\";\n\n        for (i = 0, ii = names.length; i < ii; ++i) {\n          var span = this._document.createElement(\"span\");\n\n          span.textContent = \"Hi\";\n          span.style.fontFamily = names[i];\n          div.appendChild(span);\n        }\n\n        this._document.body.appendChild(div);\n\n        isFontReady(loadTestFontId, function () {\n          _this4._document.body.removeChild(div);\n\n          request.complete();\n        });\n      }\n    }]);\n\n    return GenericFontLoader;\n  }(BaseFontLoader);\n}\n\nvar FontFaceObject = /*#__PURE__*/function () {\n  function FontFaceObject(translatedData, _ref2) {\n    var _ref2$isEvalSupported = _ref2.isEvalSupported,\n        isEvalSupported = _ref2$isEvalSupported === void 0 ? true : _ref2$isEvalSupported,\n        _ref2$disableFontFace = _ref2.disableFontFace,\n        disableFontFace = _ref2$disableFontFace === void 0 ? false : _ref2$disableFontFace,\n        _ref2$ignoreErrors = _ref2.ignoreErrors,\n        ignoreErrors = _ref2$ignoreErrors === void 0 ? false : _ref2$ignoreErrors,\n        onUnsupportedFeature = _ref2.onUnsupportedFeature,\n        _ref2$fontRegistry = _ref2.fontRegistry,\n        fontRegistry = _ref2$fontRegistry === void 0 ? null : _ref2$fontRegistry;\n\n    _classCallCheck(this, FontFaceObject);\n\n    this.compiledGlyphs = Object.create(null);\n\n    for (var i in translatedData) {\n      this[i] = translatedData[i];\n    }\n\n    this.isEvalSupported = isEvalSupported !== false;\n    this.disableFontFace = disableFontFace === true;\n    this.ignoreErrors = ignoreErrors === true;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this.fontRegistry = fontRegistry;\n  }\n\n  _createClass(FontFaceObject, [{\n    key: \"createNativeFontFace\",\n    value: function createNativeFontFace() {\n      if (!this.data || this.disableFontFace) {\n        return null;\n      }\n\n      var nativeFontFace = new FontFace(this.loadedName, this.data, {});\n\n      if (this.fontRegistry) {\n        this.fontRegistry.registerFont(this);\n      }\n\n      return nativeFontFace;\n    }\n  }, {\n    key: \"createFontFaceRule\",\n    value: function createFontFaceRule() {\n      if (!this.data || this.disableFontFace) {\n        return null;\n      }\n\n      var data = (0, _util.bytesToString)(new Uint8Array(this.data));\n      var url = \"url(data:\".concat(this.mimetype, \";base64,\").concat(btoa(data), \");\");\n      var rule = \"@font-face {font-family:\\\"\".concat(this.loadedName, \"\\\";src:\").concat(url, \"}\");\n\n      if (this.fontRegistry) {\n        this.fontRegistry.registerFont(this, url);\n      }\n\n      return rule;\n    }\n  }, {\n    key: \"getPathGenerator\",\n    value: function getPathGenerator(objs, character) {\n      if (this.compiledGlyphs[character] !== undefined) {\n        return this.compiledGlyphs[character];\n      }\n\n      var cmds, current;\n\n      try {\n        cmds = objs.get(this.loadedName + \"_path_\" + character);\n      } catch (ex) {\n        if (!this.ignoreErrors) {\n          throw ex;\n        }\n\n        this._onUnsupportedFeature({\n          featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath\n        });\n\n        (0, _util.warn)(\"getPathGenerator - ignoring character: \\\"\".concat(ex, \"\\\".\"));\n        return this.compiledGlyphs[character] = null;\n      }\n\n      if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {\n        var args,\n            js = \"\";\n\n        for (var i = 0, ii = cmds.length; i < ii; i++) {\n          current = cmds[i];\n\n          if (current.args !== undefined) {\n            args = current.args.join(\",\");\n          } else {\n            args = \"\";\n          }\n\n          js += \"c.\" + current.cmd + \"(\" + args + \");\\n\";\n        }\n\n        return this.compiledGlyphs[character] = new Function(\"c\", \"size\", js);\n      }\n\n      return this.compiledGlyphs[character] = function (c, size) {\n        for (var _i = 0, _ii = cmds.length; _i < _ii; _i++) {\n          current = cmds[_i];\n\n          if (current.cmd === \"scale\") {\n            current.args = [size, -size];\n          }\n\n          c[current.cmd].apply(c, current.args);\n        }\n      };\n    }\n  }]);\n\n  return FontFaceObject;\n}();\n\nexports.FontFaceObject = FontFaceObject;\n\n/***/ }),\n/* 137 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.NodeCMapReaderFactory = exports.NodeCanvasFactory = void 0;\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _is_node = __w_pdfjs_require__(6);\n\nvar _util = __w_pdfjs_require__(4);\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar NodeCanvasFactory = function NodeCanvasFactory() {\n  _classCallCheck(this, NodeCanvasFactory);\n\n  (0, _util.unreachable)(\"Not implemented: NodeCanvasFactory\");\n};\n\nexports.NodeCanvasFactory = NodeCanvasFactory;\n\nvar NodeCMapReaderFactory = function NodeCMapReaderFactory() {\n  _classCallCheck(this, NodeCMapReaderFactory);\n\n  (0, _util.unreachable)(\"Not implemented: NodeCMapReaderFactory\");\n};\n\nexports.NodeCMapReaderFactory = NodeCMapReaderFactory;\n\nif (_is_node.isNodeJS) {\n  exports.NodeCanvasFactory = NodeCanvasFactory = /*#__PURE__*/function (_BaseCanvasFactory) {\n    _inherits(NodeCanvasFactory, _BaseCanvasFactory);\n\n    var _super = _createSuper(NodeCanvasFactory);\n\n    function NodeCanvasFactory() {\n      _classCallCheck(this, NodeCanvasFactory);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(NodeCanvasFactory, [{\n      key: \"create\",\n      value: function create(width, height) {\n        if (width <= 0 || height <= 0) {\n          throw new Error(\"Invalid canvas size\");\n        }\n\n        var Canvas = __webpack_require__(/*! canvas */ \"?97a1\");\n\n        var canvas = Canvas.createCanvas(width, height);\n        return {\n          canvas: canvas,\n          context: canvas.getContext(\"2d\")\n        };\n      }\n    }]);\n\n    return NodeCanvasFactory;\n  }(_display_utils.BaseCanvasFactory);\n\n  exports.NodeCMapReaderFactory = NodeCMapReaderFactory = /*#__PURE__*/function (_BaseCMapReaderFactor) {\n    _inherits(NodeCMapReaderFactory, _BaseCMapReaderFactor);\n\n    var _super2 = _createSuper(NodeCMapReaderFactory);\n\n    function NodeCMapReaderFactory() {\n      _classCallCheck(this, NodeCMapReaderFactory);\n\n      return _super2.apply(this, arguments);\n    }\n\n    _createClass(NodeCMapReaderFactory, [{\n      key: \"_fetchData\",\n      value: function _fetchData(url, compressionType) {\n        return new Promise(function (resolve, reject) {\n          var fs = __webpack_require__(/*! fs */ \"?6e49\");\n\n          fs.readFile(url, function (error, data) {\n            if (error || !data) {\n              reject(new Error(error));\n              return;\n            }\n\n            resolve({\n              cMapData: new Uint8Array(data),\n              compressionType: compressionType\n            });\n          });\n        });\n      }\n    }]);\n\n    return NodeCMapReaderFactory;\n  }(_display_utils.BaseCMapReaderFactory);\n}\n\n/***/ }),\n/* 138 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationStorage = void 0;\n\nvar _util = __w_pdfjs_require__(4);\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AnnotationStorage = /*#__PURE__*/function () {\n  function AnnotationStorage() {\n    _classCallCheck(this, AnnotationStorage);\n\n    this._storage = new Map();\n    this._modified = false;\n    this.onSetModified = null;\n    this.onResetModified = null;\n  }\n\n  _createClass(AnnotationStorage, [{\n    key: \"getOrCreateValue\",\n    value: function getOrCreateValue(key, defaultValue) {\n      if (this._storage.has(key)) {\n        return this._storage.get(key);\n      }\n\n      this._storage.set(key, defaultValue);\n\n      return defaultValue;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(key, value) {\n      var obj = this._storage.get(key);\n\n      var modified = false;\n\n      if (obj !== undefined) {\n        for (var _i = 0, _Object$entries = Object.entries(value); _i < _Object$entries.length; _i++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n              entry = _Object$entries$_i[0],\n              val = _Object$entries$_i[1];\n\n          if (obj[entry] !== val) {\n            modified = true;\n            obj[entry] = val;\n          }\n        }\n      } else {\n        this._storage.set(key, value);\n\n        modified = true;\n      }\n\n      if (modified) {\n        this._setModified();\n      }\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      if (this._storage.size === 0) {\n        return null;\n      }\n\n      return (0, _util.objectFromEntries)(this._storage);\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._storage.size;\n    }\n  }, {\n    key: \"_setModified\",\n    value: function _setModified() {\n      if (!this._modified) {\n        this._modified = true;\n\n        if (typeof this.onSetModified === \"function\") {\n          this.onSetModified();\n        }\n      }\n    }\n  }, {\n    key: \"resetModified\",\n    value: function resetModified() {\n      if (this._modified) {\n        this._modified = false;\n\n        if (typeof this.onResetModified === \"function\") {\n          this.onResetModified();\n        }\n      }\n    }\n  }]);\n\n  return AnnotationStorage;\n}();\n\nexports.AnnotationStorage = AnnotationStorage;\n\n/***/ }),\n/* 139 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.apiCompatibilityParams = void 0;\n\nvar _is_node = __w_pdfjs_require__(6);\n\nvar compatibilityParams = Object.create(null);\n{\n  (function checkFontFace() {\n    if (_is_node.isNodeJS) {\n      compatibilityParams.disableFontFace = true;\n    }\n  })();\n}\nvar apiCompatibilityParams = Object.freeze(compatibilityParams);\nexports.apiCompatibilityParams = apiCompatibilityParams;\n\n/***/ }),\n/* 140 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CanvasGraphics = void 0;\n\nvar _util = __w_pdfjs_require__(4);\n\nvar _pattern_helper = __w_pdfjs_require__(141);\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar MIN_FONT_SIZE = 16;\nvar MAX_FONT_SIZE = 100;\nvar MAX_GROUP_SIZE = 4096;\nvar COMPILE_TYPE3_GLYPHS = false;\nvar MAX_SIZE_TO_COMPILE = 1000;\nvar FULL_CHUNK_HEIGHT = 16;\n\nfunction addContextCurrentTransform(ctx) {\n  if (!ctx.mozCurrentTransform) {\n    ctx._originalSave = ctx.save;\n    ctx._originalRestore = ctx.restore;\n    ctx._originalRotate = ctx.rotate;\n    ctx._originalScale = ctx.scale;\n    ctx._originalTranslate = ctx.translate;\n    ctx._originalTransform = ctx.transform;\n    ctx._originalSetTransform = ctx.setTransform;\n    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\n    ctx._transformStack = [];\n    Object.defineProperty(ctx, \"mozCurrentTransform\", {\n      get: function getCurrentTransform() {\n        return this._transformMatrix;\n      }\n    });\n    Object.defineProperty(ctx, \"mozCurrentTransformInverse\", {\n      get: function getCurrentTransformInverse() {\n        var m = this._transformMatrix;\n        var a = m[0],\n            b = m[1],\n            c = m[2],\n            d = m[3],\n            e = m[4],\n            f = m[5];\n        var ad_bc = a * d - b * c;\n        var bc_ad = b * c - a * d;\n        return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];\n      }\n    });\n\n    ctx.save = function ctxSave() {\n      var old = this._transformMatrix;\n\n      this._transformStack.push(old);\n\n      this._transformMatrix = old.slice(0, 6);\n\n      this._originalSave();\n    };\n\n    ctx.restore = function ctxRestore() {\n      var prev = this._transformStack.pop();\n\n      if (prev) {\n        this._transformMatrix = prev;\n\n        this._originalRestore();\n      }\n    };\n\n    ctx.translate = function ctxTranslate(x, y) {\n      var m = this._transformMatrix;\n      m[4] = m[0] * x + m[2] * y + m[4];\n      m[5] = m[1] * x + m[3] * y + m[5];\n\n      this._originalTranslate(x, y);\n    };\n\n    ctx.scale = function ctxScale(x, y) {\n      var m = this._transformMatrix;\n      m[0] = m[0] * x;\n      m[1] = m[1] * x;\n      m[2] = m[2] * y;\n      m[3] = m[3] * y;\n\n      this._originalScale(x, y);\n    };\n\n    ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n      var m = this._transformMatrix;\n      this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];\n\n      ctx._originalTransform(a, b, c, d, e, f);\n    };\n\n    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n      this._transformMatrix = [a, b, c, d, e, f];\n\n      ctx._originalSetTransform(a, b, c, d, e, f);\n    };\n\n    ctx.rotate = function ctxRotate(angle) {\n      var cosValue = Math.cos(angle);\n      var sinValue = Math.sin(angle);\n      var m = this._transformMatrix;\n      this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];\n\n      this._originalRotate(angle);\n    };\n  }\n}\n\nvar CachedCanvases = function CachedCanvasesClosure() {\n  function CachedCanvases(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n\n  CachedCanvases.prototype = {\n    getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {\n      var canvasEntry;\n\n      if (this.cache[id] !== undefined) {\n        canvasEntry = this.cache[id];\n        this.canvasFactory.reset(canvasEntry, width, height);\n        canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);\n      } else {\n        canvasEntry = this.canvasFactory.create(width, height);\n        this.cache[id] = canvasEntry;\n      }\n\n      if (trackTransform) {\n        addContextCurrentTransform(canvasEntry.context);\n      }\n\n      return canvasEntry;\n    },\n    clear: function clear() {\n      for (var id in this.cache) {\n        var canvasEntry = this.cache[id];\n        this.canvasFactory.destroy(canvasEntry);\n        delete this.cache[id];\n      }\n    }\n  };\n  return CachedCanvases;\n}();\n\nfunction compileType3Glyph(imgData) {\n  var POINT_TO_PROCESS_LIMIT = 1000;\n  var width = imgData.width,\n      height = imgData.height,\n      width1 = width + 1;\n  var i, ii, j, j0;\n  var points = new Uint8Array(width1 * (height + 1));\n  var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n  var lineSize = width + 7 & ~7,\n      data0 = imgData.data;\n  var data = new Uint8Array(lineSize * height);\n  var pos = 0;\n\n  for (i = 0, ii = data0.length; i < ii; i++) {\n    var elem = data0[i];\n    var mask = 128;\n\n    while (mask > 0) {\n      data[pos++] = elem & mask ? 0 : 255;\n      mask >>= 1;\n    }\n  }\n\n  var count = 0;\n  pos = 0;\n\n  if (data[pos] !== 0) {\n    points[0] = 1;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j] = data[pos] ? 2 : 1;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j] = 2;\n    ++count;\n  }\n\n  for (i = 1; i < height; i++) {\n    pos = i * lineSize;\n    j0 = i * width1;\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0] = data[pos] ? 1 : 8;\n      ++count;\n    }\n\n    var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n\n    for (j = 1; j < width; j++) {\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n\n      if (POINT_TYPES[sum]) {\n        points[j0 + j] = POINT_TYPES[sum];\n        ++count;\n      }\n\n      pos++;\n    }\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0 + j] = data[pos] ? 2 : 4;\n      ++count;\n    }\n\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n  }\n\n  pos = lineSize * (height - 1);\n  j0 = i * width1;\n\n  if (data[pos] !== 0) {\n    points[j0] = 8;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j0 + j] = data[pos] ? 4 : 8;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j0 + j] = 4;\n    ++count;\n  }\n\n  if (count > POINT_TO_PROCESS_LIMIT) {\n    return null;\n  }\n\n  var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n  var outlines = [];\n\n  for (i = 0; count && i <= height; i++) {\n    var p = i * width1;\n    var end = p + width;\n\n    while (p < end && !points[p]) {\n      p++;\n    }\n\n    if (p === end) {\n      continue;\n    }\n\n    var coords = [p % width1, i];\n    var p0 = p;\n    var type = points[p];\n\n    do {\n      var step = steps[type];\n\n      do {\n        p += step;\n      } while (!points[p]);\n\n      var pp = points[p];\n\n      if (pp !== 5 && pp !== 10) {\n        type = pp;\n        points[p] = 0;\n      } else {\n        type = pp & 0x33 * type >> 4;\n        points[p] &= type >> 2 | type << 2;\n      }\n\n      coords.push(p % width1);\n      coords.push(p / width1 | 0);\n\n      if (!points[p]) {\n        --count;\n      }\n    } while (p0 !== p);\n\n    outlines.push(coords);\n    --i;\n  }\n\n  var drawOutline = function drawOutline(c) {\n    c.save();\n    c.scale(1 / width, -1 / height);\n    c.translate(0, -height);\n    c.beginPath();\n\n    for (var k = 0, kk = outlines.length; k < kk; k++) {\n      var o = outlines[k];\n      c.moveTo(o[0], o[1]);\n\n      for (var l = 2, ll = o.length; l < ll; l += 2) {\n        c.lineTo(o[l], o[l + 1]);\n      }\n    }\n\n    c.fill();\n    c.beginPath();\n    c.restore();\n  };\n\n  return drawOutline;\n}\n\nvar CanvasExtraState = function CanvasExtraStateClosure() {\n  function CanvasExtraState() {\n    this.alphaIsShape = false;\n    this.fontSize = 0;\n    this.fontSizeScale = 1;\n    this.textMatrix = _util.IDENTITY_MATRIX;\n    this.textMatrixScale = 1;\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    this.x = 0;\n    this.y = 0;\n    this.lineX = 0;\n    this.lineY = 0;\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\n    this.textRise = 0;\n    this.fillColor = \"#000000\";\n    this.strokeColor = \"#000000\";\n    this.patternFill = false;\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.activeSMask = null;\n    this.resumeSMaskCtx = null;\n    this.transferMaps = null;\n  }\n\n  CanvasExtraState.prototype = {\n    clone: function CanvasExtraState_clone() {\n      return Object.create(this);\n    },\n    setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n  };\n  return CanvasExtraState;\n}();\n\nvar CanvasGraphics = function CanvasGraphicsClosure() {\n  var EXECUTION_TIME = 15;\n  var EXECUTION_STEPS = 10;\n\n  function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer, optionalContentConfig) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState();\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.webGLContext = webGLContext;\n    this.imageLayer = imageLayer;\n    this.groupStack = [];\n    this.processingType3 = null;\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.contentVisible = true;\n    this.markedContentStack = [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n\n    if (canvasCtx) {\n      addContextCurrentTransform(canvasCtx);\n    }\n\n    this._cachedGetSinglePixelWidth = null;\n  }\n\n  function putBinaryImageData(ctx, imgData) {\n    var transferMaps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n      ctx.putImageData(imgData, 0, 0);\n      return;\n    }\n\n    var height = imgData.height,\n        width = imgData.width;\n    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    var srcPos = 0,\n        destPos;\n    var src = imgData.data;\n    var dest = chunkImgData.data;\n    var i, j, thisChunkHeight, elemsInThisChunk;\n    var transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;\n\n    if (transferMaps) {\n      switch (transferMaps.length) {\n        case 1:\n          transferMapRed = transferMaps[0];\n          transferMapGreen = transferMaps[0];\n          transferMapBlue = transferMaps[0];\n          transferMapGray = transferMaps[0];\n          break;\n\n        case 4:\n          transferMapRed = transferMaps[0];\n          transferMapGreen = transferMaps[1];\n          transferMapBlue = transferMaps[2];\n          transferMapGray = transferMaps[3];\n          break;\n      }\n    }\n\n    if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n      var srcLength = src.byteLength;\n      var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n      var dest32DataLength = dest32.length;\n      var fullSrcDiff = width + 7 >> 3;\n      var white = 0xffffffff;\n      var black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;\n\n      if (transferMapGray) {\n        if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {\n          var _ref = [black, white];\n          white = _ref[0];\n          black = _ref[1];\n        }\n      }\n\n      for (i = 0; i < totalChunks; i++) {\n        thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        destPos = 0;\n\n        for (j = 0; j < thisChunkHeight; j++) {\n          var srcDiff = srcLength - srcPos;\n          var k = 0;\n          var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n          var kEndUnrolled = kEnd & ~7;\n          var mask = 0;\n          var srcByte = 0;\n\n          for (; k < kEndUnrolled; k += 8) {\n            srcByte = src[srcPos++];\n            dest32[destPos++] = srcByte & 128 ? white : black;\n            dest32[destPos++] = srcByte & 64 ? white : black;\n            dest32[destPos++] = srcByte & 32 ? white : black;\n            dest32[destPos++] = srcByte & 16 ? white : black;\n            dest32[destPos++] = srcByte & 8 ? white : black;\n            dest32[destPos++] = srcByte & 4 ? white : black;\n            dest32[destPos++] = srcByte & 2 ? white : black;\n            dest32[destPos++] = srcByte & 1 ? white : black;\n          }\n\n          for (; k < kEnd; k++) {\n            if (mask === 0) {\n              srcByte = src[srcPos++];\n              mask = 128;\n            }\n\n            dest32[destPos++] = srcByte & mask ? white : black;\n            mask >>= 1;\n          }\n        }\n\n        while (destPos < dest32DataLength) {\n          dest32[destPos++] = 0;\n        }\n\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n      }\n    } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n      var hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n      j = 0;\n      elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n\n      for (i = 0; i < fullChunks; i++) {\n        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n        srcPos += elemsInThisChunk;\n\n        if (hasTransferMaps) {\n          for (var _k = 0; _k < elemsInThisChunk; _k += 4) {\n            if (transferMapRed) {\n              dest[_k + 0] = transferMapRed[dest[_k + 0]];\n            }\n\n            if (transferMapGreen) {\n              dest[_k + 1] = transferMapGreen[dest[_k + 1]];\n            }\n\n            if (transferMapBlue) {\n              dest[_k + 2] = transferMapBlue[dest[_k + 2]];\n            }\n          }\n        }\n\n        ctx.putImageData(chunkImgData, 0, j);\n        j += FULL_CHUNK_HEIGHT;\n      }\n\n      if (i < totalChunks) {\n        elemsInThisChunk = width * partialChunkHeight * 4;\n        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n\n        if (hasTransferMaps) {\n          for (var _k2 = 0; _k2 < elemsInThisChunk; _k2 += 4) {\n            if (transferMapRed) {\n              dest[_k2 + 0] = transferMapRed[dest[_k2 + 0]];\n            }\n\n            if (transferMapGreen) {\n              dest[_k2 + 1] = transferMapGreen[dest[_k2 + 1]];\n            }\n\n            if (transferMapBlue) {\n              dest[_k2 + 2] = transferMapBlue[dest[_k2 + 2]];\n            }\n          }\n        }\n\n        ctx.putImageData(chunkImgData, 0, j);\n      }\n    } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n      var _hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n\n      thisChunkHeight = FULL_CHUNK_HEIGHT;\n      elemsInThisChunk = width * thisChunkHeight;\n\n      for (i = 0; i < totalChunks; i++) {\n        if (i >= fullChunks) {\n          thisChunkHeight = partialChunkHeight;\n          elemsInThisChunk = width * thisChunkHeight;\n        }\n\n        destPos = 0;\n\n        for (j = elemsInThisChunk; j--;) {\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = 255;\n        }\n\n        if (_hasTransferMaps) {\n          for (var _k3 = 0; _k3 < destPos; _k3 += 4) {\n            if (transferMapRed) {\n              dest[_k3 + 0] = transferMapRed[dest[_k3 + 0]];\n            }\n\n            if (transferMapGreen) {\n              dest[_k3 + 1] = transferMapGreen[dest[_k3 + 1]];\n            }\n\n            if (transferMapBlue) {\n              dest[_k3 + 2] = transferMapBlue[dest[_k3 + 2]];\n            }\n          }\n        }\n\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n      }\n    } else {\n      throw new Error(\"bad image kind: \".concat(imgData.kind));\n    }\n  }\n\n  CanvasGraphics.putBinaryImageData = putBinaryImageData;\n\n  function putBinaryImageMask(ctx, imgData) {\n    var height = imgData.height,\n        width = imgData.width;\n    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    var srcPos = 0;\n    var src = imgData.data;\n    var dest = chunkImgData.data;\n\n    for (var i = 0; i < totalChunks; i++) {\n      var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      var destPos = 3;\n\n      for (var j = 0; j < thisChunkHeight; j++) {\n        var elem = void 0,\n            mask = 0;\n\n        for (var k = 0; k < width; k++) {\n          if (!mask) {\n            elem = src[srcPos++];\n            mask = 128;\n          }\n\n          dest[destPos] = elem & mask ? 0 : 255;\n          destPos += 4;\n          mask >>= 1;\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  }\n\n  function copyCtxState(sourceCtx, destCtx) {\n    var properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\"];\n\n    for (var i = 0, ii = properties.length; i < ii; i++) {\n      var property = properties[i];\n\n      if (sourceCtx[property] !== undefined) {\n        destCtx[property] = sourceCtx[property];\n      }\n    }\n\n    if (sourceCtx.setLineDash !== undefined) {\n      destCtx.setLineDash(sourceCtx.getLineDash());\n      destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n    }\n  }\n\n  function resetCtxToDefault(ctx) {\n    ctx.strokeStyle = \"#000000\";\n    ctx.fillStyle = \"#000000\";\n    ctx.fillRule = \"nonzero\";\n    ctx.globalAlpha = 1;\n    ctx.lineWidth = 1;\n    ctx.lineCap = \"butt\";\n    ctx.lineJoin = \"miter\";\n    ctx.miterLimit = 10;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.font = \"10px sans-serif\";\n\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash([]);\n      ctx.lineDashOffset = 0;\n    }\n  }\n\n  function composeSMaskBackdrop(bytes, r0, g0, b0) {\n    var length = bytes.length;\n\n    for (var i = 3; i < length; i += 4) {\n      var alpha = bytes[i];\n\n      if (alpha === 0) {\n        bytes[i - 3] = r0;\n        bytes[i - 2] = g0;\n        bytes[i - 1] = b0;\n      } else if (alpha < 255) {\n        var alpha_ = 255 - alpha;\n        bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n        bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n        bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n      }\n    }\n  }\n\n  function composeSMaskAlpha(maskData, layerData, transferMap) {\n    var length = maskData.length;\n    var scale = 1 / 255;\n\n    for (var i = 3; i < length; i += 4) {\n      var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n      layerData[i] = layerData[i] * alpha * scale | 0;\n    }\n  }\n\n  function composeSMaskLuminosity(maskData, layerData, transferMap) {\n    var length = maskData.length;\n\n    for (var i = 3; i < length; i += 4) {\n      var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n      layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n    }\n  }\n\n  function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {\n    var hasBackdrop = !!backdrop;\n    var r0 = hasBackdrop ? backdrop[0] : 0;\n    var g0 = hasBackdrop ? backdrop[1] : 0;\n    var b0 = hasBackdrop ? backdrop[2] : 0;\n    var composeFn;\n\n    if (subtype === \"Luminosity\") {\n      composeFn = composeSMaskLuminosity;\n    } else {\n      composeFn = composeSMaskAlpha;\n    }\n\n    var PIXELS_TO_PROCESS = 1048576;\n    var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n\n    for (var row = 0; row < height; row += chunkSize) {\n      var chunkHeight = Math.min(chunkSize, height - row);\n      var maskData = maskCtx.getImageData(0, row, width, chunkHeight);\n      var layerData = layerCtx.getImageData(0, row, width, chunkHeight);\n\n      if (hasBackdrop) {\n        composeSMaskBackdrop(maskData.data, r0, g0, b0);\n      }\n\n      composeFn(maskData.data, layerData.data, transferMap);\n      maskCtx.putImageData(layerData, 0, row);\n    }\n  }\n\n  function composeSMask(ctx, smask, layerCtx, webGLContext) {\n    var mask = smask.canvas;\n    var maskCtx = smask.context;\n    ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);\n    var backdrop = smask.backdrop || null;\n\n    if (!smask.transferMap && webGLContext.isEnabled) {\n      var composed = webGLContext.composeSMask({\n        layer: layerCtx.canvas,\n        mask: mask,\n        properties: {\n          subtype: smask.subtype,\n          backdrop: backdrop\n        }\n      });\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(composed, smask.offsetX, smask.offsetY);\n      return;\n    }\n\n    genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);\n    ctx.drawImage(mask, 0, 0);\n  }\n\n  var LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n  var LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n  var NORMAL_CLIP = {};\n  var EO_CLIP = {};\n  CanvasGraphics.prototype = {\n    beginDrawing: function beginDrawing(_ref2) {\n      var transform = _ref2.transform,\n          viewport = _ref2.viewport,\n          _ref2$transparency = _ref2.transparency,\n          transparency = _ref2$transparency === void 0 ? false : _ref2$transparency,\n          _ref2$background = _ref2.background,\n          background = _ref2$background === void 0 ? null : _ref2$background;\n      var width = this.ctx.canvas.width;\n      var height = this.ctx.canvas.height;\n      this.ctx.save();\n      this.ctx.fillStyle = background || \"rgb(255, 255, 255)\";\n      this.ctx.fillRect(0, 0, width, height);\n      this.ctx.restore();\n\n      if (transparency) {\n        var transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height, true);\n        this.compositeCtx = this.ctx;\n        this.transparentCanvas = transparentCanvas.canvas;\n        this.ctx = transparentCanvas.context;\n        this.ctx.save();\n        this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);\n      }\n\n      this.ctx.save();\n      resetCtxToDefault(this.ctx);\n\n      if (transform) {\n        this.ctx.transform.apply(this.ctx, transform);\n      }\n\n      this.ctx.transform.apply(this.ctx, viewport.transform);\n      this.baseTransform = this.ctx.mozCurrentTransform.slice();\n      this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);\n\n      if (this.imageLayer) {\n        this.imageLayer.beginLayout();\n      }\n    },\n    executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n      var argsArray = operatorList.argsArray;\n      var fnArray = operatorList.fnArray;\n      var i = executionStartIdx || 0;\n      var argsArrayLen = argsArray.length;\n\n      if (argsArrayLen === i) {\n        return i;\n      }\n\n      var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n      var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n      var steps = 0;\n      var commonObjs = this.commonObjs;\n      var objs = this.objs;\n      var fnId;\n\n      while (true) {\n        if (stepper !== undefined && i === stepper.nextBreakPoint) {\n          stepper.breakIt(i, continueCallback);\n          return i;\n        }\n\n        fnId = fnArray[i];\n\n        if (fnId !== _util.OPS.dependency) {\n          this.setCurrentOperatorIndex(i);\n          this[fnId].apply(this, argsArray[i]);\n        } else {\n          var _iterator = _createForOfIteratorHelper(argsArray[i]),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var depObjId = _step.value;\n              var objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n\n              if (!objsPool.has(depObjId)) {\n                objsPool.get(depObjId, continueCallback);\n                return i;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n\n        i++;\n\n        if (i === argsArrayLen) {\n          return i;\n        }\n\n        if (chunkOperations && ++steps > EXECUTION_STEPS) {\n          if (Date.now() > endTime) {\n            continueCallback();\n            return i;\n          }\n\n          steps = 0;\n        }\n      }\n    },\n    restoreInitialState: function CanvasGraphics_restoreInitialState() {\n      while (this.stateStack.length || this.current.activeSMask !== null) {\n        this.restore();\n      }\n\n      this.ctx.restore();\n\n      if (this.transparentCanvas) {\n        this.ctx = this.compositeCtx;\n        this.ctx.save();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.drawImage(this.transparentCanvas, 0, 0);\n        this.ctx.restore();\n        this.transparentCanvas = null;\n      }\n    },\n    endDrawing: function CanvasGraphics_endDrawing() {\n      this.restoreInitialState();\n      this.cachedCanvases.clear();\n      this.webGLContext.clear();\n\n      if (this.imageLayer) {\n        this.imageLayer.endLayout();\n      }\n    },\n    setLineWidth: function CanvasGraphics_setLineWidth(width) {\n      this.current.lineWidth = width;\n      this.ctx.lineWidth = width;\n    },\n    setLineCap: function CanvasGraphics_setLineCap(style) {\n      this.ctx.lineCap = LINE_CAP_STYLES[style];\n    },\n    setLineJoin: function CanvasGraphics_setLineJoin(style) {\n      this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n    },\n    setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {\n      this.ctx.miterLimit = limit;\n    },\n    setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {\n      var ctx = this.ctx;\n\n      if (ctx.setLineDash !== undefined) {\n        ctx.setLineDash(dashArray);\n        ctx.lineDashOffset = dashPhase;\n      }\n    },\n    setRenderingIntent: function setRenderingIntent(intent) {},\n    setFlatness: function setFlatness(flatness) {},\n    setGState: function CanvasGraphics_setGState(states) {\n      for (var i = 0, ii = states.length; i < ii; i++) {\n        var state = states[i];\n        var key = state[0];\n        var value = state[1];\n\n        switch (key) {\n          case \"LW\":\n            this.setLineWidth(value);\n            break;\n\n          case \"LC\":\n            this.setLineCap(value);\n            break;\n\n          case \"LJ\":\n            this.setLineJoin(value);\n            break;\n\n          case \"ML\":\n            this.setMiterLimit(value);\n            break;\n\n          case \"D\":\n            this.setDash(value[0], value[1]);\n            break;\n\n          case \"RI\":\n            this.setRenderingIntent(value);\n            break;\n\n          case \"FL\":\n            this.setFlatness(value);\n            break;\n\n          case \"Font\":\n            this.setFont(value[0], value[1]);\n            break;\n\n          case \"CA\":\n            this.current.strokeAlpha = state[1];\n            break;\n\n          case \"ca\":\n            this.current.fillAlpha = state[1];\n            this.ctx.globalAlpha = state[1];\n            break;\n\n          case \"BM\":\n            this.ctx.globalCompositeOperation = value;\n            break;\n\n          case \"SMask\":\n            if (this.current.activeSMask) {\n              if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {\n                this.suspendSMaskGroup();\n              } else {\n                this.endSMaskGroup();\n              }\n            }\n\n            this.current.activeSMask = value ? this.tempSMask : null;\n\n            if (this.current.activeSMask) {\n              this.beginSMaskGroup();\n            }\n\n            this.tempSMask = null;\n            break;\n\n          case \"TR\":\n            this.current.transferMaps = value;\n        }\n      }\n    },\n    beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {\n      var activeSMask = this.current.activeSMask;\n      var drawnWidth = activeSMask.canvas.width;\n      var drawnHeight = activeSMask.canvas.height;\n      var cacheId = \"smaskGroupAt\" + this.groupLevel;\n      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n      var currentCtx = this.ctx;\n      var currentTransform = currentCtx.mozCurrentTransform;\n      this.ctx.save();\n      var groupCtx = scratchCanvas.context;\n      groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);\n      groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);\n      groupCtx.transform.apply(groupCtx, currentTransform);\n      activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;\n      copyCtxState(currentCtx, groupCtx);\n      this.ctx = groupCtx;\n      this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n      this.groupStack.push(currentCtx);\n      this.groupLevel++;\n    },\n    suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n      var groupCtx = this.ctx;\n      this.groupLevel--;\n      this.ctx = this.groupStack.pop();\n      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);\n      this.ctx.restore();\n      this.ctx.save();\n      copyCtxState(groupCtx, this.ctx);\n      this.current.resumeSMaskCtx = groupCtx;\n\n      var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\n\n      this.ctx.transform.apply(this.ctx, deltaTransform);\n      groupCtx.save();\n      groupCtx.setTransform(1, 0, 0, 1, 0, 0);\n      groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);\n      groupCtx.restore();\n    },\n    resumeSMaskGroup: function CanvasGraphics_resumeSMaskGroup() {\n      var groupCtx = this.current.resumeSMaskCtx;\n      var currentCtx = this.ctx;\n      this.ctx = groupCtx;\n      this.groupStack.push(currentCtx);\n      this.groupLevel++;\n    },\n    endSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n      var groupCtx = this.ctx;\n      this.groupLevel--;\n      this.ctx = this.groupStack.pop();\n      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);\n      this.ctx.restore();\n      copyCtxState(groupCtx, this.ctx);\n\n      var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\n\n      this.ctx.transform.apply(this.ctx, deltaTransform);\n    },\n    save: function CanvasGraphics_save() {\n      this.ctx.save();\n      var old = this.current;\n      this.stateStack.push(old);\n      this.current = old.clone();\n      this.current.resumeSMaskCtx = null;\n    },\n    restore: function CanvasGraphics_restore() {\n      if (this.current.resumeSMaskCtx) {\n        this.resumeSMaskGroup();\n      }\n\n      if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {\n        this.endSMaskGroup();\n      }\n\n      if (this.stateStack.length !== 0) {\n        this.current = this.stateStack.pop();\n        this.ctx.restore();\n        this.pendingClip = null;\n        this._cachedGetSinglePixelWidth = null;\n      } else {\n        this.current.activeSMask = null;\n      }\n    },\n    transform: function CanvasGraphics_transform(a, b, c, d, e, f) {\n      if (typeof this.ctx.needDelegateInlineImageGroup === \"function\" && this.ctx.needDelegateInlineImageGroup()) {\n        return;\n      }\n\n      this.ctx.transform(a, b, c, d, e, f);\n      this._cachedGetSinglePixelWidth = null;\n    },\n    constructPath: function CanvasGraphics_constructPath(ops, args) {\n      var ctx = this.ctx;\n      var current = this.current;\n      var x = current.x,\n          y = current.y;\n\n      for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {\n        switch (ops[i] | 0) {\n          case _util.OPS.rectangle:\n            x = args[j++];\n            y = args[j++];\n            var width = args[j++];\n            var height = args[j++];\n            var xw = x + width;\n            var yh = y + height;\n            ctx.moveTo(x, y);\n\n            if (width === 0 || height === 0) {\n              ctx.lineTo(xw, yh);\n            } else {\n              ctx.lineTo(xw, y);\n              ctx.lineTo(xw, yh);\n              ctx.lineTo(x, yh);\n            }\n\n            ctx.closePath();\n            break;\n\n          case _util.OPS.moveTo:\n            x = args[j++];\n            y = args[j++];\n            ctx.moveTo(x, y);\n            break;\n\n          case _util.OPS.lineTo:\n            x = args[j++];\n            y = args[j++];\n            ctx.lineTo(x, y);\n            break;\n\n          case _util.OPS.curveTo:\n            x = args[j + 4];\n            y = args[j + 5];\n            ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n            j += 6;\n            break;\n\n          case _util.OPS.curveTo2:\n            ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n            x = args[j + 2];\n            y = args[j + 3];\n            j += 4;\n            break;\n\n          case _util.OPS.curveTo3:\n            x = args[j + 2];\n            y = args[j + 3];\n            ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n            j += 4;\n            break;\n\n          case _util.OPS.closePath:\n            ctx.closePath();\n            break;\n        }\n      }\n\n      current.setCurrentPoint(x, y);\n    },\n    closePath: function CanvasGraphics_closePath() {\n      this.ctx.closePath();\n    },\n    stroke: function CanvasGraphics_stroke(consumePath) {\n      consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n      var ctx = this.ctx;\n      var strokeColor = this.current.strokeColor;\n      ctx.globalAlpha = this.current.strokeAlpha;\n\n      if (this.contentVisible) {\n        if (_typeof(strokeColor) === \"object\" && strokeColor !== null && strokeColor !== void 0 && strokeColor.getPattern) {\n          ctx.save();\n          var transform = ctx.mozCurrentTransform;\n\n          var scale = _util.Util.singularValueDecompose2dScale(transform)[0];\n\n          ctx.strokeStyle = strokeColor.getPattern(ctx, this);\n          var lineWidth = this.getSinglePixelWidth();\n          var scaledLineWidth = this.current.lineWidth * scale;\n\n          if (lineWidth < 0 && -lineWidth >= scaledLineWidth) {\n            ctx.resetTransform();\n            ctx.lineWidth = Math.round(this._combinedScaleFactor);\n          } else {\n            ctx.lineWidth = Math.max(lineWidth, scaledLineWidth);\n          }\n\n          ctx.stroke();\n          ctx.restore();\n        } else {\n          var _lineWidth = this.getSinglePixelWidth();\n\n          if (_lineWidth < 0 && -_lineWidth >= this.current.lineWidth) {\n            ctx.save();\n            ctx.resetTransform();\n            ctx.lineWidth = Math.round(this._combinedScaleFactor);\n            ctx.stroke();\n            ctx.restore();\n          } else {\n            ctx.lineWidth = Math.max(_lineWidth, this.current.lineWidth);\n            ctx.stroke();\n          }\n        }\n      }\n\n      if (consumePath) {\n        this.consumePath();\n      }\n\n      ctx.globalAlpha = this.current.fillAlpha;\n    },\n    closeStroke: function CanvasGraphics_closeStroke() {\n      this.closePath();\n      this.stroke();\n    },\n    fill: function CanvasGraphics_fill(consumePath, isFillStrokeCombo) {\n      consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n      var ctx = this.ctx;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n      var needRestore = false;\n\n      if (isPatternFill) {\n        ctx.save();\n\n        if (this.baseTransform) {\n          ctx.setTransform.apply(ctx, this.baseTransform);\n        }\n\n        ctx.fillStyle = fillColor.getPattern(ctx, this);\n        needRestore = true;\n      }\n\n      if (this.contentVisible) {\n        if (ctx.isLMVCanvasContext && typeof ctx.isLMVCanvasContext === \"function\" && ctx.isLMVCanvasContext()) {\n          if (this.pendingEOFill) {\n            ctx.fill('evenodd', isFillStrokeCombo);\n            this.pendingEOFill = false;\n          } else {\n            ctx.fill(isFillStrokeCombo);\n          }\n        } else {\n          if (this.pendingEOFill) {\n            ctx.fill('evenodd');\n            this.pendingEOFill = false;\n          } else {\n            ctx.fill();\n          }\n        }\n      }\n\n      if (needRestore) {\n        ctx.restore();\n      }\n\n      if (consumePath) {\n        this.consumePath();\n      }\n    },\n    eoFill: function CanvasGraphics_eoFill() {\n      this.pendingEOFill = true;\n      this.fill();\n    },\n    fillStroke: function CanvasGraphics_fillStroke() {\n      this.fill(false, true);\n      this.stroke(false);\n      this.consumePath();\n    },\n    eoFillStroke: function CanvasGraphics_eoFillStroke() {\n      this.pendingEOFill = true;\n      this.fillStroke();\n    },\n    closeFillStroke: function CanvasGraphics_closeFillStroke() {\n      this.closePath();\n      this.fillStroke();\n    },\n    closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {\n      this.pendingEOFill = true;\n      this.closePath();\n      this.fillStroke();\n    },\n    endPath: function CanvasGraphics_endPath() {\n      this.consumePath();\n    },\n    clip: function CanvasGraphics_clip() {\n      this.pendingClip = NORMAL_CLIP;\n    },\n    eoClip: function CanvasGraphics_eoClip() {\n      this.pendingClip = EO_CLIP;\n    },\n    beginText: function CanvasGraphics_beginText() {\n      this.current.textMatrix = _util.IDENTITY_MATRIX;\n      this.current.textMatrixScale = 1;\n      this.current.x = this.current.lineX = 0;\n      this.current.y = this.current.lineY = 0;\n    },\n    endText: function CanvasGraphics_endText() {\n      var paths = this.pendingTextPaths;\n      var ctx = this.ctx;\n\n      if (paths === undefined) {\n        ctx.beginPath();\n        return;\n      }\n\n      ctx.save();\n      ctx.beginPath();\n\n      for (var i = 0; i < paths.length; i++) {\n        var path = paths[i];\n        ctx.setTransform.apply(ctx, path.transform);\n        ctx.translate(path.x, path.y);\n        path.addToPath(ctx, path.fontSize);\n      }\n\n      ctx.restore();\n      ctx.clip();\n      ctx.beginPath();\n      delete this.pendingTextPaths;\n    },\n    setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {\n      this.current.charSpacing = spacing;\n    },\n    setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {\n      this.current.wordSpacing = spacing;\n    },\n    setHScale: function CanvasGraphics_setHScale(scale) {\n      this.current.textHScale = scale / 100;\n    },\n    setLeading: function CanvasGraphics_setLeading(leading) {\n      this.current.leading = -leading;\n    },\n    setFont: function CanvasGraphics_setFont(fontRefName, size) {\n      var fontObj = this.commonObjs.get(fontRefName);\n      var current = this.current;\n\n      if (!fontObj) {\n        throw new Error(\"Can't find font for \".concat(fontRefName));\n      }\n\n      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n\n      if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n        (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n      }\n\n      if (size < 0) {\n        size = -size;\n        current.fontDirection = -1;\n      } else {\n        current.fontDirection = 1;\n      }\n\n      this.current.font = fontObj;\n      this.current.fontSize = size;\n\n      if (fontObj.isType3Font) {\n        return;\n      }\n\n      var name = fontObj.loadedName || \"sans-serif\";\n      var bold = \"normal\";\n\n      if (fontObj.black) {\n        bold = \"900\";\n      } else if (fontObj.bold) {\n        bold = \"bold\";\n      }\n\n      var italic = fontObj.italic ? \"italic\" : \"normal\";\n      var typeface = \"\\\"\".concat(name, \"\\\", \").concat(fontObj.fallbackName);\n      var browserFontSize = size;\n\n      if (size < MIN_FONT_SIZE) {\n        browserFontSize = MIN_FONT_SIZE;\n      } else if (size > MAX_FONT_SIZE) {\n        browserFontSize = MAX_FONT_SIZE;\n      }\n\n      this.current.fontSizeScale = size / browserFontSize;\n      this.ctx.font = \"\".concat(italic, \" \").concat(bold, \" \").concat(browserFontSize, \"px \").concat(typeface);\n    },\n    setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {\n      this.current.textRenderingMode = mode;\n    },\n    setTextRise: function CanvasGraphics_setTextRise(rise) {\n      this.current.textRise = rise;\n    },\n    moveText: function CanvasGraphics_moveText(x, y) {\n      this.current.x = this.current.lineX += x;\n      this.current.y = this.current.lineY += y;\n    },\n    setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {\n      this.setLeading(-y);\n      this.moveText(x, y);\n    },\n    setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {\n      this.current.textMatrix = [a, b, c, d, e, f];\n      this.current.textMatrixScale = Math.hypot(a, b);\n      this.current.x = this.current.lineX = 0;\n      this.current.y = this.current.lineY = 0;\n    },\n    nextLine: function CanvasGraphics_nextLine() {\n      this.moveText(0, this.current.leading);\n    },\n    paintChar: function paintChar(character, x, y, patternTransform, resetLineWidthToOne) {\n      var ctx = this.ctx;\n      var current = this.current;\n      var font = current.font;\n      var textRenderingMode = current.textRenderingMode;\n      var fontSize = current.fontSize / current.fontSizeScale;\n      var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n      var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n      var patternFill = current.patternFill && !font.missingFile;\n      var addToPath;\n\n      if (font.disableFontFace || isAddToPathSet || patternFill) {\n        addToPath = font.getPathGenerator(this.commonObjs, character);\n      }\n\n      if (addToPath && (font.disableFontFace || patternFill)) {\n        ctx.save();\n        ctx.translate(x, y);\n        ctx.beginPath(character, x, y, font, fontSize);\n        addToPath(ctx, fontSize);\n\n        if (patternTransform) {\n          ctx.setTransform.apply(ctx, patternTransform);\n        }\n\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          ctx.fill();\n        }\n\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          if (resetLineWidthToOne) {\n            ctx.resetTransform();\n            ctx.lineWidth = Math.round(this._combinedScaleFactor);\n          }\n\n          ctx.stroke();\n        }\n\n        ctx.restore();\n      } else {\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          ctx.fillText(character, x, y, undefined, font, fontSize);\n        }\n\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          if (resetLineWidthToOne) {\n            ctx.save();\n            ctx.moveTo(x, y);\n            ctx.resetTransform();\n            ctx.lineWidth = Math.round(this._combinedScaleFactor);\n            ctx.strokeText(character, 0, 0, undefined, font, fontSize);\n            ctx.restore();\n          } else {\n            ctx.strokeText(character, x, y, undefined, font, fontSize);\n          }\n        }\n      }\n\n      if (addToPath && isAddToPathSet) {\n        var paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n        paths.push({\n          transform: ctx.mozCurrentTransform,\n          x: x,\n          y: y,\n          fontSize: fontSize,\n          addToPath: addToPath\n        });\n      }\n    },\n\n    get isFontSubpixelAAEnabled() {\n      var _this$cachedCanvases$ = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10),\n          ctx = _this$cachedCanvases$.context;\n\n      ctx.scale(1.5, 1);\n      ctx.fillText(\"I\", 0, 10);\n      var data = ctx.getImageData(0, 0, 10, 10).data;\n      var enabled = false;\n\n      for (var i = 3; i < data.length; i += 4) {\n        if (data[i] > 0 && data[i] < 255) {\n          enabled = true;\n          break;\n        }\n      }\n\n      return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n    },\n\n    showText: function CanvasGraphics_showText(glyphs) {\n      var current = this.current;\n      var font = current.font;\n\n      if (font.isType3Font) {\n        return this.showType3Text(glyphs);\n      }\n\n      var fontSize = current.fontSize;\n\n      if (fontSize === 0) {\n        return undefined;\n      }\n\n      var ctx = this.ctx;\n      var fontSizeScale = current.fontSizeScale;\n      var charSpacing = current.charSpacing;\n      var wordSpacing = current.wordSpacing;\n      var fontDirection = current.fontDirection;\n      var textHScale = current.textHScale * fontDirection;\n      var glyphsLength = glyphs.length;\n      var vertical = font.vertical;\n      var spacingDir = vertical ? 1 : -1;\n      var defaultVMetrics = font.defaultVMetrics;\n      var widthAdvanceScale = fontSize * current.fontMatrix[0];\n      var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n      ctx.save();\n      var patternTransform;\n\n      if (current.patternFill) {\n        ctx.save();\n        var pattern = current.fillColor.getPattern(ctx, this);\n        patternTransform = ctx.mozCurrentTransform;\n        ctx.restore();\n        ctx.fillStyle = pattern;\n      }\n\n      ctx.transform.apply(ctx, current.textMatrix);\n      ctx.translate(current.x, current.y + current.textRise);\n\n      if (fontDirection > 0) {\n        ctx.scale(textHScale, -1);\n      } else {\n        ctx.scale(textHScale, 1);\n      }\n\n      var lineWidth = current.lineWidth;\n      var resetLineWidthToOne = false;\n      var scale = current.textMatrixScale;\n\n      if (scale === 0 || lineWidth === 0) {\n        var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          this._cachedGetSinglePixelWidth = null;\n          lineWidth = this.getSinglePixelWidth();\n          resetLineWidthToOne = lineWidth < 0;\n        }\n      } else {\n        lineWidth /= scale;\n      }\n\n      if (fontSizeScale !== 1.0) {\n        ctx.scale(fontSizeScale, fontSizeScale);\n        lineWidth /= fontSizeScale;\n      }\n\n      ctx.lineWidth = lineWidth;\n      var x = 0,\n          i;\n\n      for (i = 0; i < glyphsLength; ++i) {\n        var glyph = glyphs[i];\n\n        if ((0, _util.isNum)(glyph)) {\n          x += spacingDir * glyph * fontSize / 1000;\n          continue;\n        }\n\n        var restoreNeeded = false;\n        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n        var character = glyph.fontChar;\n        var accent = glyph.accent;\n        var scaledX = void 0,\n            scaledY = void 0;\n        var width = glyph.width;\n\n        if (vertical) {\n          var vmetric = glyph.vmetric || defaultVMetrics;\n          var vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n          var vy = vmetric[2] * widthAdvanceScale;\n          width = vmetric ? -vmetric[0] : width;\n          scaledX = vx / fontSizeScale;\n          scaledY = (x + vy) / fontSizeScale;\n        } else {\n          scaledX = x / fontSizeScale;\n          scaledY = 0;\n        }\n\n        if (font.remeasure && width > 0) {\n          var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n\n          if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n            var characterScaleX = width / measuredWidth;\n            restoreNeeded = true;\n            ctx.save();\n            ctx.scale(characterScaleX, 1);\n            scaledX /= characterScaleX;\n          } else if (width !== measuredWidth) {\n            scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n          }\n        }\n\n        if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n          if (simpleFillText && !accent) {\n            ctx.fillText(character, scaledX, scaledY);\n          } else {\n            this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);\n\n            if (accent) {\n              var scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n              var scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n              this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);\n            }\n          }\n        }\n\n        var charWidth = void 0;\n\n        if (vertical) {\n          charWidth = width * widthAdvanceScale - spacing * fontDirection;\n        } else {\n          charWidth = width * widthAdvanceScale + spacing * fontDirection;\n        }\n\n        x += charWidth;\n\n        if (restoreNeeded) {\n          ctx.restore();\n        }\n      }\n\n      if (vertical) {\n        current.y -= x;\n      } else {\n        current.x += x * textHScale;\n      }\n\n      ctx.restore();\n    },\n    showType3Text: function CanvasGraphics_showType3Text(glyphs) {\n      var ctx = this.ctx;\n      var current = this.current;\n      var font = current.font;\n      var fontSize = current.fontSize;\n      var fontDirection = current.fontDirection;\n      var spacingDir = font.vertical ? 1 : -1;\n      var charSpacing = current.charSpacing;\n      var wordSpacing = current.wordSpacing;\n      var textHScale = current.textHScale * fontDirection;\n      var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n      var glyphsLength = glyphs.length;\n      var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n      var i, glyph, width, spacingLength;\n\n      if (isTextInvisible || fontSize === 0) {\n        return;\n      }\n\n      this._cachedGetSinglePixelWidth = null;\n      ctx.save();\n      ctx.transform.apply(ctx, current.textMatrix);\n      ctx.translate(current.x, current.y);\n      ctx.scale(textHScale, fontDirection);\n\n      for (i = 0; i < glyphsLength; ++i) {\n        glyph = glyphs[i];\n\n        if ((0, _util.isNum)(glyph)) {\n          spacingLength = spacingDir * glyph * fontSize / 1000;\n          this.ctx.translate(spacingLength, 0);\n          current.x += spacingLength * textHScale;\n          continue;\n        }\n\n        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n        var operatorList = font.charProcOperatorList[glyph.operatorListId];\n\n        if (!operatorList) {\n          (0, _util.warn)(\"Type3 character \\\"\".concat(glyph.operatorListId, \"\\\" is not available.\"));\n          continue;\n        }\n\n        if (this.contentVisible) {\n          this.processingType3 = glyph;\n          this.save();\n          ctx.scale(fontSize, fontSize);\n          ctx.transform.apply(ctx, fontMatrix);\n          this.executeOperatorList(operatorList);\n          this.restore();\n        }\n\n        var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\n\n        width = transformed[0] * fontSize + spacing;\n        ctx.translate(width, 0);\n        current.x += width * textHScale;\n      }\n\n      ctx.restore();\n      this.processingType3 = null;\n    },\n    setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},\n    setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n      this.ctx.rect(llx, lly, urx - llx, ury - lly);\n      this.clip();\n      this.endPath();\n    },\n    getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {\n      var _this = this;\n\n      var pattern;\n\n      if (IR[0] === \"TilingPattern\") {\n        var color = IR[1];\n        var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();\n        var canvasGraphicsFactory = {\n          createCanvasGraphics: function createCanvasGraphics(ctx) {\n            return new CanvasGraphics(ctx, _this.commonObjs, _this.objs, _this.canvasFactory, _this.webGLContext);\n          }\n        };\n        pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n      } else {\n        pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);\n      }\n\n      return pattern;\n    },\n    setStrokeColorN: function CanvasGraphics_setStrokeColorN() {\n      this.current.strokeColor = this.getColorN_Pattern(arguments);\n    },\n    setFillColorN: function CanvasGraphics_setFillColorN() {\n      this.current.fillColor = this.getColorN_Pattern(arguments);\n      this.current.patternFill = true;\n    },\n    setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {\n      var color = _util.Util.makeHexColor(r, g, b);\n\n      this.ctx.strokeStyle = color;\n      this.current.strokeColor = color;\n    },\n    setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {\n      var color = _util.Util.makeHexColor(r, g, b);\n\n      this.ctx.fillStyle = color;\n      this.current.fillColor = color;\n      this.current.patternFill = false;\n    },\n    shadingFill: function CanvasGraphics_shadingFill(patternIR) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      this.save();\n      var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);\n      ctx.fillStyle = pattern.getPattern(ctx, this, true);\n      var inv = ctx.mozCurrentTransformInverse;\n\n      if (inv) {\n        var canvas = ctx.canvas;\n        var width = canvas.width;\n        var height = canvas.height;\n\n        var bl = _util.Util.applyTransform([0, 0], inv);\n\n        var br = _util.Util.applyTransform([0, height], inv);\n\n        var ul = _util.Util.applyTransform([width, 0], inv);\n\n        var ur = _util.Util.applyTransform([width, height], inv);\n\n        var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n        var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n        var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n        var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n        this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n      } else {\n        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n      }\n\n      this.restore();\n    },\n    beginInlineImage: function CanvasGraphics_beginInlineImage() {\n      (0, _util.unreachable)(\"Should not call beginInlineImage\");\n    },\n    beginImageData: function CanvasGraphics_beginImageData() {\n      (0, _util.unreachable)(\"Should not call beginImageData\");\n    },\n    paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.save();\n      this.baseTransformStack.push(this.baseTransform);\n\n      if (Array.isArray(matrix) && matrix.length === 6) {\n        this.transform.apply(this, matrix);\n      }\n\n      this.baseTransform = this.ctx.mozCurrentTransform;\n\n      if (bbox) {\n        var width = bbox[2] - bbox[0];\n        var height = bbox[3] - bbox[1];\n        this.ctx.rect(bbox[0], bbox[1], width, height);\n        this.clip();\n        this.endPath();\n      }\n    },\n    paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.restore();\n      this.baseTransform = this.baseTransformStack.pop();\n    },\n    beginGroup: function CanvasGraphics_beginGroup(group) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.save();\n      var currentCtx = this.ctx;\n\n      if (!group.isolated) {\n        (0, _util.info)(\"TODO: Support non-isolated groups.\");\n      }\n\n      if (group.knockout) {\n        (0, _util.warn)(\"Knockout groups not supported.\");\n      }\n\n      if (!(this.ctx.beginChildGroup && typeof this.ctx.beginChildGroup === \"function\" && this.ctx.beginChildGroup(group))) {\n        var currentTransform = currentCtx.mozCurrentTransform;\n\n        if (group.matrix) {\n          currentCtx.transform.apply(currentCtx, group.matrix);\n        }\n\n        if (!group.bbox) {\n          throw new Error(\"Bounding box is required.\");\n        }\n\n        var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);\n\n        var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n        bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n        var offsetX = Math.floor(bounds[0]);\n        var offsetY = Math.floor(bounds[1]);\n        var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n        var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n        var scaleX = 1,\n            scaleY = 1;\n\n        if (drawnWidth > MAX_GROUP_SIZE) {\n          scaleX = drawnWidth / MAX_GROUP_SIZE;\n          drawnWidth = MAX_GROUP_SIZE;\n        }\n\n        if (drawnHeight > MAX_GROUP_SIZE) {\n          scaleY = drawnHeight / MAX_GROUP_SIZE;\n          drawnHeight = MAX_GROUP_SIZE;\n        }\n\n        var cacheId = \"groupAt\" + this.groupLevel;\n\n        if (group.smask) {\n          cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n        }\n\n        var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n        var groupCtx = scratchCanvas.context;\n        groupCtx.scale(1 / scaleX, 1 / scaleY);\n        groupCtx.translate(-offsetX, -offsetY);\n        groupCtx.transform.apply(groupCtx, currentTransform);\n\n        if (group.smask) {\n          this.smaskStack.push({\n            canvas: scratchCanvas.canvas,\n            context: groupCtx,\n            offsetX: offsetX,\n            offsetY: offsetY,\n            scaleX: scaleX,\n            scaleY: scaleY,\n            subtype: group.smask.subtype,\n            backdrop: group.smask.backdrop,\n            transferMap: group.smask.transferMap || null,\n            startTransformInverse: null\n          });\n        } else {\n          currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n          currentCtx.translate(offsetX, offsetY);\n          currentCtx.scale(scaleX, scaleY);\n        }\n\n        copyCtxState(currentCtx, groupCtx);\n        this.ctx = groupCtx;\n      }\n\n      this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n      this.groupStack.push(currentCtx);\n      this.groupLevel++;\n      this.current.activeSMask = null;\n    },\n    endGroup: function CanvasGraphics_endGroup(group) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.groupLevel--;\n      var groupCtx = this.ctx;\n      this.ctx = this.groupStack.pop();\n\n      if (!(this.ctx.endChildGroup && typeof this.ctx.endChildGroup === \"function\" && this.ctx.endChildGroup(group))) {\n        if (this.ctx.imageSmoothingEnabled !== undefined) {\n          this.ctx.imageSmoothingEnabled = false;\n        } else {\n          this.ctx.mozImageSmoothingEnabled = false;\n        }\n\n        if (group.smask) {\n          this.tempSMask = this.smaskStack.pop();\n        } else {\n          this.ctx.drawImage(groupCtx.canvas, 0, 0);\n        }\n      }\n\n      this.restore();\n    },\n    beginAnnotations: function CanvasGraphics_beginAnnotations() {},\n    endAnnotations: function CanvasGraphics_endAnnotations() {},\n    beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {\n      this.restoreInitialState();\n      resetCtxToDefault(this.ctx);\n      this.ctx.save();\n      this.save();\n\n      if (this.baseTransform) {\n        this.ctx.setTransform.apply(this.ctx, this.baseTransform);\n      }\n\n      this.ctx.beginPath();\n      this.current = new CanvasExtraState();\n\n      if (Array.isArray(rect) && rect.length === 4) {\n        var width = rect[2] - rect[0];\n        var height = rect[3] - rect[1];\n        this.ctx.rect(rect[0], rect[1], width, height);\n        this.clip();\n        this.endPath();\n      }\n\n      this.transform.apply(this, transform);\n      this.transform.apply(this, matrix);\n    },\n    endAnnotation: function CanvasGraphics_endAnnotation() {},\n    paintJpegXObject: function CanvasGraphics_paintJpegXObject(objId, w, h) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var domImage = this.processingType3 ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n      if (!domImage) {\n        (0, _util.warn)(\"Dependent image isn't ready yet\");\n        return;\n      }\n\n      this.save();\n      var ctx = this.ctx;\n      ctx.scale(1 / w, -1 / h);\n      ctx.drawImage(domImage, 0, 0, domImage.width, domImage.height, 0, -h, w, h);\n\n      if (this.imageLayer) {\n        var currentTransform = ctx.mozCurrentTransformInverse;\n        var position = this.getCanvasPosition(0, 0);\n        this.imageLayer.appendImage({\n          objId: objId,\n          left: position[0],\n          top: position[1],\n          width: w / currentTransform[0],\n          height: h / currentTransform[3]\n        });\n      }\n\n      this.restore();\n    },\n    paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      var width = img.width,\n          height = img.height;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n      var glyph = this.processingType3;\n\n      if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {\n        if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {\n          glyph.compiled = compileType3Glyph({\n            data: img.data,\n            width: width,\n            height: height\n          });\n        } else {\n          glyph.compiled = null;\n        }\n      }\n\n      if (glyph !== null && glyph !== void 0 && glyph.compiled) {\n        glyph.compiled(ctx);\n        return;\n      }\n\n      var maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      var maskCtx = maskCanvas.context;\n      maskCtx.save();\n      putBinaryImageMask(maskCtx, img);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      this.paintInlineImageXObject(maskCanvas.canvas);\n    },\n    paintImageMaskXObjectRepeat: function paintImageMaskXObjectRepeat(imgData, scaleX) {\n      var skewX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var skewY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var scaleY = arguments.length > 4 ? arguments[4] : undefined;\n      var positions = arguments.length > 5 ? arguments[5] : undefined;\n\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var width = imgData.width;\n      var height = imgData.height;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n      var maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      var maskCtx = maskCanvas.context;\n      maskCtx.save();\n      putBinaryImageMask(maskCtx, imgData);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      var ctx = this.ctx;\n\n      for (var i = 0, ii = positions.length; i < ii; i += 2) {\n        ctx.save();\n        ctx.transform(scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]);\n        ctx.scale(1, -1);\n        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n        ctx.restore();\n      }\n    },\n    paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n\n      for (var i = 0, ii = images.length; i < ii; i++) {\n        var image = images[i];\n        var width = image.width,\n            height = image.height;\n        var maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n        var maskCtx = maskCanvas.context;\n        maskCtx.save();\n        putBinaryImageMask(maskCtx, image);\n        maskCtx.globalCompositeOperation = \"source-in\";\n        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n        maskCtx.fillRect(0, 0, width, height);\n        maskCtx.restore();\n        ctx.save();\n        ctx.transform.apply(ctx, image.transform);\n        ctx.scale(1, -1);\n        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n        ctx.restore();\n      }\n    },\n    paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n      if (!imgData) {\n        (0, _util.warn)(\"Dependent image isn't ready yet\");\n        return;\n      }\n\n      this.paintInlineImageXObject(imgData);\n    },\n    paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n      if (!imgData) {\n        (0, _util.warn)(\"Dependent image isn't ready yet\");\n        return;\n      }\n\n      var width = imgData.width;\n      var height = imgData.height;\n      var map = [];\n\n      for (var i = 0, ii = positions.length; i < ii; i += 2) {\n        map.push({\n          transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n          x: 0,\n          y: 0,\n          w: width,\n          h: height\n        });\n      }\n\n      this.paintInlineImageXObjectGroup(imgData, map);\n    },\n    paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var width = imgData.width;\n      var height = imgData.height;\n      var ctx = this.ctx;\n      this.save();\n      ctx.scale(1 / width, -1 / height);\n      var currentTransform = ctx.mozCurrentTransformInverse;\n      var widthScale = Math.max(Math.hypot(currentTransform[0], currentTransform[1]), 1);\n      var heightScale = Math.max(Math.hypot(currentTransform[2], currentTransform[3]), 1);\n      var imgToPaint, tmpCanvas, tmpCtx;\n\n      if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n        imgToPaint = imgData;\n      } else {\n        tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n        tmpCtx = tmpCanvas.context;\n        putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n        imgToPaint = tmpCanvas.canvas;\n      }\n\n      var paintWidth = width,\n          paintHeight = height;\n      var tmpCanvasId = \"prescale1\";\n\n      while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n        var newWidth = paintWidth,\n            newHeight = paintHeight;\n\n        if (widthScale > 2 && paintWidth > 1) {\n          newWidth = Math.ceil(paintWidth / 2);\n          widthScale /= paintWidth / newWidth;\n        }\n\n        if (heightScale > 2 && paintHeight > 1) {\n          newHeight = Math.ceil(paintHeight / 2);\n          heightScale /= paintHeight / newHeight;\n        }\n\n        tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n        tmpCtx = tmpCanvas.context;\n        tmpCtx.clearRect(0, 0, newWidth, newHeight);\n        tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n        imgToPaint = tmpCanvas.canvas;\n        paintWidth = newWidth;\n        paintHeight = newHeight;\n        tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n      }\n\n      ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);\n\n      if (this.imageLayer) {\n        var position = this.getCanvasPosition(0, -height);\n        this.imageLayer.appendImage({\n          imgData: imgData,\n          left: position[0],\n          top: position[1],\n          width: width / currentTransform[0],\n          height: height / currentTransform[3]\n        });\n      }\n\n      this.restore();\n    },\n    paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      var w = imgData.width;\n      var h = imgData.height;\n      var tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n      var tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n\n      for (var i = 0, ii = map.length; i < ii; i++) {\n        var entry = map[i];\n        ctx.save();\n        ctx.transform.apply(ctx, entry.transform);\n        ctx.scale(1, -1);\n        ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n\n        if (this.imageLayer) {\n          var position = this.getCanvasPosition(entry.x, entry.y);\n          this.imageLayer.appendImage({\n            imgData: imgData,\n            left: position[0],\n            top: position[1],\n            width: w,\n            height: h\n          });\n        }\n\n        ctx.restore();\n      }\n    },\n    paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.ctx.fillRect(0, 0, 1, 1);\n    },\n    markPoint: function CanvasGraphics_markPoint(tag) {},\n    markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},\n    beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {\n      this.markedContentStack.push({\n        visible: true\n      });\n\n      if (this.ctx.beginMarkedContent) {\n        this.ctx.beginMarkedContent(tag);\n      }\n    },\n    beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {\n      if (tag === \"OC\") {\n        this.markedContentStack.push({\n          visible: this.optionalContentConfig.isVisible(properties)\n        });\n      } else {\n        this.markedContentStack.push({\n          visible: true\n        });\n      }\n\n      this.contentVisible = true;\n\n      if (this.ctx.beginMarkedContentProps) {\n        this.ctx.beginMarkedContentProps(tag, properties);\n      }\n    },\n    endMarkedContent: function CanvasGraphics_endMarkedContent() {\n      this.markedContentStack.pop();\n      this.contentVisible = true;\n\n      if (this.ctx.endMarkedContent) {\n        this.ctx.endMarkedContent();\n      }\n    },\n    setCurrentOperatorIndex: function CanvasGraphics_setCurrentOperatorIndex(index) {\n      if (this.ctx.setCurrentOperatorIndex) {\n        this.ctx.setCurrentOperatorIndex(index);\n      }\n    },\n    beginCompat: function CanvasGraphics_beginCompat() {},\n    endCompat: function CanvasGraphics_endCompat() {},\n    consumePath: function CanvasGraphics_consumePath() {\n      var ctx = this.ctx;\n\n      if (this.pendingClip) {\n        if (this.pendingClip === EO_CLIP) {\n          ctx.clip(\"evenodd\");\n        } else {\n          ctx.clip();\n        }\n\n        this.pendingClip = null;\n      }\n\n      ctx.beginPath();\n    },\n    getSinglePixelWidth: function getSinglePixelWidth() {\n      if (this._cachedGetSinglePixelWidth === null) {\n        this._cachedGetSinglePixelWidth = 1e-10;\n      }\n\n      return this._cachedGetSinglePixelWidth;\n    },\n    getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {\n      var transform = this.ctx.mozCurrentTransform;\n      return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];\n    },\n    isContentVisible: function CanvasGraphics_isContentVisible() {\n      for (var i = this.markedContentStack.length - 1; i >= 0; i--) {\n        if (!this.markedContentStack[i].visible) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  };\n\n  for (var op in _util.OPS) {\n    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n  }\n\n  return CanvasGraphics;\n}();\n\nexports.CanvasGraphics = CanvasGraphics;\n\n/***/ }),\n/* 141 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getShadingPatternFromIR = getShadingPatternFromIR;\nexports.TilingPattern = void 0;\n\nvar _util = __w_pdfjs_require__(4);\n\nvar ShadingIRs = {};\n\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox || typeof Path2D === \"undefined\") {\n    return;\n  }\n\n  var width = bbox[2] - bbox[0];\n  var height = bbox[3] - bbox[1];\n  var region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\n\nShadingIRs.RadialAxial = {\n  fromIR: function RadialAxial_fromIR(raw) {\n    var type = raw[1];\n    var bbox = raw[2];\n    var colorStops = raw[3];\n    var p0 = raw[4];\n    var p1 = raw[5];\n    var r0 = raw[6];\n    var r1 = raw[7];\n    return {\n      getPattern: function RadialAxial_getPattern(ctx) {\n        applyBoundingBox(ctx, bbox);\n        var grad;\n\n        if (type === \"axial\") {\n          grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);\n        } else if (type === \"radial\") {\n          grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);\n        }\n\n        if (grad) {\n          grad.rawData = raw;\n        }\n\n        for (var i = 0, ii = colorStops.length; i < ii; ++i) {\n          var c = colorStops[i];\n          grad.addColorStop(c[0], c[1]);\n        }\n\n        return grad;\n      }\n    };\n  }\n};\n\nvar createMeshCanvas = function createMeshCanvasClosure() {\n  function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n    var coords = context.coords,\n        colors = context.colors;\n    var bytes = data.data,\n        rowSize = data.width * 4;\n    var tmp;\n\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n      tmp = p1;\n      p1 = p2;\n      p2 = tmp;\n      tmp = c1;\n      c1 = c2;\n      c2 = tmp;\n    }\n\n    if (coords[p2 + 1] > coords[p3 + 1]) {\n      tmp = p2;\n      p2 = p3;\n      p3 = tmp;\n      tmp = c2;\n      c2 = c3;\n      c3 = tmp;\n    }\n\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n      tmp = p1;\n      p1 = p2;\n      p2 = tmp;\n      tmp = c1;\n      c1 = c2;\n      c2 = tmp;\n    }\n\n    var x1 = (coords[p1] + context.offsetX) * context.scaleX;\n    var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n    var x2 = (coords[p2] + context.offsetX) * context.scaleX;\n    var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n    var x3 = (coords[p3] + context.offsetX) * context.scaleX;\n    var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n\n    if (y1 >= y3) {\n      return;\n    }\n\n    var c1r = colors[c1],\n        c1g = colors[c1 + 1],\n        c1b = colors[c1 + 2];\n    var c2r = colors[c2],\n        c2g = colors[c2 + 1],\n        c2b = colors[c2 + 2];\n    var c3r = colors[c3],\n        c3g = colors[c3 + 1],\n        c3b = colors[c3 + 2];\n    var minY = Math.round(y1),\n        maxY = Math.round(y3);\n    var xa, car, cag, cab;\n    var xb, cbr, cbg, cbb;\n\n    for (var y = minY; y <= maxY; y++) {\n      if (y < y2) {\n        var _k = void 0;\n\n        if (y < y1) {\n          _k = 0;\n        } else if (y1 === y2) {\n          _k = 1;\n        } else {\n          _k = (y1 - y) / (y1 - y2);\n        }\n\n        xa = x1 - (x1 - x2) * _k;\n        car = c1r - (c1r - c2r) * _k;\n        cag = c1g - (c1g - c2g) * _k;\n        cab = c1b - (c1b - c2b) * _k;\n      } else {\n        var _k2 = void 0;\n\n        if (y > y3) {\n          _k2 = 1;\n        } else if (y2 === y3) {\n          _k2 = 0;\n        } else {\n          _k2 = (y2 - y) / (y2 - y3);\n        }\n\n        xa = x2 - (x2 - x3) * _k2;\n        car = c2r - (c2r - c3r) * _k2;\n        cag = c2g - (c2g - c3g) * _k2;\n        cab = c2b - (c2b - c3b) * _k2;\n      }\n\n      var k = void 0;\n\n      if (y < y1) {\n        k = 0;\n      } else if (y > y3) {\n        k = 1;\n      } else {\n        k = (y1 - y) / (y1 - y3);\n      }\n\n      xb = x1 - (x1 - x3) * k;\n      cbr = c1r - (c1r - c3r) * k;\n      cbg = c1g - (c1g - c3g) * k;\n      cbb = c1b - (c1b - c3b) * k;\n      var x1_ = Math.round(Math.min(xa, xb));\n      var x2_ = Math.round(Math.max(xa, xb));\n      var j = rowSize * y + x1_ * 4;\n\n      for (var x = x1_; x <= x2_; x++) {\n        k = (xa - x) / (xa - xb);\n\n        if (k < 0) {\n          k = 0;\n        } else if (k > 1) {\n          k = 1;\n        }\n\n        bytes[j++] = car - (car - cbr) * k | 0;\n        bytes[j++] = cag - (cag - cbg) * k | 0;\n        bytes[j++] = cab - (cab - cbb) * k | 0;\n        bytes[j++] = 255;\n      }\n    }\n  }\n\n  function drawFigure(data, figure, context) {\n    var ps = figure.coords;\n    var cs = figure.colors;\n    var i, ii;\n\n    switch (figure.type) {\n      case \"lattice\":\n        var verticesPerRow = figure.verticesPerRow;\n        var rows = Math.floor(ps.length / verticesPerRow) - 1;\n        var cols = verticesPerRow - 1;\n\n        for (i = 0; i < rows; i++) {\n          var q = i * verticesPerRow;\n\n          for (var j = 0; j < cols; j++, q++) {\n            drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n            drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n          }\n        }\n\n        break;\n\n      case \"triangles\":\n        for (i = 0, ii = ps.length; i < ii; i += 3) {\n          drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n        }\n\n        break;\n\n      default:\n        throw new Error(\"illegal figure\");\n    }\n  }\n\n  function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {\n    var EXPECTED_SCALE = 1.1;\n    var MAX_PATTERN_SIZE = 3000;\n    var BORDER_SIZE = 2;\n    var offsetX = Math.floor(bounds[0]);\n    var offsetY = Math.floor(bounds[1]);\n    var boundsWidth = Math.ceil(bounds[2]) - offsetX;\n    var boundsHeight = Math.ceil(bounds[3]) - offsetY;\n    var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    var scaleX = boundsWidth / width;\n    var scaleY = boundsHeight / height;\n    var context = {\n      coords: coords,\n      colors: colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n    var paddedWidth = width + BORDER_SIZE * 2;\n    var paddedHeight = height + BORDER_SIZE * 2;\n    var canvas, tmpCanvas, i, ii;\n\n    if (webGLContext.isEnabled) {\n      canvas = webGLContext.drawFigures({\n        width: width,\n        height: height,\n        backgroundColor: backgroundColor,\n        figures: figures,\n        context: context\n      });\n      tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n      tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);\n      canvas = tmpCanvas.canvas;\n    } else {\n      tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n      var tmpCtx = tmpCanvas.context;\n      var data = tmpCtx.createImageData(width, height);\n\n      if (backgroundColor) {\n        var bytes = data.data;\n\n        for (i = 0, ii = bytes.length; i < ii; i += 4) {\n          bytes[i] = backgroundColor[0];\n          bytes[i + 1] = backgroundColor[1];\n          bytes[i + 2] = backgroundColor[2];\n          bytes[i + 3] = 255;\n        }\n      }\n\n      for (i = 0; i < figures.length; i++) {\n        drawFigure(data, figures[i], context);\n      }\n\n      tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n      canvas = tmpCanvas.canvas;\n    }\n\n    return {\n      canvas: canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX: scaleX,\n      scaleY: scaleY\n    };\n  }\n\n  return createMeshCanvas;\n}();\n\nShadingIRs.Mesh = {\n  fromIR: function Mesh_fromIR(raw) {\n    var coords = raw[2];\n    var colors = raw[3];\n    var figures = raw[4];\n    var bounds = raw[5];\n    var matrix = raw[6];\n    var bbox = raw[7];\n    var background = raw[8];\n    return {\n      getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {\n        applyBoundingBox(ctx, bbox);\n        var scale;\n\n        if (shadingFill) {\n          scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);\n        } else {\n          scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n\n          if (matrix) {\n            var matrixScale = _util.Util.singularValueDecompose2dScale(matrix);\n\n            scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n          }\n        }\n\n        var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);\n\n        if (!shadingFill) {\n          ctx.setTransform.apply(ctx, owner.baseTransform);\n\n          if (matrix) {\n            ctx.transform.apply(ctx, matrix);\n          }\n        }\n\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n      }\n    };\n  }\n};\nShadingIRs.Dummy = {\n  fromIR: function Dummy_fromIR() {\n    return {\n      getPattern: function Dummy_fromIR_getPattern() {\n        return \"hotpink\";\n      }\n    };\n  }\n};\n\nfunction getShadingPatternFromIR(raw) {\n  var shadingIR = ShadingIRs[raw[0]];\n\n  if (!shadingIR) {\n    throw new Error(\"Unknown IR type: \".concat(raw[0]));\n  }\n\n  return shadingIR.fromIR(raw);\n}\n\nvar TilingPattern = function TilingPatternClosure() {\n  var PaintType = {\n    COLORED: 1,\n    UNCOLORED: 2\n  };\n  var MAX_PATTERN_SIZE = 3000;\n\n  function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n    this.operatorList = IR[2];\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.color = color;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n    this.ctx = ctx;\n  }\n\n  TilingPattern.prototype = {\n    createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {\n      var operatorList = this.operatorList;\n      var bbox = this.bbox;\n      var xstep = this.xstep;\n      var ystep = this.ystep;\n      var paintType = this.paintType;\n      var tilingType = this.tilingType;\n      var color = this.color;\n      var canvasGraphicsFactory = this.canvasGraphicsFactory;\n      (0, _util.info)(\"TilingType: \" + tilingType);\n      var x0 = bbox[0],\n          y0 = bbox[1],\n          x1 = bbox[2],\n          y1 = bbox[3];\n\n      var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n\n      var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n\n      var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n      var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n      var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n      var tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n      var tmpCtx = tmpCanvas.context;\n      var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n      graphics.groupLevel = owner.groupLevel;\n      this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n      graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n      graphics.transform(1, 0, 0, 1, -x0, -y0);\n      this.clipBbox(graphics, bbox, x0, y0, x1, y1);\n      graphics.executeOperatorList(operatorList);\n      this.ctx.transform(1, 0, 0, 1, x0, y0);\n      this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);\n      return tmpCanvas.canvas;\n    },\n    getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {\n      step = Math.abs(step);\n      var maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);\n      var size = Math.ceil(step * scale);\n\n      if (size >= maxSize) {\n        size = maxSize;\n      } else {\n        scale = size / step;\n      }\n\n      return {\n        scale: scale,\n        size: size\n      };\n    },\n    clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {\n      if (Array.isArray(bbox) && bbox.length === 4) {\n        var bboxWidth = x1 - x0;\n        var bboxHeight = y1 - y0;\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n        graphics.clip();\n        graphics.endPath();\n      }\n    },\n    setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {\n      var context = graphics.ctx,\n          current = graphics.current;\n\n      switch (paintType) {\n        case PaintType.COLORED:\n          var ctx = this.ctx;\n          context.fillStyle = ctx.fillStyle;\n          context.strokeStyle = ctx.strokeStyle;\n          current.fillColor = ctx.fillStyle;\n          current.strokeColor = ctx.strokeStyle;\n          break;\n\n        case PaintType.UNCOLORED:\n          var cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\n\n          context.fillStyle = cssColor;\n          context.strokeStyle = cssColor;\n          current.fillColor = cssColor;\n          current.strokeColor = cssColor;\n          break;\n\n        default:\n          throw new _util.FormatError(\"Unsupported paint type: \".concat(paintType));\n      }\n    },\n    getPattern: function TilingPattern_getPattern(ctx, owner) {\n      ctx = this.ctx;\n      ctx.setTransform.apply(ctx, this.baseTransform);\n      ctx.transform.apply(ctx, this.matrix);\n      var temporaryPatternCanvas = this.createPatternCanvas(owner);\n      return ctx.createPattern(temporaryPatternCanvas, \"repeat\");\n    }\n  };\n  return TilingPattern;\n}();\n\nexports.TilingPattern = TilingPattern;\n\n/***/ }),\n/* 142 */\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.GlobalWorkerOptions = void 0;\nvar GlobalWorkerOptions = Object.create(null);\nexports.GlobalWorkerOptions = GlobalWorkerOptions;\nGlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;\nGlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? \"\" : GlobalWorkerOptions.workerSrc;\n\n/***/ }),\n/* 143 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MessageHandler = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar CallbackKind = {\n  UNKNOWN: 0,\n  DATA: 1,\n  ERROR: 2\n};\nvar StreamKind = {\n  UNKNOWN: 0,\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\n\nfunction wrapReason(reason) {\n  if (_typeof(reason) !== \"object\" || reason === null) {\n    return reason;\n  }\n\n  switch (reason.name) {\n    case \"AbortException\":\n      return new _util.AbortException(reason.message);\n\n    case \"MissingPDFException\":\n      return new _util.MissingPDFException(reason.message);\n\n    case \"UnexpectedResponseException\":\n      return new _util.UnexpectedResponseException(reason.message, reason.status);\n\n    case \"UnknownErrorException\":\n      return new _util.UnknownErrorException(reason.message, reason.details);\n\n    default:\n      return new _util.UnknownErrorException(reason.message, reason.toString());\n  }\n}\n\nvar MessageHandler = /*#__PURE__*/function () {\n  function MessageHandler(sourceName, targetName, comObj) {\n    var _this = this;\n\n    _classCallCheck(this, MessageHandler);\n\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.postMessageTransfers = true;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n\n    this._onComObjOnMessage = function (event) {\n      var data = event.data;\n\n      if (data.targetName !== _this.sourceName) {\n        return;\n      }\n\n      if (data.stream) {\n        _this._processStreamMessage(data);\n\n        return;\n      }\n\n      if (data.callback) {\n        var callbackId = data.callbackId;\n        var capability = _this.callbackCapabilities[callbackId];\n\n        if (!capability) {\n          throw new Error(\"Cannot resolve callback \".concat(callbackId));\n        }\n\n        delete _this.callbackCapabilities[callbackId];\n\n        if (data.callback === CallbackKind.DATA) {\n          capability.resolve(data.data);\n        } else if (data.callback === CallbackKind.ERROR) {\n          capability.reject(wrapReason(data.reason));\n        } else {\n          throw new Error(\"Unexpected callback case\");\n        }\n\n        return;\n      }\n\n      var action = _this.actionHandler[data.action];\n\n      if (!action) {\n        throw new Error(\"Unknown action from worker: \".concat(data.action));\n      }\n\n      if (data.callbackId) {\n        var cbSourceName = _this.sourceName;\n        var cbTargetName = data.sourceName;\n        new Promise(function (resolve) {\n          resolve(action(data.data));\n        }).then(function (result) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.DATA,\n            callbackId: data.callbackId,\n            data: result\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.ERROR,\n            callbackId: data.callbackId,\n            reason: wrapReason(reason)\n          });\n        });\n        return;\n      }\n\n      if (data.streamId) {\n        _this._createStreamSink(data);\n\n        return;\n      }\n\n      action(data.data);\n    };\n\n    comObj.addEventListener(\"message\", this._onComObjOnMessage);\n  }\n\n  _createClass(MessageHandler, [{\n    key: \"on\",\n    value: function on(actionName, handler) {\n      var ah = this.actionHandler;\n\n      if (ah[actionName]) {\n        throw new Error(\"There is already an actionName called \\\"\".concat(actionName, \"\\\"\"));\n      }\n\n      ah[actionName] = handler;\n    }\n  }, {\n    key: \"send\",\n    value: function send(actionName, data, transfers) {\n      this._postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        data: data\n      }, transfers);\n    }\n  }, {\n    key: \"sendWithPromise\",\n    value: function sendWithPromise(actionName, data, transfers) {\n      var callbackId = this.callbackId++;\n      var capability = (0, _util.createPromiseCapability)();\n      this.callbackCapabilities[callbackId] = capability;\n\n      try {\n        this._postMessage({\n          sourceName: this.sourceName,\n          targetName: this.targetName,\n          action: actionName,\n          callbackId: callbackId,\n          data: data\n        }, transfers);\n      } catch (ex) {\n        capability.reject(ex);\n      }\n\n      return capability.promise;\n    }\n  }, {\n    key: \"sendWithStream\",\n    value: function sendWithStream(actionName, data, queueingStrategy, transfers) {\n      var _this2 = this;\n\n      var streamId = this.streamId++;\n      var sourceName = this.sourceName;\n      var targetName = this.targetName;\n      var comObj = this.comObj;\n      return new ReadableStream({\n        start: function start(controller) {\n          var startCapability = (0, _util.createPromiseCapability)();\n          _this2.streamControllers[streamId] = {\n            controller: controller,\n            startCall: startCapability,\n            pullCall: null,\n            cancelCall: null,\n            isClosed: false\n          };\n\n          _this2._postMessage({\n            sourceName: sourceName,\n            targetName: targetName,\n            action: actionName,\n            streamId: streamId,\n            data: data,\n            desiredSize: controller.desiredSize\n          }, transfers);\n\n          return startCapability.promise;\n        },\n        pull: function pull(controller) {\n          var pullCapability = (0, _util.createPromiseCapability)();\n          _this2.streamControllers[streamId].pullCall = pullCapability;\n          comObj.postMessage({\n            sourceName: sourceName,\n            targetName: targetName,\n            stream: StreamKind.PULL,\n            streamId: streamId,\n            desiredSize: controller.desiredSize\n          });\n          return pullCapability.promise;\n        },\n        cancel: function cancel(reason) {\n          (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n          var cancelCapability = (0, _util.createPromiseCapability)();\n          _this2.streamControllers[streamId].cancelCall = cancelCapability;\n          _this2.streamControllers[streamId].isClosed = true;\n          comObj.postMessage({\n            sourceName: sourceName,\n            targetName: targetName,\n            stream: StreamKind.CANCEL,\n            streamId: streamId,\n            reason: wrapReason(reason)\n          });\n          return cancelCapability.promise;\n        }\n      }, queueingStrategy);\n    }\n  }, {\n    key: \"_createStreamSink\",\n    value: function _createStreamSink(data) {\n      var self = this;\n      var action = this.actionHandler[data.action];\n      var streamId = data.streamId;\n      var sourceName = this.sourceName;\n      var targetName = data.sourceName;\n      var comObj = this.comObj;\n      var streamSink = {\n        enqueue: function enqueue(chunk) {\n          var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n          var transfers = arguments.length > 2 ? arguments[2] : undefined;\n\n          if (this.isCancelled) {\n            return;\n          }\n\n          var lastDesiredSize = this.desiredSize;\n          this.desiredSize -= size;\n\n          if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n            this.sinkCapability = (0, _util.createPromiseCapability)();\n            this.ready = this.sinkCapability.promise;\n          }\n\n          self._postMessage({\n            sourceName: sourceName,\n            targetName: targetName,\n            stream: StreamKind.ENQUEUE,\n            streamId: streamId,\n            chunk: chunk\n          }, transfers);\n        },\n        close: function close() {\n          if (this.isCancelled) {\n            return;\n          }\n\n          this.isCancelled = true;\n          comObj.postMessage({\n            sourceName: sourceName,\n            targetName: targetName,\n            stream: StreamKind.CLOSE,\n            streamId: streamId\n          });\n          delete self.streamSinks[streamId];\n        },\n        error: function error(reason) {\n          (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n\n          if (this.isCancelled) {\n            return;\n          }\n\n          this.isCancelled = true;\n          comObj.postMessage({\n            sourceName: sourceName,\n            targetName: targetName,\n            stream: StreamKind.ERROR,\n            streamId: streamId,\n            reason: wrapReason(reason)\n          });\n        },\n        sinkCapability: (0, _util.createPromiseCapability)(),\n        onPull: null,\n        onCancel: null,\n        isCancelled: false,\n        desiredSize: data.desiredSize,\n        ready: null\n      };\n      streamSink.sinkCapability.resolve();\n      streamSink.ready = streamSink.sinkCapability.promise;\n      this.streamSinks[streamId] = streamSink;\n      new Promise(function (resolve) {\n        resolve(action(data.data, streamSink));\n      }).then(function () {\n        comObj.postMessage({\n          sourceName: sourceName,\n          targetName: targetName,\n          stream: StreamKind.START_COMPLETE,\n          streamId: streamId,\n          success: true\n        });\n      }, function (reason) {\n        comObj.postMessage({\n          sourceName: sourceName,\n          targetName: targetName,\n          stream: StreamKind.START_COMPLETE,\n          streamId: streamId,\n          reason: wrapReason(reason)\n        });\n      });\n    }\n  }, {\n    key: \"_processStreamMessage\",\n    value: function _processStreamMessage(data) {\n      var streamId = data.streamId;\n      var sourceName = this.sourceName;\n      var targetName = data.sourceName;\n      var comObj = this.comObj;\n\n      switch (data.stream) {\n        case StreamKind.START_COMPLETE:\n          if (data.success) {\n            this.streamControllers[streamId].startCall.resolve();\n          } else {\n            this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));\n          }\n\n          break;\n\n        case StreamKind.PULL_COMPLETE:\n          if (data.success) {\n            this.streamControllers[streamId].pullCall.resolve();\n          } else {\n            this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));\n          }\n\n          break;\n\n        case StreamKind.PULL:\n          if (!this.streamSinks[streamId]) {\n            comObj.postMessage({\n              sourceName: sourceName,\n              targetName: targetName,\n              stream: StreamKind.PULL_COMPLETE,\n              streamId: streamId,\n              success: true\n            });\n            break;\n          }\n\n          if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {\n            this.streamSinks[streamId].sinkCapability.resolve();\n          }\n\n          this.streamSinks[streamId].desiredSize = data.desiredSize;\n          var onPull = this.streamSinks[data.streamId].onPull;\n          new Promise(function (resolve) {\n            resolve(onPull && onPull());\n          }).then(function () {\n            comObj.postMessage({\n              sourceName: sourceName,\n              targetName: targetName,\n              stream: StreamKind.PULL_COMPLETE,\n              streamId: streamId,\n              success: true\n            });\n          }, function (reason) {\n            comObj.postMessage({\n              sourceName: sourceName,\n              targetName: targetName,\n              stream: StreamKind.PULL_COMPLETE,\n              streamId: streamId,\n              reason: wrapReason(reason)\n            });\n          });\n          break;\n\n        case StreamKind.ENQUEUE:\n          (0, _util.assert)(this.streamControllers[streamId], \"enqueue should have stream controller\");\n\n          if (this.streamControllers[streamId].isClosed) {\n            break;\n          }\n\n          this.streamControllers[streamId].controller.enqueue(data.chunk);\n          break;\n\n        case StreamKind.CLOSE:\n          (0, _util.assert)(this.streamControllers[streamId], \"close should have stream controller\");\n\n          if (this.streamControllers[streamId].isClosed) {\n            break;\n          }\n\n          this.streamControllers[streamId].isClosed = true;\n          this.streamControllers[streamId].controller.close();\n\n          this._deleteStreamController(streamId);\n\n          break;\n\n        case StreamKind.ERROR:\n          (0, _util.assert)(this.streamControllers[streamId], \"error should have stream controller\");\n          this.streamControllers[streamId].controller.error(wrapReason(data.reason));\n\n          this._deleteStreamController(streamId);\n\n          break;\n\n        case StreamKind.CANCEL_COMPLETE:\n          if (data.success) {\n            this.streamControllers[streamId].cancelCall.resolve();\n          } else {\n            this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));\n          }\n\n          this._deleteStreamController(streamId);\n\n          break;\n\n        case StreamKind.CANCEL:\n          if (!this.streamSinks[streamId]) {\n            break;\n          }\n\n          var onCancel = this.streamSinks[data.streamId].onCancel;\n          new Promise(function (resolve) {\n            resolve(onCancel && onCancel(wrapReason(data.reason)));\n          }).then(function () {\n            comObj.postMessage({\n              sourceName: sourceName,\n              targetName: targetName,\n              stream: StreamKind.CANCEL_COMPLETE,\n              streamId: streamId,\n              success: true\n            });\n          }, function (reason) {\n            comObj.postMessage({\n              sourceName: sourceName,\n              targetName: targetName,\n              stream: StreamKind.CANCEL_COMPLETE,\n              streamId: streamId,\n              reason: wrapReason(reason)\n            });\n          });\n          this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));\n          this.streamSinks[streamId].isCancelled = true;\n          delete this.streamSinks[streamId];\n          break;\n\n        default:\n          throw new Error(\"Unexpected stream case\");\n      }\n    }\n  }, {\n    key: \"_deleteStreamController\",\n    value: function () {\n      var _deleteStreamController2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(streamId) {\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) {\n                  return capability && capability.promise;\n                }));\n\n              case 2:\n                delete this.streamControllers[streamId];\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _deleteStreamController(_x) {\n        return _deleteStreamController2.apply(this, arguments);\n      }\n\n      return _deleteStreamController;\n    }()\n  }, {\n    key: \"_postMessage\",\n    value: function _postMessage(message, transfers) {\n      if (transfers && this.postMessageTransfers) {\n        this.comObj.postMessage(message, transfers);\n      } else {\n        this.comObj.postMessage(message);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n    }\n  }]);\n\n  return MessageHandler;\n}();\n\nexports.MessageHandler = MessageHandler;\n\n/***/ }),\n/* 144 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Metadata = void 0;\n\nvar _util = __w_pdfjs_require__(4);\n\nvar _xml_parser = __w_pdfjs_require__(145);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Metadata = /*#__PURE__*/function () {\n  function Metadata(data) {\n    _classCallCheck(this, Metadata);\n\n    (0, _util.assert)(typeof data === \"string\", \"Metadata: input is not a string\");\n    data = this._repair(data);\n    var parser = new _xml_parser.SimpleXMLParser({\n      lowerCaseName: true\n    });\n    var xmlDocument = parser.parseFromString(data);\n    this._metadataMap = new Map();\n\n    if (xmlDocument) {\n      this._parse(xmlDocument);\n    }\n\n    this._data = data;\n  }\n\n  _createClass(Metadata, [{\n    key: \"_repair\",\n    value: function _repair(data) {\n      return data.replace(/^[^<]+/, \"\").replace(/>\\\\376\\\\377([^<]+)/g, function (all, codes) {\n        var bytes = codes.replace(/\\\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {\n          return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);\n        }).replace(/&(amp|apos|gt|lt|quot);/g, function (str, name) {\n          switch (name) {\n            case \"amp\":\n              return \"&\";\n\n            case \"apos\":\n              return \"'\";\n\n            case \"gt\":\n              return \">\";\n\n            case \"lt\":\n              return \"<\";\n\n            case \"quot\":\n              return '\"';\n          }\n\n          throw new Error(\"_repair: \".concat(name, \" isn't defined.\"));\n        });\n        var chars = \"\";\n\n        for (var i = 0, ii = bytes.length; i < ii; i += 2) {\n          var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);\n\n          if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {\n            chars += String.fromCharCode(code);\n          } else {\n            chars += \"&#x\" + (0x10000 + code).toString(16).substring(1) + \";\";\n          }\n        }\n\n        return \">\" + chars;\n      });\n    }\n  }, {\n    key: \"_getSequence\",\n    value: function _getSequence(entry) {\n      var name = entry.nodeName;\n\n      if (name !== \"rdf:bag\" && name !== \"rdf:seq\" && name !== \"rdf:alt\") {\n        return null;\n      }\n\n      return entry.childNodes.filter(function (node) {\n        return node.nodeName === \"rdf:li\";\n      });\n    }\n  }, {\n    key: \"_getCreators\",\n    value: function _getCreators(entry) {\n      if (entry.nodeName !== \"dc:creator\") {\n        return false;\n      }\n\n      if (!entry.hasChildNodes()) {\n        return true;\n      }\n\n      var seqNode = entry.childNodes[0];\n      var authors = this._getSequence(seqNode) || [];\n\n      this._metadataMap.set(entry.nodeName, authors.map(function (node) {\n        return node.textContent.trim();\n      }));\n\n      return true;\n    }\n  }, {\n    key: \"_parse\",\n    value: function _parse(xmlDocument) {\n      var rdf = xmlDocument.documentElement;\n\n      if (rdf.nodeName !== \"rdf:rdf\") {\n        rdf = rdf.firstChild;\n\n        while (rdf && rdf.nodeName !== \"rdf:rdf\") {\n          rdf = rdf.nextSibling;\n        }\n      }\n\n      if (!rdf || rdf.nodeName !== \"rdf:rdf\" || !rdf.hasChildNodes()) {\n        return;\n      }\n\n      var _iterator = _createForOfIteratorHelper(rdf.childNodes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var desc = _step.value;\n\n          if (desc.nodeName !== \"rdf:description\") {\n            continue;\n          }\n\n          var _iterator2 = _createForOfIteratorHelper(desc.childNodes),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var entry = _step2.value;\n              var name = entry.nodeName;\n\n              if (name === \"#text\") {\n                continue;\n              }\n\n              if (this._getCreators(entry)) {\n                continue;\n              }\n\n              this._metadataMap.set(name, entry.textContent.trim());\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"getRaw\",\n    value: function getRaw() {\n      return this._data;\n    }\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      var _this$_metadataMap$ge;\n\n      return (_this$_metadataMap$ge = this._metadataMap.get(name)) !== null && _this$_metadataMap$ge !== void 0 ? _this$_metadataMap$ge : null;\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      return (0, _util.objectFromEntries)(this._metadataMap);\n    }\n  }, {\n    key: \"has\",\n    value: function has(name) {\n      return this._metadataMap.has(name);\n    }\n  }]);\n\n  return Metadata;\n}();\n\nexports.Metadata = Metadata;\n\n/***/ }),\n/* 145 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XMLParserErrorCode = exports.XMLParserBase = exports.SimpleXMLParser = exports.SimpleDOMNode = void 0;\n\nvar _util = __w_pdfjs_require__(4);\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar XMLParserErrorCode = {\n  NoError: 0,\n  EndOfDocument: -1,\n  UnterminatedCdat: -2,\n  UnterminatedXmlDeclaration: -3,\n  UnterminatedDoctypeDeclaration: -4,\n  UnterminatedComment: -5,\n  MalformedElement: -6,\n  OutOfMemory: -7,\n  UnterminatedAttributeValue: -8,\n  UnterminatedElement: -9,\n  ElementNeverBegun: -10\n};\nexports.XMLParserErrorCode = XMLParserErrorCode;\n\nfunction isWhitespace(s, index) {\n  var ch = s[index];\n  return ch === \" \" || ch === \"\\n\" || ch === \"\\r\" || ch === \"\\t\";\n}\n\nfunction isWhitespaceString(s) {\n  for (var i = 0, ii = s.length; i < ii; i++) {\n    if (!isWhitespace(s, i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar XMLParserBase = /*#__PURE__*/function () {\n  function XMLParserBase() {\n    _classCallCheck(this, XMLParserBase);\n  }\n\n  _createClass(XMLParserBase, [{\n    key: \"_resolveEntities\",\n    value: function _resolveEntities(s) {\n      var _this = this;\n\n      return s.replace(/&([^;]+);/g, function (all, entity) {\n        if (entity.substring(0, 2) === \"#x\") {\n          return String.fromCodePoint(parseInt(entity.substring(2), 16));\n        } else if (entity.substring(0, 1) === \"#\") {\n          return String.fromCodePoint(parseInt(entity.substring(1), 10));\n        }\n\n        switch (entity) {\n          case \"lt\":\n            return \"<\";\n\n          case \"gt\":\n            return \">\";\n\n          case \"amp\":\n            return \"&\";\n\n          case \"quot\":\n            return '\"';\n\n          case \"apos\":\n            return \"'\";\n        }\n\n        return _this.onResolveEntity(entity);\n      });\n    }\n  }, {\n    key: \"_parseContent\",\n    value: function _parseContent(s, start) {\n      var attributes = [];\n      var pos = start;\n\n      function skipWs() {\n        while (pos < s.length && isWhitespace(s, pos)) {\n          ++pos;\n        }\n      }\n\n      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \">\" && s[pos] !== \"/\") {\n        ++pos;\n      }\n\n      var name = s.substring(start, pos);\n      skipWs();\n\n      while (pos < s.length && s[pos] !== \">\" && s[pos] !== \"/\" && s[pos] !== \"?\") {\n        skipWs();\n        var attrName = \"\",\n            attrValue = \"\";\n\n        while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \"=\") {\n          attrName += s[pos];\n          ++pos;\n        }\n\n        skipWs();\n\n        if (s[pos] !== \"=\") {\n          return null;\n        }\n\n        ++pos;\n        skipWs();\n        var attrEndChar = s[pos];\n\n        if (attrEndChar !== '\"' && attrEndChar !== \"'\") {\n          return null;\n        }\n\n        var attrEndIndex = s.indexOf(attrEndChar, ++pos);\n\n        if (attrEndIndex < 0) {\n          return null;\n        }\n\n        attrValue = s.substring(pos, attrEndIndex);\n        attributes.push({\n          name: attrName,\n          value: this._resolveEntities(attrValue)\n        });\n        pos = attrEndIndex + 1;\n        skipWs();\n      }\n\n      return {\n        name: name,\n        attributes: attributes,\n        parsed: pos - start\n      };\n    }\n  }, {\n    key: \"_parseProcessingInstruction\",\n    value: function _parseProcessingInstruction(s, start) {\n      var pos = start;\n\n      function skipWs() {\n        while (pos < s.length && isWhitespace(s, pos)) {\n          ++pos;\n        }\n      }\n\n      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \">\" && s[pos] !== \"/\") {\n        ++pos;\n      }\n\n      var name = s.substring(start, pos);\n      skipWs();\n      var attrStart = pos;\n\n      while (pos < s.length && (s[pos] !== \"?\" || s[pos + 1] !== \">\")) {\n        ++pos;\n      }\n\n      var value = s.substring(attrStart, pos);\n      return {\n        name: name,\n        value: value,\n        parsed: pos - start\n      };\n    }\n  }, {\n    key: \"parseXml\",\n    value: function parseXml(s) {\n      var i = 0;\n\n      while (i < s.length) {\n        var ch = s[i];\n        var j = i;\n\n        if (ch === \"<\") {\n          ++j;\n          var ch2 = s[j];\n          var q = void 0;\n\n          switch (ch2) {\n            case \"/\":\n              ++j;\n              q = s.indexOf(\">\", j);\n\n              if (q < 0) {\n                this.onError(XMLParserErrorCode.UnterminatedElement);\n                return;\n              }\n\n              this.onEndElement(s.substring(j, q));\n              j = q + 1;\n              break;\n\n            case \"?\":\n              ++j;\n\n              var pi = this._parseProcessingInstruction(s, j);\n\n              if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== \"?>\") {\n                this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);\n                return;\n              }\n\n              this.onPi(pi.name, pi.value);\n              j += pi.parsed + 2;\n              break;\n\n            case \"!\":\n              if (s.substring(j + 1, j + 3) === \"--\") {\n                q = s.indexOf(\"-->\", j + 3);\n\n                if (q < 0) {\n                  this.onError(XMLParserErrorCode.UnterminatedComment);\n                  return;\n                }\n\n                this.onComment(s.substring(j + 3, q));\n                j = q + 3;\n              } else if (s.substring(j + 1, j + 8) === \"[CDATA[\") {\n                q = s.indexOf(\"]]>\", j + 8);\n\n                if (q < 0) {\n                  this.onError(XMLParserErrorCode.UnterminatedCdat);\n                  return;\n                }\n\n                this.onCdata(s.substring(j + 8, q));\n                j = q + 3;\n              } else if (s.substring(j + 1, j + 8) === \"DOCTYPE\") {\n                var q2 = s.indexOf(\"[\", j + 8);\n                var complexDoctype = false;\n                q = s.indexOf(\">\", j + 8);\n\n                if (q < 0) {\n                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\n                  return;\n                }\n\n                if (q2 > 0 && q > q2) {\n                  q = s.indexOf(\"]>\", j + 8);\n\n                  if (q < 0) {\n                    this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\n                    return;\n                  }\n\n                  complexDoctype = true;\n                }\n\n                var doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));\n                this.onDoctype(doctypeContent);\n                j = q + (complexDoctype ? 2 : 1);\n              } else {\n                this.onError(XMLParserErrorCode.MalformedElement);\n                return;\n              }\n\n              break;\n\n            default:\n              var content = this._parseContent(s, j);\n\n              if (content === null) {\n                this.onError(XMLParserErrorCode.MalformedElement);\n                return;\n              }\n\n              var isClosed = false;\n\n              if (s.substring(j + content.parsed, j + content.parsed + 2) === \"/>\") {\n                isClosed = true;\n              } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== \">\") {\n                this.onError(XMLParserErrorCode.UnterminatedElement);\n                return;\n              }\n\n              this.onBeginElement(content.name, content.attributes, isClosed);\n              j += content.parsed + (isClosed ? 2 : 1);\n              break;\n          }\n        } else {\n          while (j < s.length && s[j] !== \"<\") {\n            j++;\n          }\n\n          var text = s.substring(i, j);\n          this.onText(this._resolveEntities(text));\n        }\n\n        i = j;\n      }\n    }\n  }, {\n    key: \"onResolveEntity\",\n    value: function onResolveEntity(name) {\n      return \"&\".concat(name, \";\");\n    }\n  }, {\n    key: \"onPi\",\n    value: function onPi(name, value) {}\n  }, {\n    key: \"onComment\",\n    value: function onComment(text) {}\n  }, {\n    key: \"onCdata\",\n    value: function onCdata(text) {}\n  }, {\n    key: \"onDoctype\",\n    value: function onDoctype(doctypeContent) {}\n  }, {\n    key: \"onText\",\n    value: function onText(text) {}\n  }, {\n    key: \"onBeginElement\",\n    value: function onBeginElement(name, attributes, isEmpty) {}\n  }, {\n    key: \"onEndElement\",\n    value: function onEndElement(name) {}\n  }, {\n    key: \"onError\",\n    value: function onError(code) {}\n  }]);\n\n  return XMLParserBase;\n}();\n\nexports.XMLParserBase = XMLParserBase;\n\nvar SimpleDOMNode = /*#__PURE__*/function () {\n  function SimpleDOMNode(nodeName, nodeValue) {\n    _classCallCheck(this, SimpleDOMNode);\n\n    this.nodeName = nodeName;\n    this.nodeValue = nodeValue;\n    Object.defineProperty(this, \"parentNode\", {\n      value: null,\n      writable: true\n    });\n  }\n\n  _createClass(SimpleDOMNode, [{\n    key: \"firstChild\",\n    get: function get() {\n      return this.childNodes && this.childNodes[0];\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      var childNodes = this.parentNode.childNodes;\n\n      if (!childNodes) {\n        return undefined;\n      }\n\n      var index = childNodes.indexOf(this);\n\n      if (index === -1) {\n        return undefined;\n      }\n\n      return childNodes[index + 1];\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      if (!this.childNodes) {\n        return this.nodeValue || \"\";\n      }\n\n      return this.childNodes.map(function (child) {\n        return child.textContent;\n      }).join(\"\");\n    }\n  }, {\n    key: \"hasChildNodes\",\n    value: function hasChildNodes() {\n      return this.childNodes && this.childNodes.length > 0;\n    }\n  }, {\n    key: \"searchNode\",\n    value: function searchNode(paths, pos) {\n      if (pos >= paths.length) {\n        return this;\n      }\n\n      var component = paths[pos];\n      var stack = [];\n      var node = this;\n\n      while (true) {\n        if (component.name === node.nodeName) {\n          if (component.pos === 0) {\n            var res = node.searchNode(paths, pos + 1);\n\n            if (res !== null) {\n              return res;\n            }\n          } else if (stack.length === 0) {\n            return null;\n          } else {\n            var _stack$pop = stack.pop(),\n                _stack$pop2 = _slicedToArray(_stack$pop, 1),\n                parent = _stack$pop2[0];\n\n            var siblingPos = 0;\n\n            var _iterator = _createForOfIteratorHelper(parent.childNodes),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var child = _step.value;\n\n                if (component.name === child.nodeName) {\n                  if (siblingPos === component.pos) {\n                    return child.searchNode(paths, pos + 1);\n                  }\n\n                  siblingPos++;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            return node.searchNode(paths, pos + 1);\n          }\n        }\n\n        if (node.childNodes && node.childNodes.length !== 0) {\n          stack.push([node, 0]);\n          node = node.childNodes[0];\n        } else if (stack.length === 0) {\n          return null;\n        } else {\n          while (stack.length !== 0) {\n            var _stack$pop3 = stack.pop(),\n                _stack$pop4 = _slicedToArray(_stack$pop3, 2),\n                _parent = _stack$pop4[0],\n                currentPos = _stack$pop4[1];\n\n            var newPos = currentPos + 1;\n\n            if (newPos < _parent.childNodes.length) {\n              stack.push([_parent, newPos]);\n              node = _parent.childNodes[newPos];\n              break;\n            }\n          }\n\n          if (stack.length === 0) {\n            return null;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"dump\",\n    value: function dump(buffer) {\n      if (this.nodeName === \"#text\") {\n        buffer.push((0, _util.encodeToXmlString)(this.nodeValue));\n        return;\n      }\n\n      buffer.push(\"<\".concat(this.nodeName));\n\n      if (this.attributes) {\n        var _iterator2 = _createForOfIteratorHelper(this.attributes),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var attribute = _step2.value;\n            buffer.push(\" \".concat(attribute.name, \"=\\\"\").concat((0, _util.encodeToXmlString)(attribute.value), \"\\\"\"));\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      if (this.hasChildNodes()) {\n        buffer.push(\">\");\n\n        var _iterator3 = _createForOfIteratorHelper(this.childNodes),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var child = _step3.value;\n            child.dump(buffer);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        buffer.push(\"</\".concat(this.nodeName, \">\"));\n      } else if (this.nodeValue) {\n        buffer.push(\">\".concat((0, _util.encodeToXmlString)(this.nodeValue), \"</\").concat(this.nodeName, \">\"));\n      } else {\n        buffer.push(\"/>\");\n      }\n    }\n  }]);\n\n  return SimpleDOMNode;\n}();\n\nexports.SimpleDOMNode = SimpleDOMNode;\n\nvar SimpleXMLParser = /*#__PURE__*/function (_XMLParserBase) {\n  _inherits(SimpleXMLParser, _XMLParserBase);\n\n  var _super = _createSuper(SimpleXMLParser);\n\n  function SimpleXMLParser(_ref) {\n    var _this2;\n\n    var _ref$hasAttributes = _ref.hasAttributes,\n        hasAttributes = _ref$hasAttributes === void 0 ? false : _ref$hasAttributes,\n        _ref$lowerCaseName = _ref.lowerCaseName,\n        lowerCaseName = _ref$lowerCaseName === void 0 ? false : _ref$lowerCaseName;\n\n    _classCallCheck(this, SimpleXMLParser);\n\n    _this2 = _super.call(this);\n    _this2._currentFragment = null;\n    _this2._stack = null;\n    _this2._errorCode = XMLParserErrorCode.NoError;\n    _this2._hasAttributes = hasAttributes;\n    _this2._lowerCaseName = lowerCaseName;\n    return _this2;\n  }\n\n  _createClass(SimpleXMLParser, [{\n    key: \"parseFromString\",\n    value: function parseFromString(data) {\n      this._currentFragment = [];\n      this._stack = [];\n      this._errorCode = XMLParserErrorCode.NoError;\n      this.parseXml(data);\n\n      if (this._errorCode !== XMLParserErrorCode.NoError) {\n        return undefined;\n      }\n\n      var _this$_currentFragmen = _slicedToArray(this._currentFragment, 1),\n          documentElement = _this$_currentFragmen[0];\n\n      if (!documentElement) {\n        return undefined;\n      }\n\n      return {\n        documentElement: documentElement\n      };\n    }\n  }, {\n    key: \"onText\",\n    value: function onText(text) {\n      if (isWhitespaceString(text)) {\n        return;\n      }\n\n      var node = new SimpleDOMNode(\"#text\", text);\n\n      this._currentFragment.push(node);\n    }\n  }, {\n    key: \"onCdata\",\n    value: function onCdata(text) {\n      var node = new SimpleDOMNode(\"#text\", text);\n\n      this._currentFragment.push(node);\n    }\n  }, {\n    key: \"onBeginElement\",\n    value: function onBeginElement(name, attributes, isEmpty) {\n      if (this._lowerCaseName) {\n        name = name.toLowerCase();\n      }\n\n      var node = new SimpleDOMNode(name);\n      node.childNodes = [];\n\n      if (this._hasAttributes) {\n        node.attributes = attributes;\n      }\n\n      this._currentFragment.push(node);\n\n      if (isEmpty) {\n        return;\n      }\n\n      this._stack.push(this._currentFragment);\n\n      this._currentFragment = node.childNodes;\n    }\n  }, {\n    key: \"onEndElement\",\n    value: function onEndElement(name) {\n      this._currentFragment = this._stack.pop() || [];\n      var lastElement = this._currentFragment[this._currentFragment.length - 1];\n\n      if (!lastElement) {\n        return;\n      }\n\n      for (var i = 0, ii = lastElement.childNodes.length; i < ii; i++) {\n        lastElement.childNodes[i].parentNode = lastElement;\n      }\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(code) {\n      this._errorCode = code;\n    }\n  }]);\n\n  return SimpleXMLParser;\n}(XMLParserBase);\n\nexports.SimpleXMLParser = SimpleXMLParser;\n\n/***/ }),\n/* 146 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.OptionalContentConfig = void 0;\n\nvar _util = __w_pdfjs_require__(4);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar OptionalContentGroup = function OptionalContentGroup(name, intent) {\n  _classCallCheck(this, OptionalContentGroup);\n\n  this.visible = true;\n  this.name = name;\n  this.intent = intent;\n};\n\nvar OptionalContentConfig = /*#__PURE__*/function () {\n  function OptionalContentConfig(data) {\n    _classCallCheck(this, OptionalContentConfig);\n\n    this.name = null;\n    this.creator = null;\n    this._order = null;\n    this._groups = new Map();\n\n    if (data === null) {\n      return;\n    }\n\n    this.name = data.name;\n    this.creator = data.creator;\n    this._order = data.order;\n\n    var _iterator = _createForOfIteratorHelper(data.groups),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _group = _step.value;\n\n        this._groups.set(_group.id, new OptionalContentGroup(_group.name, _group.intent));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (data.baseState === \"OFF\") {\n      var _iterator2 = _createForOfIteratorHelper(this._groups),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var group = _step2.value;\n          group.visible = false;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n\n    var _iterator3 = _createForOfIteratorHelper(data.on),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var on = _step3.value;\n        this._groups.get(on).visible = true;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var _iterator4 = _createForOfIteratorHelper(data.off),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var off = _step4.value;\n        this._groups.get(off).visible = false;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n\n  _createClass(OptionalContentConfig, [{\n    key: \"isVisible\",\n    value: function isVisible(group) {\n      if (!group) {\n        (0, _util.warn)(\"Optional content group not defined.\");\n        return true;\n      }\n\n      if (group.type === \"OCG\") {\n        if (!this._groups.has(group.id)) {\n          (0, _util.warn)(\"Optional content group not found: \".concat(group.id));\n          return true;\n        }\n\n        return this._groups.get(group.id).visible;\n      } else if (group.type === \"OCMD\") {\n        if (group.expression) {\n          (0, _util.warn)(\"Visibility expression not supported yet.\");\n        }\n\n        if (!group.policy || group.policy === \"AnyOn\") {\n          var _iterator5 = _createForOfIteratorHelper(group.ids),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var id = _step5.value;\n\n              if (!this._groups.has(id)) {\n                (0, _util.warn)(\"Optional content group not found: \".concat(id));\n                return true;\n              }\n\n              if (this._groups.get(id).visible) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          return false;\n        } else if (group.policy === \"AllOn\") {\n          var _iterator6 = _createForOfIteratorHelper(group.ids),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _id = _step6.value;\n\n              if (!this._groups.has(_id)) {\n                (0, _util.warn)(\"Optional content group not found: \".concat(_id));\n                return true;\n              }\n\n              if (!this._groups.get(_id).visible) {\n                return false;\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          return true;\n        } else if (group.policy === \"AnyOff\") {\n          var _iterator7 = _createForOfIteratorHelper(group.ids),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _id2 = _step7.value;\n\n              if (!this._groups.has(_id2)) {\n                (0, _util.warn)(\"Optional content group not found: \".concat(_id2));\n                return true;\n              }\n\n              if (!this._groups.get(_id2).visible) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n\n          return false;\n        } else if (group.policy === \"AllOff\") {\n          var _iterator8 = _createForOfIteratorHelper(group.ids),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _id3 = _step8.value;\n\n              if (!this._groups.has(_id3)) {\n                (0, _util.warn)(\"Optional content group not found: \".concat(_id3));\n                return true;\n              }\n\n              if (this._groups.get(_id3).visible) {\n                return false;\n              }\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n\n          return true;\n        }\n\n        (0, _util.warn)(\"Unknown optional content policy \".concat(group.policy, \".\"));\n        return true;\n      }\n\n      (0, _util.warn)(\"Unknown group type \".concat(group.type, \".\"));\n      return true;\n    }\n  }, {\n    key: \"setVisibility\",\n    value: function setVisibility(id) {\n      var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!this._groups.has(id)) {\n        (0, _util.warn)(\"Optional content group not found: \".concat(id));\n        return;\n      }\n\n      this._groups.get(id).visible = !!visible;\n    }\n  }, {\n    key: \"getOrder\",\n    value: function getOrder() {\n      if (!this._groups.size) {\n        return null;\n      }\n\n      if (this._order) {\n        return this._order.slice();\n      }\n\n      return Array.from(this._groups.keys());\n    }\n  }, {\n    key: \"getGroups\",\n    value: function getGroups() {\n      if (!this._groups.size) {\n        return null;\n      }\n\n      return (0, _util.objectFromEntries)(this._groups);\n    }\n  }, {\n    key: \"getGroup\",\n    value: function getGroup(id) {\n      return this._groups.get(id) || null;\n    }\n  }]);\n\n  return OptionalContentConfig;\n}();\n\nexports.OptionalContentConfig = OptionalContentConfig;\n\n/***/ }),\n/* 147 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFDataTransportStream = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar PDFDataTransportStream = /*#__PURE__*/function () {\n  function PDFDataTransportStream(params, pdfDataRangeTransport) {\n    var _this = this;\n\n    _classCallCheck(this, PDFDataTransportStream);\n\n    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n    this._queuedChunks = [];\n    this._progressiveDone = params.progressiveDone || false;\n    var initialData = params.initialData;\n\n    if ((initialData === null || initialData === void 0 ? void 0 : initialData.length) > 0) {\n      var buffer = new Uint8Array(initialData).buffer;\n\n      this._queuedChunks.push(buffer);\n    }\n\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !params.disableStream;\n    this._isRangeSupported = !params.disableRange;\n    this._contentLength = params.length;\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n\n    this._pdfDataRangeTransport.addRangeListener(function (begin, chunk) {\n      _this._onReceiveData({\n        begin: begin,\n        chunk: chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressListener(function (loaded, total) {\n      _this._onProgress({\n        loaded: loaded,\n        total: total\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveReadListener(function (chunk) {\n      _this._onReceiveData({\n        chunk: chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveDoneListener(function () {\n      _this._onProgressiveDone();\n    });\n\n    this._pdfDataRangeTransport.transportReady();\n  }\n\n  _createClass(PDFDataTransportStream, [{\n    key: \"_onReceiveData\",\n    value: function _onReceiveData(args) {\n      var buffer = new Uint8Array(args.chunk).buffer;\n\n      if (args.begin === undefined) {\n        if (this._fullRequestReader) {\n          this._fullRequestReader._enqueue(buffer);\n        } else {\n          this._queuedChunks.push(buffer);\n        }\n      } else {\n        var found = this._rangeReaders.some(function (rangeReader) {\n          if (rangeReader._begin !== args.begin) {\n            return false;\n          }\n\n          rangeReader._enqueue(buffer);\n\n          return true;\n        });\n\n        (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n      }\n    }\n  }, {\n    key: \"_progressiveDataLength\",\n    get: function get() {\n      var _this$_fullRequestRea, _this$_fullRequestRea2;\n\n      return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;\n    }\n  }, {\n    key: \"_onProgress\",\n    value: function _onProgress(evt) {\n      if (evt.total === undefined) {\n        var firstReader = this._rangeReaders[0];\n\n        if (firstReader !== null && firstReader !== void 0 && firstReader.onProgress) {\n          firstReader.onProgress({\n            loaded: evt.loaded\n          });\n        }\n      } else {\n        var fullReader = this._fullRequestReader;\n\n        if (fullReader !== null && fullReader !== void 0 && fullReader.onProgress) {\n          fullReader.onProgress({\n            loaded: evt.loaded,\n            total: evt.total\n          });\n        }\n      }\n    }\n  }, {\n    key: \"_onProgressiveDone\",\n    value: function _onProgressiveDone() {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.progressiveDone();\n      }\n\n      this._progressiveDone = true;\n    }\n  }, {\n    key: \"_removeRangeReader\",\n    value: function _removeRangeReader(reader) {\n      var i = this._rangeReaders.indexOf(reader);\n\n      if (i >= 0) {\n        this._rangeReaders.splice(i, 1);\n      }\n    }\n  }, {\n    key: \"getFullReader\",\n    value: function getFullReader() {\n      (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n      var queuedChunks = this._queuedChunks;\n      this._queuedChunks = null;\n      return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone);\n    }\n  }, {\n    key: \"getRangeReader\",\n    value: function getRangeReader(begin, end) {\n      if (end <= this._progressiveDataLength) {\n        return null;\n      }\n\n      var reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n\n      this._pdfDataRangeTransport.requestDataRange(begin, end);\n\n      this._rangeReaders.push(reader);\n\n      return reader;\n    }\n  }, {\n    key: \"cancelAllRequests\",\n    value: function cancelAllRequests(reason) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.cancel(reason);\n      }\n\n      var readers = this._rangeReaders.slice(0);\n\n      readers.forEach(function (rangeReader) {\n        rangeReader.cancel(reason);\n      });\n\n      this._pdfDataRangeTransport.abort();\n    }\n  }]);\n\n  return PDFDataTransportStream;\n}();\n\nexports.PDFDataTransportStream = PDFDataTransportStream;\n\nvar PDFDataTransportStreamReader = /*#__PURE__*/function () {\n  function PDFDataTransportStreamReader(stream, queuedChunks) {\n    var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, PDFDataTransportStreamReader);\n\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n\n    var _iterator = _createForOfIteratorHelper(this._queuedChunks),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var chunk = _step.value;\n        this._loaded += chunk.byteLength;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n    this.onProgress = null;\n  }\n\n  _createClass(PDFDataTransportStreamReader, [{\n    key: \"_enqueue\",\n    value: function _enqueue(chunk) {\n      if (this._done) {\n        return;\n      }\n\n      if (this._requests.length > 0) {\n        var requestCapability = this._requests.shift();\n\n        requestCapability.resolve({\n          value: chunk,\n          done: false\n        });\n      } else {\n        this._queuedChunks.push(chunk);\n      }\n\n      this._loaded += chunk.byteLength;\n    }\n  }, {\n    key: \"headersReady\",\n    get: function get() {\n      return this._headersReady;\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._filename;\n    }\n  }, {\n    key: \"isRangeSupported\",\n    get: function get() {\n      return this._stream._isRangeSupported;\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return this._stream._isStreamingSupported;\n    }\n  }, {\n    key: \"contentLength\",\n    get: function get() {\n      return this._stream._contentLength;\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var chunk, requestCapability;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this._queuedChunks.length > 0)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                chunk = this._queuedChunks.shift();\n                return _context.abrupt(\"return\", {\n                  value: chunk,\n                  done: false\n                });\n\n              case 3:\n                if (!this._done) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  value: undefined,\n                  done: true\n                });\n\n              case 5:\n                requestCapability = (0, _util.createPromiseCapability)();\n\n                this._requests.push(requestCapability);\n\n                return _context.abrupt(\"return\", requestCapability.promise);\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function read() {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      this._done = true;\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n    }\n  }, {\n    key: \"progressiveDone\",\n    value: function progressiveDone() {\n      if (this._done) {\n        return;\n      }\n\n      this._done = true;\n    }\n  }]);\n\n  return PDFDataTransportStreamReader;\n}();\n\nvar PDFDataTransportStreamRangeReader = /*#__PURE__*/function () {\n  function PDFDataTransportStreamRangeReader(stream, begin, end) {\n    _classCallCheck(this, PDFDataTransportStreamRangeReader);\n\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n    this.onProgress = null;\n  }\n\n  _createClass(PDFDataTransportStreamRangeReader, [{\n    key: \"_enqueue\",\n    value: function _enqueue(chunk) {\n      if (this._done) {\n        return;\n      }\n\n      if (this._requests.length === 0) {\n        this._queuedChunk = chunk;\n      } else {\n        var requestsCapability = this._requests.shift();\n\n        requestsCapability.resolve({\n          value: chunk,\n          done: false\n        });\n\n        this._requests.forEach(function (requestCapability) {\n          requestCapability.resolve({\n            value: undefined,\n            done: true\n          });\n        });\n\n        this._requests = [];\n      }\n\n      this._done = true;\n\n      this._stream._removeRangeReader(this);\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n        var chunk, requestCapability;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._queuedChunk) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                chunk = this._queuedChunk;\n                this._queuedChunk = null;\n                return _context2.abrupt(\"return\", {\n                  value: chunk,\n                  done: false\n                });\n\n              case 4:\n                if (!this._done) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: undefined,\n                  done: true\n                });\n\n              case 6:\n                requestCapability = (0, _util.createPromiseCapability)();\n\n                this._requests.push(requestCapability);\n\n                return _context2.abrupt(\"return\", requestCapability.promise);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function read() {\n        return _read2.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      this._done = true;\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n\n      this._stream._removeRangeReader(this);\n    }\n  }]);\n\n  return PDFDataTransportStreamRangeReader;\n}();\n\n/***/ }),\n/* 148 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.WebGLContext = void 0;\n\nvar _util = __w_pdfjs_require__(4);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar WebGLContext = /*#__PURE__*/function () {\n  function WebGLContext(_ref) {\n    var _ref$enable = _ref.enable,\n        enable = _ref$enable === void 0 ? false : _ref$enable;\n\n    _classCallCheck(this, WebGLContext);\n\n    this._enabled = enable === true;\n  }\n\n  _createClass(WebGLContext, [{\n    key: \"isEnabled\",\n    get: function get() {\n      var enabled = this._enabled;\n\n      if (enabled) {\n        enabled = WebGLUtils.tryInitGL();\n      }\n\n      return (0, _util.shadow)(this, \"isEnabled\", enabled);\n    }\n  }, {\n    key: \"composeSMask\",\n    value: function composeSMask(_ref2) {\n      var layer = _ref2.layer,\n          mask = _ref2.mask,\n          properties = _ref2.properties;\n      return WebGLUtils.composeSMask(layer, mask, properties);\n    }\n  }, {\n    key: \"drawFigures\",\n    value: function drawFigures(_ref3) {\n      var width = _ref3.width,\n          height = _ref3.height,\n          backgroundColor = _ref3.backgroundColor,\n          figures = _ref3.figures,\n          context = _ref3.context;\n      return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      WebGLUtils.cleanup();\n    }\n  }]);\n\n  return WebGLContext;\n}();\n\nexports.WebGLContext = WebGLContext;\n\nvar WebGLUtils = function WebGLUtilsClosure() {\n  function loadShader(gl, code, shaderType) {\n    var shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, code);\n    gl.compileShader(shader);\n    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n    if (!compiled) {\n      var errorMsg = gl.getShaderInfoLog(shader);\n      throw new Error(\"Error during shader compilation: \" + errorMsg);\n    }\n\n    return shader;\n  }\n\n  function createVertexShader(gl, code) {\n    return loadShader(gl, code, gl.VERTEX_SHADER);\n  }\n\n  function createFragmentShader(gl, code) {\n    return loadShader(gl, code, gl.FRAGMENT_SHADER);\n  }\n\n  function createProgram(gl, shaders) {\n    var program = gl.createProgram();\n\n    for (var i = 0, ii = shaders.length; i < ii; ++i) {\n      gl.attachShader(program, shaders[i]);\n    }\n\n    gl.linkProgram(program);\n    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n    if (!linked) {\n      var errorMsg = gl.getProgramInfoLog(program);\n      throw new Error(\"Error during program linking: \" + errorMsg);\n    }\n\n    return program;\n  }\n\n  function createTexture(gl, image, textureId) {\n    gl.activeTexture(textureId);\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n    return texture;\n  }\n\n  var currentGL, currentCanvas;\n\n  function generateGL() {\n    if (currentGL) {\n      return;\n    }\n\n    currentCanvas = document.createElement(\"canvas\");\n    currentGL = currentCanvas.getContext(\"webgl\", {\n      premultipliedalpha: false\n    });\n  }\n\n  var smaskVertexShaderCode = \"\\\n  attribute vec2 a_position;                                    \\\n  attribute vec2 a_texCoord;                                    \\\n                                                                \\\n  uniform vec2 u_resolution;                                    \\\n                                                                \\\n  varying vec2 v_texCoord;                                      \\\n                                                                \\\n  void main() {                                                 \\\n    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \\\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\n                                                                \\\n    v_texCoord = a_texCoord;                                    \\\n  }                                                             \";\n  var smaskFragmentShaderCode = \"\\\n  precision mediump float;                                      \\\n                                                                \\\n  uniform vec4 u_backdrop;                                      \\\n  uniform int u_subtype;                                        \\\n  uniform sampler2D u_image;                                    \\\n  uniform sampler2D u_mask;                                     \\\n                                                                \\\n  varying vec2 v_texCoord;                                      \\\n                                                                \\\n  void main() {                                                 \\\n    vec4 imageColor = texture2D(u_image, v_texCoord);           \\\n    vec4 maskColor = texture2D(u_mask, v_texCoord);             \\\n    if (u_backdrop.a > 0.0) {                                   \\\n      maskColor.rgb = maskColor.rgb * maskColor.a +             \\\n                      u_backdrop.rgb * (1.0 - maskColor.a);     \\\n    }                                                           \\\n    float lum;                                                  \\\n    if (u_subtype == 0) {                                       \\\n      lum = maskColor.a;                                        \\\n    } else {                                                    \\\n      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \\\n            maskColor.b * 0.11;                                 \\\n    }                                                           \\\n    imageColor.a *= lum;                                        \\\n    imageColor.rgb *= imageColor.a;                             \\\n    gl_FragColor = imageColor;                                  \\\n  }                                                             \";\n  var smaskCache = null;\n\n  function initSmaskGL() {\n    generateGL();\n    var canvas = currentCanvas;\n    currentCanvas = null;\n    var gl = currentGL;\n    currentGL = null;\n    var vertexShader = createVertexShader(gl, smaskVertexShaderCode);\n    var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);\n    var program = createProgram(gl, [vertexShader, fragmentShader]);\n    gl.useProgram(program);\n    var cache = {};\n    cache.gl = gl;\n    cache.canvas = canvas;\n    cache.resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n    cache.positionLocation = gl.getAttribLocation(program, \"a_position\");\n    cache.backdropLocation = gl.getUniformLocation(program, \"u_backdrop\");\n    cache.subtypeLocation = gl.getUniformLocation(program, \"u_subtype\");\n    var texCoordLocation = gl.getAttribLocation(program, \"a_texCoord\");\n    var texLayerLocation = gl.getUniformLocation(program, \"u_image\");\n    var texMaskLocation = gl.getUniformLocation(program, \"u_mask\");\n    var texCoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(texCoordLocation);\n    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.uniform1i(texLayerLocation, 0);\n    gl.uniform1i(texMaskLocation, 1);\n    smaskCache = cache;\n  }\n\n  function composeSMask(layer, mask, properties) {\n    var width = layer.width,\n        height = layer.height;\n\n    if (!smaskCache) {\n      initSmaskGL();\n    }\n\n    var cache = smaskCache,\n        canvas = cache.canvas,\n        gl = cache.gl;\n    canvas.width = width;\n    canvas.height = height;\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.uniform2f(cache.resolutionLocation, width, height);\n\n    if (properties.backdrop) {\n      gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);\n    } else {\n      gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);\n    }\n\n    gl.uniform1i(cache.subtypeLocation, properties.subtype === \"Luminosity\" ? 1 : 0);\n    var texture = createTexture(gl, layer, gl.TEXTURE0);\n    var maskTexture = createTexture(gl, mask, gl.TEXTURE1);\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(cache.positionLocation);\n    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.clearColor(0, 0, 0, 0);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    gl.flush();\n    gl.deleteTexture(texture);\n    gl.deleteTexture(maskTexture);\n    gl.deleteBuffer(buffer);\n    return canvas;\n  }\n\n  var figuresVertexShaderCode = \"\\\n  attribute vec2 a_position;                                    \\\n  attribute vec3 a_color;                                       \\\n                                                                \\\n  uniform vec2 u_resolution;                                    \\\n  uniform vec2 u_scale;                                         \\\n  uniform vec2 u_offset;                                        \\\n                                                                \\\n  varying vec4 v_color;                                         \\\n                                                                \\\n  void main() {                                                 \\\n    vec2 position = (a_position + u_offset) * u_scale;          \\\n    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \\\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\n                                                                \\\n    v_color = vec4(a_color / 255.0, 1.0);                       \\\n  }                                                             \";\n  var figuresFragmentShaderCode = \"\\\n  precision mediump float;                                      \\\n                                                                \\\n  varying vec4 v_color;                                         \\\n                                                                \\\n  void main() {                                                 \\\n    gl_FragColor = v_color;                                     \\\n  }                                                             \";\n  var figuresCache = null;\n\n  function initFiguresGL() {\n    generateGL();\n    var canvas = currentCanvas;\n    currentCanvas = null;\n    var gl = currentGL;\n    currentGL = null;\n    var vertexShader = createVertexShader(gl, figuresVertexShaderCode);\n    var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);\n    var program = createProgram(gl, [vertexShader, fragmentShader]);\n    gl.useProgram(program);\n    var cache = {};\n    cache.gl = gl;\n    cache.canvas = canvas;\n    cache.resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n    cache.scaleLocation = gl.getUniformLocation(program, \"u_scale\");\n    cache.offsetLocation = gl.getUniformLocation(program, \"u_offset\");\n    cache.positionLocation = gl.getAttribLocation(program, \"a_position\");\n    cache.colorLocation = gl.getAttribLocation(program, \"a_color\");\n    figuresCache = cache;\n  }\n\n  function drawFigures(width, height, backgroundColor, figures, context) {\n    if (!figuresCache) {\n      initFiguresGL();\n    }\n\n    var cache = figuresCache,\n        canvas = cache.canvas,\n        gl = cache.gl;\n    canvas.width = width;\n    canvas.height = height;\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.uniform2f(cache.resolutionLocation, width, height);\n    var count = 0;\n\n    for (var i = 0, ii = figures.length; i < ii; i++) {\n      switch (figures[i].type) {\n        case \"lattice\":\n          var rows = figures[i].coords.length / figures[i].verticesPerRow | 0;\n          count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;\n          break;\n\n        case \"triangles\":\n          count += figures[i].coords.length;\n          break;\n      }\n    }\n\n    var coords = new Float32Array(count * 2);\n    var colors = new Uint8Array(count * 3);\n    var coordsMap = context.coords,\n        colorsMap = context.colors;\n    var pIndex = 0,\n        cIndex = 0;\n\n    for (var _i = 0, _ii = figures.length; _i < _ii; _i++) {\n      var figure = figures[_i],\n          ps = figure.coords,\n          cs = figure.colors;\n\n      switch (figure.type) {\n        case \"lattice\":\n          var cols = figure.verticesPerRow;\n\n          var _rows = ps.length / cols | 0;\n\n          for (var row = 1; row < _rows; row++) {\n            var offset = row * cols + 1;\n\n            for (var col = 1; col < cols; col++, offset++) {\n              coords[pIndex] = coordsMap[ps[offset - cols - 1]];\n              coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];\n              coords[pIndex + 2] = coordsMap[ps[offset - cols]];\n              coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];\n              coords[pIndex + 4] = coordsMap[ps[offset - 1]];\n              coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];\n              colors[cIndex] = colorsMap[cs[offset - cols - 1]];\n              colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];\n              colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];\n              colors[cIndex + 3] = colorsMap[cs[offset - cols]];\n              colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];\n              colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];\n              colors[cIndex + 6] = colorsMap[cs[offset - 1]];\n              colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];\n              colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];\n              coords[pIndex + 6] = coords[pIndex + 2];\n              coords[pIndex + 7] = coords[pIndex + 3];\n              coords[pIndex + 8] = coords[pIndex + 4];\n              coords[pIndex + 9] = coords[pIndex + 5];\n              coords[pIndex + 10] = coordsMap[ps[offset]];\n              coords[pIndex + 11] = coordsMap[ps[offset] + 1];\n              colors[cIndex + 9] = colors[cIndex + 3];\n              colors[cIndex + 10] = colors[cIndex + 4];\n              colors[cIndex + 11] = colors[cIndex + 5];\n              colors[cIndex + 12] = colors[cIndex + 6];\n              colors[cIndex + 13] = colors[cIndex + 7];\n              colors[cIndex + 14] = colors[cIndex + 8];\n              colors[cIndex + 15] = colorsMap[cs[offset]];\n              colors[cIndex + 16] = colorsMap[cs[offset] + 1];\n              colors[cIndex + 17] = colorsMap[cs[offset] + 2];\n              pIndex += 12;\n              cIndex += 18;\n            }\n          }\n\n          break;\n\n        case \"triangles\":\n          for (var j = 0, jj = ps.length; j < jj; j++) {\n            coords[pIndex] = coordsMap[ps[j]];\n            coords[pIndex + 1] = coordsMap[ps[j] + 1];\n            colors[cIndex] = colorsMap[cs[j]];\n            colors[cIndex + 1] = colorsMap[cs[j] + 1];\n            colors[cIndex + 2] = colorsMap[cs[j] + 2];\n            pIndex += 2;\n            cIndex += 3;\n          }\n\n          break;\n      }\n    }\n\n    if (backgroundColor) {\n      gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);\n    } else {\n      gl.clearColor(0, 0, 0, 0);\n    }\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    var coordsBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(cache.positionLocation);\n    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    var colorsBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(cache.colorLocation);\n    gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);\n    gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);\n    gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);\n    gl.drawArrays(gl.TRIANGLES, 0, count);\n    gl.flush();\n    gl.deleteBuffer(coordsBuffer);\n    gl.deleteBuffer(colorsBuffer);\n    return canvas;\n  }\n\n  return {\n    tryInitGL: function tryInitGL() {\n      try {\n        generateGL();\n        return !!currentGL;\n      } catch (ex) {}\n\n      return false;\n    },\n    composeSMask: composeSMask,\n    drawFigures: drawFigures,\n    cleanup: function cleanup() {\n      var _smaskCache, _figuresCache;\n\n      if ((_smaskCache = smaskCache) !== null && _smaskCache !== void 0 && _smaskCache.canvas) {\n        smaskCache.canvas.width = 0;\n        smaskCache.canvas.height = 0;\n      }\n\n      if ((_figuresCache = figuresCache) !== null && _figuresCache !== void 0 && _figuresCache.canvas) {\n        figuresCache.canvas.width = 0;\n        figuresCache.canvas.height = 0;\n      }\n\n      smaskCache = null;\n      figuresCache = null;\n    }\n  };\n}();\n\n/***/ }),\n/* 149 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationLayer = void 0;\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _util = __w_pdfjs_require__(4);\n\nvar _annotation_storage = __w_pdfjs_require__(138);\n\nvar _scripting_utils = __w_pdfjs_require__(150);\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AnnotationElementFactory = /*#__PURE__*/function () {\n  function AnnotationElementFactory() {\n    _classCallCheck(this, AnnotationElementFactory);\n  }\n\n  _createClass(AnnotationElementFactory, null, [{\n    key: \"create\",\n    value: function create(parameters) {\n      var subtype = parameters.data.annotationType;\n\n      switch (subtype) {\n        case _util.AnnotationType.LINK:\n          return new LinkAnnotationElement(parameters);\n\n        case _util.AnnotationType.TEXT:\n          return new TextAnnotationElement(parameters);\n\n        case _util.AnnotationType.WIDGET:\n          var fieldType = parameters.data.fieldType;\n\n          switch (fieldType) {\n            case \"Tx\":\n              return new TextWidgetAnnotationElement(parameters);\n\n            case \"Btn\":\n              if (parameters.data.radioButton) {\n                return new RadioButtonWidgetAnnotationElement(parameters);\n              } else if (parameters.data.checkBox) {\n                return new CheckboxWidgetAnnotationElement(parameters);\n              }\n\n              return new PushButtonWidgetAnnotationElement(parameters);\n\n            case \"Ch\":\n              return new ChoiceWidgetAnnotationElement(parameters);\n          }\n\n          return new WidgetAnnotationElement(parameters);\n\n        case _util.AnnotationType.POPUP:\n          return new PopupAnnotationElement(parameters);\n\n        case _util.AnnotationType.FREETEXT:\n          return new FreeTextAnnotationElement(parameters);\n\n        case _util.AnnotationType.LINE:\n          return new LineAnnotationElement(parameters);\n\n        case _util.AnnotationType.SQUARE:\n          return new SquareAnnotationElement(parameters);\n\n        case _util.AnnotationType.CIRCLE:\n          return new CircleAnnotationElement(parameters);\n\n        case _util.AnnotationType.POLYLINE:\n          return new PolylineAnnotationElement(parameters);\n\n        case _util.AnnotationType.CARET:\n          return new CaretAnnotationElement(parameters);\n\n        case _util.AnnotationType.INK:\n          return new InkAnnotationElement(parameters);\n\n        case _util.AnnotationType.POLYGON:\n          return new PolygonAnnotationElement(parameters);\n\n        case _util.AnnotationType.HIGHLIGHT:\n          return new HighlightAnnotationElement(parameters);\n\n        case _util.AnnotationType.UNDERLINE:\n          return new UnderlineAnnotationElement(parameters);\n\n        case _util.AnnotationType.SQUIGGLY:\n          return new SquigglyAnnotationElement(parameters);\n\n        case _util.AnnotationType.STRIKEOUT:\n          return new StrikeOutAnnotationElement(parameters);\n\n        case _util.AnnotationType.STAMP:\n          return new StampAnnotationElement(parameters);\n\n        case _util.AnnotationType.FILEATTACHMENT:\n          return new FileAttachmentAnnotationElement(parameters);\n\n        default:\n          return new AnnotationElement(parameters);\n      }\n    }\n  }]);\n\n  return AnnotationElementFactory;\n}();\n\nvar AnnotationElement = /*#__PURE__*/function () {\n  function AnnotationElement(parameters) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$isRenderable = _ref.isRenderable,\n        isRenderable = _ref$isRenderable === void 0 ? false : _ref$isRenderable,\n        _ref$ignoreBorder = _ref.ignoreBorder,\n        ignoreBorder = _ref$ignoreBorder === void 0 ? false : _ref$ignoreBorder,\n        _ref$createQuadrilate = _ref.createQuadrilaterals,\n        createQuadrilaterals = _ref$createQuadrilate === void 0 ? false : _ref$createQuadrilate;\n\n    _classCallCheck(this, AnnotationElement);\n\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.page = parameters.page;\n    this.viewport = parameters.viewport;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderInteractiveForms = parameters.renderInteractiveForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n    this.enableScripting = parameters.enableScripting;\n    this.hasJSActions = parameters.hasJSActions;\n    this._mouseState = parameters.mouseState;\n\n    if (isRenderable) {\n      this.container = this._createContainer(ignoreBorder);\n    }\n\n    if (createQuadrilaterals) {\n      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);\n    }\n  }\n\n  _createClass(AnnotationElement, [{\n    key: \"_createContainer\",\n    value: function _createContainer() {\n      var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var data = this.data,\n          page = this.page,\n          viewport = this.viewport;\n      var container = document.createElement(\"section\");\n      var width = data.rect[2] - data.rect[0];\n      var height = data.rect[3] - data.rect[1];\n      container.setAttribute(\"data-annotation-id\", data.id);\n\n      var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n\n      container.style.transform = \"matrix(\".concat(viewport.transform.join(\",\"), \")\");\n      container.style.transformOrigin = \"\".concat(-rect[0], \"px \").concat(-rect[1], \"px\");\n\n      if (!ignoreBorder && data.borderStyle.width > 0) {\n        container.style.borderWidth = \"\".concat(data.borderStyle.width, \"px\");\n\n        if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {\n          width = width - 2 * data.borderStyle.width;\n          height = height - 2 * data.borderStyle.width;\n        }\n\n        var horizontalRadius = data.borderStyle.horizontalCornerRadius;\n        var verticalRadius = data.borderStyle.verticalCornerRadius;\n\n        if (horizontalRadius > 0 || verticalRadius > 0) {\n          var radius = \"\".concat(horizontalRadius, \"px / \").concat(verticalRadius, \"px\");\n          container.style.borderRadius = radius;\n        }\n\n        switch (data.borderStyle.style) {\n          case _util.AnnotationBorderStyleType.SOLID:\n            container.style.borderStyle = \"solid\";\n            break;\n\n          case _util.AnnotationBorderStyleType.DASHED:\n            container.style.borderStyle = \"dashed\";\n            break;\n\n          case _util.AnnotationBorderStyleType.BEVELED:\n            (0, _util.warn)(\"Unimplemented border style: beveled\");\n            break;\n\n          case _util.AnnotationBorderStyleType.INSET:\n            (0, _util.warn)(\"Unimplemented border style: inset\");\n            break;\n\n          case _util.AnnotationBorderStyleType.UNDERLINE:\n            container.style.borderBottomStyle = \"solid\";\n            break;\n\n          default:\n            break;\n        }\n\n        if (data.color) {\n          container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);\n        } else {\n          container.style.borderWidth = 0;\n        }\n      }\n\n      container.style.left = \"\".concat(rect[0], \"px\");\n      container.style.top = \"\".concat(rect[1], \"px\");\n      container.style.width = \"\".concat(width, \"px\");\n      container.style.height = \"\".concat(height, \"px\");\n      return container;\n    }\n  }, {\n    key: \"_createQuadrilaterals\",\n    value: function _createQuadrilaterals() {\n      var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (!this.data.quadPoints) {\n        return null;\n      }\n\n      var quadrilaterals = [];\n      var savedRect = this.data.rect;\n\n      var _iterator = _createForOfIteratorHelper(this.data.quadPoints),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var quadPoint = _step.value;\n          this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];\n          quadrilaterals.push(this._createContainer(ignoreBorder));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.data.rect = savedRect;\n      return quadrilaterals;\n    }\n  }, {\n    key: \"_createPopup\",\n    value: function _createPopup(trigger, data) {\n      var container = this.container;\n\n      if (this.quadrilaterals) {\n        trigger = trigger || this.quadrilaterals;\n        container = this.quadrilaterals[0];\n      }\n\n      if (!trigger) {\n        trigger = document.createElement(\"div\");\n        trigger.style.height = container.style.height;\n        trigger.style.width = container.style.width;\n        container.appendChild(trigger);\n      }\n\n      var popupElement = new PopupElement({\n        container: container,\n        trigger: trigger,\n        color: data.color,\n        title: data.title,\n        modificationDate: data.modificationDate,\n        contents: data.contents,\n        hideWrapper: true\n      });\n      var popup = popupElement.render();\n      popup.style.left = container.style.width;\n      container.appendChild(popup);\n    }\n  }, {\n    key: \"_renderQuadrilaterals\",\n    value: function _renderQuadrilaterals(className) {\n      this.quadrilaterals.forEach(function (quadrilateral) {\n        quadrilateral.className = className;\n      });\n      return this.quadrilaterals;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n    }\n  }]);\n\n  return AnnotationElement;\n}();\n\nvar LinkAnnotationElement = /*#__PURE__*/function (_AnnotationElement) {\n  _inherits(LinkAnnotationElement, _AnnotationElement);\n\n  var _super = _createSuper(LinkAnnotationElement);\n\n  function LinkAnnotationElement(parameters) {\n    _classCallCheck(this, LinkAnnotationElement);\n\n    var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions[\"Mouse Up\"] || parameters.data.actions[\"Mouse Down\"]));\n    return _super.call(this, parameters, {\n      isRenderable: isRenderable,\n      createQuadrilaterals: true\n    });\n  }\n\n  _createClass(LinkAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      var data = this.data,\n          linkService = this.linkService;\n      var link = document.createElement(\"a\");\n\n      if (data.url) {\n        (0, _display_utils.addLinkAttributes)(link, {\n          url: data.url,\n          target: data.newWindow ? _display_utils.LinkTarget.BLANK : linkService.externalLinkTarget,\n          rel: linkService.externalLinkRel,\n          enabled: linkService.externalLinkEnabled\n        });\n      } else if (data.action) {\n        this._bindNamedAction(link, data.action);\n      } else if (data.dest) {\n        this._bindLink(link, data.dest);\n      } else if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n        this._bindJSAction(link, data);\n      } else {\n        this._bindLink(link, \"\");\n      }\n\n      if (this.quadrilaterals) {\n        return this._renderQuadrilaterals(\"linkAnnotation\").map(function (quadrilateral, index) {\n          var linkElement = index === 0 ? link : link.cloneNode();\n          quadrilateral.appendChild(linkElement);\n          return quadrilateral;\n        });\n      }\n\n      this.container.className = \"linkAnnotation\";\n      this.container.appendChild(link);\n      return this.container;\n    }\n  }, {\n    key: \"_bindLink\",\n    value: function _bindLink(link, destination) {\n      var _this = this;\n\n      link.href = this.linkService.getDestinationHash(destination);\n\n      link.onclick = function () {\n        if (destination) {\n          _this.linkService.goToDestination(destination);\n        }\n\n        return false;\n      };\n\n      if (destination || destination === \"\") {\n        link.className = \"internalLink\";\n      }\n    }\n  }, {\n    key: \"_bindNamedAction\",\n    value: function _bindNamedAction(link, action) {\n      var _this2 = this;\n\n      link.href = this.linkService.getAnchorUrl(\"\");\n\n      link.onclick = function () {\n        _this2.linkService.executeNamedAction(action);\n\n        return false;\n      };\n\n      link.className = \"internalLink\";\n    }\n  }, {\n    key: \"_bindJSAction\",\n    value: function _bindJSAction(link, data) {\n      var _this3 = this;\n\n      link.href = this.linkService.getAnchorUrl(\"\");\n      var map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n\n      var _loop = function _loop() {\n        var name = _Object$keys[_i];\n        var jsName = map.get(name);\n\n        if (!jsName) {\n          return \"continue\";\n        }\n\n        link[jsName] = function () {\n          var _this3$linkService$ev;\n\n          (_this3$linkService$ev = _this3.linkService.eventBus) === null || _this3$linkService$ev === void 0 ? void 0 : _this3$linkService$ev.dispatch(\"dispatcheventinsandbox\", {\n            source: _this3,\n            detail: {\n              id: data.id,\n              name: name\n            }\n          });\n          return false;\n        };\n      };\n\n      for (var _i = 0, _Object$keys = Object.keys(data.actions); _i < _Object$keys.length; _i++) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      }\n\n      link.className = \"internalLink\";\n    }\n  }]);\n\n  return LinkAnnotationElement;\n}(AnnotationElement);\n\nvar TextAnnotationElement = /*#__PURE__*/function (_AnnotationElement2) {\n  _inherits(TextAnnotationElement, _AnnotationElement2);\n\n  var _super2 = _createSuper(TextAnnotationElement);\n\n  function TextAnnotationElement(parameters) {\n    _classCallCheck(this, TextAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super2.call(this, parameters, {\n      isRenderable: isRenderable\n    });\n  }\n\n  _createClass(TextAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"textAnnotation\";\n      var image = document.createElement(\"img\");\n      image.style.height = this.container.style.height;\n      image.style.width = this.container.style.width;\n      image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n      image.alt = \"[{{type}} Annotation]\";\n      image.dataset.l10nId = \"text_annotation_type\";\n      image.dataset.l10nArgs = JSON.stringify({\n        type: this.data.name\n      });\n\n      if (!this.data.hasPopup) {\n        this._createPopup(image, this.data);\n      }\n\n      this.container.appendChild(image);\n      return this.container;\n    }\n  }]);\n\n  return TextAnnotationElement;\n}(AnnotationElement);\n\nvar WidgetAnnotationElement = /*#__PURE__*/function (_AnnotationElement3) {\n  _inherits(WidgetAnnotationElement, _AnnotationElement3);\n\n  var _super3 = _createSuper(WidgetAnnotationElement);\n\n  function WidgetAnnotationElement() {\n    _classCallCheck(this, WidgetAnnotationElement);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(WidgetAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      if (this.data.alternativeText) {\n        this.container.title = this.data.alternativeText;\n      }\n\n      return this.container;\n    }\n  }, {\n    key: \"_getKeyModifier\",\n    value: function _getKeyModifier(event) {\n      return navigator.platform.includes(\"Win\") && event.ctrlKey || navigator.platform.includes(\"Mac\") && event.metaKey;\n    }\n  }, {\n    key: \"_setEventListener\",\n    value: function _setEventListener(element, baseName, eventName, valueGetter) {\n      var _this4 = this;\n\n      if (baseName.includes(\"mouse\")) {\n        element.addEventListener(baseName, function (event) {\n          var _this4$linkService$ev;\n\n          (_this4$linkService$ev = _this4.linkService.eventBus) === null || _this4$linkService$ev === void 0 ? void 0 : _this4$linkService$ev.dispatch(\"dispatcheventinsandbox\", {\n            source: _this4,\n            detail: {\n              id: _this4.data.id,\n              name: eventName,\n              value: valueGetter(event),\n              shift: event.shiftKey,\n              modifier: _this4._getKeyModifier(event)\n            }\n          });\n        });\n      } else {\n        element.addEventListener(baseName, function (event) {\n          var _this4$linkService$ev2;\n\n          (_this4$linkService$ev2 = _this4.linkService.eventBus) === null || _this4$linkService$ev2 === void 0 ? void 0 : _this4$linkService$ev2.dispatch(\"dispatcheventinsandbox\", {\n            source: _this4,\n            detail: {\n              id: _this4.data.id,\n              name: eventName,\n              value: event.target.checked\n            }\n          });\n        });\n      }\n    }\n  }, {\n    key: \"_setEventListeners\",\n    value: function _setEventListeners(element, names, getter) {\n      var _iterator2 = _createForOfIteratorHelper(names),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _this$data$actions;\n\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              baseName = _step2$value[0],\n              eventName = _step2$value[1];\n\n          if (eventName === \"Action\" || (_this$data$actions = this.data.actions) !== null && _this$data$actions !== void 0 && _this$data$actions[eventName]) {\n            this._setEventListener(element, baseName, eventName, getter);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }]);\n\n  return WidgetAnnotationElement;\n}(AnnotationElement);\n\nvar TextWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem) {\n  _inherits(TextWidgetAnnotationElement, _WidgetAnnotationElem);\n\n  var _super4 = _createSuper(TextWidgetAnnotationElement);\n\n  function TextWidgetAnnotationElement(parameters) {\n    _classCallCheck(this, TextWidgetAnnotationElement);\n\n    var isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n    return _super4.call(this, parameters, {\n      isRenderable: isRenderable\n    });\n  }\n\n  _createClass(TextWidgetAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var storage = this.annotationStorage;\n      var id = this.data.id;\n      this.container.className = \"textWidgetAnnotation\";\n      var element = null;\n\n      if (this.renderInteractiveForms) {\n        var textContent = storage.getOrCreateValue(id, {\n          value: this.data.fieldValue\n        }).value;\n        var elementData = {\n          userValue: null,\n          formattedValue: null,\n          beforeInputSelectionRange: null,\n          beforeInputValue: null\n        };\n\n        if (this.data.multiLine) {\n          element = document.createElement(\"textarea\");\n          element.textContent = textContent;\n        } else {\n          element = document.createElement(\"input\");\n          element.type = \"text\";\n          element.setAttribute(\"value\", textContent);\n        }\n\n        elementData.userValue = textContent;\n        element.setAttribute(\"id\", id);\n        element.addEventListener(\"input\", function (event) {\n          storage.setValue(id, {\n            value: event.target.value\n          });\n        });\n\n        var blurListener = function blurListener(event) {\n          if (elementData.formattedValue) {\n            event.target.value = elementData.formattedValue;\n          }\n\n          event.target.setSelectionRange(0, 0);\n          elementData.beforeInputSelectionRange = null;\n        };\n\n        if (this.enableScripting && this.hasJSActions) {\n          var _this$data$actions2;\n\n          element.addEventListener(\"focus\", function (event) {\n            if (elementData.userValue) {\n              event.target.value = elementData.userValue;\n            }\n          });\n          element.addEventListener(\"updatefromsandbox\", function (event) {\n            var detail = event.detail;\n            var actions = {\n              value: function value() {\n                elementData.userValue = detail.value || \"\";\n                storage.setValue(id, {\n                  value: elementData.userValue.toString()\n                });\n\n                if (!elementData.formattedValue) {\n                  event.target.value = elementData.userValue;\n                }\n              },\n              valueAsString: function valueAsString() {\n                elementData.formattedValue = detail.valueAsString || \"\";\n\n                if (event.target !== document.activeElement) {\n                  event.target.value = elementData.formattedValue;\n                }\n\n                storage.setValue(id, {\n                  formattedValue: elementData.formattedValue\n                });\n              },\n              focus: function focus() {\n                setTimeout(function () {\n                  return event.target.focus({\n                    preventScroll: false\n                  });\n                }, 0);\n              },\n              userName: function userName() {\n                event.target.title = detail.userName;\n              },\n              hidden: function hidden() {\n                event.target.style.visibility = detail.hidden ? \"hidden\" : \"visible\";\n                storage.setValue(id, {\n                  hidden: detail.hidden\n                });\n              },\n              editable: function editable() {\n                event.target.disabled = !detail.editable;\n              },\n              selRange: function selRange() {\n                var _detail$selRange = _slicedToArray(detail.selRange, 2),\n                    selStart = _detail$selRange[0],\n                    selEnd = _detail$selRange[1];\n\n                if (selStart >= 0 && selEnd < event.target.value.length) {\n                  event.target.setSelectionRange(selStart, selEnd);\n                }\n              },\n              strokeColor: function strokeColor() {\n                var color = detail.strokeColor;\n                event.target.style.color = _scripting_utils.ColorConverters[\"\".concat(color[0], \"_HTML\")](color.slice(1));\n              }\n            };\n            Object.keys(detail).filter(function (name) {\n              return name in actions;\n            }).forEach(function (name) {\n              return actions[name]();\n            });\n          });\n          element.addEventListener(\"keydown\", function (event) {\n            var _this5$linkService$ev;\n\n            elementData.beforeInputValue = event.target.value;\n            var commitKey = -1;\n\n            if (event.key === \"Escape\") {\n              commitKey = 0;\n            } else if (event.key === \"Enter\") {\n              commitKey = 2;\n            } else if (event.key === \"Tab\") {\n              commitKey = 3;\n            }\n\n            if (commitKey === -1) {\n              return;\n            }\n\n            elementData.userValue = event.target.value;\n            (_this5$linkService$ev = _this5.linkService.eventBus) === null || _this5$linkService$ev === void 0 ? void 0 : _this5$linkService$ev.dispatch(\"dispatcheventinsandbox\", {\n              source: _this5,\n              detail: {\n                id: id,\n                name: \"Keystroke\",\n                value: event.target.value,\n                willCommit: true,\n                commitKey: commitKey,\n                selStart: event.target.selectionStart,\n                selEnd: event.target.selectionEnd\n              }\n            });\n          });\n          var _blurListener = blurListener;\n          blurListener = null;\n          element.addEventListener(\"blur\", function (event) {\n            if (_this5._mouseState.isDown) {\n              var _this5$linkService$ev2;\n\n              elementData.userValue = event.target.value;\n              (_this5$linkService$ev2 = _this5.linkService.eventBus) === null || _this5$linkService$ev2 === void 0 ? void 0 : _this5$linkService$ev2.dispatch(\"dispatcheventinsandbox\", {\n                source: _this5,\n                detail: {\n                  id: id,\n                  name: \"Keystroke\",\n                  value: event.target.value,\n                  willCommit: true,\n                  commitKey: 1,\n                  selStart: event.target.selectionStart,\n                  selEnd: event.target.selectionEnd\n                }\n              });\n            }\n\n            _blurListener(event);\n          });\n          element.addEventListener(\"mousedown\", function (event) {\n            elementData.beforeInputValue = event.target.value;\n            elementData.beforeInputSelectionRange = null;\n          });\n          element.addEventListener(\"keyup\", function (event) {\n            if (event.target.selectionStart === event.target.selectionEnd) {\n              elementData.beforeInputSelectionRange = null;\n            }\n          });\n          element.addEventListener(\"select\", function (event) {\n            elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];\n          });\n\n          if ((_this$data$actions2 = this.data.actions) !== null && _this$data$actions2 !== void 0 && _this$data$actions2.Keystroke) {\n            element.addEventListener(\"input\", function (event) {\n              var _this5$linkService$ev3;\n\n              var selStart = -1;\n              var selEnd = -1;\n\n              if (elementData.beforeInputSelectionRange) {\n                var _elementData$beforeIn = _slicedToArray(elementData.beforeInputSelectionRange, 2);\n\n                selStart = _elementData$beforeIn[0];\n                selEnd = _elementData$beforeIn[1];\n              }\n\n              (_this5$linkService$ev3 = _this5.linkService.eventBus) === null || _this5$linkService$ev3 === void 0 ? void 0 : _this5$linkService$ev3.dispatch(\"dispatcheventinsandbox\", {\n                source: _this5,\n                detail: {\n                  id: id,\n                  name: \"Keystroke\",\n                  value: elementData.beforeInputValue,\n                  change: event.data,\n                  willCommit: false,\n                  selStart: selStart,\n                  selEnd: selEnd\n                }\n              });\n            });\n          }\n\n          this._setEventListeners(element, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], function (event) {\n            return event.target.value;\n          });\n        }\n\n        if (blurListener) {\n          element.addEventListener(\"blur\", blurListener);\n        }\n\n        element.disabled = this.data.readOnly;\n        element.name = this.data.fieldName;\n\n        if (this.data.maxLen !== null) {\n          element.maxLength = this.data.maxLen;\n        }\n\n        if (this.data.comb) {\n          var fieldWidth = this.data.rect[2] - this.data.rect[0];\n          var combWidth = fieldWidth / this.data.maxLen;\n          element.classList.add(\"comb\");\n          element.style.letterSpacing = \"calc(\".concat(combWidth, \"px - 1ch)\");\n        }\n      } else {\n        element = document.createElement(\"div\");\n        element.textContent = this.data.fieldValue;\n        element.style.verticalAlign = \"middle\";\n        element.style.display = \"table-cell\";\n      }\n\n      this._setTextStyle(element);\n\n      this.container.appendChild(element);\n      return this.container;\n    }\n  }, {\n    key: \"_setTextStyle\",\n    value: function _setTextStyle(element) {\n      var TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n      var _this$data$defaultApp = this.data.defaultAppearanceData,\n          fontSize = _this$data$defaultApp.fontSize,\n          fontColor = _this$data$defaultApp.fontColor;\n      var style = element.style;\n\n      if (fontSize) {\n        style.fontSize = \"\".concat(fontSize, \"px\");\n      }\n\n      style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n\n      if (this.data.textAlignment !== null) {\n        style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n      }\n    }\n  }]);\n\n  return TextWidgetAnnotationElement;\n}(WidgetAnnotationElement);\n\nvar CheckboxWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem2) {\n  _inherits(CheckboxWidgetAnnotationElement, _WidgetAnnotationElem2);\n\n  var _super5 = _createSuper(CheckboxWidgetAnnotationElement);\n\n  function CheckboxWidgetAnnotationElement(parameters) {\n    _classCallCheck(this, CheckboxWidgetAnnotationElement);\n\n    return _super5.call(this, parameters, {\n      isRenderable: parameters.renderInteractiveForms\n    });\n  }\n\n  _createClass(CheckboxWidgetAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      var storage = this.annotationStorage;\n      var data = this.data;\n      var id = data.id;\n      var value = storage.getOrCreateValue(id, {\n        value: data.fieldValue && data.fieldValue !== \"Off\"\n      }).value;\n      this.container.className = \"buttonWidgetAnnotation checkBox\";\n      var element = document.createElement(\"input\");\n      element.disabled = data.readOnly;\n      element.type = \"checkbox\";\n      element.name = this.data.fieldName;\n\n      if (value) {\n        element.setAttribute(\"checked\", true);\n      }\n\n      element.setAttribute(\"id\", id);\n      element.addEventListener(\"change\", function (event) {\n        var name = event.target.name;\n\n        var _iterator3 = _createForOfIteratorHelper(document.getElementsByName(name)),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var checkbox = _step3.value;\n\n            if (checkbox !== event.target) {\n              checkbox.checked = false;\n              storage.setValue(checkbox.parentNode.getAttribute(\"data-annotation-id\"), {\n                value: false\n              });\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        storage.setValue(id, {\n          value: event.target.checked\n        });\n      });\n\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"updatefromsandbox\", function (event) {\n          var detail = event.detail;\n          var actions = {\n            value: function value() {\n              event.target.checked = detail.value !== \"Off\";\n              storage.setValue(id, {\n                value: event.target.checked\n              });\n            },\n            focus: function focus() {\n              setTimeout(function () {\n                return event.target.focus({\n                  preventScroll: false\n                });\n              }, 0);\n            },\n            hidden: function hidden() {\n              event.target.style.visibility = detail.hidden ? \"hidden\" : \"visible\";\n              storage.setValue(id, {\n                hidden: detail.hidden\n              });\n            },\n            editable: function editable() {\n              event.target.disabled = !detail.editable;\n            }\n          };\n          Object.keys(detail).filter(function (name) {\n            return name in actions;\n          }).forEach(function (name) {\n            return actions[name]();\n          });\n        });\n\n        this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], function (event) {\n          return event.target.checked;\n        });\n      }\n\n      this.container.appendChild(element);\n      return this.container;\n    }\n  }]);\n\n  return CheckboxWidgetAnnotationElement;\n}(WidgetAnnotationElement);\n\nvar RadioButtonWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem3) {\n  _inherits(RadioButtonWidgetAnnotationElement, _WidgetAnnotationElem3);\n\n  var _super6 = _createSuper(RadioButtonWidgetAnnotationElement);\n\n  function RadioButtonWidgetAnnotationElement(parameters) {\n    _classCallCheck(this, RadioButtonWidgetAnnotationElement);\n\n    return _super6.call(this, parameters, {\n      isRenderable: parameters.renderInteractiveForms\n    });\n  }\n\n  _createClass(RadioButtonWidgetAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"buttonWidgetAnnotation radioButton\";\n      var storage = this.annotationStorage;\n      var data = this.data;\n      var id = data.id;\n      var value = storage.getOrCreateValue(id, {\n        value: data.fieldValue === data.buttonValue\n      }).value;\n      var element = document.createElement(\"input\");\n      element.disabled = data.readOnly;\n      element.type = \"radio\";\n      element.name = data.fieldName;\n\n      if (value) {\n        element.setAttribute(\"checked\", true);\n      }\n\n      element.setAttribute(\"pdfButtonValue\", data.buttonValue);\n      element.setAttribute(\"id\", id);\n      element.addEventListener(\"change\", function (event) {\n        var target = event.target;\n\n        var _iterator4 = _createForOfIteratorHelper(document.getElementsByName(target.name)),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var radio = _step4.value;\n\n            if (radio !== target) {\n              storage.setValue(radio.getAttribute(\"id\"), {\n                value: false\n              });\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        storage.setValue(id, {\n          value: target.checked\n        });\n      });\n\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"updatefromsandbox\", function (event) {\n          var detail = event.detail;\n          var actions = {\n            value: function value() {\n              var fieldValue = detail.value;\n\n              var _iterator5 = _createForOfIteratorHelper(document.getElementsByName(event.target.name)),\n                  _step5;\n\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var radio = _step5.value;\n                  var radioId = radio.getAttribute(\"id\");\n\n                  if (fieldValue === radio.getAttribute(\"pdfButtonValue\")) {\n                    radio.setAttribute(\"checked\", true);\n                    storage.setValue(radioId, {\n                      value: true\n                    });\n                  } else {\n                    storage.setValue(radioId, {\n                      value: false\n                    });\n                  }\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n            },\n            focus: function focus() {\n              setTimeout(function () {\n                return event.target.focus({\n                  preventScroll: false\n                });\n              }, 0);\n            },\n            hidden: function hidden() {\n              event.target.style.visibility = detail.hidden ? \"hidden\" : \"visible\";\n              storage.setValue(id, {\n                hidden: detail.hidden\n              });\n            },\n            editable: function editable() {\n              event.target.disabled = !detail.editable;\n            }\n          };\n          Object.keys(detail).filter(function (name) {\n            return name in actions;\n          }).forEach(function (name) {\n            return actions[name]();\n          });\n        });\n\n        this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], function (event) {\n          return event.target.checked;\n        });\n      }\n\n      this.container.appendChild(element);\n      return this.container;\n    }\n  }]);\n\n  return RadioButtonWidgetAnnotationElement;\n}(WidgetAnnotationElement);\n\nvar PushButtonWidgetAnnotationElement = /*#__PURE__*/function (_LinkAnnotationElemen) {\n  _inherits(PushButtonWidgetAnnotationElement, _LinkAnnotationElemen);\n\n  var _super7 = _createSuper(PushButtonWidgetAnnotationElement);\n\n  function PushButtonWidgetAnnotationElement() {\n    _classCallCheck(this, PushButtonWidgetAnnotationElement);\n\n    return _super7.apply(this, arguments);\n  }\n\n  _createClass(PushButtonWidgetAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      var container = _get(_getPrototypeOf(PushButtonWidgetAnnotationElement.prototype), \"render\", this).call(this);\n\n      container.className = \"buttonWidgetAnnotation pushButton\";\n\n      if (this.data.alternativeText) {\n        container.title = this.data.alternativeText;\n      }\n\n      return container;\n    }\n  }]);\n\n  return PushButtonWidgetAnnotationElement;\n}(LinkAnnotationElement);\n\nvar ChoiceWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem4) {\n  _inherits(ChoiceWidgetAnnotationElement, _WidgetAnnotationElem4);\n\n  var _super8 = _createSuper(ChoiceWidgetAnnotationElement);\n\n  function ChoiceWidgetAnnotationElement(parameters) {\n    _classCallCheck(this, ChoiceWidgetAnnotationElement);\n\n    return _super8.call(this, parameters, {\n      isRenderable: parameters.renderInteractiveForms\n    });\n  }\n\n  _createClass(ChoiceWidgetAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      var _this6 = this;\n\n      this.container.className = \"choiceWidgetAnnotation\";\n      var storage = this.annotationStorage;\n      var id = this.data.id;\n      storage.getOrCreateValue(id, {\n        value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined\n      });\n      var selectElement = document.createElement(\"select\");\n      selectElement.disabled = this.data.readOnly;\n      selectElement.name = this.data.fieldName;\n      selectElement.setAttribute(\"id\", id);\n\n      if (!this.data.combo) {\n        selectElement.size = this.data.options.length;\n\n        if (this.data.multiSelect) {\n          selectElement.multiple = true;\n        }\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(this.data.options),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var option = _step6.value;\n          var optionElement = document.createElement(\"option\");\n          optionElement.textContent = option.displayValue;\n          optionElement.value = option.exportValue;\n\n          if (this.data.fieldValue.includes(option.exportValue)) {\n            optionElement.setAttribute(\"selected\", true);\n          }\n\n          selectElement.appendChild(optionElement);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      var getValue = function getValue(event, isExport) {\n        var name = isExport ? \"value\" : \"textContent\";\n        var options = event.target.options;\n\n        if (!event.target.multiple) {\n          return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n        }\n\n        return Array.prototype.filter.call(options, function (option) {\n          return option.selected;\n        }).map(function (option) {\n          return option[name];\n        });\n      };\n\n      var getItems = function getItems(event) {\n        var options = event.target.options;\n        return Array.prototype.map.call(options, function (option) {\n          return {\n            displayValue: option.textContent,\n            exportValue: option.value\n          };\n        });\n      };\n\n      if (this.enableScripting && this.hasJSActions) {\n        selectElement.addEventListener(\"updatefromsandbox\", function (event) {\n          var detail = event.detail;\n          var actions = {\n            value: function value() {\n              var options = selectElement.options;\n              var value = detail.value;\n              var values = new Set(Array.isArray(value) ? value : [value]);\n              Array.prototype.forEach.call(options, function (option) {\n                option.selected = values.has(option.value);\n              });\n              storage.setValue(id, {\n                value: getValue(event, true)\n              });\n            },\n            multipleSelection: function multipleSelection() {\n              selectElement.multiple = true;\n            },\n            remove: function remove() {\n              var options = selectElement.options;\n              var index = detail.remove;\n              options[index].selected = false;\n              selectElement.remove(index);\n\n              if (options.length > 0) {\n                var i = Array.prototype.findIndex.call(options, function (option) {\n                  return option.selected;\n                });\n\n                if (i === -1) {\n                  options[0].selected = true;\n                }\n              }\n\n              storage.setValue(id, {\n                value: getValue(event, true),\n                items: getItems(event)\n              });\n            },\n            clear: function clear() {\n              while (selectElement.length !== 0) {\n                selectElement.remove(0);\n              }\n\n              storage.setValue(id, {\n                value: null,\n                items: []\n              });\n            },\n            insert: function insert() {\n              var _detail$insert = detail.insert,\n                  index = _detail$insert.index,\n                  displayValue = _detail$insert.displayValue,\n                  exportValue = _detail$insert.exportValue;\n              var optionElement = document.createElement(\"option\");\n              optionElement.textContent = displayValue;\n              optionElement.value = exportValue;\n              selectElement.insertBefore(optionElement, selectElement.children[index]);\n              storage.setValue(id, {\n                value: getValue(event, true),\n                items: getItems(event)\n              });\n            },\n            items: function items() {\n              var items = detail.items;\n\n              while (selectElement.length !== 0) {\n                selectElement.remove(0);\n              }\n\n              var _iterator7 = _createForOfIteratorHelper(items),\n                  _step7;\n\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var item = _step7.value;\n                  var displayValue = item.displayValue,\n                      exportValue = item.exportValue;\n                  var optionElement = document.createElement(\"option\");\n                  optionElement.textContent = displayValue;\n                  optionElement.value = exportValue;\n                  selectElement.appendChild(optionElement);\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n\n              if (selectElement.options.length > 0) {\n                selectElement.options[0].selected = true;\n              }\n\n              storage.setValue(id, {\n                value: getValue(event, true),\n                items: getItems(event)\n              });\n            },\n            indices: function indices() {\n              var indices = new Set(detail.indices);\n              var options = event.target.options;\n              Array.prototype.forEach.call(options, function (option, i) {\n                option.selected = indices.has(i);\n              });\n              storage.setValue(id, {\n                value: getValue(event, true)\n              });\n            },\n            focus: function focus() {\n              setTimeout(function () {\n                return event.target.focus({\n                  preventScroll: false\n                });\n              }, 0);\n            },\n            hidden: function hidden() {\n              event.target.style.visibility = detail.hidden ? \"hidden\" : \"visible\";\n              storage.setValue(id, {\n                hidden: detail.hidden\n              });\n            },\n            editable: function editable() {\n              event.target.disabled = !detail.editable;\n            }\n          };\n          Object.keys(detail).filter(function (name) {\n            return name in actions;\n          }).forEach(function (name) {\n            return actions[name]();\n          });\n        });\n        selectElement.addEventListener(\"input\", function (event) {\n          var _this6$linkService$ev;\n\n          var exportValue = getValue(event, true);\n          var value = getValue(event, false);\n          storage.setValue(id, {\n            value: exportValue\n          });\n          (_this6$linkService$ev = _this6.linkService.eventBus) === null || _this6$linkService$ev === void 0 ? void 0 : _this6$linkService$ev.dispatch(\"dispatcheventinsandbox\", {\n            source: _this6,\n            detail: {\n              id: id,\n              name: \"Keystroke\",\n              value: value,\n              changeEx: exportValue,\n              willCommit: true,\n              commitKey: 1,\n              keyDown: false\n            }\n          });\n        });\n\n        this._setEventListeners(selectElement, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"]], function (event) {\n          return event.target.checked;\n        });\n      } else {\n        selectElement.addEventListener(\"input\", function (event) {\n          storage.setValue(id, {\n            value: getValue(event)\n          });\n        });\n      }\n\n      this.container.appendChild(selectElement);\n      return this.container;\n    }\n  }]);\n\n  return ChoiceWidgetAnnotationElement;\n}(WidgetAnnotationElement);\n\nvar PopupAnnotationElement = /*#__PURE__*/function (_AnnotationElement4) {\n  _inherits(PopupAnnotationElement, _AnnotationElement4);\n\n  var _super9 = _createSuper(PopupAnnotationElement);\n\n  function PopupAnnotationElement(parameters) {\n    _classCallCheck(this, PopupAnnotationElement);\n\n    var isRenderable = !!(parameters.data.title || parameters.data.contents);\n    return _super9.call(this, parameters, {\n      isRenderable: isRenderable\n    });\n  }\n\n  _createClass(PopupAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      var IGNORE_TYPES = [\"Line\", \"Square\", \"Circle\", \"PolyLine\", \"Polygon\", \"Ink\"];\n      this.container.className = \"popupAnnotation\";\n\n      if (IGNORE_TYPES.includes(this.data.parentType)) {\n        return this.container;\n      }\n\n      var selector = \"[data-annotation-id=\\\"\".concat(this.data.parentId, \"\\\"]\");\n      var parentElements = this.layer.querySelectorAll(selector);\n\n      if (parentElements.length === 0) {\n        return this.container;\n      }\n\n      var popup = new PopupElement({\n        container: this.container,\n        trigger: Array.from(parentElements),\n        color: this.data.color,\n        title: this.data.title,\n        modificationDate: this.data.modificationDate,\n        contents: this.data.contents\n      });\n      var page = this.page;\n\n      var rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);\n\n      var popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];\n      var popupTop = rect[1];\n      this.container.style.transformOrigin = \"\".concat(-popupLeft, \"px \").concat(-popupTop, \"px\");\n      this.container.style.left = \"\".concat(popupLeft, \"px\");\n      this.container.style.top = \"\".concat(popupTop, \"px\");\n      this.container.appendChild(popup.render());\n      return this.container;\n    }\n  }]);\n\n  return PopupAnnotationElement;\n}(AnnotationElement);\n\nvar PopupElement = /*#__PURE__*/function () {\n  function PopupElement(parameters) {\n    _classCallCheck(this, PopupElement);\n\n    this.container = parameters.container;\n    this.trigger = parameters.trigger;\n    this.color = parameters.color;\n    this.title = parameters.title;\n    this.modificationDate = parameters.modificationDate;\n    this.contents = parameters.contents;\n    this.hideWrapper = parameters.hideWrapper || false;\n    this.pinned = false;\n  }\n\n  _createClass(PopupElement, [{\n    key: \"render\",\n    value: function render() {\n      var _this7 = this;\n\n      var BACKGROUND_ENLIGHT = 0.7;\n      var wrapper = document.createElement(\"div\");\n      wrapper.className = \"popupWrapper\";\n      this.hideElement = this.hideWrapper ? wrapper : this.container;\n      this.hideElement.hidden = true;\n      var popup = document.createElement(\"div\");\n      popup.className = \"popup\";\n      var color = this.color;\n\n      if (color) {\n        var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\n        var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\n        var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\n        popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);\n      }\n\n      var title = document.createElement(\"h1\");\n      title.textContent = this.title;\n      popup.appendChild(title);\n\n      var dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);\n\n      if (dateObject) {\n        var modificationDate = document.createElement(\"span\");\n        modificationDate.textContent = \"{{date}}, {{time}}\";\n        modificationDate.dataset.l10nId = \"annotation_date_string\";\n        modificationDate.dataset.l10nArgs = JSON.stringify({\n          date: dateObject.toLocaleDateString(),\n          time: dateObject.toLocaleTimeString()\n        });\n        popup.appendChild(modificationDate);\n      }\n\n      var contents = this._formatContents(this.contents);\n\n      popup.appendChild(contents);\n\n      if (!Array.isArray(this.trigger)) {\n        this.trigger = [this.trigger];\n      }\n\n      this.trigger.forEach(function (element) {\n        element.addEventListener(\"click\", _this7._toggle.bind(_this7));\n        element.addEventListener(\"mouseover\", _this7._show.bind(_this7, false));\n        element.addEventListener(\"mouseout\", _this7._hide.bind(_this7, false));\n      });\n      popup.addEventListener(\"click\", this._hide.bind(this, true));\n      wrapper.appendChild(popup);\n      return wrapper;\n    }\n  }, {\n    key: \"_formatContents\",\n    value: function _formatContents(contents) {\n      var p = document.createElement(\"p\");\n      var lines = contents.split(/(?:\\r\\n?|\\n)/);\n\n      for (var i = 0, ii = lines.length; i < ii; ++i) {\n        var line = lines[i];\n        p.appendChild(document.createTextNode(line));\n\n        if (i < ii - 1) {\n          p.appendChild(document.createElement(\"br\"));\n        }\n      }\n\n      return p;\n    }\n  }, {\n    key: \"_toggle\",\n    value: function _toggle() {\n      if (this.pinned) {\n        this._hide(true);\n      } else {\n        this._show(true);\n      }\n    }\n  }, {\n    key: \"_show\",\n    value: function _show() {\n      var pin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (pin) {\n        this.pinned = true;\n      }\n\n      if (this.hideElement.hidden) {\n        this.hideElement.hidden = false;\n        this.container.style.zIndex += 1;\n      }\n    }\n  }, {\n    key: \"_hide\",\n    value: function _hide() {\n      var unpin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (unpin) {\n        this.pinned = false;\n      }\n\n      if (!this.hideElement.hidden && !this.pinned) {\n        this.hideElement.hidden = true;\n        this.container.style.zIndex -= 1;\n      }\n    }\n  }]);\n\n  return PopupElement;\n}();\n\nvar FreeTextAnnotationElement = /*#__PURE__*/function (_AnnotationElement5) {\n  _inherits(FreeTextAnnotationElement, _AnnotationElement5);\n\n  var _super10 = _createSuper(FreeTextAnnotationElement);\n\n  function FreeTextAnnotationElement(parameters) {\n    _classCallCheck(this, FreeTextAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super10.call(this, parameters, {\n      isRenderable: isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  _createClass(FreeTextAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"freeTextAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      return this.container;\n    }\n  }]);\n\n  return FreeTextAnnotationElement;\n}(AnnotationElement);\n\nvar LineAnnotationElement = /*#__PURE__*/function (_AnnotationElement6) {\n  _inherits(LineAnnotationElement, _AnnotationElement6);\n\n  var _super11 = _createSuper(LineAnnotationElement);\n\n  function LineAnnotationElement(parameters) {\n    _classCallCheck(this, LineAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super11.call(this, parameters, {\n      isRenderable: isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  _createClass(LineAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"lineAnnotation\";\n      var data = this.data;\n      var width = data.rect[2] - data.rect[0];\n      var height = data.rect[3] - data.rect[1];\n      var svg = this.svgFactory.create(width, height);\n      var line = this.svgFactory.createElement(\"svg:line\");\n      line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n      line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n      line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n      line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n      line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      line.setAttribute(\"stroke\", \"transparent\");\n      svg.appendChild(line);\n      this.container.append(svg);\n\n      this._createPopup(line, data);\n\n      return this.container;\n    }\n  }]);\n\n  return LineAnnotationElement;\n}(AnnotationElement);\n\nvar SquareAnnotationElement = /*#__PURE__*/function (_AnnotationElement7) {\n  _inherits(SquareAnnotationElement, _AnnotationElement7);\n\n  var _super12 = _createSuper(SquareAnnotationElement);\n\n  function SquareAnnotationElement(parameters) {\n    _classCallCheck(this, SquareAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super12.call(this, parameters, {\n      isRenderable: isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  _createClass(SquareAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"squareAnnotation\";\n      var data = this.data;\n      var width = data.rect[2] - data.rect[0];\n      var height = data.rect[3] - data.rect[1];\n      var svg = this.svgFactory.create(width, height);\n      var borderWidth = data.borderStyle.width;\n      var square = this.svgFactory.createElement(\"svg:rect\");\n      square.setAttribute(\"x\", borderWidth / 2);\n      square.setAttribute(\"y\", borderWidth / 2);\n      square.setAttribute(\"width\", width - borderWidth);\n      square.setAttribute(\"height\", height - borderWidth);\n      square.setAttribute(\"stroke-width\", borderWidth || 1);\n      square.setAttribute(\"stroke\", \"transparent\");\n      square.setAttribute(\"fill\", \"none\");\n      svg.appendChild(square);\n      this.container.append(svg);\n\n      this._createPopup(square, data);\n\n      return this.container;\n    }\n  }]);\n\n  return SquareAnnotationElement;\n}(AnnotationElement);\n\nvar CircleAnnotationElement = /*#__PURE__*/function (_AnnotationElement8) {\n  _inherits(CircleAnnotationElement, _AnnotationElement8);\n\n  var _super13 = _createSuper(CircleAnnotationElement);\n\n  function CircleAnnotationElement(parameters) {\n    _classCallCheck(this, CircleAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super13.call(this, parameters, {\n      isRenderable: isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  _createClass(CircleAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"circleAnnotation\";\n      var data = this.data;\n      var width = data.rect[2] - data.rect[0];\n      var height = data.rect[3] - data.rect[1];\n      var svg = this.svgFactory.create(width, height);\n      var borderWidth = data.borderStyle.width;\n      var circle = this.svgFactory.createElement(\"svg:ellipse\");\n      circle.setAttribute(\"cx\", width / 2);\n      circle.setAttribute(\"cy\", height / 2);\n      circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n      circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n      circle.setAttribute(\"stroke-width\", borderWidth || 1);\n      circle.setAttribute(\"stroke\", \"transparent\");\n      circle.setAttribute(\"fill\", \"none\");\n      svg.appendChild(circle);\n      this.container.append(svg);\n\n      this._createPopup(circle, data);\n\n      return this.container;\n    }\n  }]);\n\n  return CircleAnnotationElement;\n}(AnnotationElement);\n\nvar PolylineAnnotationElement = /*#__PURE__*/function (_AnnotationElement9) {\n  _inherits(PolylineAnnotationElement, _AnnotationElement9);\n\n  var _super14 = _createSuper(PolylineAnnotationElement);\n\n  function PolylineAnnotationElement(parameters) {\n    var _this8;\n\n    _classCallCheck(this, PolylineAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    _this8 = _super14.call(this, parameters, {\n      isRenderable: isRenderable,\n      ignoreBorder: true\n    });\n    _this8.containerClassName = \"polylineAnnotation\";\n    _this8.svgElementName = \"svg:polyline\";\n    return _this8;\n  }\n\n  _createClass(PolylineAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = this.containerClassName;\n      var data = this.data;\n      var width = data.rect[2] - data.rect[0];\n      var height = data.rect[3] - data.rect[1];\n      var svg = this.svgFactory.create(width, height);\n      var points = [];\n\n      var _iterator8 = _createForOfIteratorHelper(data.vertices),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var coordinate = _step8.value;\n          var x = coordinate.x - data.rect[0];\n          var y = data.rect[3] - coordinate.y;\n          points.push(x + \",\" + y);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      points = points.join(\" \");\n      var polyline = this.svgFactory.createElement(this.svgElementName);\n      polyline.setAttribute(\"points\", points);\n      polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      polyline.setAttribute(\"stroke\", \"transparent\");\n      polyline.setAttribute(\"fill\", \"none\");\n      svg.appendChild(polyline);\n      this.container.append(svg);\n\n      this._createPopup(polyline, data);\n\n      return this.container;\n    }\n  }]);\n\n  return PolylineAnnotationElement;\n}(AnnotationElement);\n\nvar PolygonAnnotationElement = /*#__PURE__*/function (_PolylineAnnotationEl) {\n  _inherits(PolygonAnnotationElement, _PolylineAnnotationEl);\n\n  var _super15 = _createSuper(PolygonAnnotationElement);\n\n  function PolygonAnnotationElement(parameters) {\n    var _this9;\n\n    _classCallCheck(this, PolygonAnnotationElement);\n\n    _this9 = _super15.call(this, parameters);\n    _this9.containerClassName = \"polygonAnnotation\";\n    _this9.svgElementName = \"svg:polygon\";\n    return _this9;\n  }\n\n  return PolygonAnnotationElement;\n}(PolylineAnnotationElement);\n\nvar CaretAnnotationElement = /*#__PURE__*/function (_AnnotationElement10) {\n  _inherits(CaretAnnotationElement, _AnnotationElement10);\n\n  var _super16 = _createSuper(CaretAnnotationElement);\n\n  function CaretAnnotationElement(parameters) {\n    _classCallCheck(this, CaretAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super16.call(this, parameters, {\n      isRenderable: isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  _createClass(CaretAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"caretAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      return this.container;\n    }\n  }]);\n\n  return CaretAnnotationElement;\n}(AnnotationElement);\n\nvar InkAnnotationElement = /*#__PURE__*/function (_AnnotationElement11) {\n  _inherits(InkAnnotationElement, _AnnotationElement11);\n\n  var _super17 = _createSuper(InkAnnotationElement);\n\n  function InkAnnotationElement(parameters) {\n    var _this10;\n\n    _classCallCheck(this, InkAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    _this10 = _super17.call(this, parameters, {\n      isRenderable: isRenderable,\n      ignoreBorder: true\n    });\n    _this10.containerClassName = \"inkAnnotation\";\n    _this10.svgElementName = \"svg:polyline\";\n    return _this10;\n  }\n\n  _createClass(InkAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = this.containerClassName;\n      var data = this.data;\n      var width = data.rect[2] - data.rect[0];\n      var height = data.rect[3] - data.rect[1];\n      var svg = this.svgFactory.create(width, height);\n\n      var _iterator9 = _createForOfIteratorHelper(data.inkLists),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var inkList = _step9.value;\n          var points = [];\n\n          var _iterator10 = _createForOfIteratorHelper(inkList),\n              _step10;\n\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var coordinate = _step10.value;\n              var x = coordinate.x - data.rect[0];\n              var y = data.rect[3] - coordinate.y;\n              points.push(\"\".concat(x, \",\").concat(y));\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n\n          points = points.join(\" \");\n          var polyline = this.svgFactory.createElement(this.svgElementName);\n          polyline.setAttribute(\"points\", points);\n          polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n          polyline.setAttribute(\"stroke\", \"transparent\");\n          polyline.setAttribute(\"fill\", \"none\");\n\n          this._createPopup(polyline, data);\n\n          svg.appendChild(polyline);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      this.container.append(svg);\n      return this.container;\n    }\n  }]);\n\n  return InkAnnotationElement;\n}(AnnotationElement);\n\nvar HighlightAnnotationElement = /*#__PURE__*/function (_AnnotationElement12) {\n  _inherits(HighlightAnnotationElement, _AnnotationElement12);\n\n  var _super18 = _createSuper(HighlightAnnotationElement);\n\n  function HighlightAnnotationElement(parameters) {\n    _classCallCheck(this, HighlightAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super18.call(this, parameters, {\n      isRenderable: isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  _createClass(HighlightAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      if (this.quadrilaterals) {\n        return this._renderQuadrilaterals(\"highlightAnnotation\");\n      }\n\n      this.container.className = \"highlightAnnotation\";\n      return this.container;\n    }\n  }]);\n\n  return HighlightAnnotationElement;\n}(AnnotationElement);\n\nvar UnderlineAnnotationElement = /*#__PURE__*/function (_AnnotationElement13) {\n  _inherits(UnderlineAnnotationElement, _AnnotationElement13);\n\n  var _super19 = _createSuper(UnderlineAnnotationElement);\n\n  function UnderlineAnnotationElement(parameters) {\n    _classCallCheck(this, UnderlineAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super19.call(this, parameters, {\n      isRenderable: isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  _createClass(UnderlineAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      if (this.quadrilaterals) {\n        return this._renderQuadrilaterals(\"underlineAnnotation\");\n      }\n\n      this.container.className = \"underlineAnnotation\";\n      return this.container;\n    }\n  }]);\n\n  return UnderlineAnnotationElement;\n}(AnnotationElement);\n\nvar SquigglyAnnotationElement = /*#__PURE__*/function (_AnnotationElement14) {\n  _inherits(SquigglyAnnotationElement, _AnnotationElement14);\n\n  var _super20 = _createSuper(SquigglyAnnotationElement);\n\n  function SquigglyAnnotationElement(parameters) {\n    _classCallCheck(this, SquigglyAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super20.call(this, parameters, {\n      isRenderable: isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  _createClass(SquigglyAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      if (this.quadrilaterals) {\n        return this._renderQuadrilaterals(\"squigglyAnnotation\");\n      }\n\n      this.container.className = \"squigglyAnnotation\";\n      return this.container;\n    }\n  }]);\n\n  return SquigglyAnnotationElement;\n}(AnnotationElement);\n\nvar StrikeOutAnnotationElement = /*#__PURE__*/function (_AnnotationElement15) {\n  _inherits(StrikeOutAnnotationElement, _AnnotationElement15);\n\n  var _super21 = _createSuper(StrikeOutAnnotationElement);\n\n  function StrikeOutAnnotationElement(parameters) {\n    _classCallCheck(this, StrikeOutAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super21.call(this, parameters, {\n      isRenderable: isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n\n  _createClass(StrikeOutAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      if (this.quadrilaterals) {\n        return this._renderQuadrilaterals(\"strikeoutAnnotation\");\n      }\n\n      this.container.className = \"strikeoutAnnotation\";\n      return this.container;\n    }\n  }]);\n\n  return StrikeOutAnnotationElement;\n}(AnnotationElement);\n\nvar StampAnnotationElement = /*#__PURE__*/function (_AnnotationElement16) {\n  _inherits(StampAnnotationElement, _AnnotationElement16);\n\n  var _super22 = _createSuper(StampAnnotationElement);\n\n  function StampAnnotationElement(parameters) {\n    _classCallCheck(this, StampAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super22.call(this, parameters, {\n      isRenderable: isRenderable,\n      ignoreBorder: true\n    });\n  }\n\n  _createClass(StampAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"stampAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(null, this.data);\n      }\n\n      return this.container;\n    }\n  }]);\n\n  return StampAnnotationElement;\n}(AnnotationElement);\n\nvar FileAttachmentAnnotationElement = /*#__PURE__*/function (_AnnotationElement17) {\n  _inherits(FileAttachmentAnnotationElement, _AnnotationElement17);\n\n  var _super23 = _createSuper(FileAttachmentAnnotationElement);\n\n  function FileAttachmentAnnotationElement(parameters) {\n    var _this11$linkService$e;\n\n    var _this11;\n\n    _classCallCheck(this, FileAttachmentAnnotationElement);\n\n    _this11 = _super23.call(this, parameters, {\n      isRenderable: true\n    });\n    var _this11$data$file = _this11.data.file,\n        filename = _this11$data$file.filename,\n        content = _this11$data$file.content;\n    _this11.filename = (0, _display_utils.getFilenameFromUrl)(filename);\n    _this11.content = content;\n    (_this11$linkService$e = _this11.linkService.eventBus) === null || _this11$linkService$e === void 0 ? void 0 : _this11$linkService$e.dispatch(\"fileattachmentannotation\", {\n      source: _assertThisInitialized(_this11),\n      id: (0, _util.stringToPDFString)(filename),\n      filename: filename,\n      content: content\n    });\n    return _this11;\n  }\n\n  _createClass(FileAttachmentAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"fileAttachmentAnnotation\";\n      var trigger = document.createElement(\"div\");\n      trigger.style.height = this.container.style.height;\n      trigger.style.width = this.container.style.width;\n      trigger.addEventListener(\"dblclick\", this._download.bind(this));\n\n      if (!this.data.hasPopup && (this.data.title || this.data.contents)) {\n        this._createPopup(trigger, this.data);\n      }\n\n      this.container.appendChild(trigger);\n      return this.container;\n    }\n  }, {\n    key: \"_download\",\n    value: function _download() {\n      if (!this.downloadManager) {\n        (0, _util.warn)(\"Download cannot be started due to unavailable download manager\");\n        return;\n      }\n\n      this.downloadManager.downloadData(this.content, this.filename, \"\");\n    }\n  }]);\n\n  return FileAttachmentAnnotationElement;\n}(AnnotationElement);\n\nvar AnnotationLayer = /*#__PURE__*/function () {\n  function AnnotationLayer() {\n    _classCallCheck(this, AnnotationLayer);\n  }\n\n  _createClass(AnnotationLayer, null, [{\n    key: \"render\",\n    value: function render(parameters) {\n      var sortedAnnotations = [],\n          popupAnnotations = [];\n\n      var _iterator11 = _createForOfIteratorHelper(parameters.annotations),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var _data = _step11.value;\n\n          if (!_data) {\n            continue;\n          }\n\n          if (_data.annotationType === _util.AnnotationType.POPUP) {\n            popupAnnotations.push(_data);\n            continue;\n          }\n\n          sortedAnnotations.push(_data);\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      if (popupAnnotations.length) {\n        sortedAnnotations.push.apply(sortedAnnotations, popupAnnotations);\n      }\n\n      for (var _i2 = 0, _sortedAnnotations = sortedAnnotations; _i2 < _sortedAnnotations.length; _i2++) {\n        var data = _sortedAnnotations[_i2];\n        var element = AnnotationElementFactory.create({\n          data: data,\n          layer: parameters.div,\n          page: parameters.page,\n          viewport: parameters.viewport,\n          linkService: parameters.linkService,\n          downloadManager: parameters.downloadManager,\n          imageResourcesPath: parameters.imageResourcesPath || \"\",\n          renderInteractiveForms: typeof parameters.renderInteractiveForms === \"boolean\" ? parameters.renderInteractiveForms : true,\n          svgFactory: new _display_utils.DOMSVGFactory(),\n          annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),\n          enableScripting: parameters.enableScripting,\n          hasJSActions: parameters.hasJSActions,\n          mouseState: parameters.mouseState || {\n            isDown: false\n          }\n        });\n\n        if (element.isRenderable) {\n          var rendered = element.render();\n\n          if (data.hidden) {\n            rendered.style.visibility = \"hidden\";\n          }\n\n          if (Array.isArray(rendered)) {\n            var _iterator12 = _createForOfIteratorHelper(rendered),\n                _step12;\n\n            try {\n              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                var renderedElement = _step12.value;\n                parameters.div.appendChild(renderedElement);\n              }\n            } catch (err) {\n              _iterator12.e(err);\n            } finally {\n              _iterator12.f();\n            }\n          } else {\n            if (element instanceof PopupAnnotationElement) {\n              parameters.div.prepend(rendered);\n            } else {\n              parameters.div.appendChild(rendered);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(parameters) {\n      var transform = \"matrix(\".concat(parameters.viewport.transform.join(\",\"), \")\");\n\n      var _iterator13 = _createForOfIteratorHelper(parameters.annotations),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var data = _step13.value;\n          var elements = parameters.div.querySelectorAll(\"[data-annotation-id=\\\"\".concat(data.id, \"\\\"]\"));\n\n          if (elements) {\n            elements.forEach(function (element) {\n              element.style.transform = transform;\n            });\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      parameters.div.hidden = false;\n    }\n  }]);\n\n  return AnnotationLayer;\n}();\n\nexports.AnnotationLayer = AnnotationLayer;\n\n/***/ }),\n/* 150 */\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ColorConverters = void 0;\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction makeColorComp(n) {\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\n\nvar ColorConverters = /*#__PURE__*/function () {\n  function ColorConverters() {\n    _classCallCheck(this, ColorConverters);\n  }\n\n  _createClass(ColorConverters, null, [{\n    key: \"CMYK_G\",\n    value: function CMYK_G(_ref) {\n      var _ref2 = _slicedToArray(_ref, 4),\n          c = _ref2[0],\n          y = _ref2[1],\n          m = _ref2[2],\n          k = _ref2[3];\n\n      return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n    }\n  }, {\n    key: \"G_CMYK\",\n    value: function G_CMYK(_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          g = _ref4[0];\n\n      return [\"CMYK\", 0, 0, 0, 1 - g];\n    }\n  }, {\n    key: \"G_RGB\",\n    value: function G_RGB(_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 1),\n          g = _ref6[0];\n\n      return [\"RGB\", g, g, g];\n    }\n  }, {\n    key: \"G_HTML\",\n    value: function G_HTML(_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 1),\n          g = _ref8[0];\n\n      var G = makeColorComp(g);\n      return \"#\".concat(G).concat(G).concat(G);\n    }\n  }, {\n    key: \"RGB_G\",\n    value: function RGB_G(_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 3),\n          r = _ref10[0],\n          g = _ref10[1],\n          b = _ref10[2];\n\n      return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n    }\n  }, {\n    key: \"RGB_HTML\",\n    value: function RGB_HTML(_ref11) {\n      var _ref12 = _slicedToArray(_ref11, 3),\n          r = _ref12[0],\n          g = _ref12[1],\n          b = _ref12[2];\n\n      var R = makeColorComp(r);\n      var G = makeColorComp(g);\n      var B = makeColorComp(b);\n      return \"#\".concat(R).concat(G).concat(B);\n    }\n  }, {\n    key: \"T_HTML\",\n    value: function T_HTML() {\n      return \"#00000000\";\n    }\n  }, {\n    key: \"CMYK_RGB\",\n    value: function CMYK_RGB(_ref13) {\n      var _ref14 = _slicedToArray(_ref13, 4),\n          c = _ref14[0],\n          y = _ref14[1],\n          m = _ref14[2],\n          k = _ref14[3];\n\n      return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n    }\n  }, {\n    key: \"CMYK_HTML\",\n    value: function CMYK_HTML(components) {\n      return this.RGB_HTML(this.CMYK_RGB(components));\n    }\n  }, {\n    key: \"RGB_CMYK\",\n    value: function RGB_CMYK(_ref15) {\n      var _ref16 = _slicedToArray(_ref15, 3),\n          r = _ref16[0],\n          g = _ref16[1],\n          b = _ref16[2];\n\n      var c = 1 - r;\n      var m = 1 - g;\n      var y = 1 - b;\n      var k = Math.min(c, m, y);\n      return [\"CMYK\", c, m, y, k];\n    }\n  }]);\n\n  return ColorConverters;\n}();\n\nexports.ColorConverters = ColorConverters;\n\n/***/ }),\n/* 151 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.renderTextLayer = void 0;\n\nvar _util = __w_pdfjs_require__(4);\n\nvar renderTextLayer = function renderTextLayerClosure() {\n  var MAX_TEXT_DIVS_TO_RENDER = 100000;\n  var NonWhitespaceRegexp = /\\S/;\n\n  function isAllWhitespace(str) {\n    return !NonWhitespaceRegexp.test(str);\n  }\n\n  function appendText(task, geom, styles) {\n    var textDiv = document.createElement(\"div\");\n    var textDivProperties = {\n      angle: 0,\n      canvasWidth: 0,\n      isWhitespace: false,\n      originalTransform: null,\n      paddingBottom: 0,\n      paddingLeft: 0,\n      paddingRight: 0,\n      paddingTop: 0,\n      scale: 1\n    };\n\n    task._textDivs.push(textDiv);\n\n    if (isAllWhitespace(geom.str)) {\n      textDivProperties.isWhitespace = true;\n\n      task._textDivProperties.set(textDiv, textDivProperties);\n\n      return;\n    }\n\n    var tx = _util.Util.transform(task._viewport.transform, geom.transform);\n\n    var angle = Math.atan2(tx[1], tx[0]);\n    var style = styles[geom.fontName];\n\n    if (style.vertical) {\n      angle += Math.PI / 2;\n    }\n\n    var fontHeight = Math.hypot(tx[2], tx[3]);\n    var fontAscent = fontHeight;\n\n    if (style.ascent) {\n      fontAscent = style.ascent * fontAscent;\n    } else if (style.descent) {\n      fontAscent = (1 + style.descent) * fontAscent;\n    }\n\n    var left, top;\n\n    if (angle === 0) {\n      left = tx[4];\n      top = tx[5] - fontAscent;\n    } else {\n      left = tx[4] + fontAscent * Math.sin(angle);\n      top = tx[5] - fontAscent * Math.cos(angle);\n    }\n\n    textDiv.style.left = \"\".concat(left, \"px\");\n    textDiv.style.top = \"\".concat(top, \"px\");\n    textDiv.style.fontSize = \"\".concat(fontHeight, \"px\");\n    textDiv.style.fontFamily = style.fontFamily;\n\n    if (task._container.classList && task._container.classList.contains(\"visible\") && geom.fillColor) {\n      textDiv.style.color = \"rgb(\".concat(geom.fillColor[0], \", \").concat(geom.fillColor[1], \", \").concat(geom.fillColor[2], \");\");\n    }\n\n    textDiv.textContent = geom.str;\n    textDiv.dir = geom.dir;\n\n    if (task._fontInspectorEnabled) {\n      textDiv.dataset.fontName = geom.fontName;\n    }\n\n    if (angle !== 0) {\n      textDivProperties.angle = angle * (180 / Math.PI);\n    }\n\n    var shouldScaleText = false;\n\n    if (geom.str.length > 1) {\n      shouldScaleText = true;\n    } else if (geom.transform[0] !== geom.transform[3]) {\n      var absScaleX = Math.abs(geom.transform[0]),\n          absScaleY = Math.abs(geom.transform[3]);\n\n      if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n        shouldScaleText = true;\n      }\n    }\n\n    if (shouldScaleText) {\n      if (style.vertical) {\n        textDivProperties.canvasWidth = geom.height * task._viewport.scale;\n      } else {\n        textDivProperties.canvasWidth = geom.width * task._viewport.scale;\n      }\n    }\n\n    task._textDivProperties.set(textDiv, textDivProperties);\n\n    if (task._textContentStream) {\n      task._layoutText(textDiv);\n    }\n\n    if (task._enhanceTextSelection) {\n      var angleCos = 1,\n          angleSin = 0;\n\n      if (angle !== 0) {\n        angleCos = Math.cos(angle);\n        angleSin = Math.sin(angle);\n      }\n\n      var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;\n      var divHeight = fontHeight;\n      var m, b;\n\n      if (angle !== 0) {\n        m = [angleCos, angleSin, -angleSin, angleCos, left, top];\n        b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);\n      } else {\n        b = [left, top, left + divWidth, top + divHeight];\n      }\n\n      task._bounds.push({\n        left: b[0],\n        top: b[1],\n        right: b[2],\n        bottom: b[3],\n        div: textDiv,\n        size: [divWidth, divHeight],\n        m: m\n      });\n    }\n  }\n\n  function render(task) {\n    if (task._canceled) {\n      return;\n    }\n\n    var textDivs = task._textDivs;\n    var capability = task._capability;\n    var textDivsLength = textDivs.length;\n\n    if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n      task._renderingDone = true;\n      capability.resolve();\n      return;\n    }\n\n    if (!task._textContentStream) {\n      for (var i = 0; i < textDivsLength; i++) {\n        task._layoutText(textDivs[i]);\n      }\n    }\n\n    task._renderingDone = true;\n    capability.resolve();\n  }\n\n  function findPositiveMin(ts, offset, count) {\n    var result = 0;\n\n    for (var i = 0; i < count; i++) {\n      var t = ts[offset++];\n\n      if (t > 0) {\n        result = result ? Math.min(t, result) : t;\n      }\n    }\n\n    return result;\n  }\n\n  function expand(task) {\n    var bounds = task._bounds;\n    var viewport = task._viewport;\n    var expanded = expandBounds(viewport.width, viewport.height, bounds);\n\n    var _loop = function _loop(i) {\n      var div = bounds[i].div;\n\n      var divProperties = task._textDivProperties.get(div);\n\n      if (divProperties.angle === 0) {\n        divProperties.paddingLeft = bounds[i].left - expanded[i].left;\n        divProperties.paddingTop = bounds[i].top - expanded[i].top;\n        divProperties.paddingRight = expanded[i].right - bounds[i].right;\n        divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;\n\n        task._textDivProperties.set(div, divProperties);\n\n        return \"continue\";\n      }\n\n      var e = expanded[i],\n          b = bounds[i];\n      var m = b.m,\n          c = m[0],\n          s = m[1];\n      var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];\n      var ts = new Float64Array(64);\n      points.forEach(function (p, j) {\n        var t = _util.Util.applyTransform(p, m);\n\n        ts[j + 0] = c && (e.left - t[0]) / c;\n        ts[j + 4] = s && (e.top - t[1]) / s;\n        ts[j + 8] = c && (e.right - t[0]) / c;\n        ts[j + 12] = s && (e.bottom - t[1]) / s;\n        ts[j + 16] = s && (e.left - t[0]) / -s;\n        ts[j + 20] = c && (e.top - t[1]) / c;\n        ts[j + 24] = s && (e.right - t[0]) / -s;\n        ts[j + 28] = c && (e.bottom - t[1]) / c;\n        ts[j + 32] = c && (e.left - t[0]) / -c;\n        ts[j + 36] = s && (e.top - t[1]) / -s;\n        ts[j + 40] = c && (e.right - t[0]) / -c;\n        ts[j + 44] = s && (e.bottom - t[1]) / -s;\n        ts[j + 48] = s && (e.left - t[0]) / s;\n        ts[j + 52] = c && (e.top - t[1]) / -c;\n        ts[j + 56] = s && (e.right - t[0]) / s;\n        ts[j + 60] = c && (e.bottom - t[1]) / -c;\n      });\n      var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));\n      divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;\n      divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;\n      divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;\n      divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;\n\n      task._textDivProperties.set(div, divProperties);\n    };\n\n    for (var i = 0; i < expanded.length; i++) {\n      var _ret = _loop(i);\n\n      if (_ret === \"continue\") continue;\n    }\n  }\n\n  function expandBounds(width, height, boxes) {\n    var bounds = boxes.map(function (box, i) {\n      return {\n        x1: box.left,\n        y1: box.top,\n        x2: box.right,\n        y2: box.bottom,\n        index: i,\n        x1New: undefined,\n        x2New: undefined\n      };\n    });\n    expandBoundsLTR(width, bounds);\n    var expanded = new Array(boxes.length);\n    bounds.forEach(function (b) {\n      var i = b.index;\n      expanded[i] = {\n        left: b.x1New,\n        top: 0,\n        right: b.x2New,\n        bottom: 0\n      };\n    });\n    boxes.map(function (box, i) {\n      var e = expanded[i],\n          b = bounds[i];\n      b.x1 = box.top;\n      b.y1 = width - e.right;\n      b.x2 = box.bottom;\n      b.y2 = width - e.left;\n      b.index = i;\n      b.x1New = undefined;\n      b.x2New = undefined;\n    });\n    expandBoundsLTR(height, bounds);\n    bounds.forEach(function (b) {\n      var i = b.index;\n      expanded[i].top = b.x1New;\n      expanded[i].bottom = b.x2New;\n    });\n    return expanded;\n  }\n\n  function expandBoundsLTR(width, bounds) {\n    bounds.sort(function (a, b) {\n      return a.x1 - b.x1 || a.index - b.index;\n    });\n    var fakeBoundary = {\n      x1: -Infinity,\n      y1: -Infinity,\n      x2: 0,\n      y2: Infinity,\n      index: -1,\n      x1New: 0,\n      x2New: 0\n    };\n    var horizon = [{\n      start: -Infinity,\n      end: Infinity,\n      boundary: fakeBoundary\n    }];\n    bounds.forEach(function (boundary) {\n      var i = 0;\n\n      while (i < horizon.length && horizon[i].end <= boundary.y1) {\n        i++;\n      }\n\n      var j = horizon.length - 1;\n\n      while (j >= 0 && horizon[j].start >= boundary.y2) {\n        j--;\n      }\n\n      var horizonPart, affectedBoundary;\n      var q,\n          k,\n          maxXNew = -Infinity;\n\n      for (q = i; q <= j; q++) {\n        horizonPart = horizon[q];\n        affectedBoundary = horizonPart.boundary;\n        var xNew = void 0;\n\n        if (affectedBoundary.x2 > boundary.x1) {\n          xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;\n        } else if (affectedBoundary.x2New === undefined) {\n          xNew = (affectedBoundary.x2 + boundary.x1) / 2;\n        } else {\n          xNew = affectedBoundary.x2New;\n        }\n\n        if (xNew > maxXNew) {\n          maxXNew = xNew;\n        }\n      }\n\n      boundary.x1New = maxXNew;\n\n      for (q = i; q <= j; q++) {\n        horizonPart = horizon[q];\n        affectedBoundary = horizonPart.boundary;\n\n        if (affectedBoundary.x2New === undefined) {\n          if (affectedBoundary.x2 > boundary.x1) {\n            if (affectedBoundary.index > boundary.index) {\n              affectedBoundary.x2New = affectedBoundary.x2;\n            }\n          } else {\n            affectedBoundary.x2New = maxXNew;\n          }\n        } else if (affectedBoundary.x2New > maxXNew) {\n          affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);\n        }\n      }\n\n      var changedHorizon = [];\n      var lastBoundary = null;\n\n      for (q = i; q <= j; q++) {\n        horizonPart = horizon[q];\n        affectedBoundary = horizonPart.boundary;\n        var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;\n\n        if (lastBoundary === useBoundary) {\n          changedHorizon[changedHorizon.length - 1].end = horizonPart.end;\n        } else {\n          changedHorizon.push({\n            start: horizonPart.start,\n            end: horizonPart.end,\n            boundary: useBoundary\n          });\n          lastBoundary = useBoundary;\n        }\n      }\n\n      if (horizon[i].start < boundary.y1) {\n        changedHorizon[0].start = boundary.y1;\n        changedHorizon.unshift({\n          start: horizon[i].start,\n          end: boundary.y1,\n          boundary: horizon[i].boundary\n        });\n      }\n\n      if (boundary.y2 < horizon[j].end) {\n        changedHorizon[changedHorizon.length - 1].end = boundary.y2;\n        changedHorizon.push({\n          start: boundary.y2,\n          end: horizon[j].end,\n          boundary: horizon[j].boundary\n        });\n      }\n\n      for (q = i; q <= j; q++) {\n        horizonPart = horizon[q];\n        affectedBoundary = horizonPart.boundary;\n\n        if (affectedBoundary.x2New !== undefined) {\n          continue;\n        }\n\n        var used = false;\n\n        for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {\n          used = horizon[k].boundary === affectedBoundary;\n        }\n\n        for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {\n          used = horizon[k].boundary === affectedBoundary;\n        }\n\n        for (k = 0; !used && k < changedHorizon.length; k++) {\n          used = changedHorizon[k].boundary === affectedBoundary;\n        }\n\n        if (!used) {\n          affectedBoundary.x2New = maxXNew;\n        }\n      }\n\n      Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));\n    });\n    horizon.forEach(function (horizonPart) {\n      var affectedBoundary = horizonPart.boundary;\n\n      if (affectedBoundary.x2New === undefined) {\n        affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);\n      }\n    });\n  }\n\n  function TextLayerRenderTask(_ref) {\n    var _globalThis$FontInspe,\n        _this = this;\n\n    var textContent = _ref.textContent,\n        textContentStream = _ref.textContentStream,\n        container = _ref.container,\n        viewport = _ref.viewport,\n        textDivs = _ref.textDivs,\n        textContentItemsStr = _ref.textContentItemsStr,\n        enhanceTextSelection = _ref.enhanceTextSelection;\n    this._textContent = textContent;\n    this._textContentStream = textContentStream;\n    this._container = container;\n    this._document = container.ownerDocument;\n    this._viewport = viewport;\n    this._textDivs = textDivs || [];\n    this._textContentItemsStr = textContentItemsStr || [];\n    this._enhanceTextSelection = !!enhanceTextSelection;\n    this._fontInspectorEnabled = !!((_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled);\n    this._reader = null;\n    this._layoutTextLastFontSize = null;\n    this._layoutTextLastFontFamily = null;\n    this._layoutTextCtx = null;\n    this._textDivProperties = new WeakMap();\n    this._renderingDone = false;\n    this._canceled = false;\n    this._capability = (0, _util.createPromiseCapability)();\n    this._renderTimer = null;\n    this._bounds = [];\n\n    this._capability.promise[\"finally\"](function () {\n      if (_this._layoutTextCtx) {\n        _this._layoutTextCtx.canvas.width = 0;\n        _this._layoutTextCtx.canvas.height = 0;\n        _this._layoutTextCtx = null;\n      }\n    })[\"catch\"](function () {});\n  }\n\n  TextLayerRenderTask.prototype = {\n    get promise() {\n      return this._capability.promise;\n    },\n\n    cancel: function TextLayer_cancel() {\n      this._canceled = true;\n\n      if (this._reader) {\n        this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\"));\n\n        this._reader = null;\n      }\n\n      if (this._renderTimer !== null) {\n        clearTimeout(this._renderTimer);\n        this._renderTimer = null;\n      }\n\n      this._capability.reject(new Error(\"TextLayer task cancelled.\"));\n    },\n    _processItems: function _processItems(items, styleCache) {\n      for (var i = 0, len = items.length; i < len; i++) {\n        this._textContentItemsStr.push(items[i].str);\n\n        appendText(this, items[i], styleCache);\n      }\n    },\n    _layoutText: function _layoutText(textDiv) {\n      var textDivProperties = this._textDivProperties.get(textDiv);\n\n      if (textDivProperties.isWhitespace) {\n        return;\n      }\n\n      var transform = \"\";\n\n      if (textDivProperties.canvasWidth !== 0) {\n        var _textDiv$style = textDiv.style,\n            fontSize = _textDiv$style.fontSize,\n            fontFamily = _textDiv$style.fontFamily;\n\n        if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {\n          this._layoutTextCtx.font = \"\".concat(fontSize, \" \").concat(fontFamily);\n          this._layoutTextLastFontSize = fontSize;\n          this._layoutTextLastFontFamily = fontFamily;\n        }\n\n        var _this$_layoutTextCtx$ = this._layoutTextCtx.measureText(textDiv.textContent),\n            width = _this$_layoutTextCtx$.width;\n\n        if (width > 0) {\n          textDivProperties.scale = textDivProperties.canvasWidth / width;\n          transform = \"scaleX(\".concat(textDivProperties.scale, \")\");\n        }\n      }\n\n      if (textDivProperties.angle !== 0) {\n        transform = \"rotate(\".concat(textDivProperties.angle, \"deg) \").concat(transform);\n      }\n\n      if (transform.length > 0) {\n        if (this._enhanceTextSelection) {\n          textDivProperties.originalTransform = transform;\n        }\n\n        textDiv.style.transform = transform;\n      }\n\n      this._textDivProperties.set(textDiv, textDivProperties);\n\n      this._container.appendChild(textDiv);\n    },\n    _render: function TextLayer_render(timeout) {\n      var _this2 = this;\n\n      var capability = (0, _util.createPromiseCapability)();\n      var styleCache = Object.create(null);\n\n      var canvas = this._document.createElement(\"canvas\");\n\n      canvas.mozOpaque = true;\n      this._layoutTextCtx = canvas.getContext(\"2d\", {\n        alpha: false\n      });\n\n      if (this._textContent) {\n        var textItems = this._textContent.items;\n        var textStyles = this._textContent.styles;\n\n        this._processItems(textItems, textStyles);\n\n        capability.resolve();\n      } else if (this._textContentStream) {\n        var pump = function pump() {\n          _this2._reader.read().then(function (_ref2) {\n            var value = _ref2.value,\n                done = _ref2.done;\n\n            if (done) {\n              capability.resolve();\n              return;\n            }\n\n            Object.assign(styleCache, value.styles);\n\n            _this2._processItems(value.items, styleCache);\n\n            pump();\n          }, capability.reject);\n        };\n\n        this._reader = this._textContentStream.getReader();\n        pump();\n      } else {\n        throw new Error('Neither \"textContent\" nor \"textContentStream\"' + \" parameters specified.\");\n      }\n\n      capability.promise.then(function () {\n        styleCache = null;\n\n        if (!timeout) {\n          render(_this2);\n        } else {\n          _this2._renderTimer = setTimeout(function () {\n            render(_this2);\n            _this2._renderTimer = null;\n          }, timeout);\n        }\n      }, this._capability.reject);\n    },\n    expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {\n      if (!this._enhanceTextSelection || !this._renderingDone) {\n        return;\n      }\n\n      if (this._bounds !== null) {\n        expand(this);\n        this._bounds = null;\n      }\n\n      var transformBuf = [],\n          paddingBuf = [];\n\n      for (var i = 0, ii = this._textDivs.length; i < ii; i++) {\n        var div = this._textDivs[i];\n\n        var divProps = this._textDivProperties.get(div);\n\n        if (divProps.isWhitespace) {\n          continue;\n        }\n\n        if (expandDivs) {\n          transformBuf.length = 0;\n          paddingBuf.length = 0;\n\n          if (divProps.originalTransform) {\n            transformBuf.push(divProps.originalTransform);\n          }\n\n          if (divProps.paddingTop > 0) {\n            paddingBuf.push(\"\".concat(divProps.paddingTop, \"px\"));\n            transformBuf.push(\"translateY(\".concat(-divProps.paddingTop, \"px)\"));\n          } else {\n            paddingBuf.push(0);\n          }\n\n          if (divProps.paddingRight > 0) {\n            paddingBuf.push(\"\".concat(divProps.paddingRight / divProps.scale, \"px\"));\n          } else {\n            paddingBuf.push(0);\n          }\n\n          if (divProps.paddingBottom > 0) {\n            paddingBuf.push(\"\".concat(divProps.paddingBottom, \"px\"));\n          } else {\n            paddingBuf.push(0);\n          }\n\n          if (divProps.paddingLeft > 0) {\n            paddingBuf.push(\"\".concat(divProps.paddingLeft / divProps.scale, \"px\"));\n            transformBuf.push(\"translateX(\".concat(-divProps.paddingLeft / divProps.scale, \"px)\"));\n          } else {\n            paddingBuf.push(0);\n          }\n\n          div.style.padding = paddingBuf.join(\" \");\n\n          if (transformBuf.length) {\n            div.style.transform = transformBuf.join(\" \");\n          }\n        } else {\n          div.style.padding = null;\n          div.style.transform = divProps.originalTransform;\n        }\n      }\n    }\n  };\n\n  function renderTextLayer(renderParameters) {\n    var task = new TextLayerRenderTask({\n      textContent: renderParameters.textContent,\n      textContentStream: renderParameters.textContentStream,\n      container: renderParameters.container,\n      viewport: renderParameters.viewport,\n      textDivs: renderParameters.textDivs,\n      textContentItemsStr: renderParameters.textContentItemsStr,\n      enhanceTextSelection: renderParameters.enhanceTextSelection\n    });\n\n    task._render(renderParameters.timeout);\n\n    return task;\n  }\n\n  return renderTextLayer;\n}();\n\nexports.renderTextLayer = renderTextLayer;\n\n/***/ }),\n/* 152 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SVGGraphics = void 0;\n\nvar _util = __w_pdfjs_require__(4);\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _is_node = __w_pdfjs_require__(6);\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar SVGGraphics = function SVGGraphics() {\n  throw new Error(\"Not implemented: SVGGraphics\");\n};\n\nexports.SVGGraphics = SVGGraphics;\n{\n  var opListToTree = function opListToTree(opList) {\n    var opTree = [];\n    var tmp = [];\n\n    var _iterator = _createForOfIteratorHelper(opList),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var opListElement = _step.value;\n\n        if (opListElement.fn === \"save\") {\n          opTree.push({\n            fnId: 92,\n            fn: \"group\",\n            items: []\n          });\n          tmp.push(opTree);\n          opTree = opTree[opTree.length - 1].items;\n          continue;\n        }\n\n        if (opListElement.fn === \"restore\") {\n          opTree = tmp.pop();\n        } else {\n          opTree.push(opListElement);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return opTree;\n  };\n\n  var pf = function pf(value) {\n    if (Number.isInteger(value)) {\n      return value.toString();\n    }\n\n    var s = value.toFixed(10);\n    var i = s.length - 1;\n\n    if (s[i] !== \"0\") {\n      return s;\n    }\n\n    do {\n      i--;\n    } while (s[i] === \"0\");\n\n    return s.substring(0, s[i] === \".\" ? i : i + 1);\n  };\n\n  var pm = function pm(m) {\n    if (m[4] === 0 && m[5] === 0) {\n      if (m[1] === 0 && m[2] === 0) {\n        if (m[0] === 1 && m[3] === 1) {\n          return \"\";\n        }\n\n        return \"scale(\".concat(pf(m[0]), \" \").concat(pf(m[3]), \")\");\n      }\n\n      if (m[0] === m[3] && m[1] === -m[2]) {\n        var a = Math.acos(m[0]) * 180 / Math.PI;\n        return \"rotate(\".concat(pf(a), \")\");\n      }\n    } else {\n      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n        return \"translate(\".concat(pf(m[4]), \" \").concat(pf(m[5]), \")\");\n      }\n    }\n\n    return \"matrix(\".concat(pf(m[0]), \" \").concat(pf(m[1]), \" \").concat(pf(m[2]), \" \").concat(pf(m[3]), \" \").concat(pf(m[4]), \" \") + \"\".concat(pf(m[5]), \")\");\n  };\n\n  var SVG_DEFAULTS = {\n    fontStyle: \"normal\",\n    fontWeight: \"normal\",\n    fillColor: \"#000000\"\n  };\n  var XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n  var XLINK_NS = \"http://www.w3.org/1999/xlink\";\n  var LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n  var LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n\n  var convertImgDataToPng = function () {\n    var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n    var CHUNK_WRAPPER_SIZE = 12;\n    var crcTable = new Int32Array(256);\n\n    for (var i = 0; i < 256; i++) {\n      var c = i;\n\n      for (var h = 0; h < 8; h++) {\n        if (c & 1) {\n          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;\n        } else {\n          c = c >> 1 & 0x7fffffff;\n        }\n      }\n\n      crcTable[i] = c;\n    }\n\n    function crc32(data, start, end) {\n      var crc = -1;\n\n      for (var _i = start; _i < end; _i++) {\n        var a = (crc ^ data[_i]) & 0xff;\n        var b = crcTable[a];\n        crc = crc >>> 8 ^ b;\n      }\n\n      return crc ^ -1;\n    }\n\n    function writePngChunk(type, body, data, offset) {\n      var p = offset;\n      var len = body.length;\n      data[p] = len >> 24 & 0xff;\n      data[p + 1] = len >> 16 & 0xff;\n      data[p + 2] = len >> 8 & 0xff;\n      data[p + 3] = len & 0xff;\n      p += 4;\n      data[p] = type.charCodeAt(0) & 0xff;\n      data[p + 1] = type.charCodeAt(1) & 0xff;\n      data[p + 2] = type.charCodeAt(2) & 0xff;\n      data[p + 3] = type.charCodeAt(3) & 0xff;\n      p += 4;\n      data.set(body, p);\n      p += body.length;\n      var crc = crc32(data, offset + 4, p);\n      data[p] = crc >> 24 & 0xff;\n      data[p + 1] = crc >> 16 & 0xff;\n      data[p + 2] = crc >> 8 & 0xff;\n      data[p + 3] = crc & 0xff;\n    }\n\n    function adler32(data, start, end) {\n      var a = 1;\n      var b = 0;\n\n      for (var _i2 = start; _i2 < end; ++_i2) {\n        a = (a + (data[_i2] & 0xff)) % 65521;\n        b = (b + a) % 65521;\n      }\n\n      return b << 16 | a;\n    }\n\n    function deflateSync(literals) {\n      if (!_is_node.isNodeJS) {\n        return deflateSyncUncompressed(literals);\n      }\n\n      try {\n        var input;\n\n        if (parseInt(process.versions.node) >= 8) {\n          input = literals;\n        } else {\n          input = Buffer.from(literals);\n        }\n\n        var output = (__webpack_require__(/*! zlib */ \"?331b\").deflateSync)(input, {\n          level: 9\n        });\n\n        return output instanceof Uint8Array ? output : new Uint8Array(output);\n      } catch (e) {\n        (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n      }\n\n      return deflateSyncUncompressed(literals);\n    }\n\n    function deflateSyncUncompressed(literals) {\n      var len = literals.length;\n      var maxBlockLength = 0xffff;\n      var deflateBlocks = Math.ceil(len / maxBlockLength);\n      var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n      var pi = 0;\n      idat[pi++] = 0x78;\n      idat[pi++] = 0x9c;\n      var pos = 0;\n\n      while (len > maxBlockLength) {\n        idat[pi++] = 0x00;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0x00;\n        idat[pi++] = 0x00;\n        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n        pi += maxBlockLength;\n        pos += maxBlockLength;\n        len -= maxBlockLength;\n      }\n\n      idat[pi++] = 0x01;\n      idat[pi++] = len & 0xff;\n      idat[pi++] = len >> 8 & 0xff;\n      idat[pi++] = ~len & 0xffff & 0xff;\n      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n      idat.set(literals.subarray(pos), pi);\n      pi += literals.length - pos;\n      var adler = adler32(literals, 0, literals.length);\n      idat[pi++] = adler >> 24 & 0xff;\n      idat[pi++] = adler >> 16 & 0xff;\n      idat[pi++] = adler >> 8 & 0xff;\n      idat[pi++] = adler & 0xff;\n      return idat;\n    }\n\n    function encode(imgData, kind, forceDataSchema, isMask) {\n      var width = imgData.width;\n      var height = imgData.height;\n      var bitDepth, colorType, lineSize;\n      var bytes = imgData.data;\n\n      switch (kind) {\n        case _util.ImageKind.GRAYSCALE_1BPP:\n          colorType = 0;\n          bitDepth = 1;\n          lineSize = width + 7 >> 3;\n          break;\n\n        case _util.ImageKind.RGB_24BPP:\n          colorType = 2;\n          bitDepth = 8;\n          lineSize = width * 3;\n          break;\n\n        case _util.ImageKind.RGBA_32BPP:\n          colorType = 6;\n          bitDepth = 8;\n          lineSize = width * 4;\n          break;\n\n        default:\n          throw new Error(\"invalid format\");\n      }\n\n      var literals = new Uint8Array((1 + lineSize) * height);\n      var offsetLiterals = 0,\n          offsetBytes = 0;\n\n      for (var y = 0; y < height; ++y) {\n        literals[offsetLiterals++] = 0;\n        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n        offsetBytes += lineSize;\n        offsetLiterals += lineSize;\n      }\n\n      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n        offsetLiterals = 0;\n\n        for (var _y = 0; _y < height; _y++) {\n          offsetLiterals++;\n\n          for (var _i3 = 0; _i3 < lineSize; _i3++) {\n            literals[offsetLiterals++] ^= 0xff;\n          }\n        }\n      }\n\n      var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\n      var idat = deflateSync(literals);\n      var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n      var data = new Uint8Array(pngLength);\n      var offset = 0;\n      data.set(PNG_HEADER, offset);\n      offset += PNG_HEADER.length;\n      writePngChunk(\"IHDR\", ihdr, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n      writePngChunk(\"IDATA\", idat, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + idat.length;\n      writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n      return (0, _util.createObjectURL)(data, \"image/png\", forceDataSchema);\n    }\n\n    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n      var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n      return encode(imgData, kind, forceDataSchema, isMask);\n    };\n  }();\n\n  var SVGExtraState = /*#__PURE__*/function () {\n    function SVGExtraState() {\n      _classCallCheck(this, SVGExtraState);\n\n      this.fontSizeScale = 1;\n      this.fontWeight = SVG_DEFAULTS.fontWeight;\n      this.fontSize = 0;\n      this.textMatrix = _util.IDENTITY_MATRIX;\n      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n      this.leading = 0;\n      this.textRenderingMode = _util.TextRenderingMode.FILL;\n      this.textMatrixScale = 1;\n      this.x = 0;\n      this.y = 0;\n      this.lineX = 0;\n      this.lineY = 0;\n      this.charSpacing = 0;\n      this.wordSpacing = 0;\n      this.textHScale = 1;\n      this.textRise = 0;\n      this.fillColor = SVG_DEFAULTS.fillColor;\n      this.strokeColor = \"#000000\";\n      this.fillAlpha = 1;\n      this.strokeAlpha = 1;\n      this.lineWidth = 1;\n      this.lineJoin = \"\";\n      this.lineCap = \"\";\n      this.miterLimit = 0;\n      this.dashArray = [];\n      this.dashPhase = 0;\n      this.dependencies = [];\n      this.activeClipUrl = null;\n      this.clipGroup = null;\n      this.maskId = \"\";\n    }\n\n    _createClass(SVGExtraState, [{\n      key: \"clone\",\n      value: function clone() {\n        return Object.create(this);\n      }\n    }, {\n      key: \"setCurrentPoint\",\n      value: function setCurrentPoint(x, y) {\n        this.x = x;\n        this.y = y;\n      }\n    }]);\n\n    return SVGExtraState;\n  }();\n\n  var clipCount = 0;\n  var maskCount = 0;\n  var shadingCount = 0;\n\n  exports.SVGGraphics = SVGGraphics = /*#__PURE__*/function () {\n    function SVGGraphics(commonObjs, objs) {\n      var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      _classCallCheck(this, SVGGraphics);\n\n      this.svgFactory = new _display_utils.DOMSVGFactory();\n      this.current = new SVGExtraState();\n      this.transformMatrix = _util.IDENTITY_MATRIX;\n      this.transformStack = [];\n      this.extraStack = [];\n      this.commonObjs = commonObjs;\n      this.objs = objs;\n      this.pendingClip = null;\n      this.pendingEOFill = false;\n      this.embedFonts = false;\n      this.embeddedFonts = Object.create(null);\n      this.cssStyle = null;\n      this.forceDataSchema = !!forceDataSchema;\n      this._operatorIdMapping = [];\n\n      for (var op in _util.OPS) {\n        this._operatorIdMapping[_util.OPS[op]] = op;\n      }\n    }\n\n    _createClass(SVGGraphics, [{\n      key: \"save\",\n      value: function save() {\n        this.transformStack.push(this.transformMatrix);\n        var old = this.current;\n        this.extraStack.push(old);\n        this.current = old.clone();\n      }\n    }, {\n      key: \"restore\",\n      value: function restore() {\n        this.transformMatrix = this.transformStack.pop();\n        this.current = this.extraStack.pop();\n        this.pendingClip = null;\n        this.tgrp = null;\n      }\n    }, {\n      key: \"group\",\n      value: function group(items) {\n        this.save();\n        this.executeOpTree(items);\n        this.restore();\n      }\n    }, {\n      key: \"loadDependencies\",\n      value: function loadDependencies(operatorList) {\n        var _this = this;\n\n        var fnArray = operatorList.fnArray;\n        var argsArray = operatorList.argsArray;\n\n        for (var i = 0, ii = fnArray.length; i < ii; i++) {\n          if (fnArray[i] !== _util.OPS.dependency) {\n            continue;\n          }\n\n          var _iterator2 = _createForOfIteratorHelper(argsArray[i]),\n              _step2;\n\n          try {\n            var _loop = function _loop() {\n              var obj = _step2.value;\n              var objsPool = obj.startsWith(\"g_\") ? _this.commonObjs : _this.objs;\n              var promise = new Promise(function (resolve) {\n                objsPool.get(obj, resolve);\n              });\n\n              _this.current.dependencies.push(promise);\n            };\n\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              _loop();\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        return Promise.all(this.current.dependencies);\n      }\n    }, {\n      key: \"transform\",\n      value: function transform(a, b, c, d, e, f) {\n        var transformMatrix = [a, b, c, d, e, f];\n        this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n        this.tgrp = null;\n      }\n    }, {\n      key: \"getSVG\",\n      value: function getSVG(operatorList, viewport) {\n        var _this2 = this;\n\n        this.viewport = viewport;\n\n        var svgElement = this._initialize(viewport);\n\n        return this.loadDependencies(operatorList).then(function () {\n          _this2.transformMatrix = _util.IDENTITY_MATRIX;\n\n          _this2.executeOpTree(_this2.convertOpList(operatorList));\n\n          return svgElement;\n        });\n      }\n    }, {\n      key: \"convertOpList\",\n      value: function convertOpList(operatorList) {\n        var operatorIdMapping = this._operatorIdMapping;\n        var argsArray = operatorList.argsArray;\n        var fnArray = operatorList.fnArray;\n        var opList = [];\n\n        for (var i = 0, ii = fnArray.length; i < ii; i++) {\n          var fnId = fnArray[i];\n          opList.push({\n            fnId: fnId,\n            fn: operatorIdMapping[fnId],\n            args: argsArray[i]\n          });\n        }\n\n        return opListToTree(opList);\n      }\n    }, {\n      key: \"executeOpTree\",\n      value: function executeOpTree(opTree) {\n        var _iterator3 = _createForOfIteratorHelper(opTree),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var opTreeElement = _step3.value;\n            var fn = opTreeElement.fn;\n            var fnId = opTreeElement.fnId;\n            var args = opTreeElement.args;\n\n            switch (fnId | 0) {\n              case _util.OPS.beginText:\n                this.beginText();\n                break;\n\n              case _util.OPS.dependency:\n                break;\n\n              case _util.OPS.setLeading:\n                this.setLeading(args);\n                break;\n\n              case _util.OPS.setLeadingMoveText:\n                this.setLeadingMoveText(args[0], args[1]);\n                break;\n\n              case _util.OPS.setFont:\n                this.setFont(args);\n                break;\n\n              case _util.OPS.showText:\n                this.showText(args[0]);\n                break;\n\n              case _util.OPS.showSpacedText:\n                this.showText(args[0]);\n                break;\n\n              case _util.OPS.endText:\n                this.endText();\n                break;\n\n              case _util.OPS.moveText:\n                this.moveText(args[0], args[1]);\n                break;\n\n              case _util.OPS.setCharSpacing:\n                this.setCharSpacing(args[0]);\n                break;\n\n              case _util.OPS.setWordSpacing:\n                this.setWordSpacing(args[0]);\n                break;\n\n              case _util.OPS.setHScale:\n                this.setHScale(args[0]);\n                break;\n\n              case _util.OPS.setTextMatrix:\n                this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n                break;\n\n              case _util.OPS.setTextRise:\n                this.setTextRise(args[0]);\n                break;\n\n              case _util.OPS.setTextRenderingMode:\n                this.setTextRenderingMode(args[0]);\n                break;\n\n              case _util.OPS.setLineWidth:\n                this.setLineWidth(args[0]);\n                break;\n\n              case _util.OPS.setLineJoin:\n                this.setLineJoin(args[0]);\n                break;\n\n              case _util.OPS.setLineCap:\n                this.setLineCap(args[0]);\n                break;\n\n              case _util.OPS.setMiterLimit:\n                this.setMiterLimit(args[0]);\n                break;\n\n              case _util.OPS.setFillRGBColor:\n                this.setFillRGBColor(args[0], args[1], args[2]);\n                break;\n\n              case _util.OPS.setStrokeRGBColor:\n                this.setStrokeRGBColor(args[0], args[1], args[2]);\n                break;\n\n              case _util.OPS.setStrokeColorN:\n                this.setStrokeColorN(args);\n                break;\n\n              case _util.OPS.setFillColorN:\n                this.setFillColorN(args);\n                break;\n\n              case _util.OPS.shadingFill:\n                this.shadingFill(args[0]);\n                break;\n\n              case _util.OPS.setDash:\n                this.setDash(args[0], args[1]);\n                break;\n\n              case _util.OPS.setRenderingIntent:\n                this.setRenderingIntent(args[0]);\n                break;\n\n              case _util.OPS.setFlatness:\n                this.setFlatness(args[0]);\n                break;\n\n              case _util.OPS.setGState:\n                this.setGState(args[0]);\n                break;\n\n              case _util.OPS.fill:\n                this.fill();\n                break;\n\n              case _util.OPS.eoFill:\n                this.eoFill();\n                break;\n\n              case _util.OPS.stroke:\n                this.stroke();\n                break;\n\n              case _util.OPS.fillStroke:\n                this.fillStroke();\n                break;\n\n              case _util.OPS.eoFillStroke:\n                this.eoFillStroke();\n                break;\n\n              case _util.OPS.clip:\n                this.clip(\"nonzero\");\n                break;\n\n              case _util.OPS.eoClip:\n                this.clip(\"evenodd\");\n                break;\n\n              case _util.OPS.paintSolidColorImageMask:\n                this.paintSolidColorImageMask();\n                break;\n\n              case _util.OPS.paintImageXObject:\n                this.paintImageXObject(args[0]);\n                break;\n\n              case _util.OPS.paintInlineImageXObject:\n                this.paintInlineImageXObject(args[0]);\n                break;\n\n              case _util.OPS.paintImageMaskXObject:\n                this.paintImageMaskXObject(args[0]);\n                break;\n\n              case _util.OPS.paintFormXObjectBegin:\n                this.paintFormXObjectBegin(args[0], args[1]);\n                break;\n\n              case _util.OPS.paintFormXObjectEnd:\n                this.paintFormXObjectEnd();\n                break;\n\n              case _util.OPS.closePath:\n                this.closePath();\n                break;\n\n              case _util.OPS.closeStroke:\n                this.closeStroke();\n                break;\n\n              case _util.OPS.closeFillStroke:\n                this.closeFillStroke();\n                break;\n\n              case _util.OPS.closeEOFillStroke:\n                this.closeEOFillStroke();\n                break;\n\n              case _util.OPS.nextLine:\n                this.nextLine();\n                break;\n\n              case _util.OPS.transform:\n                this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n                break;\n\n              case _util.OPS.constructPath:\n                this.constructPath(args[0], args[1]);\n                break;\n\n              case _util.OPS.endPath:\n                this.endPath();\n                break;\n\n              case 92:\n                this.group(opTreeElement.items);\n                break;\n\n              default:\n                (0, _util.warn)(\"Unimplemented operator \".concat(fn));\n                break;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }, {\n      key: \"setWordSpacing\",\n      value: function setWordSpacing(wordSpacing) {\n        this.current.wordSpacing = wordSpacing;\n      }\n    }, {\n      key: \"setCharSpacing\",\n      value: function setCharSpacing(charSpacing) {\n        this.current.charSpacing = charSpacing;\n      }\n    }, {\n      key: \"nextLine\",\n      value: function nextLine() {\n        this.moveText(0, this.current.leading);\n      }\n    }, {\n      key: \"setTextMatrix\",\n      value: function setTextMatrix(a, b, c, d, e, f) {\n        var current = this.current;\n        current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n        current.textMatrixScale = Math.hypot(a, b);\n        current.x = current.lineX = 0;\n        current.y = current.lineY = 0;\n        current.xcoords = [];\n        current.ycoords = [];\n        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n        current.tspan.setAttributeNS(null, \"font-size\", \"\".concat(pf(current.fontSize), \"px\"));\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n        current.txtElement = this.svgFactory.createElement(\"svg:text\");\n        current.txtElement.appendChild(current.tspan);\n      }\n    }, {\n      key: \"beginText\",\n      value: function beginText() {\n        var current = this.current;\n        current.x = current.lineX = 0;\n        current.y = current.lineY = 0;\n        current.textMatrix = _util.IDENTITY_MATRIX;\n        current.lineMatrix = _util.IDENTITY_MATRIX;\n        current.textMatrixScale = 1;\n        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        current.txtElement = this.svgFactory.createElement(\"svg:text\");\n        current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n        current.xcoords = [];\n        current.ycoords = [];\n      }\n    }, {\n      key: \"moveText\",\n      value: function moveText(x, y) {\n        var current = this.current;\n        current.x = current.lineX += x;\n        current.y = current.lineY += y;\n        current.xcoords = [];\n        current.ycoords = [];\n        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n        current.tspan.setAttributeNS(null, \"font-size\", \"\".concat(pf(current.fontSize), \"px\"));\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      }\n    }, {\n      key: \"showText\",\n      value: function showText(glyphs) {\n        var current = this.current;\n        var font = current.font;\n        var fontSize = current.fontSize;\n\n        if (fontSize === 0) {\n          return;\n        }\n\n        var fontSizeScale = current.fontSizeScale;\n        var charSpacing = current.charSpacing;\n        var wordSpacing = current.wordSpacing;\n        var fontDirection = current.fontDirection;\n        var textHScale = current.textHScale * fontDirection;\n        var vertical = font.vertical;\n        var spacingDir = vertical ? 1 : -1;\n        var defaultVMetrics = font.defaultVMetrics;\n        var widthAdvanceScale = fontSize * current.fontMatrix[0];\n        var x = 0;\n\n        var _iterator4 = _createForOfIteratorHelper(glyphs),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var glyph = _step4.value;\n\n            if (glyph === null) {\n              x += fontDirection * wordSpacing;\n              continue;\n            } else if ((0, _util.isNum)(glyph)) {\n              x += spacingDir * glyph * fontSize / 1000;\n              continue;\n            }\n\n            var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            var character = glyph.fontChar;\n            var scaledX = void 0,\n                scaledY = void 0;\n            var width = glyph.width;\n\n            if (vertical) {\n              var vx = void 0;\n              var vmetric = glyph.vmetric || defaultVMetrics;\n              vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n              vx = -vx * widthAdvanceScale;\n              var vy = vmetric[2] * widthAdvanceScale;\n              width = vmetric ? -vmetric[0] : width;\n              scaledX = vx / fontSizeScale;\n              scaledY = (x + vy) / fontSizeScale;\n            } else {\n              scaledX = x / fontSizeScale;\n              scaledY = 0;\n            }\n\n            if (glyph.isInFont || font.missingFile) {\n              current.xcoords.push(current.x + scaledX);\n\n              if (vertical) {\n                current.ycoords.push(-current.y + scaledY);\n              }\n\n              current.tspan.textContent += character;\n            } else {}\n\n            var charWidth = void 0;\n\n            if (vertical) {\n              charWidth = width * widthAdvanceScale - spacing * fontDirection;\n            } else {\n              charWidth = width * widthAdvanceScale + spacing * fontDirection;\n            }\n\n            x += charWidth;\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n\n        if (vertical) {\n          current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n        } else {\n          current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n        }\n\n        if (vertical) {\n          current.y -= x;\n        } else {\n          current.x += x * textHScale;\n        }\n\n        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n        current.tspan.setAttributeNS(null, \"font-size\", \"\".concat(pf(current.fontSize), \"px\"));\n\n        if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n          current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n        }\n\n        if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n          current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n        }\n\n        var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n            current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n          }\n\n          if (current.fillAlpha < 1) {\n            current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n          }\n        } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n          current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n        } else {\n          current.tspan.setAttributeNS(null, \"fill\", \"none\");\n        }\n\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          var lineWidthScale = 1 / (current.textMatrixScale || 1);\n\n          this._setStrokeAttributes(current.tspan, lineWidthScale);\n        }\n\n        var textMatrix = current.textMatrix;\n\n        if (current.textRise !== 0) {\n          textMatrix = textMatrix.slice();\n          textMatrix[5] += current.textRise;\n        }\n\n        current.txtElement.setAttributeNS(null, \"transform\", \"\".concat(pm(textMatrix), \" scale(\").concat(pf(textHScale), \", -1)\"));\n        current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n        current.txtElement.appendChild(current.tspan);\n        current.txtgrp.appendChild(current.txtElement);\n\n        this._ensureTransformGroup().appendChild(current.txtElement);\n      }\n    }, {\n      key: \"setLeadingMoveText\",\n      value: function setLeadingMoveText(x, y) {\n        this.setLeading(-y);\n        this.moveText(x, y);\n      }\n    }, {\n      key: \"addFontStyle\",\n      value: function addFontStyle(fontObj) {\n        if (!fontObj.data) {\n          throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n        }\n\n        if (!this.cssStyle) {\n          this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n          this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n          this.defs.appendChild(this.cssStyle);\n        }\n\n        var url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n        this.cssStyle.textContent += \"@font-face { font-family: \\\"\".concat(fontObj.loadedName, \"\\\";\") + \" src: url(\".concat(url, \"); }\\n\");\n      }\n    }, {\n      key: \"setFont\",\n      value: function setFont(details) {\n        var current = this.current;\n        var fontObj = this.commonObjs.get(details[0]);\n        var size = details[1];\n        current.font = fontObj;\n\n        if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n          this.addFontStyle(fontObj);\n          this.embeddedFonts[fontObj.loadedName] = fontObj;\n        }\n\n        current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n        var bold = \"normal\";\n\n        if (fontObj.black) {\n          bold = \"900\";\n        } else if (fontObj.bold) {\n          bold = \"bold\";\n        }\n\n        var italic = fontObj.italic ? \"italic\" : \"normal\";\n\n        if (size < 0) {\n          size = -size;\n          current.fontDirection = -1;\n        } else {\n          current.fontDirection = 1;\n        }\n\n        current.fontSize = size;\n        current.fontFamily = fontObj.loadedName;\n        current.fontWeight = bold;\n        current.fontStyle = italic;\n        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n        current.xcoords = [];\n        current.ycoords = [];\n      }\n    }, {\n      key: \"endText\",\n      value: function endText() {\n        var _current$txtElement;\n\n        var current = this.current;\n\n        if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && (_current$txtElement = current.txtElement) !== null && _current$txtElement !== void 0 && _current$txtElement.hasChildNodes()) {\n          current.element = current.txtElement;\n          this.clip(\"nonzero\");\n          this.endPath();\n        }\n      }\n    }, {\n      key: \"setLineWidth\",\n      value: function setLineWidth(width) {\n        if (width > 0) {\n          this.current.lineWidth = width;\n        }\n      }\n    }, {\n      key: \"setLineCap\",\n      value: function setLineCap(style) {\n        this.current.lineCap = LINE_CAP_STYLES[style];\n      }\n    }, {\n      key: \"setLineJoin\",\n      value: function setLineJoin(style) {\n        this.current.lineJoin = LINE_JOIN_STYLES[style];\n      }\n    }, {\n      key: \"setMiterLimit\",\n      value: function setMiterLimit(limit) {\n        this.current.miterLimit = limit;\n      }\n    }, {\n      key: \"setStrokeAlpha\",\n      value: function setStrokeAlpha(strokeAlpha) {\n        this.current.strokeAlpha = strokeAlpha;\n      }\n    }, {\n      key: \"setStrokeRGBColor\",\n      value: function setStrokeRGBColor(r, g, b) {\n        this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\n      }\n    }, {\n      key: \"setFillAlpha\",\n      value: function setFillAlpha(fillAlpha) {\n        this.current.fillAlpha = fillAlpha;\n      }\n    }, {\n      key: \"setFillRGBColor\",\n      value: function setFillRGBColor(r, g, b) {\n        this.current.fillColor = _util.Util.makeHexColor(r, g, b);\n        this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        this.current.xcoords = [];\n        this.current.ycoords = [];\n      }\n    }, {\n      key: \"setStrokeColorN\",\n      value: function setStrokeColorN(args) {\n        this.current.strokeColor = this._makeColorN_Pattern(args);\n      }\n    }, {\n      key: \"setFillColorN\",\n      value: function setFillColorN(args) {\n        this.current.fillColor = this._makeColorN_Pattern(args);\n      }\n    }, {\n      key: \"shadingFill\",\n      value: function shadingFill(args) {\n        var width = this.viewport.width;\n        var height = this.viewport.height;\n\n        var inv = _util.Util.inverseTransform(this.transformMatrix);\n\n        var bl = _util.Util.applyTransform([0, 0], inv);\n\n        var br = _util.Util.applyTransform([0, height], inv);\n\n        var ul = _util.Util.applyTransform([width, 0], inv);\n\n        var ur = _util.Util.applyTransform([width, height], inv);\n\n        var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n        var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n        var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n        var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n        var rect = this.svgFactory.createElement(\"svg:rect\");\n        rect.setAttributeNS(null, \"x\", x0);\n        rect.setAttributeNS(null, \"y\", y0);\n        rect.setAttributeNS(null, \"width\", x1 - x0);\n        rect.setAttributeNS(null, \"height\", y1 - y0);\n        rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n\n        if (this.current.fillAlpha < 1) {\n          rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n        }\n\n        this._ensureTransformGroup().appendChild(rect);\n      }\n    }, {\n      key: \"_makeColorN_Pattern\",\n      value: function _makeColorN_Pattern(args) {\n        if (args[0] === \"TilingPattern\") {\n          return this._makeTilingPattern(args);\n        }\n\n        return this._makeShadingPattern(args);\n      }\n    }, {\n      key: \"_makeTilingPattern\",\n      value: function _makeTilingPattern(args) {\n        var color = args[1];\n        var operatorList = args[2];\n        var matrix = args[3] || _util.IDENTITY_MATRIX;\n\n        var _args$ = _slicedToArray(args[4], 4),\n            x0 = _args$[0],\n            y0 = _args$[1],\n            x1 = _args$[2],\n            y1 = _args$[3];\n\n        var xstep = args[5];\n        var ystep = args[6];\n        var paintType = args[7];\n        var tilingId = \"shading\".concat(shadingCount++);\n\n        var _Util$applyTransform = _util.Util.applyTransform([x0, y0], matrix),\n            _Util$applyTransform2 = _slicedToArray(_Util$applyTransform, 2),\n            tx0 = _Util$applyTransform2[0],\n            ty0 = _Util$applyTransform2[1];\n\n        var _Util$applyTransform3 = _util.Util.applyTransform([x1, y1], matrix),\n            _Util$applyTransform4 = _slicedToArray(_Util$applyTransform3, 2),\n            tx1 = _Util$applyTransform4[0],\n            ty1 = _Util$applyTransform4[1];\n\n        var _Util$singularValueDe = _util.Util.singularValueDecompose2dScale(matrix),\n            _Util$singularValueDe2 = _slicedToArray(_Util$singularValueDe, 2),\n            xscale = _Util$singularValueDe2[0],\n            yscale = _Util$singularValueDe2[1];\n\n        var txstep = xstep * xscale;\n        var tystep = ystep * yscale;\n        var tiling = this.svgFactory.createElement(\"svg:pattern\");\n        tiling.setAttributeNS(null, \"id\", tilingId);\n        tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n        tiling.setAttributeNS(null, \"width\", txstep);\n        tiling.setAttributeNS(null, \"height\", tystep);\n        tiling.setAttributeNS(null, \"x\", \"\".concat(tx0));\n        tiling.setAttributeNS(null, \"y\", \"\".concat(ty0));\n        var svg = this.svg;\n        var transformMatrix = this.transformMatrix;\n        var fillColor = this.current.fillColor;\n        var strokeColor = this.current.strokeColor;\n        var bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n        this.svg = bbox;\n        this.transformMatrix = matrix;\n\n        if (paintType === 2) {\n          var cssColor = _util.Util.makeHexColor.apply(_util.Util, _toConsumableArray(color));\n\n          this.current.fillColor = cssColor;\n          this.current.strokeColor = cssColor;\n        }\n\n        this.executeOpTree(this.convertOpList(operatorList));\n        this.svg = svg;\n        this.transformMatrix = transformMatrix;\n        this.current.fillColor = fillColor;\n        this.current.strokeColor = strokeColor;\n        tiling.appendChild(bbox.childNodes[0]);\n        this.defs.appendChild(tiling);\n        return \"url(#\".concat(tilingId, \")\");\n      }\n    }, {\n      key: \"_makeShadingPattern\",\n      value: function _makeShadingPattern(args) {\n        switch (args[0]) {\n          case \"RadialAxial\":\n            var shadingId = \"shading\".concat(shadingCount++);\n            var colorStops = args[3];\n            var gradient;\n\n            switch (args[1]) {\n              case \"axial\":\n                var point0 = args[4];\n                var point1 = args[5];\n                gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n                gradient.setAttributeNS(null, \"id\", shadingId);\n                gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                gradient.setAttributeNS(null, \"x1\", point0[0]);\n                gradient.setAttributeNS(null, \"y1\", point0[1]);\n                gradient.setAttributeNS(null, \"x2\", point1[0]);\n                gradient.setAttributeNS(null, \"y2\", point1[1]);\n                break;\n\n              case \"radial\":\n                var focalPoint = args[4];\n                var circlePoint = args[5];\n                var focalRadius = args[6];\n                var circleRadius = args[7];\n                gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n                gradient.setAttributeNS(null, \"id\", shadingId);\n                gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n                gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n                gradient.setAttributeNS(null, \"r\", circleRadius);\n                gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n                gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n                gradient.setAttributeNS(null, \"fr\", focalRadius);\n                break;\n\n              default:\n                throw new Error(\"Unknown RadialAxial type: \".concat(args[1]));\n            }\n\n            var _iterator5 = _createForOfIteratorHelper(colorStops),\n                _step5;\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var colorStop = _step5.value;\n                var stop = this.svgFactory.createElement(\"svg:stop\");\n                stop.setAttributeNS(null, \"offset\", colorStop[0]);\n                stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n                gradient.appendChild(stop);\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n\n            this.defs.appendChild(gradient);\n            return \"url(#\".concat(shadingId, \")\");\n\n          case \"Mesh\":\n            (0, _util.warn)(\"Unimplemented pattern Mesh\");\n            return null;\n\n          case \"Dummy\":\n            return \"hotpink\";\n\n          default:\n            throw new Error(\"Unknown IR type: \".concat(args[0]));\n        }\n      }\n    }, {\n      key: \"setDash\",\n      value: function setDash(dashArray, dashPhase) {\n        this.current.dashArray = dashArray;\n        this.current.dashPhase = dashPhase;\n      }\n    }, {\n      key: \"constructPath\",\n      value: function constructPath(ops, args) {\n        var current = this.current;\n        var x = current.x,\n            y = current.y;\n        var d = [];\n        var j = 0;\n\n        var _iterator6 = _createForOfIteratorHelper(ops),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var op = _step6.value;\n\n            switch (op | 0) {\n              case _util.OPS.rectangle:\n                x = args[j++];\n                y = args[j++];\n                var width = args[j++];\n                var height = args[j++];\n                var xw = x + width;\n                var yh = y + height;\n                d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n                break;\n\n              case _util.OPS.moveTo:\n                x = args[j++];\n                y = args[j++];\n                d.push(\"M\", pf(x), pf(y));\n                break;\n\n              case _util.OPS.lineTo:\n                x = args[j++];\n                y = args[j++];\n                d.push(\"L\", pf(x), pf(y));\n                break;\n\n              case _util.OPS.curveTo:\n                x = args[j + 4];\n                y = args[j + 5];\n                d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n                j += 6;\n                break;\n\n              case _util.OPS.curveTo2:\n                d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n                x = args[j + 2];\n                y = args[j + 3];\n                j += 4;\n                break;\n\n              case _util.OPS.curveTo3:\n                x = args[j + 2];\n                y = args[j + 3];\n                d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n                j += 4;\n                break;\n\n              case _util.OPS.closePath:\n                d.push(\"Z\");\n                break;\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        d = d.join(\" \");\n\n        if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n          d = current.path.getAttributeNS(null, \"d\") + d;\n        } else {\n          current.path = this.svgFactory.createElement(\"svg:path\");\n\n          this._ensureTransformGroup().appendChild(current.path);\n        }\n\n        current.path.setAttributeNS(null, \"d\", d);\n        current.path.setAttributeNS(null, \"fill\", \"none\");\n        current.element = current.path;\n        current.setCurrentPoint(x, y);\n      }\n    }, {\n      key: \"endPath\",\n      value: function endPath() {\n        var current = this.current;\n        current.path = null;\n\n        if (!this.pendingClip) {\n          return;\n        }\n\n        if (!current.element) {\n          this.pendingClip = null;\n          return;\n        }\n\n        var clipId = \"clippath\".concat(clipCount++);\n        var clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n        clipPath.setAttributeNS(null, \"id\", clipId);\n        clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n        var clipElement = current.element.cloneNode(true);\n\n        if (this.pendingClip === \"evenodd\") {\n          clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n        } else {\n          clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n        }\n\n        this.pendingClip = null;\n        clipPath.appendChild(clipElement);\n        this.defs.appendChild(clipPath);\n\n        if (current.activeClipUrl) {\n          current.clipGroup = null;\n          this.extraStack.forEach(function (prev) {\n            prev.clipGroup = null;\n          });\n          clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n        }\n\n        current.activeClipUrl = \"url(#\".concat(clipId, \")\");\n        this.tgrp = null;\n      }\n    }, {\n      key: \"clip\",\n      value: function clip(type) {\n        this.pendingClip = type;\n      }\n    }, {\n      key: \"closePath\",\n      value: function closePath() {\n        var current = this.current;\n\n        if (current.path) {\n          var d = \"\".concat(current.path.getAttributeNS(null, \"d\"), \"Z\");\n          current.path.setAttributeNS(null, \"d\", d);\n        }\n      }\n    }, {\n      key: \"setLeading\",\n      value: function setLeading(leading) {\n        this.current.leading = -leading;\n      }\n    }, {\n      key: \"setTextRise\",\n      value: function setTextRise(textRise) {\n        this.current.textRise = textRise;\n      }\n    }, {\n      key: \"setTextRenderingMode\",\n      value: function setTextRenderingMode(textRenderingMode) {\n        this.current.textRenderingMode = textRenderingMode;\n      }\n    }, {\n      key: \"setHScale\",\n      value: function setHScale(scale) {\n        this.current.textHScale = scale / 100;\n      }\n    }, {\n      key: \"setRenderingIntent\",\n      value: function setRenderingIntent(intent) {}\n    }, {\n      key: \"setFlatness\",\n      value: function setFlatness(flatness) {}\n    }, {\n      key: \"setGState\",\n      value: function setGState(states) {\n        var _iterator7 = _createForOfIteratorHelper(states),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var _step7$value = _slicedToArray(_step7.value, 2),\n                key = _step7$value[0],\n                value = _step7$value[1];\n\n            switch (key) {\n              case \"LW\":\n                this.setLineWidth(value);\n                break;\n\n              case \"LC\":\n                this.setLineCap(value);\n                break;\n\n              case \"LJ\":\n                this.setLineJoin(value);\n                break;\n\n              case \"ML\":\n                this.setMiterLimit(value);\n                break;\n\n              case \"D\":\n                this.setDash(value[0], value[1]);\n                break;\n\n              case \"RI\":\n                this.setRenderingIntent(value);\n                break;\n\n              case \"FL\":\n                this.setFlatness(value);\n                break;\n\n              case \"Font\":\n                this.setFont(value);\n                break;\n\n              case \"CA\":\n                this.setStrokeAlpha(value);\n                break;\n\n              case \"ca\":\n                this.setFillAlpha(value);\n                break;\n\n              default:\n                (0, _util.warn)(\"Unimplemented graphic state operator \".concat(key));\n                break;\n            }\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n    }, {\n      key: \"fill\",\n      value: function fill() {\n        var current = this.current;\n\n        if (current.element) {\n          current.element.setAttributeNS(null, \"fill\", current.fillColor);\n          current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n          this.endPath();\n        }\n      }\n    }, {\n      key: \"stroke\",\n      value: function stroke() {\n        var current = this.current;\n\n        if (current.element) {\n          this._setStrokeAttributes(current.element);\n\n          current.element.setAttributeNS(null, \"fill\", \"none\");\n          this.endPath();\n        }\n      }\n    }, {\n      key: \"_setStrokeAttributes\",\n      value: function _setStrokeAttributes(element) {\n        var lineWidthScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        var current = this.current;\n        var dashArray = current.dashArray;\n\n        if (lineWidthScale !== 1 && dashArray.length > 0) {\n          dashArray = dashArray.map(function (value) {\n            return lineWidthScale * value;\n          });\n        }\n\n        element.setAttributeNS(null, \"stroke\", current.strokeColor);\n        element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n        element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n        element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n        element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n        element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n        element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n        element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n      }\n    }, {\n      key: \"eoFill\",\n      value: function eoFill() {\n        if (this.current.element) {\n          this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n        }\n\n        this.fill();\n      }\n    }, {\n      key: \"fillStroke\",\n      value: function fillStroke() {\n        this.stroke();\n        this.fill();\n      }\n    }, {\n      key: \"eoFillStroke\",\n      value: function eoFillStroke() {\n        if (this.current.element) {\n          this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n        }\n\n        this.fillStroke();\n      }\n    }, {\n      key: \"closeStroke\",\n      value: function closeStroke() {\n        this.closePath();\n        this.stroke();\n      }\n    }, {\n      key: \"closeFillStroke\",\n      value: function closeFillStroke() {\n        this.closePath();\n        this.fillStroke();\n      }\n    }, {\n      key: \"closeEOFillStroke\",\n      value: function closeEOFillStroke() {\n        this.closePath();\n        this.eoFillStroke();\n      }\n    }, {\n      key: \"paintSolidColorImageMask\",\n      value: function paintSolidColorImageMask() {\n        var rect = this.svgFactory.createElement(\"svg:rect\");\n        rect.setAttributeNS(null, \"x\", \"0\");\n        rect.setAttributeNS(null, \"y\", \"0\");\n        rect.setAttributeNS(null, \"width\", \"1px\");\n        rect.setAttributeNS(null, \"height\", \"1px\");\n        rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n\n        this._ensureTransformGroup().appendChild(rect);\n      }\n    }, {\n      key: \"paintImageXObject\",\n      value: function paintImageXObject(objId) {\n        var imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n        if (!imgData) {\n          (0, _util.warn)(\"Dependent image with object ID \".concat(objId, \" is not ready yet\"));\n          return;\n        }\n\n        this.paintInlineImageXObject(imgData);\n      }\n    }, {\n      key: \"paintInlineImageXObject\",\n      value: function paintInlineImageXObject(imgData, mask) {\n        var width = imgData.width;\n        var height = imgData.height;\n        var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n        var cliprect = this.svgFactory.createElement(\"svg:rect\");\n        cliprect.setAttributeNS(null, \"x\", \"0\");\n        cliprect.setAttributeNS(null, \"y\", \"0\");\n        cliprect.setAttributeNS(null, \"width\", pf(width));\n        cliprect.setAttributeNS(null, \"height\", pf(height));\n        this.current.element = cliprect;\n        this.clip(\"nonzero\");\n        var imgEl = this.svgFactory.createElement(\"svg:image\");\n        imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n        imgEl.setAttributeNS(null, \"x\", \"0\");\n        imgEl.setAttributeNS(null, \"y\", pf(-height));\n        imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n        imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n        imgEl.setAttributeNS(null, \"transform\", \"scale(\".concat(pf(1 / width), \" \").concat(pf(-1 / height), \")\"));\n\n        if (mask) {\n          mask.appendChild(imgEl);\n        } else {\n          this._ensureTransformGroup().appendChild(imgEl);\n        }\n      }\n    }, {\n      key: \"paintImageMaskXObject\",\n      value: function paintImageMaskXObject(imgData) {\n        var current = this.current;\n        var width = imgData.width;\n        var height = imgData.height;\n        var fillColor = current.fillColor;\n        current.maskId = \"mask\".concat(maskCount++);\n        var mask = this.svgFactory.createElement(\"svg:mask\");\n        mask.setAttributeNS(null, \"id\", current.maskId);\n        var rect = this.svgFactory.createElement(\"svg:rect\");\n        rect.setAttributeNS(null, \"x\", \"0\");\n        rect.setAttributeNS(null, \"y\", \"0\");\n        rect.setAttributeNS(null, \"width\", pf(width));\n        rect.setAttributeNS(null, \"height\", pf(height));\n        rect.setAttributeNS(null, \"fill\", fillColor);\n        rect.setAttributeNS(null, \"mask\", \"url(#\".concat(current.maskId, \")\"));\n        this.defs.appendChild(mask);\n\n        this._ensureTransformGroup().appendChild(rect);\n\n        this.paintInlineImageXObject(imgData, mask);\n      }\n    }, {\n      key: \"paintFormXObjectBegin\",\n      value: function paintFormXObjectBegin(matrix, bbox) {\n        if (Array.isArray(matrix) && matrix.length === 6) {\n          this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n        }\n\n        if (bbox) {\n          var width = bbox[2] - bbox[0];\n          var height = bbox[3] - bbox[1];\n          var cliprect = this.svgFactory.createElement(\"svg:rect\");\n          cliprect.setAttributeNS(null, \"x\", bbox[0]);\n          cliprect.setAttributeNS(null, \"y\", bbox[1]);\n          cliprect.setAttributeNS(null, \"width\", pf(width));\n          cliprect.setAttributeNS(null, \"height\", pf(height));\n          this.current.element = cliprect;\n          this.clip(\"nonzero\");\n          this.endPath();\n        }\n      }\n    }, {\n      key: \"paintFormXObjectEnd\",\n      value: function paintFormXObjectEnd() {}\n    }, {\n      key: \"_initialize\",\n      value: function _initialize(viewport) {\n        var svg = this.svgFactory.create(viewport.width, viewport.height);\n        var definitions = this.svgFactory.createElement(\"svg:defs\");\n        svg.appendChild(definitions);\n        this.defs = definitions;\n        var rootGroup = this.svgFactory.createElement(\"svg:g\");\n        rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n        svg.appendChild(rootGroup);\n        this.svg = rootGroup;\n        return svg;\n      }\n    }, {\n      key: \"_ensureClipGroup\",\n      value: function _ensureClipGroup() {\n        if (!this.current.clipGroup) {\n          var clipGroup = this.svgFactory.createElement(\"svg:g\");\n          clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n          this.svg.appendChild(clipGroup);\n          this.current.clipGroup = clipGroup;\n        }\n\n        return this.current.clipGroup;\n      }\n    }, {\n      key: \"_ensureTransformGroup\",\n      value: function _ensureTransformGroup() {\n        if (!this.tgrp) {\n          this.tgrp = this.svgFactory.createElement(\"svg:g\");\n          this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n\n          if (this.current.activeClipUrl) {\n            this._ensureClipGroup().appendChild(this.tgrp);\n          } else {\n            this.svg.appendChild(this.tgrp);\n          }\n        }\n\n        return this.tgrp;\n      }\n    }]);\n\n    return SVGGraphics;\n  }();\n}\n\n/***/ }),\n/* 153 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNodeStream = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(4);\n\nvar _network_utils = __w_pdfjs_require__(154);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n;\n\nvar fs = __webpack_require__(/*! fs */ \"?6e49\");\n\nvar http = __webpack_require__(/*! http */ \"?0b3b\");\n\nvar https = __webpack_require__(/*! https */ \"?bfb0\");\n\nvar url = __webpack_require__(/*! url */ \"?a42f\");\n\nvar fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n\nfunction parseUrl(sourceUrl) {\n  var parsedUrl = url.parse(sourceUrl);\n\n  if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n    return parsedUrl;\n  }\n\n  if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n    return url.parse(\"file:///\".concat(sourceUrl));\n  }\n\n  if (!parsedUrl.host) {\n    parsedUrl.protocol = \"file:\";\n  }\n\n  return parsedUrl;\n}\n\nvar PDFNodeStream = /*#__PURE__*/function () {\n  function PDFNodeStream(source) {\n    _classCallCheck(this, PDFNodeStream);\n\n    this.source = source;\n    this.url = parseUrl(source.url);\n    this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n    this.isFsUrl = this.url.protocol === \"file:\";\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  _createClass(PDFNodeStream, [{\n    key: \"_progressiveDataLength\",\n    get: function get() {\n      var _this$_fullRequestRea, _this$_fullRequestRea2;\n\n      return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;\n    }\n  }, {\n    key: \"getFullReader\",\n    value: function getFullReader() {\n      (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n      this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n      return this._fullRequestReader;\n    }\n  }, {\n    key: \"getRangeReader\",\n    value: function getRangeReader(start, end) {\n      if (end <= this._progressiveDataLength) {\n        return null;\n      }\n\n      var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n\n      this._rangeRequestReaders.push(rangeReader);\n\n      return rangeReader;\n    }\n  }, {\n    key: \"cancelAllRequests\",\n    value: function cancelAllRequests(reason) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.cancel(reason);\n      }\n\n      var readers = this._rangeRequestReaders.slice(0);\n\n      readers.forEach(function (reader) {\n        reader.cancel(reason);\n      });\n    }\n  }]);\n\n  return PDFNodeStream;\n}();\n\nexports.PDFNodeStream = PDFNodeStream;\n\nvar BaseFullReader = /*#__PURE__*/function () {\n  function BaseFullReader(stream) {\n    _classCallCheck(this, BaseFullReader);\n\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    var source = stream.source;\n    this._contentLength = source.length;\n    this._loaded = 0;\n    this._filename = null;\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._headersCapability = (0, _util.createPromiseCapability)();\n  }\n\n  _createClass(BaseFullReader, [{\n    key: \"headersReady\",\n    get: function get() {\n      return this._headersCapability.promise;\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._filename;\n    }\n  }, {\n    key: \"contentLength\",\n    get: function get() {\n      return this._contentLength;\n    }\n  }, {\n    key: \"isRangeSupported\",\n    get: function get() {\n      return this._isRangeSupported;\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return this._isStreamingSupported;\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var chunk, buffer;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._readCapability.promise;\n\n              case 2:\n                if (!this._done) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  value: undefined,\n                  done: true\n                });\n\n              case 4:\n                if (!this._storedError) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw this._storedError;\n\n              case 6:\n                chunk = this._readableStream.read();\n\n                if (!(chunk === null)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                this._readCapability = (0, _util.createPromiseCapability)();\n                return _context.abrupt(\"return\", this.read());\n\n              case 10:\n                this._loaded += chunk.length;\n\n                if (this.onProgress) {\n                  this.onProgress({\n                    loaded: this._loaded,\n                    total: this._contentLength\n                  });\n                }\n\n                buffer = new Uint8Array(chunk).buffer;\n                return _context.abrupt(\"return\", {\n                  value: buffer,\n                  done: false\n                });\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function read() {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      if (!this._readableStream) {\n        this._error(reason);\n\n        return;\n      }\n\n      this._readableStream.destroy(reason);\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(reason) {\n      this._storedError = reason;\n\n      this._readCapability.resolve();\n    }\n  }, {\n    key: \"_setReadableStream\",\n    value: function _setReadableStream(readableStream) {\n      var _this = this;\n\n      this._readableStream = readableStream;\n      readableStream.on(\"readable\", function () {\n        _this._readCapability.resolve();\n      });\n      readableStream.on(\"end\", function () {\n        readableStream.destroy();\n        _this._done = true;\n\n        _this._readCapability.resolve();\n      });\n      readableStream.on(\"error\", function (reason) {\n        _this._error(reason);\n      });\n\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this._error(new _util.AbortException(\"streaming is disabled\"));\n      }\n\n      if (this._storedError) {\n        this._readableStream.destroy(this._storedError);\n      }\n    }\n  }]);\n\n  return BaseFullReader;\n}();\n\nvar BaseRangeReader = /*#__PURE__*/function () {\n  function BaseRangeReader(stream) {\n    _classCallCheck(this, BaseRangeReader);\n\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    var source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n  }\n\n  _createClass(BaseRangeReader, [{\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return this._isStreamingSupported;\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n        var chunk, buffer;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._readCapability.promise;\n\n              case 2:\n                if (!this._done) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: undefined,\n                  done: true\n                });\n\n              case 4:\n                if (!this._storedError) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                throw this._storedError;\n\n              case 6:\n                chunk = this._readableStream.read();\n\n                if (!(chunk === null)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                this._readCapability = (0, _util.createPromiseCapability)();\n                return _context2.abrupt(\"return\", this.read());\n\n              case 10:\n                this._loaded += chunk.length;\n\n                if (this.onProgress) {\n                  this.onProgress({\n                    loaded: this._loaded\n                  });\n                }\n\n                buffer = new Uint8Array(chunk).buffer;\n                return _context2.abrupt(\"return\", {\n                  value: buffer,\n                  done: false\n                });\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function read() {\n        return _read2.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      if (!this._readableStream) {\n        this._error(reason);\n\n        return;\n      }\n\n      this._readableStream.destroy(reason);\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(reason) {\n      this._storedError = reason;\n\n      this._readCapability.resolve();\n    }\n  }, {\n    key: \"_setReadableStream\",\n    value: function _setReadableStream(readableStream) {\n      var _this2 = this;\n\n      this._readableStream = readableStream;\n      readableStream.on(\"readable\", function () {\n        _this2._readCapability.resolve();\n      });\n      readableStream.on(\"end\", function () {\n        readableStream.destroy();\n        _this2._done = true;\n\n        _this2._readCapability.resolve();\n      });\n      readableStream.on(\"error\", function (reason) {\n        _this2._error(reason);\n      });\n\n      if (this._storedError) {\n        this._readableStream.destroy(this._storedError);\n      }\n    }\n  }]);\n\n  return BaseRangeReader;\n}();\n\nfunction createRequestOptions(parsedUrl, headers) {\n  return {\n    protocol: parsedUrl.protocol,\n    auth: parsedUrl.auth,\n    host: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.path,\n    method: \"GET\",\n    headers: headers\n  };\n}\n\nvar PDFNodeStreamFullReader = /*#__PURE__*/function (_BaseFullReader) {\n  _inherits(PDFNodeStreamFullReader, _BaseFullReader);\n\n  var _super = _createSuper(PDFNodeStreamFullReader);\n\n  function PDFNodeStreamFullReader(stream) {\n    var _this3;\n\n    _classCallCheck(this, PDFNodeStreamFullReader);\n\n    _this3 = _super.call(this, stream);\n\n    var handleResponse = function handleResponse(response) {\n      if (response.statusCode === 404) {\n        var error = new _util.MissingPDFException(\"Missing PDF \\\"\".concat(_this3._url, \"\\\".\"));\n        _this3._storedError = error;\n\n        _this3._headersCapability.reject(error);\n\n        return;\n      }\n\n      _this3._headersCapability.resolve();\n\n      _this3._setReadableStream(response);\n\n      var getResponseHeader = function getResponseHeader(name) {\n        return _this3._readableStream.headers[name.toLowerCase()];\n      };\n\n      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader: getResponseHeader,\n        isHttp: stream.isHttp,\n        rangeChunkSize: _this3._rangeChunkSize,\n        disableRange: _this3._disableRange\n      }),\n          allowRangeRequests = _validateRangeRequest.allowRangeRequests,\n          suggestedLength = _validateRangeRequest.suggestedLength;\n\n      _this3._isRangeSupported = allowRangeRequests;\n      _this3._contentLength = suggestedLength || _this3._contentLength;\n      _this3._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n    };\n\n    _this3._request = null;\n\n    if (_this3._url.protocol === \"http:\") {\n      _this3._request = http.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);\n    } else {\n      _this3._request = https.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);\n    }\n\n    _this3._request.on(\"error\", function (reason) {\n      _this3._storedError = reason;\n\n      _this3._headersCapability.reject(reason);\n    });\n\n    _this3._request.end();\n\n    return _this3;\n  }\n\n  return PDFNodeStreamFullReader;\n}(BaseFullReader);\n\nvar PDFNodeStreamRangeReader = /*#__PURE__*/function (_BaseRangeReader) {\n  _inherits(PDFNodeStreamRangeReader, _BaseRangeReader);\n\n  var _super2 = _createSuper(PDFNodeStreamRangeReader);\n\n  function PDFNodeStreamRangeReader(stream, start, end) {\n    var _this4;\n\n    _classCallCheck(this, PDFNodeStreamRangeReader);\n\n    _this4 = _super2.call(this, stream);\n    _this4._httpHeaders = {};\n\n    for (var property in stream.httpHeaders) {\n      var value = stream.httpHeaders[property];\n\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n\n      _this4._httpHeaders[property] = value;\n    }\n\n    _this4._httpHeaders.Range = \"bytes=\".concat(start, \"-\").concat(end - 1);\n\n    var handleResponse = function handleResponse(response) {\n      if (response.statusCode === 404) {\n        var error = new _util.MissingPDFException(\"Missing PDF \\\"\".concat(_this4._url, \"\\\".\"));\n        _this4._storedError = error;\n        return;\n      }\n\n      _this4._setReadableStream(response);\n    };\n\n    _this4._request = null;\n\n    if (_this4._url.protocol === \"http:\") {\n      _this4._request = http.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);\n    } else {\n      _this4._request = https.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);\n    }\n\n    _this4._request.on(\"error\", function (reason) {\n      _this4._storedError = reason;\n    });\n\n    _this4._request.end();\n\n    return _this4;\n  }\n\n  return PDFNodeStreamRangeReader;\n}(BaseRangeReader);\n\nvar PDFNodeStreamFsFullReader = /*#__PURE__*/function (_BaseFullReader2) {\n  _inherits(PDFNodeStreamFsFullReader, _BaseFullReader2);\n\n  var _super3 = _createSuper(PDFNodeStreamFsFullReader);\n\n  function PDFNodeStreamFsFullReader(stream) {\n    var _this5;\n\n    _classCallCheck(this, PDFNodeStreamFsFullReader);\n\n    _this5 = _super3.call(this, stream);\n    var path = decodeURIComponent(_this5._url.path);\n\n    if (fileUriRegex.test(_this5._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    fs.lstat(path, function (error, stat) {\n      if (error) {\n        if (error.code === \"ENOENT\") {\n          error = new _util.MissingPDFException(\"Missing PDF \\\"\".concat(path, \"\\\".\"));\n        }\n\n        _this5._storedError = error;\n\n        _this5._headersCapability.reject(error);\n\n        return;\n      }\n\n      _this5._contentLength = stat.size;\n\n      _this5._setReadableStream(fs.createReadStream(path));\n\n      _this5._headersCapability.resolve();\n    });\n    return _this5;\n  }\n\n  return PDFNodeStreamFsFullReader;\n}(BaseFullReader);\n\nvar PDFNodeStreamFsRangeReader = /*#__PURE__*/function (_BaseRangeReader2) {\n  _inherits(PDFNodeStreamFsRangeReader, _BaseRangeReader2);\n\n  var _super4 = _createSuper(PDFNodeStreamFsRangeReader);\n\n  function PDFNodeStreamFsRangeReader(stream, start, end) {\n    var _this6;\n\n    _classCallCheck(this, PDFNodeStreamFsRangeReader);\n\n    _this6 = _super4.call(this, stream);\n    var path = decodeURIComponent(_this6._url.path);\n\n    if (fileUriRegex.test(_this6._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    _this6._setReadableStream(fs.createReadStream(path, {\n      start: start,\n      end: end - 1\n    }));\n\n    return _this6;\n  }\n\n  return PDFNodeStreamFsRangeReader;\n}(BaseRangeReader);\n\n/***/ }),\n/* 154 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createResponseStatusError = createResponseStatusError;\nexports.extractFilenameFromHeader = extractFilenameFromHeader;\nexports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\nexports.validateResponseStatus = validateResponseStatus;\n\nvar _util = __w_pdfjs_require__(4);\n\nvar _content_disposition = __w_pdfjs_require__(155);\n\nfunction validateRangeRequestCapabilities(_ref) {\n  var getResponseHeader = _ref.getResponseHeader,\n      isHttp = _ref.isHttp,\n      rangeChunkSize = _ref.rangeChunkSize,\n      disableRange = _ref.disableRange;\n  (0, _util.assert)(rangeChunkSize > 0, \"Range chunk size must be larger than zero\");\n  var returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined\n  };\n  var length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n\n  returnValues.suggestedLength = length;\n\n  if (length <= 2 * rangeChunkSize) {\n    return returnValues;\n  }\n\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n\n  if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n    return returnValues;\n  }\n\n  var contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n\n  if (contentEncoding !== \"identity\") {\n    return returnValues;\n  }\n\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\n\nfunction extractFilenameFromHeader(getResponseHeader) {\n  var contentDisposition = getResponseHeader(\"Content-Disposition\");\n\n  if (contentDisposition) {\n    var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n\n    if (filename.includes(\"%\")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch (ex) {}\n    }\n\n    if (/\\.pdf$/i.test(filename)) {\n      return filename;\n    }\n  }\n\n  return null;\n}\n\nfunction createResponseStatusError(status, url) {\n  if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n    return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n  }\n\n  return new _util.UnexpectedResponseException(\"Unexpected server response (\" + status + ') while retrieving PDF \"' + url + '\".', status);\n}\n\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\n/***/ }),\n/* 155 */\n/***/ (function(__unused_webpack_module, exports) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  var needsEncodingFixup = true;\n  var tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n    var filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  tmp = rfc2231getparam(contentDisposition);\n\n  if (tmp) {\n    var _filename = rfc2047decode(tmp);\n\n    return fixupEncoding(_filename);\n  }\n\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n\n    var _filename2 = rfc2616unquote(tmp);\n\n    _filename2 = rfc2047decode(_filename2);\n    return fixupEncoding(_filename2);\n  }\n\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n  }\n\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n\n      try {\n        var decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        var bytes = Array.from(value, function (ch) {\n          return ch.charCodeAt(0) & 0xff;\n        });\n        value = decoder.decode(new Uint8Array(bytes));\n        needsEncodingFixup = false;\n      } catch (e) {\n        if (/^utf-?8$/i.test(encoding)) {\n          try {\n            value = decodeURIComponent(escape(value));\n            needsEncodingFixup = false;\n          } catch (err) {}\n        }\n      }\n    }\n\n    return value;\n  }\n\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      value = textdecode(\"utf-8\", value);\n\n      if (needsEncodingFixup) {\n        value = textdecode(\"iso-8859-1\", value);\n      }\n    }\n\n    return value;\n  }\n\n  function rfc2231getparam(contentDispositionStr) {\n    var matches = [];\n    var match;\n    var iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      var _match = match,\n          _match2 = _slicedToArray(_match, 4),\n          n = _match2[1],\n          quot = _match2[2],\n          part = _match2[3];\n\n      n = parseInt(n, 10);\n\n      if (n in matches) {\n        if (n === 0) {\n          break;\n        }\n\n        continue;\n      }\n\n      matches[n] = [quot, part];\n    }\n\n    var parts = [];\n\n    for (var _n2 = 0; _n2 < matches.length; ++_n2) {\n      if (!(_n2 in matches)) {\n        break;\n      }\n\n      var _matches$_n = _slicedToArray(matches[_n2], 2),\n          _quot = _matches$_n[0],\n          _part = _matches$_n[1];\n\n      _part = rfc2616unquote(_part);\n\n      if (_quot) {\n        _part = unescape(_part);\n\n        if (_n2 === 0) {\n          _part = rfc5987decode(_part);\n        }\n      }\n\n      parts.push(_part);\n    }\n\n    return parts.join(\"\");\n  }\n\n  function rfc2616unquote(value) {\n    if (value.startsWith('\"')) {\n      var parts = value.slice(1).split('\\\\\"');\n\n      for (var i = 0; i < parts.length; ++i) {\n        var quotindex = parts[i].indexOf('\"');\n\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1;\n        }\n\n        parts[i] = parts[i].replace(/\\\\(.)/g, \"$1\");\n      }\n\n      value = parts.join('\"');\n    }\n\n    return value;\n  }\n\n  function rfc5987decode(extvalue) {\n    var encodingend = extvalue.indexOf(\"'\");\n\n    if (encodingend === -1) {\n      return extvalue;\n    }\n\n    var encoding = extvalue.slice(0, encodingend);\n    var langvalue = extvalue.slice(encodingend + 1);\n    var value = langvalue.replace(/^[^']*'/, \"\");\n    return textdecode(encoding, value);\n  }\n\n  function rfc2047decode(value) {\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n\n    return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n      if (encoding === \"q\" || encoding === \"Q\") {\n        text = text.replace(/_/g, \" \");\n        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n          return String.fromCharCode(parseInt(hex, 16));\n        });\n        return textdecode(charset, text);\n      }\n\n      try {\n        text = atob(text);\n      } catch (e) {}\n\n      return textdecode(charset, text);\n    });\n  }\n\n  return \"\";\n}\n\n/***/ }),\n/* 156 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNetworkStream = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(4);\n\nvar _network_utils = __w_pdfjs_require__(154);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n;\nvar OK_RESPONSE = 200;\nvar PARTIAL_CONTENT_RESPONSE = 206;\n\nfunction getArrayBuffer(xhr) {\n  var data = xhr.response;\n\n  if (typeof data !== \"string\") {\n    return data;\n  }\n\n  var array = (0, _util.stringToBytes)(data);\n  return array.buffer;\n}\n\nvar NetworkManager = /*#__PURE__*/function () {\n  function NetworkManager(url, args) {\n    _classCallCheck(this, NetworkManager);\n\n    this.url = url;\n    args = args || {};\n    this.isHttp = /^https?:/i.test(url);\n    this.httpHeaders = this.isHttp && args.httpHeaders || {};\n    this.withCredentials = args.withCredentials || false;\n\n    this.getXhr = args.getXhr || function NetworkManager_getXhr() {\n      return new XMLHttpRequest();\n    };\n\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n\n  _createClass(NetworkManager, [{\n    key: \"requestRange\",\n    value: function requestRange(begin, end, listeners) {\n      var args = {\n        begin: begin,\n        end: end\n      };\n\n      for (var prop in listeners) {\n        args[prop] = listeners[prop];\n      }\n\n      return this.request(args);\n    }\n  }, {\n    key: \"requestFull\",\n    value: function requestFull(listeners) {\n      return this.request(listeners);\n    }\n  }, {\n    key: \"request\",\n    value: function request(args) {\n      var xhr = this.getXhr();\n      var xhrId = this.currXhrId++;\n      var pendingRequest = this.pendingRequests[xhrId] = {\n        xhr: xhr\n      };\n      xhr.open(\"GET\", this.url);\n      xhr.withCredentials = this.withCredentials;\n\n      for (var property in this.httpHeaders) {\n        var value = this.httpHeaders[property];\n\n        if (typeof value === \"undefined\") {\n          continue;\n        }\n\n        xhr.setRequestHeader(property, value);\n      }\n\n      if (this.isHttp && \"begin\" in args && \"end\" in args) {\n        xhr.setRequestHeader(\"Range\", \"bytes=\".concat(args.begin, \"-\").concat(args.end - 1));\n        pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n      } else {\n        pendingRequest.expectedStatus = OK_RESPONSE;\n      }\n\n      xhr.responseType = \"arraybuffer\";\n\n      if (args.onError) {\n        xhr.onerror = function (evt) {\n          args.onError(xhr.status);\n        };\n      }\n\n      xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n      xhr.onprogress = this.onProgress.bind(this, xhrId);\n      pendingRequest.onHeadersReceived = args.onHeadersReceived;\n      pendingRequest.onDone = args.onDone;\n      pendingRequest.onError = args.onError;\n      pendingRequest.onProgress = args.onProgress;\n      xhr.send(null);\n      return xhrId;\n    }\n  }, {\n    key: \"onProgress\",\n    value: function onProgress(xhrId, evt) {\n      var pendingRequest = this.pendingRequests[xhrId];\n\n      if (!pendingRequest) {\n        return;\n      }\n\n      if (pendingRequest.onProgress) {\n        pendingRequest.onProgress(evt);\n      }\n    }\n  }, {\n    key: \"onStateChange\",\n    value: function onStateChange(xhrId, evt) {\n      var pendingRequest = this.pendingRequests[xhrId];\n\n      if (!pendingRequest) {\n        return;\n      }\n\n      var xhr = pendingRequest.xhr;\n\n      if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n        pendingRequest.onHeadersReceived();\n        delete pendingRequest.onHeadersReceived;\n      }\n\n      if (xhr.readyState !== 4) {\n        return;\n      }\n\n      if (!(xhrId in this.pendingRequests)) {\n        return;\n      }\n\n      delete this.pendingRequests[xhrId];\n\n      if (xhr.status === 0 && this.isHttp) {\n        if (pendingRequest.onError) {\n          pendingRequest.onError(xhr.status);\n        }\n\n        return;\n      }\n\n      var xhrStatus = xhr.status || OK_RESPONSE;\n      var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n\n      if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n        if (pendingRequest.onError) {\n          pendingRequest.onError(xhr.status);\n        }\n\n        return;\n      }\n\n      var chunk = getArrayBuffer(xhr);\n\n      if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n        var rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n        var matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n        pendingRequest.onDone({\n          begin: parseInt(matches[1], 10),\n          chunk: chunk\n        });\n      } else if (chunk) {\n        pendingRequest.onDone({\n          begin: 0,\n          chunk: chunk\n        });\n      } else if (pendingRequest.onError) {\n        pendingRequest.onError(xhr.status);\n      }\n    }\n  }, {\n    key: \"getRequestXhr\",\n    value: function getRequestXhr(xhrId) {\n      return this.pendingRequests[xhrId].xhr;\n    }\n  }, {\n    key: \"isPendingRequest\",\n    value: function isPendingRequest(xhrId) {\n      return xhrId in this.pendingRequests;\n    }\n  }, {\n    key: \"abortRequest\",\n    value: function abortRequest(xhrId) {\n      var xhr = this.pendingRequests[xhrId].xhr;\n      delete this.pendingRequests[xhrId];\n      xhr.abort();\n    }\n  }]);\n\n  return NetworkManager;\n}();\n\nvar PDFNetworkStream = /*#__PURE__*/function () {\n  function PDFNetworkStream(source) {\n    _classCallCheck(this, PDFNetworkStream);\n\n    this._source = source;\n    this._manager = new NetworkManager(source.url, {\n      httpHeaders: source.httpHeaders,\n      withCredentials: source.withCredentials\n    });\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  _createClass(PDFNetworkStream, [{\n    key: \"_onRangeRequestReaderClosed\",\n    value: function _onRangeRequestReaderClosed(reader) {\n      var i = this._rangeRequestReaders.indexOf(reader);\n\n      if (i >= 0) {\n        this._rangeRequestReaders.splice(i, 1);\n      }\n    }\n  }, {\n    key: \"getFullReader\",\n    value: function getFullReader() {\n      (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n      this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n      return this._fullRequestReader;\n    }\n  }, {\n    key: \"getRangeReader\",\n    value: function getRangeReader(begin, end) {\n      var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n      reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n\n      this._rangeRequestReaders.push(reader);\n\n      return reader;\n    }\n  }, {\n    key: \"cancelAllRequests\",\n    value: function cancelAllRequests(reason) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.cancel(reason);\n      }\n\n      var readers = this._rangeRequestReaders.slice(0);\n\n      readers.forEach(function (reader) {\n        reader.cancel(reason);\n      });\n    }\n  }]);\n\n  return PDFNetworkStream;\n}();\n\nexports.PDFNetworkStream = PDFNetworkStream;\n\nvar PDFNetworkStreamFullRequestReader = /*#__PURE__*/function () {\n  function PDFNetworkStreamFullRequestReader(manager, source) {\n    _classCallCheck(this, PDFNetworkStreamFullRequestReader);\n\n    this._manager = manager;\n    var args = {\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = source.url;\n    this._fullRequestId = manager.requestFull(args);\n    this._headersReceivedCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n    this.onProgress = null;\n  }\n\n  _createClass(PDFNetworkStreamFullRequestReader, [{\n    key: \"_onHeadersReceived\",\n    value: function _onHeadersReceived() {\n      var fullRequestXhrId = this._fullRequestId;\n\n      var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n\n      var getResponseHeader = function getResponseHeader(name) {\n        return fullRequestXhr.getResponseHeader(name);\n      };\n\n      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader: getResponseHeader,\n        isHttp: this._manager.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      }),\n          allowRangeRequests = _validateRangeRequest.allowRangeRequests,\n          suggestedLength = _validateRangeRequest.suggestedLength;\n\n      if (allowRangeRequests) {\n        this._isRangeSupported = true;\n      }\n\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n      if (this._isRangeSupported) {\n        this._manager.abortRequest(fullRequestXhrId);\n      }\n\n      this._headersReceivedCapability.resolve();\n    }\n  }, {\n    key: \"_onDone\",\n    value: function _onDone(args) {\n      if (args) {\n        if (this._requests.length > 0) {\n          var requestCapability = this._requests.shift();\n\n          requestCapability.resolve({\n            value: args.chunk,\n            done: false\n          });\n        } else {\n          this._cachedChunks.push(args.chunk);\n        }\n      }\n\n      this._done = true;\n\n      if (this._cachedChunks.length > 0) {\n        return;\n      }\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n    }\n  }, {\n    key: \"_onError\",\n    value: function _onError(status) {\n      var url = this._url;\n      var exception = (0, _network_utils.createResponseStatusError)(status, url);\n      this._storedError = exception;\n\n      this._headersReceivedCapability.reject(exception);\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.reject(exception);\n      });\n\n      this._requests = [];\n      this._cachedChunks = [];\n    }\n  }, {\n    key: \"_onProgress\",\n    value: function _onProgress(data) {\n      if (this.onProgress) {\n        this.onProgress({\n          loaded: data.loaded,\n          total: data.lengthComputable ? data.total : this._contentLength\n        });\n      }\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._filename;\n    }\n  }, {\n    key: \"isRangeSupported\",\n    get: function get() {\n      return this._isRangeSupported;\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return this._isStreamingSupported;\n    }\n  }, {\n    key: \"contentLength\",\n    get: function get() {\n      return this._contentLength;\n    }\n  }, {\n    key: \"headersReady\",\n    get: function get() {\n      return this._headersReceivedCapability.promise;\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var chunk, requestCapability;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._storedError) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw this._storedError;\n\n              case 2:\n                if (!(this._cachedChunks.length > 0)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                chunk = this._cachedChunks.shift();\n                return _context.abrupt(\"return\", {\n                  value: chunk,\n                  done: false\n                });\n\n              case 5:\n                if (!this._done) {\n                  _context.next = 7;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  value: undefined,\n                  done: true\n                });\n\n              case 7:\n                requestCapability = (0, _util.createPromiseCapability)();\n\n                this._requests.push(requestCapability);\n\n                return _context.abrupt(\"return\", requestCapability.promise);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function read() {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      this._done = true;\n\n      this._headersReceivedCapability.reject(reason);\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n\n      if (this._manager.isPendingRequest(this._fullRequestId)) {\n        this._manager.abortRequest(this._fullRequestId);\n      }\n\n      this._fullRequestReader = null;\n    }\n  }]);\n\n  return PDFNetworkStreamFullRequestReader;\n}();\n\nvar PDFNetworkStreamRangeRequestReader = /*#__PURE__*/function () {\n  function PDFNetworkStreamRangeRequestReader(manager, begin, end) {\n    _classCallCheck(this, PDFNetworkStreamRangeRequestReader);\n\n    this._manager = manager;\n    var args = {\n      onDone: this._onDone.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._requestId = manager.requestRange(begin, end, args);\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n\n  _createClass(PDFNetworkStreamRangeRequestReader, [{\n    key: \"_close\",\n    value: function _close() {\n      if (this.onClosed) {\n        this.onClosed(this);\n      }\n    }\n  }, {\n    key: \"_onDone\",\n    value: function _onDone(data) {\n      var chunk = data.chunk;\n\n      if (this._requests.length > 0) {\n        var requestCapability = this._requests.shift();\n\n        requestCapability.resolve({\n          value: chunk,\n          done: false\n        });\n      } else {\n        this._queuedChunk = chunk;\n      }\n\n      this._done = true;\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n\n      this._close();\n    }\n  }, {\n    key: \"_onProgress\",\n    value: function _onProgress(evt) {\n      if (!this.isStreamingSupported && this.onProgress) {\n        this.onProgress({\n          loaded: evt.loaded\n        });\n      }\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n        var chunk, requestCapability;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this._queuedChunk !== null)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                chunk = this._queuedChunk;\n                this._queuedChunk = null;\n                return _context2.abrupt(\"return\", {\n                  value: chunk,\n                  done: false\n                });\n\n              case 4:\n                if (!this._done) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: undefined,\n                  done: true\n                });\n\n              case 6:\n                requestCapability = (0, _util.createPromiseCapability)();\n\n                this._requests.push(requestCapability);\n\n                return _context2.abrupt(\"return\", requestCapability.promise);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function read() {\n        return _read2.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      this._done = true;\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n\n      if (this._manager.isPendingRequest(this._requestId)) {\n        this._manager.abortRequest(this._requestId);\n      }\n\n      this._close();\n    }\n  }]);\n\n  return PDFNetworkStreamRangeRequestReader;\n}();\n\n/***/ }),\n/* 157 */\n/***/ (function(__unused_webpack_module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFFetchStream = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(4);\n\nvar _network_utils = __w_pdfjs_require__(154);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n;\n\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: \"GET\",\n    headers: headers,\n    signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,\n    mode: \"cors\",\n    credentials: withCredentials ? \"include\" : \"same-origin\",\n    redirect: \"follow\"\n  };\n}\n\nfunction createHeaders(httpHeaders) {\n  var headers = new Headers();\n\n  for (var property in httpHeaders) {\n    var value = httpHeaders[property];\n\n    if (typeof value === \"undefined\") {\n      continue;\n    }\n\n    headers.append(property, value);\n  }\n\n  return headers;\n}\n\nvar PDFFetchStream = /*#__PURE__*/function () {\n  function PDFFetchStream(source) {\n    _classCallCheck(this, PDFFetchStream);\n\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  _createClass(PDFFetchStream, [{\n    key: \"_progressiveDataLength\",\n    get: function get() {\n      var _this$_fullRequestRea, _this$_fullRequestRea2;\n\n      return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;\n    }\n  }, {\n    key: \"getFullReader\",\n    value: function getFullReader() {\n      (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n      this._fullRequestReader = new PDFFetchStreamReader(this);\n      return this._fullRequestReader;\n    }\n  }, {\n    key: \"getRangeReader\",\n    value: function getRangeReader(begin, end) {\n      if (end <= this._progressiveDataLength) {\n        return null;\n      }\n\n      var reader = new PDFFetchStreamRangeReader(this, begin, end);\n\n      this._rangeRequestReaders.push(reader);\n\n      return reader;\n    }\n  }, {\n    key: \"cancelAllRequests\",\n    value: function cancelAllRequests(reason) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.cancel(reason);\n      }\n\n      var readers = this._rangeRequestReaders.slice(0);\n\n      readers.forEach(function (reader) {\n        reader.cancel(reason);\n      });\n    }\n  }]);\n\n  return PDFFetchStream;\n}();\n\nexports.PDFFetchStream = PDFFetchStream;\n\nvar PDFFetchStreamReader = /*#__PURE__*/function () {\n  function PDFFetchStreamReader(stream) {\n    var _this = this;\n\n    _classCallCheck(this, PDFFetchStreamReader);\n\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    var source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    if (typeof AbortController !== \"undefined\") {\n      this._abortController = new AbortController();\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._headers = createHeaders(this._stream.httpHeaders);\n    var url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      _this._reader = response.body.getReader();\n\n      _this._headersCapability.resolve();\n\n      var getResponseHeader = function getResponseHeader(name) {\n        return response.headers.get(name);\n      };\n\n      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader: getResponseHeader,\n        isHttp: _this._stream.isHttp,\n        rangeChunkSize: _this._rangeChunkSize,\n        disableRange: _this._disableRange\n      }),\n          allowRangeRequests = _validateRangeRequest.allowRangeRequests,\n          suggestedLength = _validateRangeRequest.suggestedLength;\n\n      _this._isRangeSupported = allowRangeRequests;\n      _this._contentLength = suggestedLength || _this._contentLength;\n      _this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n      if (!_this._isStreamingSupported && _this._isRangeSupported) {\n        _this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n      }\n    })[\"catch\"](this._headersCapability.reject);\n    this.onProgress = null;\n  }\n\n  _createClass(PDFFetchStreamReader, [{\n    key: \"headersReady\",\n    get: function get() {\n      return this._headersCapability.promise;\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._filename;\n    }\n  }, {\n    key: \"contentLength\",\n    get: function get() {\n      return this._contentLength;\n    }\n  }, {\n    key: \"isRangeSupported\",\n    get: function get() {\n      return this._isRangeSupported;\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return this._isStreamingSupported;\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var _yield$this$_reader$r, value, done, buffer;\n\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._headersCapability.promise;\n\n              case 2:\n                _context.next = 4;\n                return this._reader.read();\n\n              case 4:\n                _yield$this$_reader$r = _context.sent;\n                value = _yield$this$_reader$r.value;\n                done = _yield$this$_reader$r.done;\n\n                if (!done) {\n                  _context.next = 9;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  value: value,\n                  done: done\n                });\n\n              case 9:\n                this._loaded += value.byteLength;\n\n                if (this.onProgress) {\n                  this.onProgress({\n                    loaded: this._loaded,\n                    total: this._contentLength\n                  });\n                }\n\n                buffer = new Uint8Array(value).buffer;\n                return _context.abrupt(\"return\", {\n                  value: buffer,\n                  done: false\n                });\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function read() {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      if (this._reader) {\n        this._reader.cancel(reason);\n      }\n\n      if (this._abortController) {\n        this._abortController.abort();\n      }\n    }\n  }]);\n\n  return PDFFetchStreamReader;\n}();\n\nvar PDFFetchStreamRangeReader = /*#__PURE__*/function () {\n  function PDFFetchStreamRangeReader(stream, begin, end) {\n    var _this2 = this;\n\n    _classCallCheck(this, PDFFetchStreamRangeReader);\n\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    var source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._isStreamingSupported = !source.disableStream;\n\n    if (typeof AbortController !== \"undefined\") {\n      this._abortController = new AbortController();\n    }\n\n    this._headers = createHeaders(this._stream.httpHeaders);\n\n    this._headers.append(\"Range\", \"bytes=\".concat(begin, \"-\").concat(end - 1));\n\n    var url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      _this2._readCapability.resolve();\n\n      _this2._reader = response.body.getReader();\n    })[\"catch\"](function (reason) {\n      if ((reason === null || reason === void 0 ? void 0 : reason.name) === \"AbortError\") {\n        return;\n      }\n\n      throw reason;\n    });\n    this.onProgress = null;\n  }\n\n  _createClass(PDFFetchStreamRangeReader, [{\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return this._isStreamingSupported;\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n        var _yield$this$_reader$r2, value, done, buffer;\n\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._readCapability.promise;\n\n              case 2:\n                _context2.next = 4;\n                return this._reader.read();\n\n              case 4:\n                _yield$this$_reader$r2 = _context2.sent;\n                value = _yield$this$_reader$r2.value;\n                done = _yield$this$_reader$r2.done;\n\n                if (!done) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: value,\n                  done: done\n                });\n\n              case 9:\n                this._loaded += value.byteLength;\n\n                if (this.onProgress) {\n                  this.onProgress({\n                    loaded: this._loaded\n                  });\n                }\n\n                buffer = new Uint8Array(value).buffer;\n                return _context2.abrupt(\"return\", {\n                  value: buffer,\n                  done: false\n                });\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function read() {\n        return _read2.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      if (this._reader) {\n        this._reader.cancel(reason);\n      }\n\n      if (this._abortController) {\n        this._abortController.abort();\n      }\n    }\n  }]);\n\n  return PDFFetchStreamRangeReader;\n}();\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(__webpack_module_cache__[moduleId]) {\n/******/ \t\t\treturn __webpack_module_cache__[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);\n/******/ \t\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/node module decorator */\n/******/ \t!function() {\n/******/ \t\t__w_pdfjs_require__.nmd = function(module) {\n/******/ \t\t\tmodule.paths = [];\n/******/ \t\t\tif (!module.children) module.children = [];\n/******/ \t\t\treturn module;\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/************************************************************************/\n/******/ \t// module exports must be returned from runtime so entry inlining is disabled\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \treturn __w_pdfjs_require__(0);\n/******/ })()\n;\n});\n//# sourceMappingURL=pdf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFkc2svcGRmanMtZGlzdC9sZWdhY3kvYnVpbGQvcGRmLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBS3FEO0FBQzNELENBQUM7QUFDRCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBLHdCQUF3QiwyQkFBMkIsMkVBQTJFLGtDQUFrQyx3QkFBd0IsT0FBTyxrQ0FBa0MsbUlBQW1JOztBQUVwVztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFLHlEQUF5RCxRQUFRLG1FQUFtRSx3SEFBd0gsZ0JBQWdCLFdBQVcseUJBQXlCLFNBQVMsd0JBQXdCLDRCQUE0QixjQUFjLFNBQVMsK0JBQStCLHNCQUFzQixXQUFXLFlBQVksZ0tBQWdLLGtEQUFrRCxTQUFTLGtCQUFrQiw0QkFBNEIsb0JBQW9CLHNCQUFzQiw4QkFBOEIsY0FBYyx1QkFBdUIsZUFBZSxZQUFZLG9CQUFvQixNQUFNLGlFQUFpRSxVQUFVOztBQUV0OEIsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLDZFQUE2RSxNQUFNLDBCQUEwQiwwQkFBMEIsZ0JBQWdCLGVBQWUsVUFBVSxpQkFBaUIsa0JBQWtCLE9BQU87O0FBRTFOLGlDQUFpQyxxQkFBcUIsbUNBQW1DLGdEQUFnRCxnQ0FBZ0Msd0JBQXdCLDBFQUEwRSx1QkFBdUIseUVBQXlFLG1CQUFtQjs7QUFFOVgsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUc7O0FBRXpVLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlOztBQUUzSSx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sdUVBQXVFLElBQUksZUFBZSxZQUFZOztBQUVuVCw4QkFBOEIsZ0dBQWdHLG1EQUFtRDs7QUFFakwsa0RBQWtELDBDQUEwQzs7QUFFNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThEOztBQUVsTTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxRkFBcUY7QUFDckY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRyxNQUFLLEdBQUcsQ0FBQyxzREFBc0Q7O0FBRW5FO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE0sbUNBQW1DOztBQUVuQyxnQ0FBZ0M7O0FBRWhDLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUU3UyxrQ0FBa0M7O0FBRWxDLG1DQUFtQzs7QUFFbkMsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFekssd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHOztBQUV6VSxpQ0FBaUMsNEVBQTRFLGlCQUFpQixhQUFhOztBQUUzSSxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7O0FBRXBYLGtEQUFrRCwwRUFBMEUsZUFBZTs7QUFFM0ksd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLHVFQUF1RSxJQUFJLGVBQWUsWUFBWTs7QUFFblQsOEJBQThCLGdHQUFnRyxtREFBbUQ7O0FBRWpMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGFBQWE7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQseUNBQXlDO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUksa0JBQWtCO0FBQ3pCO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxJQUFJLGNBQWMsSUFBSSxpQ0FBaUM7O0FBRXZELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRyxJQUFJLGNBQWM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJLDZCQUE2QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSCxDQUFDO0FBQ0Qsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSxrQkFBa0I7QUFDdkI7QUFDQTtBQUNBLENBQUMsSUFBSSxrQkFBa0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdCQUF3QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdCQUF3QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdCQUF3QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSxrQkFBa0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSxrQkFBa0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUksNkNBQTZDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEVBQUUsS0FBSSxzQkFBc0IsQ0FBQztBQUM3QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSSxnQkFBZ0IscUJBQU07QUFDMUIsVUFBVSxxQkFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLFVBQVUsa0JBQWtCO0FBQzVCLGlCQUFpQixrQkFBa0I7QUFDbkMsWUFBWTtBQUNaLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsR0FBRztBQUNILGdGQUFnRixtQkFBbUI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsVUFBVSxrQkFBa0I7QUFDNUIsaUJBQWlCLGtCQUFrQjtBQUNuQyxZQUFZO0FBQ1osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxrQkFBa0I7QUFDN0IsZUFBZSxrQkFBa0I7QUFDakMsWUFBWTtBQUNaLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxrQkFBa0I7QUFDN0IsaUJBQWlCLGtCQUFrQjtBQUNuQyxXQUFXLGtCQUFrQjtBQUM3QixZQUFZLGtCQUFrQjtBQUM5QixpQkFBaUIsa0JBQWtCO0FBQ25DLFdBQVc7QUFDWCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Ysc0VBQXNFLFNBQVMsb0JBQW9CO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixhQUFhLGtCQUFrQjtBQUMvQixXQUFXLGtCQUFrQjtBQUM3QixpQkFBaUI7QUFDakIsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLGVBQWUsa0JBQWtCO0FBQ2pDLGlCQUFpQixrQkFBa0I7QUFDbkMsWUFBWSxrQkFBa0I7QUFDOUIsU0FBUyxrQkFBa0I7QUFDM0IsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWTtBQUNaLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7QUFDRjtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckMsVUFBVTtBQUNWLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQyxVQUFVO0FBQ1YsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYztBQUNkLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsV0FBVyxrQkFBa0I7QUFDN0IsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCO0FBQ2pCLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdELENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQSx3QkFBd0IsMkJBQTJCLDJFQUEyRSxrQ0FBa0Msd0JBQXdCLE9BQU8sa0NBQWtDLG1JQUFtSTs7QUFFcFc7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RSwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRzs7QUFFelUsaUNBQWlDLDRFQUE0RSxpQkFBaUIsYUFBYTs7QUFFM0ksaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDOztBQUVwWCxrREFBa0QsMEVBQTBFLGVBQWU7O0FBRTNJLHdDQUF3Qyx1QkFBdUIseUZBQXlGOztBQUV4Six1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSx1RUFBdUUsSUFBSSxlQUFlLFlBQVk7O0FBRW5ULDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTCw2RUFBNkUsTUFBTSwwQkFBMEIsMEJBQTBCLGdCQUFnQixlQUFlLFVBQVUsaUJBQWlCLGtCQUFrQixPQUFPOztBQUUxTixpQ0FBaUMscUJBQXFCLG1DQUFtQyxnREFBZ0QsZ0NBQWdDLHdCQUF3QiwwRUFBMEUsdUJBQXVCLHlFQUF5RSxtQkFBbUI7O0FBRTlYLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFdBQVc7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBOztBQUVBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyw4QkFBOEI7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOERBQThEO0FBQzlELGtEQUFrRDtBQUNsRDtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsbUVBQW1FO0FBQ25FLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsd0RBQXdEO0FBQ3hELDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5REFBeUQ7QUFDekQscURBQXFEO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixVQUFVO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixVQUFVO0FBQzlCOztBQUVBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDOztBQUU5RSw2RUFBNkUsTUFBTSwwQkFBMEIsMEJBQTBCLGdCQUFnQixlQUFlLFVBQVUsaUJBQWlCLGtCQUFrQixPQUFPOztBQUUxTixpQ0FBaUMscUJBQXFCLG1DQUFtQyxnREFBZ0QsZ0NBQWdDLHdCQUF3QiwwRUFBMEUsdUJBQXVCLHlFQUF5RSxtQkFBbUI7O0FBRTlYLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE0sd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyw4QkFBOEI7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBELFFBQVE7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUEseURBQXlELFFBQVEsbUVBQW1FLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLDRCQUE0QixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7O0FBRXQ4QixrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1MsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFekssNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThEOztBQUVsTSxrREFBa0QsMENBQTBDOztBQUU1RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsZ0NBQWdDO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxnQ0FBZ0M7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsZ0NBQWdDO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsNkVBQTZFLE1BQU0sMEJBQTBCLDBCQUEwQixnQkFBZ0IsZUFBZSxVQUFVLGlCQUFpQixrQkFBa0IsT0FBTzs7QUFFMU4saUNBQWlDLHFCQUFxQixtQ0FBbUMsZ0RBQWdELGdDQUFnQyx3QkFBd0IsMEVBQTBFLHVCQUF1Qix5RUFBeUUsbUJBQW1COztBQUU5WCx5REFBeUQsUUFBUSxtRUFBbUUsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLCtCQUErQixzQkFBc0IsV0FBVyxZQUFZLGdLQUFnSyxrREFBa0QsU0FBUyxrQkFBa0IsNEJBQTRCLG9CQUFvQixzQkFBc0IsOEJBQThCLGNBQWMsdUJBQXVCLGVBQWUsWUFBWSxvQkFBb0IsTUFBTSxpRUFBaUUsVUFBVTs7QUFFdDhCLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEOztBQUU3Uyx1Q0FBdUMsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sb0JBQW9COztBQUV6SyxrREFBa0QsMENBQTBDOztBQUU1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQ7O0FBRWxNO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FB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LGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEU7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRTtBQUNBLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEU7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEU7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEU7QUFDQSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFLE1BQU0sMERBQTBEO0FBQ2hFO0FBQ0EsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEU7QUFDQSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRTtBQUNBLGdFQUFnRTtBQUNoRTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUUsMEJBQTBCO0FBQzNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLE1BQU0sSUFBSSxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxrQ0FBa0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdJQUFnSTtBQUNoSTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLFdBQVc7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FB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QUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUEsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYzs7QUFFZDs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELGdEQUFnRCxtQ0FBbUM7QUFDdEk7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsNkVBQTZFLE1BQU0sMEJBQTBCLDBCQUEwQixnQkFBZ0IsZUFBZSxVQUFVLGlCQUFpQixrQkFBa0IsT0FBTzs7QUFFMU4saUNBQWlDLHFCQUFxQixtQ0FBbUMsZ0RBQWdELGdDQUFnQyx3QkFBd0IsMEVBQTBFLHVCQUF1Qix5RUFBeUUsbUJBQW1COztBQUU5WCxrREFBa0QsMENBQTBDOztBQUU1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQ7O0FBRWxNOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQXV0b2Rlc2suRXh0ZW5zaW9ucy8uL25vZGVfbW9kdWxlcy9AYWRzay9wZGZqcy1kaXN0L2xlZ2FjeS9idWlsZC9wZGYuanM/ZmM3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNzdGFydCBUaGUgZm9sbG93aW5nIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZVxuICogSmF2YXNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZVxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1vemlsbGEgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAbGljZW5kIFRoZSBhYm92ZSBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFzY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqL1xuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcInBkZmpzLWRpc3QvYnVpbGQvcGRmXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInBkZmpzLWRpc3QvYnVpbGQvcGRmXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInBkZmpzLWRpc3QvYnVpbGQvcGRmXCJdID0gcm9vdC5wZGZqc0xpYiA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9IChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkTGlua0F0dHJpYnV0ZXNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmFkZExpbmtBdHRyaWJ1dGVzO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGaWxlbmFtZUZyb21VcmxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmdldEZpbGVuYW1lRnJvbVVybDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlua1RhcmdldFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuTGlua1RhcmdldDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9hZFNjcmlwdFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMubG9hZFNjcmlwdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGRGF0ZVN0cmluZ1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuUERGRGF0ZVN0cmluZztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb247XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ1aWxkXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXBpLmJ1aWxkO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXREb2N1bWVudFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FwaS5nZXREb2N1bWVudDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9vcGJhY2tQb3J0XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXBpLkxvb3BiYWNrUG9ydDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGRGF0YVJhbmdlVHJhbnNwb3J0XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXBpLlBERkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGV29ya2VyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXBpLlBERldvcmtlcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHV0QmluYXJ5SW1hZ2VEYXRhXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXBpLnB1dEJpbmFyeUltYWdlRGF0YTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FwaS52ZXJzaW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDTWFwQ29tcHJlc3Npb25UeXBlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5DTWFwQ29tcHJlc3Npb25UeXBlO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVPYmplY3RVUkxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF91dGlsLmNyZWF0ZU9iamVjdFVSTDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHlcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVWYWxpZEFic29sdXRlVXJsXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5jcmVhdGVWYWxpZEFic29sdXRlVXJsO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5JbnZhbGlkUERGRXhjZXB0aW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPUFNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF91dGlsLk9QUztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFzc3dvcmRSZXNwb25zZXNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF91dGlsLlBhc3N3b3JkUmVzcG9uc2VzO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJtaXNzaW9uRmxhZ1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3V0aWwuUGVybWlzc2lvbkZsYWc7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbW92ZU51bGxDaGFyYWN0ZXJzXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5yZW1vdmVOdWxsQ2hhcmFjdGVycztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhZG93XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5zaGFkb3c7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVTlNVUFBPUlRFRF9GRUFUVVJFU1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3V0aWwuVU5TVVBQT1JURURfRkVBVFVSRVM7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0aWxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF91dGlsLlV0aWw7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZlcmJvc2l0eUxldmVsXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5WZXJib3NpdHlMZXZlbDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbkxheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYW5ub3RhdGlvbl9sYXllci5Bbm5vdGF0aW9uTGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFwaUNvbXBhdGliaWxpdHlQYXJhbXNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hcGlfY29tcGF0aWJpbGl0eS5hcGlDb21wYXRpYmlsaXR5UGFyYW1zO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHbG9iYWxXb3JrZXJPcHRpb25zXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfd29ya2VyX29wdGlvbnMuR2xvYmFsV29ya2VyT3B0aW9ucztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVuZGVyVGV4dExheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGV4dF9sYXllci5yZW5kZXJUZXh0TGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNWR0dyYXBoaWNzXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc3ZnLlNWR0dyYXBoaWNzO1xuICB9XG59KSk7XG5cbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbnZhciBfYXBpID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzUpO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Fubm90YXRpb25fbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0OSk7XG5cbnZhciBfYXBpX2NvbXBhdGliaWxpdHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzOSk7XG5cbnZhciBfd29ya2VyX29wdGlvbnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0Mik7XG5cbnZhciBfdGV4dF9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUxKTtcblxudmFyIF9zdmcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1Mik7XG5cbnZhciBwZGZqc1ZlcnNpb24gPSAnMi44LjE3Myc7XG52YXIgcGRmanNCdWlsZCA9ICdiYzgzNGQ1MTAnO1xue1xuICB2YXIgX3JlcXVpcmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpLFxuICAgICAgaXNOb2RlSlMgPSBfcmVxdWlyZS5pc05vZGVKUztcblxuICBpZiAoaXNOb2RlSlMpIHtcbiAgICB2YXIgUERGTm9kZVN0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUzKS5QREZOb2RlU3RyZWFtO1xuXG4gICAgKDAsIF9hcGkuc2V0UERGTmV0d29ya1N0cmVhbUZhY3RvcnkpKGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIHJldHVybiBuZXcgUERGTm9kZVN0cmVhbShwYXJhbXMpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBQREZOZXR3b3JrU3RyZWFtID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTYpLlBERk5ldHdvcmtTdHJlYW07XG5cbiAgICB2YXIgUERGRmV0Y2hTdHJlYW07XG5cbiAgICBpZiAoKDAsIF9kaXNwbGF5X3V0aWxzLmlzRmV0Y2hTdXBwb3J0ZWQpKCkpIHtcbiAgICAgIFBERkZldGNoU3RyZWFtID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTcpLlBERkZldGNoU3RyZWFtO1xuICAgIH1cblxuICAgICgwLCBfYXBpLnNldFBERk5ldHdvcmtTdHJlYW1GYWN0b3J5KShmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBpZiAoUERGRmV0Y2hTdHJlYW0gJiYgKDAsIF9kaXNwbGF5X3V0aWxzLmlzVmFsaWRGZXRjaFVybCkocGFyYW1zLnVybCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQREZGZXRjaFN0cmVhbShwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFBERk5ldHdvcmtTdHJlYW0ocGFyYW1zKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuYWRkTGlua0F0dHJpYnV0ZXMgPSBhZGRMaW5rQXR0cmlidXRlcztcbmV4cG9ydHMuZGVwcmVjYXRlZCA9IGRlcHJlY2F0ZWQ7XG5leHBvcnRzLmdldEZpbGVuYW1lRnJvbVVybCA9IGdldEZpbGVuYW1lRnJvbVVybDtcbmV4cG9ydHMuaXNGZXRjaFN1cHBvcnRlZCA9IGlzRmV0Y2hTdXBwb3J0ZWQ7XG5leHBvcnRzLmlzVmFsaWRGZXRjaFVybCA9IGlzVmFsaWRGZXRjaFVybDtcbmV4cG9ydHMubG9hZFNjcmlwdCA9IGxvYWRTY3JpcHQ7XG5leHBvcnRzLlN0YXRUaW1lciA9IGV4cG9ydHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uID0gZXhwb3J0cy5QREZEYXRlU3RyaW5nID0gZXhwb3J0cy5QYWdlVmlld3BvcnQgPSBleHBvcnRzLkxpbmtUYXJnZXQgPSBleHBvcnRzLkRPTVNWR0ZhY3RvcnkgPSBleHBvcnRzLkRPTUNNYXBSZWFkZXJGYWN0b3J5ID0gZXhwb3J0cy5ET01DYW52YXNGYWN0b3J5ID0gZXhwb3J0cy5ERUZBVUxUX0xJTktfUkVMID0gZXhwb3J0cy5CYXNlQ01hcFJlYWRlckZhY3RvcnkgPSBleHBvcnRzLkJhc2VDYW52YXNGYWN0b3J5ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dfcGRmanNfcmVxdWlyZV9fKDIpKTtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBERUZBVUxUX0xJTktfUkVMID0gXCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCI7XG5leHBvcnRzLkRFRkFVTFRfTElOS19SRUwgPSBERUZBVUxUX0xJTktfUkVMO1xudmFyIFNWR19OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcblxudmFyIEJhc2VDYW52YXNGYWN0b3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUNhbnZhc0ZhY3RvcnkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VDYW52YXNGYWN0b3J5KTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlQ2FudmFzRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VDYW52YXNGYWN0b3J5LlwiKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZUNhbnZhc0ZhY3RvcnksIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUod2lkdGgsIGhlaWdodCkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgY3JlYXRlYCBjYWxsZWQuXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldChjYW52YXNBbmRDb250ZXh0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgICAgfVxuXG4gICAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koY2FudmFzQW5kQ29udGV4dCkge1xuICAgICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICAgIH1cblxuICAgICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSAwO1xuICAgICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzID0gbnVsbDtcbiAgICAgIGNhbnZhc0FuZENvbnRleHQuY29udGV4dCA9IG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VDYW52YXNGYWN0b3J5O1xufSgpO1xuXG5leHBvcnRzLkJhc2VDYW52YXNGYWN0b3J5ID0gQmFzZUNhbnZhc0ZhY3Rvcnk7XG5cbnZhciBET01DYW52YXNGYWN0b3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUNhbnZhc0ZhY3RvcnkpIHtcbiAgX2luaGVyaXRzKERPTUNhbnZhc0ZhY3RvcnksIF9CYXNlQ2FudmFzRmFjdG9yeSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihET01DYW52YXNGYWN0b3J5KTtcblxuICBmdW5jdGlvbiBET01DYW52YXNGYWN0b3J5KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZiRvd25lckRvY3VtZW50ID0gX3JlZi5vd25lckRvY3VtZW50LFxuICAgICAgICBvd25lckRvY3VtZW50ID0gX3JlZiRvd25lckRvY3VtZW50ID09PSB2b2lkIDAgPyBnbG9iYWxUaGlzLmRvY3VtZW50IDogX3JlZiRvd25lckRvY3VtZW50O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERPTUNhbnZhc0ZhY3RvcnkpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhET01DYW52YXNGYWN0b3J5LCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2FudmFzIHNpemVcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRE9NQ2FudmFzRmFjdG9yeTtcbn0oQmFzZUNhbnZhc0ZhY3RvcnkpO1xuXG5leHBvcnRzLkRPTUNhbnZhc0ZhY3RvcnkgPSBET01DYW52YXNGYWN0b3J5O1xuXG52YXIgQmFzZUNNYXBSZWFkZXJGYWN0b3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUNNYXBSZWFkZXJGYWN0b3J5KF9yZWYyKSB7XG4gICAgdmFyIF9yZWYyJGJhc2VVcmwgPSBfcmVmMi5iYXNlVXJsLFxuICAgICAgICBiYXNlVXJsID0gX3JlZjIkYmFzZVVybCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYyJGJhc2VVcmwsXG4gICAgICAgIF9yZWYyJGlzQ29tcHJlc3NlZCA9IF9yZWYyLmlzQ29tcHJlc3NlZCxcbiAgICAgICAgaXNDb21wcmVzc2VkID0gX3JlZjIkaXNDb21wcmVzc2VkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJGlzQ29tcHJlc3NlZDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlQ01hcFJlYWRlckZhY3RvcnkpO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VDTWFwUmVhZGVyRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VDTWFwUmVhZGVyRmFjdG9yeS5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICB0aGlzLmlzQ29tcHJlc3NlZCA9IGlzQ29tcHJlc3NlZDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlQ01hcFJlYWRlckZhY3RvcnksIFt7XG4gICAga2V5OiBcImZldGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZmV0Y2ggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKF9yZWYzKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBuYW1lLCB1cmwsIGNvbXByZXNzaW9uVHlwZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBuYW1lID0gX3JlZjMubmFtZTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhc2VVcmwpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgQ01hcCBcImJhc2VVcmxcIiBwYXJhbWV0ZXIgbXVzdCBiZSBzcGVjaWZpZWQsIGVuc3VyZSB0aGF0ICcgKyAndGhlIFwiY01hcFVybFwiIGFuZCBcImNNYXBQYWNrZWRcIiBBUEkgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQuJyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNNYXAgbmFtZSBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuYmFzZVVybCArIG5hbWUgKyAodGhpcy5pc0NvbXByZXNzZWQgPyBcIi5iY21hcFwiIDogXCJcIik7XG4gICAgICAgICAgICAgICAgY29tcHJlc3Npb25UeXBlID0gdGhpcy5pc0NvbXByZXNzZWQgPyBfdXRpbC5DTWFwQ29tcHJlc3Npb25UeXBlLkJJTkFSWSA6IF91dGlsLkNNYXBDb21wcmVzc2lvblR5cGUuTk9ORTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2ZldGNoRGF0YSh1cmwsIGNvbXByZXNzaW9uVHlwZSlbXCJjYXRjaFwiXShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbG9hZCBcIi5jb25jYXQoX3RoaXMyLmlzQ29tcHJlc3NlZCA/IFwiYmluYXJ5IFwiIDogXCJcIiwgXCJDTWFwIGF0OiBcIikuY29uY2F0KHVybCkpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGZldGNoKF94KSB7XG4gICAgICAgIHJldHVybiBfZmV0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZldGNoO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9mZXRjaERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZldGNoRGF0YSh1cmwsIGNvbXByZXNzaW9uVHlwZSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoRGF0YWAgY2FsbGVkLlwiKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZUNNYXBSZWFkZXJGYWN0b3J5O1xufSgpO1xuXG5leHBvcnRzLkJhc2VDTWFwUmVhZGVyRmFjdG9yeSA9IEJhc2VDTWFwUmVhZGVyRmFjdG9yeTtcblxudmFyIERPTUNNYXBSZWFkZXJGYWN0b3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUNNYXBSZWFkZXJGYWN0b3IpIHtcbiAgX2luaGVyaXRzKERPTUNNYXBSZWFkZXJGYWN0b3J5LCBfQmFzZUNNYXBSZWFkZXJGYWN0b3IpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKERPTUNNYXBSZWFkZXJGYWN0b3J5KTtcblxuICBmdW5jdGlvbiBET01DTWFwUmVhZGVyRmFjdG9yeSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRE9NQ01hcFJlYWRlckZhY3RvcnkpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhET01DTWFwUmVhZGVyRmFjdG9yeSwgW3tcbiAgICBrZXk6IFwiX2ZldGNoRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKGlzRmV0Y2hTdXBwb3J0ZWQoKSAmJiBpc1ZhbGlkRmV0Y2hVcmwodXJsLCBkb2N1bWVudC5iYXNlVVJJKSkge1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsKS50aGVuKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfcmVmNCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgY01hcERhdGE7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMzLmlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBVaW50OEFycmF5O1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50MSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgICAgICBjTWFwRGF0YSA9IG5ldyBfY29udGV4dDIudDAoX2NvbnRleHQyLnQxKTtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50MiA9IF91dGlsLnN0cmluZ1RvQnl0ZXM7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50MyA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgICAgICBjTWFwRGF0YSA9ICgwLCBfY29udGV4dDIudDIpKF9jb250ZXh0Mi50Myk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBjTWFwRGF0YTogY01hcERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb25UeXBlOiBjb21wcmVzc2lvblR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZTIpO1xuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcblxuICAgICAgICBpZiAoX3RoaXMzLmlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwIHx8IHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgY01hcERhdGE7XG5cbiAgICAgICAgICAgIGlmIChfdGhpczMuaXNDb21wcmVzc2VkICYmIHJlcXVlc3QucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgY01hcERhdGEgPSBuZXcgVWludDhBcnJheShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIV90aGlzMy5pc0NvbXByZXNzZWQgJiYgcmVxdWVzdC5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICAgICAgY01hcERhdGEgPSAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY01hcERhdGEpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgY01hcERhdGE6IGNNYXBEYXRhLFxuICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uVHlwZTogY29tcHJlc3Npb25UeXBlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0LnNlbmQobnVsbCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRE9NQ01hcFJlYWRlckZhY3Rvcnk7XG59KEJhc2VDTWFwUmVhZGVyRmFjdG9yeSk7XG5cbmV4cG9ydHMuRE9NQ01hcFJlYWRlckZhY3RvcnkgPSBET01DTWFwUmVhZGVyRmFjdG9yeTtcblxudmFyIERPTVNWR0ZhY3RvcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBET01TVkdGYWN0b3J5KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBET01TVkdGYWN0b3J5KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhET01TVkdGYWN0b3J5LCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwLCBcIkludmFsaWQgU1ZHIGRpbWVuc2lvbnNcIik7XG4gICAgICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJzdmc6c3ZnXCIpO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcInZlcnNpb25cIiwgXCIxLjFcIik7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGggKyBcInB4XCIpO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQgKyBcInB4XCIpO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJub25lXCIpO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgXCIwIDAgXCIgKyB3aWR0aCArIFwiIFwiICsgaGVpZ2h0KTtcbiAgICAgIHJldHVybiBzdmc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlKSB7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiwgXCJJbnZhbGlkIFNWRyBlbGVtZW50IHR5cGVcIik7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgdHlwZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERPTVNWR0ZhY3Rvcnk7XG59KCk7XG5cbmV4cG9ydHMuRE9NU1ZHRmFjdG9yeSA9IERPTVNWR0ZhY3Rvcnk7XG5cbnZhciBQYWdlVmlld3BvcnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYWdlVmlld3BvcnQoX3JlZjUpIHtcbiAgICB2YXIgdmlld0JveCA9IF9yZWY1LnZpZXdCb3gsXG4gICAgICAgIHNjYWxlID0gX3JlZjUuc2NhbGUsXG4gICAgICAgIHJvdGF0aW9uID0gX3JlZjUucm90YXRpb24sXG4gICAgICAgIF9yZWY1JG9mZnNldFggPSBfcmVmNS5vZmZzZXRYLFxuICAgICAgICBvZmZzZXRYID0gX3JlZjUkb2Zmc2V0WCA9PT0gdm9pZCAwID8gMCA6IF9yZWY1JG9mZnNldFgsXG4gICAgICAgIF9yZWY1JG9mZnNldFkgPSBfcmVmNS5vZmZzZXRZLFxuICAgICAgICBvZmZzZXRZID0gX3JlZjUkb2Zmc2V0WSA9PT0gdm9pZCAwID8gMCA6IF9yZWY1JG9mZnNldFksXG4gICAgICAgIF9yZWY1JGRvbnRGbGlwID0gX3JlZjUuZG9udEZsaXAsXG4gICAgICAgIGRvbnRGbGlwID0gX3JlZjUkZG9udEZsaXAgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjUkZG9udEZsaXA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFnZVZpZXdwb3J0KTtcblxuICAgIHRoaXMudmlld0JveCA9IHZpZXdCb3g7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgdmFyIGNlbnRlclggPSAodmlld0JveFsyXSArIHZpZXdCb3hbMF0pIC8gMjtcbiAgICB2YXIgY2VudGVyWSA9ICh2aWV3Qm94WzNdICsgdmlld0JveFsxXSkgLyAyO1xuICAgIHZhciByb3RhdGVBLCByb3RhdGVCLCByb3RhdGVDLCByb3RhdGVEO1xuICAgIHJvdGF0aW9uID0gcm90YXRpb24gJSAzNjA7XG4gICAgcm90YXRpb24gPSByb3RhdGlvbiA8IDAgPyByb3RhdGlvbiArIDM2MCA6IHJvdGF0aW9uO1xuXG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJvdGF0ZUEgPSAtMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gMTtcbiAgICAgICAgcm90YXRlQyA9IDE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gLTE7XG4gICAgICAgIHJvdGF0ZUMgPSAtMTtcbiAgICAgICAgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJvdGF0ZUEgPSAxO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAtMTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhZ2VWaWV3cG9ydDogSW52YWxpZCByb3RhdGlvbiwgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDkwIGRlZ3JlZXMuXCIpO1xuICAgIH1cblxuICAgIGlmIChkb250RmxpcCkge1xuICAgICAgcm90YXRlQyA9IC1yb3RhdGVDO1xuICAgICAgcm90YXRlRCA9IC1yb3RhdGVEO1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRDYW52YXNYLCBvZmZzZXRDYW52YXNZO1xuICAgIHZhciB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgaWYgKHJvdGF0ZUEgPT09IDApIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSBNYXRoLmFicyh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9IE1hdGguYWJzKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gTWF0aC5hYnModmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSBNYXRoLmFicyh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zZm9ybSA9IFtyb3RhdGVBICogc2NhbGUsIHJvdGF0ZUIgKiBzY2FsZSwgcm90YXRlQyAqIHNjYWxlLCByb3RhdGVEICogc2NhbGUsIG9mZnNldENhbnZhc1ggLSByb3RhdGVBICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlQyAqIHNjYWxlICogY2VudGVyWSwgb2Zmc2V0Q2FudmFzWSAtIHJvdGF0ZUIgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVEICogc2NhbGUgKiBjZW50ZXJZXTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGFnZVZpZXdwb3J0LCBbe1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHZhciBfcmVmNiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgX3JlZjYkc2NhbGUgPSBfcmVmNi5zY2FsZSxcbiAgICAgICAgICBzY2FsZSA9IF9yZWY2JHNjYWxlID09PSB2b2lkIDAgPyB0aGlzLnNjYWxlIDogX3JlZjYkc2NhbGUsXG4gICAgICAgICAgX3JlZjYkcm90YXRpb24gPSBfcmVmNi5yb3RhdGlvbixcbiAgICAgICAgICByb3RhdGlvbiA9IF9yZWY2JHJvdGF0aW9uID09PSB2b2lkIDAgPyB0aGlzLnJvdGF0aW9uIDogX3JlZjYkcm90YXRpb24sXG4gICAgICAgICAgX3JlZjYkb2Zmc2V0WCA9IF9yZWY2Lm9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WCA9IF9yZWY2JG9mZnNldFggPT09IHZvaWQgMCA/IHRoaXMub2Zmc2V0WCA6IF9yZWY2JG9mZnNldFgsXG4gICAgICAgICAgX3JlZjYkb2Zmc2V0WSA9IF9yZWY2Lm9mZnNldFksXG4gICAgICAgICAgb2Zmc2V0WSA9IF9yZWY2JG9mZnNldFkgPT09IHZvaWQgMCA/IHRoaXMub2Zmc2V0WSA6IF9yZWY2JG9mZnNldFksXG4gICAgICAgICAgX3JlZjYkZG9udEZsaXAgPSBfcmVmNi5kb250RmxpcCxcbiAgICAgICAgICBkb250RmxpcCA9IF9yZWY2JGRvbnRGbGlwID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY2JGRvbnRGbGlwO1xuXG4gICAgICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveC5zbGljZSgpLFxuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgICAgb2Zmc2V0WDogb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICAgICAgZG9udEZsaXA6IGRvbnRGbGlwXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udmVydFRvVmlld3BvcnRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0VG9WaWV3cG9ydFBvaW50KHgsIHkpIHtcbiAgICAgIHJldHVybiBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4LCB5XSwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZShyZWN0KSB7XG4gICAgICB2YXIgdG9wTGVmdCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMF0sIHJlY3RbMV1dLCB0aGlzLnRyYW5zZm9ybSk7XG5cbiAgICAgIHZhciBib3R0b21SaWdodCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMl0sIHJlY3RbM11dLCB0aGlzLnRyYW5zZm9ybSk7XG5cbiAgICAgIHJldHVybiBbdG9wTGVmdFswXSwgdG9wTGVmdFsxXSwgYm90dG9tUmlnaHRbMF0sIGJvdHRvbVJpZ2h0WzFdXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udmVydFRvUGRmUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydFRvUGRmUG9pbnQoeCwgeSkge1xuICAgICAgcmV0dXJuIF91dGlsLlV0aWwuYXBwbHlJbnZlcnNlVHJhbnNmb3JtKFt4LCB5XSwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYWdlVmlld3BvcnQ7XG59KCk7XG5cbmV4cG9ydHMuUGFnZVZpZXdwb3J0ID0gUGFnZVZpZXdwb3J0O1xuXG52YXIgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUV4Y2VwdGlvbikge1xuICBfaW5oZXJpdHMoUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uLCBfQmFzZUV4Y2VwdGlvbik7XG5cbiAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKTtcblxuICBmdW5jdGlvbiBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24obXNnLCB0eXBlKSB7XG4gICAgdmFyIF90aGlzNDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24pO1xuXG4gICAgX3RoaXM0ID0gX3N1cGVyMy5jYWxsKHRoaXMsIG1zZyk7XG4gICAgX3RoaXM0LnR5cGUgPSB0eXBlO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cblxuICByZXR1cm4gUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uO1xufShfdXRpbC5CYXNlRXhjZXB0aW9uKTtcblxuZXhwb3J0cy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gPSBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb247XG52YXIgTGlua1RhcmdldCA9IHtcbiAgTk9ORTogMCxcbiAgU0VMRjogMSxcbiAgQkxBTks6IDIsXG4gIFBBUkVOVDogMyxcbiAgVE9QOiA0XG59O1xuZXhwb3J0cy5MaW5rVGFyZ2V0ID0gTGlua1RhcmdldDtcblxuZnVuY3Rpb24gYWRkTGlua0F0dHJpYnV0ZXMobGluaykge1xuICB2YXIgX3JlZjcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgdXJsID0gX3JlZjcudXJsLFxuICAgICAgdGFyZ2V0ID0gX3JlZjcudGFyZ2V0LFxuICAgICAgcmVsID0gX3JlZjcucmVsLFxuICAgICAgX3JlZjckZW5hYmxlZCA9IF9yZWY3LmVuYWJsZWQsXG4gICAgICBlbmFibGVkID0gX3JlZjckZW5hYmxlZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWY3JGVuYWJsZWQ7XG5cbiAgKDAsIF91dGlsLmFzc2VydCkodXJsICYmIHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIsICdhZGRMaW5rQXR0cmlidXRlczogQSB2YWxpZCBcInVybFwiIHBhcmFtZXRlciBtdXN0IHByb3ZpZGVkLicpO1xuICB2YXIgdXJsTnVsbFJlbW92ZWQgPSAoMCwgX3V0aWwucmVtb3ZlTnVsbENoYXJhY3RlcnMpKHVybCk7XG5cbiAgaWYgKGVuYWJsZWQpIHtcbiAgICBsaW5rLmhyZWYgPSBsaW5rLnRpdGxlID0gdXJsTnVsbFJlbW92ZWQ7XG4gIH0gZWxzZSB7XG4gICAgbGluay5ocmVmID0gXCJcIjtcbiAgICBsaW5rLnRpdGxlID0gXCJEaXNhYmxlZDogXCIuY29uY2F0KHVybE51bGxSZW1vdmVkKTtcblxuICAgIGxpbmsub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHRhcmdldFN0ciA9IFwiXCI7XG5cbiAgc3dpdGNoICh0YXJnZXQpIHtcbiAgICBjYXNlIExpbmtUYXJnZXQuTk9ORTpcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBMaW5rVGFyZ2V0LlNFTEY6XG4gICAgICB0YXJnZXRTdHIgPSBcIl9zZWxmXCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTGlua1RhcmdldC5CTEFOSzpcbiAgICAgIHRhcmdldFN0ciA9IFwiX2JsYW5rXCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTGlua1RhcmdldC5QQVJFTlQ6XG4gICAgICB0YXJnZXRTdHIgPSBcIl9wYXJlbnRcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBMaW5rVGFyZ2V0LlRPUDpcbiAgICAgIHRhcmdldFN0ciA9IFwiX3RvcFwiO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBsaW5rLnRhcmdldCA9IHRhcmdldFN0cjtcbiAgbGluay5yZWwgPSB0eXBlb2YgcmVsID09PSBcInN0cmluZ1wiID8gcmVsIDogREVGQVVMVF9MSU5LX1JFTDtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tVXJsKHVybCkge1xuICB2YXIgYW5jaG9yID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuICB2YXIgcXVlcnkgPSB1cmwuaW5kZXhPZihcIj9cIik7XG4gIHZhciBlbmQgPSBNYXRoLm1pbihhbmNob3IgPiAwID8gYW5jaG9yIDogdXJsLmxlbmd0aCwgcXVlcnkgPiAwID8gcXVlcnkgOiB1cmwubGVuZ3RoKTtcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcodXJsLmxhc3RJbmRleE9mKFwiL1wiLCBlbmQpICsgMSwgZW5kKTtcbn1cblxudmFyIFN0YXRUaW1lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0YXRUaW1lcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhdFRpbWVyKTtcblxuICAgIHRoaXMuc3RhcnRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50aW1lcyA9IFtdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0YXRUaW1lciwgW3tcbiAgICBrZXk6IFwidGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lIGluIHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJUaW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcgZm9yIFwiLmNvbmNhdChuYW1lKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhcnRlZFtuYW1lXSA9IERhdGUubm93KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpbWVFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZUVuZChuYW1lKSB7XG4gICAgICBpZiAoIShuYW1lIGluIHRoaXMuc3RhcnRlZCkpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVGltZXIgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgZm9yIFwiLmNvbmNhdChuYW1lKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGltZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXG4gICAgICAgIGVuZDogRGF0ZS5ub3coKVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgdGhpcy5zdGFydGVkW25hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBvdXRCdWYgPSBbXTtcbiAgICAgIHZhciBsb25nZXN0ID0gMDtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMudGltZXMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB0aW1lID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aW1lLm5hbWU7XG5cbiAgICAgICAgICBpZiAobmFtZS5sZW5ndGggPiBsb25nZXN0KSB7XG4gICAgICAgICAgICBsb25nZXN0ID0gbmFtZS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy50aW1lcyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfdGltZSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSBfdGltZS5lbmQgLSBfdGltZS5zdGFydDtcbiAgICAgICAgICBvdXRCdWYucHVzaChcIlwiLmNvbmNhdChfdGltZS5uYW1lLnBhZEVuZChsb25nZXN0KSwgXCIgXCIpLmNvbmNhdChkdXJhdGlvbiwgXCJtc1xcblwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0QnVmLmpvaW4oXCJcIik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0YXRUaW1lcjtcbn0oKTtcblxuZXhwb3J0cy5TdGF0VGltZXIgPSBTdGF0VGltZXI7XG5cbmZ1bmN0aW9uIGlzRmV0Y2hTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiB0eXBlb2YgZmV0Y2ggIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFJlc3BvbnNlICE9PSBcInVuZGVmaW5lZFwiICYmIFwiYm9keVwiIGluIFJlc3BvbnNlLnByb3RvdHlwZSAmJiB0eXBlb2YgUmVhZGFibGVTdHJlYW0gIT09IFwidW5kZWZpbmVkXCI7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRGZXRjaFVybCh1cmwsIGJhc2VVcmwpIHtcbiAgdHJ5IHtcbiAgICB2YXIgX3JlZjggPSBiYXNlVXJsID8gbmV3IFVSTCh1cmwsIGJhc2VVcmwpIDogbmV3IFVSTCh1cmwpLFxuICAgICAgICBwcm90b2NvbCA9IF9yZWY4LnByb3RvY29sO1xuXG4gICAgcmV0dXJuIHByb3RvY29sID09PSBcImh0dHA6XCIgfHwgcHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvYWRTY3JpcHQoc3JjKSB7XG4gIHZhciByZW1vdmVTY3JpcHRFbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBzY3JpcHQuc3JjID0gc3JjO1xuXG4gICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmIChyZW1vdmVTY3JpcHRFbGVtZW50KSB7XG4gICAgICAgIHNjcmlwdC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShldnQpO1xuICAgIH07XG5cbiAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDYW5ub3QgbG9hZCBzY3JpcHQgYXQ6IFwiLmNvbmNhdChzY3JpcHQuc3JjKSkpO1xuICAgIH07XG5cbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkKGRldGFpbHMpIHtcbiAgY29uc29sZS5sb2coXCJEZXByZWNhdGVkIEFQSSB1c2FnZTogXCIgKyBkZXRhaWxzKTtcbn1cblxudmFyIHBkZkRhdGVTdHJpbmdSZWdleDtcblxudmFyIFBERkRhdGVTdHJpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZEYXRlU3RyaW5nKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZEYXRlU3RyaW5nKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZEYXRlU3RyaW5nLCBudWxsLCBbe1xuICAgIGtleTogXCJ0b0RhdGVPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9EYXRlT2JqZWN0KGlucHV0KSB7XG4gICAgICBpZiAoIWlucHV0IHx8ICEoMCwgX3V0aWwuaXNTdHJpbmcpKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwZGZEYXRlU3RyaW5nUmVnZXgpIHtcbiAgICAgICAgcGRmRGF0ZVN0cmluZ1JlZ2V4ID0gbmV3IFJlZ0V4cChcIl5EOlwiICsgXCIoXFxcXGR7NH0pXCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihbWnwrfC1dKT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaGVzID0gcGRmRGF0ZVN0cmluZ1JlZ2V4LmV4ZWMoaW5wdXQpO1xuXG4gICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApO1xuICAgICAgdmFyIG1vbnRoID0gcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApO1xuICAgICAgbW9udGggPSBtb250aCA+PSAxICYmIG1vbnRoIDw9IDEyID8gbW9udGggLSAxIDogMDtcbiAgICAgIHZhciBkYXkgPSBwYXJzZUludChtYXRjaGVzWzNdLCAxMCk7XG4gICAgICBkYXkgPSBkYXkgPj0gMSAmJiBkYXkgPD0gMzEgPyBkYXkgOiAxO1xuICAgICAgdmFyIGhvdXIgPSBwYXJzZUludChtYXRjaGVzWzRdLCAxMCk7XG4gICAgICBob3VyID0gaG91ciA+PSAwICYmIGhvdXIgPD0gMjMgPyBob3VyIDogMDtcbiAgICAgIHZhciBtaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICBtaW51dGUgPSBtaW51dGUgPj0gMCAmJiBtaW51dGUgPD0gNTkgPyBtaW51dGUgOiAwO1xuICAgICAgdmFyIHNlY29uZCA9IHBhcnNlSW50KG1hdGNoZXNbNl0sIDEwKTtcbiAgICAgIHNlY29uZCA9IHNlY29uZCA+PSAwICYmIHNlY29uZCA8PSA1OSA/IHNlY29uZCA6IDA7XG4gICAgICB2YXIgdW5pdmVyc2FsVGltZVJlbGF0aW9uID0gbWF0Y2hlc1s3XSB8fCBcIlpcIjtcbiAgICAgIHZhciBvZmZzZXRIb3VyID0gcGFyc2VJbnQobWF0Y2hlc1s4XSwgMTApO1xuICAgICAgb2Zmc2V0SG91ciA9IG9mZnNldEhvdXIgPj0gMCAmJiBvZmZzZXRIb3VyIDw9IDIzID8gb2Zmc2V0SG91ciA6IDA7XG4gICAgICB2YXIgb2Zmc2V0TWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s5XSwgMTApIHx8IDA7XG4gICAgICBvZmZzZXRNaW51dGUgPSBvZmZzZXRNaW51dGUgPj0gMCAmJiBvZmZzZXRNaW51dGUgPD0gNTkgPyBvZmZzZXRNaW51dGUgOiAwO1xuXG4gICAgICBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIi1cIikge1xuICAgICAgICBob3VyICs9IG9mZnNldEhvdXI7XG4gICAgICAgIG1pbnV0ZSArPSBvZmZzZXRNaW51dGU7XG4gICAgICB9IGVsc2UgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCIrXCIpIHtcbiAgICAgICAgaG91ciAtPSBvZmZzZXRIb3VyO1xuICAgICAgICBtaW51dGUgLT0gb2Zmc2V0TWludXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGRGF0ZVN0cmluZztcbn0oKTtcblxuZXhwb3J0cy5QREZEYXRlU3RyaW5nID0gUERGRGF0ZVN0cmluZztcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIG1vZHVsZSBkZWNvcmF0b3IgKi8gbW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXy5ubWQobW9kdWxlKTtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBydW50aW1lID0gZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkO1xuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG5cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgYXJnOiBlcnJcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG5cbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3IgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICBfX2F3YWl0OiBhcmdcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgX3R5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcblxuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcblxuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICB0cnlMb2M6IGxvY3NbMF1cbiAgICB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbe1xuICAgICAgdHJ5TG9jOiBcInJvb3RcIlxuICAgIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBrZXlzLnJldmVyc2UoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcblxuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG5cbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZG9uZVJlc3VsdFxuICAgIH07XG4gIH1cblxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcblxuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiYgKHR5cGUgPT09IFwiYnJlYWtcIiB8fCB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8IHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBleHBvcnRzO1xufSgoIGZhbHNlID8gMCA6IF90eXBlb2YobW9kdWxlKSkgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9KTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuYXJyYXlCeXRlTGVuZ3RoID0gYXJyYXlCeXRlTGVuZ3RoO1xuZXhwb3J0cy5hcnJheXNUb0J5dGVzID0gYXJyYXlzVG9CeXRlcztcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gYnl0ZXNUb1N0cmluZztcbmV4cG9ydHMuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkgPSBjcmVhdGVQcm9taXNlQ2FwYWJpbGl0eTtcbmV4cG9ydHMuY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCA9IGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmw7XG5leHBvcnRzLmVuY29kZVRvWG1sU3RyaW5nID0gZW5jb2RlVG9YbWxTdHJpbmc7XG5leHBvcnRzLmVzY2FwZVN0cmluZyA9IGVzY2FwZVN0cmluZztcbmV4cG9ydHMuZ2V0TW9kaWZpY2F0aW9uRGF0ZSA9IGdldE1vZGlmaWNhdGlvbkRhdGU7XG5leHBvcnRzLmdldFZlcmJvc2l0eUxldmVsID0gZ2V0VmVyYm9zaXR5TGV2ZWw7XG5leHBvcnRzLmluZm8gPSBpbmZvO1xuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbmV4cG9ydHMuaXNBcnJheUVxdWFsID0gaXNBcnJheUVxdWFsO1xuZXhwb3J0cy5pc0FzY2lpID0gaXNBc2NpaTtcbmV4cG9ydHMuaXNCb29sID0gaXNCb29sO1xuZXhwb3J0cy5pc051bSA9IGlzTnVtO1xuZXhwb3J0cy5pc1NhbWVPcmlnaW4gPSBpc1NhbWVPcmlnaW47XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLm9iamVjdEZyb21FbnRyaWVzID0gb2JqZWN0RnJvbUVudHJpZXM7XG5leHBvcnRzLm9iamVjdFNpemUgPSBvYmplY3RTaXplO1xuZXhwb3J0cy5yZW1vdmVOdWxsQ2hhcmFjdGVycyA9IHJlbW92ZU51bGxDaGFyYWN0ZXJzO1xuZXhwb3J0cy5zZXRWZXJib3NpdHlMZXZlbCA9IHNldFZlcmJvc2l0eUxldmVsO1xuZXhwb3J0cy5zaGFkb3cgPSBzaGFkb3c7XG5leHBvcnRzLnN0cmluZzMyID0gc3RyaW5nMzI7XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuZXhwb3J0cy5zdHJpbmdUb1BERlN0cmluZyA9IHN0cmluZ1RvUERGU3RyaW5nO1xuZXhwb3J0cy5zdHJpbmdUb1VURjE2QkVTdHJpbmcgPSBzdHJpbmdUb1VURjE2QkVTdHJpbmc7XG5leHBvcnRzLnN0cmluZ1RvVVRGOFN0cmluZyA9IHN0cmluZ1RvVVRGOFN0cmluZztcbmV4cG9ydHMudW5yZWFjaGFibGUgPSB1bnJlYWNoYWJsZTtcbmV4cG9ydHMudXRmOFN0cmluZ1RvU3RyaW5nID0gdXRmOFN0cmluZ1RvU3RyaW5nO1xuZXhwb3J0cy53YXJuID0gd2FybjtcbmV4cG9ydHMuVmVyYm9zaXR5TGV2ZWwgPSBleHBvcnRzLlV0aWwgPSBleHBvcnRzLlVOU1VQUE9SVEVEX0ZFQVRVUkVTID0gZXhwb3J0cy5Vbmtub3duRXJyb3JFeGNlcHRpb24gPSBleHBvcnRzLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiA9IGV4cG9ydHMuVGV4dFJlbmRlcmluZ01vZGUgPSBleHBvcnRzLlN0cmVhbVR5cGUgPSBleHBvcnRzLlBlcm1pc3Npb25GbGFnID0gZXhwb3J0cy5QYXNzd29yZFJlc3BvbnNlcyA9IGV4cG9ydHMuUGFzc3dvcmRFeGNlcHRpb24gPSBleHBvcnRzLlBhZ2VBY3Rpb25FdmVudFR5cGUgPSBleHBvcnRzLk9QUyA9IGV4cG9ydHMuTWlzc2luZ1BERkV4Y2VwdGlvbiA9IGV4cG9ydHMuSXNMaXR0bGVFbmRpYW5DYWNoZWQgPSBleHBvcnRzLklzRXZhbFN1cHBvcnRlZENhY2hlZCA9IGV4cG9ydHMuSW52YWxpZFBERkV4Y2VwdGlvbiA9IGV4cG9ydHMuSW1hZ2VLaW5kID0gZXhwb3J0cy5JREVOVElUWV9NQVRSSVggPSBleHBvcnRzLkZvcm1hdEVycm9yID0gZXhwb3J0cy5Gb250VHlwZSA9IGV4cG9ydHMuRk9OVF9JREVOVElUWV9NQVRSSVggPSBleHBvcnRzLkRvY3VtZW50QWN0aW9uRXZlbnRUeXBlID0gZXhwb3J0cy5jcmVhdGVPYmplY3RVUkwgPSBleHBvcnRzLkNNYXBDb21wcmVzc2lvblR5cGUgPSBleHBvcnRzLkJhc2VFeGNlcHRpb24gPSBleHBvcnRzLkFubm90YXRpb25UeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uU3RhdGVNb2RlbFR5cGUgPSBleHBvcnRzLkFubm90YXRpb25SZXZpZXdTdGF0ZSA9IGV4cG9ydHMuQW5ub3RhdGlvblJlcGx5VHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvbk1hcmtlZFN0YXRlID0gZXhwb3J0cy5Bbm5vdGF0aW9uRmxhZyA9IGV4cG9ydHMuQW5ub3RhdGlvbkZpZWxkRmxhZyA9IGV4cG9ydHMuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IGV4cG9ydHMuQWJvcnRFeGNlcHRpb24gPSB2b2lkIDA7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oNSk7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgSURFTlRJVFlfTUFUUklYID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuZXhwb3J0cy5JREVOVElUWV9NQVRSSVggPSBJREVOVElUWV9NQVRSSVg7XG52YXIgRk9OVF9JREVOVElUWV9NQVRSSVggPSBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXTtcbmV4cG9ydHMuRk9OVF9JREVOVElUWV9NQVRSSVggPSBGT05UX0lERU5USVRZX01BVFJJWDtcbnZhciBQZXJtaXNzaW9uRmxhZyA9IHtcbiAgUFJJTlQ6IDB4MDQsXG4gIE1PRElGWV9DT05URU5UUzogMHgwOCxcbiAgQ09QWTogMHgxMCxcbiAgTU9ESUZZX0FOTk9UQVRJT05TOiAweDIwLFxuICBGSUxMX0lOVEVSQUNUSVZFX0ZPUk1TOiAweDEwMCxcbiAgQ09QWV9GT1JfQUNDRVNTSUJJTElUWTogMHgyMDAsXG4gIEFTU0VNQkxFOiAweDQwMCxcbiAgUFJJTlRfSElHSF9RVUFMSVRZOiAweDgwMFxufTtcbmV4cG9ydHMuUGVybWlzc2lvbkZsYWcgPSBQZXJtaXNzaW9uRmxhZztcbnZhciBUZXh0UmVuZGVyaW5nTW9kZSA9IHtcbiAgRklMTDogMCxcbiAgU1RST0tFOiAxLFxuICBGSUxMX1NUUk9LRTogMixcbiAgSU5WSVNJQkxFOiAzLFxuICBGSUxMX0FERF9UT19QQVRIOiA0LFxuICBTVFJPS0VfQUREX1RPX1BBVEg6IDUsXG4gIEZJTExfU1RST0tFX0FERF9UT19QQVRIOiA2LFxuICBBRERfVE9fUEFUSDogNyxcbiAgRklMTF9TVFJPS0VfTUFTSzogMyxcbiAgQUREX1RPX1BBVEhfRkxBRzogNFxufTtcbmV4cG9ydHMuVGV4dFJlbmRlcmluZ01vZGUgPSBUZXh0UmVuZGVyaW5nTW9kZTtcbnZhciBJbWFnZUtpbmQgPSB7XG4gIEdSQVlTQ0FMRV8xQlBQOiAxLFxuICBSR0JfMjRCUFA6IDIsXG4gIFJHQkFfMzJCUFA6IDNcbn07XG5leHBvcnRzLkltYWdlS2luZCA9IEltYWdlS2luZDtcbnZhciBBbm5vdGF0aW9uVHlwZSA9IHtcbiAgVEVYVDogMSxcbiAgTElOSzogMixcbiAgRlJFRVRFWFQ6IDMsXG4gIExJTkU6IDQsXG4gIFNRVUFSRTogNSxcbiAgQ0lSQ0xFOiA2LFxuICBQT0xZR09OOiA3LFxuICBQT0xZTElORTogOCxcbiAgSElHSExJR0hUOiA5LFxuICBVTkRFUkxJTkU6IDEwLFxuICBTUVVJR0dMWTogMTEsXG4gIFNUUklLRU9VVDogMTIsXG4gIFNUQU1QOiAxMyxcbiAgQ0FSRVQ6IDE0LFxuICBJTks6IDE1LFxuICBQT1BVUDogMTYsXG4gIEZJTEVBVFRBQ0hNRU5UOiAxNyxcbiAgU09VTkQ6IDE4LFxuICBNT1ZJRTogMTksXG4gIFdJREdFVDogMjAsXG4gIFNDUkVFTjogMjEsXG4gIFBSSU5URVJNQVJLOiAyMixcbiAgVFJBUE5FVDogMjMsXG4gIFdBVEVSTUFSSzogMjQsXG4gIFRIUkVFRDogMjUsXG4gIFJFREFDVDogMjZcbn07XG5leHBvcnRzLkFubm90YXRpb25UeXBlID0gQW5ub3RhdGlvblR5cGU7XG52YXIgQW5ub3RhdGlvblN0YXRlTW9kZWxUeXBlID0ge1xuICBNQVJLRUQ6IFwiTWFya2VkXCIsXG4gIFJFVklFVzogXCJSZXZpZXdcIlxufTtcbmV4cG9ydHMuQW5ub3RhdGlvblN0YXRlTW9kZWxUeXBlID0gQW5ub3RhdGlvblN0YXRlTW9kZWxUeXBlO1xudmFyIEFubm90YXRpb25NYXJrZWRTdGF0ZSA9IHtcbiAgTUFSS0VEOiBcIk1hcmtlZFwiLFxuICBVTk1BUktFRDogXCJVbm1hcmtlZFwiXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uTWFya2VkU3RhdGUgPSBBbm5vdGF0aW9uTWFya2VkU3RhdGU7XG52YXIgQW5ub3RhdGlvblJldmlld1N0YXRlID0ge1xuICBBQ0NFUFRFRDogXCJBY2NlcHRlZFwiLFxuICBSRUpFQ1RFRDogXCJSZWplY3RlZFwiLFxuICBDQU5DRUxMRUQ6IFwiQ2FuY2VsbGVkXCIsXG4gIENPTVBMRVRFRDogXCJDb21wbGV0ZWRcIixcbiAgTk9ORTogXCJOb25lXCJcbn07XG5leHBvcnRzLkFubm90YXRpb25SZXZpZXdTdGF0ZSA9IEFubm90YXRpb25SZXZpZXdTdGF0ZTtcbnZhciBBbm5vdGF0aW9uUmVwbHlUeXBlID0ge1xuICBHUk9VUDogXCJHcm91cFwiLFxuICBSRVBMWTogXCJSXCJcbn07XG5leHBvcnRzLkFubm90YXRpb25SZXBseVR5cGUgPSBBbm5vdGF0aW9uUmVwbHlUeXBlO1xudmFyIEFubm90YXRpb25GbGFnID0ge1xuICBJTlZJU0lCTEU6IDB4MDEsXG4gIEhJRERFTjogMHgwMixcbiAgUFJJTlQ6IDB4MDQsXG4gIE5PWk9PTTogMHgwOCxcbiAgTk9ST1RBVEU6IDB4MTAsXG4gIE5PVklFVzogMHgyMCxcbiAgUkVBRE9OTFk6IDB4NDAsXG4gIExPQ0tFRDogMHg4MCxcbiAgVE9HR0xFTk9WSUVXOiAweDEwMCxcbiAgTE9DS0VEQ09OVEVOVFM6IDB4MjAwXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uRmxhZyA9IEFubm90YXRpb25GbGFnO1xudmFyIEFubm90YXRpb25GaWVsZEZsYWcgPSB7XG4gIFJFQURPTkxZOiAweDAwMDAwMDEsXG4gIFJFUVVJUkVEOiAweDAwMDAwMDIsXG4gIE5PRVhQT1JUOiAweDAwMDAwMDQsXG4gIE1VTFRJTElORTogMHgwMDAxMDAwLFxuICBQQVNTV09SRDogMHgwMDAyMDAwLFxuICBOT1RPR0dMRVRPT0ZGOiAweDAwMDQwMDAsXG4gIFJBRElPOiAweDAwMDgwMDAsXG4gIFBVU0hCVVRUT046IDB4MDAxMDAwMCxcbiAgQ09NQk86IDB4MDAyMDAwMCxcbiAgRURJVDogMHgwMDQwMDAwLFxuICBTT1JUOiAweDAwODAwMDAsXG4gIEZJTEVTRUxFQ1Q6IDB4MDEwMDAwMCxcbiAgTVVMVElTRUxFQ1Q6IDB4MDIwMDAwMCxcbiAgRE9OT1RTUEVMTENIRUNLOiAweDA0MDAwMDAsXG4gIERPTk9UU0NST0xMOiAweDA4MDAwMDAsXG4gIENPTUI6IDB4MTAwMDAwMCxcbiAgUklDSFRFWFQ6IDB4MjAwMDAwMCxcbiAgUkFESU9TSU5VTklTT046IDB4MjAwMDAwMCxcbiAgQ09NTUlUT05TRUxDSEFOR0U6IDB4NDAwMDAwMFxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkZpZWxkRmxhZyA9IEFubm90YXRpb25GaWVsZEZsYWc7XG52YXIgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IHtcbiAgU09MSUQ6IDEsXG4gIERBU0hFRDogMixcbiAgQkVWRUxFRDogMyxcbiAgSU5TRVQ6IDQsXG4gIFVOREVSTElORTogNVxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGU7XG52YXIgQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgRTogXCJNb3VzZSBFbnRlclwiLFxuICBYOiBcIk1vdXNlIEV4aXRcIixcbiAgRDogXCJNb3VzZSBEb3duXCIsXG4gIFU6IFwiTW91c2UgVXBcIixcbiAgRm86IFwiRm9jdXNcIixcbiAgQmw6IFwiQmx1clwiLFxuICBQTzogXCJQYWdlT3BlblwiLFxuICBQQzogXCJQYWdlQ2xvc2VcIixcbiAgUFY6IFwiUGFnZVZpc2libGVcIixcbiAgUEk6IFwiUGFnZUludmlzaWJsZVwiLFxuICBLOiBcIktleXN0cm9rZVwiLFxuICBGOiBcIkZvcm1hdFwiLFxuICBWOiBcIlZhbGlkYXRlXCIsXG4gIEM6IFwiQ2FsY3VsYXRlXCJcbn07XG5leHBvcnRzLkFubm90YXRpb25BY3Rpb25FdmVudFR5cGUgPSBBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlO1xudmFyIERvY3VtZW50QWN0aW9uRXZlbnRUeXBlID0ge1xuICBXQzogXCJXaWxsQ2xvc2VcIixcbiAgV1M6IFwiV2lsbFNhdmVcIixcbiAgRFM6IFwiRGlkU2F2ZVwiLFxuICBXUDogXCJXaWxsUHJpbnRcIixcbiAgRFA6IFwiRGlkUHJpbnRcIlxufTtcbmV4cG9ydHMuRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUgPSBEb2N1bWVudEFjdGlvbkV2ZW50VHlwZTtcbnZhciBQYWdlQWN0aW9uRXZlbnRUeXBlID0ge1xuICBPOiBcIlBhZ2VPcGVuXCIsXG4gIEM6IFwiUGFnZUNsb3NlXCJcbn07XG5leHBvcnRzLlBhZ2VBY3Rpb25FdmVudFR5cGUgPSBQYWdlQWN0aW9uRXZlbnRUeXBlO1xudmFyIFN0cmVhbVR5cGUgPSB7XG4gIFVOS05PV046IFwiVU5LTk9XTlwiLFxuICBGTEFURTogXCJGTEFURVwiLFxuICBMWlc6IFwiTFpXXCIsXG4gIERDVDogXCJEQ1RcIixcbiAgSlBYOiBcIkpQWFwiLFxuICBKQklHOiBcIkpCSUdcIixcbiAgQTg1OiBcIkE4NVwiLFxuICBBSFg6IFwiQUhYXCIsXG4gIENDRjogXCJDQ0ZcIixcbiAgUkxYOiBcIlJMWFwiXG59O1xuZXhwb3J0cy5TdHJlYW1UeXBlID0gU3RyZWFtVHlwZTtcbnZhciBGb250VHlwZSA9IHtcbiAgVU5LTk9XTjogXCJVTktOT1dOXCIsXG4gIFRZUEUxOiBcIlRZUEUxXCIsXG4gIFRZUEUxQzogXCJUWVBFMUNcIixcbiAgQ0lERk9OVFRZUEUwOiBcIkNJREZPTlRUWVBFMFwiLFxuICBDSURGT05UVFlQRTBDOiBcIkNJREZPTlRUWVBFMENcIixcbiAgVFJVRVRZUEU6IFwiVFJVRVRZUEVcIixcbiAgQ0lERk9OVFRZUEUyOiBcIkNJREZPTlRUWVBFMlwiLFxuICBUWVBFMzogXCJUWVBFM1wiLFxuICBPUEVOVFlQRTogXCJPUEVOVFlQRVwiLFxuICBUWVBFMDogXCJUWVBFMFwiLFxuICBNTVRZUEUxOiBcIk1NVFlQRTFcIlxufTtcbmV4cG9ydHMuRm9udFR5cGUgPSBGb250VHlwZTtcbnZhciBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5leHBvcnRzLlZlcmJvc2l0eUxldmVsID0gVmVyYm9zaXR5TGV2ZWw7XG52YXIgQ01hcENvbXByZXNzaW9uVHlwZSA9IHtcbiAgTk9ORTogMCxcbiAgQklOQVJZOiAxLFxuICBTVFJFQU06IDJcbn07XG5leHBvcnRzLkNNYXBDb21wcmVzc2lvblR5cGUgPSBDTWFwQ29tcHJlc3Npb25UeXBlO1xudmFyIE9QUyA9IHtcbiAgZGVwZW5kZW5jeTogMSxcbiAgc2V0TGluZVdpZHRoOiAyLFxuICBzZXRMaW5lQ2FwOiAzLFxuICBzZXRMaW5lSm9pbjogNCxcbiAgc2V0TWl0ZXJMaW1pdDogNSxcbiAgc2V0RGFzaDogNixcbiAgc2V0UmVuZGVyaW5nSW50ZW50OiA3LFxuICBzZXRGbGF0bmVzczogOCxcbiAgc2V0R1N0YXRlOiA5LFxuICBzYXZlOiAxMCxcbiAgcmVzdG9yZTogMTEsXG4gIHRyYW5zZm9ybTogMTIsXG4gIG1vdmVUbzogMTMsXG4gIGxpbmVUbzogMTQsXG4gIGN1cnZlVG86IDE1LFxuICBjdXJ2ZVRvMjogMTYsXG4gIGN1cnZlVG8zOiAxNyxcbiAgY2xvc2VQYXRoOiAxOCxcbiAgcmVjdGFuZ2xlOiAxOSxcbiAgc3Ryb2tlOiAyMCxcbiAgY2xvc2VTdHJva2U6IDIxLFxuICBmaWxsOiAyMixcbiAgZW9GaWxsOiAyMyxcbiAgZmlsbFN0cm9rZTogMjQsXG4gIGVvRmlsbFN0cm9rZTogMjUsXG4gIGNsb3NlRmlsbFN0cm9rZTogMjYsXG4gIGNsb3NlRU9GaWxsU3Ryb2tlOiAyNyxcbiAgZW5kUGF0aDogMjgsXG4gIGNsaXA6IDI5LFxuICBlb0NsaXA6IDMwLFxuICBiZWdpblRleHQ6IDMxLFxuICBlbmRUZXh0OiAzMixcbiAgc2V0Q2hhclNwYWNpbmc6IDMzLFxuICBzZXRXb3JkU3BhY2luZzogMzQsXG4gIHNldEhTY2FsZTogMzUsXG4gIHNldExlYWRpbmc6IDM2LFxuICBzZXRGb250OiAzNyxcbiAgc2V0VGV4dFJlbmRlcmluZ01vZGU6IDM4LFxuICBzZXRUZXh0UmlzZTogMzksXG4gIG1vdmVUZXh0OiA0MCxcbiAgc2V0TGVhZGluZ01vdmVUZXh0OiA0MSxcbiAgc2V0VGV4dE1hdHJpeDogNDIsXG4gIG5leHRMaW5lOiA0MyxcbiAgc2hvd1RleHQ6IDQ0LFxuICBzaG93U3BhY2VkVGV4dDogNDUsXG4gIG5leHRMaW5lU2hvd1RleHQ6IDQ2LFxuICBuZXh0TGluZVNldFNwYWNpbmdTaG93VGV4dDogNDcsXG4gIHNldENoYXJXaWR0aDogNDgsXG4gIHNldENoYXJXaWR0aEFuZEJvdW5kczogNDksXG4gIHNldFN0cm9rZUNvbG9yU3BhY2U6IDUwLFxuICBzZXRGaWxsQ29sb3JTcGFjZTogNTEsXG4gIHNldFN0cm9rZUNvbG9yOiA1MixcbiAgc2V0U3Ryb2tlQ29sb3JOOiA1MyxcbiAgc2V0RmlsbENvbG9yOiA1NCxcbiAgc2V0RmlsbENvbG9yTjogNTUsXG4gIHNldFN0cm9rZUdyYXk6IDU2LFxuICBzZXRGaWxsR3JheTogNTcsXG4gIHNldFN0cm9rZVJHQkNvbG9yOiA1OCxcbiAgc2V0RmlsbFJHQkNvbG9yOiA1OSxcbiAgc2V0U3Ryb2tlQ01ZS0NvbG9yOiA2MCxcbiAgc2V0RmlsbENNWUtDb2xvcjogNjEsXG4gIHNoYWRpbmdGaWxsOiA2MixcbiAgYmVnaW5JbmxpbmVJbWFnZTogNjMsXG4gIGJlZ2luSW1hZ2VEYXRhOiA2NCxcbiAgZW5kSW5saW5lSW1hZ2U6IDY1LFxuICBwYWludFhPYmplY3Q6IDY2LFxuICBtYXJrUG9pbnQ6IDY3LFxuICBtYXJrUG9pbnRQcm9wczogNjgsXG4gIGJlZ2luTWFya2VkQ29udGVudDogNjksXG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzOiA3MCxcbiAgZW5kTWFya2VkQ29udGVudDogNzEsXG4gIGJlZ2luQ29tcGF0OiA3MixcbiAgZW5kQ29tcGF0OiA3MyxcbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luOiA3NCxcbiAgcGFpbnRGb3JtWE9iamVjdEVuZDogNzUsXG4gIGJlZ2luR3JvdXA6IDc2LFxuICBlbmRHcm91cDogNzcsXG4gIGJlZ2luQW5ub3RhdGlvbnM6IDc4LFxuICBlbmRBbm5vdGF0aW9uczogNzksXG4gIGJlZ2luQW5ub3RhdGlvbjogODAsXG4gIGVuZEFubm90YXRpb246IDgxLFxuICBwYWludEpwZWdYT2JqZWN0OiA4MixcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTFcbn07XG5leHBvcnRzLk9QUyA9IE9QUztcbnZhciBVTlNVUFBPUlRFRF9GRUFUVVJFUyA9IHtcbiAgdW5rbm93bjogXCJ1bmtub3duXCIsXG4gIGZvcm1zOiBcImZvcm1zXCIsXG4gIGphdmFTY3JpcHQ6IFwiamF2YVNjcmlwdFwiLFxuICBzbWFzazogXCJzbWFza1wiLFxuICBzaGFkaW5nUGF0dGVybjogXCJzaGFkaW5nUGF0dGVyblwiLFxuICBmb250OiBcImZvbnRcIixcbiAgZXJyb3JUaWxpbmdQYXR0ZXJuOiBcImVycm9yVGlsaW5nUGF0dGVyblwiLFxuICBlcnJvckV4dEdTdGF0ZTogXCJlcnJvckV4dEdTdGF0ZVwiLFxuICBlcnJvclhPYmplY3Q6IFwiZXJyb3JYT2JqZWN0XCIsXG4gIGVycm9yRm9udExvYWRUeXBlMzogXCJlcnJvckZvbnRMb2FkVHlwZTNcIixcbiAgZXJyb3JGb250U3RhdGU6IFwiZXJyb3JGb250U3RhdGVcIixcbiAgZXJyb3JGb250TWlzc2luZzogXCJlcnJvckZvbnRNaXNzaW5nXCIsXG4gIGVycm9yRm9udFRyYW5zbGF0ZTogXCJlcnJvckZvbnRUcmFuc2xhdGVcIixcbiAgZXJyb3JDb2xvclNwYWNlOiBcImVycm9yQ29sb3JTcGFjZVwiLFxuICBlcnJvck9wZXJhdG9yTGlzdDogXCJlcnJvck9wZXJhdG9yTGlzdFwiLFxuICBlcnJvckZvbnRUb1VuaWNvZGU6IFwiZXJyb3JGb250VG9Vbmljb2RlXCIsXG4gIGVycm9yRm9udExvYWROYXRpdmU6IFwiZXJyb3JGb250TG9hZE5hdGl2ZVwiLFxuICBlcnJvckZvbnRHZXRQYXRoOiBcImVycm9yRm9udEdldFBhdGhcIixcbiAgZXJyb3JNYXJrZWRDb250ZW50OiBcImVycm9yTWFya2VkQ29udGVudFwiXG59O1xuZXhwb3J0cy5VTlNVUFBPUlRFRF9GRUFUVVJFUyA9IFVOU1VQUE9SVEVEX0ZFQVRVUkVTO1xudmFyIFBhc3N3b3JkUmVzcG9uc2VzID0ge1xuICBORUVEX1BBU1NXT1JEOiAxLFxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcbn07XG5leHBvcnRzLlBhc3N3b3JkUmVzcG9uc2VzID0gUGFzc3dvcmRSZXNwb25zZXM7XG52YXIgdmVyYm9zaXR5ID0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1M7XG5cbmZ1bmN0aW9uIHNldFZlcmJvc2l0eUxldmVsKGxldmVsKSB7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGxldmVsKSkge1xuICAgIHZlcmJvc2l0eSA9IGxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFZlcmJvc2l0eUxldmVsKCkge1xuICByZXR1cm4gdmVyYm9zaXR5O1xufVxuXG5mdW5jdGlvbiBpbmZvKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLklORk9TKSB7XG4gICAgY29uc29sZS5sb2coXCJJbmZvOiBcIi5jb25jYXQobXNnKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUykge1xuICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogXCIuY29uY2F0KG1zZykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVucmVhY2hhYmxlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZykge1xuICBpZiAoIWNvbmQpIHtcbiAgICB1bnJlYWNoYWJsZShtc2cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yaWdpbihiYXNlVXJsLCBvdGhlclVybCkge1xuICB2YXIgYmFzZTtcblxuICB0cnkge1xuICAgIGJhc2UgPSBuZXcgVVJMKGJhc2VVcmwpO1xuXG4gICAgaWYgKCFiYXNlLm9yaWdpbiB8fCBiYXNlLm9yaWdpbiA9PT0gXCJudWxsXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgb3RoZXIgPSBuZXcgVVJMKG90aGVyVXJsLCBiYXNlKTtcbiAgcmV0dXJuIGJhc2Uub3JpZ2luID09PSBvdGhlci5vcmlnaW47XG59XG5cbmZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2wodXJsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcbiAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICBjYXNlIFwiaHR0cHM6XCI6XG4gICAgY2FzZSBcImZ0cDpcIjpcbiAgICBjYXNlIFwibWFpbHRvOlwiOlxuICAgIGNhc2UgXCJ0ZWw6XCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCh1cmwsIGJhc2VVcmwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIGFic29sdXRlVXJsID0gYmFzZVVybCA/IG5ldyBVUkwodXJsLCBiYXNlVXJsKSA6IG5ldyBVUkwodXJsKTtcblxuICAgIGlmIChfaXNWYWxpZFByb3RvY29sKGFic29sdXRlVXJsKSkge1xuICAgICAgcmV0dXJuIGFic29sdXRlVXJsO1xuICAgIH1cbiAgfSBjYXRjaCAoZXgpIHt9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHNoYWRvdyhvYmosIHByb3AsIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBCYXNlRXhjZXB0aW9uID0gZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIEJhc2VFeGNlcHRpb24obWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlRXhjZXB0aW9uKSB7XG4gICAgICB1bnJlYWNoYWJsZShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VFeGNlcHRpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgQmFzZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgQmFzZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IEJhc2VFeGNlcHRpb247XG4gIHJldHVybiBCYXNlRXhjZXB0aW9uO1xufSgpO1xuXG5leHBvcnRzLkJhc2VFeGNlcHRpb24gPSBCYXNlRXhjZXB0aW9uO1xuXG52YXIgUGFzc3dvcmRFeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlRXhjZXB0aW9uKSB7XG4gIF9pbmhlcml0cyhQYXNzd29yZEV4Y2VwdGlvbiwgX0Jhc2VFeGNlcHRpb24pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUGFzc3dvcmRFeGNlcHRpb24pO1xuXG4gIGZ1bmN0aW9uIFBhc3N3b3JkRXhjZXB0aW9uKG1zZywgY29kZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXNzd29yZEV4Y2VwdGlvbik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1zZyk7XG4gICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFBhc3N3b3JkRXhjZXB0aW9uO1xufShCYXNlRXhjZXB0aW9uKTtcblxuZXhwb3J0cy5QYXNzd29yZEV4Y2VwdGlvbiA9IFBhc3N3b3JkRXhjZXB0aW9uO1xuXG52YXIgVW5rbm93bkVycm9yRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUV4Y2VwdGlvbjIpIHtcbiAgX2luaGVyaXRzKFVua25vd25FcnJvckV4Y2VwdGlvbiwgX0Jhc2VFeGNlcHRpb24yKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihVbmtub3duRXJyb3JFeGNlcHRpb24pO1xuXG4gIGZ1bmN0aW9uIFVua25vd25FcnJvckV4Y2VwdGlvbihtc2csIGRldGFpbHMpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFVua25vd25FcnJvckV4Y2VwdGlvbik7XG5cbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwodGhpcywgbXNnKTtcbiAgICBfdGhpczIuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIHJldHVybiBVbmtub3duRXJyb3JFeGNlcHRpb247XG59KEJhc2VFeGNlcHRpb24pO1xuXG5leHBvcnRzLlVua25vd25FcnJvckV4Y2VwdGlvbiA9IFVua25vd25FcnJvckV4Y2VwdGlvbjtcblxudmFyIEludmFsaWRQREZFeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlRXhjZXB0aW9uMykge1xuICBfaW5oZXJpdHMoSW52YWxpZFBERkV4Y2VwdGlvbiwgX0Jhc2VFeGNlcHRpb24zKTtcblxuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihJbnZhbGlkUERGRXhjZXB0aW9uKTtcblxuICBmdW5jdGlvbiBJbnZhbGlkUERGRXhjZXB0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnZhbGlkUERGRXhjZXB0aW9uKTtcblxuICAgIHJldHVybiBfc3VwZXIzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gSW52YWxpZFBERkV4Y2VwdGlvbjtcbn0oQmFzZUV4Y2VwdGlvbik7XG5cbmV4cG9ydHMuSW52YWxpZFBERkV4Y2VwdGlvbiA9IEludmFsaWRQREZFeGNlcHRpb247XG5cbnZhciBNaXNzaW5nUERGRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUV4Y2VwdGlvbjQpIHtcbiAgX2luaGVyaXRzKE1pc3NpbmdQREZFeGNlcHRpb24sIF9CYXNlRXhjZXB0aW9uNCk7XG5cbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoTWlzc2luZ1BERkV4Y2VwdGlvbik7XG5cbiAgZnVuY3Rpb24gTWlzc2luZ1BERkV4Y2VwdGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWlzc2luZ1BERkV4Y2VwdGlvbik7XG5cbiAgICByZXR1cm4gX3N1cGVyNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIE1pc3NpbmdQREZFeGNlcHRpb247XG59KEJhc2VFeGNlcHRpb24pO1xuXG5leHBvcnRzLk1pc3NpbmdQREZFeGNlcHRpb24gPSBNaXNzaW5nUERGRXhjZXB0aW9uO1xuXG52YXIgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUV4Y2VwdGlvbjUpIHtcbiAgX2luaGVyaXRzKFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiwgX0Jhc2VFeGNlcHRpb241KTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24pO1xuXG4gIGZ1bmN0aW9uIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihtc2csIHN0YXR1cykge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKTtcblxuICAgIF90aGlzMyA9IF9zdXBlcjUuY2FsbCh0aGlzLCBtc2cpO1xuICAgIF90aGlzMy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHJldHVybiBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb247XG59KEJhc2VFeGNlcHRpb24pO1xuXG5leHBvcnRzLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiA9IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcblxudmFyIEZvcm1hdEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUV4Y2VwdGlvbjYpIHtcbiAgX2luaGVyaXRzKEZvcm1hdEVycm9yLCBfQmFzZUV4Y2VwdGlvbjYpO1xuXG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKEZvcm1hdEVycm9yKTtcblxuICBmdW5jdGlvbiBGb3JtYXRFcnJvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9ybWF0RXJyb3IpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBGb3JtYXRFcnJvcjtcbn0oQmFzZUV4Y2VwdGlvbik7XG5cbmV4cG9ydHMuRm9ybWF0RXJyb3IgPSBGb3JtYXRFcnJvcjtcblxudmFyIEFib3J0RXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUV4Y2VwdGlvbjcpIHtcbiAgX2luaGVyaXRzKEFib3J0RXhjZXB0aW9uLCBfQmFzZUV4Y2VwdGlvbjcpO1xuXG4gIHZhciBfc3VwZXI3ID0gX2NyZWF0ZVN1cGVyKEFib3J0RXhjZXB0aW9uKTtcblxuICBmdW5jdGlvbiBBYm9ydEV4Y2VwdGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRFeGNlcHRpb24pO1xuXG4gICAgcmV0dXJuIF9zdXBlcjcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBBYm9ydEV4Y2VwdGlvbjtcbn0oQmFzZUV4Y2VwdGlvbik7XG5cbmV4cG9ydHMuQWJvcnRFeGNlcHRpb24gPSBBYm9ydEV4Y2VwdGlvbjtcbnZhciBOdWxsQ2hhcmFjdGVyc1JlZ0V4cCA9IC9cXHgwMC9nO1xuXG5mdW5jdGlvbiByZW1vdmVOdWxsQ2hhcmFjdGVycyhzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICB3YXJuKFwiVGhlIGFyZ3VtZW50IGZvciByZW1vdmVOdWxsQ2hhcmFjdGVycyBtdXN0IGJlIGEgc3RyaW5nLlwiKTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKE51bGxDaGFyYWN0ZXJzUmVnRXhwLCBcIlwiKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICBhc3NlcnQoYnl0ZXMgIT09IG51bGwgJiYgX3R5cGVvZihieXRlcykgPT09IFwib2JqZWN0XCIgJiYgYnl0ZXMubGVuZ3RoICE9PSB1bmRlZmluZWQsIFwiSW52YWxpZCBhcmd1bWVudCBmb3IgYnl0ZXNUb1N0cmluZ1wiKTtcbiAgdmFyIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgdmFyIE1BWF9BUkdVTUVOVF9DT1VOVCA9IDgxOTI7XG5cbiAgaWYgKGxlbmd0aCA8IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbiAgfVxuXG4gIHZhciBzdHJCdWYgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICB2YXIgY2h1bmtFbmQgPSBNYXRoLm1pbihpICsgTUFYX0FSR1VNRU5UX0NPVU5ULCBsZW5ndGgpO1xuICAgIHZhciBjaHVuayA9IGJ5dGVzLnN1YmFycmF5KGksIGNodW5rRW5kKTtcbiAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNodW5rKSk7XG4gIH1cblxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIGFzc2VydCh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiLCBcIkludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXNcIik7XG4gIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBieXRlc1tpXSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZjtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuZnVuY3Rpb24gYXJyYXlCeXRlTGVuZ3RoKGFycikge1xuICBpZiAoYXJyLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyci5sZW5ndGg7XG4gIH1cblxuICBhc3NlcnQoYXJyLmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZCwgXCJhcnJheUJ5dGVMZW5ndGggLSBpbnZhbGlkIGFyZ3VtZW50LlwiKTtcbiAgcmV0dXJuIGFyci5ieXRlTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBhcnJheXNUb0J5dGVzKGFycikge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoID09PSAxICYmIGFyclswXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gYXJyWzBdO1xuICB9XG5cbiAgdmFyIHJlc3VsdExlbmd0aCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdExlbmd0aCArPSBhcnJheUJ5dGVMZW5ndGgoYXJyW2ldKTtcbiAgfVxuXG4gIHZhciBwb3MgPSAwO1xuICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHJlc3VsdExlbmd0aCk7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbmd0aDsgX2krKykge1xuICAgIHZhciBpdGVtID0gYXJyW19pXTtcblxuICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGl0ZW0gPSBzdHJpbmdUb0J5dGVzKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbSA9IG5ldyBVaW50OEFycmF5KGl0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpdGVtTGVuZ3RoID0gaXRlbS5ieXRlTGVuZ3RoO1xuICAgIGRhdGEuc2V0KGl0ZW0sIHBvcyk7XG4gICAgcG9zICs9IGl0ZW1MZW5ndGg7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nMzIodmFsdWUpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUgPj4gMjQgJiAweGZmLCB2YWx1ZSA+PiAxNiAmIDB4ZmYsIHZhbHVlID4+IDggJiAweGZmLCB2YWx1ZSAmIDB4ZmYpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RTaXplKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIG9iamVjdEZyb21FbnRyaWVzKGl0ZXJhYmxlKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIE9iamVjdC5mcm9tRW50cmllcyhpdGVyYWJsZSkpO1xufVxuXG5mdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcbiAgdmFyIGJ1ZmZlcjggPSBuZXcgVWludDhBcnJheSg0KTtcbiAgYnVmZmVyOFswXSA9IDE7XG4gIHZhciB2aWV3MzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyOC5idWZmZXIsIDAsIDEpO1xuICByZXR1cm4gdmlldzMyWzBdID09PSAxO1xufVxuXG52YXIgSXNMaXR0bGVFbmRpYW5DYWNoZWQgPSB7XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwidmFsdWVcIiwgaXNMaXR0bGVFbmRpYW4oKSk7XG4gIH1cblxufTtcbmV4cG9ydHMuSXNMaXR0bGVFbmRpYW5DYWNoZWQgPSBJc0xpdHRsZUVuZGlhbkNhY2hlZDtcblxuZnVuY3Rpb24gaXNFdmFsU3VwcG9ydGVkKCkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihcIlwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG52YXIgSXNFdmFsU3VwcG9ydGVkQ2FjaGVkID0ge1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInZhbHVlXCIsIGlzRXZhbFN1cHBvcnRlZCgpKTtcbiAgfVxuXG59O1xuZXhwb3J0cy5Jc0V2YWxTdXBwb3J0ZWRDYWNoZWQgPSBJc0V2YWxTdXBwb3J0ZWRDYWNoZWQ7XG5cbnZhciBoZXhOdW1iZXJzID0gX3RvQ29uc3VtYWJsZUFycmF5KEFycmF5KDI1Nikua2V5cygpKS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbn0pO1xuXG52YXIgVXRpbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFV0aWwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFV0aWwpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFV0aWwsIG51bGwsIFt7XG4gICAga2V5OiBcIm1ha2VIZXhDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlSGV4Q29sb3IociwgZywgYikge1xuICAgICAgcmV0dXJuIFwiI1wiLmNvbmNhdChoZXhOdW1iZXJzW3JdKS5jb25jYXQoaGV4TnVtYmVyc1tnXSkuY29uY2F0KGhleE51bWJlcnNbYl0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtKG0xLCBtMikge1xuICAgICAgcmV0dXJuIFttMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXSwgbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV0sIG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdLCBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXSwgbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XSwgbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5VHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKHAsIG0pIHtcbiAgICAgIHZhciB4dCA9IHBbMF0gKiBtWzBdICsgcFsxXSAqIG1bMl0gKyBtWzRdO1xuICAgICAgdmFyIHl0ID0gcFswXSAqIG1bMV0gKyBwWzFdICogbVszXSArIG1bNV07XG4gICAgICByZXR1cm4gW3h0LCB5dF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5SW52ZXJzZVRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgbSkge1xuICAgICAgdmFyIGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgICAgdmFyIHh0ID0gKHBbMF0gKiBtWzNdIC0gcFsxXSAqIG1bMl0gKyBtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQ7XG4gICAgICB2YXIgeXQgPSAoLXBbMF0gKiBtWzFdICsgcFsxXSAqIG1bMF0gKyBtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGQ7XG4gICAgICByZXR1cm4gW3h0LCB5dF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KHIsIG0pIHtcbiAgICAgIHZhciBwMSA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0ociwgbSk7XG4gICAgICB2YXIgcDIgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKHIuc2xpY2UoMiwgNCksIG0pO1xuICAgICAgdmFyIHAzID0gVXRpbC5hcHBseVRyYW5zZm9ybShbclswXSwgclszXV0sIG0pO1xuICAgICAgdmFyIHA0ID0gVXRpbC5hcHBseVRyYW5zZm9ybShbclsyXSwgclsxXV0sIG0pO1xuICAgICAgcmV0dXJuIFtNYXRoLm1pbihwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksIE1hdGgubWluKHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKSwgTWF0aC5tYXgocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLCBNYXRoLm1heChwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnNlVHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmVyc2VUcmFuc2Zvcm0obSkge1xuICAgICAgdmFyIGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgICAgcmV0dXJuIFttWzNdIC8gZCwgLW1bMV0gLyBkLCAtbVsyXSAvIGQsIG1bMF0gLyBkLCAobVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkLCAobVs0XSAqIG1bMV0gLSBtWzVdICogbVswXSkgLyBkXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHkzZFRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseTNkVHJhbnNmb3JtKG0sIHYpIHtcbiAgICAgIHJldHVybiBbbVswXSAqIHZbMF0gKyBtWzFdICogdlsxXSArIG1bMl0gKiB2WzJdLCBtWzNdICogdlswXSArIG1bNF0gKiB2WzFdICsgbVs1XSAqIHZbMl0sIG1bNl0gKiB2WzBdICsgbVs3XSAqIHZbMV0gKyBtWzhdICogdlsyXV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG0pIHtcbiAgICAgIHZhciB0cmFuc3Bvc2UgPSBbbVswXSwgbVsyXSwgbVsxXSwgbVszXV07XG4gICAgICB2YXIgYSA9IG1bMF0gKiB0cmFuc3Bvc2VbMF0gKyBtWzFdICogdHJhbnNwb3NlWzJdO1xuICAgICAgdmFyIGIgPSBtWzBdICogdHJhbnNwb3NlWzFdICsgbVsxXSAqIHRyYW5zcG9zZVszXTtcbiAgICAgIHZhciBjID0gbVsyXSAqIHRyYW5zcG9zZVswXSArIG1bM10gKiB0cmFuc3Bvc2VbMl07XG4gICAgICB2YXIgZCA9IG1bMl0gKiB0cmFuc3Bvc2VbMV0gKyBtWzNdICogdHJhbnNwb3NlWzNdO1xuICAgICAgdmFyIGZpcnN0ID0gKGEgKyBkKSAvIDI7XG4gICAgICB2YXIgc2Vjb25kID0gTWF0aC5zcXJ0KE1hdGgucG93KGEgKyBkLCAyKSAtIDQgKiAoYSAqIGQgLSBjICogYikpIC8gMjtcbiAgICAgIHZhciBzeCA9IGZpcnN0ICsgc2Vjb25kIHx8IDE7XG4gICAgICB2YXIgc3kgPSBmaXJzdCAtIHNlY29uZCB8fCAxO1xuICAgICAgcmV0dXJuIFtNYXRoLnNxcnQoc3gpLCBNYXRoLnNxcnQoc3kpXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9ybWFsaXplUmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICAgIHZhciByID0gcmVjdC5zbGljZSgwKTtcblxuICAgICAgaWYgKHJlY3RbMF0gPiByZWN0WzJdKSB7XG4gICAgICAgIHJbMF0gPSByZWN0WzJdO1xuICAgICAgICByWzJdID0gcmVjdFswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY3RbMV0gPiByZWN0WzNdKSB7XG4gICAgICAgIHJbMV0gPSByZWN0WzNdO1xuICAgICAgICByWzNdID0gcmVjdFsxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVyc2VjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnNlY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3JkZXJlZFggPSBbcmVjdDFbMF0sIHJlY3QxWzJdLCByZWN0MlswXSwgcmVjdDJbMl1dLnNvcnQoY29tcGFyZSk7XG4gICAgICB2YXIgb3JkZXJlZFkgPSBbcmVjdDFbMV0sIHJlY3QxWzNdLCByZWN0MlsxXSwgcmVjdDJbM11dLnNvcnQoY29tcGFyZSk7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICByZWN0MSA9IFV0aWwubm9ybWFsaXplUmVjdChyZWN0MSk7XG4gICAgICByZWN0MiA9IFV0aWwubm9ybWFsaXplUmVjdChyZWN0Mik7XG5cbiAgICAgIGlmIChvcmRlcmVkWFswXSA9PT0gcmVjdDFbMF0gJiYgb3JkZXJlZFhbMV0gPT09IHJlY3QyWzBdIHx8IG9yZGVyZWRYWzBdID09PSByZWN0MlswXSAmJiBvcmRlcmVkWFsxXSA9PT0gcmVjdDFbMF0pIHtcbiAgICAgICAgcmVzdWx0WzBdID0gb3JkZXJlZFhbMV07XG4gICAgICAgIHJlc3VsdFsyXSA9IG9yZGVyZWRYWzJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmRlcmVkWVswXSA9PT0gcmVjdDFbMV0gJiYgb3JkZXJlZFlbMV0gPT09IHJlY3QyWzFdIHx8IG9yZGVyZWRZWzBdID09PSByZWN0MlsxXSAmJiBvcmRlcmVkWVsxXSA9PT0gcmVjdDFbMV0pIHtcbiAgICAgICAgcmVzdWx0WzFdID0gb3JkZXJlZFlbMV07XG4gICAgICAgIHJlc3VsdFszXSA9IG9yZGVyZWRZWzJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFV0aWw7XG59KCk7XG5cbmV4cG9ydHMuVXRpbCA9IFV0aWw7XG52YXIgUERGU3RyaW5nVHJhbnNsYXRlVGFibGUgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyRDgsIDB4MkM3LCAweDJDNiwgMHgyRDksIDB4MkRELCAweDJEQiwgMHgyREEsIDB4MkRDLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDIwMjIsIDB4MjAyMCwgMHgyMDIxLCAweDIwMjYsIDB4MjAxNCwgMHgyMDEzLCAweDE5MiwgMHgyMDQ0LCAweDIwMzksIDB4MjAzQSwgMHgyMjEyLCAweDIwMzAsIDB4MjAxRSwgMHgyMDFDLCAweDIwMUQsIDB4MjAxOCwgMHgyMDE5LCAweDIwMUEsIDB4MjEyMiwgMHhGQjAxLCAweEZCMDIsIDB4MTQxLCAweDE1MiwgMHgxNjAsIDB4MTc4LCAweDE3RCwgMHgxMzEsIDB4MTQyLCAweDE1MywgMHgxNjEsIDB4MTdFLCAwLCAweDIwQUNdO1xuXG5mdW5jdGlvbiBzdHJpbmdUb1BERlN0cmluZyhzdHIpIHtcbiAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGgsXG4gICAgICBzdHJCdWYgPSBbXTtcblxuICBpZiAoc3RyWzBdID09PSBcIlxceEZFXCIgJiYgc3RyWzFdID09PSBcIlxceEZGXCIpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHN0ci5jaGFyQ29kZUF0KGkpIDw8IDggfCBzdHIuY2hhckNvZGVBdChpICsgMSkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RyWzBdID09PSBcIlxceEZGXCIgJiYgc3RyWzFdID09PSBcIlxceEZFXCIpIHtcbiAgICBmb3IgKHZhciBfaTIgPSAyOyBfaTIgPCBsZW5ndGg7IF9pMiArPSAyKSB7XG4gICAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHN0ci5jaGFyQ29kZUF0KF9pMiArIDEpIDw8IDggfCBzdHIuY2hhckNvZGVBdChfaTIpKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxlbmd0aDsgKytfaTMpIHtcbiAgICAgIHZhciBjb2RlID0gUERGU3RyaW5nVHJhbnNsYXRlVGFibGVbc3RyLmNoYXJDb2RlQXQoX2kzKV07XG4gICAgICBzdHJCdWYucHVzaChjb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSA6IHN0ci5jaGFyQXQoX2kzKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsoKVxcXFxcXG5cXHJdKS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09IFwiXFxuXCIpIHtcbiAgICAgIHJldHVybiBcIlxcXFxuXCI7XG4gICAgfSBlbHNlIGlmIChtYXRjaCA9PT0gXCJcXHJcIikge1xuICAgICAgcmV0dXJuIFwiXFxcXHJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcXFxcXCIuY29uY2F0KG1hdGNoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzQXNjaWkoc3RyKSB7XG4gIHJldHVybiAvXltcXHgwMC1cXHg3Rl0qJC8udGVzdChzdHIpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjE2QkVTdHJpbmcoc3RyKSB7XG4gIHZhciBidWYgPSBbXCJcXHhGRVxceEZGXCJdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHN0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIF9jaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBidWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKF9jaGFyID4+IDggJiAweGZmKSk7XG4gICAgYnVmLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShfY2hhciAmIDB4ZmYpKTtcbiAgfVxuXG4gIHJldHVybiBidWYuam9pbihcIlwiKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4U3RyaW5nKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbn1cblxuZnVuY3Rpb24gdXRmOFN0cmluZ1RvU3RyaW5nKHN0cikge1xuICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2wodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwiYm9vbGVhblwiO1xufVxuXG5mdW5jdGlvbiBpc051bSh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIjtcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodikge1xuICByZXR1cm4gX3R5cGVvZih2KSA9PT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsICYmIHYuYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5RXF1YWwoYXJyMSwgYXJyMikge1xuICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGFycjEuZXZlcnkoZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPT09IGFycjJbaW5kZXhdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TW9kaWZpY2F0aW9uRGF0ZSgpIHtcbiAgdmFyIGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG5ldyBEYXRlKCk7XG4gIHZhciBidWZmZXIgPSBbZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCksIChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENEYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDU2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpXTtcbiAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSgpIHtcbiAgdmFyIGNhcGFiaWxpdHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgaXNTZXR0bGVkID0gZmFsc2U7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYXBhYmlsaXR5LCBcInNldHRsZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGlzU2V0dGxlZDtcbiAgICB9XG4gIH0pO1xuICBjYXBhYmlsaXR5LnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgY2FwYWJpbGl0eS5yZXNvbHZlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGlzU2V0dGxlZCA9IHRydWU7XG4gICAgICByZXNvbHZlKGRhdGEpO1xuICAgIH07XG5cbiAgICBjYXBhYmlsaXR5LnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlzU2V0dGxlZCA9IHRydWU7XG4gICAgICByZWplY3QocmVhc29uKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGNhcGFiaWxpdHk7XG59XG5cbnZhciBjcmVhdGVPYmplY3RVUkwgPSBmdW5jdGlvbiBjcmVhdGVPYmplY3RVUkxDbG9zdXJlKCkge1xuICB2YXIgZGlnaXRzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlT2JqZWN0VVJMKGRhdGEsIGNvbnRlbnRUeXBlKSB7XG4gICAgdmFyIGZvcmNlRGF0YVNjaGVtYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICBpZiAoIWZvcmNlRGF0YVNjaGVtYSAmJiBVUkwuY3JlYXRlT2JqZWN0VVJMKSB7XG4gICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwge1xuICAgICAgICB0eXBlOiBjb250ZW50VHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB9XG5cbiAgICB2YXIgYnVmZmVyID0gXCJkYXRhOlwiLmNvbmNhdChjb250ZW50VHlwZSwgXCI7YmFzZTY0LFwiKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGRhdGEubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgdmFyIGIxID0gZGF0YVtpXSAmIDB4ZmY7XG4gICAgICB2YXIgYjIgPSBkYXRhW2kgKyAxXSAmIDB4ZmY7XG4gICAgICB2YXIgYjMgPSBkYXRhW2kgKyAyXSAmIDB4ZmY7XG4gICAgICB2YXIgZDEgPSBiMSA+PiAyLFxuICAgICAgICAgIGQyID0gKGIxICYgMykgPDwgNCB8IGIyID4+IDQ7XG4gICAgICB2YXIgZDMgPSBpICsgMSA8IGlpID8gKGIyICYgMHhmKSA8PCAyIHwgYjMgPj4gNiA6IDY0O1xuICAgICAgdmFyIGQ0ID0gaSArIDIgPCBpaSA/IGIzICYgMHgzZiA6IDY0O1xuICAgICAgYnVmZmVyICs9IGRpZ2l0c1tkMV0gKyBkaWdpdHNbZDJdICsgZGlnaXRzW2QzXSArIGRpZ2l0c1tkNF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5jcmVhdGVPYmplY3RVUkwgPSBjcmVhdGVPYmplY3RVUkw7XG52YXIgWE1MRW50aXRpZXMgPSB7XG4gIDB4M2M6IFwiJmx0O1wiLFxuICAweDNlOiBcIiZndDtcIixcbiAgMHgyNjogXCImYW1wO1wiLFxuICAweDIyOiBcIiZxdW90O1wiLFxuICAweDI3OiBcIiZhcG9zO1wiXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVUb1htbFN0cmluZyhzdHIpIHtcbiAgdmFyIGJ1ZmZlciA9IFtdO1xuICB2YXIgc3RhcnQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IHN0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgdmFyIF9jaGFyMiA9IHN0ci5jb2RlUG9pbnRBdChpKTtcblxuICAgIGlmICgweDIwIDw9IF9jaGFyMiAmJiBfY2hhcjIgPD0gMHg3ZSkge1xuICAgICAgdmFyIGVudGl0eSA9IFhNTEVudGl0aWVzW19jaGFyMl07XG5cbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgaSkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlci5wdXNoKGVudGl0eSk7XG4gICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGFydCA8IGkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goc3RyLnN1YnN0cmluZyhzdGFydCwgaSkpO1xuICAgICAgfVxuXG4gICAgICBidWZmZXIucHVzaChcIiYjeFwiLmNvbmNhdChfY2hhcjIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksIFwiO1wiKSk7XG5cbiAgICAgIGlmIChfY2hhcjIgPiAweGQ3ZmYgJiYgKF9jaGFyMiA8IDB4ZTAwMCB8fCBfY2hhcjIgPiAweGZmZmQpKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICB9XG4gIH1cblxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAoc3RhcnQgPCBzdHIubGVuZ3RoKSB7XG4gICAgYnVmZmVyLnB1c2goc3RyLnN1YnN0cmluZyhzdGFydCwgc3RyLmxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXCIpO1xufVxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaXNfbm9kZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG5cbmlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhZ2xvYmFsVGhpcy5fcGRmanNDb21wYXRpYmlsaXR5Q2hlY2tlZCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwidW5kZWZpbmVkXCIgfHwgZ2xvYmFsVGhpcy5NYXRoICE9PSBNYXRoKSB7XG4gICAgZ2xvYmFsVGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oNyk7XG4gIH1cblxuICBnbG9iYWxUaGlzLl9wZGZqc0NvbXBhdGliaWxpdHlDaGVja2VkID0gdHJ1ZTtcblxuICAoZnVuY3Rpb24gY2hlY2tOb2RlQnRvYSgpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5idG9hIHx8ICFfaXNfbm9kZS5pc05vZGVKUykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdsb2JhbFRoaXMuYnRvYSA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNoYXJzLCBcImJpbmFyeVwiKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja05vZGVBdG9iKCkge1xuICAgIGlmIChnbG9iYWxUaGlzLmF0b2IgfHwgIV9pc19ub2RlLmlzTm9kZUpTKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2xvYmFsVGhpcy5hdG9iID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oaW5wdXQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwiYmluYXJ5XCIpO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIGNoZWNrT2JqZWN0RnJvbUVudHJpZXMoKSB7XG4gICAgaWYgKE9iamVjdC5mcm9tRW50cmllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9fd19wZGZqc19yZXF1aXJlX18oNTIpO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja1Byb21pc2UoKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuUHJvbWlzZS5hbGxTZXR0bGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2xvYmFsVGhpcy5Qcm9taXNlID0gX193X3BkZmpzX3JlcXVpcmVfXyg4Mik7XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIGNoZWNrVVJMKCkge1xuICAgIGdsb2JhbFRoaXMuVVJMID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTEpO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja1JlYWRhYmxlU3RyZWFtKCkge1xuICAgIHZhciBpc1JlYWRhYmxlU3RyZWFtU3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIGlmIChpc1JlYWRhYmxlU3RyZWFtU3VwcG9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTIxKS5SZWFkYWJsZVN0cmVhbTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tTdHJpbmdQYWRTdGFydCgpIHtcbiAgICBpZiAoU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9fd19wZGZqc19yZXF1aXJlX18oMTIyKTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tTdHJpbmdQYWRFbmQoKSB7XG4gICAgaWYgKFN0cmluZy5wcm90b3R5cGUucGFkRW5kKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX193X3BkZmpzX3JlcXVpcmVfXygxMjgpO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja09iamVjdFZhbHVlcygpIHtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE9iamVjdC52YWx1ZXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzMCk7XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIGNoZWNrT2JqZWN0RW50cmllcygpIHtcbiAgICBpZiAoT2JqZWN0LmVudHJpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBPYmplY3QuZW50cmllcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMzKTtcbiAgfSkoKTtcbn1cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5pc05vZGVKUyA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgaXNOb2RlSlMgPSAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihwcm9jZXNzKSkgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyArIFwiXCIgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiICYmICFwcm9jZXNzLnZlcnNpb25zLm53ICYmICEocHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbiAmJiBwcm9jZXNzLnR5cGUgJiYgcHJvY2Vzcy50eXBlICE9PSBcImJyb3dzZXJcIik7XG5leHBvcnRzLmlzTm9kZUpTID0gaXNOb2RlSlM7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oOCk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXyg5KTtcbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbiQoeyBnbG9iYWw6IHRydWUgfSwgeyBnbG9iYWxUaGlzOiBnbG9iYWwgfSk7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDExKS5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpO1xudmFyIHJlZGVmaW5lID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG52YXIgc2V0R2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygyOSk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMzkpO1xudmFyIGlzRm9yY2VkID0gX193X3BkZmpzX3JlcXVpcmVfXyg1MSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiBpZiAoR0xPQkFMKSB7XG4gIHRhcmdldCA9IGdsb2JhbDtcbiB9IGVsc2UgaWYgKFNUQVRJQykge1xuICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBzZXRHbG9iYWwoVEFSR0VULCB7fSk7XG4gfSBlbHNlIHtcbiAgdGFyZ2V0ID0gKGdsb2JhbFtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gfVxuIGlmICh0YXJnZXQpXG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICB9IGVsc2VcbiAgICB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpXG4gICAgIGNvbnRpbnVlO1xuICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgIH1cbiAgIGlmIChvcHRpb25zLnNoYW0gfHwgdGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgIH1cbiAgIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8IGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fCBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fCBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHwgZnVuY3Rpb24gKCkge1xuIHJldHVybiB0aGlzO1xufSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTYpO1xudmFyIHRvUHJpbWl0aXZlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG52YXIgaGFzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIzKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuIGlmIChJRThfRE9NX0RFRklORSlcbiAgdHJ5IHtcbiAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gIH1cbiBpZiAoaGFzKE8sIFApKVxuICByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMpO1xubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gNztcbiAgfVxuIH0pWzFdICE9IDc7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gdHJ5IHtcbiAgcmV0dXJuICEhZXhlYygpO1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gIHJldHVybiB0cnVlO1xuIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gcmV0dXJuIHtcbiAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgdmFsdWU6IHZhbHVlXG4gfTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMpO1xudmFyIGNsYXNzb2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE4KTtcbnZhciBzcGxpdCA9ICcnLnNwbGl0O1xubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gcmV0dXJuICFPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIGNsYXNzb2YoaXQpID09ICdTdHJpbmcnID8gc3BsaXQuY2FsbChpdCwgJycpIDogT2JqZWN0KGl0KTtcbn0gOiBPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gaWYgKGl0ID09IHVuZGVmaW5lZClcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gcmV0dXJuIGl0O1xufTtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjEpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIFBSRUZFUlJFRF9TVFJJTkcpIHtcbiBpZiAoIWlzT2JqZWN0KGlucHV0KSlcbiAgcmV0dXJuIGlucHV0O1xuIHZhciBmbiwgdmFsO1xuIGlmIChQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKVxuICByZXR1cm4gdmFsO1xuIGlmICh0eXBlb2YgKGZuID0gaW5wdXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKVxuICByZXR1cm4gdmFsO1xuIGlmICghUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSlcbiAgcmV0dXJuIHZhbDtcbiB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXygxMik7XG52YXIgZmFpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNCk7XG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiA3O1xuICB9XG4gfSkuYSAhPSA3O1xufSk7XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgaXNPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuIHJldHVybiBFWElTVFMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTIpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyNik7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxNSk7XG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiByZXR1cm4gb2JqZWN0O1xufTtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTIpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193X3BkZmpzX3JlcXVpcmVfXygyMyk7XG52YXIgYW5PYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI3KTtcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiBhbk9iamVjdChPKTtcbiBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gaWYgKElFOF9ET01fREVGSU5FKVxuICB0cnkge1xuICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICB9XG4gaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcylcbiAgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpXG4gIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuIHJldHVybiBPO1xufTtcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjEpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiBpZiAoIWlzT2JqZWN0KGl0KSkge1xuICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xuIH1cbiByZXR1cm4gaXQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpO1xudmFyIGhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIHNldEdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjkpO1xudmFyIGluc3BlY3RTb3VyY2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMwKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygzMik7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiB2YXIgdW5zYWZlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy51bnNhZmUgOiBmYWxzZTtcbiB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG4gdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuIHZhciBzdGF0ZTtcbiBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgJiYgIWhhcyh2YWx1ZSwgJ25hbWUnKSkge1xuICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIGtleSk7XG4gIH1cbiAgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gIGlmICghc3RhdGUuc291cmNlKSB7XG4gICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBrZXkgOiAnJyk7XG4gIH1cbiB9XG4gaWYgKE8gPT09IGdsb2JhbCkge1xuICBpZiAoc2ltcGxlKVxuICAgT1trZXldID0gdmFsdWU7XG4gIGVsc2VcbiAgIHNldEdsb2JhbChrZXksIHZhbHVlKTtcbiAgcmV0dXJuO1xuIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xuICBkZWxldGUgT1trZXldO1xuIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xuICBzaW1wbGUgPSB0cnVlO1xuIH1cbiBpZiAoc2ltcGxlKVxuICBPW2tleV0gPSB2YWx1ZTtcbiBlbHNlXG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCBrZXksIHZhbHVlKTtcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuIHRyeSB7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShnbG9iYWwsIGtleSwgdmFsdWUpO1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gIGdsb2JhbFtrZXldID0gdmFsdWU7XG4gfVxuIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgc3RvcmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMxKTtcbnZhciBmdW5jdGlvblRvU3RyaW5nID0gRnVuY3Rpb24udG9TdHJpbmc7XG5pZiAodHlwZW9mIHN0b3JlLmluc3BlY3RTb3VyY2UgIT0gJ2Z1bmN0aW9uJykge1xuIHN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XG4gfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBzZXRHbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gX193X3BkZmpzX3JlcXVpcmVfXygzMyk7XG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgaXNPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI1KTtcbnZhciBvYmplY3RIYXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyKTtcbnZhciBzaGFyZWQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMxKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM0KTtcbnZhciBoaWRkZW5LZXlzID0gX193X3BkZmpzX3JlcXVpcmVfXygzOCk7XG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHN0YXRlO1xuICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xuIH07XG59O1xuaWYgKE5BVElWRV9XRUFLX01BUCkge1xuIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gdmFyIHdtZ2V0ID0gc3RvcmUuZ2V0O1xuIHZhciB3bWhhcyA9IHN0b3JlLmhhcztcbiB2YXIgd21zZXQgPSBzdG9yZS5zZXQ7XG4gc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgd21zZXQuY2FsbChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgcmV0dXJuIG1ldGFkYXRhO1xuIH07XG4gZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB3bWdldC5jYWxsKHN0b3JlLCBpdCkgfHwge307XG4gfTtcbiBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUsIGl0KTtcbiB9O1xufSBlbHNlIHtcbiB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gaGlkZGVuS2V5c1tTVEFURV0gPSB0cnVlO1xuIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgcmV0dXJuIG1ldGFkYXRhO1xuIH07XG4gZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuIH07XG4gaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKTtcbiB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gc2V0OiBzZXQsXG4gZ2V0OiBnZXQsXG4gaGFzOiBoYXMsXG4gZW5mb3JjZTogZW5mb3JjZSxcbiBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBpbnNwZWN0U291cmNlID0gX193X3BkZmpzX3JlcXVpcmVfXygzMCk7XG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwKSk7XG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgc2hhcmVkID0gX193X3BkZmpzX3JlcXVpcmVfXygzNSk7XG52YXIgdWlkID0gX193X3BkZmpzX3JlcXVpcmVfXygzNyk7XG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBJU19QVVJFID0gX193X3BkZmpzX3JlcXVpcmVfXygzNik7XG52YXIgc3RvcmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMxKTtcbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gdmVyc2lvbjogJzMuOC4zJyxcbiBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gY29weXJpZ2h0OiAnwqkgMjAyMSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuXG4vKioqLyB9KSxcbi8qIDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgaGFzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG52YXIgb3duS2V5cyA9IF9fd19wZGZqc19yZXF1aXJlX18oNDApO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyNik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgaWYgKCFoYXModGFyZ2V0LCBrZXkpKVxuICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuIH1cbn07XG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd19wZGZqc19yZXF1aXJlX18oNDEpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQzKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUwKTtcbnZhciBhbk9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjcpO1xubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cbi8qKiovIH0pLFxuLyogNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgcGF0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDIpO1xudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuIHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT0gJ2Z1bmN0aW9uJyA/IHZhcmlhYmxlIDogdW5kZWZpbmVkO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKHBhdGhbbmFtZXNwYWNlXSkgfHwgYUZ1bmN0aW9uKGdsb2JhbFtuYW1lc3BhY2VdKSA6IHBhdGhbbmFtZXNwYWNlXSAmJiBwYXRoW25hbWVzcGFjZV1bbWV0aG9kXSB8fCBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd19wZGZqc19yZXF1aXJlX18oNDQpO1xudmFyIGVudW1CdWdLZXlzID0gX193X3BkZmpzX3JlcXVpcmVfXyg0OSk7XG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgaGFzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxNik7XG52YXIgaW5kZXhPZiA9IF9fd19wZGZqc19yZXF1aXJlX18oNDUpLmluZGV4T2Y7XG52YXIgaGlkZGVuS2V5cyA9IF9fd19wZGZqc19yZXF1aXJlX18oMzgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gdmFyIGkgPSAwO1xuIHZhciByZXN1bHQgPSBbXTtcbiB2YXIga2V5O1xuIGZvciAoa2V5IGluIE8pXG4gICFoYXMoaGlkZGVuS2V5cywga2V5KSAmJiBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKVxuICBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTYpO1xudmFyIHRvTGVuZ3RoID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Nik7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0OCk7XG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gIHZhciB2YWx1ZTtcbiAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKVxuICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSlcbiAgICAgcmV0dXJuIHRydWU7XG4gICB9XG4gIGVsc2VcbiAgIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKVxuICAgICByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgIH1cbiAgcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiB9O1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcblxuLyoqKi8gfSksXG4vKiA0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0ludGVnZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ3KTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXIoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7XG59O1xuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gcmV0dXJuIGlzTmFOKGFyZ3VtZW50ID0gK2FyZ3VtZW50KSA/IDAgOiAoYXJndW1lbnQgPiAwID8gZmxvb3IgOiBjZWlsKShhcmd1bWVudCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd19wZGZqc19yZXF1aXJlX18oNDcpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyKGluZGV4KTtcbiByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gJ2NvbnN0cnVjdG9yJyxcbiAnaGFzT3duUHJvcGVydHknLFxuICdpc1Byb3RvdHlwZU9mJyxcbiAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICd0b0xvY2FsZVN0cmluZycsXG4gJ3RvU3RyaW5nJyxcbiAndmFsdWVPZidcbl07XG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMyk7XG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2UgOiB0eXBlb2YgZGV0ZWN0aW9uID09ICdmdW5jdGlvbicgPyBmYWlscyhkZXRlY3Rpb24pIDogISFkZXRlY3Rpb247XG59O1xudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xubW9kdWxlLmV4cG9ydHMgPSBpc0ZvcmNlZDtcblxuLyoqKi8gfSksXG4vKiA1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oNTMpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg3Mik7XG52YXIgcGF0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDIpO1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoLk9iamVjdC5mcm9tRW50cmllcztcblxuLyoqKi8gfSksXG4vKiA1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxNik7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd19wZGZqc19yZXF1aXJlX18oNTQpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd19wZGZqc19yZXF1aXJlX18oNjIpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMyKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oNjMpO1xudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgdGFyZ2V0OiB0b0luZGV4ZWRPYmplY3QoaXRlcmF0ZWQpLFxuICBpbmRleDogMCxcbiAga2luZDoga2luZFxuIH0pO1xufSwgZnVuY3Rpb24gKCkge1xuIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcbiBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHtcbiAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICBkb25lOiB0cnVlXG4gIH07XG4gfVxuIGlmIChraW5kID09ICdrZXlzJylcbiAgcmV0dXJuIHtcbiAgIHZhbHVlOiBpbmRleCxcbiAgIGRvbmU6IGZhbHNlXG4gIH07XG4gaWYgKGtpbmQgPT0gJ3ZhbHVlcycpXG4gIHJldHVybiB7XG4gICB2YWx1ZTogdGFyZ2V0W2luZGV4XSxcbiAgIGRvbmU6IGZhbHNlXG4gIH07XG4gcmV0dXJuIHtcbiAgdmFsdWU6IFtcbiAgIGluZGV4LFxuICAgdGFyZ2V0W2luZGV4XVxuICBdLFxuICBkb25lOiBmYWxzZVxuIH07XG59LCAndmFsdWVzJyk7XG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cbi8qKiovIH0pLFxuLyogNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1NSk7XG52YXIgY3JlYXRlID0gX193X3BkZmpzX3JlcXVpcmVfXyg1OCk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI2KTtcbnZhciBVTlNDT1BBQkxFUyA9IHdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogY3JlYXRlKG51bGwpXG4gfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIHNoYXJlZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMzUpO1xudmFyIGhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIHVpZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMzcpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU2KTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTcpO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gaWYgKCFoYXMoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSkge1xuICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXMoU3ltYm9sLCBuYW1lKSlcbiAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbFtuYW1lXTtcbiAgZWxzZVxuICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKCdTeW1ib2wuJyArIG5hbWUpO1xuIH1cbiByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcblxuLyoqKi8gfSksXG4vKiA1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMpO1xubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gIVN0cmluZyhTeW1ib2woKSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBOQVRJVkVfU1lNQk9MID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nik7XG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0wgJiYgIVN5bWJvbC5zaGFtICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cbi8qKiovIH0pLFxuLyogNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI3KTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gX193X3BkZmpzX3JlcXVpcmVfXyg1OSk7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ5KTtcbnZhciBoaWRkZW5LZXlzID0gX193X3BkZmpzX3JlcXVpcmVfXygzOCk7XG52YXIgaHRtbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNjEpO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjQpO1xudmFyIHNoYXJlZEtleSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzQpO1xudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFNDUklQVCA9ICdzY3JpcHQnO1xudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG59O1xudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiBhY3RpdmVYRG9jdW1lbnQgPSBudWxsO1xuIHJldHVybiB0ZW1wO1xufTtcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuIHZhciBpZnJhbWVEb2N1bWVudDtcbiBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuIHJldHVybiBpZnJhbWVEb2N1bWVudC5GO1xufTtcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuIHRyeSB7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IGRvY3VtZW50LmRvbWFpbiAmJiBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiB9IGNhdGNoIChlcnJvcikge1xuIH1cbiBOdWxsUHJvdG9PYmplY3QgPSBhY3RpdmVYRG9jdW1lbnQgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKTtcbiB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuIHdoaWxlIChsZW5ndGgtLSlcbiAgZGVsZXRlIE51bGxQcm90b09iamVjdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2xlbmd0aF1dO1xuIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5oaWRkZW5LZXlzW0lFX1BST1RPXSA9IHRydWU7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiB2YXIgcmVzdWx0O1xuIGlmIChPICE9PSBudWxsKSB7XG4gIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBudWxsO1xuICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiB9IGVsc2VcbiAgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjYpO1xudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNyk7XG52YXIgb2JqZWN0S2V5cyA9IF9fd19wZGZqc19yZXF1aXJlX18oNjApO1xubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gYW5PYmplY3QoTyk7XG4gdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiB2YXIgaW5kZXggPSAwO1xuIHZhciBrZXk7XG4gd2hpbGUgKGxlbmd0aCA+IGluZGV4KVxuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIFByb3BlcnRpZXNba2V5XSk7XG4gcmV0dXJuIE87XG59O1xuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd19wZGZqc19yZXF1aXJlX18oNDQpO1xudmFyIGVudW1CdWdLZXlzID0gX193X3BkZmpzX3JlcXVpcmVfXyg0OSk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuLyoqKi8gfSksXG4vKiA2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRCdWlsdEluID0gX193X3BkZmpzX3JlcXVpcmVfXyg0MSk7XG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY0KTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd19wZGZqc19yZXF1aXJlX18oNjYpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193X3BkZmpzX3JlcXVpcmVfXyg3MCk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY5KTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI1KTtcbnZhciByZWRlZmluZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjgpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTUpO1xudmFyIElTX1BVUkUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM2KTtcbnZhciBJdGVyYXRvcnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYyKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gX193X3BkZmpzX3JlcXVpcmVfXyg2NSk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcbnZhciBFTlRSSUVTID0gJ2VudHJpZXMnO1xudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7XG4gcmV0dXJuIHRoaXM7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKVxuICAgcmV0dXJuIGRlZmF1bHRJdGVyYXRvcjtcbiAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpXG4gICByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gIHN3aXRjaCAoS0lORCkge1xuICBjYXNlIEtFWVM6XG4gICByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7XG4gICB9O1xuICBjYXNlIFZBTFVFUzpcbiAgIHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpO1xuICAgfTtcbiAgY2FzZSBFTlRSSUVTOlxuICAgcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpO1xuICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpO1xuICB9O1xuIH07XG4gdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl0gfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXSB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcbiBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgIGlmICghSVNfUFVSRSAmJiBnZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUpICE9PSBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICBzZXRQcm90b3R5cGVPZihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgIH1cbiAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICBpZiAoSVNfUFVSRSlcbiAgICBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICB9XG4gfVxuIGlmIChERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcbiAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7XG4gIH07XG4gfVxuIGlmICgoIUlTX1BVUkUgfHwgRk9SQ0VEKSAmJiBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SLCBkZWZhdWx0SXRlcmF0b3IpO1xuIH1cbiBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG4gaWYgKERFRkFVTFQpIHtcbiAgbWV0aG9kcyA9IHtcbiAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgfTtcbiAgaWYgKEZPUkNFRClcbiAgIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgfVxuICAgfVxuICBlbHNlXG4gICAkKHtcbiAgICB0YXJnZXQ6IE5BTUUsXG4gICAgcHJvdG86IHRydWUsXG4gICAgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRVxuICAgfSwgbWV0aG9kcyk7XG4gfVxuIHJldHVybiBtZXRob2RzO1xufTtcblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY1KS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU4KTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1KTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd19wZGZqc19yZXF1aXJlX18oNjkpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd19wZGZqc19yZXF1aXJlX18oNjIpO1xudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7XG4gcmV0dXJuIHRoaXM7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuIEl0ZXJhdG9yQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSwgdHJ1ZSk7XG4gSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY2KTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI1KTtcbnZhciBoYXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU1KTtcbnZhciBJU19QVVJFID0gX193X3BkZmpzX3JlcXVpcmVfXygzNik7XG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IGZhbHNlO1xudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7XG4gcmV0dXJuIHRoaXM7XG59O1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5pZiAoW10ua2V5cykge1xuIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKVxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiBlbHNlIHtcbiAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKVxuICAgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gfVxufVxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuIHZhciB0ZXN0ID0ge307XG4gcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xufSk7XG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSlcbiBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuaWYgKCghSVNfUFVSRSB8fCBORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpIHtcbiBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSxcbiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuXG4vKioqLyB9KSxcbi8qIDY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIHRvT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg2Nyk7XG52YXIgc2hhcmVkS2V5ID0gX193X3BkZmpzX3JlcXVpcmVfXygzNCk7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gX193X3BkZmpzX3JlcXVpcmVfXyg2OCk7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbm1vZHVsZS5leHBvcnRzID0gQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiBPID0gdG9PYmplY3QoTyk7XG4gaWYgKGhhcyhPLCBJRV9QUk9UTykpXG4gIHJldHVybiBPW0lFX1BST1RPXTtcbiBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gfVxuIHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTkpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiByZXR1cm4gT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG5cbi8qKiovIH0pLFxuLyogNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiBmdW5jdGlvbiBGKCkge1xuIH1cbiBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxuLyoqKi8gfSksXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjYpLmY7XG52YXIgaGFzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1NSk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xuIGlmIChpdCAmJiAhaGFzKGl0ID0gU1RBVElDID8gaXQgOiBpdC5wcm90b3R5cGUsIFRPX1NUUklOR19UQUcpKSB7XG4gIGRlZmluZVByb3BlcnR5KGl0LCBUT19TVFJJTkdfVEFHLCB7XG4gICBjb25maWd1cmFibGU6IHRydWUsXG4gICB2YWx1ZTogVEFHXG4gIH0pO1xuIH1cbn07XG5cbi8qKiovIH0pLFxuLyogNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI3KTtcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcxKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiB2YXIgdGVzdCA9IHt9O1xuIHZhciBzZXR0ZXI7XG4gdHJ5IHtcbiAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuICBzZXR0ZXIuY2FsbCh0ZXN0LCBbXSk7XG4gIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gfVxuIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgaWYgKENPUlJFQ1RfU0VUVEVSKVxuICAgc2V0dGVyLmNhbGwoTywgcHJvdG8pO1xuICBlbHNlXG4gICBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICByZXR1cm4gTztcbiB9O1xufSgpIDogdW5kZWZpbmVkKTtcblxuLyoqKi8gfSksXG4vKiA3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjEpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiBpZiAoIWlzT2JqZWN0KGl0KSAmJiBpdCAhPT0gbnVsbCkge1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyBTdHJpbmcoaXQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xuIH1cbiByZXR1cm4gaXQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDcyICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oOSk7XG52YXIgaXRlcmF0ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNzMpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXyg4MSk7XG4kKHtcbiB0YXJnZXQ6ICdPYmplY3QnLFxuIHN0YXQ6IHRydWVcbn0sIHtcbiBmcm9tRW50cmllczogZnVuY3Rpb24gZnJvbUVudHJpZXMoaXRlcmFibGUpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICBpdGVyYXRlKGl0ZXJhYmxlLCBmdW5jdGlvbiAoaywgdikge1xuICAgY3JlYXRlUHJvcGVydHkob2JqLCBrLCB2KTtcbiAgfSwgeyBBU19FTlRSSUVTOiB0cnVlIH0pO1xuICByZXR1cm4gb2JqO1xuIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNyk7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gX193X3BkZmpzX3JlcXVpcmVfXyg3NCk7XG52YXIgdG9MZW5ndGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ2KTtcbnZhciBiaW5kID0gX193X3BkZmpzX3JlcXVpcmVfXyg3NSk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc3KTtcbnZhciBpdGVyYXRvckNsb3NlID0gX193X3BkZmpzX3JlcXVpcmVfXyg4MCk7XG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIHVuYm91bmRGdW5jdGlvbiwgb3B0aW9ucykge1xuIHZhciB0aGF0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnRoYXQ7XG4gdmFyIEFTX0VOVFJJRVMgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuQVNfRU5UUklFUyk7XG4gdmFyIElTX0lURVJBVE9SID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklTX0lURVJBVE9SKTtcbiB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuIHZhciBmbiA9IGJpbmQodW5ib3VuZEZ1bmN0aW9uLCB0aGF0LCAxICsgQVNfRU5UUklFUyArIElOVEVSUlVQVEVEKTtcbiB2YXIgaXRlcmF0b3IsIGl0ZXJGbiwgaW5kZXgsIGxlbmd0aCwgcmVzdWx0LCBuZXh0LCBzdGVwO1xuIHZhciBzdG9wID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICBpZiAoaXRlcmF0b3IpXG4gICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yKTtcbiAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgY29uZGl0aW9uKTtcbiB9O1xuIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKEFTX0VOVFJJRVMpIHtcbiAgIGFuT2JqZWN0KHZhbHVlKTtcbiAgIHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSwgc3RvcCkgOiBmbih2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICB9XG4gIHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiB9O1xuIGlmIChJU19JVEVSQVRPUikge1xuICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuIH0gZWxzZSB7XG4gIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJylcbiAgIHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBpdGVyYWJsZScpO1xuICBpZiAoaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJGbikpIHtcbiAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KVxuICAgICByZXR1cm4gcmVzdWx0O1xuICAgfVxuICAgcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICB9XG4gIGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpO1xuIH1cbiBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiB3aGlsZSAoIShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZSkge1xuICB0cnkge1xuICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvcik7XG4gICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KVxuICAgcmV0dXJuIHJlc3VsdDtcbiB9XG4gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcblxuLyoqKi8gfSksXG4vKiA3NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU1KTtcbnZhciBJdGVyYXRvcnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYyKTtcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGFGdW5jdGlvbiA9IF9fd19wZGZqc19yZXF1aXJlX18oNzYpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuIGFGdW5jdGlvbihmbik7XG4gaWYgKHRoYXQgPT09IHVuZGVmaW5lZClcbiAgcmV0dXJuIGZuO1xuIHN3aXRjaCAobGVuZ3RoKSB7XG4gY2FzZSAwOlxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIGZuLmNhbGwodGhhdCk7XG4gIH07XG4gY2FzZSAxOlxuICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICB9O1xuIGNhc2UgMjpcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgfTtcbiBjYXNlIDM6XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gIH07XG4gfVxuIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuIH07XG59O1xuXG4vKioqLyB9KSxcbi8qIDc2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB7XG4gIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuIH1cbiByZXR1cm4gaXQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDc3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGNsYXNzb2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc4KTtcbnZhciBJdGVyYXRvcnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYyKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU1KTtcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gaWYgKGl0ICE9IHVuZGVmaW5lZClcbiAgcmV0dXJuIGl0W0lURVJBVE9SXSB8fCBpdFsnQEBpdGVyYXRvciddIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd19wZGZqc19yZXF1aXJlX18oNzkpO1xudmFyIGNsYXNzb2ZSYXcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE4KTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU1KTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdyhmdW5jdGlvbiAoKSB7XG4gcmV0dXJuIGFyZ3VtZW50cztcbn0oKSkgPT0gJ0FyZ3VtZW50cyc7XG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiB0cnkge1xuICByZXR1cm4gaXRba2V5XTtcbiB9IGNhdGNoIChlcnJvcikge1xuIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiB2YXIgTywgdGFnLCByZXN1bHQ7XG4gcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZyA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKSA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxuLyoqKi8gfSksXG4vKiA3OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU1KTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuXG4vKioqLyB9KSxcbi8qIDgwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuIHZhciByZXR1cm5NZXRob2QgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gaWYgKHJldHVybk1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gIHJldHVybiBhbk9iamVjdChyZXR1cm5NZXRob2QuY2FsbChpdGVyYXRvcikpLnZhbHVlO1xuIH1cbn07XG5cbi8qKiovIH0pLFxuLyogODEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHRvUHJpbWl0aXZlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI2KTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKGtleSk7XG4gaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdClcbiAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgdmFsdWUpKTtcbiBlbHNlXG4gIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG5cbi8qKiovIH0pLFxuLyogODIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5fX3dfcGRmanNfcmVxdWlyZV9fKDgzKTtcbl9fd19wZGZqc19yZXF1aXJlX18oODQpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4Nik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNCk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwOSk7XG52YXIgcGF0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDIpO1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoLlByb21pc2U7XG5cbi8qKiovIH0pLFxuLyogODMgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oOSk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY2KTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IF9fd19wZGZqc19yZXF1aXJlX18oNzApO1xudmFyIGNyZWF0ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNTgpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUpO1xudmFyIGl0ZXJhdGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDczKTtcbnZhciAkQWdncmVnYXRlRXJyb3IgPSBmdW5jdGlvbiBBZ2dyZWdhdGVFcnJvcihlcnJvcnMsIG1lc3NhZ2UpIHtcbiB2YXIgdGhhdCA9IHRoaXM7XG4gaWYgKCEodGhhdCBpbnN0YW5jZW9mICRBZ2dyZWdhdGVFcnJvcikpXG4gIHJldHVybiBuZXcgJEFnZ3JlZ2F0ZUVycm9yKGVycm9ycywgbWVzc2FnZSk7XG4gaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gIHRoYXQgPSBzZXRQcm90b3R5cGVPZihuZXcgRXJyb3IodW5kZWZpbmVkKSwgZ2V0UHJvdG90eXBlT2YodGhhdCkpO1xuIH1cbiBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKVxuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkodGhhdCwgJ21lc3NhZ2UnLCBTdHJpbmcobWVzc2FnZSkpO1xuIHZhciBlcnJvcnNBcnJheSA9IFtdO1xuIGl0ZXJhdGUoZXJyb3JzLCBlcnJvcnNBcnJheS5wdXNoLCB7IHRoYXQ6IGVycm9yc0FycmF5IH0pO1xuIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSh0aGF0LCAnZXJyb3JzJywgZXJyb3JzQXJyYXkpO1xuIHJldHVybiB0aGF0O1xufTtcbiRBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUgPSBjcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gY29uc3RydWN0b3I6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcig1LCAkQWdncmVnYXRlRXJyb3IpLFxuIG1lc3NhZ2U6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcig1LCAnJyksXG4gbmFtZTogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDUsICdBZ2dyZWdhdGVFcnJvcicpXG59KTtcbiQoeyBnbG9iYWw6IHRydWUgfSwgeyBBZ2dyZWdhdGVFcnJvcjogJEFnZ3JlZ2F0ZUVycm9yIH0pO1xuXG4vKioqLyB9KSxcbi8qIDg0ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gX193X3BkZmpzX3JlcXVpcmVfXyg3OSk7XG52YXIgcmVkZWZpbmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI4KTtcbnZhciB0b1N0cmluZyA9IF9fd19wZGZqc19yZXF1aXJlX18oODUpO1xuaWYgKCFUT19TVFJJTkdfVEFHX1NVUFBPUlQpIHtcbiByZWRlZmluZShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCB0b1N0cmluZywgeyB1bnNhZmU6IHRydWUgfSk7XG59XG5cbi8qKiovIH0pLFxuLyogODUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd19wZGZqc19yZXF1aXJlX18oNzkpO1xudmFyIGNsYXNzb2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc4KTtcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8ge30udG9TdHJpbmcgOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG59O1xuXG4vKioqLyB9KSxcbi8qIDg2ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkpO1xudmFyIElTX1BVUkUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM2KTtcbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBnZXRCdWlsdEluID0gX193X3BkZmpzX3JlcXVpcmVfXyg0MSk7XG52YXIgTmF0aXZlUHJvbWlzZSA9IF9fd19wZGZqc19yZXF1aXJlX18oODcpO1xudmFyIHJlZGVmaW5lID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG52YXIgcmVkZWZpbmVBbGwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDg4KTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd19wZGZqc19yZXF1aXJlX18oNjkpO1xudmFyIHNldFNwZWNpZXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDg5KTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjEpO1xudmFyIGFGdW5jdGlvbiA9IF9fd19wZGZqc19yZXF1aXJlX18oNzYpO1xudmFyIGFuSW5zdGFuY2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkwKTtcbnZhciBpbnNwZWN0U291cmNlID0gX193X3BkZmpzX3JlcXVpcmVfXygzMCk7XG52YXIgaXRlcmF0ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNzMpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IF9fd19wZGZqc19yZXF1aXJlX18oOTEpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IF9fd19wZGZqc19yZXF1aXJlX18oOTIpO1xudmFyIHRhc2sgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkzKS5zZXQ7XG52YXIgbWljcm90YXNrID0gX193X3BkZmpzX3JlcXVpcmVfXyg5Nyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk5KTtcbnZhciBob3N0UmVwb3J0RXJyb3JzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMDEpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMDApO1xudmFyIHBlcmZvcm0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwMik7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzIpO1xudmFyIGlzRm9yY2VkID0gX193X3BkZmpzX3JlcXVpcmVfXyg1MSk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1NSk7XG52YXIgSVNfTk9ERSA9IF9fd19wZGZqc19yZXF1aXJlX18oOTYpO1xudmFyIFY4X1ZFUlNJT04gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwMyk7XG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyIFBST01JU0UgPSAnUHJvbWlzZSc7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFBST01JU0UpO1xudmFyIFByb21pc2VDb25zdHJ1Y3RvciA9IE5hdGl2ZVByb21pc2U7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgJGZldGNoID0gZ2V0QnVpbHRJbignZmV0Y2gnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG52YXIgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHk7XG52YXIgRElTUEFUQ0hfRVZFTlQgPSAhIShkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFdmVudCAmJiBnbG9iYWwuZGlzcGF0Y2hFdmVudCk7XG52YXIgTkFUSVZFX1JFSkVDVElPTl9FVkVOVCA9IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJztcbnZhciBVTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZHJlamVjdGlvbic7XG52YXIgUkVKRUNUSU9OX0hBTkRMRUQgPSAncmVqZWN0aW9uaGFuZGxlZCc7XG52YXIgUEVORElORyA9IDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG52YXIgSEFORExFRCA9IDE7XG52YXIgVU5IQU5ETEVEID0gMjtcbnZhciBJbnRlcm5hbCwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFByb21pc2VXcmFwcGVyLCBuYXRpdmVUaGVuO1xudmFyIEZPUkNFRCA9IGlzRm9yY2VkKFBST01JU0UsIGZ1bmN0aW9uICgpIHtcbiB2YXIgR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSA9IGluc3BlY3RTb3VyY2UoUHJvbWlzZUNvbnN0cnVjdG9yKSAhPT0gU3RyaW5nKFByb21pc2VDb25zdHJ1Y3Rvcik7XG4gaWYgKCFHTE9CQUxfQ09SRV9KU19QUk9NSVNFKSB7XG4gIGlmIChWOF9WRVJTSU9OID09PSA2NilcbiAgIHJldHVybiB0cnVlO1xuICBpZiAoIUlTX05PREUgJiYgIU5BVElWRV9SRUpFQ1RJT05fRVZFTlQpXG4gICByZXR1cm4gdHJ1ZTtcbiB9XG4gaWYgKElTX1BVUkUgJiYgIVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGVbJ2ZpbmFsbHknXSlcbiAgcmV0dXJuIHRydWU7XG4gaWYgKFY4X1ZFUlNJT04gPj0gNTEgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFByb21pc2VDb25zdHJ1Y3RvcikpXG4gIHJldHVybiBmYWxzZTtcbiB2YXIgcHJvbWlzZSA9IFByb21pc2VDb25zdHJ1Y3Rvci5yZXNvbHZlKDEpO1xuIHZhciBGYWtlUHJvbWlzZSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIGV4ZWMoZnVuY3Rpb24gKCkge1xuICB9LCBmdW5jdGlvbiAoKSB7XG4gIH0pO1xuIH07XG4gdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9O1xuIGNvbnN0cnVjdG9yW1NQRUNJRVNdID0gRmFrZVByb21pc2U7XG4gcmV0dXJuICEocHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiB9KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlKTtcbn0pO1xudmFyIElOQ09SUkVDVF9JVEVSQVRJT04gPSBGT1JDRUQgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiBQcm9taXNlQ29uc3RydWN0b3IuYWxsKGl0ZXJhYmxlKVsnY2F0Y2gnXShmdW5jdGlvbiAoKSB7XG4gfSk7XG59KTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gdmFyIHRoZW47XG4gcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbiAoc3RhdGUsIGlzUmVqZWN0KSB7XG4gaWYgKHN0YXRlLm5vdGlmaWVkKVxuICByZXR1cm47XG4gc3RhdGUubm90aWZpZWQgPSB0cnVlO1xuIHZhciBjaGFpbiA9IHN0YXRlLnJlYWN0aW9ucztcbiBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgdmFyIG9rID0gc3RhdGUuc3RhdGUgPT0gRlVMRklMTEVEO1xuICB2YXIgaW5kZXggPSAwO1xuICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaW5kZXgpIHtcbiAgIHZhciByZWFjdGlvbiA9IGNoYWluW2luZGV4KytdO1xuICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICAgdHJ5IHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICBpZiAoIW9rKSB7XG4gICAgICBpZiAoc3RhdGUucmVqZWN0aW9uID09PSBVTkhBTkRMRUQpXG4gICAgICAgb25IYW5kbGVVbmhhbmRsZWQoc3RhdGUpO1xuICAgICAgc3RhdGUucmVqZWN0aW9uID0gSEFORExFRDtcbiAgICAgfVxuICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSlcbiAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICBlbHNlIHtcbiAgICAgIGlmIChkb21haW4pXG4gICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgIGV4aXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgIH1cbiAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICB9IGVsc2VcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2VcbiAgICAgcmVqZWN0KHZhbHVlKTtcbiAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGRvbWFpbiAmJiAhZXhpdGVkKVxuICAgICBkb21haW4uZXhpdCgpO1xuICAgIHJlamVjdChlcnJvcik7XG4gICB9XG4gIH1cbiAgc3RhdGUucmVhY3Rpb25zID0gW107XG4gIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gIGlmIChpc1JlamVjdCAmJiAhc3RhdGUucmVqZWN0aW9uKVxuICAgb25VbmhhbmRsZWQoc3RhdGUpO1xuIH0pO1xufTtcbnZhciBkaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIHByb21pc2UsIHJlYXNvbikge1xuIHZhciBldmVudCwgaGFuZGxlcjtcbiBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgZXZlbnQucHJvbWlzZSA9IHByb21pc2U7XG4gIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgZXZlbnQuaW5pdEV2ZW50KG5hbWUsIGZhbHNlLCB0cnVlKTtcbiAgZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuIH0gZWxzZVxuICBldmVudCA9IHtcbiAgIHByb21pc2U6IHByb21pc2UsXG4gICByZWFzb246IHJlYXNvblxuICB9O1xuIGlmICghTkFUSVZFX1JFSkVDVElPTl9FVkVOVCAmJiAoaGFuZGxlciA9IGdsb2JhbFsnb24nICsgbmFtZV0pKVxuICBoYW5kbGVyKGV2ZW50KTtcbiBlbHNlIGlmIChuYW1lID09PSBVTkhBTkRMRURfUkVKRUNUSU9OKVxuICBob3N0UmVwb3J0RXJyb3JzKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCByZWFzb24pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoSVNfVU5IQU5ETEVEKSB7XG4gICByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoSVNfTk9ERSkge1xuICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICB9IGVsc2VcbiAgICAgZGlzcGF0Y2hFdmVudChVTkhBTkRMRURfUkVKRUNUSU9OLCBwcm9taXNlLCB2YWx1ZSk7XG4gICB9KTtcbiAgIHN0YXRlLnJlamVjdGlvbiA9IElTX05PREUgfHwgaXNVbmhhbmRsZWQoc3RhdGUpID8gVU5IQU5ETEVEIDogSEFORExFRDtcbiAgIGlmIChyZXN1bHQuZXJyb3IpXG4gICAgdGhyb3cgcmVzdWx0LnZhbHVlO1xuICB9XG4gfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gcmV0dXJuIHN0YXRlLnJlamVjdGlvbiAhPT0gSEFORExFRCAmJiAhc3RhdGUucGFyZW50O1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gIGlmIChJU19OT0RFKSB7XG4gICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgfSBlbHNlXG4gICBkaXNwYXRjaEV2ZW50KFJFSkVDVElPTl9IQU5ETEVELCBwcm9taXNlLCBzdGF0ZS52YWx1ZSk7XG4gfSk7XG59O1xudmFyIGJpbmQgPSBmdW5jdGlvbiAoZm4sIHN0YXRlLCB1bndyYXApIHtcbiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGZuKHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiB9O1xufTtcbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuIGlmIChzdGF0ZS5kb25lKVxuICByZXR1cm47XG4gc3RhdGUuZG9uZSA9IHRydWU7XG4gaWYgKHVud3JhcClcbiAgc3RhdGUgPSB1bndyYXA7XG4gc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiBzdGF0ZS5zdGF0ZSA9IFJFSkVDVEVEO1xuIG5vdGlmeShzdGF0ZSwgdHJ1ZSk7XG59O1xudmFyIGludGVybmFsUmVzb2x2ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuIGlmIChzdGF0ZS5kb25lKVxuICByZXR1cm47XG4gc3RhdGUuZG9uZSA9IHRydWU7XG4gaWYgKHVud3JhcClcbiAgc3RhdGUgPSB1bndyYXA7XG4gdHJ5IHtcbiAgaWYgKHN0YXRlLmZhY2FkZSA9PT0gdmFsdWUpXG4gICB0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgdmFyIHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKTtcbiAgaWYgKHRoZW4pIHtcbiAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdyYXBwZXIgPSB7IGRvbmU6IGZhbHNlIH07XG4gICAgdHJ5IHtcbiAgICAgdGhlbi5jYWxsKHZhbHVlLCBiaW5kKGludGVybmFsUmVzb2x2ZSwgd3JhcHBlciwgc3RhdGUpLCBiaW5kKGludGVybmFsUmVqZWN0LCB3cmFwcGVyLCBzdGF0ZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgIGludGVybmFsUmVqZWN0KHdyYXBwZXIsIGVycm9yLCBzdGF0ZSk7XG4gICAgfVxuICAgfSk7XG4gIH0gZWxzZSB7XG4gICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICAgc3RhdGUuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICBub3RpZnkoc3RhdGUsIGZhbHNlKTtcbiAgfVxuIH0gY2F0Y2ggKGVycm9yKSB7XG4gIGludGVybmFsUmVqZWN0KHsgZG9uZTogZmFsc2UgfSwgZXJyb3IsIHN0YXRlKTtcbiB9XG59O1xuaWYgKEZPUkNFRCkge1xuIFByb21pc2VDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgYW5JbnN0YW5jZSh0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UpO1xuICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICB0cnkge1xuICAgZXhlY3V0b3IoYmluZChpbnRlcm5hbFJlc29sdmUsIHN0YXRlKSwgYmluZChpbnRlcm5hbFJlamVjdCwgc3RhdGUpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgIGludGVybmFsUmVqZWN0KHN0YXRlLCBlcnJvcik7XG4gIH1cbiB9O1xuIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgIHR5cGU6IFBST01JU0UsXG4gICBkb25lOiBmYWxzZSxcbiAgIG5vdGlmaWVkOiBmYWxzZSxcbiAgIHBhcmVudDogZmFsc2UsXG4gICByZWFjdGlvbnM6IFtdLFxuICAgcmVqZWN0aW9uOiBmYWxzZSxcbiAgIHN0YXRlOiBQRU5ESU5HLFxuICAgdmFsdWU6IHVuZGVmaW5lZFxuICB9KTtcbiB9O1xuIEludGVybmFsLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKFByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUodGhpcyk7XG4gICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgUHJvbWlzZUNvbnN0cnVjdG9yKSk7XG4gICByZWFjdGlvbi5vayA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgcmVhY3Rpb24uZmFpbCA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgIHJlYWN0aW9uLmRvbWFpbiA9IElTX05PREUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgIHN0YXRlLnBhcmVudCA9IHRydWU7XG4gICBzdGF0ZS5yZWFjdGlvbnMucHVzaChyZWFjdGlvbik7XG4gICBpZiAoc3RhdGUuc3RhdGUgIT0gUEVORElORylcbiAgICBub3RpZnkoc3RhdGUsIGZhbHNlKTtcbiAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICB9LFxuICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICB9XG4gfSk7XG4gT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUocHJvbWlzZSk7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIHRoaXMucmVzb2x2ZSA9IGJpbmQoaW50ZXJuYWxSZXNvbHZlLCBzdGF0ZSk7XG4gIHRoaXMucmVqZWN0ID0gYmluZChpbnRlcm5hbFJlamVjdCwgc3RhdGUpO1xuIH07XG4gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIEMgPT09IFByb21pc2VDb25zdHJ1Y3RvciB8fCBDID09PSBQcm9taXNlV3JhcHBlciA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKSA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiB9O1xuIGlmICghSVNfUFVSRSAmJiB0eXBlb2YgTmF0aXZlUHJvbWlzZSA9PSAnZnVuY3Rpb24nKSB7XG4gIG5hdGl2ZVRoZW4gPSBOYXRpdmVQcm9taXNlLnByb3RvdHlwZS50aGVuO1xuICByZWRlZmluZShOYXRpdmVQcm9taXNlLnByb3RvdHlwZSwgJ3RoZW4nLCBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICB2YXIgdGhhdCA9IHRoaXM7XG4gICByZXR1cm4gbmV3IFByb21pc2VDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbmF0aXZlVGhlbi5jYWxsKHRoYXQsIHJlc29sdmUsIHJlamVjdCk7XG4gICB9KS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgfSwgeyB1bnNhZmU6IHRydWUgfSk7XG4gIGlmICh0eXBlb2YgJGZldGNoID09ICdmdW5jdGlvbicpXG4gICAkKHtcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBmb3JjZWQ6IHRydWVcbiAgIH0sIHtcbiAgICBmZXRjaDogZnVuY3Rpb24gZmV0Y2goaW5wdXQpIHtcbiAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKFByb21pc2VDb25zdHJ1Y3RvciwgJGZldGNoLmFwcGx5KGdsb2JhbCwgYXJndW1lbnRzKSk7XG4gICAgfVxuICAgfSk7XG4gfVxufVxuJCh7XG4gZ2xvYmFsOiB0cnVlLFxuIHdyYXA6IHRydWUsXG4gZm9yY2VkOiBGT1JDRURcbn0sIHsgUHJvbWlzZTogUHJvbWlzZUNvbnN0cnVjdG9yIH0pO1xuc2V0VG9TdHJpbmdUYWcoUHJvbWlzZUNvbnN0cnVjdG9yLCBQUk9NSVNFLCBmYWxzZSwgdHJ1ZSk7XG5zZXRTcGVjaWVzKFBST01JU0UpO1xuUHJvbWlzZVdyYXBwZXIgPSBnZXRCdWlsdEluKFBST01JU0UpO1xuJCh7XG4gdGFyZ2V0OiBQUk9NSVNFLFxuIHN0YXQ6IHRydWUsXG4gZm9yY2VkOiBGT1JDRURcbn0sIHtcbiByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gIGNhcGFiaWxpdHkucmVqZWN0LmNhbGwodW5kZWZpbmVkLCByKTtcbiAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiB9XG59KTtcbiQoe1xuIHRhcmdldDogUFJPTUlTRSxcbiBzdGF0OiB0cnVlLFxuIGZvcmNlZDogSVNfUFVSRSB8fCBGT1JDRURcbn0sIHtcbiByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgcmV0dXJuIHByb21pc2VSZXNvbHZlKElTX1BVUkUgJiYgdGhpcyA9PT0gUHJvbWlzZVdyYXBwZXIgPyBQcm9taXNlQ29uc3RydWN0b3IgOiB0aGlzLCB4KTtcbiB9XG59KTtcbiQoe1xuIHRhcmdldDogUFJPTUlTRSxcbiBzdGF0OiB0cnVlLFxuIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTlxufSwge1xuIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gIHZhciBDID0gdGhpcztcbiAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFGdW5jdGlvbihDLnJlc29sdmUpO1xuICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICBpdGVyYXRlKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgcmVtYWluaW5nKys7XG4gICAgJHByb21pc2VSZXNvbHZlLmNhbGwoQywgcHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgaWYgKGFscmVhZHlDYWxsZWQpXG4gICAgICByZXR1cm47XG4gICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9LCByZWplY3QpO1xuICAgfSk7XG4gICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gIH0pO1xuICBpZiAocmVzdWx0LmVycm9yKVxuICAgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gfSxcbiByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gIHZhciBDID0gdGhpcztcbiAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUZ1bmN0aW9uKEMucmVzb2x2ZSk7XG4gICBpdGVyYXRlKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICRwcm9taXNlUmVzb2x2ZS5jYWxsKEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgfSk7XG4gIH0pO1xuICBpZiAocmVzdWx0LmVycm9yKVxuICAgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gfVxufSk7XG5cbi8qKiovIH0pLFxuLyogODcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5Qcm9taXNlO1xuXG4vKioqLyB9KSxcbi8qIDg4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIHJlZGVmaW5lID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuIGZvciAodmFyIGtleSBpbiBzcmMpXG4gIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKiovIH0pLFxuLyogODkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGdldEJ1aWx0SW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQxKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjYpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTUpO1xudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXygxMik7XG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4oQ09OU1RSVUNUT1JfTkFNRSk7XG4gdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiBpZiAoREVTQ1JJUFRPUlMgJiYgQ29uc3RydWN0b3IgJiYgIUNvbnN0cnVjdG9yW1NQRUNJRVNdKSB7XG4gIGRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBTUEVDSUVTLCB7XG4gICBjb25maWd1cmFibGU6IHRydWUsXG4gICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgIH1cbiAgfSk7XG4gfVxufTtcblxuLyoqKi8gfSksXG4vKiA5MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUpIHtcbiBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCAnICsgKG5hbWUgPyBuYW1lICsgJyAnIDogJycpICsgJ2ludm9jYXRpb24nKTtcbiB9XG4gcmV0dXJuIGl0O1xufTtcblxuLyoqKi8gfSksXG4vKiA5MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU1KTtcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcbnRyeSB7XG4gdmFyIGNhbGxlZCA9IDA7XG4gdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICB9LFxuICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgfVxuIH07XG4gaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG4gfTtcbiBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkge1xuICB0aHJvdyAyO1xuIH0pO1xufSBjYXRjaCAoZXJyb3IpIHtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpXG4gIHJldHVybiBmYWxzZTtcbiB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcbiB0cnkge1xuICB2YXIgb2JqZWN0ID0ge307XG4gIG9iamVjdFtJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgfVxuICAgfTtcbiAgfTtcbiAgZXhlYyhvYmplY3QpO1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gfVxuIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG5cbi8qKiovIH0pLFxuLyogOTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI3KTtcbnZhciBhRnVuY3Rpb24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc2KTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU1KTtcbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuIHZhciBTO1xuIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuLyoqKi8gfSksXG4vKiA5MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBmYWlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMpO1xudmFyIGJpbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc1KTtcbnZhciBodG1sID0gX193X3BkZmpzX3JlcXVpcmVfXyg2MSk7XG52YXIgY3JlYXRlRWxlbWVudCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjQpO1xudmFyIElTX0lPUyA9IF9fd19wZGZqc19yZXF1aXJlX18oOTQpO1xudmFyIElTX05PREUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk2KTtcbnZhciBsb2NhdGlvbiA9IGdsb2JhbC5sb2NhdGlvbjtcbnZhciBzZXQgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgdmFyIGZuID0gcXVldWVbaWRdO1xuICBkZWxldGUgcXVldWVbaWRdO1xuICBmbigpO1xuIH1cbn07XG52YXIgcnVubmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgcnVuKGlkKTtcbiB9O1xufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuIHJ1bihldmVudC5kYXRhKTtcbn07XG52YXIgcG9zdCA9IGZ1bmN0aW9uIChpZCkge1xuIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0KTtcbn07XG5pZiAoIXNldCB8fCAhY2xlYXIpIHtcbiBzZXQgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgdmFyIGkgPSAxO1xuICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpXG4gICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbikpLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gIH07XG4gIGRlZmVyKGNvdW50ZXIpO1xuICByZXR1cm4gY291bnRlcjtcbiB9O1xuIGNsZWFyID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgZGVsZXRlIHF1ZXVlW2lkXTtcbiB9O1xuIGlmIChJU19OT0RFKSB7XG4gIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICBwcm9jZXNzLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuICB9O1xuIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICBEaXNwYXRjaC5ub3cocnVubmVyKGlkKSk7XG4gIH07XG4gfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCAmJiAhSVNfSU9TKSB7XG4gIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gIGRlZmVyID0gYmluZChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyAmJiBsb2NhdGlvbiAmJiBsb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJiAhZmFpbHMocG9zdCkpIHtcbiAgZGVmZXIgPSBwb3N0O1xuICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgIGh0bWwuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICBydW4oaWQpO1xuICAgfTtcbiAgfTtcbiB9IGVsc2Uge1xuICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgc2V0VGltZW91dChydW5uZXIoaWQpLCAwKTtcbiAgfTtcbiB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiBzZXQ6IHNldCxcbiBjbGVhcjogY2xlYXJcbn07XG5cbi8qKiovIH0pLFxuLyogOTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgdXNlckFnZW50ID0gX193X3BkZmpzX3JlcXVpcmVfXyg5NSk7XG5tb2R1bGUuZXhwb3J0cyA9IC8oaXBob25lfGlwb2R8aXBhZCkuKmFwcGxld2Via2l0L2kudGVzdCh1c2VyQWdlbnQpO1xuXG4vKioqLyB9KSxcbi8qIDk1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGdldEJ1aWx0SW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQxKTtcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG4vKioqLyB9KSxcbi8qIDk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGNsYXNzb2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE4KTtcbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbm1vZHVsZS5leHBvcnRzID0gY2xhc3NvZihnbG9iYWwucHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG4vKioqLyB9KSxcbi8qIDk3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpLmY7XG52YXIgbWFjcm90YXNrID0gX193X3BkZmpzX3JlcXVpcmVfXyg5Mykuc2V0O1xudmFyIElTX0lPUyA9IF9fd19wZGZqc19yZXF1aXJlX18oOTQpO1xudmFyIElTX1dFQk9TX1dFQktJVCA9IF9fd19wZGZqc19yZXF1aXJlX18oOTgpO1xudmFyIElTX05PREUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk2KTtcbnZhciBNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsLCAncXVldWVNaWNyb3Rhc2snKTtcbnZhciBxdWV1ZU1pY3JvdGFzayA9IHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciAmJiBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IudmFsdWU7XG52YXIgZmx1c2gsIGhlYWQsIGxhc3QsIG5vdGlmeSwgdG9nZ2xlLCBub2RlLCBwcm9taXNlLCB0aGVuO1xuaWYgKCFxdWV1ZU1pY3JvdGFzaykge1xuIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyZW50LCBmbjtcbiAgaWYgKElTX05PREUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSlcbiAgIHBhcmVudC5leGl0KCk7XG4gIHdoaWxlIChoZWFkKSB7XG4gICBmbiA9IGhlYWQuZm47XG4gICBoZWFkID0gaGVhZC5uZXh0O1xuICAgdHJ5IHtcbiAgICBmbigpO1xuICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaGVhZClcbiAgICAgbm90aWZ5KCk7XG4gICAgZWxzZVxuICAgICBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIHRocm93IGVycm9yO1xuICAgfVxuICB9XG4gIGxhc3QgPSB1bmRlZmluZWQ7XG4gIGlmIChwYXJlbnQpXG4gICBwYXJlbnQuZW50ZXIoKTtcbiB9O1xuIGlmICghSVNfSU9TICYmICFJU19OT0RFICYmICFJU19XRUJPU19XRUJLSVQgJiYgTXV0YXRpb25PYnNlcnZlciAmJiBkb2N1bWVudCkge1xuICB0b2dnbGUgPSB0cnVlO1xuICBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gIH07XG4gfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHRoZW4gPSBwcm9taXNlLnRoZW47XG4gIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgIHRoZW4uY2FsbChwcm9taXNlLCBmbHVzaCk7XG4gIH07XG4gfSBlbHNlIGlmIChJU19OT0RFKSB7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xuIH0gZWxzZSB7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICB9O1xuIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gcXVldWVNaWNyb3Rhc2sgfHwgZnVuY3Rpb24gKGZuKSB7XG4gdmFyIHRhc2sgPSB7XG4gIGZuOiBmbixcbiAgbmV4dDogdW5kZWZpbmVkXG4gfTtcbiBpZiAobGFzdClcbiAgbGFzdC5uZXh0ID0gdGFzaztcbiBpZiAoIWhlYWQpIHtcbiAgaGVhZCA9IHRhc2s7XG4gIG5vdGlmeSgpO1xuIH1cbiBsYXN0ID0gdGFzaztcbn07XG5cbi8qKiovIH0pLFxuLyogOTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgdXNlckFnZW50ID0gX193X3BkZmpzX3JlcXVpcmVfXyg5NSk7XG5tb2R1bGUuZXhwb3J0cyA9IC93ZWIwcyg/IS4qY2hyb21lKS9pLnRlc3QodXNlckFnZW50KTtcblxuLyoqKi8gfSksXG4vKiA5OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjcpO1xudmFyIGlzT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMSk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwMCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gYW5PYmplY3QoQyk7XG4gaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpXG4gIHJldHVybiB4O1xuIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuIHJlc29sdmUoeCk7XG4gcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG4vKioqLyB9KSxcbi8qIDEwMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYUZ1bmN0aW9uID0gX193X3BkZmpzX3JlcXVpcmVfXyg3Nik7XG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuIHZhciByZXNvbHZlLCByZWplY3Q7XG4gdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZClcbiAgIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gfSk7XG4gdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59O1xubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYSwgYikge1xuIHZhciBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGU7XG4gaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gY29uc29sZS5lcnJvcihhKSA6IGNvbnNvbGUuZXJyb3IoYSwgYik7XG4gfVxufTtcblxuLyoqKi8gfSksXG4vKiAxMDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuIHRyeSB7XG4gIHJldHVybiB7XG4gICBlcnJvcjogZmFsc2UsXG4gICB2YWx1ZTogZXhlYygpXG4gIH07XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgIGVycm9yOiB0cnVlLFxuICAgdmFsdWU6IGVycm9yXG4gIH07XG4gfVxufTtcblxuLyoqKi8gfSksXG4vKiAxMDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgdXNlckFnZW50ID0gX193X3BkZmpzX3JlcXVpcmVfXyg5NSk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5pZiAodjgpIHtcbiBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gdmVyc2lvbiA9IG1hdGNoWzBdICsgbWF0Y2hbMV07XG59IGVsc2UgaWYgKHVzZXJBZ2VudCkge1xuIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gIGlmIChtYXRjaClcbiAgIHZlcnNpb24gPSBtYXRjaFsxXTtcbiB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb24gJiYgK3ZlcnNpb247XG5cbi8qKiovIH0pLFxuLyogMTA0ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkpO1xudmFyIGFGdW5jdGlvbiA9IF9fd19wZGZqc19yZXF1aXJlX18oNzYpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMDApO1xudmFyIHBlcmZvcm0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwMik7XG52YXIgaXRlcmF0ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNzMpO1xuJCh7XG4gdGFyZ2V0OiAnUHJvbWlzZScsXG4gc3RhdDogdHJ1ZVxufSwge1xuIGFsbFNldHRsZWQ6IGZ1bmN0aW9uIGFsbFNldHRsZWQoaXRlcmFibGUpIHtcbiAgdmFyIEMgPSB0aGlzO1xuICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmYoQyk7XG4gIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgIHZhciBwcm9taXNlUmVzb2x2ZSA9IGFGdW5jdGlvbihDLnJlc29sdmUpO1xuICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICBpdGVyYXRlKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgcmVtYWluaW5nKys7XG4gICAgcHJvbWlzZVJlc29sdmUuY2FsbChDLCBwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICBpZiAoYWxyZWFkeUNhbGxlZClcbiAgICAgIHJldHVybjtcbiAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgIHZhbHVlc1tpbmRleF0gPSB7XG4gICAgICBzdGF0dXM6ICdmdWxmaWxsZWQnLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgIH07XG4gICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgaWYgKGFscmVhZHlDYWxsZWQpXG4gICAgICByZXR1cm47XG4gICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICB2YWx1ZXNbaW5kZXhdID0ge1xuICAgICAgc3RhdHVzOiAncmVqZWN0ZWQnLFxuICAgICAgcmVhc29uOiBlcnJvclxuICAgICB9O1xuICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICB9KTtcbiAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgfSk7XG4gIGlmIChyZXN1bHQuZXJyb3IpXG4gICByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oOSk7XG52YXIgYUZ1bmN0aW9uID0gX193X3BkZmpzX3JlcXVpcmVfXyg3Nik7XG52YXIgZ2V0QnVpbHRJbiA9IF9fd19wZGZqc19yZXF1aXJlX18oNDEpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMDApO1xudmFyIHBlcmZvcm0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwMik7XG52YXIgaXRlcmF0ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNzMpO1xudmFyIFBST01JU0VfQU5ZX0VSUk9SID0gJ05vIG9uZSBwcm9taXNlIHJlc29sdmVkJztcbiQoe1xuIHRhcmdldDogJ1Byb21pc2UnLFxuIHN0YXQ6IHRydWVcbn0sIHtcbiBhbnk6IGZ1bmN0aW9uIGFueShpdGVyYWJsZSkge1xuICB2YXIgQyA9IHRoaXM7XG4gIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgdmFyIHByb21pc2VSZXNvbHZlID0gYUZ1bmN0aW9uKEMucmVzb2x2ZSk7XG4gICB2YXIgZXJyb3JzID0gW107XG4gICB2YXIgY291bnRlciA9IDA7XG4gICB2YXIgcmVtYWluaW5nID0gMTtcbiAgIHZhciBhbHJlYWR5UmVzb2x2ZWQgPSBmYWxzZTtcbiAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgIHZhciBhbHJlYWR5UmVqZWN0ZWQgPSBmYWxzZTtcbiAgICBlcnJvcnMucHVzaCh1bmRlZmluZWQpO1xuICAgIHJlbWFpbmluZysrO1xuICAgIHByb21pc2VSZXNvbHZlLmNhbGwoQywgcHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgaWYgKGFscmVhZHlSZWplY3RlZCB8fCBhbHJlYWR5UmVzb2x2ZWQpXG4gICAgICByZXR1cm47XG4gICAgIGFscmVhZHlSZXNvbHZlZCA9IHRydWU7XG4gICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICBpZiAoYWxyZWFkeVJlamVjdGVkIHx8IGFscmVhZHlSZXNvbHZlZClcbiAgICAgIHJldHVybjtcbiAgICAgYWxyZWFkeVJlamVjdGVkID0gdHJ1ZTtcbiAgICAgZXJyb3JzW2luZGV4XSA9IGVycm9yO1xuICAgICAtLXJlbWFpbmluZyB8fCByZWplY3QobmV3IChnZXRCdWlsdEluKCdBZ2dyZWdhdGVFcnJvcicpKShlcnJvcnMsIFBST01JU0VfQU5ZX0VSUk9SKSk7XG4gICAgfSk7XG4gICB9KTtcbiAgIC0tcmVtYWluaW5nIHx8IHJlamVjdChuZXcgKGdldEJ1aWx0SW4oJ0FnZ3JlZ2F0ZUVycm9yJykpKGVycm9ycywgUFJPTUlTRV9BTllfRVJST1IpKTtcbiAgfSk7XG4gIGlmIChyZXN1bHQuZXJyb3IpXG4gICByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDYgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oOSk7XG52YXIgSVNfUFVSRSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzYpO1xudmFyIE5hdGl2ZVByb21pc2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDg3KTtcbnZhciBmYWlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMpO1xudmFyIGdldEJ1aWx0SW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQxKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkyKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oOTkpO1xudmFyIHJlZGVmaW5lID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG52YXIgTk9OX0dFTkVSSUMgPSAhIU5hdGl2ZVByb21pc2UgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuIE5hdGl2ZVByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10uY2FsbCh7XG4gIHRoZW46IGZ1bmN0aW9uICgpIHtcbiAgfVxuIH0sIGZ1bmN0aW9uICgpIHtcbiB9KTtcbn0pO1xuJCh7XG4gdGFyZ2V0OiAnUHJvbWlzZScsXG4gcHJvdG86IHRydWUsXG4gcmVhbDogdHJ1ZSxcbiBmb3JjZWQ6IE5PTl9HRU5FUklDXG59LCB7XG4gJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGdldEJ1aWx0SW4oJ1Byb21pc2UnKSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geDtcbiAgIH0pO1xuICB9IDogb25GaW5hbGx5LCBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKGUpIHtcbiAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgZTtcbiAgIH0pO1xuICB9IDogb25GaW5hbGx5KTtcbiB9XG59KTtcbmlmICghSVNfUFVSRSAmJiB0eXBlb2YgTmF0aXZlUHJvbWlzZSA9PSAnZnVuY3Rpb24nICYmICFOYXRpdmVQcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddKSB7XG4gcmVkZWZpbmUoTmF0aXZlUHJvbWlzZS5wcm90b3R5cGUsICdmaW5hbGx5JywgZ2V0QnVpbHRJbignUHJvbWlzZScpLnByb3RvdHlwZVsnZmluYWxseSddKTtcbn1cblxuLyoqKi8gfSksXG4vKiAxMDcgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2hhckF0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMDgpLmNoYXJBdDtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygzMik7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYzKTtcbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICBzdHJpbmc6IFN0cmluZyhpdGVyYXRlZCksXG4gIGluZGV4OiAwXG4gfSk7XG59LCBmdW5jdGlvbiBuZXh0KCkge1xuIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleDtcbiB2YXIgcG9pbnQ7XG4gaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpXG4gIHJldHVybiB7XG4gICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgZG9uZTogdHJ1ZVxuICB9O1xuIHBvaW50ID0gY2hhckF0KHN0cmluZywgaW5kZXgpO1xuIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiByZXR1cm4ge1xuICB2YWx1ZTogcG9pbnQsXG4gIGRvbmU6IGZhbHNlXG4gfTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEwOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0ludGVnZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ3KTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxOSk7XG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgcG9zKSB7XG4gIHZhciBTID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG4gIHZhciBzaXplID0gUy5sZW5ndGg7XG4gIHZhciBmaXJzdCwgc2Vjb25kO1xuICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpXG4gICByZXR1cm4gQ09OVkVSVF9UT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgZmlyc3QgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplIHx8IChzZWNvbmQgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGID8gQ09OVkVSVF9UT19TVFJJTkcgPyBTLmNoYXJBdChwb3NpdGlvbikgOiBmaXJzdCA6IENPTlZFUlRfVE9fU1RSSU5HID8gUy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyAyKSA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gfTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gY2hhckF0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG5cbi8qKiovIH0pLFxuLyogMTA5ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgRE9NSXRlcmFibGVzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTApO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Myk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNSk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1NSk7XG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEFycmF5SXRlcmF0b3JNZXRob2RzLnZhbHVlcztcbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdO1xuIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gIT09IEFycmF5VmFsdWVzKVxuICAgdHJ5IHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gPSBBcnJheVZhbHVlcztcbiAgIH1cbiAgaWYgKCFDb2xsZWN0aW9uUHJvdG90eXBlW1RPX1NUUklOR19UQUddKSB7XG4gICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgQ09MTEVDVElPTl9OQU1FKTtcbiAgfVxuICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pXG4gICBmb3IgKHZhciBNRVRIT0RfTkFNRSBpbiBBcnJheUl0ZXJhdG9yTWV0aG9kcykge1xuICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKVxuICAgICB0cnkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIE1FVEhPRF9OQU1FLCBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pO1xuICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gPSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV07XG4gICAgIH1cbiAgIH1cbiB9XG59XG5cbi8qKiovIH0pLFxuLyogMTEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuIENTU1J1bGVMaXN0OiAwLFxuIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gQ1NTVmFsdWVMaXN0OiAwLFxuIENsaWVudFJlY3RMaXN0OiAwLFxuIERPTVJlY3RMaXN0OiAwLFxuIERPTVN0cmluZ0xpc3Q6IDAsXG4gRE9NVG9rZW5MaXN0OiAxLFxuIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuIEZpbGVMaXN0OiAwLFxuIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuIEhUTUxDb2xsZWN0aW9uOiAwLFxuIEhUTUxGb3JtRWxlbWVudDogMCxcbiBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiBNZWRpYUxpc3Q6IDAsXG4gTWltZVR5cGVBcnJheTogMCxcbiBOYW1lZE5vZGVNYXA6IDAsXG4gTm9kZUxpc3Q6IDEsXG4gUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiBQbHVnaW46IDAsXG4gUGx1Z2luQXJyYXk6IDAsXG4gU1ZHTGVuZ3RoTGlzdDogMCxcbiBTVkdOdW1iZXJMaXN0OiAwLFxuIFNWR1BhdGhTZWdMaXN0OiAwLFxuIFNWR1BvaW50TGlzdDogMCxcbiBTVkdTdHJpbmdMaXN0OiAwLFxuIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gU291cmNlQnVmZmVyTGlzdDogMCxcbiBTdHlsZVNoZWV0TGlzdDogMCxcbiBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuIFRleHRUcmFja0xpc3Q6IDAsXG4gVG91Y2hMaXN0OiAwXG59O1xuXG4vKioqLyB9KSxcbi8qIDExMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMTEyKTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTIwKTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTE4KTtcbnZhciBwYXRoID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Mik7XG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguVVJMO1xuXG4vKioqLyB9KSxcbi8qIDExMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMTA3KTtcbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXyg5KTtcbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTIpO1xudmFyIFVTRV9OQVRJVkVfVVJMID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTMpO1xudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU5KTtcbnZhciByZWRlZmluZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjgpO1xudmFyIGFuSW5zdGFuY2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkwKTtcbnZhciBoYXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyKTtcbnZhciBhc3NpZ24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDExNCk7XG52YXIgYXJyYXlGcm9tID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTUpO1xudmFyIGNvZGVBdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTA4KS5jb2RlQXQ7XG52YXIgdG9BU0NJSSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTE3KTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd19wZGZqc19yZXF1aXJlX18oNjkpO1xudmFyIFVSTFNlYXJjaFBhcmFtc01vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTE4KTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygzMik7XG52YXIgTmF0aXZlVVJMID0gZ2xvYmFsLlVSTDtcbnZhciBVUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuVVJMU2VhcmNoUGFyYW1zO1xudmFyIGdldEludGVybmFsU2VhcmNoUGFyYW1zU3RhdGUgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuZ2V0U3RhdGU7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsVVJMU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcignVVJMJyk7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIElOVkFMSURfQVVUSE9SSVRZID0gJ0ludmFsaWQgYXV0aG9yaXR5JztcbnZhciBJTlZBTElEX1NDSEVNRSA9ICdJbnZhbGlkIHNjaGVtZSc7XG52YXIgSU5WQUxJRF9IT1NUID0gJ0ludmFsaWQgaG9zdCc7XG52YXIgSU5WQUxJRF9QT1JUID0gJ0ludmFsaWQgcG9ydCc7XG52YXIgQUxQSEEgPSAvW0EtWmEtel0vO1xudmFyIEFMUEhBTlVNRVJJQyA9IC9bXFxkKy0uQS1aYS16XS87XG52YXIgRElHSVQgPSAvXFxkLztcbnZhciBIRVhfU1RBUlQgPSAvXigweHwwWCkvO1xudmFyIE9DVCA9IC9eWzAtN10rJC87XG52YXIgREVDID0gL15cXGQrJC87XG52YXIgSEVYID0gL15bXFxkQS1GYS1mXSskLztcbnZhciBGT1JCSURERU5fSE9TVF9DT0RFX1BPSU5UID0gL1tcXHUwMDAwXFx1MDAwOVxcdTAwMEFcXHUwMDBEICMlLzo/QFtcXFxcXV0vO1xudmFyIEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlRfRVhDTFVESU5HX1BFUkNFTlQgPSAvW1xcdTAwMDBcXHUwMDA5XFx1MDAwQVxcdTAwMEQgIy86P0BbXFxcXF1dLztcbnZhciBMRUFESU5HX0FORF9UUkFJTElOR19DMF9DT05UUk9MX09SX1NQQUNFID0gL15bXFx1MDAwMC1cXHUwMDFGIF0rfFtcXHUwMDAwLVxcdTAwMUYgXSskL2c7XG52YXIgVEFCX0FORF9ORVdfTElORSA9IC9bXFx1MDAwOVxcdTAwMEFcXHUwMDBEXS9nO1xudmFyIEVPRjtcbnZhciBwYXJzZUhvc3QgPSBmdW5jdGlvbiAodXJsLCBpbnB1dCkge1xuIHZhciByZXN1bHQsIGNvZGVQb2ludHMsIGluZGV4O1xuIGlmIChpbnB1dC5jaGFyQXQoMCkgPT0gJ1snKSB7XG4gIGlmIChpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT0gJ10nKVxuICAgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgcmVzdWx0ID0gcGFyc2VJUHY2KGlucHV0LnNsaWNlKDEsIC0xKSk7XG4gIGlmICghcmVzdWx0KVxuICAgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgdXJsLmhvc3QgPSByZXN1bHQ7XG4gfSBlbHNlIGlmICghaXNTcGVjaWFsKHVybCkpIHtcbiAgaWYgKEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlRfRVhDTFVESU5HX1BFUkNFTlQudGVzdChpbnB1dCkpXG4gICByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICByZXN1bHQgPSAnJztcbiAgY29kZVBvaW50cyA9IGFycmF5RnJvbShpbnB1dCk7XG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGNvZGVQb2ludHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICByZXN1bHQgKz0gcGVyY2VudEVuY29kZShjb2RlUG9pbnRzW2luZGV4XSwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XG4gIH1cbiAgdXJsLmhvc3QgPSByZXN1bHQ7XG4gfSBlbHNlIHtcbiAgaW5wdXQgPSB0b0FTQ0lJKGlucHV0KTtcbiAgaWYgKEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlQudGVzdChpbnB1dCkpXG4gICByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICByZXN1bHQgPSBwYXJzZUlQdjQoaW5wdXQpO1xuICBpZiAocmVzdWx0ID09PSBudWxsKVxuICAgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgdXJsLmhvc3QgPSByZXN1bHQ7XG4gfVxufTtcbnZhciBwYXJzZUlQdjQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiB2YXIgcGFydHMgPSBpbnB1dC5zcGxpdCgnLicpO1xuIHZhciBwYXJ0c0xlbmd0aCwgbnVtYmVycywgaW5kZXgsIHBhcnQsIHJhZGl4LCBudW1iZXIsIGlwdjQ7XG4gaWYgKHBhcnRzLmxlbmd0aCAmJiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA9PSAnJykge1xuICBwYXJ0cy5wb3AoKTtcbiB9XG4gcGFydHNMZW5ndGggPSBwYXJ0cy5sZW5ndGg7XG4gaWYgKHBhcnRzTGVuZ3RoID4gNClcbiAgcmV0dXJuIGlucHV0O1xuIG51bWJlcnMgPSBbXTtcbiBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwYXJ0c0xlbmd0aDsgaW5kZXgrKykge1xuICBwYXJ0ID0gcGFydHNbaW5kZXhdO1xuICBpZiAocGFydCA9PSAnJylcbiAgIHJldHVybiBpbnB1dDtcbiAgcmFkaXggPSAxMDtcbiAgaWYgKHBhcnQubGVuZ3RoID4gMSAmJiBwYXJ0LmNoYXJBdCgwKSA9PSAnMCcpIHtcbiAgIHJhZGl4ID0gSEVYX1NUQVJULnRlc3QocGFydCkgPyAxNiA6IDg7XG4gICBwYXJ0ID0gcGFydC5zbGljZShyYWRpeCA9PSA4ID8gMSA6IDIpO1xuICB9XG4gIGlmIChwYXJ0ID09PSAnJykge1xuICAgbnVtYmVyID0gMDtcbiAgfSBlbHNlIHtcbiAgIGlmICghKHJhZGl4ID09IDEwID8gREVDIDogcmFkaXggPT0gOCA/IE9DVCA6IEhFWCkudGVzdChwYXJ0KSlcbiAgICByZXR1cm4gaW5wdXQ7XG4gICBudW1iZXIgPSBwYXJzZUludChwYXJ0LCByYWRpeCk7XG4gIH1cbiAgbnVtYmVycy5wdXNoKG51bWJlcik7XG4gfVxuIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBhcnRzTGVuZ3RoOyBpbmRleCsrKSB7XG4gIG51bWJlciA9IG51bWJlcnNbaW5kZXhdO1xuICBpZiAoaW5kZXggPT0gcGFydHNMZW5ndGggLSAxKSB7XG4gICBpZiAobnVtYmVyID49IHBvdygyNTYsIDUgLSBwYXJ0c0xlbmd0aCkpXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAobnVtYmVyID4gMjU1KVxuICAgcmV0dXJuIG51bGw7XG4gfVxuIGlwdjQgPSBudW1iZXJzLnBvcCgpO1xuIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IG51bWJlcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gIGlwdjQgKz0gbnVtYmVyc1tpbmRleF0gKiBwb3coMjU2LCAzIC0gaW5kZXgpO1xuIH1cbiByZXR1cm4gaXB2NDtcbn07XG52YXIgcGFyc2VJUHY2ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gdmFyIGFkZHJlc3MgPSBbXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDBcbiBdO1xuIHZhciBwaWVjZUluZGV4ID0gMDtcbiB2YXIgY29tcHJlc3MgPSBudWxsO1xuIHZhciBwb2ludGVyID0gMDtcbiB2YXIgdmFsdWUsIGxlbmd0aCwgbnVtYmVyc1NlZW4sIGlwdjRQaWVjZSwgbnVtYmVyLCBzd2Fwcywgc3dhcDtcbiB2YXIgY2hhciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlucHV0LmNoYXJBdChwb2ludGVyKTtcbiB9O1xuIGlmIChjaGFyKCkgPT0gJzonKSB7XG4gIGlmIChpbnB1dC5jaGFyQXQoMSkgIT0gJzonKVxuICAgcmV0dXJuO1xuICBwb2ludGVyICs9IDI7XG4gIHBpZWNlSW5kZXgrKztcbiAgY29tcHJlc3MgPSBwaWVjZUluZGV4O1xuIH1cbiB3aGlsZSAoY2hhcigpKSB7XG4gIGlmIChwaWVjZUluZGV4ID09IDgpXG4gICByZXR1cm47XG4gIGlmIChjaGFyKCkgPT0gJzonKSB7XG4gICBpZiAoY29tcHJlc3MgIT09IG51bGwpXG4gICAgcmV0dXJuO1xuICAgcG9pbnRlcisrO1xuICAgcGllY2VJbmRleCsrO1xuICAgY29tcHJlc3MgPSBwaWVjZUluZGV4O1xuICAgY29udGludWU7XG4gIH1cbiAgdmFsdWUgPSBsZW5ndGggPSAwO1xuICB3aGlsZSAobGVuZ3RoIDwgNCAmJiBIRVgudGVzdChjaGFyKCkpKSB7XG4gICB2YWx1ZSA9IHZhbHVlICogMTYgKyBwYXJzZUludChjaGFyKCksIDE2KTtcbiAgIHBvaW50ZXIrKztcbiAgIGxlbmd0aCsrO1xuICB9XG4gIGlmIChjaGFyKCkgPT0gJy4nKSB7XG4gICBpZiAobGVuZ3RoID09IDApXG4gICAgcmV0dXJuO1xuICAgcG9pbnRlciAtPSBsZW5ndGg7XG4gICBpZiAocGllY2VJbmRleCA+IDYpXG4gICAgcmV0dXJuO1xuICAgbnVtYmVyc1NlZW4gPSAwO1xuICAgd2hpbGUgKGNoYXIoKSkge1xuICAgIGlwdjRQaWVjZSA9IG51bGw7XG4gICAgaWYgKG51bWJlcnNTZWVuID4gMCkge1xuICAgICBpZiAoY2hhcigpID09ICcuJyAmJiBudW1iZXJzU2VlbiA8IDQpXG4gICAgICBwb2ludGVyKys7XG4gICAgIGVsc2VcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFESUdJVC50ZXN0KGNoYXIoKSkpXG4gICAgIHJldHVybjtcbiAgICB3aGlsZSAoRElHSVQudGVzdChjaGFyKCkpKSB7XG4gICAgIG51bWJlciA9IHBhcnNlSW50KGNoYXIoKSwgMTApO1xuICAgICBpZiAoaXB2NFBpZWNlID09PSBudWxsKVxuICAgICAgaXB2NFBpZWNlID0gbnVtYmVyO1xuICAgICBlbHNlIGlmIChpcHY0UGllY2UgPT0gMClcbiAgICAgIHJldHVybjtcbiAgICAgZWxzZVxuICAgICAgaXB2NFBpZWNlID0gaXB2NFBpZWNlICogMTAgKyBudW1iZXI7XG4gICAgIGlmIChpcHY0UGllY2UgPiAyNTUpXG4gICAgICByZXR1cm47XG4gICAgIHBvaW50ZXIrKztcbiAgICB9XG4gICAgYWRkcmVzc1twaWVjZUluZGV4XSA9IGFkZHJlc3NbcGllY2VJbmRleF0gKiAyNTYgKyBpcHY0UGllY2U7XG4gICAgbnVtYmVyc1NlZW4rKztcbiAgICBpZiAobnVtYmVyc1NlZW4gPT0gMiB8fCBudW1iZXJzU2VlbiA9PSA0KVxuICAgICBwaWVjZUluZGV4Kys7XG4gICB9XG4gICBpZiAobnVtYmVyc1NlZW4gIT0gNClcbiAgICByZXR1cm47XG4gICBicmVhaztcbiAgfSBlbHNlIGlmIChjaGFyKCkgPT0gJzonKSB7XG4gICBwb2ludGVyKys7XG4gICBpZiAoIWNoYXIoKSlcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoY2hhcigpKVxuICAgcmV0dXJuO1xuICBhZGRyZXNzW3BpZWNlSW5kZXgrK10gPSB2YWx1ZTtcbiB9XG4gaWYgKGNvbXByZXNzICE9PSBudWxsKSB7XG4gIHN3YXBzID0gcGllY2VJbmRleCAtIGNvbXByZXNzO1xuICBwaWVjZUluZGV4ID0gNztcbiAgd2hpbGUgKHBpZWNlSW5kZXggIT0gMCAmJiBzd2FwcyA+IDApIHtcbiAgIHN3YXAgPSBhZGRyZXNzW3BpZWNlSW5kZXhdO1xuICAgYWRkcmVzc1twaWVjZUluZGV4LS1dID0gYWRkcmVzc1tjb21wcmVzcyArIHN3YXBzIC0gMV07XG4gICBhZGRyZXNzW2NvbXByZXNzICsgLS1zd2Fwc10gPSBzd2FwO1xuICB9XG4gfSBlbHNlIGlmIChwaWVjZUluZGV4ICE9IDgpXG4gIHJldHVybjtcbiByZXR1cm4gYWRkcmVzcztcbn07XG52YXIgZmluZExvbmdlc3RaZXJvU2VxdWVuY2UgPSBmdW5jdGlvbiAoaXB2Nikge1xuIHZhciBtYXhJbmRleCA9IG51bGw7XG4gdmFyIG1heExlbmd0aCA9IDE7XG4gdmFyIGN1cnJTdGFydCA9IG51bGw7XG4gdmFyIGN1cnJMZW5ndGggPSAwO1xuIHZhciBpbmRleCA9IDA7XG4gZm9yICg7IGluZGV4IDwgODsgaW5kZXgrKykge1xuICBpZiAoaXB2NltpbmRleF0gIT09IDApIHtcbiAgIGlmIChjdXJyTGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XG4gICAgbWF4TGVuZ3RoID0gY3Vyckxlbmd0aDtcbiAgIH1cbiAgIGN1cnJTdGFydCA9IG51bGw7XG4gICBjdXJyTGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgIGlmIChjdXJyU3RhcnQgPT09IG51bGwpXG4gICAgY3VyclN0YXJ0ID0gaW5kZXg7XG4gICArK2N1cnJMZW5ndGg7XG4gIH1cbiB9XG4gaWYgKGN1cnJMZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XG4gIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XG4gfVxuIHJldHVybiBtYXhJbmRleDtcbn07XG52YXIgc2VyaWFsaXplSG9zdCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gdmFyIHJlc3VsdCwgaW5kZXgsIGNvbXByZXNzLCBpZ25vcmUwO1xuIGlmICh0eXBlb2YgaG9zdCA9PSAnbnVtYmVyJykge1xuICByZXN1bHQgPSBbXTtcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgNDsgaW5kZXgrKykge1xuICAgcmVzdWx0LnVuc2hpZnQoaG9zdCAlIDI1Nik7XG4gICBob3N0ID0gZmxvb3IoaG9zdCAvIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcuJyk7XG4gfSBlbHNlIGlmICh0eXBlb2YgaG9zdCA9PSAnb2JqZWN0Jykge1xuICByZXN1bHQgPSAnJztcbiAgY29tcHJlc3MgPSBmaW5kTG9uZ2VzdFplcm9TZXF1ZW5jZShob3N0KTtcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgODsgaW5kZXgrKykge1xuICAgaWYgKGlnbm9yZTAgJiYgaG9zdFtpbmRleF0gPT09IDApXG4gICAgY29udGludWU7XG4gICBpZiAoaWdub3JlMClcbiAgICBpZ25vcmUwID0gZmFsc2U7XG4gICBpZiAoY29tcHJlc3MgPT09IGluZGV4KSB7XG4gICAgcmVzdWx0ICs9IGluZGV4ID8gJzonIDogJzo6JztcbiAgICBpZ25vcmUwID0gdHJ1ZTtcbiAgIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IGhvc3RbaW5kZXhdLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaW5kZXggPCA3KVxuICAgICByZXN1bHQgKz0gJzonO1xuICAgfVxuICB9XG4gIHJldHVybiAnWycgKyByZXN1bHQgKyAnXSc7XG4gfVxuIHJldHVybiBob3N0O1xufTtcbnZhciBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0ID0ge307XG52YXIgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0LCB7XG4gJyAnOiAxLFxuICdcIic6IDEsXG4gJzwnOiAxLFxuICc+JzogMSxcbiAnYCc6IDFcbn0pO1xudmFyIHBhdGhQZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBmcmFnbWVudFBlcmNlbnRFbmNvZGVTZXQsIHtcbiAnIyc6IDEsXG4gJz8nOiAxLFxuICd7JzogMSxcbiAnfSc6IDFcbn0pO1xudmFyIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCA9IGFzc2lnbih7fSwgcGF0aFBlcmNlbnRFbmNvZGVTZXQsIHtcbiAnLyc6IDEsXG4gJzonOiAxLFxuICc7JzogMSxcbiAnPSc6IDEsXG4gJ0AnOiAxLFxuICdbJzogMSxcbiAnXFxcXCc6IDEsXG4gJ10nOiAxLFxuICdeJzogMSxcbiAnfCc6IDFcbn0pO1xudmFyIHBlcmNlbnRFbmNvZGUgPSBmdW5jdGlvbiAoY2hhciwgc2V0KSB7XG4gdmFyIGNvZGUgPSBjb2RlQXQoY2hhciwgMCk7XG4gcmV0dXJuIGNvZGUgPiAweDIwICYmIGNvZGUgPCAweDdGICYmICFoYXMoc2V0LCBjaGFyKSA/IGNoYXIgOiBlbmNvZGVVUklDb21wb25lbnQoY2hhcik7XG59O1xudmFyIHNwZWNpYWxTY2hlbWVzID0ge1xuIGZ0cDogMjEsXG4gZmlsZTogbnVsbCxcbiBodHRwOiA4MCxcbiBodHRwczogNDQzLFxuIHdzOiA4MCxcbiB3c3M6IDQ0M1xufTtcbnZhciBpc1NwZWNpYWwgPSBmdW5jdGlvbiAodXJsKSB7XG4gcmV0dXJuIGhhcyhzcGVjaWFsU2NoZW1lcywgdXJsLnNjaGVtZSk7XG59O1xudmFyIGluY2x1ZGVzQ3JlZGVudGlhbHMgPSBmdW5jdGlvbiAodXJsKSB7XG4gcmV0dXJuIHVybC51c2VybmFtZSAhPSAnJyB8fCB1cmwucGFzc3dvcmQgIT0gJyc7XG59O1xudmFyIGNhbm5vdEhhdmVVc2VybmFtZVBhc3N3b3JkUG9ydCA9IGZ1bmN0aW9uICh1cmwpIHtcbiByZXR1cm4gIXVybC5ob3N0IHx8IHVybC5jYW5ub3RCZUFCYXNlVVJMIHx8IHVybC5zY2hlbWUgPT0gJ2ZpbGUnO1xufTtcbnZhciBpc1dpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIChzdHJpbmcsIG5vcm1hbGl6ZWQpIHtcbiB2YXIgc2Vjb25kO1xuIHJldHVybiBzdHJpbmcubGVuZ3RoID09IDIgJiYgQUxQSEEudGVzdChzdHJpbmcuY2hhckF0KDApKSAmJiAoKHNlY29uZCA9IHN0cmluZy5jaGFyQXQoMSkpID09ICc6JyB8fCAhbm9ybWFsaXplZCAmJiBzZWNvbmQgPT0gJ3wnKTtcbn07XG52YXIgc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiB2YXIgdGhpcmQ7XG4gcmV0dXJuIHN0cmluZy5sZW5ndGggPiAxICYmIGlzV2luZG93c0RyaXZlTGV0dGVyKHN0cmluZy5zbGljZSgwLCAyKSkgJiYgKHN0cmluZy5sZW5ndGggPT0gMiB8fCAoKHRoaXJkID0gc3RyaW5nLmNoYXJBdCgyKSkgPT09ICcvJyB8fCB0aGlyZCA9PT0gJ1xcXFwnIHx8IHRoaXJkID09PSAnPycgfHwgdGhpcmQgPT09ICcjJykpO1xufTtcbnZhciBzaG9ydGVuVVJMc1BhdGggPSBmdW5jdGlvbiAodXJsKSB7XG4gdmFyIHBhdGggPSB1cmwucGF0aDtcbiB2YXIgcGF0aFNpemUgPSBwYXRoLmxlbmd0aDtcbiBpZiAocGF0aFNpemUgJiYgKHVybC5zY2hlbWUgIT0gJ2ZpbGUnIHx8IHBhdGhTaXplICE9IDEgfHwgIWlzV2luZG93c0RyaXZlTGV0dGVyKHBhdGhbMF0sIHRydWUpKSkge1xuICBwYXRoLnBvcCgpO1xuIH1cbn07XG52YXIgaXNTaW5nbGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuIHJldHVybiBzZWdtZW50ID09PSAnLicgfHwgc2VnbWVudC50b0xvd2VyQ2FzZSgpID09PSAnJTJlJztcbn07XG52YXIgaXNEb3VibGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuIHNlZ21lbnQgPSBzZWdtZW50LnRvTG93ZXJDYXNlKCk7XG4gcmV0dXJuIHNlZ21lbnQgPT09ICcuLicgfHwgc2VnbWVudCA9PT0gJyUyZS4nIHx8IHNlZ21lbnQgPT09ICcuJTJlJyB8fCBzZWdtZW50ID09PSAnJTJlJTJlJztcbn07XG52YXIgU0NIRU1FX1NUQVJUID0ge307XG52YXIgU0NIRU1FID0ge307XG52YXIgTk9fU0NIRU1FID0ge307XG52YXIgU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFkgPSB7fTtcbnZhciBQQVRIX09SX0FVVEhPUklUWSA9IHt9O1xudmFyIFJFTEFUSVZFID0ge307XG52YXIgUkVMQVRJVkVfU0xBU0ggPSB7fTtcbnZhciBTUEVDSUFMX0FVVEhPUklUWV9TTEFTSEVTID0ge307XG52YXIgU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVMgPSB7fTtcbnZhciBBVVRIT1JJVFkgPSB7fTtcbnZhciBIT1NUID0ge307XG52YXIgSE9TVE5BTUUgPSB7fTtcbnZhciBQT1JUID0ge307XG52YXIgRklMRSA9IHt9O1xudmFyIEZJTEVfU0xBU0ggPSB7fTtcbnZhciBGSUxFX0hPU1QgPSB7fTtcbnZhciBQQVRIX1NUQVJUID0ge307XG52YXIgUEFUSCA9IHt9O1xudmFyIENBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEggPSB7fTtcbnZhciBRVUVSWSA9IHt9O1xudmFyIEZSQUdNRU5UID0ge307XG52YXIgcGFyc2VVUkwgPSBmdW5jdGlvbiAodXJsLCBpbnB1dCwgc3RhdGVPdmVycmlkZSwgYmFzZSkge1xuIHZhciBzdGF0ZSA9IHN0YXRlT3ZlcnJpZGUgfHwgU0NIRU1FX1NUQVJUO1xuIHZhciBwb2ludGVyID0gMDtcbiB2YXIgYnVmZmVyID0gJyc7XG4gdmFyIHNlZW5BdCA9IGZhbHNlO1xuIHZhciBzZWVuQnJhY2tldCA9IGZhbHNlO1xuIHZhciBzZWVuUGFzc3dvcmRUb2tlbiA9IGZhbHNlO1xuIHZhciBjb2RlUG9pbnRzLCBjaGFyLCBidWZmZXJDb2RlUG9pbnRzLCBmYWlsdXJlO1xuIGlmICghc3RhdGVPdmVycmlkZSkge1xuICB1cmwuc2NoZW1lID0gJyc7XG4gIHVybC51c2VybmFtZSA9ICcnO1xuICB1cmwucGFzc3dvcmQgPSAnJztcbiAgdXJsLmhvc3QgPSBudWxsO1xuICB1cmwucG9ydCA9IG51bGw7XG4gIHVybC5wYXRoID0gW107XG4gIHVybC5xdWVyeSA9IG51bGw7XG4gIHVybC5mcmFnbWVudCA9IG51bGw7XG4gIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gZmFsc2U7XG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZShMRUFESU5HX0FORF9UUkFJTElOR19DMF9DT05UUk9MX09SX1NQQUNFLCAnJyk7XG4gfVxuIGlucHV0ID0gaW5wdXQucmVwbGFjZShUQUJfQU5EX05FV19MSU5FLCAnJyk7XG4gY29kZVBvaW50cyA9IGFycmF5RnJvbShpbnB1dCk7XG4gd2hpbGUgKHBvaW50ZXIgPD0gY29kZVBvaW50cy5sZW5ndGgpIHtcbiAgY2hhciA9IGNvZGVQb2ludHNbcG9pbnRlcl07XG4gIHN3aXRjaCAoc3RhdGUpIHtcbiAgY2FzZSBTQ0hFTUVfU1RBUlQ6XG4gICBpZiAoY2hhciAmJiBBTFBIQS50ZXN0KGNoYXIpKSB7XG4gICAgYnVmZmVyICs9IGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICBzdGF0ZSA9IFNDSEVNRTtcbiAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUpIHtcbiAgICBzdGF0ZSA9IE5PX1NDSEVNRTtcbiAgICBjb250aW51ZTtcbiAgIH0gZWxzZVxuICAgIHJldHVybiBJTlZBTElEX1NDSEVNRTtcbiAgIGJyZWFrO1xuICBjYXNlIFNDSEVNRTpcbiAgIGlmIChjaGFyICYmIChBTFBIQU5VTUVSSUMudGVzdChjaGFyKSB8fCBjaGFyID09ICcrJyB8fCBjaGFyID09ICctJyB8fCBjaGFyID09ICcuJykpIHtcbiAgICBidWZmZXIgKz0gY2hhci50b0xvd2VyQ2FzZSgpO1xuICAgfSBlbHNlIGlmIChjaGFyID09ICc6Jykge1xuICAgIGlmIChzdGF0ZU92ZXJyaWRlICYmIChpc1NwZWNpYWwodXJsKSAhPSBoYXMoc3BlY2lhbFNjaGVtZXMsIGJ1ZmZlcikgfHwgYnVmZmVyID09ICdmaWxlJyAmJiAoaW5jbHVkZXNDcmVkZW50aWFscyh1cmwpIHx8IHVybC5wb3J0ICE9PSBudWxsKSB8fCB1cmwuc2NoZW1lID09ICdmaWxlJyAmJiAhdXJsLmhvc3QpKVxuICAgICByZXR1cm47XG4gICAgdXJsLnNjaGVtZSA9IGJ1ZmZlcjtcbiAgICBpZiAoc3RhdGVPdmVycmlkZSkge1xuICAgICBpZiAoaXNTcGVjaWFsKHVybCkgJiYgc3BlY2lhbFNjaGVtZXNbdXJsLnNjaGVtZV0gPT0gdXJsLnBvcnQpXG4gICAgICB1cmwucG9ydCA9IG51bGw7XG4gICAgIHJldHVybjtcbiAgICB9XG4gICAgYnVmZmVyID0gJyc7XG4gICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnKSB7XG4gICAgIHN0YXRlID0gRklMRTtcbiAgICB9IGVsc2UgaWYgKGlzU3BlY2lhbCh1cmwpICYmIGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gdXJsLnNjaGVtZSkge1xuICAgICBzdGF0ZSA9IFNQRUNJQUxfUkVMQVRJVkVfT1JfQVVUSE9SSVRZO1xuICAgIH0gZWxzZSBpZiAoaXNTcGVjaWFsKHVybCkpIHtcbiAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9TTEFTSEVTO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50c1twb2ludGVyICsgMV0gPT0gJy8nKSB7XG4gICAgIHN0YXRlID0gUEFUSF9PUl9BVVRIT1JJVFk7XG4gICAgIHBvaW50ZXIrKztcbiAgICB9IGVsc2Uge1xuICAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IHRydWU7XG4gICAgIHVybC5wYXRoLnB1c2goJycpO1xuICAgICBzdGF0ZSA9IENBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEg7XG4gICAgfVxuICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSkge1xuICAgIGJ1ZmZlciA9ICcnO1xuICAgIHN0YXRlID0gTk9fU0NIRU1FO1xuICAgIHBvaW50ZXIgPSAwO1xuICAgIGNvbnRpbnVlO1xuICAgfSBlbHNlXG4gICAgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xuICAgYnJlYWs7XG4gIGNhc2UgTk9fU0NIRU1FOlxuICAgaWYgKCFiYXNlIHx8IGJhc2UuY2Fubm90QmVBQmFzZVVSTCAmJiBjaGFyICE9ICcjJylcbiAgICByZXR1cm4gSU5WQUxJRF9TQ0hFTUU7XG4gICBpZiAoYmFzZS5jYW5ub3RCZUFCYXNlVVJMICYmIGNoYXIgPT0gJyMnKSB7XG4gICAgdXJsLnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IHRydWU7XG4gICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICBicmVhaztcbiAgIH1cbiAgIHN0YXRlID0gYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnID8gRklMRSA6IFJFTEFUSVZFO1xuICAgY29udGludWU7XG4gIGNhc2UgU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFk6XG4gICBpZiAoY2hhciA9PSAnLycgJiYgY29kZVBvaW50c1twb2ludGVyICsgMV0gPT0gJy8nKSB7XG4gICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcbiAgICBwb2ludGVyKys7XG4gICB9IGVsc2Uge1xuICAgIHN0YXRlID0gUkVMQVRJVkU7XG4gICAgY29udGludWU7XG4gICB9XG4gICBicmVhaztcbiAgY2FzZSBQQVRIX09SX0FVVEhPUklUWTpcbiAgIGlmIChjaGFyID09ICcvJykge1xuICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgIGJyZWFrO1xuICAgfSBlbHNlIHtcbiAgICBzdGF0ZSA9IFBBVEg7XG4gICAgY29udGludWU7XG4gICB9XG4gIGNhc2UgUkVMQVRJVkU6XG4gICB1cmwuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG4gICBpZiAoY2hhciA9PSBFT0YpIHtcbiAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgfSBlbHNlIGlmIChjaGFyID09ICcvJyB8fCBjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkge1xuICAgIHN0YXRlID0gUkVMQVRJVkVfU0xBU0g7XG4gICB9IGVsc2UgaWYgKGNoYXIgPT0gJz8nKSB7XG4gICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgc3RhdGUgPSBRVUVSWTtcbiAgIH0gZWxzZSBpZiAoY2hhciA9PSAnIycpIHtcbiAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICB9IGVsc2Uge1xuICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xuICAgIHVybC5wYXRoLnBvcCgpO1xuICAgIHN0YXRlID0gUEFUSDtcbiAgICBjb250aW51ZTtcbiAgIH1cbiAgIGJyZWFrO1xuICBjYXNlIFJFTEFUSVZFX1NMQVNIOlxuICAgaWYgKGlzU3BlY2lhbCh1cmwpICYmIChjaGFyID09ICcvJyB8fCBjaGFyID09ICdcXFxcJykpIHtcbiAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTO1xuICAgfSBlbHNlIGlmIChjaGFyID09ICcvJykge1xuICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgfSBlbHNlIHtcbiAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgc3RhdGUgPSBQQVRIO1xuICAgIGNvbnRpbnVlO1xuICAgfVxuICAgYnJlYWs7XG4gIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUzpcbiAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM7XG4gICBpZiAoY2hhciAhPSAnLycgfHwgYnVmZmVyLmNoYXJBdChwb2ludGVyICsgMSkgIT0gJy8nKVxuICAgIGNvbnRpbnVlO1xuICAgcG9pbnRlcisrO1xuICAgYnJlYWs7XG4gIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM6XG4gICBpZiAoY2hhciAhPSAnLycgJiYgY2hhciAhPSAnXFxcXCcpIHtcbiAgICBzdGF0ZSA9IEFVVEhPUklUWTtcbiAgICBjb250aW51ZTtcbiAgIH1cbiAgIGJyZWFrO1xuICBjYXNlIEFVVEhPUklUWTpcbiAgIGlmIChjaGFyID09ICdAJykge1xuICAgIGlmIChzZWVuQXQpXG4gICAgIGJ1ZmZlciA9ICclNDAnICsgYnVmZmVyO1xuICAgIHNlZW5BdCA9IHRydWU7XG4gICAgYnVmZmVyQ29kZVBvaW50cyA9IGFycmF5RnJvbShidWZmZXIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyQ29kZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICB2YXIgY29kZVBvaW50ID0gYnVmZmVyQ29kZVBvaW50c1tpXTtcbiAgICAgaWYgKGNvZGVQb2ludCA9PSAnOicgJiYgIXNlZW5QYXNzd29yZFRva2VuKSB7XG4gICAgICBzZWVuUGFzc3dvcmRUb2tlbiA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICAgfVxuICAgICB2YXIgZW5jb2RlZENvZGVQb2ludHMgPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludCwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgaWYgKHNlZW5QYXNzd29yZFRva2VuKVxuICAgICAgdXJsLnBhc3N3b3JkICs9IGVuY29kZWRDb2RlUG9pbnRzO1xuICAgICBlbHNlXG4gICAgICB1cmwudXNlcm5hbWUgKz0gZW5jb2RlZENvZGVQb2ludHM7XG4gICAgfVxuICAgIGJ1ZmZlciA9ICcnO1xuICAgfSBlbHNlIGlmIChjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJyB8fCBjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkge1xuICAgIGlmIChzZWVuQXQgJiYgYnVmZmVyID09ICcnKVxuICAgICByZXR1cm4gSU5WQUxJRF9BVVRIT1JJVFk7XG4gICAgcG9pbnRlciAtPSBhcnJheUZyb20oYnVmZmVyKS5sZW5ndGggKyAxO1xuICAgIGJ1ZmZlciA9ICcnO1xuICAgIHN0YXRlID0gSE9TVDtcbiAgIH0gZWxzZVxuICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgYnJlYWs7XG4gIGNhc2UgSE9TVDpcbiAgY2FzZSBIT1NUTkFNRTpcbiAgIGlmIChzdGF0ZU92ZXJyaWRlICYmIHVybC5zY2hlbWUgPT0gJ2ZpbGUnKSB7XG4gICAgc3RhdGUgPSBGSUxFX0hPU1Q7XG4gICAgY29udGludWU7XG4gICB9IGVsc2UgaWYgKGNoYXIgPT0gJzonICYmICFzZWVuQnJhY2tldCkge1xuICAgIGlmIChidWZmZXIgPT0gJycpXG4gICAgIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgZmFpbHVyZSA9IHBhcnNlSG9zdCh1cmwsIGJ1ZmZlcik7XG4gICAgaWYgKGZhaWx1cmUpXG4gICAgIHJldHVybiBmYWlsdXJlO1xuICAgIGJ1ZmZlciA9ICcnO1xuICAgIHN0YXRlID0gUE9SVDtcbiAgICBpZiAoc3RhdGVPdmVycmlkZSA9PSBIT1NUTkFNRSlcbiAgICAgcmV0dXJuO1xuICAgfSBlbHNlIGlmIChjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJyB8fCBjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkge1xuICAgIGlmIChpc1NwZWNpYWwodXJsKSAmJiBidWZmZXIgPT0gJycpXG4gICAgIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgYnVmZmVyID09ICcnICYmIChpbmNsdWRlc0NyZWRlbnRpYWxzKHVybCkgfHwgdXJsLnBvcnQgIT09IG51bGwpKVxuICAgICByZXR1cm47XG4gICAgZmFpbHVyZSA9IHBhcnNlSG9zdCh1cmwsIGJ1ZmZlcik7XG4gICAgaWYgKGZhaWx1cmUpXG4gICAgIHJldHVybiBmYWlsdXJlO1xuICAgIGJ1ZmZlciA9ICcnO1xuICAgIHN0YXRlID0gUEFUSF9TVEFSVDtcbiAgICBpZiAoc3RhdGVPdmVycmlkZSlcbiAgICAgcmV0dXJuO1xuICAgIGNvbnRpbnVlO1xuICAgfSBlbHNlIHtcbiAgICBpZiAoY2hhciA9PSAnWycpXG4gICAgIHNlZW5CcmFja2V0ID0gdHJ1ZTtcbiAgICBlbHNlIGlmIChjaGFyID09ICddJylcbiAgICAgc2VlbkJyYWNrZXQgPSBmYWxzZTtcbiAgICBidWZmZXIgKz0gY2hhcjtcbiAgIH1cbiAgIGJyZWFrO1xuICBjYXNlIFBPUlQ6XG4gICBpZiAoRElHSVQudGVzdChjaGFyKSkge1xuICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgfSBlbHNlIGlmIChjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJyB8fCBjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSB8fCBzdGF0ZU92ZXJyaWRlKSB7XG4gICAgaWYgKGJ1ZmZlciAhPSAnJykge1xuICAgICB2YXIgcG9ydCA9IHBhcnNlSW50KGJ1ZmZlciwgMTApO1xuICAgICBpZiAocG9ydCA+IDB4RkZGRilcbiAgICAgIHJldHVybiBJTlZBTElEX1BPUlQ7XG4gICAgIHVybC5wb3J0ID0gaXNTcGVjaWFsKHVybCkgJiYgcG9ydCA9PT0gc3BlY2lhbFNjaGVtZXNbdXJsLnNjaGVtZV0gPyBudWxsIDogcG9ydDtcbiAgICAgYnVmZmVyID0gJyc7XG4gICAgfVxuICAgIGlmIChzdGF0ZU92ZXJyaWRlKVxuICAgICByZXR1cm47XG4gICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgIGNvbnRpbnVlO1xuICAgfSBlbHNlXG4gICAgcmV0dXJuIElOVkFMSURfUE9SVDtcbiAgIGJyZWFrO1xuICBjYXNlIEZJTEU6XG4gICB1cmwuc2NoZW1lID0gJ2ZpbGUnO1xuICAgaWYgKGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJ1xcXFwnKVxuICAgIHN0YXRlID0gRklMRV9TTEFTSDtcbiAgIGVsc2UgaWYgKGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnKSB7XG4gICAgaWYgKGNoYXIgPT0gRU9GKSB7XG4gICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xuICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnPycpIHtcbiAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnIycpIHtcbiAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgIH0gZWxzZSB7XG4gICAgIGlmICghc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihjb2RlUG9pbnRzLnNsaWNlKHBvaW50ZXIpLmpvaW4oJycpKSkge1xuICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xuICAgICAgc2hvcnRlblVSTHNQYXRoKHVybCk7XG4gICAgIH1cbiAgICAgc3RhdGUgPSBQQVRIO1xuICAgICBjb250aW51ZTtcbiAgICB9XG4gICB9IGVsc2Uge1xuICAgIHN0YXRlID0gUEFUSDtcbiAgICBjb250aW51ZTtcbiAgIH1cbiAgIGJyZWFrO1xuICBjYXNlIEZJTEVfU0xBU0g6XG4gICBpZiAoY2hhciA9PSAnLycgfHwgY2hhciA9PSAnXFxcXCcpIHtcbiAgICBzdGF0ZSA9IEZJTEVfSE9TVDtcbiAgICBicmVhaztcbiAgIH1cbiAgIGlmIChiYXNlICYmIGJhc2Uuc2NoZW1lID09ICdmaWxlJyAmJiAhc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihjb2RlUG9pbnRzLnNsaWNlKHBvaW50ZXIpLmpvaW4oJycpKSkge1xuICAgIGlmIChpc1dpbmRvd3NEcml2ZUxldHRlcihiYXNlLnBhdGhbMF0sIHRydWUpKVxuICAgICB1cmwucGF0aC5wdXNoKGJhc2UucGF0aFswXSk7XG4gICAgZWxzZVxuICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgIH1cbiAgIHN0YXRlID0gUEFUSDtcbiAgIGNvbnRpbnVlO1xuICBjYXNlIEZJTEVfSE9TVDpcbiAgIGlmIChjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICdcXFxcJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJykge1xuICAgIGlmICghc3RhdGVPdmVycmlkZSAmJiBpc1dpbmRvd3NEcml2ZUxldHRlcihidWZmZXIpKSB7XG4gICAgIHN0YXRlID0gUEFUSDtcbiAgICB9IGVsc2UgaWYgKGJ1ZmZlciA9PSAnJykge1xuICAgICB1cmwuaG9zdCA9ICcnO1xuICAgICBpZiAoc3RhdGVPdmVycmlkZSlcbiAgICAgIHJldHVybjtcbiAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgIH0gZWxzZSB7XG4gICAgIGZhaWx1cmUgPSBwYXJzZUhvc3QodXJsLCBidWZmZXIpO1xuICAgICBpZiAoZmFpbHVyZSlcbiAgICAgIHJldHVybiBmYWlsdXJlO1xuICAgICBpZiAodXJsLmhvc3QgPT0gJ2xvY2FsaG9zdCcpXG4gICAgICB1cmwuaG9zdCA9ICcnO1xuICAgICBpZiAoc3RhdGVPdmVycmlkZSlcbiAgICAgIHJldHVybjtcbiAgICAgYnVmZmVyID0gJyc7XG4gICAgIHN0YXRlID0gUEFUSF9TVEFSVDtcbiAgICB9XG4gICAgY29udGludWU7XG4gICB9IGVsc2VcbiAgICBidWZmZXIgKz0gY2hhcjtcbiAgIGJyZWFrO1xuICBjYXNlIFBBVEhfU1RBUlQ6XG4gICBpZiAoaXNTcGVjaWFsKHVybCkpIHtcbiAgICBzdGF0ZSA9IFBBVEg7XG4gICAgaWYgKGNoYXIgIT0gJy8nICYmIGNoYXIgIT0gJ1xcXFwnKVxuICAgICBjb250aW51ZTtcbiAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hhciA9PSAnPycpIHtcbiAgICB1cmwucXVlcnkgPSAnJztcbiAgICBzdGF0ZSA9IFFVRVJZO1xuICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSAmJiBjaGFyID09ICcjJykge1xuICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICB9IGVsc2UgaWYgKGNoYXIgIT0gRU9GKSB7XG4gICAgc3RhdGUgPSBQQVRIO1xuICAgIGlmIChjaGFyICE9ICcvJylcbiAgICAgY29udGludWU7XG4gICB9XG4gICBicmVhaztcbiAgY2FzZSBQQVRIOlxuICAgaWYgKGNoYXIgPT0gRU9GIHx8IGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJ1xcXFwnICYmIGlzU3BlY2lhbCh1cmwpIHx8ICFzdGF0ZU92ZXJyaWRlICYmIChjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJykpIHtcbiAgICBpZiAoaXNEb3VibGVEb3QoYnVmZmVyKSkge1xuICAgICBzaG9ydGVuVVJMc1BhdGgodXJsKTtcbiAgICAgaWYgKGNoYXIgIT0gJy8nICYmICEoY2hhciA9PSAnXFxcXCcgJiYgaXNTcGVjaWFsKHVybCkpKSB7XG4gICAgICB1cmwucGF0aC5wdXNoKCcnKTtcbiAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNTaW5nbGVEb3QoYnVmZmVyKSkge1xuICAgICBpZiAoY2hhciAhPSAnLycgJiYgIShjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkpIHtcbiAgICAgIHVybC5wYXRoLnB1c2goJycpO1xuICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnICYmICF1cmwucGF0aC5sZW5ndGggJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoYnVmZmVyKSkge1xuICAgICAgaWYgKHVybC5ob3N0KVxuICAgICAgIHVybC5ob3N0ID0gJyc7XG4gICAgICBidWZmZXIgPSBidWZmZXIuY2hhckF0KDApICsgJzonO1xuICAgICB9XG4gICAgIHVybC5wYXRoLnB1c2goYnVmZmVyKTtcbiAgICB9XG4gICAgYnVmZmVyID0gJyc7XG4gICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnICYmIChjaGFyID09IEVPRiB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJykpIHtcbiAgICAgd2hpbGUgKHVybC5wYXRoLmxlbmd0aCA+IDEgJiYgdXJsLnBhdGhbMF0gPT09ICcnKSB7XG4gICAgICB1cmwucGF0aC5zaGlmdCgpO1xuICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFyID09ICc/Jykge1xuICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICB9IGVsc2UgaWYgKGNoYXIgPT0gJyMnKSB7XG4gICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgIH1cbiAgIH0gZWxzZSB7XG4gICAgYnVmZmVyICs9IHBlcmNlbnRFbmNvZGUoY2hhciwgcGF0aFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgfVxuICAgYnJlYWs7XG4gIGNhc2UgQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSDpcbiAgIGlmIChjaGFyID09ICc/Jykge1xuICAgIHVybC5xdWVyeSA9ICcnO1xuICAgIHN0YXRlID0gUVVFUlk7XG4gICB9IGVsc2UgaWYgKGNoYXIgPT0gJyMnKSB7XG4gICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgIH0gZWxzZSBpZiAoY2hhciAhPSBFT0YpIHtcbiAgICB1cmwucGF0aFswXSArPSBwZXJjZW50RW5jb2RlKGNoYXIsIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgfVxuICAgYnJlYWs7XG4gIGNhc2UgUVVFUlk6XG4gICBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hhciA9PSAnIycpIHtcbiAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgfSBlbHNlIGlmIChjaGFyICE9IEVPRikge1xuICAgIGlmIChjaGFyID09IFwiJ1wiICYmIGlzU3BlY2lhbCh1cmwpKVxuICAgICB1cmwucXVlcnkgKz0gJyUyNyc7XG4gICAgZWxzZSBpZiAoY2hhciA9PSAnIycpXG4gICAgIHVybC5xdWVyeSArPSAnJTIzJztcbiAgICBlbHNlXG4gICAgIHVybC5xdWVyeSArPSBwZXJjZW50RW5jb2RlKGNoYXIsIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgfVxuICAgYnJlYWs7XG4gIGNhc2UgRlJBR01FTlQ6XG4gICBpZiAoY2hhciAhPSBFT0YpXG4gICAgdXJsLmZyYWdtZW50ICs9IHBlcmNlbnRFbmNvZGUoY2hhciwgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0KTtcbiAgIGJyZWFrO1xuICB9XG4gIHBvaW50ZXIrKztcbiB9XG59O1xudmFyIFVSTENvbnN0cnVjdG9yID0gZnVuY3Rpb24gVVJMKHVybCkge1xuIHZhciB0aGF0ID0gYW5JbnN0YW5jZSh0aGlzLCBVUkxDb25zdHJ1Y3RvciwgJ1VSTCcpO1xuIHZhciBiYXNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gdmFyIHVybFN0cmluZyA9IFN0cmluZyh1cmwpO1xuIHZhciBzdGF0ZSA9IHNldEludGVybmFsU3RhdGUodGhhdCwgeyB0eXBlOiAnVVJMJyB9KTtcbiB2YXIgYmFzZVN0YXRlLCBmYWlsdXJlO1xuIGlmIChiYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgaWYgKGJhc2UgaW5zdGFuY2VvZiBVUkxDb25zdHJ1Y3RvcilcbiAgIGJhc2VTdGF0ZSA9IGdldEludGVybmFsVVJMU3RhdGUoYmFzZSk7XG4gIGVsc2Uge1xuICAgZmFpbHVyZSA9IHBhcnNlVVJMKGJhc2VTdGF0ZSA9IHt9LCBTdHJpbmcoYmFzZSkpO1xuICAgaWYgKGZhaWx1cmUpXG4gICAgdGhyb3cgVHlwZUVycm9yKGZhaWx1cmUpO1xuICB9XG4gfVxuIGZhaWx1cmUgPSBwYXJzZVVSTChzdGF0ZSwgdXJsU3RyaW5nLCBudWxsLCBiYXNlU3RhdGUpO1xuIGlmIChmYWlsdXJlKVxuICB0aHJvdyBUeXBlRXJyb3IoZmFpbHVyZSk7XG4gdmFyIHNlYXJjaFBhcmFtcyA9IHN0YXRlLnNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiB2YXIgc2VhcmNoUGFyYW1zU3RhdGUgPSBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlKHNlYXJjaFBhcmFtcyk7XG4gc2VhcmNoUGFyYW1zU3RhdGUudXBkYXRlU2VhcmNoUGFyYW1zKHN0YXRlLnF1ZXJ5KTtcbiBzZWFyY2hQYXJhbXNTdGF0ZS51cGRhdGVVUkwgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YXRlLnF1ZXJ5ID0gU3RyaW5nKHNlYXJjaFBhcmFtcykgfHwgbnVsbDtcbiB9O1xuIGlmICghREVTQ1JJUFRPUlMpIHtcbiAgdGhhdC5ocmVmID0gc2VyaWFsaXplVVJMLmNhbGwodGhhdCk7XG4gIHRoYXQub3JpZ2luID0gZ2V0T3JpZ2luLmNhbGwodGhhdCk7XG4gIHRoYXQucHJvdG9jb2wgPSBnZXRQcm90b2NvbC5jYWxsKHRoYXQpO1xuICB0aGF0LnVzZXJuYW1lID0gZ2V0VXNlcm5hbWUuY2FsbCh0aGF0KTtcbiAgdGhhdC5wYXNzd29yZCA9IGdldFBhc3N3b3JkLmNhbGwodGhhdCk7XG4gIHRoYXQuaG9zdCA9IGdldEhvc3QuY2FsbCh0aGF0KTtcbiAgdGhhdC5ob3N0bmFtZSA9IGdldEhvc3RuYW1lLmNhbGwodGhhdCk7XG4gIHRoYXQucG9ydCA9IGdldFBvcnQuY2FsbCh0aGF0KTtcbiAgdGhhdC5wYXRobmFtZSA9IGdldFBhdGhuYW1lLmNhbGwodGhhdCk7XG4gIHRoYXQuc2VhcmNoID0gZ2V0U2VhcmNoLmNhbGwodGhhdCk7XG4gIHRoYXQuc2VhcmNoUGFyYW1zID0gZ2V0U2VhcmNoUGFyYW1zLmNhbGwodGhhdCk7XG4gIHRoYXQuaGFzaCA9IGdldEhhc2guY2FsbCh0aGF0KTtcbiB9XG59O1xudmFyIFVSTFByb3RvdHlwZSA9IFVSTENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbnZhciBzZXJpYWxpemVVUkwgPSBmdW5jdGlvbiAoKSB7XG4gdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gdmFyIHNjaGVtZSA9IHVybC5zY2hlbWU7XG4gdmFyIHVzZXJuYW1lID0gdXJsLnVzZXJuYW1lO1xuIHZhciBwYXNzd29yZCA9IHVybC5wYXNzd29yZDtcbiB2YXIgaG9zdCA9IHVybC5ob3N0O1xuIHZhciBwb3J0ID0gdXJsLnBvcnQ7XG4gdmFyIHBhdGggPSB1cmwucGF0aDtcbiB2YXIgcXVlcnkgPSB1cmwucXVlcnk7XG4gdmFyIGZyYWdtZW50ID0gdXJsLmZyYWdtZW50O1xuIHZhciBvdXRwdXQgPSBzY2hlbWUgKyAnOic7XG4gaWYgKGhvc3QgIT09IG51bGwpIHtcbiAgb3V0cHV0ICs9ICcvLyc7XG4gIGlmIChpbmNsdWRlc0NyZWRlbnRpYWxzKHVybCkpIHtcbiAgIG91dHB1dCArPSB1c2VybmFtZSArIChwYXNzd29yZCA/ICc6JyArIHBhc3N3b3JkIDogJycpICsgJ0AnO1xuICB9XG4gIG91dHB1dCArPSBzZXJpYWxpemVIb3N0KGhvc3QpO1xuICBpZiAocG9ydCAhPT0gbnVsbClcbiAgIG91dHB1dCArPSAnOicgKyBwb3J0O1xuIH0gZWxzZSBpZiAoc2NoZW1lID09ICdmaWxlJylcbiAgb3V0cHV0ICs9ICcvLyc7XG4gb3V0cHV0ICs9IHVybC5jYW5ub3RCZUFCYXNlVVJMID8gcGF0aFswXSA6IHBhdGgubGVuZ3RoID8gJy8nICsgcGF0aC5qb2luKCcvJykgOiAnJztcbiBpZiAocXVlcnkgIT09IG51bGwpXG4gIG91dHB1dCArPSAnPycgKyBxdWVyeTtcbiBpZiAoZnJhZ21lbnQgIT09IG51bGwpXG4gIG91dHB1dCArPSAnIycgKyBmcmFnbWVudDtcbiByZXR1cm4gb3V0cHV0O1xufTtcbnZhciBnZXRPcmlnaW4gPSBmdW5jdGlvbiAoKSB7XG4gdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gdmFyIHNjaGVtZSA9IHVybC5zY2hlbWU7XG4gdmFyIHBvcnQgPSB1cmwucG9ydDtcbiBpZiAoc2NoZW1lID09ICdibG9iJylcbiAgdHJ5IHtcbiAgIHJldHVybiBuZXcgVVJMKHNjaGVtZS5wYXRoWzBdKS5vcmlnaW47XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICByZXR1cm4gJ251bGwnO1xuICB9XG4gaWYgKHNjaGVtZSA9PSAnZmlsZScgfHwgIWlzU3BlY2lhbCh1cmwpKVxuICByZXR1cm4gJ251bGwnO1xuIHJldHVybiBzY2hlbWUgKyAnOi8vJyArIHNlcmlhbGl6ZUhvc3QodXJsLmhvc3QpICsgKHBvcnQgIT09IG51bGwgPyAnOicgKyBwb3J0IDogJycpO1xufTtcbnZhciBnZXRQcm90b2NvbCA9IGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5zY2hlbWUgKyAnOic7XG59O1xudmFyIGdldFVzZXJuYW1lID0gZnVuY3Rpb24gKCkge1xuIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnVzZXJuYW1lO1xufTtcbnZhciBnZXRQYXNzd29yZCA9IGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5wYXNzd29yZDtcbn07XG52YXIgZ2V0SG9zdCA9IGZ1bmN0aW9uICgpIHtcbiB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiB2YXIgaG9zdCA9IHVybC5ob3N0O1xuIHZhciBwb3J0ID0gdXJsLnBvcnQ7XG4gcmV0dXJuIGhvc3QgPT09IG51bGwgPyAnJyA6IHBvcnQgPT09IG51bGwgPyBzZXJpYWxpemVIb3N0KGhvc3QpIDogc2VyaWFsaXplSG9zdChob3N0KSArICc6JyArIHBvcnQ7XG59O1xudmFyIGdldEhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xuIHZhciBob3N0ID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5ob3N0O1xuIHJldHVybiBob3N0ID09PSBudWxsID8gJycgOiBzZXJpYWxpemVIb3N0KGhvc3QpO1xufTtcbnZhciBnZXRQb3J0ID0gZnVuY3Rpb24gKCkge1xuIHZhciBwb3J0ID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5wb3J0O1xuIHJldHVybiBwb3J0ID09PSBudWxsID8gJycgOiBTdHJpbmcocG9ydCk7XG59O1xudmFyIGdldFBhdGhuYW1lID0gZnVuY3Rpb24gKCkge1xuIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuIHZhciBwYXRoID0gdXJsLnBhdGg7XG4gcmV0dXJuIHVybC5jYW5ub3RCZUFCYXNlVVJMID8gcGF0aFswXSA6IHBhdGgubGVuZ3RoID8gJy8nICsgcGF0aC5qb2luKCcvJykgOiAnJztcbn07XG52YXIgZ2V0U2VhcmNoID0gZnVuY3Rpb24gKCkge1xuIHZhciBxdWVyeSA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcykucXVlcnk7XG4gcmV0dXJuIHF1ZXJ5ID8gJz8nICsgcXVlcnkgOiAnJztcbn07XG52YXIgZ2V0U2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKCkge1xuIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnNlYXJjaFBhcmFtcztcbn07XG52YXIgZ2V0SGFzaCA9IGZ1bmN0aW9uICgpIHtcbiB2YXIgZnJhZ21lbnQgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLmZyYWdtZW50O1xuIHJldHVybiBmcmFnbWVudCA/ICcjJyArIGZyYWdtZW50IDogJyc7XG59O1xudmFyIGFjY2Vzc29yRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChnZXR0ZXIsIHNldHRlcikge1xuIHJldHVybiB7XG4gIGdldDogZ2V0dGVyLFxuICBzZXQ6IHNldHRlcixcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlXG4gfTtcbn07XG5pZiAoREVTQ1JJUFRPUlMpIHtcbiBkZWZpbmVQcm9wZXJ0aWVzKFVSTFByb3RvdHlwZSwge1xuICBocmVmOiBhY2Nlc3NvckRlc2NyaXB0b3Ioc2VyaWFsaXplVVJMLCBmdW5jdGlvbiAoaHJlZikge1xuICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gICB2YXIgdXJsU3RyaW5nID0gU3RyaW5nKGhyZWYpO1xuICAgdmFyIGZhaWx1cmUgPSBwYXJzZVVSTCh1cmwsIHVybFN0cmluZyk7XG4gICBpZiAoZmFpbHVyZSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoZmFpbHVyZSk7XG4gICBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlKHVybC5zZWFyY2hQYXJhbXMpLnVwZGF0ZVNlYXJjaFBhcmFtcyh1cmwucXVlcnkpO1xuICB9KSxcbiAgb3JpZ2luOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0T3JpZ2luKSxcbiAgcHJvdG9jb2w6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRQcm90b2NvbCwgZnVuY3Rpb24gKHByb3RvY29sKSB7XG4gICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgIHBhcnNlVVJMKHVybCwgU3RyaW5nKHByb3RvY29sKSArICc6JywgU0NIRU1FX1NUQVJUKTtcbiAgfSksXG4gIHVzZXJuYW1lOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0VXNlcm5hbWUsIGZ1bmN0aW9uICh1c2VybmFtZSkge1xuICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gICB2YXIgY29kZVBvaW50cyA9IGFycmF5RnJvbShTdHJpbmcodXNlcm5hbWUpKTtcbiAgIGlmIChjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQodXJsKSlcbiAgICByZXR1cm47XG4gICB1cmwudXNlcm5hbWUgPSAnJztcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHVybC51c2VybmFtZSArPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludHNbaV0sIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCk7XG4gICB9XG4gIH0pLFxuICBwYXNzd29yZDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFBhc3N3b3JkLCBmdW5jdGlvbiAocGFzc3dvcmQpIHtcbiAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgdmFyIGNvZGVQb2ludHMgPSBhcnJheUZyb20oU3RyaW5nKHBhc3N3b3JkKSk7XG4gICBpZiAoY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KHVybCkpXG4gICAgcmV0dXJuO1xuICAgdXJsLnBhc3N3b3JkID0gJyc7XG4gICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB1cmwucGFzc3dvcmQgKz0gcGVyY2VudEVuY29kZShjb2RlUG9pbnRzW2ldLCB1c2VyaW5mb1BlcmNlbnRFbmNvZGVTZXQpO1xuICAgfVxuICB9KSxcbiAgaG9zdDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldEhvc3QsIGZ1bmN0aW9uIChob3N0KSB7XG4gICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgIGlmICh1cmwuY2Fubm90QmVBQmFzZVVSTClcbiAgICByZXR1cm47XG4gICBwYXJzZVVSTCh1cmwsIFN0cmluZyhob3N0KSwgSE9TVCk7XG4gIH0pLFxuICBob3N0bmFtZTogYWNjZXNzb3JEZXNjcmlwdG9yKGdldEhvc3RuYW1lLCBmdW5jdGlvbiAoaG9zdG5hbWUpIHtcbiAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgaWYgKHVybC5jYW5ub3RCZUFCYXNlVVJMKVxuICAgIHJldHVybjtcbiAgIHBhcnNlVVJMKHVybCwgU3RyaW5nKGhvc3RuYW1lKSwgSE9TVE5BTUUpO1xuICB9KSxcbiAgcG9ydDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFBvcnQsIGZ1bmN0aW9uIChwb3J0KSB7XG4gICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgIGlmIChjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQodXJsKSlcbiAgICByZXR1cm47XG4gICBwb3J0ID0gU3RyaW5nKHBvcnQpO1xuICAgaWYgKHBvcnQgPT0gJycpXG4gICAgdXJsLnBvcnQgPSBudWxsO1xuICAgZWxzZVxuICAgIHBhcnNlVVJMKHVybCwgcG9ydCwgUE9SVCk7XG4gIH0pLFxuICBwYXRobmFtZTogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFBhdGhuYW1lLCBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgaWYgKHVybC5jYW5ub3RCZUFCYXNlVVJMKVxuICAgIHJldHVybjtcbiAgIHVybC5wYXRoID0gW107XG4gICBwYXJzZVVSTCh1cmwsIHBhdGhuYW1lICsgJycsIFBBVEhfU1RBUlQpO1xuICB9KSxcbiAgc2VhcmNoOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0U2VhcmNoLCBmdW5jdGlvbiAoc2VhcmNoKSB7XG4gICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgIHNlYXJjaCA9IFN0cmluZyhzZWFyY2gpO1xuICAgaWYgKHNlYXJjaCA9PSAnJykge1xuICAgIHVybC5xdWVyeSA9IG51bGw7XG4gICB9IGVsc2Uge1xuICAgIGlmICgnPycgPT0gc2VhcmNoLmNoYXJBdCgwKSlcbiAgICAgc2VhcmNoID0gc2VhcmNoLnNsaWNlKDEpO1xuICAgIHVybC5xdWVyeSA9ICcnO1xuICAgIHBhcnNlVVJMKHVybCwgc2VhcmNoLCBRVUVSWSk7XG4gICB9XG4gICBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlKHVybC5zZWFyY2hQYXJhbXMpLnVwZGF0ZVNlYXJjaFBhcmFtcyh1cmwucXVlcnkpO1xuICB9KSxcbiAgc2VhcmNoUGFyYW1zOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0U2VhcmNoUGFyYW1zKSxcbiAgaGFzaDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldEhhc2gsIGZ1bmN0aW9uIChoYXNoKSB7XG4gICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgIGhhc2ggPSBTdHJpbmcoaGFzaCk7XG4gICBpZiAoaGFzaCA9PSAnJykge1xuICAgIHVybC5mcmFnbWVudCA9IG51bGw7XG4gICAgcmV0dXJuO1xuICAgfVxuICAgaWYgKCcjJyA9PSBoYXNoLmNoYXJBdCgwKSlcbiAgICBoYXNoID0gaGFzaC5zbGljZSgxKTtcbiAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgcGFyc2VVUkwodXJsLCBoYXNoLCBGUkFHTUVOVCk7XG4gIH0pXG4gfSk7XG59XG5yZWRlZmluZShVUkxQcm90b3R5cGUsICd0b0pTT04nLCBmdW5jdGlvbiB0b0pTT04oKSB7XG4gcmV0dXJuIHNlcmlhbGl6ZVVSTC5jYWxsKHRoaXMpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xucmVkZWZpbmUoVVJMUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiByZXR1cm4gc2VyaWFsaXplVVJMLmNhbGwodGhpcyk7XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5pZiAoTmF0aXZlVVJMKSB7XG4gdmFyIG5hdGl2ZUNyZWF0ZU9iamVjdFVSTCA9IE5hdGl2ZVVSTC5jcmVhdGVPYmplY3RVUkw7XG4gdmFyIG5hdGl2ZVJldm9rZU9iamVjdFVSTCA9IE5hdGl2ZVVSTC5yZXZva2VPYmplY3RVUkw7XG4gaWYgKG5hdGl2ZUNyZWF0ZU9iamVjdFVSTClcbiAgcmVkZWZpbmUoVVJMQ29uc3RydWN0b3IsICdjcmVhdGVPYmplY3RVUkwnLCBmdW5jdGlvbiBjcmVhdGVPYmplY3RVUkwoYmxvYikge1xuICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZU9iamVjdFVSTC5hcHBseShOYXRpdmVVUkwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuIGlmIChuYXRpdmVSZXZva2VPYmplY3RVUkwpXG4gIHJlZGVmaW5lKFVSTENvbnN0cnVjdG9yLCAncmV2b2tlT2JqZWN0VVJMJywgZnVuY3Rpb24gcmV2b2tlT2JqZWN0VVJMKHVybCkge1xuICAgcmV0dXJuIG5hdGl2ZVJldm9rZU9iamVjdFVSTC5hcHBseShOYXRpdmVVUkwsIGFyZ3VtZW50cyk7XG4gIH0pO1xufVxuc2V0VG9TdHJpbmdUYWcoVVJMQ29uc3RydWN0b3IsICdVUkwnKTtcbiQoe1xuIGdsb2JhbDogdHJ1ZSxcbiBmb3JjZWQ6ICFVU0VfTkFUSVZFX1VSTCxcbiBzaGFtOiAhREVTQ1JJUFRPUlNcbn0sIHsgVVJMOiBVUkxDb25zdHJ1Y3RvciB9KTtcblxuLyoqKi8gfSksXG4vKiAxMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU1KTtcbnZhciBJU19QVVJFID0gX193X3BkZmpzX3JlcXVpcmVfXygzNik7XG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gdmFyIHVybCA9IG5ldyBVUkwoJ2I/YT0xJmI9MiZjPTMnLCAnaHR0cDovL2EnKTtcbiB2YXIgc2VhcmNoUGFyYW1zID0gdXJsLnNlYXJjaFBhcmFtcztcbiB2YXIgcmVzdWx0ID0gJyc7XG4gdXJsLnBhdGhuYW1lID0gJ2MlMjBkJztcbiBzZWFyY2hQYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICBzZWFyY2hQYXJhbXNbJ2RlbGV0ZSddKCdiJyk7XG4gIHJlc3VsdCArPSBrZXkgKyB2YWx1ZTtcbiB9KTtcbiByZXR1cm4gSVNfUFVSRSAmJiAhdXJsLnRvSlNPTiB8fCAhc2VhcmNoUGFyYW1zLnNvcnQgfHwgdXJsLmhyZWYgIT09ICdodHRwOi8vYS9jJTIwZD9hPTEmYz0zJyB8fCBzZWFyY2hQYXJhbXMuZ2V0KCdjJykgIT09ICczJyB8fCBTdHJpbmcobmV3IFVSTFNlYXJjaFBhcmFtcygnP2E9MScpKSAhPT0gJ2E9MScgfHwgIXNlYXJjaFBhcmFtc1tJVEVSQVRPUl0gfHwgbmV3IFVSTCgnaHR0cHM6Ly9hQGInKS51c2VybmFtZSAhPT0gJ2EnIHx8IG5ldyBVUkxTZWFyY2hQYXJhbXMobmV3IFVSTFNlYXJjaFBhcmFtcygnYT1iJykpLmdldCgnYScpICE9PSAnYicgfHwgbmV3IFVSTCgnaHR0cDovL9GC0LXRgdGCJykuaG9zdCAhPT0gJ3huLS1lMWF5YmMnIHx8IG5ldyBVUkwoJ2h0dHA6Ly9hI9CxJykuaGFzaCAhPT0gJyMlRDAlQjEnIHx8IHJlc3VsdCAhPT0gJ2ExYzMnIHx8IG5ldyBVUkwoJ2h0dHA6Ly94JywgdW5kZWZpbmVkKS5ob3N0ICE9PSAneCc7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXygxMik7XG52YXIgZmFpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbnZhciBvYmplY3RLZXlzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2MCk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXyg1MCk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciB0b09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oNjcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3KTtcbnZhciBuYXRpdmVBc3NpZ24gPSBPYmplY3QuYXNzaWduO1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSAhbmF0aXZlQXNzaWduIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiBpZiAoREVTQ1JJUFRPUlMgJiYgbmF0aXZlQXNzaWduKHsgYjogMSB9LCBuYXRpdmVBc3NpZ24oZGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGRlZmluZVByb3BlcnR5KHRoaXMsICdiJywge1xuICAgICB2YWx1ZTogMyxcbiAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSlcbiAgcmV0dXJuIHRydWU7XG4gdmFyIEEgPSB7fTtcbiB2YXIgQiA9IHt9O1xuIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuIEFbc3ltYm9sXSA9IDc7XG4gYWxwaGFiZXQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNocikge1xuICBCW2Nocl0gPSBjaHI7XG4gfSk7XG4gcmV0dXJuIG5hdGl2ZUFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPSA3IHx8IG9iamVjdEtleXMobmF0aXZlQXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiB2YXIgaW5kZXggPSAxO1xuIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xuIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICB2YXIgUyA9IEluZGV4ZWRPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBvYmplY3RLZXlzKFMpLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyhTKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaiA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICBrZXkgPSBrZXlzW2orK107XG4gICBpZiAoIURFU0NSSVBUT1JTIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoUywga2V5KSlcbiAgICBUW2tleV0gPSBTW2tleV07XG4gIH1cbiB9XG4gcmV0dXJuIFQ7XG59IDogbmF0aXZlQXNzaWduO1xuXG4vKioqLyB9KSxcbi8qIDExNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYmluZCA9IF9fd19wZGZqc19yZXF1aXJlX18oNzUpO1xudmFyIHRvT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg2Nyk7XG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTE2KTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc0KTtcbnZhciB0b0xlbmd0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDYpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXyg4MSk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc3KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZnJvbShhcnJheUxpa2UpIHtcbiB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gdmFyIEMgPSB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5O1xuIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xuIHZhciBpbmRleCA9IDA7XG4gdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dCwgdmFsdWU7XG4gaWYgKG1hcHBpbmcpXG4gIG1hcGZuID0gYmluZChtYXBmbiwgYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gaWYgKGl0ZXJhdG9yTWV0aG9kICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkpIHtcbiAgaXRlcmF0b3IgPSBpdGVyYXRvck1ldGhvZC5jYWxsKE8pO1xuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgcmVzdWx0ID0gbmV3IEMoKTtcbiAgZm9yICg7ICEoc3RlcCA9IG5leHQuY2FsbChpdGVyYXRvcikpLmRvbmU7IGluZGV4KyspIHtcbiAgIHZhbHVlID0gbWFwcGluZyA/IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIG1hcGZuLCBbXG4gICAgc3RlcC52YWx1ZSxcbiAgICBpbmRleFxuICAgXSwgdHJ1ZSkgOiBzdGVwLnZhbHVlO1xuICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICB9XG4gfSBlbHNlIHtcbiAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICByZXN1bHQgPSBuZXcgQyhsZW5ndGgpO1xuICBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgIHZhbHVlID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgfVxuIH1cbiByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKiovIH0pLFxuLyogMTE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNyk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd19wZGZqc19yZXF1aXJlX18oODApO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgRU5UUklFUykge1xuIHRyeSB7XG4gIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgaXRlcmF0b3JDbG9zZShpdGVyYXRvcik7XG4gIHRocm93IGVycm9yO1xuIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgbWF4SW50ID0gMjE0NzQ4MzY0NztcbnZhciBiYXNlID0gMzY7XG52YXIgdE1pbiA9IDE7XG52YXIgdE1heCA9IDI2O1xudmFyIHNrZXcgPSAzODtcbnZhciBkYW1wID0gNzAwO1xudmFyIGluaXRpYWxCaWFzID0gNzI7XG52YXIgaW5pdGlhbE4gPSAxMjg7XG52YXIgZGVsaW1pdGVyID0gJy0nO1xudmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXDAtXFx1MDA3RV0vO1xudmFyIHJlZ2V4U2VwYXJhdG9ycyA9IC9bLlxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZztcbnZhciBPVkVSRkxPV19FUlJPUiA9ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2Vzcyc7XG52YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIHVjczJkZWNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gdmFyIG91dHB1dCA9IFtdO1xuIHZhciBjb3VudGVyID0gMDtcbiB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICB2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICBpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICB2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgaWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG4gICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcbiAgIH0gZWxzZSB7XG4gICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgIGNvdW50ZXItLTtcbiAgIH1cbiAgfSBlbHNlIHtcbiAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgfVxuIH1cbiByZXR1cm4gb3V0cHV0O1xufTtcbnZhciBkaWdpdFRvQmFzaWMgPSBmdW5jdGlvbiAoZGlnaXQpIHtcbiByZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpO1xufTtcbnZhciBhZGFwdCA9IGZ1bmN0aW9uIChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiB2YXIgayA9IDA7XG4gZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcbiBkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG4gZm9yICg7IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG4gIGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcbiB9XG4gcmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG59O1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuIHZhciBvdXRwdXQgPSBbXTtcbiBpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiB2YXIgbiA9IGluaXRpYWxOO1xuIHZhciBkZWx0YSA9IDA7XG4gdmFyIGJpYXMgPSBpbml0aWFsQmlhcztcbiB2YXIgaSwgY3VycmVudFZhbHVlO1xuIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICBjdXJyZW50VmFsdWUgPSBpbnB1dFtpXTtcbiAgaWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcbiAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcbiAgfVxuIH1cbiB2YXIgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuIHZhciBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuIGlmIChiYXNpY0xlbmd0aCkge1xuICBvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuIH1cbiB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuICB2YXIgbSA9IG1heEludDtcbiAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICBjdXJyZW50VmFsdWUgPSBpbnB1dFtpXTtcbiAgIGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG4gICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgIH1cbiAgfVxuICB2YXIgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuICBpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuICAgdGhyb3cgUmFuZ2VFcnJvcihPVkVSRkxPV19FUlJPUik7XG4gIH1cbiAgZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcbiAgbiA9IG07XG4gIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICBpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG4gICAgdGhyb3cgUmFuZ2VFcnJvcihPVkVSRkxPV19FUlJPUik7XG4gICB9XG4gICBpZiAoY3VycmVudFZhbHVlID09IG4pIHtcbiAgICB2YXIgcSA9IGRlbHRhO1xuICAgIGZvciAodmFyIGsgPSBiYXNlOzsgayArPSBiYXNlKSB7XG4gICAgIHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG4gICAgIGlmIChxIDwgdClcbiAgICAgIGJyZWFrO1xuICAgICB2YXIgcU1pbnVzVCA9IHEgLSB0O1xuICAgICB2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCkpKTtcbiAgICAgcSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcbiAgICB9XG4gICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxKSkpO1xuICAgIGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG4gICAgZGVsdGEgPSAwO1xuICAgICsraGFuZGxlZENQQ291bnQ7XG4gICB9XG4gIH1cbiAgKytkZWx0YTtcbiAgKytuO1xuIH1cbiByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gdmFyIGVuY29kZWQgPSBbXTtcbiB2YXIgbGFiZWxzID0gaW5wdXQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xcdTAwMkUnKS5zcGxpdCgnLicpO1xuIHZhciBpLCBsYWJlbDtcbiBmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gIGxhYmVsID0gbGFiZWxzW2ldO1xuICBlbmNvZGVkLnB1c2gocmVnZXhOb25BU0NJSS50ZXN0KGxhYmVsKSA/ICd4bi0tJyArIGVuY29kZShsYWJlbCkgOiBsYWJlbCk7XG4gfVxuIHJldHVybiBlbmNvZGVkLmpvaW4oJy4nKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oNTMpO1xudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkpO1xudmFyIGdldEJ1aWx0SW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQxKTtcbnZhciBVU0VfTkFUSVZFX1VSTCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEzKTtcbnZhciByZWRlZmluZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjgpO1xudmFyIHJlZGVmaW5lQWxsID0gX193X3BkZmpzX3JlcXVpcmVfXyg4OCk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY5KTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXyg2NCk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzIpO1xudmFyIGFuSW5zdGFuY2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkwKTtcbnZhciBoYXNPd24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyKTtcbnZhciBiaW5kID0gX193X3BkZmpzX3JlcXVpcmVfXyg3NSk7XG52YXIgY2xhc3NvZiA9IF9fd19wZGZqc19yZXF1aXJlX18oNzgpO1xudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNyk7XG52YXIgaXNPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcbnZhciBjcmVhdGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU4KTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1KTtcbnZhciBnZXRJdGVyYXRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTE5KTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IF9fd19wZGZqc19yZXF1aXJlX18oNzcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTUpO1xudmFyICRmZXRjaCA9IGdldEJ1aWx0SW4oJ2ZldGNoJyk7XG52YXIgSGVhZGVycyA9IGdldEJ1aWx0SW4oJ0hlYWRlcnMnKTtcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBVUkxfU0VBUkNIX1BBUkFNUyA9ICdVUkxTZWFyY2hQYXJhbXMnO1xudmFyIFVSTF9TRUFSQ0hfUEFSQU1TX0lURVJBVE9SID0gVVJMX1NFQVJDSF9QQVJBTVMgKyAnSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoVVJMX1NFQVJDSF9QQVJBTVMpO1xudmFyIGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFVSTF9TRUFSQ0hfUEFSQU1TX0lURVJBVE9SKTtcbnZhciBwbHVzID0gL1xcKy9nO1xudmFyIHNlcXVlbmNlcyA9IEFycmF5KDQpO1xudmFyIHBlcmNlbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uIChieXRlcykge1xuIHJldHVybiBzZXF1ZW5jZXNbYnl0ZXMgLSAxXSB8fCAoc2VxdWVuY2VzW2J5dGVzIC0gMV0gPSBSZWdFeHAoJygoPzolW1xcXFxkYS1mXXsyfSl7JyArIGJ5dGVzICsgJ30pJywgJ2dpJykpO1xufTtcbnZhciBwZXJjZW50RGVjb2RlID0gZnVuY3Rpb24gKHNlcXVlbmNlKSB7XG4gdHJ5IHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzZXF1ZW5jZSk7XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgcmV0dXJuIHNlcXVlbmNlO1xuIH1cbn07XG52YXIgZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoaXQpIHtcbiB2YXIgcmVzdWx0ID0gaXQucmVwbGFjZShwbHVzLCAnICcpO1xuIHZhciBieXRlcyA9IDQ7XG4gdHJ5IHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChyZXN1bHQpO1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gIHdoaWxlIChieXRlcykge1xuICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UocGVyY2VudFNlcXVlbmNlKGJ5dGVzLS0pLCBwZXJjZW50RGVjb2RlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xuIH1cbn07XG52YXIgZmluZCA9IC9bIScoKX5dfCUyMC9nO1xudmFyIHJlcGxhY2UgPSB7XG4gJyEnOiAnJTIxJyxcbiBcIidcIjogJyUyNycsXG4gJygnOiAnJTI4JyxcbiAnKSc6ICclMjknLFxuICd+JzogJyU3RScsXG4gJyUyMCc6ICcrJ1xufTtcbnZhciByZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xuIHJldHVybiByZXBsYWNlW21hdGNoXTtcbn07XG52YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChpdCkucmVwbGFjZShmaW5kLCByZXBsYWNlcik7XG59O1xudmFyIHBhcnNlU2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKHJlc3VsdCwgcXVlcnkpIHtcbiBpZiAocXVlcnkpIHtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBxdWVyeS5zcGxpdCgnJicpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgYXR0cmlidXRlLCBlbnRyeTtcbiAgd2hpbGUgKGluZGV4IDwgYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaW5kZXgrK107XG4gICBpZiAoYXR0cmlidXRlLmxlbmd0aCkge1xuICAgIGVudHJ5ID0gYXR0cmlidXRlLnNwbGl0KCc9Jyk7XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICBrZXk6IGRlc2VyaWFsaXplKGVudHJ5LnNoaWZ0KCkpLFxuICAgICB2YWx1ZTogZGVzZXJpYWxpemUoZW50cnkuam9pbignPScpKVxuICAgIH0pO1xuICAgfVxuICB9XG4gfVxufTtcbnZhciB1cGRhdGVTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiB0aGlzLmVudHJpZXMubGVuZ3RoID0gMDtcbiBwYXJzZVNlYXJjaFBhcmFtcyh0aGlzLmVudHJpZXMsIHF1ZXJ5KTtcbn07XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSBmdW5jdGlvbiAocGFzc2VkLCByZXF1aXJlZCkge1xuIGlmIChwYXNzZWQgPCByZXF1aXJlZClcbiAgdGhyb3cgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xufTtcbnZhciBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoZnVuY3Rpb24gSXRlcmF0b3IocGFyYW1zLCBraW5kKSB7XG4gc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gIHR5cGU6IFVSTF9TRUFSQ0hfUEFSQU1TX0lURVJBVE9SLFxuICBpdGVyYXRvcjogZ2V0SXRlcmF0b3IoZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZShwYXJhbXMpLmVudHJpZXMpLFxuICBraW5kOiBraW5kXG4gfSk7XG59LCAnSXRlcmF0b3InLCBmdW5jdGlvbiBuZXh0KCkge1xuIHZhciBzdGF0ZSA9IGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSh0aGlzKTtcbiB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gdmFyIHN0ZXAgPSBzdGF0ZS5pdGVyYXRvci5uZXh0KCk7XG4gdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiBpZiAoIXN0ZXAuZG9uZSkge1xuICBzdGVwLnZhbHVlID0ga2luZCA9PT0gJ2tleXMnID8gZW50cnkua2V5IDoga2luZCA9PT0gJ3ZhbHVlcycgPyBlbnRyeS52YWx1ZSA6IFtcbiAgIGVudHJ5LmtleSxcbiAgIGVudHJ5LnZhbHVlXG4gIF07XG4gfVxuIHJldHVybiBzdGVwO1xufSk7XG52YXIgVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBVUkxTZWFyY2hQYXJhbXMoKSB7XG4gYW5JbnN0YW5jZSh0aGlzLCBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvciwgVVJMX1NFQVJDSF9QQVJBTVMpO1xuIHZhciBpbml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG4gdmFyIHRoYXQgPSB0aGlzO1xuIHZhciBlbnRyaWVzID0gW107XG4gdmFyIGl0ZXJhdG9yTWV0aG9kLCBpdGVyYXRvciwgbmV4dCwgc3RlcCwgZW50cnlJdGVyYXRvciwgZW50cnlOZXh0LCBmaXJzdCwgc2Vjb25kLCBrZXk7XG4gc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gIHR5cGU6IFVSTF9TRUFSQ0hfUEFSQU1TLFxuICBlbnRyaWVzOiBlbnRyaWVzLFxuICB1cGRhdGVVUkw6IGZ1bmN0aW9uICgpIHtcbiAgfSxcbiAgdXBkYXRlU2VhcmNoUGFyYW1zOiB1cGRhdGVTZWFyY2hQYXJhbXNcbiB9KTtcbiBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gIGlmIChpc09iamVjdChpbml0KSkge1xuICAgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChpbml0KTtcbiAgIGlmICh0eXBlb2YgaXRlcmF0b3JNZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhdG9yTWV0aG9kLmNhbGwoaW5pdCk7XG4gICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQ7XG4gICAgd2hpbGUgKCEoc3RlcCA9IG5leHQuY2FsbChpdGVyYXRvcikpLmRvbmUpIHtcbiAgICAgZW50cnlJdGVyYXRvciA9IGdldEl0ZXJhdG9yKGFuT2JqZWN0KHN0ZXAudmFsdWUpKTtcbiAgICAgZW50cnlOZXh0ID0gZW50cnlJdGVyYXRvci5uZXh0O1xuICAgICBpZiAoKGZpcnN0ID0gZW50cnlOZXh0LmNhbGwoZW50cnlJdGVyYXRvcikpLmRvbmUgfHwgKHNlY29uZCA9IGVudHJ5TmV4dC5jYWxsKGVudHJ5SXRlcmF0b3IpKS5kb25lIHx8ICFlbnRyeU5leHQuY2FsbChlbnRyeUl0ZXJhdG9yKS5kb25lKVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdFeHBlY3RlZCBzZXF1ZW5jZSB3aXRoIGxlbmd0aCAyJyk7XG4gICAgIGVudHJpZXMucHVzaCh7XG4gICAgICBrZXk6IGZpcnN0LnZhbHVlICsgJycsXG4gICAgICB2YWx1ZTogc2Vjb25kLnZhbHVlICsgJydcbiAgICAgfSk7XG4gICAgfVxuICAgfSBlbHNlXG4gICAgZm9yIChrZXkgaW4gaW5pdClcbiAgICAgaWYgKGhhc093bihpbml0LCBrZXkpKVxuICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICBrZXk6IGtleSxcbiAgICAgICB2YWx1ZTogaW5pdFtrZXldICsgJydcbiAgICAgIH0pO1xuICB9IGVsc2Uge1xuICAgcGFyc2VTZWFyY2hQYXJhbXMoZW50cmllcywgdHlwZW9mIGluaXQgPT09ICdzdHJpbmcnID8gaW5pdC5jaGFyQXQoMCkgPT09ICc/JyA/IGluaXQuc2xpY2UoMSkgOiBpbml0IDogaW5pdCArICcnKTtcbiAgfVxuIH1cbn07XG52YXIgVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlID0gVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IucHJvdG90eXBlO1xucmVkZWZpbmVBbGwoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLCB7XG4gYXBwZW5kOiBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcyk7XG4gIHN0YXRlLmVudHJpZXMucHVzaCh7XG4gICBrZXk6IG5hbWUgKyAnJyxcbiAgIHZhbHVlOiB2YWx1ZSArICcnXG4gIH0pO1xuICBzdGF0ZS51cGRhdGVVUkwoKTtcbiB9LFxuICdkZWxldGUnOiBmdW5jdGlvbiAobmFtZSkge1xuICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgdmFyIGVudHJpZXMgPSBzdGF0ZS5lbnRyaWVzO1xuICB2YXIga2V5ID0gbmFtZSArICcnO1xuICB2YXIgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgaWYgKGVudHJpZXNbaW5kZXhdLmtleSA9PT0ga2V5KVxuICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgIGVsc2VcbiAgICBpbmRleCsrO1xuICB9XG4gIHN0YXRlLnVwZGF0ZVVSTCgpO1xuIH0sXG4gZ2V0OiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gIHZhciBrZXkgPSBuYW1lICsgJyc7XG4gIHZhciBpbmRleCA9IDA7XG4gIGZvciAoOyBpbmRleCA8IGVudHJpZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICBpZiAoZW50cmllc1tpbmRleF0ua2V5ID09PSBrZXkpXG4gICAgcmV0dXJuIGVudHJpZXNbaW5kZXhdLnZhbHVlO1xuICB9XG4gIHJldHVybiBudWxsO1xuIH0sXG4gZ2V0QWxsOiBmdW5jdGlvbiBnZXRBbGwobmFtZSkge1xuICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gIHZhciBrZXkgPSBuYW1lICsgJyc7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgZm9yICg7IGluZGV4IDwgZW50cmllcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgIGlmIChlbnRyaWVzW2luZGV4XS5rZXkgPT09IGtleSlcbiAgICByZXN1bHQucHVzaChlbnRyaWVzW2luZGV4XS52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbiB9LFxuIGhhczogZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICB2YXIga2V5ID0gbmFtZSArICcnO1xuICB2YXIgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgaWYgKGVudHJpZXNbaW5kZXgrK10ua2V5ID09PSBrZXkpXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xuIH0sXG4gc2V0OiBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUpIHtcbiAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcyk7XG4gIHZhciBlbnRyaWVzID0gc3RhdGUuZW50cmllcztcbiAgdmFyIGZvdW5kID0gZmFsc2U7XG4gIHZhciBrZXkgPSBuYW1lICsgJyc7XG4gIHZhciB2YWwgPSB2YWx1ZSArICcnO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgZW50cnk7XG4gIGZvciAoOyBpbmRleCA8IGVudHJpZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgaWYgKGVudHJ5LmtleSA9PT0ga2V5KSB7XG4gICAgaWYgKGZvdW5kKVxuICAgICBlbnRyaWVzLnNwbGljZShpbmRleC0tLCAxKTtcbiAgICBlbHNlIHtcbiAgICAgZm91bmQgPSB0cnVlO1xuICAgICBlbnRyeS52YWx1ZSA9IHZhbDtcbiAgICB9XG4gICB9XG4gIH1cbiAgaWYgKCFmb3VuZClcbiAgIGVudHJpZXMucHVzaCh7XG4gICAga2V5OiBrZXksXG4gICAgdmFsdWU6IHZhbFxuICAgfSk7XG4gIHN0YXRlLnVwZGF0ZVVSTCgpO1xuIH0sXG4gc29ydDogZnVuY3Rpb24gc29ydCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgdmFyIGVudHJpZXMgPSBzdGF0ZS5lbnRyaWVzO1xuICB2YXIgc2xpY2UgPSBlbnRyaWVzLnNsaWNlKCk7XG4gIHZhciBlbnRyeSwgZW50cmllc0luZGV4LCBzbGljZUluZGV4O1xuICBlbnRyaWVzLmxlbmd0aCA9IDA7XG4gIGZvciAoc2xpY2VJbmRleCA9IDA7IHNsaWNlSW5kZXggPCBzbGljZS5sZW5ndGg7IHNsaWNlSW5kZXgrKykge1xuICAgZW50cnkgPSBzbGljZVtzbGljZUluZGV4XTtcbiAgIGZvciAoZW50cmllc0luZGV4ID0gMDsgZW50cmllc0luZGV4IDwgc2xpY2VJbmRleDsgZW50cmllc0luZGV4KyspIHtcbiAgICBpZiAoZW50cmllc1tlbnRyaWVzSW5kZXhdLmtleSA+IGVudHJ5LmtleSkge1xuICAgICBlbnRyaWVzLnNwbGljZShlbnRyaWVzSW5kZXgsIDAsIGVudHJ5KTtcbiAgICAgYnJlYWs7XG4gICAgfVxuICAgfVxuICAgaWYgKGVudHJpZXNJbmRleCA9PT0gc2xpY2VJbmRleClcbiAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG4gIHN0YXRlLnVwZGF0ZVVSTCgpO1xuIH0sXG4gZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaykge1xuICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBlbnRyeTtcbiAgd2hpbGUgKGluZGV4IDwgZW50cmllcy5sZW5ndGgpIHtcbiAgIGVudHJ5ID0gZW50cmllc1tpbmRleCsrXTtcbiAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG4gIH1cbiB9LFxuIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ2tleXMnKTtcbiB9LFxuIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yKHRoaXMsICd2YWx1ZXMnKTtcbiB9LFxuIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ2VudHJpZXMnKTtcbiB9XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5yZWRlZmluZShVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsIElURVJBVE9SLCBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUuZW50cmllcyk7XG5yZWRlZmluZShVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuIHZhciByZXN1bHQgPSBbXTtcbiB2YXIgaW5kZXggPSAwO1xuIHZhciBlbnRyeTtcbiB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICBlbnRyeSA9IGVudHJpZXNbaW5kZXgrK107XG4gIHJlc3VsdC5wdXNoKHNlcmlhbGl6ZShlbnRyeS5rZXkpICsgJz0nICsgc2VyaWFsaXplKGVudHJ5LnZhbHVlKSk7XG4gfVxuIHJldHVybiByZXN1bHQuam9pbignJicpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuc2V0VG9TdHJpbmdUYWcoVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IsIFVSTF9TRUFSQ0hfUEFSQU1TKTtcbiQoe1xuIGdsb2JhbDogdHJ1ZSxcbiBmb3JjZWQ6ICFVU0VfTkFUSVZFX1VSTFxufSwgeyBVUkxTZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yIH0pO1xuaWYgKCFVU0VfTkFUSVZFX1VSTCAmJiB0eXBlb2YgJGZldGNoID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIEhlYWRlcnMgPT0gJ2Z1bmN0aW9uJykge1xuICQoe1xuICBnbG9iYWw6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGZvcmNlZDogdHJ1ZVxuIH0sIHtcbiAgZmV0Y2g6IGZ1bmN0aW9uIGZldGNoKGlucHV0KSB7XG4gICB2YXIgYXJncyA9IFtpbnB1dF07XG4gICB2YXIgaW5pdCwgYm9keSwgaGVhZGVycztcbiAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGluaXQgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGlzT2JqZWN0KGluaXQpKSB7XG4gICAgIGJvZHkgPSBpbml0LmJvZHk7XG4gICAgIGlmIChjbGFzc29mKGJvZHkpID09PSBVUkxfU0VBUkNIX1BBUkFNUykge1xuICAgICAgaGVhZGVycyA9IGluaXQuaGVhZGVycyA/IG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycykgOiBuZXcgSGVhZGVycygpO1xuICAgICAgaWYgKCFoZWFkZXJzLmhhcygnY29udGVudC10eXBlJykpIHtcbiAgICAgICBoZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICB9XG4gICAgICBpbml0ID0gY3JlYXRlKGluaXQsIHtcbiAgICAgICBib2R5OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgU3RyaW5nKGJvZHkpKSxcbiAgICAgICBoZWFkZXJzOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgaGVhZGVycylcbiAgICAgIH0pO1xuICAgICB9XG4gICAgfVxuICAgIGFyZ3MucHVzaChpbml0KTtcbiAgIH1cbiAgIHJldHVybiAkZmV0Y2guYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbiB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuIFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IsXG4gZ2V0U3RhdGU6IGdldEludGVybmFsUGFyYW1zU3RhdGVcbn07XG5cbi8qKiovIH0pLFxuLyogMTE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc3KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoaXQpO1xuIGlmICh0eXBlb2YgaXRlcmF0b3JNZXRob2QgIT0gJ2Z1bmN0aW9uJykge1xuICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG4gfVxuIHJldHVybiBhbk9iamVjdChpdGVyYXRvck1ldGhvZC5jYWxsKGl0KSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDEyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXyg5KTtcbiQoe1xuIHRhcmdldDogJ1VSTCcsXG4gcHJvdG86IHRydWUsXG4gZW51bWVyYWJsZTogdHJ1ZVxufSwge1xuIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4gVVJMLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpO1xuIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHRydWUgPyBmYWN0b3J5KGV4cG9ydHMpIDogMDtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAndXNlIHN0cmljdCc7XG4gdmFyIFN5bWJvbFBvbHlmaWxsID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJyA/IFN5bWJvbCA6IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICByZXR1cm4gXCJTeW1ib2woXCIgKyBkZXNjcmlwdGlvbiArIFwiKVwiO1xuIH07XG4gZnVuY3Rpb24gbm9vcCgpIHtcbiB9XG4gZnVuY3Rpb24gZ2V0R2xvYmFscygpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgcmV0dXJuIHNlbGY7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgIHJldHVybiB3aW5kb3c7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgIHJldHVybiBnbG9iYWw7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbiB9XG4gdmFyIGdsb2JhbHMgPSBnZXRHbG9iYWxzKCk7XG4gZnVuY3Rpb24gdHlwZUlzT2JqZWN0KHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuIH1cbiB2YXIgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uID0gbm9vcDtcbiB2YXIgb3JpZ2luYWxQcm9taXNlID0gUHJvbWlzZTtcbiB2YXIgb3JpZ2luYWxQcm9taXNlVGhlbiA9IFByb21pc2UucHJvdG90eXBlLnRoZW47XG4gdmFyIG9yaWdpbmFsUHJvbWlzZVJlc29sdmUgPSBQcm9taXNlLnJlc29sdmUuYmluZChvcmlnaW5hbFByb21pc2UpO1xuIHZhciBvcmlnaW5hbFByb21pc2VSZWplY3QgPSBQcm9taXNlLnJlamVjdC5iaW5kKG9yaWdpbmFsUHJvbWlzZSk7XG4gZnVuY3Rpb24gbmV3UHJvbWlzZShleGVjdXRvcikge1xuICByZXR1cm4gbmV3IG9yaWdpbmFsUHJvbWlzZShleGVjdXRvcik7XG4gfVxuIGZ1bmN0aW9uIHByb21pc2VSZXNvbHZlZFdpdGgodmFsdWUpIHtcbiAgcmV0dXJuIG9yaWdpbmFsUHJvbWlzZVJlc29sdmUodmFsdWUpO1xuIH1cbiBmdW5jdGlvbiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYXNvbikge1xuICByZXR1cm4gb3JpZ2luYWxQcm9taXNlUmVqZWN0KHJlYXNvbik7XG4gfVxuIGZ1bmN0aW9uIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICByZXR1cm4gb3JpZ2luYWxQcm9taXNlVGhlbi5jYWxsKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiB9XG4gZnVuY3Rpb24gdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgUGVyZm9ybVByb21pc2VUaGVuKFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCksIHVuZGVmaW5lZCwgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uKTtcbiB9XG4gZnVuY3Rpb24gdXBvbkZ1bGZpbGxtZW50KHByb21pc2UsIG9uRnVsZmlsbGVkKSB7XG4gIHVwb25Qcm9taXNlKHByb21pc2UsIG9uRnVsZmlsbGVkKTtcbiB9XG4gZnVuY3Rpb24gdXBvblJlamVjdGlvbihwcm9taXNlLCBvblJlamVjdGVkKSB7XG4gIHVwb25Qcm9taXNlKHByb21pc2UsIHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gfVxuIGZ1bmN0aW9uIHRyYW5zZm9ybVByb21pc2VXaXRoKHByb21pc2UsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICByZXR1cm4gUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gfVxuIGZ1bmN0aW9uIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocHJvbWlzZSkge1xuICBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgdW5kZWZpbmVkLCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pO1xuIH1cbiB2YXIgcXVldWVNaWNyb3Rhc2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBnbG9iYWxRdWV1ZU1pY3JvdGFzayA9IGdsb2JhbHMgJiYgZ2xvYmFscy5xdWV1ZU1pY3JvdGFzaztcbiAgaWYgKHR5cGVvZiBnbG9iYWxRdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgcmV0dXJuIGdsb2JhbFF1ZXVlTWljcm90YXNrO1xuICB9XG4gIHZhciByZXNvbHZlZFByb21pc2UgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4ocmVzb2x2ZWRQcm9taXNlLCBmbik7XG4gIH07XG4gfSgpO1xuIGZ1bmN0aW9uIHJlZmxlY3RDYWxsKEYsIFYsIGFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBGICE9PSAnZnVuY3Rpb24nKSB7XG4gICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChGLCBWLCBhcmdzKTtcbiB9XG4gZnVuY3Rpb24gcHJvbWlzZUNhbGwoRiwgViwgYXJncykge1xuICB0cnkge1xuICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgocmVmbGVjdENhbGwoRiwgViwgYXJncykpO1xuICB9IGNhdGNoICh2YWx1ZSkge1xuICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodmFsdWUpO1xuICB9XG4gfVxuIHZhciBRVUVVRV9NQVhfQVJSQVlfU0laRSA9IDE2Mzg0O1xuIHZhciBTaW1wbGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2ltcGxlUXVldWUoKSB7XG4gICB0aGlzLl9jdXJzb3IgPSAwO1xuICAgdGhpcy5fc2l6ZSA9IDA7XG4gICB0aGlzLl9mcm9udCA9IHtcbiAgICBfZWxlbWVudHM6IFtdLFxuICAgIF9uZXh0OiB1bmRlZmluZWRcbiAgIH07XG4gICB0aGlzLl9iYWNrID0gdGhpcy5fZnJvbnQ7XG4gICB0aGlzLl9jdXJzb3IgPSAwO1xuICAgdGhpcy5fc2l6ZSA9IDA7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVF1ZXVlLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICB9LFxuICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIFNpbXBsZVF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgIHZhciBvbGRCYWNrID0gdGhpcy5fYmFjaztcbiAgIHZhciBuZXdCYWNrID0gb2xkQmFjaztcbiAgIGlmIChvbGRCYWNrLl9lbGVtZW50cy5sZW5ndGggPT09IFFVRVVFX01BWF9BUlJBWV9TSVpFIC0gMSkge1xuICAgIG5ld0JhY2sgPSB7XG4gICAgIF9lbGVtZW50czogW10sXG4gICAgIF9uZXh0OiB1bmRlZmluZWRcbiAgICB9O1xuICAgfVxuICAgb2xkQmFjay5fZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgIGlmIChuZXdCYWNrICE9PSBvbGRCYWNrKSB7XG4gICAgdGhpcy5fYmFjayA9IG5ld0JhY2s7XG4gICAgb2xkQmFjay5fbmV4dCA9IG5ld0JhY2s7XG4gICB9XG4gICArK3RoaXMuX3NpemU7XG4gIH07XG4gIFNpbXBsZVF1ZXVlLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgIHZhciBvbGRGcm9udCA9IHRoaXMuX2Zyb250O1xuICAgdmFyIG5ld0Zyb250ID0gb2xkRnJvbnQ7XG4gICB2YXIgb2xkQ3Vyc29yID0gdGhpcy5fY3Vyc29yO1xuICAgdmFyIG5ld0N1cnNvciA9IG9sZEN1cnNvciArIDE7XG4gICB2YXIgZWxlbWVudHMgPSBvbGRGcm9udC5fZWxlbWVudHM7XG4gICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW29sZEN1cnNvcl07XG4gICBpZiAobmV3Q3Vyc29yID09PSBRVUVVRV9NQVhfQVJSQVlfU0laRSkge1xuICAgIG5ld0Zyb250ID0gb2xkRnJvbnQuX25leHQ7XG4gICAgbmV3Q3Vyc29yID0gMDtcbiAgIH1cbiAgIC0tdGhpcy5fc2l6ZTtcbiAgIHRoaXMuX2N1cnNvciA9IG5ld0N1cnNvcjtcbiAgIGlmIChvbGRGcm9udCAhPT0gbmV3RnJvbnQpIHtcbiAgICB0aGlzLl9mcm9udCA9IG5ld0Zyb250O1xuICAgfVxuICAgZWxlbWVudHNbb2xkQ3Vyc29yXSA9IHVuZGVmaW5lZDtcbiAgIHJldHVybiBlbGVtZW50O1xuICB9O1xuICBTaW1wbGVRdWV1ZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgdmFyIGkgPSB0aGlzLl9jdXJzb3I7XG4gICB2YXIgbm9kZSA9IHRoaXMuX2Zyb250O1xuICAgdmFyIGVsZW1lbnRzID0gbm9kZS5fZWxlbWVudHM7XG4gICB3aGlsZSAoaSAhPT0gZWxlbWVudHMubGVuZ3RoIHx8IG5vZGUuX25leHQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpID09PSBlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgbm9kZSA9IG5vZGUuX25leHQ7XG4gICAgIGVsZW1lbnRzID0gbm9kZS5fZWxlbWVudHM7XG4gICAgIGkgPSAwO1xuICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICAgfVxuICAgIH1cbiAgICBjYWxsYmFjayhlbGVtZW50c1tpXSk7XG4gICAgKytpO1xuICAgfVxuICB9O1xuICBTaW1wbGVRdWV1ZS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgdmFyIGN1cnNvciA9IHRoaXMuX2N1cnNvcjtcbiAgIHJldHVybiBmcm9udC5fZWxlbWVudHNbY3Vyc29yXTtcbiAgfTtcbiAgcmV0dXJuIFNpbXBsZVF1ZXVlO1xuIH0oKTtcbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHJlYWRlciwgc3RyZWFtKSB7XG4gIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9IHN0cmVhbTtcbiAgc3RyZWFtLl9yZWFkZXIgPSByZWFkZXI7XG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAncmVhZGFibGUnKSB7XG4gICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKTtcbiAgfSBlbHNlIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZChyZWFkZXIpO1xuICB9IGVsc2Uge1xuICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZChyZWFkZXIsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbChyZWFkZXIsIHJlYXNvbikge1xuICB2YXIgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcikge1xuICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCBuZXcgVHlwZUVycm9yKFwiUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NcIikpO1xuICB9IGVsc2Uge1xuICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQocmVhZGVyLCBuZXcgVHlwZUVycm9yKFwiUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NcIikpO1xuICB9XG4gIHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbS5fcmVhZGVyID0gdW5kZWZpbmVkO1xuICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPSB1bmRlZmluZWQ7XG4gfVxuIGZ1bmN0aW9uIHJlYWRlckxvY2tFeGNlcHRpb24obmFtZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQ2Fubm90ICcgKyBuYW1lICsgJyBhIHN0cmVhbSB1c2luZyBhIHJlbGVhc2VkIHJlYWRlcicpO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKSB7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZSA9IG5ld1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcbiAgfSk7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCByZWFzb24pIHtcbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgcmVhc29uKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZChyZWFkZXIpIHtcbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIHJlYXNvbikge1xuICBpZiAocmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICByZXR1cm47XG4gIH1cbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShyZWFkZXIuX2Nsb3NlZFByb21pc2UpO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZChyZWFkZXIsIHJlYXNvbikge1xuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgcmVhc29uKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcikge1xuICBpZiAocmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuO1xuICB9XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuIH1cbiB2YXIgQWJvcnRTdGVwcyA9IFN5bWJvbFBvbHlmaWxsKCdbW0Fib3J0U3RlcHNdXScpO1xuIHZhciBFcnJvclN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbRXJyb3JTdGVwc11dJyk7XG4gdmFyIENhbmNlbFN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbQ2FuY2VsU3RlcHNdXScpO1xuIHZhciBQdWxsU3RlcHMgPSBTeW1ib2xQb2x5ZmlsbCgnW1tQdWxsU3RlcHNdXScpO1xuIHZhciBOdW1iZXJJc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmIGlzRmluaXRlKHgpO1xuIH07XG4gdmFyIE1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcbiAgcmV0dXJuIHYgPCAwID8gTWF0aC5jZWlsKHYpIDogTWF0aC5mbG9vcih2KTtcbiB9O1xuIGZ1bmN0aW9uIGlzRGljdGlvbmFyeSh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gfVxuIGZ1bmN0aW9uIGFzc2VydERpY3Rpb25hcnkob2JqLCBjb250ZXh0KSB7XG4gIGlmIChvYmogIT09IHVuZGVmaW5lZCAmJiAhaXNEaWN0aW9uYXJ5KG9iaikpIHtcbiAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29udGV4dCArIFwiIGlzIG5vdCBhbiBvYmplY3QuXCIpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKHgsIGNvbnRleHQpIHtcbiAgaWYgKHR5cGVvZiB4ICE9PSAnZnVuY3Rpb24nKSB7XG4gICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvbnRleHQgKyBcIiBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gIH1cbiB9XG4gZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gfVxuIGZ1bmN0aW9uIGFzc2VydE9iamVjdCh4LCBjb250ZXh0KSB7XG4gIGlmICghaXNPYmplY3QoeCkpIHtcbiAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29udGV4dCArIFwiIGlzIG5vdCBhbiBvYmplY3QuXCIpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoeCwgcG9zaXRpb24sIGNvbnRleHQpIHtcbiAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciBcIiArIHBvc2l0aW9uICsgXCIgaXMgcmVxdWlyZWQgaW4gJ1wiICsgY29udGV4dCArIFwiJy5cIik7XG4gIH1cbiB9XG4gZnVuY3Rpb24gYXNzZXJ0UmVxdWlyZWRGaWVsZCh4LCBmaWVsZCwgY29udGV4dCkge1xuICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICB0aHJvdyBuZXcgVHlwZUVycm9yKGZpZWxkICsgXCIgaXMgcmVxdWlyZWQgaW4gJ1wiICsgY29udGV4dCArIFwiJy5cIik7XG4gIH1cbiB9XG4gZnVuY3Rpb24gY29udmVydFVucmVzdHJpY3RlZERvdWJsZSh2YWx1ZSkge1xuICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiB9XG4gZnVuY3Rpb24gY2Vuc29yTmVnYXRpdmVaZXJvKHgpIHtcbiAgcmV0dXJuIHggPT09IDAgPyAwIDogeDtcbiB9XG4gZnVuY3Rpb24gaW50ZWdlclBhcnQoeCkge1xuICByZXR1cm4gY2Vuc29yTmVnYXRpdmVaZXJvKE1hdGhUcnVuYyh4KSk7XG4gfVxuIGZ1bmN0aW9uIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSh2YWx1ZSwgY29udGV4dCkge1xuICB2YXIgbG93ZXJCb3VuZCA9IDA7XG4gIHZhciB1cHBlckJvdW5kID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gIHZhciB4ID0gTnVtYmVyKHZhbHVlKTtcbiAgeCA9IGNlbnNvck5lZ2F0aXZlWmVybyh4KTtcbiAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSkge1xuICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb250ZXh0ICsgXCIgaXMgbm90IGEgZmluaXRlIG51bWJlclwiKTtcbiAgfVxuICB4ID0gaW50ZWdlclBhcnQoeCk7XG4gIGlmICh4IDwgbG93ZXJCb3VuZCB8fCB4ID4gdXBwZXJCb3VuZCkge1xuICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb250ZXh0ICsgXCIgaXMgb3V0c2lkZSB0aGUgYWNjZXB0ZWQgcmFuZ2Ugb2YgXCIgKyBsb3dlckJvdW5kICsgXCIgdG8gXCIgKyB1cHBlckJvdW5kICsgXCIsIGluY2x1c2l2ZVwiKTtcbiAgfVxuICBpZiAoIU51bWJlcklzRmluaXRlKHgpIHx8IHggPT09IDApIHtcbiAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB4O1xuIH1cbiBmdW5jdGlvbiBhc3NlcnRSZWFkYWJsZVN0cmVhbSh4LCBjb250ZXh0KSB7XG4gIGlmICghSXNSZWFkYWJsZVN0cmVhbSh4KSkge1xuICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb250ZXh0ICsgXCIgaXMgbm90IGEgUmVhZGFibGVTdHJlYW0uXCIpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQWRkUmVhZFJlcXVlc3Qoc3RyZWFtLCByZWFkUmVxdWVzdCkge1xuICBzdHJlYW0uX3JlYWRlci5fcmVhZFJlcXVlc3RzLnB1c2gocmVhZFJlcXVlc3QpO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGNodW5rLCBkb25lKSB7XG4gIHZhciByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgdmFyIHJlYWRSZXF1ZXN0ID0gcmVhZGVyLl9yZWFkUmVxdWVzdHMuc2hpZnQoKTtcbiAgaWYgKGRvbmUpIHtcbiAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG4gIH0gZWxzZSB7XG4gICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG4gIH1cbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uX3JlYWRlci5fcmVhZFJlcXVlc3RzLmxlbmd0aDtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkge1xuICB2YXIgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiB2YXIgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKSB7XG4gICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcicpO1xuICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyJyk7XG4gICB9XG4gICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG4gICB0aGlzLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZSwgXCJjbG9zZWRcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICBpZiAocmVhc29uID09PSB2b2lkIDApIHtcbiAgICByZWFzb24gPSB1bmRlZmluZWQ7XG4gICB9XG4gICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgIH1cbiAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICB9XG4gICByZXR1cm4gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gIH07XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZCcpKTtcbiAgIH1cbiAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdyZWFkIGZyb20nKSk7XG4gICB9XG4gICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gICB2YXIgcmVqZWN0UHJvbWlzZTtcbiAgIHZhciBwcm9taXNlID0gbmV3UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgIHJlamVjdFByb21pc2UgPSByZWplY3Q7XG4gICB9KTtcbiAgIHZhciByZWFkUmVxdWVzdCA9IHtcbiAgICBfY2h1bmtTdGVwczogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgIHJldHVybiByZXNvbHZlUHJvbWlzZSh7XG4gICAgICB2YWx1ZTogY2h1bmssXG4gICAgICBkb25lOiBmYWxzZVxuICAgICB9KTtcbiAgICB9LFxuICAgIF9jbG9zZVN0ZXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgIHJldHVybiByZXNvbHZlUHJvbWlzZSh7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgICB9KTtcbiAgICB9LFxuICAgIF9lcnJvclN0ZXBzOiBmdW5jdGlvbiAoZSkge1xuICAgICByZXR1cm4gcmVqZWN0UHJvbWlzZShlKTtcbiAgICB9XG4gICB9O1xuICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCh0aGlzLCByZWFkUmVxdWVzdCk7XG4gICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZS5yZWxlYXNlTG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICB0aHJvdyBkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgIH1cbiAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gICB9XG4gICBpZiAodGhpcy5fcmVhZFJlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUcmllZCB0byByZWxlYXNlIGEgcmVhZGVyIGxvY2sgd2hlbiB0aGF0IHJlYWRlciBoYXMgcGVuZGluZyByZWFkKCkgY2FsbHMgdW4tc2V0dGxlZCcpO1xuICAgfVxuICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSh0aGlzKTtcbiAgfTtcbiAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjtcbiB9KCk7XG4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZSwge1xuICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICByZWFkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcmVsZWFzZUxvY2s6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gfSk7XG4gaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcicsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gfVxuIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHgpIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3JlYWRSZXF1ZXN0cycpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCkge1xuICB2YXIgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcbiAgfSBlbHNlIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9IGVsc2Uge1xuICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCk7XG4gIH1cbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUuXCIgKyBuYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclwiKTtcbiB9XG4gdmFyIF9hO1xuIHZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlO1xuIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwuYXN5bmNJdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IChfYSA9IHt9LCBfYVtTeW1ib2xQb2x5ZmlsbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzO1xuICB9LCBfYSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3luY0l0ZXJhdG9yUHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC5hc3luY0l0ZXJhdG9yLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xuIH1cbiB2YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbChyZWFkZXIsIHByZXZlbnRDYW5jZWwpIHtcbiAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgdGhpcy5faXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xuICAgdGhpcy5fcHJldmVudENhbmNlbCA9IHByZXZlbnRDYW5jZWw7XG4gIH1cbiAgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICB2YXIgbmV4dFN0ZXBzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcy5fbmV4dFN0ZXBzKCk7XG4gICB9O1xuICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/IHRyYW5zZm9ybVByb21pc2VXaXRoKHRoaXMuX29uZ29pbmdQcm9taXNlLCBuZXh0U3RlcHMsIG5leHRTdGVwcykgOiBuZXh0U3RlcHMoKTtcbiAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZTtcbiAgfTtcbiAgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbC5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgdmFyIHJldHVyblN0ZXBzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcy5fcmV0dXJuU3RlcHModmFsdWUpO1xuICAgfTtcbiAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/IHRyYW5zZm9ybVByb21pc2VXaXRoKHRoaXMuX29uZ29pbmdQcm9taXNlLCByZXR1cm5TdGVwcywgcmV0dXJuU3RlcHMpIDogcmV0dXJuU3RlcHMoKTtcbiAgfTtcbiAgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbC5wcm90b3R5cGUuX25leHRTdGVwcyA9IGZ1bmN0aW9uICgpIHtcbiAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICBpZiAodGhpcy5faXNGaW5pc2hlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICBkb25lOiB0cnVlXG4gICAgfSk7XG4gICB9XG4gICB2YXIgcmVhZGVyID0gdGhpcy5fcmVhZGVyO1xuICAgaWYgKHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbignaXRlcmF0ZScpKTtcbiAgIH1cbiAgIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgIHZhciByZWplY3RQcm9taXNlO1xuICAgdmFyIHByb21pc2UgPSBuZXdQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgIH0pO1xuICAgdmFyIHJlYWRSZXF1ZXN0ID0ge1xuICAgIF9jaHVua1N0ZXBzOiBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgX3RoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICBxdWV1ZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVByb21pc2Uoe1xuICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgIH0pO1xuICAgIH0sXG4gICAgX2Nsb3NlU3RlcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgX3RoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICBfdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG4gICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgcmVzb2x2ZVByb21pc2Uoe1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRvbmU6IHRydWVcbiAgICAgfSk7XG4gICAgfSxcbiAgICBfZXJyb3JTdGVwczogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICBfdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgIF90aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICByZWplY3RQcm9taXNlKHJlYXNvbik7XG4gICAgfVxuICAgfTtcbiAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG4gICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbiAgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbC5wcm90b3R5cGUuX3JldHVyblN0ZXBzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICBpZiAodGhpcy5faXNGaW5pc2hlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICB2YWx1ZTogdmFsdWUsXG4gICAgIGRvbmU6IHRydWVcbiAgICB9KTtcbiAgIH1cbiAgIHRoaXMuX2lzRmluaXNoZWQgPSB0cnVlO1xuICAgdmFyIHJlYWRlciA9IHRoaXMuX3JlYWRlcjtcbiAgIGlmIChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2ZpbmlzaCBpdGVyYXRpbmcnKSk7XG4gICB9XG4gICBpZiAoIXRoaXMuX3ByZXZlbnRDYW5jZWwpIHtcbiAgICB2YXIgcmVzdWx0ID0gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHJlYWRlciwgdmFsdWUpO1xuICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgocmVzdWx0LCBmdW5jdGlvbiAoKSB7XG4gICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBkb25lOiB0cnVlXG4gICAgIH07XG4gICAgfSk7XG4gICB9XG4gICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IHRydWVcbiAgIH0pO1xuICB9O1xuICByZXR1cm4gUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbDtcbiB9KCk7XG4gdmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IHtcbiAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKCduZXh0JykpO1xuICAgfVxuICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLm5leHQoKTtcbiAgfSxcbiAgcmV0dXJuOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcykpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1Bc3luY0l0ZXJhdG9yQnJhbmRDaGVja0V4Y2VwdGlvbigncmV0dXJuJykpO1xuICAgfVxuICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLnJldHVybih2YWx1ZSk7XG4gIH1cbiB9O1xuIGlmIChBc3luY0l0ZXJhdG9yUHJvdG90eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG4gfVxuIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtLCBwcmV2ZW50Q2FuY2VsKSB7XG4gIHZhciByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gIHZhciBpbXBsID0gbmV3IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwocmVhZGVyLCBwcmV2ZW50Q2FuY2VsKTtcbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuICBpdGVyYXRvci5fYXN5bmNJdGVyYXRvckltcGwgPSBpbXBsO1xuICByZXR1cm4gaXRlcmF0b3I7XG4gfVxuIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHgpIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2FzeW5jSXRlcmF0b3JJbXBsJykpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvci5cIiArIG5hbWUgKyBcIiBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdGVhbUFzeW5jSXRlcmF0b3JcIik7XG4gfVxuIHZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geCAhPT0geDtcbiB9O1xuIGZ1bmN0aW9uIElzRmluaXRlTm9uTmVnYXRpdmVOdW1iZXIodikge1xuICBpZiAoIUlzTm9uTmVnYXRpdmVOdW1iZXIodikpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodiA9PT0gSW5maW5pdHkpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gSXNOb25OZWdhdGl2ZU51bWJlcih2KSB7XG4gIGlmICh0eXBlb2YgdiAhPT0gJ251bWJlcicpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoTnVtYmVySXNOYU4odikpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodiA8IDApIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gRGVxdWV1ZVZhbHVlKGNvbnRhaW5lcikge1xuICB2YXIgcGFpciA9IGNvbnRhaW5lci5fcXVldWUuc2hpZnQoKTtcbiAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBwYWlyLnNpemU7XG4gIGlmIChjb250YWluZXIuX3F1ZXVlVG90YWxTaXplIDwgMCkge1xuICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA9IDA7XG4gIH1cbiAgcmV0dXJuIHBhaXIudmFsdWU7XG4gfVxuIGZ1bmN0aW9uIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRhaW5lciwgdmFsdWUsIHNpemUpIHtcbiAgc2l6ZSA9IE51bWJlcihzaXplKTtcbiAgaWYgKCFJc0Zpbml0ZU5vbk5lZ2F0aXZlTnVtYmVyKHNpemUpKSB7XG4gICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignU2l6ZSBtdXN0IGJlIGEgZmluaXRlLCBub24tTmFOLCBub24tbmVnYXRpdmUgbnVtYmVyLicpO1xuICB9XG4gIGNvbnRhaW5lci5fcXVldWUucHVzaCh7XG4gICB2YWx1ZTogdmFsdWUsXG4gICBzaXplOiBzaXplXG4gIH0pO1xuICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplICs9IHNpemU7XG4gfVxuIGZ1bmN0aW9uIFBlZWtRdWV1ZVZhbHVlKGNvbnRhaW5lcikge1xuICB2YXIgcGFpciA9IGNvbnRhaW5lci5fcXVldWUucGVlaygpO1xuICByZXR1cm4gcGFpci52YWx1ZTtcbiB9XG4gZnVuY3Rpb24gUmVzZXRRdWV1ZShjb250YWluZXIpIHtcbiAgY29udGFpbmVyLl9xdWV1ZSA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplID0gMDtcbiB9XG4gZnVuY3Rpb24gQ3JlYXRlQXJyYXlGcm9tTGlzdChlbGVtZW50cykge1xuICByZXR1cm4gZWxlbWVudHMuc2xpY2UoKTtcbiB9XG4gZnVuY3Rpb24gQ29weURhdGFCbG9ja0J5dGVzKGRlc3QsIGRlc3RPZmZzZXQsIHNyYywgc3JjT2Zmc2V0LCBuKSB7XG4gIG5ldyBVaW50OEFycmF5KGRlc3QpLnNldChuZXcgVWludDhBcnJheShzcmMsIHNyY09mZnNldCwgbiksIGRlc3RPZmZzZXQpO1xuIH1cbiBmdW5jdGlvbiBUcmFuc2ZlckFycmF5QnVmZmVyKE8pIHtcbiAgcmV0dXJuIE87XG4gfVxuIGZ1bmN0aW9uIElzRGV0YWNoZWRCdWZmZXIoTykge1xuICByZXR1cm4gZmFsc2U7XG4gfVxuIHZhciBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KCkge1xuICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwgXCJ2aWV3XCIsIHtcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG4gICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigndmlldycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdmlldztcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uZCA9IGZ1bmN0aW9uIChieXRlc1dyaXR0ZW4pIHtcbiAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG4gICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kJyk7XG4gICB9XG4gICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGJ5dGVzV3JpdHRlbiwgMSwgJ3Jlc3BvbmQnKTtcbiAgIGJ5dGVzV3JpdHRlbiA9IGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZShieXRlc1dyaXR0ZW4sICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgIGlmICh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcbiAgIH1cbiAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHRoaXMuX3ZpZXcuYnVmZmVyKSk7XG4gICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZCh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgYnl0ZXNXcml0dGVuKTtcbiAgfTtcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uZFdpdGhOZXdWaWV3ID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHRoaXMpKSB7XG4gICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kV2l0aE5ld1ZpZXcnKTtcbiAgIH1cbiAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQodmlldywgMSwgJ3Jlc3BvbmRXaXRoTmV3VmlldycpO1xuICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcodmlldykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgY2FuIG9ubHkgcmVzcG9uZCB3aXRoIGFycmF5IGJ1ZmZlciB2aWV3cycpO1xuICAgfVxuICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJyk7XG4gICB9XG4gICBpZiAodmlldy5idWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjaHVuaydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aFwiKTtcbiAgIH1cbiAgIGlmICh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcbiAgIH1cbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kV2l0aE5ld1ZpZXcodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIHZpZXcpO1xuICB9O1xuICByZXR1cm4gUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcbiB9KCk7XG4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUsIHtcbiAgcmVzcG9uZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlc3BvbmRXaXRoTmV3VmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHZpZXc6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gfSk7XG4gaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0JyxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiB9XG4gdmFyIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoKSB7XG4gICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBcImJ5b2JSZXF1ZXN0XCIsIHtcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignYnlvYlJlcXVlc3QnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2J5b2JSZXF1ZXN0ID09PSBudWxsICYmIHRoaXMuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICB2YXIgZmlyc3REZXNjcmlwdG9yID0gdGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciwgZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQsIGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoIC0gZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkKTtcbiAgICAgdmFyIGJ5b2JSZXF1ZXN0ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSk7XG4gICAgIFNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdChieW9iUmVxdWVzdCwgdGhpcywgdmlldyk7XG4gICAgIHRoaXMuX2J5b2JSZXF1ZXN0ID0gYnlvYlJlcXVlc3Q7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ieW9iUmVxdWVzdDtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBcImRlc2lyZWRTaXplXCIsIHtcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKTtcbiAgIH1cbiAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQ7IGRvIG5vdCBjbG9zZSBpdCBhZ2FpbiEnKTtcbiAgIH1cbiAgIHZhciBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuICAgaWYgKHN0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBzdHJlYW0gKGluIFwiICsgc3RhdGUgKyBcIiBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZFwiKTtcbiAgIH1cbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZSh0aGlzKTtcbiAgfTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcbiAgIH1cbiAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoY2h1bmssIDEsICdlbnF1ZXVlJyk7XG4gICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaHVuayBtdXN0IGJlIGFuIGFycmF5IGJ1ZmZlciB2aWV3Jyk7XG4gICB9XG4gICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJyk7XG4gICB9XG4gICBpZiAoY2h1bmsuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2h1bmsncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhcIik7XG4gICB9XG4gICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJlYW0gaXMgY2xvc2VkIG9yIGRyYWluaW5nJyk7XG4gICB9XG4gICB2YXIgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtcbiAgIGlmIChzdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgc3RyZWFtIChpbiBcIiArIHN0YXRlICsgXCIgc3RhdGUpIGlzIG5vdCBpbiB0aGUgcmVhZGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBlbnF1ZXVlZCB0b1wiKTtcbiAgIH1cbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcbiAgfTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgaWYgKGUgPT09IHZvaWQgMCkge1xuICAgIGUgPSB1bmRlZmluZWQ7XG4gICB9XG4gICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgIH1cbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgfTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGVbQ2FuY2VsU3RlcHNdID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgaWYgKHRoaXMuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgIHZhciBmaXJzdERlc2NyaXB0b3IgPSB0aGlzLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPSAwO1xuICAgfVxuICAgUmVzZXRRdWV1ZSh0aGlzKTtcbiAgIHZhciByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZVtQdWxsU3RlcHNdID0gZnVuY3Rpb24gKHJlYWRSZXF1ZXN0KSB7XG4gICB2YXIgc3RyZWFtID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgIGlmICh0aGlzLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgIHRoaXMuX3F1ZXVlVG90YWxTaXplIC09IGVudHJ5LmJ5dGVMZW5ndGg7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4odGhpcyk7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbnRyeS5idWZmZXIsIGVudHJ5LmJ5dGVPZmZzZXQsIGVudHJ5LmJ5dGVMZW5ndGgpO1xuICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKHZpZXcpO1xuICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSB0aGlzLl9hdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gICBpZiAoYXV0b0FsbG9jYXRlQ2h1bmtTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgYnVmZmVyID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihhdXRvQWxsb2NhdGVDaHVua1NpemUpO1xuICAgIH0gY2F0Y2ggKGJ1ZmZlckUpIHtcbiAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoYnVmZmVyRSk7XG4gICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHB1bGxJbnRvRGVzY3JpcHRvciA9IHtcbiAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgIGJ5dGVPZmZzZXQ6IDAsXG4gICAgIGJ5dGVMZW5ndGg6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcbiAgICAgYnl0ZXNGaWxsZWQ6IDAsXG4gICAgIGVsZW1lbnRTaXplOiAxLFxuICAgICB2aWV3Q29uc3RydWN0b3I6IFVpbnQ4QXJyYXksXG4gICAgIHJlYWRlclR5cGU6ICdkZWZhdWx0J1xuICAgIH07XG4gICAgdGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICB9XG4gICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0KHN0cmVhbSwgcmVhZFJlcXVlc3QpO1xuICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gIH07XG4gIHJldHVybiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyO1xuIH0oKTtcbiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSwge1xuICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGVucXVldWU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBlcnJvcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGJ5b2JSZXF1ZXN0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gfSk7XG4gaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgdmFsdWU6ICdSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyJyxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiB9XG4gZnVuY3Rpb24gSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHgpIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0nKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QoeCkge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKSB7XG4gIHZhciBzaG91bGRQdWxsID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpO1xuICBpZiAoIXNob3VsZFB1bGwpIHtcbiAgIHJldHVybjtcbiAgfVxuICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gdHJ1ZTtcbiAgIHJldHVybjtcbiAgfVxuICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcbiAgdmFyIHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuICB1cG9uUHJvbWlzZShwdWxsUHJvbWlzZSwgZnVuY3Rpb24gKCkge1xuICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxBZ2Fpbikge1xuICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgfVxuICB9LCBmdW5jdGlvbiAoZSkge1xuICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICB9KTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyhjb250cm9sbGVyKSB7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG4gIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihzdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgIGRvbmUgPSB0cnVlO1xuICB9XG4gIHZhciBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5yZWFkZXJUeXBlID09PSAnZGVmYXVsdCcpIHtcbiAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgZmlsbGVkVmlldywgZG9uZSk7XG4gIH0gZWxzZSB7XG4gICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCBmaWxsZWRWaWV3LCBkb25lKTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvcihwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgdmFyIGJ5dGVzRmlsbGVkID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICB2YXIgZWxlbWVudFNpemUgPSBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemU7XG4gIHJldHVybiBuZXcgcHVsbEludG9EZXNjcmlwdG9yLnZpZXdDb25zdHJ1Y3RvcihwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCwgYnl0ZXNGaWxsZWQgLyBlbGVtZW50U2l6ZSk7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBjb250cm9sbGVyLl9xdWV1ZS5wdXNoKHtcbiAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgYnl0ZU9mZnNldDogYnl0ZU9mZnNldCxcbiAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGhcbiAgfSk7XG4gIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplICs9IGJ5dGVMZW5ndGg7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuICB2YXIgZWxlbWVudFNpemUgPSBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemU7XG4gIHZhciBjdXJyZW50QWxpZ25lZEJ5dGVzID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgZWxlbWVudFNpemU7XG4gIHZhciBtYXhCeXRlc1RvQ29weSA9IE1hdGgubWluKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZUxlbmd0aCAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG4gIHZhciBtYXhCeXRlc0ZpbGxlZCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIG1heEJ5dGVzVG9Db3B5O1xuICB2YXIgbWF4QWxpZ25lZEJ5dGVzID0gbWF4Qnl0ZXNGaWxsZWQgLSBtYXhCeXRlc0ZpbGxlZCAlIGVsZW1lbnRTaXplO1xuICB2YXIgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA9IG1heEJ5dGVzVG9Db3B5O1xuICB2YXIgcmVhZHkgPSBmYWxzZTtcbiAgaWYgKG1heEFsaWduZWRCeXRlcyA+IGN1cnJlbnRBbGlnbmVkQnl0ZXMpIHtcbiAgIHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPSBtYXhBbGlnbmVkQnl0ZXMgLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICByZWFkeSA9IHRydWU7XG4gIH1cbiAgdmFyIHF1ZXVlID0gY29udHJvbGxlci5fcXVldWU7XG4gIHdoaWxlICh0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID4gMCkge1xuICAgdmFyIGhlYWRPZlF1ZXVlID0gcXVldWUucGVlaygpO1xuICAgdmFyIGJ5dGVzVG9Db3B5ID0gTWF0aC5taW4odG90YWxCeXRlc1RvQ29weVJlbWFpbmluZywgaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCk7XG4gICB2YXIgZGVzdFN0YXJ0ID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICBDb3B5RGF0YUJsb2NrQnl0ZXMocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgZGVzdFN0YXJ0LCBoZWFkT2ZRdWV1ZS5idWZmZXIsIGhlYWRPZlF1ZXVlLmJ5dGVPZmZzZXQsIGJ5dGVzVG9Db3B5KTtcbiAgIGlmIChoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoID09PSBieXRlc1RvQ29weSkge1xuICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICB9IGVsc2Uge1xuICAgIGhlYWRPZlF1ZXVlLmJ5dGVPZmZzZXQgKz0gYnl0ZXNUb0NvcHk7XG4gICAgaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCAtPSBieXRlc1RvQ29weTtcbiAgIH1cbiAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplIC09IGJ5dGVzVG9Db3B5O1xuICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIGJ5dGVzVG9Db3B5LCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyAtPSBieXRlc1RvQ29weTtcbiAgfVxuICByZXR1cm4gcmVhZHk7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBzaXplLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcbiAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICs9IHNpemU7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKGNvbnRyb2xsZXIpIHtcbiAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID09PSAwICYmIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgUmVhZGFibGVTdHJlYW1DbG9zZShjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcikge1xuICBpZiAoY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcbiAgIHJldHVybjtcbiAgfVxuICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0Ll92aWV3ID0gbnVsbDtcbiAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBudWxsO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpIHtcbiAgd2hpbGUgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIHB1bGxJbnRvRGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgaWYgKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikpIHtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgfVxuICB9XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50byhjb250cm9sbGVyLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpIHtcbiAgdmFyIHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gIHZhciBlbGVtZW50U2l6ZSA9IDE7XG4gIGlmICh2aWV3LmNvbnN0cnVjdG9yICE9PSBEYXRhVmlldykge1xuICAgZWxlbWVudFNpemUgPSB2aWV3LmNvbnN0cnVjdG9yLkJZVEVTX1BFUl9FTEVNRU5UO1xuICB9XG4gIHZhciBjdG9yID0gdmlldy5jb25zdHJ1Y3RvcjtcbiAgdmFyIGJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIodmlldy5idWZmZXIpO1xuICB2YXIgcHVsbEludG9EZXNjcmlwdG9yID0ge1xuICAgYnVmZmVyOiBidWZmZXIsXG4gICBieXRlT2Zmc2V0OiB2aWV3LmJ5dGVPZmZzZXQsXG4gICBieXRlTGVuZ3RoOiB2aWV3LmJ5dGVMZW5ndGgsXG4gICBieXRlc0ZpbGxlZDogMCxcbiAgIGVsZW1lbnRTaXplOiBlbGVtZW50U2l6ZSxcbiAgIHZpZXdDb25zdHJ1Y3RvcjogY3RvcixcbiAgIHJlYWRlclR5cGU6ICdieW9iJ1xuICB9O1xuICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgcmVhZEludG9SZXF1ZXN0KTtcbiAgIHJldHVybjtcbiAgfVxuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgIHZhciBlbXB0eVZpZXcgPSBuZXcgY3RvcihwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLCBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCwgMCk7XG4gICByZWFkSW50b1JlcXVlc3QuX2Nsb3NlU3RlcHMoZW1wdHlWaWV3KTtcbiAgIHJldHVybjtcbiAgfVxuICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICBpZiAoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUoY29udHJvbGxlciwgcHVsbEludG9EZXNjcmlwdG9yKSkge1xuICAgIHZhciBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbihjb250cm9sbGVyKTtcbiAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoZmlsbGVkVmlldyk7XG4gICAgcmV0dXJuO1xuICAgfVxuICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgdmFyIGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICAgIHJlYWRJbnRvUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgICByZXR1cm47XG4gICB9XG4gIH1cbiAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gIFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgcmVhZEludG9SZXF1ZXN0KTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5DbG9zZWRTdGF0ZShjb250cm9sbGVyLCBmaXJzdERlc2NyaXB0b3IpIHtcbiAgZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlcik7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcbiAgIHdoaWxlIChSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICB2YXIgcHVsbEludG9EZXNjcmlwdG9yID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3Ioc3RyZWFtLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgfVxuICB9XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG4gIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyBieXRlc1dyaXR0ZW4gPiBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZUxlbmd0aCkge1xuICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2J5dGVzV3JpdHRlbiBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICBpZiAocHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIDwgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplKSB7XG4gICByZXR1cm47XG4gIH1cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICB2YXIgcmVtYWluZGVyU2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAlIHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcbiAgaWYgKHJlbWFpbmRlclNpemUgPiAwKSB7XG4gICB2YXIgZW5kID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQ7XG4gICB2YXIgcmVtYWluZGVyID0gcHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlci5zbGljZShlbmQgLSByZW1haW5kZXJTaXplLCBlbmQpO1xuICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgcmVtYWluZGVyLCAwLCByZW1haW5kZXIuYnl0ZUxlbmd0aCk7XG4gIH1cbiAgcHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlcik7XG4gIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAtPSByZW1haW5kZXJTaXplO1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKSB7XG4gIHZhciBmaXJzdERlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgdmFyIHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgIGlmIChieXRlc1dyaXR0ZW4gIT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1dyaXR0ZW4gbXVzdCBiZSAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSBjbG9zZWQgc3RyZWFtJyk7XG4gICB9XG4gICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUoY29udHJvbGxlciwgZmlyc3REZXNjcmlwdG9yKTtcbiAgfSBlbHNlIHtcbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgZmlyc3REZXNjcmlwdG9yKTtcbiAgfVxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnNoaWZ0KCk7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG4gIHJldHVybiBkZXNjcmlwdG9yO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcikge1xuICB2YXIgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBkZXNpcmVkU2l6ZSA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgaWYgKGRlc2lyZWRTaXplID4gMCkge1xuICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcbiAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoY29udHJvbGxlcikge1xuICB2YXIgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgIHJldHVybjtcbiAgfVxuICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IHRydWU7XG4gICByZXR1cm47XG4gIH1cbiAgaWYgKGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgdmFyIGZpcnN0UGVuZGluZ1B1bGxJbnRvID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICBpZiAoZmlyc3RQZW5kaW5nUHVsbEludG8uYnl0ZXNGaWxsZWQgPiAwKSB7XG4gICAgdmFyIGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICAgIHRocm93IGU7XG4gICB9XG4gIH1cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShjb250cm9sbGVyLCBjaHVuaykge1xuICB2YXIgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgIHJldHVybjtcbiAgfVxuICB2YXIgYnVmZmVyID0gY2h1bmsuYnVmZmVyO1xuICB2YXIgYnl0ZU9mZnNldCA9IGNodW5rLmJ5dGVPZmZzZXQ7XG4gIHZhciBieXRlTGVuZ3RoID0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgdmFyIHRyYW5zZmVycmVkQnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihidWZmZXIpO1xuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkpIHtcbiAgIGlmIChSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID09PSAwKSB7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgfSBlbHNlIHtcbiAgICB2YXIgdHJhbnNmZXJyZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgdHJhbnNmZXJyZWRWaWV3LCBmYWxzZSk7XG4gICB9XG4gIH0gZWxzZSBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG4gIH0gZWxzZSB7XG4gICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIH1cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgcmV0dXJuO1xuICB9XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MoY29udHJvbGxlcik7XG4gIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcbiAgdmFyIHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKSB7XG4gIGJ5dGVzV3JpdHRlbiA9IE51bWJlcihieXRlc1dyaXR0ZW4pO1xuICBpZiAoIUlzRmluaXRlTm9uTmVnYXRpdmVOdW1iZXIoYnl0ZXNXcml0dGVuKSkge1xuICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2J5dGVzV3JpdHRlbiBtdXN0IGJlIGEgZmluaXRlJyk7XG4gIH1cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGNvbnRyb2xsZXIsIHZpZXcpIHtcbiAgdmFyIGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgIT09IHZpZXcuYnl0ZU9mZnNldCkge1xuICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSByZWdpb24gc3BlY2lmaWVkIGJ5IHZpZXcgZG9lcyBub3QgbWF0Y2ggYnlvYlJlcXVlc3QnKTtcbiAgfVxuICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGggIT09IHZpZXcuYnl0ZUxlbmd0aCkge1xuICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBidWZmZXIgb2YgdmlldyBoYXMgZGlmZmVyZW50IGNhcGFjaXR5IHRoYW4gYnlvYlJlcXVlc3QnKTtcbiAgfVxuICBmaXJzdERlc2NyaXB0b3IuYnVmZmVyID0gdmlldy5idWZmZXI7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgdmlldy5ieXRlTGVuZ3RoKTtcbiB9XG4gZnVuY3Rpb24gU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgYXV0b0FsbG9jYXRlQ2h1bmtTaXplKSB7XG4gIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0gPSBzdHJlYW07XG4gIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gbnVsbDtcbiAgY29udHJvbGxlci5fcXVldWUgPSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcbiAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XG4gIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gIHZhciBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gIHVwb25Qcm9taXNlKHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpLCBmdW5jdGlvbiAoKSB7XG4gICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICB9LCBmdW5jdGlvbiAocikge1xuICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIHIpO1xuICB9KTtcbiB9XG4gZnVuY3Rpb24gU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2Uoc3RyZWFtLCB1bmRlcmx5aW5nQnl0ZVNvdXJjZSwgaGlnaFdhdGVyTWFyaykge1xuICB2YXIgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xuICB2YXIgc3RhcnRBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuICB2YXIgcHVsbEFsZ29yaXRobSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH07XG4gIHZhciBjYW5jZWxBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9O1xuICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgc3RhcnRBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuZGVybHlpbmdCeXRlU291cmNlLnN0YXJ0KGNvbnRyb2xsZXIpO1xuICAgfTtcbiAgfVxuICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2UucHVsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICBwdWxsQWxnb3JpdGhtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5wdWxsKGNvbnRyb2xsZXIpO1xuICAgfTtcbiAgfVxuICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgIGNhbmNlbEFsZ29yaXRobSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gdW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsKHJlYXNvbik7XG4gICB9O1xuICB9XG4gIHZhciBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5hdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gIGlmIChhdXRvQWxsb2NhdGVDaHVua1NpemUgPT09IDApIHtcbiAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gIH1cbiAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgYXV0b0FsbG9jYXRlQ2h1bmtTaXplKTtcbiB9XG4gZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHJlcXVlc3QsIGNvbnRyb2xsZXIsIHZpZXcpIHtcbiAgcmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICByZXF1ZXN0Ll92aWV3ID0gdmlldztcbiB9XG4gZnVuY3Rpb24gYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZS5cIiArIG5hbWUgKyBcIiBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdFwiKTtcbiB9XG4gZnVuY3Rpb24gYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5cIiArIG5hbWUgKyBcIiBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclwiKTtcbiB9XG4gZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihzdHJlYW0pIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpIHtcbiAgc3RyZWFtLl9yZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMucHVzaChyZWFkSW50b1JlcXVlc3QpO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZG9uZSkge1xuICB2YXIgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gIHZhciByZWFkSW50b1JlcXVlc3QgPSByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuc2hpZnQoKTtcbiAgaWYgKGRvbmUpIHtcbiAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhjaHVuayk7XG4gIH0gZWxzZSB7XG4gICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5fcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aDtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkge1xuICB2YXIgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiB2YXIgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKSB7XG4gICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcicpO1xuICAgYXNzZXJ0UmVhZGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyJyk7XG4gICB9XG4gICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29uc3RydWN0IGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIGZvciBhIHN0cmVhbSBub3QgY29uc3RydWN0ZWQgd2l0aCBhIGJ5dGUgJyArICdzb3VyY2UnKTtcbiAgIH1cbiAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUodGhpcywgc3RyZWFtKTtcbiAgIHRoaXMuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZSwgXCJjbG9zZWRcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICBpZiAocmVhc29uID09PSB2b2lkIDApIHtcbiAgICByZWFzb24gPSB1bmRlZmluZWQ7XG4gICB9XG4gICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgIH1cbiAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICB9XG4gICByZXR1cm4gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gIH07XG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWQnKSk7XG4gICB9XG4gICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXcgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlldycpKTtcbiAgIH1cbiAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3IG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJykpO1xuICAgfVxuICAgaWYgKHZpZXcuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKFwidmlldydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aFwiKSk7XG4gICB9XG4gICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbigncmVhZCBmcm9tJykpO1xuICAgfVxuICAgdmFyIHJlc29sdmVQcm9taXNlO1xuICAgdmFyIHJlamVjdFByb21pc2U7XG4gICB2YXIgcHJvbWlzZSA9IG5ld1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuICAgfSk7XG4gICB2YXIgcmVhZEludG9SZXF1ZXN0ID0ge1xuICAgIF9jaHVua1N0ZXBzOiBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlKHtcbiAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgIH0pO1xuICAgIH0sXG4gICAgX2Nsb3NlU3RlcHM6IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICByZXR1cm4gcmVzb2x2ZVByb21pc2Uoe1xuICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgICB9KTtcbiAgICB9LFxuICAgIF9lcnJvclN0ZXBzOiBmdW5jdGlvbiAoZSkge1xuICAgICByZXR1cm4gcmVqZWN0UHJvbWlzZShlKTtcbiAgICB9XG4gICB9O1xuICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVhZCh0aGlzLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpO1xuICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG4gIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUucmVsZWFzZUxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgdGhyb3cgYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XG4gICB9XG4gICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICAgfVxuICAgaWYgKHRoaXMuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RyaWVkIHRvIHJlbGVhc2UgYSByZWFkZXIgbG9jayB3aGVuIHRoYXQgcmVhZGVyIGhhcyBwZW5kaW5nIHJlYWQoKSBjYWxscyB1bi1zZXR0bGVkJyk7XG4gICB9XG4gICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHRoaXMpO1xuICB9O1xuICByZXR1cm4gUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyO1xuIH0oKTtcbiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLCB7XG4gIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlYWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiB9KTtcbiBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyJyxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiB9XG4gZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoeCkge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZEludG9SZXF1ZXN0cycpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQocmVhZGVyLCB2aWV3LCByZWFkSW50b1JlcXVlc3QpIHtcbiAgdmFyIHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcbiAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH0gZWxzZSB7XG4gICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8oc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHZpZXcsIHJlYWRJbnRvUmVxdWVzdCk7XG4gIH1cbiB9XG4gZnVuY3Rpb24gYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUuXCIgKyBuYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclwiKTtcbiB9XG4gZnVuY3Rpb24gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIGRlZmF1bHRIV00pIHtcbiAgdmFyIGhpZ2hXYXRlck1hcmsgPSBzdHJhdGVneS5oaWdoV2F0ZXJNYXJrO1xuICBpZiAoaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkKSB7XG4gICByZXR1cm4gZGVmYXVsdEhXTTtcbiAgfVxuICBpZiAoTnVtYmVySXNOYU4oaGlnaFdhdGVyTWFyaykgfHwgaGlnaFdhdGVyTWFyayA8IDApIHtcbiAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGhpZ2hXYXRlck1hcmsnKTtcbiAgfVxuICByZXR1cm4gaGlnaFdhdGVyTWFyaztcbiB9XG4gZnVuY3Rpb24gRXh0cmFjdFNpemVBbGdvcml0aG0oc3RyYXRlZ3kpIHtcbiAgdmFyIHNpemUgPSBzdHJhdGVneS5zaXplO1xuICBpZiAoIXNpemUpIHtcbiAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDE7XG4gICB9O1xuICB9XG4gIHJldHVybiBzaXplO1xuIH1cbiBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KGluaXQsIGNvbnRleHQpIHtcbiAgYXNzZXJ0RGljdGlvbmFyeShpbml0LCBjb250ZXh0KTtcbiAgdmFyIGhpZ2hXYXRlck1hcmsgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHNpemUgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuc2l6ZTtcbiAgcmV0dXJuIHtcbiAgIGhpZ2hXYXRlck1hcms6IGhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUoaGlnaFdhdGVyTWFyayksXG4gICBzaXplOiBzaXplID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5U2l6ZShzaXplLCBjb250ZXh0ICsgXCIgaGFzIG1lbWJlciAnc2l6ZScgdGhhdFwiKVxuICB9O1xuIH1cbiBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5U2l6ZShmbiwgY29udGV4dCkge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY2h1bmspIHtcbiAgIHJldHVybiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGZuKGNodW5rKSk7XG4gIH07XG4gfVxuIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2luayhvcmlnaW5hbCwgY29udGV4dCkge1xuICBhc3NlcnREaWN0aW9uYXJ5KG9yaWdpbmFsLCBjb250ZXh0KTtcbiAgdmFyIGFib3J0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmFib3J0O1xuICB2YXIgY2xvc2UgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuY2xvc2U7XG4gIHZhciBzdGFydCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5zdGFydDtcbiAgdmFyIHR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHlwZTtcbiAgdmFyIHdyaXRlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLndyaXRlO1xuICByZXR1cm4ge1xuICAgYWJvcnQ6IGFib3J0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrKGFib3J0LCBvcmlnaW5hbCwgY29udGV4dCArIFwiIGhhcyBtZW1iZXIgJ2Fib3J0JyB0aGF0XCIpLFxuICAgY2xvc2U6IGNsb3NlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrKGNsb3NlLCBvcmlnaW5hbCwgY29udGV4dCArIFwiIGhhcyBtZW1iZXIgJ2Nsb3NlJyB0aGF0XCIpLFxuICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0VW5kZXJseWluZ1NpbmtTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgY29udGV4dCArIFwiIGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0XCIpLFxuICAgd3JpdGU6IHdyaXRlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrKHdyaXRlLCBvcmlnaW5hbCwgY29udGV4dCArIFwiIGhhcyBtZW1iZXIgJ3dyaXRlJyB0aGF0XCIpLFxuICAgdHlwZTogdHlwZVxuICB9O1xuIH1cbiBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAocmVhc29uKSB7XG4gICByZXR1cm4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbcmVhc29uXSk7XG4gIH07XG4gfVxuIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Nsb3NlQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtdKTtcbiAgfTtcbiB9XG4gZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgIHJldHVybiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG4gIH07XG4gfVxuIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua1dyaXRlQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjaHVuaywgY29udHJvbGxlcikge1xuICAgcmV0dXJuIHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW1xuICAgIGNodW5rLFxuICAgIGNvbnRyb2xsZXJcbiAgIF0pO1xuICB9O1xuIH1cbiBmdW5jdGlvbiBhc3NlcnRXcml0YWJsZVN0cmVhbSh4LCBjb250ZXh0KSB7XG4gIGlmICghSXNXcml0YWJsZVN0cmVhbSh4KSkge1xuICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb250ZXh0ICsgXCIgaXMgbm90IGEgV3JpdGFibGVTdHJlYW0uXCIpO1xuICB9XG4gfVxuIHZhciBXcml0YWJsZVN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW0ocmF3VW5kZXJseWluZ1NpbmssIHJhd1N0cmF0ZWd5KSB7XG4gICBpZiAocmF3VW5kZXJseWluZ1NpbmsgPT09IHZvaWQgMCkge1xuICAgIHJhd1VuZGVybHlpbmdTaW5rID0ge307XG4gICB9XG4gICBpZiAocmF3U3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIHJhd1N0cmF0ZWd5ID0ge307XG4gICB9XG4gICBpZiAocmF3VW5kZXJseWluZ1NpbmsgPT09IHVuZGVmaW5lZCkge1xuICAgIHJhd1VuZGVybHlpbmdTaW5rID0gbnVsbDtcbiAgIH0gZWxzZSB7XG4gICAgYXNzZXJ0T2JqZWN0KHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICB9XG4gICB2YXIgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgdmFyIHVuZGVybHlpbmdTaW5rID0gY29udmVydFVuZGVybHlpbmdTaW5rKHJhd1VuZGVybHlpbmdTaW5rLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0odGhpcyk7XG4gICB2YXIgdHlwZSA9IHVuZGVybHlpbmdTaW5rLnR5cGU7XG4gICBpZiAodHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZSBpcyBzcGVjaWZpZWQnKTtcbiAgIH1cbiAgIHZhciBzaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0oc3RyYXRlZ3kpO1xuICAgdmFyIGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMSk7XG4gICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NpbmsodGhpcywgdW5kZXJseWluZ1NpbmssIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIFwibG9ja2VkXCIsIHtcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdsb2NrZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcyk7XG4gICB9LFxuICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgIGlmIChyZWFzb24gPT09IHZvaWQgMCkge1xuICAgIHJlYXNvbiA9IHVuZGVmaW5lZDtcbiAgIH1cbiAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Fib3J0JykpO1xuICAgfVxuICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgYWJvcnQgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcbiAgIH1cbiAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KHRoaXMsIHJlYXNvbik7XG4gIH07XG4gIFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xuICAgfVxuICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcbiAgIH1cbiAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodCh0aGlzKSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtJykpO1xuICAgfVxuICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2UodGhpcyk7XG4gIH07XG4gIFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5nZXRXcml0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcbiAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdnZXRXcml0ZXInKTtcbiAgIH1cbiAgIHJldHVybiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpO1xuICB9O1xuICByZXR1cm4gV3JpdGFibGVTdHJlYW07XG4gfSgpO1xuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSwge1xuICBhYm9ydDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZ2V0V3JpdGVyOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgbG9ja2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuIH0pO1xuIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICB2YWx1ZTogJ1dyaXRhYmxlU3RyZWFtJyxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiB9XG4gZnVuY3Rpb24gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcihzdHJlYW0pIHtcbiAgcmV0dXJuIG5ldyBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoc3RyZWFtKTtcbiB9XG4gZnVuY3Rpb24gQ3JlYXRlV3JpdGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcbiAgaWYgKGhpZ2hXYXRlck1hcmsgPT09IHZvaWQgMCkge1xuICAgaGlnaFdhdGVyTWFyayA9IDE7XG4gIH1cbiAgaWYgKHNpemVBbGdvcml0aG0gPT09IHZvaWQgMCkge1xuICAgc2l6ZUFsZ29yaXRobSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMTtcbiAgIH07XG4gIH1cbiAgdmFyIHN0cmVhbSA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlKTtcbiAgSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHN0cmVhbSk7XG4gIHZhciBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgcmV0dXJuIHN0cmVhbTtcbiB9XG4gZnVuY3Rpb24gSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICBzdHJlYW0uX3N0YXRlID0gJ3dyaXRhYmxlJztcbiAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgc3RyZWFtLl93cml0ZXIgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBmYWxzZTtcbiB9XG4gZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbSh4KSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ193cml0YWJsZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtLl93cml0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUFib3J0KHN0cmVhbSwgcmVhc29uKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybiBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Byb21pc2U7XG4gIH1cbiAgdmFyIHdhc0FscmVhZHlFcnJvcmluZyA9IGZhbHNlO1xuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgIHdhc0FscmVhZHlFcnJvcmluZyA9IHRydWU7XG4gICByZWFzb24gPSB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHByb21pc2UgPSBuZXdQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHtcbiAgICBfcHJvbWlzZTogdW5kZWZpbmVkLFxuICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgIF9yZWplY3Q6IHJlamVjdCxcbiAgICBfcmVhc29uOiByZWFzb24sXG4gICAgX3dhc0FscmVhZHlFcnJvcmluZzogd2FzQWxyZWFkeUVycm9yaW5nXG4gICB9O1xuICB9KTtcbiAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9wcm9taXNlID0gcHJvbWlzZTtcbiAgaWYgKCF3YXNBbHJlYWR5RXJyb3JpbmcpIHtcbiAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIHJlYXNvbik7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihcIlRoZSBzdHJlYW0gKGluIFwiICsgc3RhdGUgKyBcIiBzdGF0ZSkgaXMgbm90IGluIHRoZSB3cml0YWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZFwiKSk7XG4gIH1cbiAgdmFyIHByb21pc2UgPSBuZXdQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgIHZhciBjbG9zZVJlcXVlc3QgPSB7XG4gICAgX3Jlc29sdmU6IHJlc29sdmUsXG4gICAgX3JlamVjdDogcmVqZWN0XG4gICB9O1xuICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSBjbG9zZVJlcXVlc3Q7XG4gIH0pO1xuICB2YXIgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCAmJiBzdHJlYW0uX2JhY2twcmVzc3VyZSAmJiBzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgfVxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2Uoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICByZXR1cm4gcHJvbWlzZTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3Qoc3RyZWFtKSB7XG4gIHZhciBwcm9taXNlID0gbmV3UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICB2YXIgd3JpdGVSZXF1ZXN0ID0ge1xuICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgIF9yZWplY3Q6IHJlamVjdFxuICAgfTtcbiAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5wdXNoKHdyaXRlUmVxdWVzdCk7XG4gIH0pO1xuICByZXR1cm4gcHJvbWlzZTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgZXJyb3IpO1xuICAgcmV0dXJuO1xuICB9XG4gIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgcmVhc29uKSB7XG4gIHZhciBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JpbmcnO1xuICBzdHJlYW0uX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICB2YXIgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuICB9XG4gIGlmICghV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodChzdHJlYW0pICYmIGNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSkge1xuICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yZWQnO1xuICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcltFcnJvclN0ZXBzXSgpO1xuICB2YXIgc3RvcmVkRXJyb3IgPSBzdHJlYW0uX3N0b3JlZEVycm9yO1xuICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAod3JpdGVSZXF1ZXN0KSB7XG4gICB3cml0ZVJlcXVlc3QuX3JlamVjdChzdG9yZWRFcnJvcik7XG4gIH0pO1xuICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICByZXR1cm47XG4gIH1cbiAgdmFyIGFib3J0UmVxdWVzdCA9IHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdDtcbiAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICBpZiAoYWJvcnRSZXF1ZXN0Ll93YXNBbHJlYWR5RXJyb3JpbmcpIHtcbiAgIGFib3J0UmVxdWVzdC5fcmVqZWN0KHN0b3JlZEVycm9yKTtcbiAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgIHJldHVybjtcbiAgfVxuICB2YXIgcHJvbWlzZSA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Fib3J0U3RlcHNdKGFib3J0UmVxdWVzdC5fcmVhc29uKTtcbiAgdXBvblByb21pc2UocHJvbWlzZSwgZnVuY3Rpb24gKCkge1xuICAgYWJvcnRSZXF1ZXN0Ll9yZXNvbHZlKCk7XG4gICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgIGFib3J0UmVxdWVzdC5fcmVqZWN0KHJlYXNvbik7XG4gICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUoc3RyZWFtKSB7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QuX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yKHN0cmVhbSwgZXJyb3IpIHtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdC5fcmVqZWN0KGVycm9yKTtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlKHN0cmVhbSkge1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcmVzb2x2ZSgpO1xuICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgIH1cbiAgfVxuICBzdHJlYW0uX3N0YXRlID0gJ2Nsb3NlZCc7XG4gIHZhciB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3Ioc3RyZWFtLCBlcnJvcikge1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcmVqZWN0KGVycm9yKTtcbiAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgfVxuICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQoc3RyZWFtKSB7XG4gIGlmIChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID09PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSkge1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gc3RyZWFtLl9jbG9zZVJlcXVlc3Q7XG4gIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbU1hcmtGaXJzdFdyaXRlUmVxdWVzdEluRmxpZ2h0KHN0cmVhbSkge1xuICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gc3RyZWFtLl93cml0ZVJlcXVlc3RzLnNoaWZ0KCk7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKSB7XG4gIGlmIChzdHJlYW0uX2Nsb3NlUmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICBzdHJlYW0uX2Nsb3NlUmVxdWVzdC5fcmVqZWN0KHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpIHtcbiAgdmFyIHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQgJiYgYmFja3ByZXNzdXJlICE9PSBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgaWYgKGJhY2twcmVzc3VyZSkge1xuICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXIpO1xuICAgfSBlbHNlIHtcbiAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpO1xuICAgfVxuICB9XG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gYmFja3ByZXNzdXJlO1xuIH1cbiB2YXIgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoc3RyZWFtKSB7XG4gICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHN0cmVhbSwgMSwgJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcicpO1xuICAgYXNzZXJ0V3JpdGFibGVTdHJlYW0oc3RyZWFtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSB3cml0aW5nIGJ5IGFub3RoZXIgd3JpdGVyJyk7XG4gICB9XG4gICB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICAgc3RyZWFtLl93cml0ZXIgPSB0aGlzO1xuICAgdmFyIHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgfVxuICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcbiAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcbiAgIH0gZWxzZSB7XG4gICAgdmFyIHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcbiAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuICAgfVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCBcImNsb3NlZFwiLCB7XG4gICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuICAgfSxcbiAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwgXCJkZXNpcmVkU2l6ZVwiLCB7XG4gICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgIHRocm93IGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgIHRocm93IGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgIH1cbiAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG4gICB9LFxuICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCBcInJlYWR5XCIsIHtcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWR5JykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZHlQcm9taXNlO1xuICAgfSxcbiAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgaWYgKHJlYXNvbiA9PT0gdm9pZCAwKSB7XG4gICAgcmVhc29uID0gdW5kZWZpbmVkO1xuICAgfVxuICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdhYm9ydCcpKTtcbiAgIH1cbiAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignYWJvcnQnKSk7XG4gICB9XG4gICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQodGhpcywgcmVhc29uKTtcbiAgfTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKSk7XG4gICB9XG4gICB2YXIgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdjbG9zZScpKTtcbiAgIH1cbiAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW0nKSk7XG4gICB9XG4gICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2UodGhpcyk7XG4gIH07XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUucmVsZWFzZUxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgdGhyb3cgZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XG4gICB9XG4gICB2YXIgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgIH1cbiAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UodGhpcyk7XG4gIH07XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgIGlmIChjaHVuayA9PT0gdm9pZCAwKSB7XG4gICAgY2h1bmsgPSB1bmRlZmluZWQ7XG4gICB9XG4gICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3dyaXRlJykpO1xuICAgfVxuICAgaWYgKHRoaXMuX293bmVyV3JpdGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCd3cml0ZSB0bycpKTtcbiAgIH1cbiAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh0aGlzLCBjaHVuayk7XG4gIH07XG4gIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI7XG4gfSgpO1xuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUsIHtcbiAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgd3JpdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHJlYWR5OiB7IGVudW1lcmFibGU6IHRydWUgfVxuIH0pO1xuIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXInLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih4KSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19vd25lcldyaXRhYmxlU3RyZWFtJykpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQod3JpdGVyLCByZWFzb24pIHtcbiAgdmFyIHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoc3RyZWFtLCByZWFzb24pO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSh3cml0ZXIpIHtcbiAgdmFyIHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbih3cml0ZXIpIHtcbiAgdmFyIHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgfHwgc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxuICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2Uod3JpdGVyKTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkKHdyaXRlciwgZXJyb3IpIHtcbiAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID09PSAncGVuZGluZycpIHtcbiAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCBlcnJvcik7XG4gIH1cbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCBlcnJvcikge1xuICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0KHdyaXRlciwgZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIGVycm9yKTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh3cml0ZXIpIHtcbiAgdmFyIHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJSZWxlYXNlKHdyaXRlcikge1xuICB2YXIgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICB2YXIgcmVsZWFzZWRFcnJvciA9IG5ldyBUeXBlRXJyb3IoXCJXcml0ZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc1wiKTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlUmVhZHlQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWxlYXNlZEVycm9yKTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVsZWFzZWRFcnJvcik7XG4gIHN0cmVhbS5fd3JpdGVyID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW0gPSB1bmRlZmluZWQ7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHdyaXRlciwgY2h1bmspIHtcbiAgdmFyIHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgdmFyIGNvbnRyb2xsZXIgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgdmFyIGNodW5rU2l6ZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRDaHVua1NpemUoY29udHJvbGxlciwgY2h1bmspO1xuICBpZiAoc3RyZWFtICE9PSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW0pIHtcbiAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCd3cml0ZSB0bycpKTtcbiAgfVxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cbiAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgfHwgc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIGNsb3Npbmcgb3IgY2xvc2VkIGFuZCBjYW5ub3QgYmUgd3JpdHRlbiB0bycpKTtcbiAgfVxuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG4gIHZhciBwcm9taXNlID0gV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3Qoc3RyZWFtKTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuICByZXR1cm4gcHJvbWlzZTtcbiB9XG4gdmFyIGNsb3NlU2VudGluZWwgPSB7fTtcbiB2YXIgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcigpIHtcbiAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgfVxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICBpZiAoZSA9PT0gdm9pZCAwKSB7XG4gICAgZSA9IHVuZGVmaW5lZDtcbiAgIH1cbiAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZXJyb3IgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInKTtcbiAgIH1cbiAgIHZhciBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbS5fc3RhdGU7XG4gICBpZiAoc3RhdGUgIT09ICd3cml0YWJsZScpIHtcbiAgICByZXR1cm47XG4gICB9XG4gICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgZSk7XG4gIH07XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlW0Fib3J0U3RlcHNdID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Fib3J0QWxnb3JpdGhtKHJlYXNvbik7XG4gICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGVbRXJyb3JTdGVwc10gPSBmdW5jdGlvbiAoKSB7XG4gICBSZXNldFF1ZXVlKHRoaXMpO1xuICB9O1xuICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiB9KCk7XG4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHsgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9IH0pO1xuIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gfVxuIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4KSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkV3JpdGFibGVTdHJlYW0nKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuICBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0gPSBzdHJlYW07XG4gIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgY29udHJvbGxlci5fcXVldWUgPSB1bmRlZmluZWQ7XG4gIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkO1xuICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHNpemVBbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcbiAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB3cml0ZUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0gPSBjbG9zZUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fYWJvcnRBbGdvcml0aG0gPSBhYm9ydEFsZ29yaXRobTtcbiAgdmFyIGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgdmFyIHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcbiAgdmFyIHN0YXJ0UHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpO1xuICB1cG9uUHJvbWlzZShzdGFydFByb21pc2UsIGZ1bmN0aW9uICgpIHtcbiAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICB9LCBmdW5jdGlvbiAocikge1xuICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgcik7XG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1Npbmsoc3RyZWFtLCB1bmRlcmx5aW5nU2luaywgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuICB2YXIgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICB2YXIgc3RhcnRBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuICB2YXIgd3JpdGVBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9O1xuICB2YXIgY2xvc2VBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9O1xuICB2YXIgYWJvcnRBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9O1xuICBpZiAodW5kZXJseWluZ1Npbmsuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgc3RhcnRBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuZGVybHlpbmdTaW5rLnN0YXJ0KGNvbnRyb2xsZXIpO1xuICAgfTtcbiAgfVxuICBpZiAodW5kZXJseWluZ1Npbmsud3JpdGUgIT09IHVuZGVmaW5lZCkge1xuICAgd3JpdGVBbGdvcml0aG0gPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICByZXR1cm4gdW5kZXJseWluZ1Npbmsud3JpdGUoY2h1bmssIGNvbnRyb2xsZXIpO1xuICAgfTtcbiAgfVxuICBpZiAodW5kZXJseWluZ1NpbmsuY2xvc2UgIT09IHVuZGVmaW5lZCkge1xuICAgY2xvc2VBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuZGVybHlpbmdTaW5rLmNsb3NlKCk7XG4gICB9O1xuICB9XG4gIGlmICh1bmRlcmx5aW5nU2luay5hYm9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICBhYm9ydEFsZ29yaXRobSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gdW5kZXJseWluZ1NpbmsuYWJvcnQocmVhc29uKTtcbiAgIH07XG4gIH1cbiAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcbiAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gIGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoY29udHJvbGxlcikge1xuICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjbG9zZVNlbnRpbmVsLCAwKTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gIHRyeSB7XG4gICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcbiAgfSBjYXRjaCAoY2h1bmtTaXplRSkge1xuICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgY2h1bmtTaXplRSk7XG4gICByZXR1cm4gMTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcikge1xuICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpIHtcbiAgdHJ5IHtcbiAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuICB9IGNhdGNoIChlbnF1ZXVlRSkge1xuICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgZW5xdWV1ZUUpO1xuICAgcmV0dXJuO1xuICB9XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICB2YXIgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcbiAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgfVxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKSB7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgcmV0dXJuO1xuICB9XG4gIGlmIChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybjtcbiAgfVxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbiAgIHJldHVybjtcbiAgfVxuICBpZiAoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbHVlID0gUGVla1F1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gIGlmICh2YWx1ZSA9PT0gY2xvc2VTZW50aW5lbCkge1xuICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NDbG9zZShjb250cm9sbGVyKTtcbiAgfSBlbHNlIHtcbiAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzV3JpdGUoY29udHJvbGxlciwgdmFsdWUpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGVycm9yKSB7XG4gIGlmIChjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZXJyb3IpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcikge1xuICB2YXIgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICBXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pO1xuICBEZXF1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gIHZhciBzaW5rQ2xvc2VQcm9taXNlID0gY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0oKTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgdXBvblByb21pc2Uoc2lua0Nsb3NlUHJvbWlzZSwgZnVuY3Rpb24gKCkge1xuICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlKHN0cmVhbSk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gIFdyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcbiAgdmFyIHNpbmtXcml0ZVByb21pc2UgPSBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobShjaHVuayk7XG4gIHVwb25Qcm9taXNlKHNpbmtXcml0ZVByb21pc2UsIGZ1bmN0aW9uICgpIHtcbiAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZShzdHJlYW0pO1xuICAgdmFyIHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcbiAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgIHZhciBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgIH1cbiAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgfVxuICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcbiAgfSk7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcikge1xuICB2YXIgZGVzaXJlZFNpemUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG4gIHJldHVybiBkZXNpcmVkU2l6ZSA8PSAwO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZXJyb3IpIHtcbiAgdmFyIHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgZXJyb3IpO1xuIH1cbiBmdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuXCIgKyBuYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtXCIpO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS5cIiArIG5hbWUgKyBcIiBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyXCIpO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbihuYW1lKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdDYW5ub3QgJyArIG5hbWUgKyAnIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgd3JpdGVyJyk7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpIHtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlID0gbmV3UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncGVuZGluZyc7XG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyKSB7XG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pIHtcbiAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuO1xuICB9XG4gIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUod3JpdGVyLl9jbG9zZWRQcm9taXNlKTtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncmVqZWN0ZWQnO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcikge1xuICBpZiAod3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuO1xuICB9XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZXNvbHZlZCc7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcikge1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZSA9IG5ld1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gIH0pO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ3BlbmRpbmcnO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXIpIHtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbikge1xuICBpZiAod3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybjtcbiAgfVxuICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHdyaXRlci5fcmVhZHlQcm9taXNlKTtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXIpIHtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpIHtcbiAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuO1xuICB9XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ2Z1bGZpbGxlZCc7XG4gfVxuIGZ1bmN0aW9uIGlzQWJvcnRTaWduYWwodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5hYm9ydGVkID09PSAnYm9vbGVhbic7XG4gIH0gY2F0Y2ggKF9hKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiB9XG4gdmFyIE5hdGl2ZURPTUV4Y2VwdGlvbiA9IHR5cGVvZiBET01FeGNlcHRpb24gIT09ICd1bmRlZmluZWQnID8gRE9NRXhjZXB0aW9uIDogdW5kZWZpbmVkO1xuIGZ1bmN0aW9uIGlzRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IoY3Rvcikge1xuICBpZiAoISh0eXBlb2YgY3RvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY3RvciA9PT0gJ29iamVjdCcpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgIG5ldyBjdG9yKCk7XG4gICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoX2EpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBjcmVhdGVET01FeGNlcHRpb25Qb2x5ZmlsbCgpIHtcbiAgdmFyIGN0b3IgPSBmdW5jdGlvbiBET01FeGNlcHRpb24obWVzc2FnZSwgbmFtZSkge1xuICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcbiAgIHRoaXMubmFtZSA9IG5hbWUgfHwgJ0Vycm9yJztcbiAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgfVxuICB9O1xuICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCB7XG4gICB2YWx1ZTogY3RvcixcbiAgIHdyaXRhYmxlOiB0cnVlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gY3RvcjtcbiB9XG4gdmFyIERPTUV4Y2VwdGlvbiQxID0gaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvcihOYXRpdmVET01FeGNlcHRpb24pID8gTmF0aXZlRE9NRXhjZXB0aW9uIDogY3JlYXRlRE9NRXhjZXB0aW9uUG9seWZpbGwoKTtcbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVBpcGVUbyhzb3VyY2UsIGRlc3QsIHByZXZlbnRDbG9zZSwgcHJldmVudEFib3J0LCBwcmV2ZW50Q2FuY2VsLCBzaWduYWwpIHtcbiAgdmFyIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc291cmNlKTtcbiAgdmFyIHdyaXRlciA9IEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoZGVzdCk7XG4gIHNvdXJjZS5fZGlzdHVyYmVkID0gdHJ1ZTtcbiAgdmFyIHNodXR0aW5nRG93biA9IGZhbHNlO1xuICB2YXIgY3VycmVudFdyaXRlID0gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICByZXR1cm4gbmV3UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICB2YXIgYWJvcnRBbGdvcml0aG07XG4gICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBhYm9ydEFsZ29yaXRobSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgdmFyIGVycm9yID0gbmV3IERPTUV4Y2VwdGlvbiQxKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKTtcbiAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgaWYgKCFwcmV2ZW50QWJvcnQpIHtcbiAgICAgIGFjdGlvbnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KGRlc3QsIGVycm9yKTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgIH0pO1xuICAgICB9XG4gICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICAgYWN0aW9ucy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICBpZiAoc291cmNlLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBlcnJvcik7XG4gICAgICAgfVxuICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICB9KTtcbiAgICAgfVxuICAgICBzaHV0ZG93bldpdGhBY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGFjdGlvbnMubWFwKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICByZXR1cm4gYWN0aW9uKCk7XG4gICAgICB9KSk7XG4gICAgIH0sIHRydWUsIGVycm9yKTtcbiAgICB9O1xuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICBhYm9ydEFsZ29yaXRobSgpO1xuICAgICByZXR1cm47XG4gICAgfVxuICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QWxnb3JpdGhtKTtcbiAgIH1cbiAgIGZ1bmN0aW9uIHBpcGVMb29wKCkge1xuICAgIHJldHVybiBuZXdQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlTG9vcCwgcmVqZWN0TG9vcCkge1xuICAgICBmdW5jdGlvbiBuZXh0KGRvbmUpIHtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgcmVzb2x2ZUxvb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgUGVyZm9ybVByb21pc2VUaGVuKHBpcGVTdGVwKCksIG5leHQsIHJlamVjdExvb3ApO1xuICAgICAgfVxuICAgICB9XG4gICAgIG5leHQoZmFsc2UpO1xuICAgIH0pO1xuICAgfVxuICAgZnVuY3Rpb24gcGlwZVN0ZXAoKSB7XG4gICAgaWYgKHNodXR0aW5nRG93bikge1xuICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbih3cml0ZXIuX3JlYWR5UHJvbWlzZSwgZnVuY3Rpb24gKCkge1xuICAgICByZXR1cm4gbmV3UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZVJlYWQsIHJlamVjdFJlYWQpIHtcbiAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCB7XG4gICAgICAgX2NodW5rU3RlcHM6IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICBjdXJyZW50V3JpdGUgPSBQZXJmb3JtUHJvbWlzZVRoZW4oV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGUod3JpdGVyLCBjaHVuayksIHVuZGVmaW5lZCwgbm9vcCk7XG4gICAgICAgIHJlc29sdmVSZWFkKGZhbHNlKTtcbiAgICAgICB9LFxuICAgICAgIF9jbG9zZVN0ZXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlUmVhZCh0cnVlKTtcbiAgICAgICB9LFxuICAgICAgIF9lcnJvclN0ZXBzOiByZWplY3RSZWFkXG4gICAgICB9KTtcbiAgICAgfSk7XG4gICAgfSk7XG4gICB9XG4gICBpc09yQmVjb21lc0Vycm9yZWQoc291cmNlLCByZWFkZXIuX2Nsb3NlZFByb21pc2UsIGZ1bmN0aW9uIChzdG9yZWRFcnJvcikge1xuICAgIGlmICghcHJldmVudEFib3J0KSB7XG4gICAgIHNodXRkb3duV2l0aEFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydChkZXN0LCBzdG9yZWRFcnJvcik7XG4gICAgIH0sIHRydWUsIHN0b3JlZEVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICBzaHV0ZG93bih0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgfVxuICAgfSk7XG4gICBpc09yQmVjb21lc0Vycm9yZWQoZGVzdCwgd3JpdGVyLl9jbG9zZWRQcm9taXNlLCBmdW5jdGlvbiAoc3RvcmVkRXJyb3IpIHtcbiAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcbiAgICAgc2h1dGRvd25XaXRoQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIHN0b3JlZEVycm9yKTtcbiAgICAgfSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgIHNodXRkb3duKHRydWUsIHN0b3JlZEVycm9yKTtcbiAgICB9XG4gICB9KTtcbiAgIGlzT3JCZWNvbWVzQ2xvc2VkKHNvdXJjZSwgcmVhZGVyLl9jbG9zZWRQcm9taXNlLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwcmV2ZW50Q2xvc2UpIHtcbiAgICAgc2h1dGRvd25XaXRoQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZVdpdGhFcnJvclByb3BhZ2F0aW9uKHdyaXRlcik7XG4gICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgIHNodXRkb3duKCk7XG4gICAgfVxuICAgfSk7XG4gICBpZiAoV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoZGVzdCkgfHwgZGVzdC5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgdmFyIGRlc3RDbG9zZWRfMSA9IG5ldyBUeXBlRXJyb3IoJ3RoZSBkZXN0aW5hdGlvbiB3cml0YWJsZSBzdHJlYW0gY2xvc2VkIGJlZm9yZSBhbGwgZGF0YSBjb3VsZCBiZSBwaXBlZCB0byBpdCcpO1xuICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICBzaHV0ZG93bldpdGhBY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHNvdXJjZSwgZGVzdENsb3NlZF8xKTtcbiAgICAgfSwgdHJ1ZSwgZGVzdENsb3NlZF8xKTtcbiAgICB9IGVsc2Uge1xuICAgICBzaHV0ZG93bih0cnVlLCBkZXN0Q2xvc2VkXzEpO1xuICAgIH1cbiAgIH1cbiAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocGlwZUxvb3AoKSk7XG4gICBmdW5jdGlvbiB3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSB7XG4gICAgdmFyIG9sZEN1cnJlbnRXcml0ZSA9IGN1cnJlbnRXcml0ZTtcbiAgICByZXR1cm4gUGVyZm9ybVByb21pc2VUaGVuKGN1cnJlbnRXcml0ZSwgZnVuY3Rpb24gKCkge1xuICAgICByZXR1cm4gb2xkQ3VycmVudFdyaXRlICE9PSBjdXJyZW50V3JpdGUgPyB3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgIH1cbiAgIGZ1bmN0aW9uIGlzT3JCZWNvbWVzRXJyb3JlZChzdHJlYW0sIHByb21pc2UsIGFjdGlvbikge1xuICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgYWN0aW9uKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgIHVwb25SZWplY3Rpb24ocHJvbWlzZSwgYWN0aW9uKTtcbiAgICB9XG4gICB9XG4gICBmdW5jdGlvbiBpc09yQmVjb21lc0Nsb3NlZChzdHJlYW0sIHByb21pc2UsIGFjdGlvbikge1xuICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICBhY3Rpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICB1cG9uRnVsZmlsbG1lbnQocHJvbWlzZSwgYWN0aW9uKTtcbiAgICB9XG4gICB9XG4gICBmdW5jdGlvbiBzaHV0ZG93bldpdGhBY3Rpb24oYWN0aW9uLCBvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG4gICAgIHJldHVybjtcbiAgICB9XG4gICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcbiAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScgJiYgIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpKSB7XG4gICAgIHVwb25GdWxmaWxsbWVudCh3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSwgZG9UaGVSZXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICBkb1RoZVJlc3QoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZG9UaGVSZXN0KCkge1xuICAgICB1cG9uUHJvbWlzZShhY3Rpb24oKSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZpbmFsaXplKG9yaWdpbmFsSXNFcnJvciwgb3JpZ2luYWxFcnJvcik7XG4gICAgIH0sIGZ1bmN0aW9uIChuZXdFcnJvcikge1xuICAgICAgcmV0dXJuIGZpbmFsaXplKHRydWUsIG5ld0Vycm9yKTtcbiAgICAgfSk7XG4gICAgfVxuICAgfVxuICAgZnVuY3Rpb24gc2h1dGRvd24oaXNFcnJvciwgZXJyb3IpIHtcbiAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG4gICAgIHJldHVybjtcbiAgICB9XG4gICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcbiAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScgJiYgIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpKSB7XG4gICAgIHVwb25GdWxmaWxsbWVudCh3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKTtcbiAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgZmluYWxpemUoaXNFcnJvciwgZXJyb3IpO1xuICAgIH1cbiAgIH1cbiAgIGZ1bmN0aW9uIGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKSB7XG4gICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh3cml0ZXIpO1xuICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbGdvcml0aG0pO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcikge1xuICAgICByZWplY3QoZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICB9XG4gIH0pO1xuIH1cbiB2YXIgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcigpIHtcbiAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgY29uc3RydWN0b3InKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFwiZGVzaXJlZFNpemVcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgIH1cbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICAgfSxcbiAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpO1xuICAgfVxuICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUodGhpcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBjbG9zZScpO1xuICAgfVxuICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHRoaXMpO1xuICB9O1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICBpZiAoY2h1bmsgPT09IHZvaWQgMCkge1xuICAgIGNodW5rID0gdW5kZWZpbmVkO1xuICAgfVxuICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcbiAgIH1cbiAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHRoaXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgZW5xdWV1ZScpO1xuICAgfVxuICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcbiAgfTtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgaWYgKGUgPT09IHZvaWQgMCkge1xuICAgIGUgPSB1bmRlZmluZWQ7XG4gICB9XG4gICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgIH1cbiAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgfTtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGVbQ2FuY2VsU3RlcHNdID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgUmVzZXRRdWV1ZSh0aGlzKTtcbiAgIHZhciByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZVtQdWxsU3RlcHNdID0gZnVuY3Rpb24gKHJlYWRSZXF1ZXN0KSB7XG4gICB2YXIgc3RyZWFtID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgY2h1bmsgPSBEZXF1ZXVlVmFsdWUodGhpcyk7XG4gICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gICAgfVxuICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKGNodW5rKTtcbiAgIH0gZWxzZSB7XG4gICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0sIHJlYWRSZXF1ZXN0KTtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcbiAgIH1cbiAgfTtcbiAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gfSgpO1xuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZW5xdWV1ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gfSk7XG4gaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyJyxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiB9XG4gZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHgpIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbScpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpIHtcbiAgdmFyIHNob3VsZFB1bGwgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcik7XG4gIGlmICghc2hvdWxkUHVsbCkge1xuICAgcmV0dXJuO1xuICB9XG4gIGlmIChjb250cm9sbGVyLl9wdWxsaW5nKSB7XG4gICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSB0cnVlO1xuICAgcmV0dXJuO1xuICB9XG4gIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSB0cnVlO1xuICB2YXIgcHVsbFByb21pc2UgPSBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtKCk7XG4gIHVwb25Qcm9taXNlKHB1bGxQcm9taXNlLCBmdW5jdGlvbiAoKSB7XG4gICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG4gICBpZiAoY29udHJvbGxlci5fcHVsbEFnYWluKSB7XG4gICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICB9XG4gIH0sIGZ1bmN0aW9uIChlKSB7XG4gICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwoY29udHJvbGxlcikge1xuICB2YXIgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBkZXNpcmVkU2l6ZSA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgaWYgKGRlc2lyZWRTaXplID4gMCkge1xuICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcbiAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShjb250cm9sbGVyKSB7XG4gIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG4gICByZXR1cm47XG4gIH1cbiAgdmFyIHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSB0cnVlO1xuICBpZiAoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG4gICByZXR1cm47XG4gIH1cbiAgdmFyIHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgdmFyIGNodW5rU2l6ZSA9IHZvaWQgMDtcbiAgIHRyeSB7XG4gICAgY2h1bmtTaXplID0gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcbiAgIH0gY2F0Y2ggKGNodW5rU2l6ZUUpIHtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgY2h1bmtTaXplRSk7XG4gICAgdGhyb3cgY2h1bmtTaXplRTtcbiAgIH1cbiAgIHRyeSB7XG4gICAgRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udHJvbGxlciwgY2h1bmssIGNodW5rU2l6ZSk7XG4gICB9IGNhdGNoIChlbnF1ZXVlRSkge1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlbnF1ZXVlRSk7XG4gICAgdGhyb3cgZW5xdWV1ZUU7XG4gICB9XG4gIH1cbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG4gIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICByZXR1cm47XG4gIH1cbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcikge1xuICB2YXIgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNIC0gY29udHJvbGxlci5fcXVldWVUb3RhbFNpemU7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUoY29udHJvbGxlcikge1xuICBpZiAoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShjb250cm9sbGVyKSB7XG4gIHZhciBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGU7XG4gIGlmICghY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgJiYgc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbiB9XG4gZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuICBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0gPSBzdHJlYW07XG4gIGNvbnRyb2xsZXIuX3F1ZXVlID0gdW5kZWZpbmVkO1xuICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcbiAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSBzaXplQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XG4gIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG4gIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgdmFyIHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcbiAgdXBvblByb21pc2UocHJvbWlzZVJlc29sdmVkV2l0aChzdGFydFJlc3VsdCksIGZ1bmN0aW9uICgpIHtcbiAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gIH0sIGZ1bmN0aW9uIChyKSB7XG4gICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgcik7XG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZShzdHJlYW0sIHVuZGVybHlpbmdTb3VyY2UsIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcbiAgdmFyIGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgdmFyIHN0YXJ0QWxnb3JpdGhtID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcbiAgdmFyIHB1bGxBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9O1xuICB2YXIgY2FuY2VsQWxnb3JpdGhtID0gZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfTtcbiAgaWYgKHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgc3RhcnRBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQoY29udHJvbGxlcik7XG4gICB9O1xuICB9XG4gIGlmICh1bmRlcmx5aW5nU291cmNlLnB1bGwgIT09IHVuZGVmaW5lZCkge1xuICAgcHVsbEFsZ29yaXRobSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdW5kZXJseWluZ1NvdXJjZS5wdWxsKGNvbnRyb2xsZXIpO1xuICAgfTtcbiAgfVxuICBpZiAodW5kZXJseWluZ1NvdXJjZS5jYW5jZWwgIT09IHVuZGVmaW5lZCkge1xuICAgY2FuY2VsQWxnb3JpdGhtID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB1bmRlcmx5aW5nU291cmNlLmNhbmNlbChyZWFzb24pO1xuICAgfTtcbiAgfVxuICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5cIiArIG5hbWUgKyBcIiBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiKTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1UZWUoc3RyZWFtLCBjbG9uZUZvckJyYW5jaDIpIHtcbiAgdmFyIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgdmFyIHJlYWRpbmcgPSBmYWxzZTtcbiAgdmFyIGNhbmNlbGVkMSA9IGZhbHNlO1xuICB2YXIgY2FuY2VsZWQyID0gZmFsc2U7XG4gIHZhciByZWFzb24xO1xuICB2YXIgcmVhc29uMjtcbiAgdmFyIGJyYW5jaDE7XG4gIHZhciBicmFuY2gyO1xuICB2YXIgcmVzb2x2ZUNhbmNlbFByb21pc2U7XG4gIHZhciBjYW5jZWxQcm9taXNlID0gbmV3UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgcmVzb2x2ZUNhbmNlbFByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcbiAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpIHtcbiAgIGlmIChyZWFkaW5nKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgIH1cbiAgIHJlYWRpbmcgPSB0cnVlO1xuICAgdmFyIHJlYWRSZXF1ZXN0ID0ge1xuICAgIF9jaHVua1N0ZXBzOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgcXVldWVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgdmFyIHZhbHVlMSA9IHZhbHVlO1xuICAgICAgdmFyIHZhbHVlMiA9IHZhbHVlO1xuICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHZhbHVlMSk7XG4gICAgICB9XG4gICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgdmFsdWUyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgIH0pO1xuICAgIH0sXG4gICAgX2Nsb3NlU3RlcHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgIH1cbiAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICB9XG4gICAgfSxcbiAgICBfZXJyb3JTdGVwczogZnVuY3Rpb24gKCkge1xuICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICAgfTtcbiAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG4gICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uKSB7XG4gICBjYW5jZWxlZDEgPSB0cnVlO1xuICAgcmVhc29uMSA9IHJlYXNvbjtcbiAgIGlmIChjYW5jZWxlZDIpIHtcbiAgICB2YXIgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbXG4gICAgIHJlYXNvbjEsXG4gICAgIHJlYXNvbjJcbiAgICBdKTtcbiAgICB2YXIgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICB9XG4gICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWwyQWxnb3JpdGhtKHJlYXNvbikge1xuICAgY2FuY2VsZWQyID0gdHJ1ZTtcbiAgIHJlYXNvbjIgPSByZWFzb247XG4gICBpZiAoY2FuY2VsZWQxKSB7XG4gICAgdmFyIGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW1xuICAgICByZWFzb24xLFxuICAgICByZWFzb24yXG4gICAgXSk7XG4gICAgdmFyIGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuICAgfVxuICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG4gIH1cbiAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwxQWxnb3JpdGhtKTtcbiAgYnJhbmNoMiA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWwyQWxnb3JpdGhtKTtcbiAgdXBvblJlamVjdGlvbihyZWFkZXIuX2Nsb3NlZFByb21pc2UsIGZ1bmN0aW9uIChyKSB7XG4gICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgfSk7XG4gIHJldHVybiBbXG4gICBicmFuY2gxLFxuICAgYnJhbmNoMlxuICBdO1xuIH1cbiBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2Uoc291cmNlLCBjb250ZXh0KSB7XG4gIGFzc2VydERpY3Rpb25hcnkoc291cmNlLCBjb250ZXh0KTtcbiAgdmFyIG9yaWdpbmFsID0gc291cmNlO1xuICB2YXIgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgdmFyIGNhbmNlbCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5jYW5jZWw7XG4gIHZhciBwdWxsID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnB1bGw7XG4gIHZhciBzdGFydCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5zdGFydDtcbiAgdmFyIHR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHlwZTtcbiAgcmV0dXJuIHtcbiAgIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTogYXV0b0FsbG9jYXRlQ2h1bmtTaXplID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoYXV0b0FsbG9jYXRlQ2h1bmtTaXplLCBjb250ZXh0ICsgXCIgaGFzIG1lbWJlciAnYXV0b0FsbG9jYXRlQ2h1bmtTaXplJyB0aGF0XCIpLFxuICAgY2FuY2VsOiBjYW5jZWwgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soY2FuY2VsLCBvcmlnaW5hbCwgY29udGV4dCArIFwiIGhhcyBtZW1iZXIgJ2NhbmNlbCcgdGhhdFwiKSxcbiAgIHB1bGw6IHB1bGwgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrKHB1bGwsIG9yaWdpbmFsLCBjb250ZXh0ICsgXCIgaGFzIG1lbWJlciAncHVsbCcgdGhhdFwiKSxcbiAgIHN0YXJ0OiBzdGFydCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgY29udGV4dCArIFwiIGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0XCIpLFxuICAgdHlwZTogdHlwZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSh0eXBlLCBjb250ZXh0ICsgXCIgaGFzIG1lbWJlciAndHlwZScgdGhhdFwiKVxuICB9O1xuIH1cbiBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAocmVhc29uKSB7XG4gICByZXR1cm4gcHJvbWlzZUNhbGwoZm4sIG9yaWdpbmFsLCBbcmVhc29uXSk7XG4gIH07XG4gfVxuIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgcmV0dXJuIHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgfTtcbiB9XG4gZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgcmV0dXJuIHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgfTtcbiB9XG4gZnVuY3Rpb24gY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSh0eXBlLCBjb250ZXh0KSB7XG4gIHR5cGUgPSBcIlwiICsgdHlwZTtcbiAgaWYgKHR5cGUgIT09ICdieXRlcycpIHtcbiAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29udGV4dCArIFwiICdcIiArIHR5cGUgKyBcIicgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtVHlwZVwiKTtcbiAgfVxuICByZXR1cm4gdHlwZTtcbiB9XG4gZnVuY3Rpb24gY29udmVydFJlYWRlck9wdGlvbnMob3B0aW9ucywgY29udGV4dCkge1xuICBhc3NlcnREaWN0aW9uYXJ5KG9wdGlvbnMsIGNvbnRleHQpO1xuICB2YXIgbW9kZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlO1xuICByZXR1cm4geyBtb2RlOiBtb2RlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlKG1vZGUsIGNvbnRleHQgKyBcIiBoYXMgbWVtYmVyICdtb2RlJyB0aGF0XCIpIH07XG4gfVxuIGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZSwgY29udGV4dCkge1xuICBtb2RlID0gXCJcIiArIG1vZGU7XG4gIGlmIChtb2RlICE9PSAnYnlvYicpIHtcbiAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29udGV4dCArIFwiICdcIiArIG1vZGUgKyBcIicgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtUmVhZGVyTW9kZVwiKTtcbiAgfVxuICByZXR1cm4gbW9kZTtcbiB9XG4gZnVuY3Rpb24gY29udmVydEl0ZXJhdG9yT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG4gIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gIHZhciBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRDYW5jZWw7XG4gIHJldHVybiB7IHByZXZlbnRDYW5jZWw6IEJvb2xlYW4ocHJldmVudENhbmNlbCkgfTtcbiB9XG4gZnVuY3Rpb24gY29udmVydFBpcGVPcHRpb25zKG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgYXNzZXJ0RGljdGlvbmFyeShvcHRpb25zLCBjb250ZXh0KTtcbiAgdmFyIHByZXZlbnRBYm9ydCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV2ZW50QWJvcnQ7XG4gIHZhciBwcmV2ZW50Q2FuY2VsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRDYW5jZWw7XG4gIHZhciBwcmV2ZW50Q2xvc2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENsb3NlO1xuICB2YXIgc2lnbmFsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbDtcbiAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICBhc3NlcnRBYm9ydFNpZ25hbChzaWduYWwsIGNvbnRleHQgKyBcIiBoYXMgbWVtYmVyICdzaWduYWwnIHRoYXRcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgIHByZXZlbnRBYm9ydDogQm9vbGVhbihwcmV2ZW50QWJvcnQpLFxuICAgcHJldmVudENhbmNlbDogQm9vbGVhbihwcmV2ZW50Q2FuY2VsKSxcbiAgIHByZXZlbnRDbG9zZTogQm9vbGVhbihwcmV2ZW50Q2xvc2UpLFxuICAgc2lnbmFsOiBzaWduYWxcbiAgfTtcbiB9XG4gZnVuY3Rpb24gYXNzZXJ0QWJvcnRTaWduYWwoc2lnbmFsLCBjb250ZXh0KSB7XG4gIGlmICghaXNBYm9ydFNpZ25hbChzaWduYWwpKSB7XG4gICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvbnRleHQgKyBcIiBpcyBub3QgYW4gQWJvcnRTaWduYWwuXCIpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpcihwYWlyLCBjb250ZXh0KSB7XG4gIGFzc2VydERpY3Rpb25hcnkocGFpciwgY29udGV4dCk7XG4gIHZhciByZWFkYWJsZSA9IHBhaXIgPT09IG51bGwgfHwgcGFpciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFpci5yZWFkYWJsZTtcbiAgYXNzZXJ0UmVxdWlyZWRGaWVsZChyZWFkYWJsZSwgJ3JlYWRhYmxlJywgJ1JlYWRhYmxlV3JpdGFibGVQYWlyJyk7XG4gIGFzc2VydFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlLCBjb250ZXh0ICsgXCIgaGFzIG1lbWJlciAncmVhZGFibGUnIHRoYXRcIik7XG4gIHZhciB3cml0YWJsZSA9IHBhaXIgPT09IG51bGwgfHwgcGFpciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFpci53cml0YWJsZTtcbiAgYXNzZXJ0UmVxdWlyZWRGaWVsZCh3cml0YWJsZSwgJ3dyaXRhYmxlJywgJ1JlYWRhYmxlV3JpdGFibGVQYWlyJyk7XG4gIGFzc2VydFdyaXRhYmxlU3RyZWFtKHdyaXRhYmxlLCBjb250ZXh0ICsgXCIgaGFzIG1lbWJlciAnd3JpdGFibGUnIHRoYXRcIik7XG4gIHJldHVybiB7XG4gICByZWFkYWJsZTogcmVhZGFibGUsXG4gICB3cml0YWJsZTogd3JpdGFibGVcbiAgfTtcbiB9XG4gdmFyIFJlYWRhYmxlU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbShyYXdVbmRlcmx5aW5nU291cmNlLCByYXdTdHJhdGVneSkge1xuICAgaWYgKHJhd1VuZGVybHlpbmdTb3VyY2UgPT09IHZvaWQgMCkge1xuICAgIHJhd1VuZGVybHlpbmdTb3VyY2UgPSB7fTtcbiAgIH1cbiAgIGlmIChyYXdTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgcmF3U3RyYXRlZ3kgPSB7fTtcbiAgIH1cbiAgIGlmIChyYXdVbmRlcmx5aW5nU291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICByYXdVbmRlcmx5aW5nU291cmNlID0gbnVsbDtcbiAgIH0gZWxzZSB7XG4gICAgYXNzZXJ0T2JqZWN0KHJhd1VuZGVybHlpbmdTb3VyY2UsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgIH1cbiAgIHZhciBzdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3U3RyYXRlZ3ksICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICB2YXIgdW5kZXJseWluZ1NvdXJjZSA9IGNvbnZlcnRVbmRlcmx5aW5nRGVmYXVsdE9yQnl0ZVNvdXJjZShyYXdVbmRlcmx5aW5nU291cmNlLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0odGhpcyk7XG4gICBpZiAodW5kZXJseWluZ1NvdXJjZS50eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgaWYgKHN0cmF0ZWd5LnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHN0cmF0ZWd5IGZvciBhIGJ5dGUgc3RyZWFtIGNhbm5vdCBoYXZlIGEgc2l6ZSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAwKTtcbiAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSh0aGlzLCB1bmRlcmx5aW5nU291cmNlLCBoaWdoV2F0ZXJNYXJrKTtcbiAgIH0gZWxzZSB7XG4gICAgdmFyIHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XG4gICAgdmFyIGhpZ2hXYXRlck1hcmsgPSBFeHRyYWN0SGlnaFdhdGVyTWFyayhzdHJhdGVneSwgMSk7XG4gICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UodGhpcywgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gICB9XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwgXCJsb2NrZWRcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnbG9ja2VkJyk7XG4gICAgfVxuICAgIHJldHVybiBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpO1xuICAgfSxcbiAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgaWYgKHJlYXNvbiA9PT0gdm9pZCAwKSB7XG4gICAgcmVhc29uID0gdW5kZWZpbmVkO1xuICAgfVxuICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdjYW5jZWwnKSk7XG4gICB9XG4gICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYW5jZWwgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHJlYWRlcicpKTtcbiAgIH1cbiAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbCh0aGlzLCByZWFzb24pO1xuICB9O1xuICBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuZ2V0UmVhZGVyID0gZnVuY3Rpb24gKHJhd09wdGlvbnMpIHtcbiAgIGlmIChyYXdPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICByYXdPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgfVxuICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdnZXRSZWFkZXInKTtcbiAgIH1cbiAgIHZhciBvcHRpb25zID0gY29udmVydFJlYWRlck9wdGlvbnMocmF3T3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgaWYgKG9wdGlvbnMubW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcyk7XG4gICB9XG4gICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKTtcbiAgfTtcbiAgUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoID0gZnVuY3Rpb24gKHJhd1RyYW5zZm9ybSwgcmF3T3B0aW9ucykge1xuICAgaWYgKHJhd09wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIHJhd09wdGlvbnMgPSB7fTtcbiAgIH1cbiAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgncGlwZVRocm91Z2gnKTtcbiAgIH1cbiAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQocmF3VHJhbnNmb3JtLCAxLCAncGlwZVRocm91Z2gnKTtcbiAgIHZhciB0cmFuc2Zvcm0gPSBjb252ZXJ0UmVhZGFibGVXcml0YWJsZVBhaXIocmF3VHJhbnNmb3JtLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICB2YXIgb3B0aW9ucyA9IGNvbnZlcnRQaXBlT3B0aW9ucyhyYXdPcHRpb25zLCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW0nKTtcbiAgIH1cbiAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRyYW5zZm9ybS53cml0YWJsZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW0nKTtcbiAgIH1cbiAgIHZhciBwcm9taXNlID0gUmVhZGFibGVTdHJlYW1QaXBlVG8odGhpcywgdHJhbnNmb3JtLndyaXRhYmxlLCBvcHRpb25zLnByZXZlbnRDbG9zZSwgb3B0aW9ucy5wcmV2ZW50QWJvcnQsIG9wdGlvbnMucHJldmVudENhbmNlbCwgb3B0aW9ucy5zaWduYWwpO1xuICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwcm9taXNlKTtcbiAgIHJldHVybiB0cmFuc2Zvcm0ucmVhZGFibGU7XG4gIH07XG4gIFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHJhd09wdGlvbnMpIHtcbiAgIGlmIChyYXdPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICByYXdPcHRpb25zID0ge307XG4gICB9XG4gICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3BpcGVUbycpKTtcbiAgIH1cbiAgIGlmIChkZXN0aW5hdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoXCJQYXJhbWV0ZXIgMSBpcyByZXF1aXJlZCBpbiAncGlwZVRvJy5cIik7XG4gICB9XG4gICBpZiAoIUlzV3JpdGFibGVTdHJlYW0oZGVzdGluYXRpb24pKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8ncyBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgV3JpdGFibGVTdHJlYW1cIikpO1xuICAgfVxuICAgdmFyIG9wdGlvbnM7XG4gICB0cnkge1xuICAgIG9wdGlvbnMgPSBjb252ZXJ0UGlwZU9wdGlvbnMocmF3T3B0aW9ucywgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChlKTtcbiAgIH1cbiAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbyBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBSZWFkYWJsZVN0cmVhbScpKTtcbiAgIH1cbiAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKGRlc3RpbmF0aW9uKSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW0nKSk7XG4gICB9XG4gICByZXR1cm4gUmVhZGFibGVTdHJlYW1QaXBlVG8odGhpcywgZGVzdGluYXRpb24sIG9wdGlvbnMucHJldmVudENsb3NlLCBvcHRpb25zLnByZXZlbnRBYm9ydCwgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsLCBvcHRpb25zLnNpZ25hbCk7XG4gIH07XG4gIFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS50ZWUgPSBmdW5jdGlvbiAoKSB7XG4gICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3RlZScpO1xuICAgfVxuICAgdmFyIGJyYW5jaGVzID0gUmVhZGFibGVTdHJlYW1UZWUodGhpcyk7XG4gICByZXR1cm4gQ3JlYXRlQXJyYXlGcm9tTGlzdChicmFuY2hlcyk7XG4gIH07XG4gIFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAocmF3T3B0aW9ucykge1xuICAgaWYgKHJhd09wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIHJhd09wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICB9XG4gICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3ZhbHVlcycpO1xuICAgfVxuICAgdmFyIG9wdGlvbnMgPSBjb252ZXJ0SXRlcmF0b3JPcHRpb25zKHJhd09wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgIHJldHVybiBBY3F1aXJlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMsIG9wdGlvbnMucHJldmVudENhbmNlbCk7XG4gIH07XG4gIHJldHVybiBSZWFkYWJsZVN0cmVhbTtcbiB9KCk7XG4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCB7XG4gIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGdldFJlYWRlcjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHBpcGVUaHJvdWdoOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgcGlwZVRvOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgdGVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgdmFsdWVzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgbG9ja2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuIH0pO1xuIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICB2YWx1ZTogJ1JlYWRhYmxlU3RyZWFtJyxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiB9XG4gaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC5hc3luY0l0ZXJhdG9yID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC5hc3luY0l0ZXJhdG9yLCB7XG4gICB2YWx1ZTogUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnZhbHVlcyxcbiAgIHdyaXRhYmxlOiB0cnVlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG4gIGlmIChoaWdoV2F0ZXJNYXJrID09PSB2b2lkIDApIHtcbiAgIGhpZ2hXYXRlck1hcmsgPSAxO1xuICB9XG4gIGlmIChzaXplQWxnb3JpdGhtID09PSB2b2lkIDApIHtcbiAgIHNpemVBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDE7XG4gICB9O1xuICB9XG4gIHZhciBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG4gIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbShzdHJlYW0pO1xuICB2YXIgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgcmV0dXJuIHN0cmVhbTtcbiB9XG4gZnVuY3Rpb24gSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICBzdHJlYW0uX3N0YXRlID0gJ3JlYWRhYmxlJztcbiAgc3RyZWFtLl9yZWFkZXIgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fZGlzdHVyYmVkID0gZmFsc2U7XG4gfVxuIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW0oeCkge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZGFibGVTdHJlYW1Db250cm9sbGVyJykpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbS5fcmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pIHtcbiAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cbiAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICB2YXIgc291cmNlQ2FuY2VsUHJvbWlzZSA9IHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW0NhbmNlbFN0ZXBzXShyZWFzb24pO1xuICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoc291cmNlQ2FuY2VsUHJvbWlzZSwgbm9vcCk7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5fc3RhdGUgPSAnY2xvc2VkJztcbiAgdmFyIHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybjtcbiAgfVxuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKTtcbiAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcbiAgIHJlYWRlci5fcmVhZFJlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlYWRSZXF1ZXN0KSB7XG4gICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcbiAgIH0pO1xuICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUVycm9yKHN0cmVhbSwgZSkge1xuICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yZWQnO1xuICBzdHJlYW0uX3N0b3JlZEVycm9yID0gZTtcbiAgdmFyIHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybjtcbiAgfVxuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIGUpO1xuICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVhZFJlcXVlc3QpIHtcbiAgICByZWFkUmVxdWVzdC5fZXJyb3JTdGVwcyhlKTtcbiAgIH0pO1xuICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfSBlbHNlIHtcbiAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWFkSW50b1JlcXVlc3QpIHtcbiAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG4gICB9KTtcbiAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMShuYW1lKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLlwiICsgbmFtZSArIFwiIGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbVwiKTtcbiB9XG4gZnVuY3Rpb24gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQoaW5pdCwgY29udGV4dCkge1xuICBhc3NlcnREaWN0aW9uYXJ5KGluaXQsIGNvbnRleHQpO1xuICB2YXIgaGlnaFdhdGVyTWFyayA9IGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5oaWdoV2F0ZXJNYXJrO1xuICBhc3NlcnRSZXF1aXJlZEZpZWxkKGhpZ2hXYXRlck1hcmssICdoaWdoV2F0ZXJNYXJrJywgJ1F1ZXVpbmdTdHJhdGVneUluaXQnKTtcbiAgcmV0dXJuIHsgaGlnaFdhdGVyTWFyazogY29udmVydFVucmVzdHJpY3RlZERvdWJsZShoaWdoV2F0ZXJNYXJrKSB9O1xuIH1cbiB2YXIgYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiA9IGZ1bmN0aW9uIHNpemUoY2h1bmspIHtcbiAgcmV0dXJuIGNodW5rLmJ5dGVMZW5ndGg7XG4gfTtcbiB2YXIgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneShvcHRpb25zKSB7XG4gICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KG9wdGlvbnMsIDEsICdCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5Jyk7XG4gICBvcHRpb25zID0gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQob3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsgPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCBcImhpZ2hXYXRlck1hcmtcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgdGhyb3cgYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24oJ2hpZ2hXYXRlck1hcmsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrO1xuICAgfSxcbiAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUlzQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuICAgICB0aHJvdyBieXRlTGVuZ3RoQnJhbmRDaGVja0V4Y2VwdGlvbignc2l6ZScpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZUxlbmd0aFNpemVGdW5jdGlvbjtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3k7XG4gfSgpO1xuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCB7XG4gIGhpZ2hXYXRlck1hcms6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuIH0pO1xuIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgIHZhbHVlOiAnQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneScsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gfVxuIGZ1bmN0aW9uIGJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS5cIiArIG5hbWUgKyBcIiBjYW4gb25seSBiZSB1c2VkIG9uIGEgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneVwiKTtcbiB9XG4gZnVuY3Rpb24gSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHgpIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrJykpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gdmFyIGNvdW50U2l6ZUZ1bmN0aW9uID0gZnVuY3Rpb24gc2l6ZSgpIHtcbiAgcmV0dXJuIDE7XG4gfTtcbiB2YXIgQ291bnRRdWV1aW5nU3RyYXRlZ3kgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvdW50UXVldWluZ1N0cmF0ZWd5KG9wdGlvbnMpIHtcbiAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQob3B0aW9ucywgMSwgJ0NvdW50UXVldWluZ1N0cmF0ZWd5Jyk7XG4gICBvcHRpb25zID0gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQob3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgdGhpcy5fY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFwiaGlnaFdhdGVyTWFya1wiLCB7XG4gICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUlzQ291bnRRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgdGhyb3cgY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKCdoaWdoV2F0ZXJNYXJrJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms7XG4gICB9LFxuICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUlzQ291bnRRdWV1aW5nU3RyYXRlZ3kodGhpcykpIHtcbiAgICAgdGhyb3cgY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKCdzaXplJyk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudFNpemVGdW5jdGlvbjtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIENvdW50UXVldWluZ1N0cmF0ZWd5O1xuIH0oKTtcbiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUsIHtcbiAgaGlnaFdhdGVyTWFyazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gfSk7XG4gaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgIHZhbHVlOiAnQ291bnRRdWV1aW5nU3RyYXRlZ3knLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIkNvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS5cIiArIG5hbWUgKyBcIiBjYW4gb25seSBiZSB1c2VkIG9uIGEgQ291bnRRdWV1aW5nU3RyYXRlZ3lcIik7XG4gfVxuIGZ1bmN0aW9uIElzQ291bnRRdWV1aW5nU3RyYXRlZ3koeCkge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrJykpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyKG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gIGFzc2VydERpY3Rpb25hcnkob3JpZ2luYWwsIGNvbnRleHQpO1xuICB2YXIgZmx1c2ggPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuZmx1c2g7XG4gIHZhciByZWFkYWJsZVR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwucmVhZGFibGVUeXBlO1xuICB2YXIgc3RhcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuc3RhcnQ7XG4gIHZhciB0cmFuc2Zvcm0gPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHJhbnNmb3JtO1xuICB2YXIgd3JpdGFibGVUeXBlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLndyaXRhYmxlVHlwZTtcbiAgcmV0dXJuIHtcbiAgIGZsdXNoOiBmbHVzaCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayhmbHVzaCwgb3JpZ2luYWwsIGNvbnRleHQgKyBcIiBoYXMgbWVtYmVyICdmbHVzaCcgdGhhdFwiKSxcbiAgIHJlYWRhYmxlVHlwZTogcmVhZGFibGVUeXBlLFxuICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0VHJhbnNmb3JtZXJTdGFydENhbGxiYWNrKHN0YXJ0LCBvcmlnaW5hbCwgY29udGV4dCArIFwiIGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0XCIpLFxuICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKHRyYW5zZm9ybSwgb3JpZ2luYWwsIGNvbnRleHQgKyBcIiBoYXMgbWVtYmVyICd0cmFuc2Zvcm0nIHRoYXRcIiksXG4gICB3cml0YWJsZVR5cGU6IHdyaXRhYmxlVHlwZVxuICB9O1xuIH1cbiBmdW5jdGlvbiBjb252ZXJ0VHJhbnNmb3JtZXJGbHVzaENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgcmV0dXJuIHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgfTtcbiB9XG4gZnVuY3Rpb24gY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgIHJldHVybiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG4gIH07XG4gfVxuIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgIHJldHVybiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtcbiAgICBjaHVuayxcbiAgICBjb250cm9sbGVyXG4gICBdKTtcbiAgfTtcbiB9XG4gdmFyIFRyYW5zZm9ybVN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtKHJhd1RyYW5zZm9ybWVyLCByYXdXcml0YWJsZVN0cmF0ZWd5LCByYXdSZWFkYWJsZVN0cmF0ZWd5KSB7XG4gICBpZiAocmF3VHJhbnNmb3JtZXIgPT09IHZvaWQgMCkge1xuICAgIHJhd1RyYW5zZm9ybWVyID0ge307XG4gICB9XG4gICBpZiAocmF3V3JpdGFibGVTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgcmF3V3JpdGFibGVTdHJhdGVneSA9IHt9O1xuICAgfVxuICAgaWYgKHJhd1JlYWRhYmxlU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIHJhd1JlYWRhYmxlU3RyYXRlZ3kgPSB7fTtcbiAgIH1cbiAgIGlmIChyYXdUcmFuc2Zvcm1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmF3VHJhbnNmb3JtZXIgPSBudWxsO1xuICAgfVxuICAgdmFyIHdyaXRhYmxlU3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1dyaXRhYmxlU3RyYXRlZ3ksICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICB2YXIgcmVhZGFibGVTdHJhdGVneSA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3kocmF3UmVhZGFibGVTdHJhdGVneSwgJ1RoaXJkIHBhcmFtZXRlcicpO1xuICAgdmFyIHRyYW5zZm9ybWVyID0gY29udmVydFRyYW5zZm9ybWVyKHJhd1RyYW5zZm9ybWVyLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICBpZiAodHJhbnNmb3JtZXIucmVhZGFibGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCByZWFkYWJsZVR5cGUgc3BlY2lmaWVkJyk7XG4gICB9XG4gICBpZiAodHJhbnNmb3JtZXIud3JpdGFibGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB3cml0YWJsZVR5cGUgc3BlY2lmaWVkJyk7XG4gICB9XG4gICB2YXIgcmVhZGFibGVIaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsocmVhZGFibGVTdHJhdGVneSwgMCk7XG4gICB2YXIgcmVhZGFibGVTaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0ocmVhZGFibGVTdHJhdGVneSk7XG4gICB2YXIgd3JpdGFibGVIaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsod3JpdGFibGVTdHJhdGVneSwgMSk7XG4gICB2YXIgd3JpdGFibGVTaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0od3JpdGFibGVTdHJhdGVneSk7XG4gICB2YXIgc3RhcnRQcm9taXNlX3Jlc29sdmU7XG4gICB2YXIgc3RhcnRQcm9taXNlID0gbmV3UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIHN0YXJ0UHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgIH0pO1xuICAgSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbSh0aGlzLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG4gICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVRyYW5zZm9ybWVyKHRoaXMsIHRyYW5zZm9ybWVyKTtcbiAgIGlmICh0cmFuc2Zvcm1lci5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodHJhbnNmb3JtZXIuc3RhcnQodGhpcy5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcikpO1xuICAgfSBlbHNlIHtcbiAgICBzdGFydFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgfVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCBcInJlYWRhYmxlXCIsIHtcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW0odGhpcykpIHtcbiAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdyZWFkYWJsZScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGU7XG4gICB9LFxuICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCBcIndyaXRhYmxlXCIsIHtcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghSXNUcmFuc2Zvcm1TdHJlYW0odGhpcykpIHtcbiAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCd3cml0YWJsZScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGU7XG4gICB9LFxuICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBUcmFuc2Zvcm1TdHJlYW07XG4gfSgpO1xuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUsIHtcbiAgcmVhZGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICB3cml0YWJsZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiB9KTtcbiBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgIHZhbHVlOiAnVHJhbnNmb3JtU3RyZWFtJyxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiB9XG4gZnVuY3Rpb24gSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbShzdHJlYW0sIHN0YXJ0UHJvbWlzZSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKSB7XG4gIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xuICAgcmV0dXJuIHN0YXJ0UHJvbWlzZTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZUFsZ29yaXRobShjaHVuaykge1xuICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rV3JpdGVBbGdvcml0aG0oc3RyZWFtLCBjaHVuayk7XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnRBbGdvcml0aG0ocmVhc29uKSB7XG4gICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtBYm9ydEFsZ29yaXRobShzdHJlYW0sIHJlYXNvbik7XG4gIH1cbiAgZnVuY3Rpb24gY2xvc2VBbGdvcml0aG0oKSB7XG4gICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtDbG9zZUFsZ29yaXRobShzdHJlYW0pO1xuICB9XG4gIHN0cmVhbS5fd3JpdGFibGUgPSBDcmVhdGVXcml0YWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0pO1xuICBmdW5jdGlvbiBwdWxsQWxnb3JpdGhtKCkge1xuICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSk7XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsQWxnb3JpdGhtKHJlYXNvbikge1xuICAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIHJlYXNvbik7XG4gICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9XG4gIHN0cmVhbS5fcmVhZGFibGUgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gdW5kZWZpbmVkO1xuICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCB0cnVlKTtcbiAgc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuIH1cbiBmdW5jdGlvbiBJc1RyYW5zZm9ybVN0cmVhbSh4KSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ190cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyJykpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKSB7XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGUpO1xuICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZSk7XG4gfVxuIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKSB7XG4gIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcik7XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKHN0cmVhbS5fd3JpdGFibGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciwgZSk7XG4gIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgZmFsc2UpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSkge1xuICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlKCk7XG4gIH1cbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gbmV3UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICB9KTtcbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBiYWNrcHJlc3N1cmU7XG4gfVxuIHZhciBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoKSB7XG4gICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgXCJkZXNpcmVkU2l6ZVwiLCB7XG4gICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2Rlc2lyZWRTaXplJyk7XG4gICAgfVxuICAgIHZhciByZWFkYWJsZUNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUocmVhZGFibGVDb250cm9sbGVyKTtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgIGlmIChjaHVuayA9PT0gdm9pZCAwKSB7XG4gICAgY2h1bmsgPSB1bmRlZmluZWQ7XG4gICB9XG4gICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZW5xdWV1ZScpO1xuICAgfVxuICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHRoaXMsIGNodW5rKTtcbiAgfTtcbiAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgaWYgKHJlYXNvbiA9PT0gdm9pZCAwKSB7XG4gICAgcmVhc29uID0gdW5kZWZpbmVkO1xuICAgfVxuICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2Vycm9yJyk7XG4gICB9XG4gICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIHJlYXNvbik7XG4gIH07XG4gIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS50ZXJtaW5hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgndGVybWluYXRlJyk7XG4gICB9XG4gICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclRlcm1pbmF0ZSh0aGlzKTtcbiAgfTtcbiAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuIH0oKTtcbiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgZW5xdWV1ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgdGVybWluYXRlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gfSk7XG4gaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgIHZhbHVlOiAnVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHgpIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0nKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgdHJhbnNmb3JtQWxnb3JpdGhtLCBmbHVzaEFsZ29yaXRobSkge1xuICBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtID0gc3RyZWFtO1xuICBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB0cmFuc2Zvcm1BbGdvcml0aG07XG4gIGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtID0gZmx1c2hBbGdvcml0aG07XG4gfVxuIGZ1bmN0aW9uIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXIoc3RyZWFtLCB0cmFuc2Zvcm1lcikge1xuICB2YXIgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgdmFyIHRyYW5zZm9ybUFsZ29yaXRobSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgdHJ5IHtcbiAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspO1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICB9IGNhdGNoICh0cmFuc2Zvcm1SZXN1bHRFKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodHJhbnNmb3JtUmVzdWx0RSk7XG4gICB9XG4gIH07XG4gIHZhciBmbHVzaEFsZ29yaXRobSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH07XG4gIGlmICh0cmFuc2Zvcm1lci50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgdHJhbnNmb3JtQWxnb3JpdGhtID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyLnRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcik7XG4gICB9O1xuICB9XG4gIGlmICh0cmFuc2Zvcm1lci5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICBmbHVzaEFsZ29yaXRobSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXIuZmx1c2goY29udHJvbGxlcik7XG4gICB9O1xuICB9XG4gIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCB0cmFuc2Zvcm1BbGdvcml0aG0sIGZsdXNoQWxnb3JpdGhtKTtcbiB9XG4gZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuICBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gIGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuIH1cbiBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspIHtcbiAgdmFyIHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW07XG4gIHZhciByZWFkYWJsZUNvbnRyb2xsZXIgPSBzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHJlYWRhYmxlQ29udHJvbGxlcikpIHtcbiAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlIHNpZGUgaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWUnKTtcbiAgfVxuICB0cnkge1xuICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUocmVhZGFibGVDb250cm9sbGVyLCBjaHVuayk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKTtcbiAgIHRocm93IHN0cmVhbS5fcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuICB9XG4gIHZhciBiYWNrcHJlc3N1cmUgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlKHJlYWRhYmxlQ29udHJvbGxlcik7XG4gIGlmIChiYWNrcHJlc3N1cmUgIT09IHN0cmVhbS5fYmFja3ByZXNzdXJlKSB7XG4gICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCB0cnVlKTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpIHtcbiAgVHJhbnNmb3JtU3RyZWFtRXJyb3IoY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSwgZSk7XG4gfVxuIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuaykge1xuICB2YXIgdHJhbnNmb3JtUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobShjaHVuayk7XG4gIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aCh0cmFuc2Zvcm1Qcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uIChyKSB7XG4gICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLCByKTtcbiAgIHRocm93IHI7XG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclRlcm1pbmF0ZShjb250cm9sbGVyKSB7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtO1xuICB2YXIgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UocmVhZGFibGVDb250cm9sbGVyKTtcbiAgdmFyIGVycm9yID0gbmV3IFR5cGVFcnJvcignVHJhbnNmb3JtU3RyZWFtIHRlcm1pbmF0ZWQnKTtcbiAgVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGVycm9yKTtcbiB9XG4gZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobShzdHJlYW0sIGNodW5rKSB7XG4gIHZhciBjb250cm9sbGVyID0gc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO1xuICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgIHZhciBiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlO1xuICAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKGJhY2twcmVzc3VyZUNoYW5nZVByb21pc2UsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgd3JpdGFibGUgPSBzdHJlYW0uX3dyaXRhYmxlO1xuICAgIHZhciBzdGF0ZSA9IHdyaXRhYmxlLl9zdGF0ZTtcbiAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAgdGhyb3cgd3JpdGFibGUuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtKGNvbnRyb2xsZXIsIGNodW5rKTtcbiAgIH0pO1xuICB9XG4gIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm0oY29udHJvbGxlciwgY2h1bmspO1xuIH1cbiBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Fib3J0QWxnb3JpdGhtKHN0cmVhbSwgcmVhc29uKSB7XG4gIFRyYW5zZm9ybVN0cmVhbUVycm9yKHN0cmVhbSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiB9XG4gZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtDbG9zZUFsZ29yaXRobShzdHJlYW0pIHtcbiAgdmFyIHJlYWRhYmxlID0gc3RyZWFtLl9yZWFkYWJsZTtcbiAgdmFyIGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG4gIHZhciBmbHVzaFByb21pc2UgPSBjb250cm9sbGVyLl9mbHVzaEFsZ29yaXRobSgpO1xuICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgcmV0dXJuIHRyYW5zZm9ybVByb21pc2VXaXRoKGZsdXNoUHJvbWlzZSwgZnVuY3Rpb24gKCkge1xuICAgaWYgKHJlYWRhYmxlLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgdGhyb3cgcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuICAgfVxuICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHJlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICB9LCBmdW5jdGlvbiAocikge1xuICAgVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCByKTtcbiAgIHRocm93IHJlYWRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgfSk7XG4gfVxuIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSkge1xuICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBmYWxzZSk7XG4gIHJldHVybiBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2U7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuXCIgKyBuYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyXCIpO1xuIH1cbiBmdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIobmFtZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUuXCIgKyBuYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbVwiKTtcbiB9XG4gZXhwb3J0cy5CeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5ID0gQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneTtcbiBleHBvcnRzLkNvdW50UXVldWluZ1N0cmF0ZWd5ID0gQ291bnRRdWV1aW5nU3RyYXRlZ3k7XG4gZXhwb3J0cy5SZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcbiBleHBvcnRzLlJlYWRhYmxlU3RyZWFtID0gUmVhZGFibGVTdHJlYW07XG4gZXhwb3J0cy5SZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIgPSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXI7XG4gZXhwb3J0cy5SZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0ID0gUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcbiBleHBvcnRzLlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuIGV4cG9ydHMuUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyO1xuIGV4cG9ydHMuVHJhbnNmb3JtU3RyZWFtID0gVHJhbnNmb3JtU3RyZWFtO1xuIGV4cG9ydHMuVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgPSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiBleHBvcnRzLldyaXRhYmxlU3RyZWFtID0gV3JpdGFibGVTdHJlYW07XG4gZXhwb3J0cy5Xcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiBleHBvcnRzLldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjtcbiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufSkpO1xuXG4vKioqLyB9KSxcbi8qIDEyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMTIzKTtcbnZhciBlbnRyeVVuYmluZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI3KTtcbm1vZHVsZS5leHBvcnRzID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdwYWRTdGFydCcpO1xuXG4vKioqLyB9KSxcbi8qIDEyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXyg5KTtcbnZhciAkcGFkU3RhcnQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyNCkuc3RhcnQ7XG52YXIgV0VCS0lUX0JVRyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI2KTtcbiQoe1xuIHRhcmdldDogJ1N0cmluZycsXG4gcHJvdG86IHRydWUsXG4gZm9yY2VkOiBXRUJLSVRfQlVHXG59LCB7XG4gcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCkge1xuICByZXR1cm4gJHBhZFN0YXJ0KHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0xlbmd0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDYpO1xudmFyIHJlcGVhdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI1KTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxOSk7XG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfRU5EKSB7XG4gcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nKSB7XG4gIHZhciBTID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgdmFyIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoO1xuICB2YXIgZmlsbFN0ciA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKTtcbiAgdmFyIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIHZhciBmaWxsTGVuLCBzdHJpbmdGaWxsZXI7XG4gIGlmIChpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpXG4gICByZXR1cm4gUztcbiAgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aDtcbiAgc3RyaW5nRmlsbGVyID0gcmVwZWF0LmNhbGwoZmlsbFN0ciwgY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYgKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKVxuICAgc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gSVNfRU5EID8gUyArIHN0cmluZ0ZpbGxlciA6IHN0cmluZ0ZpbGxlciArIFM7XG4gfTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiBzdGFydDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiBlbmQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcblxuLyoqKi8gfSksXG4vKiAxMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHRvSW50ZWdlciA9IF9fd19wZGZqc19yZXF1aXJlX18oNDcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5KTtcbm1vZHVsZS5leHBvcnRzID0gJycucmVwZWF0IHx8IGZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuIHZhciBzdHIgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gdmFyIHJlc3VsdCA9ICcnO1xuIHZhciBuID0gdG9JbnRlZ2VyKGNvdW50KTtcbiBpZiAobiA8IDAgfHwgbiA9PSBJbmZpbml0eSlcbiAgdGhyb3cgUmFuZ2VFcnJvcignV3JvbmcgbnVtYmVyIG9mIHJlcGV0aXRpb25zJyk7XG4gZm9yICg7IG4gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSlcbiAgaWYgKG4gJiAxKVxuICAgcmVzdWx0ICs9IHN0cjtcbiByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqKi8gfSksXG4vKiAxMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgdXNlckFnZW50ID0gX193X3BkZmpzX3JlcXVpcmVfXyg5NSk7XG5tb2R1bGUuZXhwb3J0cyA9IC9WZXJzaW9uXFwvMTBcXC5cXGQrKFxcLlxcZCspPyggTW9iaWxlXFwvXFx3Kyk/IFNhZmFyaVxcLy8udGVzdCh1c2VyQWdlbnQpO1xuXG4vKioqLyB9KSxcbi8qIDEyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBiaW5kID0gX193X3BkZmpzX3JlcXVpcmVfXyg3NSk7XG52YXIgY2FsbCA9IEZ1bmN0aW9uLmNhbGw7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUiwgTUVUSE9ELCBsZW5ndGgpIHtcbiByZXR1cm4gYmluZChjYWxsLCBnbG9iYWxbQ09OU1RSVUNUT1JdLnByb3RvdHlwZVtNRVRIT0RdLCBsZW5ndGgpO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5fX3dfcGRmanNfcmVxdWlyZV9fKDEyOSk7XG52YXIgZW50cnlVbmJpbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyNyk7XG5tb2R1bGUuZXhwb3J0cyA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAncGFkRW5kJyk7XG5cbi8qKiovIH0pLFxuLyogMTI5ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkpO1xudmFyICRwYWRFbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyNCkuZW5kO1xudmFyIFdFQktJVF9CVUcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyNik7XG4kKHtcbiB0YXJnZXQ6ICdTdHJpbmcnLFxuIHByb3RvOiB0cnVlLFxuIGZvcmNlZDogV0VCS0lUX0JVR1xufSwge1xuIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCkge1xuICByZXR1cm4gJHBhZEVuZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5fX3dfcGRmanNfcmVxdWlyZV9fKDEzMSk7XG52YXIgcGF0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDIpO1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoLk9iamVjdC52YWx1ZXM7XG5cbi8qKiovIH0pLFxuLyogMTMxICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oOSk7XG52YXIgJHZhbHVlcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMyKS52YWx1ZXM7XG4kKHtcbiB0YXJnZXQ6ICdPYmplY3QnLFxuIHN0YXQ6IHRydWVcbn0sIHtcbiB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhPKSB7XG4gIHJldHVybiAkdmFsdWVzKE8pO1xuIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTIpO1xudmFyIG9iamVjdEtleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYwKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2KTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpLmY7XG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRPX0VOVFJJRVMpIHtcbiByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKE8pO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAga2V5ID0ga2V5c1tpKytdO1xuICAgaWYgKCFERVNDUklQVE9SUyB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKE8sIGtleSkpIHtcbiAgICByZXN1bHQucHVzaChUT19FTlRSSUVTID8gW1xuICAgICBrZXksXG4gICAgIE9ba2V5XVxuICAgIF0gOiBPW2tleV0pO1xuICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG4gfTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiBlbnRyaWVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gdmFsdWVzOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuXG4vKioqLyB9KSxcbi8qIDEzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMTM0KTtcbnZhciBwYXRoID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Mik7XG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguT2JqZWN0LmVudHJpZXM7XG5cbi8qKiovIH0pLFxuLyogMTM0ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oOSk7XG52YXIgJGVudHJpZXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzMikuZW50cmllcztcbiQoe1xuIHRhcmdldDogJ09iamVjdCcsXG4gc3RhdDogdHJ1ZVxufSwge1xuIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoTykge1xuICByZXR1cm4gJGVudHJpZXMoTyk7XG4gfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMTM1ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5nZXREb2N1bWVudCA9IGdldERvY3VtZW50O1xuZXhwb3J0cy5zZXRQREZOZXR3b3JrU3RyZWFtRmFjdG9yeSA9IHNldFBERk5ldHdvcmtTdHJlYW1GYWN0b3J5O1xuZXhwb3J0cy52ZXJzaW9uID0gZXhwb3J0cy5QREZXb3JrZXIgPSBleHBvcnRzLlBERlBhZ2VQcm94eSA9IGV4cG9ydHMuUERGRG9jdW1lbnRQcm94eSA9IGV4cG9ydHMuUERGRGF0YVJhbmdlVHJhbnNwb3J0ID0gZXhwb3J0cy5Mb29wYmFja1BvcnQgPSBleHBvcnRzLnB1dEJpbmFyeUltYWdlRGF0YSA9IGV4cG9ydHMuRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gZXhwb3J0cy5EZWZhdWx0Q2FudmFzRmFjdG9yeSA9IGV4cG9ydHMuYnVpbGQgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd19wZGZqc19yZXF1aXJlX18oMikpO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2ZvbnRfbG9hZGVyID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzYpO1xuXG52YXIgX25vZGVfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzNyk7XG5cbnZhciBfYW5ub3RhdGlvbl9zdG9yYWdlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzgpO1xuXG52YXIgX2FwaV9jb21wYXRpYmlsaXR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzkpO1xuXG52YXIgX2NhbnZhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQwKTtcblxudmFyIF93b3JrZXJfb3B0aW9ucyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQyKTtcblxudmFyIF9pc19ub2RlID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcblxudmFyIF9tZXNzYWdlX2hhbmRsZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0Myk7XG5cbnZhciBfbWV0YWRhdGEgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0NCk7XG5cbnZhciBfb3B0aW9uYWxfY29udGVudF9jb25maWcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0Nik7XG5cbnZhciBfdHJhbnNwb3J0X3N0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQ3KTtcblxudmFyIF93ZWJnbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQ4KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgdGhyb3cgX2UyOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMykgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTM7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgREVGQVVMVF9SQU5HRV9DSFVOS19TSVpFID0gNjU1MzY7XG52YXIgUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUID0gMTAwO1xudmFyIERlZmF1bHRDYW52YXNGYWN0b3J5ID0gX2lzX25vZGUuaXNOb2RlSlMgPyBfbm9kZV91dGlscy5Ob2RlQ2FudmFzRmFjdG9yeSA6IF9kaXNwbGF5X3V0aWxzLkRPTUNhbnZhc0ZhY3Rvcnk7XG5leHBvcnRzLkRlZmF1bHRDYW52YXNGYWN0b3J5ID0gRGVmYXVsdENhbnZhc0ZhY3Rvcnk7XG52YXIgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gX2lzX25vZGUuaXNOb2RlSlMgPyBfbm9kZV91dGlscy5Ob2RlQ01hcFJlYWRlckZhY3RvcnkgOiBfZGlzcGxheV91dGlscy5ET01DTWFwUmVhZGVyRmFjdG9yeTtcbmV4cG9ydHMuRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xudmFyIGNyZWF0ZVBERk5ldHdvcmtTdHJlYW07XG5cbmZ1bmN0aW9uIHNldFBERk5ldHdvcmtTdHJlYW1GYWN0b3J5KHBkZk5ldHdvcmtTdHJlYW1GYWN0b3J5KSB7XG4gIGNyZWF0ZVBERk5ldHdvcmtTdHJlYW0gPSBwZGZOZXR3b3JrU3RyZWFtRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoc3JjKSB7XG4gIHZhciB0YXNrID0gbmV3IFBERkRvY3VtZW50TG9hZGluZ1Rhc2soKTtcbiAgdmFyIHNvdXJjZTtcblxuICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHNvdXJjZSA9IHtcbiAgICAgIHVybDogc3JjXG4gICAgfTtcbiAgfSBlbHNlIGlmICgoMCwgX3V0aWwuaXNBcnJheUJ1ZmZlcikoc3JjKSkge1xuICAgIHNvdXJjZSA9IHtcbiAgICAgIGRhdGE6IHNyY1xuICAgIH07XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgUERGRGF0YVJhbmdlVHJhbnNwb3J0KSB7XG4gICAgc291cmNlID0ge1xuICAgICAgcmFuZ2U6IHNyY1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaWYgKF90eXBlb2Yoc3JjKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgaW4gZ2V0RG9jdW1lbnQsIFwiICsgXCJuZWVkIGVpdGhlciBVaW50OEFycmF5LCBzdHJpbmcgb3IgYSBwYXJhbWV0ZXIgb2JqZWN0XCIpO1xuICAgIH1cblxuICAgIGlmICghc3JjLnVybCAmJiAhc3JjLmRhdGEgJiYgIXNyYy5yYW5nZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgb2JqZWN0OiBuZWVkIGVpdGhlciAuZGF0YSwgLnJhbmdlIG9yIC51cmxcIik7XG4gICAgfVxuXG4gICAgc291cmNlID0gc3JjO1xuICB9XG5cbiAgdmFyIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciByYW5nZVRyYW5zcG9ydCA9IG51bGwsXG4gICAgICB3b3JrZXIgPSBudWxsO1xuXG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoa2V5ID09PSBcInVybFwiICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHBhcmFtc1trZXldID0gbmV3IFVSTChzb3VyY2Vba2V5XSwgd2luZG93LmxvY2F0aW9uKS5ocmVmO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwicmFuZ2VcIikge1xuICAgICAgcmFuZ2VUcmFuc3BvcnQgPSBzb3VyY2Vba2V5XTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIndvcmtlclwiKSB7XG4gICAgICB3b3JrZXIgPSBzb3VyY2Vba2V5XTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImRhdGFcIiAmJiAhKHNvdXJjZVtrZXldIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHZhciBwZGZCeXRlcyA9IHNvdXJjZVtrZXldO1xuXG4gICAgICBpZiAodHlwZW9mIHBkZkJ5dGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBhcmFtc1trZXldID0gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKHBkZkJ5dGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihwZGZCeXRlcykgPT09IFwib2JqZWN0XCIgJiYgcGRmQnl0ZXMgIT09IG51bGwgJiYgIWlzTmFOKHBkZkJ5dGVzLmxlbmd0aCkpIHtcbiAgICAgICAgcGFyYW1zW2tleV0gPSBuZXcgVWludDhBcnJheShwZGZCeXRlcyk7XG4gICAgICB9IGVsc2UgaWYgKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKShwZGZCeXRlcykpIHtcbiAgICAgICAgcGFyYW1zW2tleV0gPSBuZXcgVWludDhBcnJheShwZGZCeXRlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiBiaW5hcnkgZGF0YTogZWl0aGVyIHR5cGVkIGFycmF5LCBcIiArIFwic3RyaW5nIG9yIGFycmF5LWxpa2Ugb2JqZWN0IGlzIGV4cGVjdGVkIGluIHRoZSBcIiArIFwiZGF0YSBwcm9wZXJ0eS5cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcmFtc1trZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICBwYXJhbXMucmFuZ2VDaHVua1NpemUgPSBwYXJhbXMucmFuZ2VDaHVua1NpemUgfHwgREVGQVVMVF9SQU5HRV9DSFVOS19TSVpFO1xuICBwYXJhbXMuQ01hcFJlYWRlckZhY3RvcnkgPSBwYXJhbXMuQ01hcFJlYWRlckZhY3RvcnkgfHwgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xuICBwYXJhbXMuaWdub3JlRXJyb3JzID0gcGFyYW1zLnN0b3BBdEVycm9ycyAhPT0gdHJ1ZTtcbiAgcGFyYW1zLmZvbnRFeHRyYVByb3BlcnRpZXMgPSBwYXJhbXMuZm9udEV4dHJhUHJvcGVydGllcyA9PT0gdHJ1ZTtcbiAgcGFyYW1zLnBkZkJ1ZyA9IHBhcmFtcy5wZGZCdWcgPT09IHRydWU7XG5cbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHBhcmFtcy5tYXhJbWFnZVNpemUpKSB7XG4gICAgcGFyYW1zLm1heEltYWdlU2l6ZSA9IC0xO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJhbXMuaXNFdmFsU3VwcG9ydGVkICE9PSBcImJvb2xlYW5cIikge1xuICAgIHBhcmFtcy5pc0V2YWxTdXBwb3J0ZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJhbXMuZGlzYWJsZUZvbnRGYWNlICE9PSBcImJvb2xlYW5cIikge1xuICAgIHBhcmFtcy5kaXNhYmxlRm9udEZhY2UgPSBfYXBpX2NvbXBhdGliaWxpdHkuYXBpQ29tcGF0aWJpbGl0eVBhcmFtcy5kaXNhYmxlRm9udEZhY2UgfHwgZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhcmFtcy5vd25lckRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcGFyYW1zLm93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJhbXMuZGlzYWJsZVJhbmdlICE9PSBcImJvb2xlYW5cIikge1xuICAgIHBhcmFtcy5kaXNhYmxlUmFuZ2UgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zLmRpc2FibGVTdHJlYW0gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgcGFyYW1zLmRpc2FibGVTdHJlYW0gPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zLmRpc2FibGVBdXRvRmV0Y2ggIT09IFwiYm9vbGVhblwiKSB7XG4gICAgcGFyYW1zLmRpc2FibGVBdXRvRmV0Y2ggPSBmYWxzZTtcbiAgfVxuXG4gICgwLCBfdXRpbC5zZXRWZXJib3NpdHlMZXZlbCkocGFyYW1zLnZlcmJvc2l0eSk7XG5cbiAgaWYgKCF3b3JrZXIpIHtcbiAgICB2YXIgd29ya2VyUGFyYW1zID0ge1xuICAgICAgdmVyYm9zaXR5OiBwYXJhbXMudmVyYm9zaXR5LFxuICAgICAgcG9ydDogX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydFxuICAgIH07XG4gICAgd29ya2VyID0gd29ya2VyUGFyYW1zLnBvcnQgPyBQREZXb3JrZXIuZnJvbVBvcnQod29ya2VyUGFyYW1zKSA6IG5ldyBQREZXb3JrZXIod29ya2VyUGFyYW1zKTtcbiAgICB0YXNrLl93b3JrZXIgPSB3b3JrZXI7XG4gIH1cblxuICB2YXIgZG9jSWQgPSB0YXNrLmRvY0lkO1xuICB3b3JrZXIucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgYWJvcnRlZFwiKTtcbiAgICB9XG5cbiAgICB2YXIgd29ya2VySWRQcm9taXNlID0gX2ZldGNoRG9jdW1lbnQod29ya2VyLCBwYXJhbXMsIHJhbmdlVHJhbnNwb3J0LCBkb2NJZCk7XG5cbiAgICB2YXIgbmV0d29ya1N0cmVhbVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgdmFyIG5ldHdvcmtTdHJlYW07XG5cbiAgICAgIGlmIChyYW5nZVRyYW5zcG9ydCkge1xuICAgICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IF90cmFuc3BvcnRfc3RyZWFtLlBERkRhdGFUcmFuc3BvcnRTdHJlYW0oe1xuICAgICAgICAgIGxlbmd0aDogcGFyYW1zLmxlbmd0aCxcbiAgICAgICAgICBpbml0aWFsRGF0YTogcGFyYW1zLmluaXRpYWxEYXRhLFxuICAgICAgICAgIHByb2dyZXNzaXZlRG9uZTogcGFyYW1zLnByb2dyZXNzaXZlRG9uZSxcbiAgICAgICAgICBkaXNhYmxlUmFuZ2U6IHBhcmFtcy5kaXNhYmxlUmFuZ2UsXG4gICAgICAgICAgZGlzYWJsZVN0cmVhbTogcGFyYW1zLmRpc2FibGVTdHJlYW1cbiAgICAgICAgfSwgcmFuZ2VUcmFuc3BvcnQpO1xuICAgICAgfSBlbHNlIGlmICghcGFyYW1zLmRhdGEpIHtcbiAgICAgICAgbmV0d29ya1N0cmVhbSA9IGNyZWF0ZVBERk5ldHdvcmtTdHJlYW0oe1xuICAgICAgICAgIHVybDogcGFyYW1zLnVybCxcbiAgICAgICAgICBsZW5ndGg6IHBhcmFtcy5sZW5ndGgsXG4gICAgICAgICAgaHR0cEhlYWRlcnM6IHBhcmFtcy5odHRwSGVhZGVycyxcbiAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHBhcmFtcy53aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgICAgcmFuZ2VDaHVua1NpemU6IHBhcmFtcy5yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgICBkaXNhYmxlUmFuZ2U6IHBhcmFtcy5kaXNhYmxlUmFuZ2UsXG4gICAgICAgICAgZGlzYWJsZVN0cmVhbTogcGFyYW1zLmRpc2FibGVTdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUobmV0d29ya1N0cmVhbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFt3b3JrZXJJZFByb21pc2UsIG5ldHdvcmtTdHJlYW1Qcm9taXNlXSkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgd29ya2VySWQgPSBfcmVmMlswXSxcbiAgICAgICAgICBuZXR3b3JrU3RyZWFtID0gX3JlZjJbMV07XG5cbiAgICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKGRvY0lkLCB3b3JrZXJJZCwgd29ya2VyLnBvcnQpO1xuICAgICAgbWVzc2FnZUhhbmRsZXIucG9zdE1lc3NhZ2VUcmFuc2ZlcnMgPSB3b3JrZXIucG9zdE1lc3NhZ2VUcmFuc2ZlcnM7XG4gICAgICB2YXIgdHJhbnNwb3J0ID0gbmV3IFdvcmtlclRyYW5zcG9ydChtZXNzYWdlSGFuZGxlciwgdGFzaywgbmV0d29ya1N0cmVhbSwgcGFyYW1zKTtcbiAgICAgIHRhc2suX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJSZWFkeVwiLCBudWxsKTtcbiAgICB9KTtcbiAgfSlbXCJjYXRjaFwiXSh0YXNrLl9jYXBhYmlsaXR5LnJlamVjdCk7XG4gIHJldHVybiB0YXNrO1xufVxuXG5mdW5jdGlvbiBfZmV0Y2hEb2N1bWVudCh3b3JrZXIsIHNvdXJjZSwgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LCBkb2NJZCkge1xuICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gIH1cblxuICBpZiAocGRmRGF0YVJhbmdlVHJhbnNwb3J0KSB7XG4gICAgc291cmNlLmxlbmd0aCA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5sZW5ndGg7XG4gICAgc291cmNlLmluaXRpYWxEYXRhID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmluaXRpYWxEYXRhO1xuICAgIHNvdXJjZS5wcm9ncmVzc2l2ZURvbmUgPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQucHJvZ3Jlc3NpdmVEb25lO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtlci5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREb2NSZXF1ZXN0XCIsIHtcbiAgICBkb2NJZDogZG9jSWQsXG4gICAgYXBpVmVyc2lvbjogJzIuOC4xNzMnLFxuICAgIHNvdXJjZToge1xuICAgICAgZGF0YTogc291cmNlLmRhdGEsXG4gICAgICB1cmw6IHNvdXJjZS51cmwsXG4gICAgICBwYXNzd29yZDogc291cmNlLnBhc3N3b3JkLFxuICAgICAgZGlzYWJsZUF1dG9GZXRjaDogc291cmNlLmRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICByYW5nZUNodW5rU2l6ZTogc291cmNlLnJhbmdlQ2h1bmtTaXplLFxuICAgICAgbGVuZ3RoOiBzb3VyY2UubGVuZ3RoXG4gICAgfSxcbiAgICBtYXhJbWFnZVNpemU6IHNvdXJjZS5tYXhJbWFnZVNpemUsXG4gICAgZGlzYWJsZUZvbnRGYWNlOiBzb3VyY2UuZGlzYWJsZUZvbnRGYWNlLFxuICAgIHBvc3RNZXNzYWdlVHJhbnNmZXJzOiB3b3JrZXIucG9zdE1lc3NhZ2VUcmFuc2ZlcnMsXG4gICAgZG9jQmFzZVVybDogc291cmNlLmRvY0Jhc2VVcmwsXG4gICAgaWdub3JlRXJyb3JzOiBzb3VyY2UuaWdub3JlRXJyb3JzLFxuICAgIGlzRXZhbFN1cHBvcnRlZDogc291cmNlLmlzRXZhbFN1cHBvcnRlZCxcbiAgICBmb250RXh0cmFQcm9wZXJ0aWVzOiBzb3VyY2UuZm9udEV4dHJhUHJvcGVydGllc1xuICB9KS50aGVuKGZ1bmN0aW9uICh3b3JrZXJJZCkge1xuICAgIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya2VySWQ7XG4gIH0pO1xufVxuXG52YXIgUERGRG9jdW1lbnRMb2FkaW5nVGFzayA9IGZ1bmN0aW9uIFBERkRvY3VtZW50TG9hZGluZ1Rhc2tDbG9zdXJlKCkge1xuICB2YXIgbmV4dERvY3VtZW50SWQgPSAwO1xuXG4gIHZhciBQREZEb2N1bWVudExvYWRpbmdUYXNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQREZEb2N1bWVudExvYWRpbmdUYXNrKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERkRvY3VtZW50TG9hZGluZ1Rhc2spO1xuXG4gICAgICB0aGlzLl9jYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgICB0aGlzLmRvY0lkID0gXCJkXCIgKyBuZXh0RG9jdW1lbnRJZCsrO1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMub25QYXNzd29yZCA9IG51bGw7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgdGhpcy5vblVuc3VwcG9ydGVkRmVhdHVyZSA9IG51bGw7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFBERkRvY3VtZW50TG9hZGluZ1Rhc2ssIFt7XG4gICAgICBrZXk6IFwicHJvbWlzZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydERlc3Ryb3llZCA9ICF0aGlzLl90cmFuc3BvcnQgPyBQcm9taXNlLnJlc29sdmUoKSA6IHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnREZXN0cm95ZWQudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoX3RoaXMuX3dvcmtlcikge1xuICAgICAgICAgICAgX3RoaXMuX3dvcmtlci5kZXN0cm95KCk7XG5cbiAgICAgICAgICAgIF90aGlzLl93b3JrZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBERkRvY3VtZW50TG9hZGluZ1Rhc2s7XG4gIH0oKTtcblxuICByZXR1cm4gUERGRG9jdW1lbnRMb2FkaW5nVGFzaztcbn0oKTtcblxudmFyIFBERkRhdGFSYW5nZVRyYW5zcG9ydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERkRhdGFSYW5nZVRyYW5zcG9ydChsZW5ndGgsIGluaXRpYWxEYXRhKSB7XG4gICAgdmFyIHByb2dyZXNzaXZlRG9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGRGF0YVJhbmdlVHJhbnNwb3J0KTtcblxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuaW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICB0aGlzLnByb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLl9yYW5nZUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERkRhdGFSYW5nZVRyYW5zcG9ydCwgW3tcbiAgICBrZXk6IFwiYWRkUmFuZ2VMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9yYW5nZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUHJvZ3Jlc3NMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQcm9ncmVzc0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25EYXRhUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EYXRhUmFuZ2UoYmVnaW4sIGNodW5rKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5fcmFuZ2VMaXN0ZW5lcnMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGxpc3RlbmVyKGJlZ2luLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25EYXRhUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EYXRhUHJvZ3Jlc3MobG9hZGVkLCB0b3RhbCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKF90aGlzMi5fcHJvZ3Jlc3NMaXN0ZW5lcnMpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyKGxvYWRlZCwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkRhdGFQcm9ncmVzc2l2ZVJlYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EYXRhUHJvZ3Jlc3NpdmVSZWFkKGNodW5rKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX3RoaXMzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMpLFxuICAgICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25EYXRhUHJvZ3Jlc3NpdmVEb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRGF0YVByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihfdGhpczQuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycyksXG4gICAgICAgICAgICBfc3RlcDQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNwb3J0UmVhZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNwb3J0UmVhZHkoKSB7XG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXF1ZXN0RGF0YVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBQREZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWJvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERkRhdGFSYW5nZVRyYW5zcG9ydDtcbn0oKTtcblxuZXhwb3J0cy5QREZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBQREZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG5cbnZhciBQREZEb2N1bWVudFByb3h5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGRG9jdW1lbnRQcm94eShwZGZJbmZvLCB0cmFuc3BvcnQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGRG9jdW1lbnRQcm94eSk7XG5cbiAgICB0aGlzLl9wZGZJbmZvID0gcGRmSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGRG9jdW1lbnRQcm94eSwgW3tcbiAgICBrZXk6IFwiYW5ub3RhdGlvblN0b3JhZ2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImFubm90YXRpb25TdG9yYWdlXCIsIG5ldyBfYW5ub3RhdGlvbl9zdG9yYWdlLkFubm90YXRpb25TdG9yYWdlKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJudW1QYWdlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BkZkluZm8ubnVtUGFnZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmdlcnByaW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5maW5nZXJwcmludDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZShwYWdlTnVtYmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFnZUluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUluZGV4KHJlZik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBhZ2VPQ0dOYW1lc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYWdlT0NHTmFtZXMocmVmKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VPQ0dOYW1lcyhyZWYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T2JqZWN0KHJlZikge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPYmplY3QocmVmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVzdGluYXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb25zKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlc3RpbmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9uKGlkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFnZUxhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYWdlTGFiZWxzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGFiZWxzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBhZ2VMYXlvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFnZUxheW91dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxheW91dCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlTW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYWdlTW9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZU1vZGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Vmlld2VyUHJlZmVyZW5jZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFZpZXdlclByZWZlcmVuY2VzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9wZW5BY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3BlbkFjdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3BlbkFjdGlvbigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdHRhY2htZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRhY2htZW50cygpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QXR0YWNobWVudHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SmF2YVNjcmlwdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRKYXZhU2NyaXB0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRKYXZhU2NyaXB0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEpTQWN0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRKU0FjdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERvY0pTQWN0aW9ucygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPdXRsaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE91dGxpbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE91dGxpbmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbmFsQ29udGVudENvbmZpZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBlcm1pc3Npb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBlcm1pc3Npb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQZXJtaXNzaW9ucygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNZXRhZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZXRhZGF0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWV0YWRhdGEoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFya0luZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFya0luZm8oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1hcmtJbmZvKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGF0YSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREb3dubG9hZEluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RG93bmxvYWRJbmZvKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFN0YXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRTdGF0cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbnVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnN0YXJ0Q2xlYW51cCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRpbmdQYXJhbXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1BhcmFtcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZGluZ1Rhc2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1Rhc2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhdmVEb2N1bWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlRG9jdW1lbnQoYW5ub3RhdGlvblN0b3JhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc2F2ZURvY3VtZW50KGFubm90YXRpb25TdG9yYWdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmllbGRPYmplY3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpZWxkT2JqZWN0cygpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RmllbGRPYmplY3RzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0pTQWN0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNKU0FjdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lmhhc0pTQWN0aW9ucygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWxjdWxhdGlvbk9yZGVySWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldENhbGN1bGF0aW9uT3JkZXJJZHMoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGRG9jdW1lbnRQcm94eTtcbn0oKTtcblxuZXhwb3J0cy5QREZEb2N1bWVudFByb3h5ID0gUERGRG9jdW1lbnRQcm94eTtcblxudmFyIFBERlBhZ2VQcm94eSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERlBhZ2VQcm94eShwYWdlSW5kZXgsIHBhZ2VJbmZvLCB0cmFuc3BvcnQsIG93bmVyRG9jdW1lbnQpIHtcbiAgICB2YXIgcGRmQnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZQYWdlUHJveHkpO1xuXG4gICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuX3BhZ2VJbmZvID0gcGFnZUluZm87XG4gICAgdGhpcy5fb3duZXJEb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuX3N0YXRzID0gcGRmQnVnID8gbmV3IF9kaXNwbGF5X3V0aWxzLlN0YXRUaW1lcigpIDogbnVsbDtcbiAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgdGhpcy5jb21tb25PYmpzID0gdHJhbnNwb3J0LmNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLmNsZWFudXBBZnRlclJlbmRlciA9IGZhbHNlO1xuICAgIHRoaXMucGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZQYWdlUHJveHksIFt7XG4gICAga2V5OiBcInBhZ2VOdW1iZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlSW5kZXggKyAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yb3RhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZlwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJlZjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXNlclVuaXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby51c2VyVW5pdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmlld1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnZpZXc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZpZXdwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdwb3J0KCkge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBzY2FsZSA9IF9yZWYzLnNjYWxlLFxuICAgICAgICAgIF9yZWYzJHJvdGF0aW9uID0gX3JlZjMucm90YXRpb24sXG4gICAgICAgICAgcm90YXRpb24gPSBfcmVmMyRyb3RhdGlvbiA9PT0gdm9pZCAwID8gdGhpcy5yb3RhdGUgOiBfcmVmMyRyb3RhdGlvbixcbiAgICAgICAgICBfcmVmMyRvZmZzZXRYID0gX3JlZjMub2Zmc2V0WCxcbiAgICAgICAgICBvZmZzZXRYID0gX3JlZjMkb2Zmc2V0WCA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJG9mZnNldFgsXG4gICAgICAgICAgX3JlZjMkb2Zmc2V0WSA9IF9yZWYzLm9mZnNldFksXG4gICAgICAgICAgb2Zmc2V0WSA9IF9yZWYzJG9mZnNldFkgPT09IHZvaWQgMCA/IDAgOiBfcmVmMyRvZmZzZXRZLFxuICAgICAgICAgIF9yZWYzJGRvbnRGbGlwID0gX3JlZjMuZG9udEZsaXAsXG4gICAgICAgICAgZG9udEZsaXAgPSBfcmVmMyRkb250RmxpcCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMyRkb250RmxpcDtcblxuICAgICAgcmV0dXJuIG5ldyBfZGlzcGxheV91dGlscy5QYWdlVmlld3BvcnQoe1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXcsXG4gICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICBvZmZzZXRYOiBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZOiBvZmZzZXRZLFxuICAgICAgICBkb250RmxpcDogZG9udEZsaXBcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBbm5vdGF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbm5vdGF0aW9ucygpIHtcbiAgICAgIHZhciBfcmVmNCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgX3JlZjQkaW50ZW50ID0gX3JlZjQuaW50ZW50LFxuICAgICAgICAgIGludGVudCA9IF9yZWY0JGludGVudCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWY0JGludGVudDtcblxuICAgICAgaWYgKCF0aGlzLmFubm90YXRpb25zUHJvbWlzZSB8fCB0aGlzLmFubm90YXRpb25zSW50ZW50ICE9PSBpbnRlbnQpIHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uc1Byb21pc2UgPSB0aGlzLl90cmFuc3BvcnQuZ2V0QW5ub3RhdGlvbnModGhpcy5fcGFnZUluZGV4LCBpbnRlbnQpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25zSW50ZW50ID0gaW50ZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hbm5vdGF0aW9uc1Byb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEpTQWN0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRKU0FjdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fanNBY3Rpb25zUHJvbWlzZSB8fCAodGhpcy5fanNBY3Rpb25zUHJvbWlzZSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSlNBY3Rpb25zKHRoaXMuX3BhZ2VJbmRleCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKF9yZWY1KSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGNhbnZhc0NvbnRleHQgPSBfcmVmNS5jYW52YXNDb250ZXh0LFxuICAgICAgICAgIHZpZXdwb3J0ID0gX3JlZjUudmlld3BvcnQsXG4gICAgICAgICAgX3JlZjUkaW50ZW50ID0gX3JlZjUuaW50ZW50LFxuICAgICAgICAgIGludGVudCA9IF9yZWY1JGludGVudCA9PT0gdm9pZCAwID8gXCJkaXNwbGF5XCIgOiBfcmVmNSRpbnRlbnQsXG4gICAgICAgICAgX3JlZjUkZW5hYmxlV2ViR0wgPSBfcmVmNS5lbmFibGVXZWJHTCxcbiAgICAgICAgICBlbmFibGVXZWJHTCA9IF9yZWY1JGVuYWJsZVdlYkdMID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY1JGVuYWJsZVdlYkdMLFxuICAgICAgICAgIF9yZWY1JHJlbmRlckludGVyYWN0aSA9IF9yZWY1LnJlbmRlckludGVyYWN0aXZlRm9ybXMsXG4gICAgICAgICAgcmVuZGVySW50ZXJhY3RpdmVGb3JtcyA9IF9yZWY1JHJlbmRlckludGVyYWN0aSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNSRyZW5kZXJJbnRlcmFjdGksXG4gICAgICAgICAgX3JlZjUkdHJhbnNmb3JtID0gX3JlZjUudHJhbnNmb3JtLFxuICAgICAgICAgIHRyYW5zZm9ybSA9IF9yZWY1JHRyYW5zZm9ybSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWY1JHRyYW5zZm9ybSxcbiAgICAgICAgICBfcmVmNSRpbWFnZUxheWVyID0gX3JlZjUuaW1hZ2VMYXllcixcbiAgICAgICAgICBpbWFnZUxheWVyID0gX3JlZjUkaW1hZ2VMYXllciA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWY1JGltYWdlTGF5ZXIsXG4gICAgICAgICAgX3JlZjUkY2FudmFzRmFjdG9yeSA9IF9yZWY1LmNhbnZhc0ZhY3RvcnksXG4gICAgICAgICAgY2FudmFzRmFjdG9yeSA9IF9yZWY1JGNhbnZhc0ZhY3RvcnkgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmNSRjYW52YXNGYWN0b3J5LFxuICAgICAgICAgIF9yZWY1JGJhY2tncm91bmQgPSBfcmVmNS5iYWNrZ3JvdW5kLFxuICAgICAgICAgIGJhY2tncm91bmQgPSBfcmVmNSRiYWNrZ3JvdW5kID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjUkYmFja2dyb3VuZCxcbiAgICAgICAgICBfcmVmNSRhbm5vdGF0aW9uU3RvcmEgPSBfcmVmNS5hbm5vdGF0aW9uU3RvcmFnZSxcbiAgICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZSA9IF9yZWY1JGFubm90YXRpb25TdG9yYSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWY1JGFubm90YXRpb25TdG9yYSxcbiAgICAgICAgICBfcmVmNSRvcHRpb25hbENvbnRlbnQgPSBfcmVmNS5vcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlLFxuICAgICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSBfcmVmNSRvcHRpb25hbENvbnRlbnQgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmNSRvcHRpb25hbENvbnRlbnQ7XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0cykge1xuICAgICAgICB0aGlzLl9zdGF0cy50aW1lKFwiT3ZlcmFsbFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbmRlcmluZ0ludGVudCA9IGludGVudCA9PT0gXCJwcmludFwiID8gXCJwcmludFwiIDogXCJkaXNwbGF5XCI7XG4gICAgICB0aGlzLnBlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG5cbiAgICAgIGlmICghb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSkge1xuICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gdGhpcy5fdHJhbnNwb3J0LmdldE9wdGlvbmFsQ29udGVudENvbmZpZygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KHJlbmRlcmluZ0ludGVudCk7XG5cbiAgICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5zZXQocmVuZGVyaW5nSW50ZW50LCBpbnRlbnRTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KTtcbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW52YXNGYWN0b3J5SW5zdGFuY2UgPSBjYW52YXNGYWN0b3J5IHx8IG5ldyBEZWZhdWx0Q2FudmFzRmFjdG9yeSh7XG4gICAgICAgIG93bmVyRG9jdW1lbnQ6IHRoaXMuX293bmVyRG9jdW1lbnRcbiAgICAgIH0pO1xuICAgICAgdmFyIHdlYkdMQ29udGV4dCA9IG5ldyBfd2ViZ2wuV2ViR0xDb250ZXh0KHtcbiAgICAgICAgZW5hYmxlOiBlbmFibGVXZWJHTFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QgPSB7XG4gICAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgICBsYXN0Q2h1bms6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICAgICAgdGhpcy5fc3RhdHMudGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgICAgIGludGVudDogcmVuZGVyaW5nSW50ZW50LFxuICAgICAgICAgIHJlbmRlckludGVyYWN0aXZlRm9ybXM6IHJlbmRlckludGVyYWN0aXZlRm9ybXMgPT09IHRydWUsXG4gICAgICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IChhbm5vdGF0aW9uU3RvcmFnZSA9PT0gbnVsbCB8fCBhbm5vdGF0aW9uU3RvcmFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5ub3RhdGlvblN0b3JhZ2UuZ2V0QWxsKCkpIHx8IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKGVycm9yKSB7XG4gICAgICAgIHZhciBpID0gaW50ZW50U3RhdGUucmVuZGVyVGFza3MuaW5kZXhPZihpbnRlcm5hbFJlbmRlclRhc2spO1xuXG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXM1LmNsZWFudXBBZnRlclJlbmRlciB8fCByZW5kZXJpbmdJbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgIF90aGlzNS5wZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczUuX3RyeUNsZWFudXAoKTtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuXG4gICAgICAgICAgX3RoaXM1Ll9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgICBpbnRlbnRTdGF0ZTogaW50ZW50U3RhdGUsXG4gICAgICAgICAgICByZWFzb246IGVycm9yXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzNS5fc3RhdHMpIHtcbiAgICAgICAgICBfdGhpczUuX3N0YXRzLnRpbWVFbmQoXCJSZW5kZXJpbmdcIik7XG5cbiAgICAgICAgICBfdGhpczUuX3N0YXRzLnRpbWVFbmQoXCJPdmVyYWxsXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgaW50ZXJuYWxSZW5kZXJUYXNrID0gbmV3IEludGVybmFsUmVuZGVyVGFzayh7XG4gICAgICAgIGNhbGxiYWNrOiBjb21wbGV0ZSxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgY2FudmFzQ29udGV4dDogY2FudmFzQ29udGV4dCxcbiAgICAgICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgaW1hZ2VMYXllcjogaW1hZ2VMYXllcixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kXG4gICAgICAgIH0sXG4gICAgICAgIG9ianM6IHRoaXMub2JqcyxcbiAgICAgICAgY29tbW9uT2JqczogdGhpcy5jb21tb25PYmpzLFxuICAgICAgICBvcGVyYXRvckxpc3Q6IGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCxcbiAgICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICAgIGNhbnZhc0ZhY3Rvcnk6IGNhbnZhc0ZhY3RvcnlJbnN0YW5jZSxcbiAgICAgICAgd2ViR0xDb250ZXh0OiB3ZWJHTENvbnRleHQsXG4gICAgICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZTogcmVuZGVyaW5nSW50ZW50ICE9PSBcInByaW50XCIsXG4gICAgICAgIHBkZkJ1ZzogdGhpcy5fcGRmQnVnXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5wdXNoKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgICB2YXIgcmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzay50YXNrO1xuICAgICAgUHJvbWlzZS5hbGwoW2ludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucHJvbWlzZSwgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24gKF9yZWY2KSB7XG4gICAgICAgIHZhciBfcmVmNyA9IF9zbGljZWRUb0FycmF5KF9yZWY2LCAyKSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW5jeSA9IF9yZWY3WzBdLFxuICAgICAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnID0gX3JlZjdbMV07XG5cbiAgICAgICAgaWYgKF90aGlzNS5wZW5kaW5nQ2xlYW51cCkge1xuICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzNS5fc3RhdHMpIHtcbiAgICAgICAgICBfdGhpczUuX3N0YXRzLnRpbWUoXCJSZW5kZXJpbmdcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suaW5pdGlhbGl6ZUdyYXBoaWNzKHtcbiAgICAgICAgICB0cmFuc3BhcmVuY3k6IHRyYW5zcGFyZW5jeSxcbiAgICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWc6IG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgICAgICB9KTtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oY29tcGxldGUpO1xuICAgICAgcmV0dXJuIHJlbmRlclRhc2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9wZXJhdG9yTGlzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcGVyYXRvckxpc3QoaW50ZW50KSB7XG4gICAgICBmdW5jdGlvbiBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnJlc29sdmUoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KTtcbiAgICAgICAgICB2YXIgaSA9IGludGVudFN0YXRlLnJlbmRlclRhc2tzLmluZGV4T2Yob3BMaXN0VGFzayk7XG5cbiAgICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByZW5kZXJpbmdJbnRlbnQgPSBpbnRlbnQgfHwgXCJvcGxpc3RcIjtcblxuICAgICAgdmFyIGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChyZW5kZXJpbmdJbnRlbnQpO1xuXG4gICAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICAgIGludGVudFN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KHJlbmRlcmluZ0ludGVudCwgaW50ZW50U3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3BMaXN0VGFzaztcblxuICAgICAgaWYgKCFpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICAgIGxhc3RDaHVuazogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgICAgICB0aGlzLl9zdGF0cy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICAgICAgaW50ZW50OiByZW5kZXJpbmdJbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG5cbiAgICAgICAgaWYgKCFpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBvcExpc3RUYXNrID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgb3BMaXN0VGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkID0gb3BlcmF0b3JMaXN0Q2hhbmdlZDtcbiAgICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MucHVzaChvcExpc3RUYXNrKTtcbiAgICAgICAgb3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RyZWFtVGV4dENvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyZWFtVGV4dENvbnRlbnQoKSB7XG4gICAgICB2YXIgX3JlZjggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIF9yZWY4JG5vcm1hbGl6ZVdoaXRlcyA9IF9yZWY4Lm5vcm1hbGl6ZVdoaXRlc3BhY2UsXG4gICAgICAgICAgbm9ybWFsaXplV2hpdGVzcGFjZSA9IF9yZWY4JG5vcm1hbGl6ZVdoaXRlcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmOCRub3JtYWxpemVXaGl0ZXMsXG4gICAgICAgICAgX3JlZjgkZGlzYWJsZUNvbWJpbmVUID0gX3JlZjguZGlzYWJsZUNvbWJpbmVUZXh0SXRlbXMsXG4gICAgICAgICAgZGlzYWJsZUNvbWJpbmVUZXh0SXRlbXMgPSBfcmVmOCRkaXNhYmxlQ29tYmluZVQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjgkZGlzYWJsZUNvbWJpbmVUO1xuXG4gICAgICB2YXIgVEVYVF9DT05URU5UX0NIVU5LX1NJWkUgPSAxMDA7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoU3RyZWFtKFwiR2V0VGV4dENvbnRlbnRcIiwge1xuICAgICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgICAgbm9ybWFsaXplV2hpdGVzcGFjZTogbm9ybWFsaXplV2hpdGVzcGFjZSA9PT0gdHJ1ZSxcbiAgICAgICAgY29tYmluZVRleHRJdGVtczogZGlzYWJsZUNvbWJpbmVUZXh0SXRlbXMgIT09IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgaGlnaFdhdGVyTWFyazogVEVYVF9DT05URU5UX0NIVU5LX1NJWkUsXG4gICAgICAgIHNpemU6IGZ1bmN0aW9uIHNpemUodGV4dENvbnRlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dENvbnRlbnQuaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGV4dENvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHZhciByZWFkYWJsZVN0cmVhbSA9IHRoaXMuc3RyZWFtVGV4dENvbnRlbnQocGFyYW1zKTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uIChfcmVmOSkge1xuICAgICAgICAgICAgdmFyIF90ZXh0Q29udGVudCRpdGVtcztcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gX3JlZjkudmFsdWUsXG4gICAgICAgICAgICAgICAgZG9uZSA9IF9yZWY5LmRvbmU7XG5cbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGV4dENvbnRlbnQuc3R5bGVzLCB2YWx1ZS5zdHlsZXMpO1xuXG4gICAgICAgICAgICAoX3RleHRDb250ZW50JGl0ZW1zID0gdGV4dENvbnRlbnQuaXRlbXMpLnB1c2guYXBwbHkoX3RleHRDb250ZW50JGl0ZW1zLCBfdG9Db25zdW1hYmxlQXJyYXkodmFsdWUuaXRlbXMpKTtcblxuICAgICAgICAgICAgcHVtcCgpO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IHtcbiAgICAgICAgICBpdGVtczogW10sXG4gICAgICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICAgIH07XG4gICAgICAgIHB1bXAoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydC5wYWdlQ2FjaGVbdGhpcy5fcGFnZUluZGV4XSA9IG51bGw7XG4gICAgICB2YXIgd2FpdE9uID0gW107XG5cbiAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5faW50ZW50U3RhdGVzKSxcbiAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwNSR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNS52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGludGVudCA9IF9zdGVwNSR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgaW50ZW50U3RhdGUgPSBfc3RlcDUkdmFsdWVbMV07XG5cbiAgICAgICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgICBpbnRlbnRTdGF0ZTogaW50ZW50U3RhdGUsXG4gICAgICAgICAgICByZWFzb246IG5ldyBFcnJvcihcIlBhZ2Ugd2FzIGRlc3Ryb3llZC5cIiksXG4gICAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGludGVudCA9PT0gXCJvcGxpc3RcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyksXG4gICAgICAgICAgICAgIF9zdGVwNjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgaW50ZXJuYWxSZW5kZXJUYXNrID0gX3N0ZXA2LnZhbHVlO1xuICAgICAgICAgICAgICB3YWl0T24ucHVzaChpbnRlcm5hbFJlbmRlclRhc2suY29tcGxldGVkKTtcbiAgICAgICAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNi5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgICAgdGhpcy5hbm5vdGF0aW9uc1Byb21pc2UgPSBudWxsO1xuICAgICAgdGhpcy5fanNBY3Rpb25zUHJvbWlzZSA9IG51bGw7XG4gICAgICB0aGlzLnBlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwod2FpdE9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYW51cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgdmFyIHJlc2V0U3RhdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgdGhpcy5wZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5fdHJ5Q2xlYW51cChyZXNldFN0YXRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyeUNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyeUNsZWFudXAoKSB7XG4gICAgICB2YXIgcmVzZXRTdGF0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgIGlmICghdGhpcy5wZW5kaW5nQ2xlYW51cCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSxcbiAgICAgICAgICBfc3RlcDc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwNyR2YWx1ZSA9IF9zdGVwNy52YWx1ZSxcbiAgICAgICAgICAgICAgcmVuZGVyVGFza3MgPSBfc3RlcDckdmFsdWUucmVuZGVyVGFza3MsXG4gICAgICAgICAgICAgIG9wZXJhdG9yTGlzdCA9IF9zdGVwNyR2YWx1ZS5vcGVyYXRvckxpc3Q7XG5cbiAgICAgICAgICBpZiAocmVuZGVyVGFza3MubGVuZ3RoICE9PSAwIHx8ICFvcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I3LmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLmNsZWFyKCk7XG5cbiAgICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgICAgdGhpcy5hbm5vdGF0aW9uc1Byb21pc2UgPSBudWxsO1xuICAgICAgdGhpcy5fanNBY3Rpb25zUHJvbWlzZSA9IG51bGw7XG5cbiAgICAgIGlmIChyZXNldFN0YXRzICYmIHRoaXMuX3N0YXRzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRzID0gbmV3IF9kaXNwbGF5X3V0aWxzLlN0YXRUaW1lcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0UmVuZGVyUGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRSZW5kZXJQYWdlKHRyYW5zcGFyZW5jeSwgaW50ZW50KSB7XG4gICAgICB2YXIgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGludGVudCk7XG5cbiAgICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgICAgdGhpcy5fc3RhdHMudGltZUVuZChcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKHRyYW5zcGFyZW5jeSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZW5kZXJQYWdlQ2h1bmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlclBhZ2VDaHVuayhvcGVyYXRvckxpc3RDaHVuaywgaW50ZW50U3RhdGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG9wZXJhdG9yTGlzdENodW5rLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmZuQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5mbkFycmF5W2ldKTtcbiAgICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5wdXNoKG9wZXJhdG9yTGlzdENodW5rLmFyZ3NBcnJheVtpXSk7XG4gICAgICB9XG5cbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSBvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bms7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGludGVudFN0YXRlLnJlbmRlclRhc2tzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3NbX2kyXS5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bmspIHtcbiAgICAgICAgdGhpcy5fdHJ5Q2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcHVtcE9wZXJhdG9yTGlzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHVtcE9wZXJhdG9yTGlzdChhcmdzKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgKDAsIF91dGlsLmFzc2VydCkoYXJncy5pbnRlbnQsICdQREZQYWdlUHJveHkuX3B1bXBPcGVyYXRvckxpc3Q6IEV4cGVjdGVkIFwiaW50ZW50XCIgYXJndW1lbnQuJyk7XG5cbiAgICAgIHZhciByZWFkYWJsZVN0cmVhbSA9IHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldE9wZXJhdG9yTGlzdFwiLCBhcmdzKTtcblxuICAgICAgdmFyIHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuXG4gICAgICB2YXIgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGFyZ3MuaW50ZW50KTtcblxuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gcmVhZGVyO1xuXG4gICAgICB2YXIgcHVtcCA9IGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgIHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoX3JlZjEwKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3JlZjEwLnZhbHVlLFxuICAgICAgICAgICAgICBkb25lID0gX3JlZjEwLmRvbmU7XG5cbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3RoaXM2Ll90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXM2Ll9yZW5kZXJQYWdlQ2h1bmsodmFsdWUsIGludGVudFN0YXRlKTtcblxuICAgICAgICAgIHB1bXAoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoX3RoaXM2Ll90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCkge1xuICAgICAgICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZW50U3RhdGUucmVuZGVyVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3NbaV0ub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfdGhpczYuX3RyeUNsZWFudXAoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBwdW1wKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hYm9ydE9wZXJhdG9yTGlzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWJvcnRPcGVyYXRvckxpc3QoX3JlZjExKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIGludGVudFN0YXRlID0gX3JlZjExLmludGVudFN0YXRlLFxuICAgICAgICAgIHJlYXNvbiA9IF9yZWYxMS5yZWFzb24sXG4gICAgICAgICAgX3JlZjExJGZvcmNlID0gX3JlZjExLmZvcmNlLFxuICAgICAgICAgIGZvcmNlID0gX3JlZjExJGZvcmNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYxMSRmb3JjZTtcbiAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yIHx8IF90eXBlb2YocmVhc29uKSA9PT0gXCJvYmplY3RcIiAmJiByZWFzb24gIT09IG51bGwsICdQREZQYWdlUHJveHkuX2Fib3J0T3BlcmF0b3JMaXN0OiBFeHBlY3RlZCBcInJlYXNvblwiIGFyZ3VtZW50LicpO1xuXG4gICAgICBpZiAoIWludGVudFN0YXRlLnN0cmVhbVJlYWRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghZm9yY2UpIHtcbiAgICAgICAgaWYgKGludGVudFN0YXRlLnJlbmRlclRhc2tzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBfZGlzcGxheV91dGlscy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24pIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczcuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICAgICAgaW50ZW50U3RhdGU6IGludGVudFN0YXRlLFxuICAgICAgICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB9LCBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIuY2FuY2VsKG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihyZWFzb24gPT09IG51bGwgfHwgcmVhc29uID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWFzb24ubWVzc2FnZSkpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuX2ludGVudFN0YXRlcyksXG4gICAgICAgICAgX3N0ZXA4O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjgucygpOyAhKF9zdGVwOCA9IF9pdGVyYXRvcjgubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDgkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDgudmFsdWUsIDIpLFxuICAgICAgICAgICAgICBpbnRlbnQgPSBfc3RlcDgkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIGN1ckludGVudFN0YXRlID0gX3N0ZXA4JHZhbHVlWzFdO1xuXG4gICAgICAgICAgaWYgKGN1ckludGVudFN0YXRlID09PSBpbnRlbnRTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5faW50ZW50U3RhdGVzW1wiZGVsZXRlXCJdKGludGVudCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjguZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yOC5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGF0c1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZQYWdlUHJveHk7XG59KCk7XG5cbmV4cG9ydHMuUERGUGFnZVByb3h5ID0gUERGUGFnZVByb3h5O1xuXG52YXIgTG9vcGJhY2tQb3J0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9vcGJhY2tQb3J0KCkge1xuICAgIHZhciBkZWZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb29wYmFja1BvcnQpO1xuXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fZGVmZXIgPSBkZWZlcjtcbiAgICB0aGlzLl9kZWZlcnJlZCA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExvb3BiYWNrUG9ydCwgW3tcbiAgICBrZXk6IFwicG9zdE1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2Uob2JqLCB0cmFuc2ZlcnMpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKHZhbHVlKSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9uZWQuaGFzKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBjbG9uZWQuZ2V0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidWZmZXIsIHJlc3VsdDtcblxuICAgICAgICBpZiAoKGJ1ZmZlciA9IHZhbHVlLmJ1ZmZlcikgJiYgKDAsIF91dGlsLmlzQXJyYXlCdWZmZXIpKGJ1ZmZlcikpIHtcbiAgICAgICAgICBpZiAodHJhbnNmZXJzICE9PSBudWxsICYmIHRyYW5zZmVycyAhPT0gdm9pZCAwICYmIHRyYW5zZmVycy5pbmNsdWRlcyhidWZmZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgdmFsdWUuY29uc3RydWN0b3IoYnVmZmVyLCB2YWx1ZS5ieXRlT2Zmc2V0LCB2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IHZhbHVlLmNvbnN0cnVjdG9yKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbG9uZWQuc2V0KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IFtdIDoge307XG4gICAgICAgIGNsb25lZC5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB2YWx1ZSkge1xuICAgICAgICAgIHZhciBkZXNjID0gdm9pZCAwLFxuICAgICAgICAgICAgICBwID0gdmFsdWU7XG5cbiAgICAgICAgICB3aGlsZSAoIShkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwLCBpKSkpIHtcbiAgICAgICAgICAgIHAgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBkZXNjLnZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGRlc2MudmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5ICYmIHZhbHVlLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvb3BiYWNrUG9ydC5wb3N0TWVzc2FnZSAtIGNhbm5vdCBjbG9uZTogXCIuY29uY2F0KHZhbHVlW2ldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdFtpXSA9IGNsb25lVmFsdWUoZGVzYy52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2RlZmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgIGxpc3RlbmVyLmNhbGwoX3RoaXM4LCB7XG4gICAgICAgICAgICBkYXRhOiBvYmpcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvbmVkID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIHZhciBlID0ge1xuICAgICAgICBkYXRhOiBjbG9uZVZhbHVlKG9iailcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2RlZmVycmVkLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczguX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgIGxpc3RlbmVyLmNhbGwoX3RoaXM4LCBlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGkgPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG5cbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRlcm1pbmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXJtaW5hdGUoKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTG9vcGJhY2tQb3J0O1xufSgpO1xuXG5leHBvcnRzLkxvb3BiYWNrUG9ydCA9IExvb3BiYWNrUG9ydDtcblxudmFyIFBERldvcmtlciA9IGZ1bmN0aW9uIFBERldvcmtlckNsb3N1cmUoKSB7XG4gIHZhciBwZGZXb3JrZXJQb3J0cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBpc1dvcmtlckRpc2FibGVkID0gZmFsc2U7XG4gIHZhciBmYWxsYmFja1dvcmtlclNyYztcbiAgdmFyIG5leHRGYWtlV29ya2VySWQgPSAwO1xuICB2YXIgZmFrZVdvcmtlckNhcGFiaWxpdHk7XG5cbiAgaWYgKF9pc19ub2RlLmlzTm9kZUpTICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICBmYWxsYmFja1dvcmtlclNyYyA9IFwiLi9wZGYud29ya2VyLmpzXCI7XG4gIH0gZWxzZSBpZiAoKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGRvY3VtZW50KSkgPT09IFwib2JqZWN0XCIgJiYgXCJjdXJyZW50U2NyaXB0XCIgaW4gZG9jdW1lbnQpIHtcbiAgICB2YXIgX2RvY3VtZW50JGN1cnJlbnRTY3JpO1xuXG4gICAgdmFyIHBkZmpzRmlsZVBhdGggPSAoX2RvY3VtZW50JGN1cnJlbnRTY3JpID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdCkgPT09IG51bGwgfHwgX2RvY3VtZW50JGN1cnJlbnRTY3JpID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZG9jdW1lbnQkY3VycmVudFNjcmkuc3JjO1xuXG4gICAgaWYgKHBkZmpzRmlsZVBhdGgpIHtcbiAgICAgIGZhbGxiYWNrV29ya2VyU3JjID0gcGRmanNGaWxlUGF0aC5yZXBsYWNlKC8oXFwuKD86bWluXFwuKT9qcykoXFw/LiopPyQvaSwgXCIud29ya2VyJDEkMlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0V29ya2VyU3JjKCkge1xuICAgIGlmIChfd29ya2VyX29wdGlvbnMuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMpIHtcbiAgICAgIHJldHVybiBfd29ya2VyX29wdGlvbnMuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmYWxsYmFja1dvcmtlclNyYyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKCFfaXNfbm9kZS5pc05vZGVKUykge1xuICAgICAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoJ05vIFwiR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmNcIiBzcGVjaWZpZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxsYmFja1dvcmtlclNyYztcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwiR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmNcIiBzcGVjaWZpZWQuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgdmFyIG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgX2dsb2JhbFRoaXMkcGRmanNXb3JrO1xuXG4gICAgICBtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIgPSAoX2dsb2JhbFRoaXMkcGRmanNXb3JrID0gZ2xvYmFsVGhpcy5wZGZqc1dvcmtlcikgPT09IG51bGwgfHwgX2dsb2JhbFRoaXMkcGRmanNXb3JrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2xvYmFsVGhpcyRwZGZqc1dvcmsuV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgfSBjYXRjaCAoZXgpIHt9XG5cbiAgICByZXR1cm4gbWFpbldvcmtlck1lc3NhZ2VIYW5kbGVyIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cEZha2VXb3JrZXJHbG9iYWwoKSB7XG4gICAgaWYgKGZha2VXb3JrZXJDYXBhYmlsaXR5KSB7XG4gICAgICByZXR1cm4gZmFrZVdvcmtlckNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG5cbiAgICBmYWtlV29ya2VyQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcblxuICAgIHZhciBsb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYxMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIsIHdvcmtlcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIgPSBnZXRNYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIoKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWFpbldvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbWFpbldvcmtlck1lc3NhZ2VIYW5kbGVyKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKCEoX2lzX25vZGUuaXNOb2RlSlMgJiYgdHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd29ya2VyID0gZXZhbChcInJlcXVpcmVcIikoX2dldFdvcmtlclNyYygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHdvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2Rpc3BsYXlfdXRpbHMubG9hZFNjcmlwdCkoX2dldFdvcmtlclNyYygpKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB3aW5kb3cucGRmanNXb3JrZXIuV29ya2VyTWVzc2FnZUhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYxMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICBsb2FkZXIoKS50aGVuKGZha2VXb3JrZXJDYXBhYmlsaXR5LnJlc29sdmUsIGZha2VXb3JrZXJDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgcmV0dXJuIGZha2VXb3JrZXJDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDRE5XcmFwcGVyKHVybCkge1xuICAgIHZhciB3cmFwcGVyID0gXCJpbXBvcnRTY3JpcHRzKCdcIiArIHVybCArIFwiJyk7XCI7XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3dyYXBwZXJdKSk7XG4gIH1cblxuICB2YXIgUERGV29ya2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQREZXb3JrZXIoKSB7XG4gICAgICB2YXIgX3JlZjEzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBfcmVmMTMkbmFtZSA9IF9yZWYxMy5uYW1lLFxuICAgICAgICAgIG5hbWUgPSBfcmVmMTMkbmFtZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYxMyRuYW1lLFxuICAgICAgICAgIF9yZWYxMyRwb3J0ID0gX3JlZjEzLnBvcnQsXG4gICAgICAgICAgcG9ydCA9IF9yZWYxMyRwb3J0ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjEzJHBvcnQsXG4gICAgICAgICAgX3JlZjEzJHZlcmJvc2l0eSA9IF9yZWYxMy52ZXJib3NpdHksXG4gICAgICAgICAgdmVyYm9zaXR5ID0gX3JlZjEzJHZlcmJvc2l0eSA9PT0gdm9pZCAwID8gKDAsIF91dGlsLmdldFZlcmJvc2l0eUxldmVsKSgpIDogX3JlZjEzJHZlcmJvc2l0eTtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERldvcmtlcik7XG5cbiAgICAgIGlmIChwb3J0ICYmIHBkZldvcmtlclBvcnRzLmhhcyhwb3J0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIG1vcmUgdGhhbiBvbmUgUERGV29ya2VyIHBlciBwb3J0XCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9zdE1lc3NhZ2VUcmFuc2ZlcnMgPSB0cnVlO1xuICAgICAgdGhpcy52ZXJib3NpdHkgPSB2ZXJib3NpdHk7XG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICB0aGlzLl9wb3J0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3dlYldvcmtlciA9IG51bGw7XG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG51bGw7XG5cbiAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgIHBkZldvcmtlclBvcnRzLnNldChwb3J0LCB0aGlzKTtcblxuICAgICAgICB0aGlzLl9pbml0aWFsaXplRnJvbVBvcnQocG9ydCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFBERldvcmtlciwgW3tcbiAgICAgIGtleTogXCJwcm9taXNlXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwb3J0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm1lc3NhZ2VIYW5kbGVyXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaW5pdGlhbGl6ZUZyb21Qb3J0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRpYWxpemVGcm9tUG9ydChwb3J0KSB7XG4gICAgICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCBwb3J0KTtcblxuICAgICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGZ1bmN0aW9uICgpIHt9KTtcblxuICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaW5pdGlhbGl6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0aWFsaXplKCkge1xuICAgICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgICBpZiAodHlwZW9mIFdvcmtlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNXb3JrZXJEaXNhYmxlZCAmJiAhZ2V0TWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKCkpIHtcbiAgICAgICAgICB2YXIgd29ya2VyU3JjID0gX2dldFdvcmtlclNyYygpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghKDAsIF91dGlsLmlzU2FtZU9yaWdpbikod2luZG93LmxvY2F0aW9uLmhyZWYsIHdvcmtlclNyYykpIHtcbiAgICAgICAgICAgICAgd29ya2VyU3JjID0gY3JlYXRlQ0ROV3JhcHBlcihuZXcgVVJMKHdvcmtlclNyYywgd2luZG93LmxvY2F0aW9uKS5ocmVmKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjKTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCB3b3JrZXIpO1xuXG4gICAgICAgICAgICB2YXIgdGVybWluYXRlRWFybHkgPSBmdW5jdGlvbiB0ZXJtaW5hdGVFYXJseSgpIHtcbiAgICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbldvcmtlckVycm9yKTtcbiAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKF90aGlzOS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpczkuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzOS5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBvbldvcmtlckVycm9yID0gZnVuY3Rpb24gb25Xb3JrZXJFcnJvcigpIHtcbiAgICAgICAgICAgICAgaWYgKCFfdGhpczkuX3dlYldvcmtlcikge1xuICAgICAgICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Xb3JrZXJFcnJvcik7XG4gICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5vbihcInRlc3RcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbldvcmtlckVycm9yKTtcblxuICAgICAgICAgICAgICBpZiAoX3RoaXM5LmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBfdGhpczkuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICAgICAgICAgICAgX3RoaXM5Ll9wb3J0ID0gd29ya2VyO1xuICAgICAgICAgICAgICAgIF90aGlzOS5fd2ViV29ya2VyID0gd29ya2VyO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLnN1cHBvcnRUcmFuc2ZlcnMpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzOS5wb3N0TWVzc2FnZVRyYW5zZmVycyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF90aGlzOS5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcblxuICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJjb25maWd1cmVcIiwge1xuICAgICAgICAgICAgICAgICAgdmVyYm9zaXR5OiBfdGhpczkudmVyYm9zaXR5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXM5Ll9zZXR1cEZha2VXb3JrZXIoKTtcblxuICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJyZWFkeVwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuXG4gICAgICAgICAgICAgIGlmIChfdGhpczkuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNlbmRUZXN0KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpczkuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHNlbmRUZXN0ID0gZnVuY3Rpb24gc2VuZFRlc3QoKSB7XG4gICAgICAgICAgICAgIHZhciB0ZXN0T2JqID0gbmV3IFVpbnQ4QXJyYXkoW190aGlzOS5wb3N0TWVzc2FnZVRyYW5zZmVycyA/IDI1NSA6IDBdKTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJ0ZXN0XCIsIHRlc3RPYmosIFt0ZXN0T2JqLmJ1ZmZlcl0pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIkNhbm5vdCB1c2UgcG9zdE1lc3NhZ2UgdHJhbnNmZXJzLlwiKTtcbiAgICAgICAgICAgICAgICB0ZXN0T2JqWzBdID0gMDtcbiAgICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwidGVzdFwiLCB0ZXN0T2JqKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWwuaW5mbykoXCJUaGUgd29ya2VyIGhhcyBiZWVuIGRpc2FibGVkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldHVwRmFrZVdvcmtlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEZha2VXb3JrZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgICBpZiAoIWlzV29ya2VyRGlzYWJsZWQpIHtcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJTZXR0aW5nIHVwIGZha2Ugd29ya2VyLlwiKTtcbiAgICAgICAgICBpc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHVwRmFrZVdvcmtlckdsb2JhbCgpLnRoZW4oZnVuY3Rpb24gKFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKF90aGlzMTAuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICBfdGhpczEwLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwb3J0ID0gbmV3IExvb3BiYWNrUG9ydCgpO1xuICAgICAgICAgIF90aGlzMTAuX3BvcnQgPSBwb3J0O1xuICAgICAgICAgIHZhciBpZCA9IFwiZmFrZVwiICsgbmV4dEZha2VXb3JrZXJJZCsrO1xuICAgICAgICAgIHZhciB3b3JrZXJIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoaWQgKyBcIl93b3JrZXJcIiwgaWQsIHBvcnQpO1xuICAgICAgICAgIFdvcmtlck1lc3NhZ2VIYW5kbGVyLnNldHVwKHdvcmtlckhhbmRsZXIsIHBvcnQpO1xuICAgICAgICAgIHZhciBtZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKGlkLCBpZCArIFwiX3dvcmtlclwiLCBwb3J0KTtcbiAgICAgICAgICBfdGhpczEwLl9tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuXG4gICAgICAgICAgX3RoaXMxMC5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcblxuICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJjb25maWd1cmVcIiwge1xuICAgICAgICAgICAgdmVyYm9zaXR5OiBfdGhpczEwLnZlcmJvc2l0eVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBfdGhpczEwLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIlNldHRpbmcgdXAgZmFrZSB3b3JrZXIgZmFpbGVkOiBcXFwiXCIuY29uY2F0KHJlYXNvbi5tZXNzYWdlLCBcIlxcXCIuXCIpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLl93ZWJXb3JrZXIpIHtcbiAgICAgICAgICB0aGlzLl93ZWJXb3JrZXIudGVybWluYXRlKCk7XG5cbiAgICAgICAgICB0aGlzLl93ZWJXb3JrZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcGRmV29ya2VyUG9ydHNbXCJkZWxldGVcIl0odGhpcy5fcG9ydCk7XG4gICAgICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLl9tZXNzYWdlSGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcblxuICAgICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImZyb21Qb3J0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVBvcnQocGFyYW1zKSB7XG4gICAgICAgIGlmICghcGFyYW1zIHx8ICFwYXJhbXMucG9ydCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBERldvcmtlci5mcm9tUG9ydCAtIGludmFsaWQgbWV0aG9kIHNpZ25hdHVyZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGRmV29ya2VyUG9ydHMuaGFzKHBhcmFtcy5wb3J0KSkge1xuICAgICAgICAgIHJldHVybiBwZGZXb3JrZXJQb3J0cy5nZXQocGFyYW1zLnBvcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQREZXb3JrZXIocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0V29ya2VyU3JjXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V29ya2VyU3JjKCkge1xuICAgICAgICByZXR1cm4gX2dldFdvcmtlclNyYygpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQREZXb3JrZXI7XG4gIH0oKTtcblxuICByZXR1cm4gUERGV29ya2VyO1xufSgpO1xuXG5leHBvcnRzLlBERldvcmtlciA9IFBERldvcmtlcjtcblxudmFyIFdvcmtlclRyYW5zcG9ydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdvcmtlclRyYW5zcG9ydChtZXNzYWdlSGFuZGxlciwgbG9hZGluZ1Rhc2ssIG5ldHdvcmtTdHJlYW0sIHBhcmFtcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXb3JrZXJUcmFuc3BvcnQpO1xuXG4gICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG1lc3NhZ2VIYW5kbGVyO1xuICAgIHRoaXMubG9hZGluZ1Rhc2sgPSBsb2FkaW5nVGFzaztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuZm9udExvYWRlciA9IG5ldyBfZm9udF9sb2FkZXIuRm9udExvYWRlcih7XG4gICAgICBkb2NJZDogbG9hZGluZ1Rhc2suZG9jSWQsXG4gICAgICBvblVuc3VwcG9ydGVkRmVhdHVyZTogdGhpcy5fb25VbnN1cHBvcnRlZEZlYXR1cmUuYmluZCh0aGlzKSxcbiAgICAgIG93bmVyRG9jdW1lbnQ6IHBhcmFtcy5vd25lckRvY3VtZW50XG4gICAgfSk7XG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuQ01hcFJlYWRlckZhY3RvcnkgPSBuZXcgcGFyYW1zLkNNYXBSZWFkZXJGYWN0b3J5KHtcbiAgICAgIGJhc2VVcmw6IHBhcmFtcy5jTWFwVXJsLFxuICAgICAgaXNDb21wcmVzc2VkOiBwYXJhbXMuY01hcFBhY2tlZFxuICAgIH0pO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy5fcGFzc3dvcmRDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLl9uZXR3b3JrU3RyZWFtID0gbmV0d29ya1N0cmVhbTtcbiAgICB0aGlzLl9mdWxsUmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMucGFnZUNhY2hlID0gW107XG4gICAgdGhpcy5wYWdlUHJvbWlzZXMgPSBbXTtcbiAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgdGhpcy5zZXR1cE1lc3NhZ2VIYW5kbGVyKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV29ya2VyVHJhbnNwb3J0LCBbe1xuICAgIGtleTogXCJsb2FkaW5nVGFza1NldHRsZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnNldHRsZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuZGVzdHJveUNhcGFiaWxpdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcblxuICAgICAgaWYgKHRoaXMuX3Bhc3N3b3JkQ2FwYWJpbGl0eSkge1xuICAgICAgICB0aGlzLl9wYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkIGR1cmluZyBvblBhc3N3b3JkIGNhbGxiYWNrXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdhaXRPbiA9IFtdO1xuICAgICAgdGhpcy5wYWdlQ2FjaGUuZm9yRWFjaChmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgIHdhaXRPbi5wdXNoKHBhZ2UuX2Rlc3Ryb3koKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wYWdlQ2FjaGUubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucGFnZVByb21pc2VzLmxlbmd0aCA9IDA7XG4gICAgICB2YXIgdGVybWluYXRlZCA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiVGVybWluYXRlXCIsIG51bGwpO1xuICAgICAgd2FpdE9uLnB1c2godGVybWluYXRlZCk7XG5cbiAgICAgIGlmICh0aGlzLmxvYWRpbmdUYXNrU2V0dGxlZCkge1xuICAgICAgICB2YXIgYW5ub3RhdGlvblN0b3JhZ2VSZXNldE1vZGlmaWVkID0gdGhpcy5sb2FkaW5nVGFzay5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHBkZkRvY3VtZW50KSB7XG4gICAgICAgICAgaWYgKHBkZkRvY3VtZW50Lmhhc093blByb3BlcnR5KFwiYW5ub3RhdGlvblN0b3JhZ2VcIikpIHtcbiAgICAgICAgICAgIHBkZkRvY3VtZW50LmFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge30pO1xuICAgICAgICB3YWl0T24ucHVzaChhbm5vdGF0aW9uU3RvcmFnZVJlc2V0TW9kaWZpZWQpO1xuICAgICAgfVxuXG4gICAgICBQcm9taXNlLmFsbCh3YWl0T24pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczExLmNvbW1vbk9ianMuY2xlYXIoKTtcblxuICAgICAgICBfdGhpczExLmZvbnRMb2FkZXIuY2xlYXIoKTtcblxuICAgICAgICBfdGhpczExLl9oYXNKU0FjdGlvbnNQcm9taXNlID0gbnVsbDtcblxuICAgICAgICBpZiAoX3RoaXMxMS5fbmV0d29ya1N0cmVhbSkge1xuICAgICAgICAgIF90aGlzMTEuX25ldHdvcmtTdHJlYW0uY2FuY2VsQWxsUmVxdWVzdHMobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwiV29ya2VyIHdhcyB0ZXJtaW5hdGVkLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMxMS5tZXNzYWdlSGFuZGxlcikge1xuICAgICAgICAgIF90aGlzMTEubWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuXG4gICAgICAgICAgX3RoaXMxMS5tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczExLmRlc3Ryb3lDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIH0sIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwTWVzc2FnZUhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBNZXNzYWdlSGFuZGxlcigpIHtcbiAgICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgICAgdmFyIG1lc3NhZ2VIYW5kbGVyID0gdGhpcy5tZXNzYWdlSGFuZGxlcixcbiAgICAgICAgICBsb2FkaW5nVGFzayA9IHRoaXMubG9hZGluZ1Rhc2s7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJlYWRlclwiLCBmdW5jdGlvbiAoZGF0YSwgc2luaykge1xuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShfdGhpczEyLl9uZXR3b3JrU3RyZWFtLCBcIkdldFJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgICBfdGhpczEyLl9mdWxsUmVhZGVyID0gX3RoaXMxMi5fbmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyKCk7XG5cbiAgICAgICAgX3RoaXMxMi5fZnVsbFJlYWRlci5vblByb2dyZXNzID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgIF90aGlzMTIuX2xhc3RQcm9ncmVzcyA9IHtcbiAgICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpbmsub25QdWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMTIuX2Z1bGxSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWYxNCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX3JlZjE0LnZhbHVlLFxuICAgICAgICAgICAgICAgIGRvbmUgPSBfcmVmMTQuZG9uZTtcblxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKSh2YWx1ZSksIFwiR2V0UmVhZGVyIC0gZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIuXCIpO1xuICAgICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2luay5vbkNhbmNlbCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBfdGhpczEyLl9mdWxsUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuXG4gICAgICAgICAgc2luay5yZWFkeVtcImNhdGNoXCJdKGZ1bmN0aW9uIChyZWFkeVJlYXNvbikge1xuICAgICAgICAgICAgaWYgKF90aGlzMTIuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUmVhZGVySGVhZGVyc1JlYWR5XCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBoZWFkZXJzQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgICAgdmFyIGZ1bGxSZWFkZXIgPSBfdGhpczEyLl9mdWxsUmVhZGVyO1xuICAgICAgICBmdWxsUmVhZGVyLmhlYWRlcnNSZWFkeS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWZ1bGxSZWFkZXIuaXNTdHJlYW1pbmdTdXBwb3J0ZWQgfHwgIWZ1bGxSZWFkZXIuaXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgaWYgKF90aGlzMTIuX2xhc3RQcm9ncmVzcyAmJiBsb2FkaW5nVGFzay5vblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3MoX3RoaXMxMi5fbGFzdFByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVsbFJlYWRlci5vblByb2dyZXNzID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICBpZiAobG9hZGluZ1Rhc2sub25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgICAgaXNTdHJlYW1pbmdTdXBwb3J0ZWQ6IGZ1bGxSZWFkZXIuaXNTdHJlYW1pbmdTdXBwb3J0ZWQsXG4gICAgICAgICAgICBpc1JhbmdlU3VwcG9ydGVkOiBmdWxsUmVhZGVyLmlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgICAgICBjb250ZW50TGVuZ3RoOiBmdWxsUmVhZGVyLmNvbnRlbnRMZW5ndGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmFuZ2VSZWFkZXJcIiwgZnVuY3Rpb24gKGRhdGEsIHNpbmspIHtcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkoX3RoaXMxMi5fbmV0d29ya1N0cmVhbSwgXCJHZXRSYW5nZVJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuXG4gICAgICAgIHZhciByYW5nZVJlYWRlciA9IF90aGlzMTIuX25ldHdvcmtTdHJlYW0uZ2V0UmFuZ2VSZWFkZXIoZGF0YS5iZWdpbiwgZGF0YS5lbmQpO1xuXG4gICAgICAgIGlmICghcmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2luay5vblB1bGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmFuZ2VSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWYxNSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX3JlZjE1LnZhbHVlLFxuICAgICAgICAgICAgICAgIGRvbmUgPSBfcmVmMTUuZG9uZTtcblxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKSh2YWx1ZSksIFwiR2V0UmFuZ2VSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBzaW5rLm9uQ2FuY2VsID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHJhbmdlUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgICAgIHNpbmsucmVhZHlbXCJjYXRjaFwiXShmdW5jdGlvbiAocmVhZHlSZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChfdGhpczEyLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldERvY1wiLCBmdW5jdGlvbiAoX3JlZjE2KSB7XG4gICAgICAgIHZhciBwZGZJbmZvID0gX3JlZjE2LnBkZkluZm87XG4gICAgICAgIF90aGlzMTIuX251bVBhZ2VzID0gcGRmSW5mby5udW1QYWdlcztcblxuICAgICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZXNvbHZlKG5ldyBQREZEb2N1bWVudFByb3h5KHBkZkluZm8sIF90aGlzMTIpKTtcbiAgICAgIH0pO1xuICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJEb2NFeGNlcHRpb25cIiwgZnVuY3Rpb24gKGV4KSB7XG4gICAgICAgIHZhciByZWFzb247XG5cbiAgICAgICAgc3dpdGNoIChleC5uYW1lKSB7XG4gICAgICAgICAgY2FzZSBcIlBhc3N3b3JkRXhjZXB0aW9uXCI6XG4gICAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuUGFzc3dvcmRFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguY29kZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCI6XG4gICAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuSW52YWxpZFBERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIk1pc3NpbmdQREZFeGNlcHRpb25cIjpcbiAgICAgICAgICAgIHJlYXNvbiA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LnN0YXR1cyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgICAgICAgIHJlYXNvbiA9IG5ldyBfdXRpbC5Vbmtub3duRXJyb3JFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguZGV0YWlscyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHZhciBtc2cgPSBcIkRvY0V4Y2VwdGlvbiAtIGV4cGVjdGVkIGEgdmFsaWQgRXJyb3IuXCI7XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKG1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJQYXNzd29yZFJlcXVlc3RcIiwgZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICBfdGhpczEyLl9wYXNzd29yZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG5cbiAgICAgICAgaWYgKGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQpIHtcbiAgICAgICAgICB2YXIgdXBkYXRlUGFzc3dvcmQgPSBmdW5jdGlvbiB1cGRhdGVQYXNzd29yZChwYXNzd29yZCkge1xuICAgICAgICAgICAgX3RoaXMxMi5fcGFzc3dvcmRDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9hZGluZ1Rhc2sub25QYXNzd29yZCh1cGRhdGVQYXNzd29yZCwgZXhjZXB0aW9uLmNvZGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBfdGhpczEyLl9wYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMxMi5fcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChuZXcgX3V0aWwuUGFzc3dvcmRFeGNlcHRpb24oZXhjZXB0aW9uLm1lc3NhZ2UsIGV4Y2VwdGlvbi5jb2RlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMxMi5fcGFzc3dvcmRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRGF0YUxvYWRlZFwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAobG9hZGluZ1Rhc2sub25Qcm9ncmVzcykge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgbG9hZGVkOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsOiBkYXRhLmxlbmd0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMxMi5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnJlc29sdmUoZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiU3RhcnRSZW5kZXJQYWdlXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChfdGhpczEyLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWdlID0gX3RoaXMxMi5wYWdlQ2FjaGVbZGF0YS5wYWdlSW5kZXhdO1xuXG4gICAgICAgIHBhZ2UuX3N0YXJ0UmVuZGVyUGFnZShkYXRhLnRyYW5zcGFyZW5jeSwgZGF0YS5pbnRlbnQpO1xuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcImNvbW1vbm9ialwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX2dsb2JhbFRoaXMkRm9udEluc3BlO1xuXG4gICAgICAgIGlmIChfdGhpczEyLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZGF0YSA9IF9zbGljZWRUb0FycmF5KGRhdGEsIDMpLFxuICAgICAgICAgICAgaWQgPSBfZGF0YVswXSxcbiAgICAgICAgICAgIHR5cGUgPSBfZGF0YVsxXSxcbiAgICAgICAgICAgIGV4cG9ydGVkRGF0YSA9IF9kYXRhWzJdO1xuXG4gICAgICAgIGlmIChfdGhpczEyLmNvbW1vbk9ianMuaGFzKGlkKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gX3RoaXMxMi5fcGFyYW1zO1xuXG4gICAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIGV4cG9ydGVkRGF0YSkge1xuICAgICAgICAgICAgICB2YXIgZXhwb3J0ZWRFcnJvciA9IGV4cG9ydGVkRGF0YS5lcnJvcjtcbiAgICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiRXJyb3IgZHVyaW5nIGZvbnQgbG9hZGluZzogXCIuY29uY2F0KGV4cG9ydGVkRXJyb3IpKTtcblxuICAgICAgICAgICAgICBfdGhpczEyLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWRFcnJvcik7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmb250UmVnaXN0cnkgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLnBkZkJ1ZyAmJiAoX2dsb2JhbFRoaXMkRm9udEluc3BlID0gZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yKSAhPT0gbnVsbCAmJiBfZ2xvYmFsVGhpcyRGb250SW5zcGUgIT09IHZvaWQgMCAmJiBfZ2xvYmFsVGhpcyRGb250SW5zcGUuZW5hYmxlZCkge1xuICAgICAgICAgICAgICBmb250UmVnaXN0cnkgPSB7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJGb250OiBmdW5jdGlvbiByZWdpc3RlckZvbnQoZm9udCwgdXJsKSB7XG4gICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3IuZm9udEFkZGVkKGZvbnQsIHVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZm9udCA9IG5ldyBfZm9udF9sb2FkZXIuRm9udEZhY2VPYmplY3QoZXhwb3J0ZWREYXRhLCB7XG4gICAgICAgICAgICAgIGlzRXZhbFN1cHBvcnRlZDogcGFyYW1zLmlzRXZhbFN1cHBvcnRlZCxcbiAgICAgICAgICAgICAgZGlzYWJsZUZvbnRGYWNlOiBwYXJhbXMuZGlzYWJsZUZvbnRGYWNlLFxuICAgICAgICAgICAgICBpZ25vcmVFcnJvcnM6IHBhcmFtcy5pZ25vcmVFcnJvcnMsXG4gICAgICAgICAgICAgIG9uVW5zdXBwb3J0ZWRGZWF0dXJlOiBfdGhpczEyLl9vblVuc3VwcG9ydGVkRmVhdHVyZS5iaW5kKF90aGlzMTIpLFxuICAgICAgICAgICAgICBmb250UmVnaXN0cnk6IGZvbnRSZWdpc3RyeVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF90aGlzMTIuZm9udExvYWRlci5iaW5kKGZvbnQpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiRm9udEZhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVtcImZpbmFsbHlcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoIXBhcmFtcy5mb250RXh0cmFQcm9wZXJ0aWVzICYmIGZvbnQuZGF0YSkge1xuICAgICAgICAgICAgICAgIGZvbnQuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfdGhpczEyLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZm9udCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiRm9udFBhdGhcIjpcbiAgICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgICAgIF90aGlzMTIuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZERhdGEpO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHb3QgdW5rbm93biBjb21tb24gb2JqZWN0IHR5cGUgXCIuY29uY2F0KHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcIm9ialwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgX2ltYWdlRGF0YSRkYXRhO1xuXG4gICAgICAgIGlmIChfdGhpczEyLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2RhdGEyID0gX3NsaWNlZFRvQXJyYXkoZGF0YSwgNCksXG4gICAgICAgICAgICBpZCA9IF9kYXRhMlswXSxcbiAgICAgICAgICAgIHBhZ2VJbmRleCA9IF9kYXRhMlsxXSxcbiAgICAgICAgICAgIHR5cGUgPSBfZGF0YTJbMl0sXG4gICAgICAgICAgICBpbWFnZURhdGEgPSBfZGF0YTJbM107XG5cbiAgICAgICAgdmFyIHBhZ2VQcm94eSA9IF90aGlzMTIucGFnZUNhY2hlW3BhZ2VJbmRleF07XG5cbiAgICAgICAgaWYgKHBhZ2VQcm94eS5vYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIkltYWdlXCI6XG4gICAgICAgICAgICBwYWdlUHJveHkub2Jqcy5yZXNvbHZlKGlkLCBpbWFnZURhdGEpO1xuICAgICAgICAgICAgdmFyIE1BWF9JTUFHRV9TSVpFX1RPX1NUT1JFID0gODAwMDAwMDtcblxuICAgICAgICAgICAgaWYgKChpbWFnZURhdGEgPT09IG51bGwgfHwgaW1hZ2VEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2ltYWdlRGF0YSRkYXRhID0gaW1hZ2VEYXRhLmRhdGEpID09PSBudWxsIHx8IF9pbWFnZURhdGEkZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ltYWdlRGF0YSRkYXRhLmxlbmd0aCkgPiBNQVhfSU1BR0VfU0laRV9UT19TVE9SRSkge1xuICAgICAgICAgICAgICBwYWdlUHJveHkuY2xlYW51cEFmdGVyUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR290IHVua25vd24gb2JqZWN0IHR5cGUgXCIuY29uY2F0KHR5cGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jUHJvZ3Jlc3NcIiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKF90aGlzMTIuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzKHtcbiAgICAgICAgICAgIGxvYWRlZDogZGF0YS5sb2FkZWQsXG4gICAgICAgICAgICB0b3RhbDogZGF0YS50b3RhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiVW5zdXBwb3J0ZWRGZWF0dXJlXCIsIHRoaXMuX29uVW5zdXBwb3J0ZWRGZWF0dXJlLmJpbmQodGhpcykpO1xuICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJGZXRjaEJ1aWx0SW5DTWFwXCIsIGZ1bmN0aW9uIChkYXRhLCBzaW5rKSB7XG4gICAgICAgIGlmIChfdGhpczEyLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHNpbmsuZXJyb3IobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmZXRjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgc2luay5vblB1bGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZldGNoZWQpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmZXRjaGVkID0gdHJ1ZTtcblxuICAgICAgICAgIF90aGlzMTIuQ01hcFJlYWRlckZhY3RvcnkuZmV0Y2goZGF0YSkudGhlbihmdW5jdGlvbiAoYnVpbHRJbkNNYXApIHtcbiAgICAgICAgICAgIHNpbmsuZW5xdWV1ZShidWlsdEluQ01hcCwgMSwgW2J1aWx0SW5DTWFwLmNNYXBEYXRhLmJ1ZmZlcl0pO1xuICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblVuc3VwcG9ydGVkRmVhdHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25VbnN1cHBvcnRlZEZlYXR1cmUoX3JlZjE3KSB7XG4gICAgICB2YXIgZmVhdHVyZUlkID0gX3JlZjE3LmZlYXR1cmVJZDtcblxuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubG9hZGluZ1Rhc2sub25VbnN1cHBvcnRlZEZlYXR1cmUpIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nVGFzay5vblVuc3VwcG9ydGVkRmVhdHVyZShmZWF0dXJlSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREYXRhXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgICAgdmFyIF90aGlzMTMgPSB0aGlzO1xuXG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocGFnZU51bWJlcikgfHwgcGFnZU51bWJlciA8PSAwIHx8IHBhZ2VOdW1iZXIgPiB0aGlzLl9udW1QYWdlcykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBwYWdlIHJlcXVlc3RcIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDE7XG5cbiAgICAgIGlmIChwYWdlSW5kZXggaW4gdGhpcy5wYWdlUHJvbWlzZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZVByb21pc2VzW3BhZ2VJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlXCIsIHtcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXhcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHBhZ2VJbmZvKSB7XG4gICAgICAgIGlmIChfdGhpczEzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCBkZXN0cm95ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFnZSA9IG5ldyBQREZQYWdlUHJveHkocGFnZUluZGV4LCBwYWdlSW5mbywgX3RoaXMxMywgX3RoaXMxMy5fcGFyYW1zLm93bmVyRG9jdW1lbnQsIF90aGlzMTMuX3BhcmFtcy5wZGZCdWcpO1xuICAgICAgICBfdGhpczEzLnBhZ2VDYWNoZVtwYWdlSW5kZXhdID0gcGFnZTtcbiAgICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGFnZVByb21pc2VzW3BhZ2VJbmRleF0gPSBwcm9taXNlO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBhZ2VJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlSW5kZXhcIiwge1xuICAgICAgICByZWY6IHJlZlxuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFnZU9DR05hbWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2VPQ0dOYW1lcyhyZWYpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VPQ0dOYW1lc1wiLCB7XG4gICAgICAgIHJlZjogcmVmXG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T2JqZWN0KHJlZikge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T2JqZWN0XCIsIHtcbiAgICAgICAgcmVmOiByZWZcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFubm90YXRpb25zKHBhZ2VJbmRleCwgaW50ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBbm5vdGF0aW9uc1wiLCB7XG4gICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICBpbnRlbnQ6IGludGVudFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhdmVEb2N1bWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlRG9jdW1lbnQoYW5ub3RhdGlvblN0b3JhZ2UpIHtcbiAgICAgIHZhciBfdGhpcyRfZnVsbFJlYWRlciRmaWwsIF90aGlzJF9mdWxsUmVhZGVyO1xuXG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJTYXZlRG9jdW1lbnRcIiwge1xuICAgICAgICBudW1QYWdlczogdGhpcy5fbnVtUGFnZXMsXG4gICAgICAgIGFubm90YXRpb25TdG9yYWdlOiAoYW5ub3RhdGlvblN0b3JhZ2UgPT09IG51bGwgfHwgYW5ub3RhdGlvblN0b3JhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFubm90YXRpb25TdG9yYWdlLmdldEFsbCgpKSB8fCBudWxsLFxuICAgICAgICBmaWxlbmFtZTogKF90aGlzJF9mdWxsUmVhZGVyJGZpbCA9IChfdGhpcyRfZnVsbFJlYWRlciA9IHRoaXMuX2Z1bGxSZWFkZXIpID09PSBudWxsIHx8IF90aGlzJF9mdWxsUmVhZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfZnVsbFJlYWRlci5maWxlbmFtZSkgIT09IG51bGwgJiYgX3RoaXMkX2Z1bGxSZWFkZXIkZmlsICE9PSB2b2lkIDAgPyBfdGhpcyRfZnVsbFJlYWRlciRmaWwgOiBudWxsXG4gICAgICB9KVtcImZpbmFsbHlcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoYW5ub3RhdGlvblN0b3JhZ2UpIHtcbiAgICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZS5yZXNldE1vZGlmaWVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGaWVsZE9iamVjdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmllbGRPYmplY3RzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RmllbGRPYmplY3RzXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNKU0FjdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzSlNBY3Rpb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc0pTQWN0aW9uc1Byb21pc2UgfHwgKHRoaXMuX2hhc0pTQWN0aW9uc1Byb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkhhc0pTQWN0aW9uc1wiLCBudWxsKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENhbGN1bGF0aW9uT3JkZXJJZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldENhbGN1bGF0aW9uT3JkZXJJZHNcIiwgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlc3RpbmF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvbnNcIiwgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlc3RpbmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIGRlc3RpbmF0aW9uIHJlcXVlc3QuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25cIiwge1xuICAgICAgICBpZDogaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGFiZWxzXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlTGF5b3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2VMYXlvdXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGF5b3V0XCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlTW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYWdlTW9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VNb2RlXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWV3ZXJQcmVmZXJlbmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3ZXJQcmVmZXJlbmNlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFZpZXdlclByZWZlcmVuY2VzXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcGVuQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcGVuQWN0aW9uXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdHRhY2htZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRhY2htZW50cygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRKYXZhU2NyaXB0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEphdmFTY3JpcHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRKYXZhU2NyaXB0XCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREb2NKU0FjdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RG9jSlNBY3Rpb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RG9jSlNBY3Rpb25zXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlSlNBY3Rpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2VKU0FjdGlvbnMocGFnZUluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlSlNBY3Rpb25zXCIsIHtcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPdXRsaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE91dGxpbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPdXRsaW5lXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcHRpb25hbENvbnRlbnRDb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3B0aW9uYWxDb250ZW50Q29uZmlnXCIsIG51bGwpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfb3B0aW9uYWxfY29udGVudF9jb25maWcuT3B0aW9uYWxDb250ZW50Q29uZmlnKHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBlcm1pc3Npb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBlcm1pc3Npb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGVybWlzc2lvbnNcIiwgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1ldGFkYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKCkge1xuICAgICAgdmFyIF90aGlzMTQgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRNZXRhZGF0YVwiLCBudWxsKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpczE0JF9mdWxsUmVhZGVyJGYsIF90aGlzMTQkX2Z1bGxSZWFkZXIsIF90aGlzMTQkX2Z1bGxSZWFkZXIkYywgX3RoaXMxNCRfZnVsbFJlYWRlcjI7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmZvOiByZXN1bHRzWzBdLFxuICAgICAgICAgIG1ldGFkYXRhOiByZXN1bHRzWzFdID8gbmV3IF9tZXRhZGF0YS5NZXRhZGF0YShyZXN1bHRzWzFdKSA6IG51bGwsXG4gICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IChfdGhpczE0JF9mdWxsUmVhZGVyJGYgPSAoX3RoaXMxNCRfZnVsbFJlYWRlciA9IF90aGlzMTQuX2Z1bGxSZWFkZXIpID09PSBudWxsIHx8IF90aGlzMTQkX2Z1bGxSZWFkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzMTQkX2Z1bGxSZWFkZXIuZmlsZW5hbWUpICE9PSBudWxsICYmIF90aGlzMTQkX2Z1bGxSZWFkZXIkZiAhPT0gdm9pZCAwID8gX3RoaXMxNCRfZnVsbFJlYWRlciRmIDogbnVsbCxcbiAgICAgICAgICBjb250ZW50TGVuZ3RoOiAoX3RoaXMxNCRfZnVsbFJlYWRlciRjID0gKF90aGlzMTQkX2Z1bGxSZWFkZXIyID0gX3RoaXMxNC5fZnVsbFJlYWRlcikgPT09IG51bGwgfHwgX3RoaXMxNCRfZnVsbFJlYWRlcjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzMTQkX2Z1bGxSZWFkZXIyLmNvbnRlbnRMZW5ndGgpICE9PSBudWxsICYmIF90aGlzMTQkX2Z1bGxSZWFkZXIkYyAhPT0gdm9pZCAwID8gX3RoaXMxNCRfZnVsbFJlYWRlciRjIDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcmtJbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtJbmZvKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0TWFya0luZm9cIiwgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFN0YXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0U3RhdHNcIiwgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0Q2xlYW51cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydENsZWFudXAoKSB7XG4gICAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkNsZWFudXBcIiwgbnVsbCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IF90aGlzMTUucGFnZUNhY2hlLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFnZSA9IF90aGlzMTUucGFnZUNhY2hlW2ldO1xuXG4gICAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICAgIHZhciBjbGVhbnVwU3VjY2Vzc2Z1bCA9IHBhZ2UuY2xlYW51cCgpO1xuXG4gICAgICAgICAgICBpZiAoIWNsZWFudXBTdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0YXJ0Q2xlYW51cDogUGFnZSBcIi5jb25jYXQoaSArIDEsIFwiIGlzIGN1cnJlbnRseSByZW5kZXJpbmcuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczE1LmNvbW1vbk9ianMuY2xlYXIoKTtcblxuICAgICAgICBfdGhpczE1LmZvbnRMb2FkZXIuY2xlYXIoKTtcblxuICAgICAgICBfdGhpczE1Ll9oYXNKU0FjdGlvbnNQcm9taXNlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2FkaW5nUGFyYW1zXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICAgICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwibG9hZGluZ1BhcmFtc1wiLCB7XG4gICAgICAgIGRpc2FibGVBdXRvRmV0Y2g6IHBhcmFtcy5kaXNhYmxlQXV0b0ZldGNoLFxuICAgICAgICBkaXNhYmxlRm9udEZhY2U6IHBhcmFtcy5kaXNhYmxlRm9udEZhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXb3JrZXJUcmFuc3BvcnQ7XG59KCk7XG5cbnZhciBQREZPYmplY3RzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGT2JqZWN0cygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGT2JqZWN0cyk7XG5cbiAgICB0aGlzLl9vYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZPYmplY3RzLCBbe1xuICAgIGtleTogXCJfZW5zdXJlT2JqXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnN1cmVPYmoob2JqSWQpIHtcbiAgICAgIGlmICh0aGlzLl9vYmpzW29iaklkXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Jqc1tvYmpJZF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9vYmpzW29iaklkXSA9IHtcbiAgICAgICAgY2FwYWJpbGl0eTogKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpLFxuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICByZXNvbHZlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQob2JqSWQpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZU9iaihvYmpJZCkuY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oY2FsbGJhY2spO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JqID0gdGhpcy5fb2Jqc1tvYmpJZF07XG5cbiAgICAgIGlmICghb2JqIHx8ICFvYmoucmVzb2x2ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGluZyBvYmplY3QgdGhhdCBpc24ndCByZXNvbHZlZCB5ZXQgXCIuY29uY2F0KG9iaklkLCBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqLmRhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMob2JqSWQpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl9vYmpzW29iaklkXTtcbiAgICAgIHJldHVybiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLnJlc29sdmVkKSB8fCBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKG9iaklkLCBkYXRhKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fZW5zdXJlT2JqKG9iaklkKTtcblxuICAgICAgb2JqLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIG9iai5kYXRhID0gZGF0YTtcbiAgICAgIG9iai5jYXBhYmlsaXR5LnJlc29sdmUoZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5fb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERk9iamVjdHM7XG59KCk7XG5cbnZhciBSZW5kZXJUYXNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVuZGVyVGFzayhpbnRlcm5hbFJlbmRlclRhc2spIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVuZGVyVGFzayk7XG5cbiAgICB0aGlzLl9pbnRlcm5hbFJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2s7XG4gICAgdGhpcy5vbkNvbnRpbnVlID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZW5kZXJUYXNrLCBbe1xuICAgIGtleTogXCJwcm9taXNlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIHRoaXMuX2ludGVybmFsUmVuZGVyVGFzay5jYW5jZWwoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVuZGVyVGFzaztcbn0oKTtcblxudmFyIEludGVybmFsUmVuZGVyVGFzayA9IGZ1bmN0aW9uIEludGVybmFsUmVuZGVyVGFza0Nsb3N1cmUoKSB7XG4gIHZhciBjYW52YXNJblJlbmRlcmluZyA9IG5ldyBXZWFrU2V0KCk7XG5cbiAgdmFyIEludGVybmFsUmVuZGVyVGFzayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJuYWxSZW5kZXJUYXNrKF9yZWYxOCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gX3JlZjE4LmNhbGxiYWNrLFxuICAgICAgICAgIHBhcmFtcyA9IF9yZWYxOC5wYXJhbXMsXG4gICAgICAgICAgb2JqcyA9IF9yZWYxOC5vYmpzLFxuICAgICAgICAgIGNvbW1vbk9ianMgPSBfcmVmMTguY29tbW9uT2JqcyxcbiAgICAgICAgICBvcGVyYXRvckxpc3QgPSBfcmVmMTgub3BlcmF0b3JMaXN0LFxuICAgICAgICAgIHBhZ2VJbmRleCA9IF9yZWYxOC5wYWdlSW5kZXgsXG4gICAgICAgICAgY2FudmFzRmFjdG9yeSA9IF9yZWYxOC5jYW52YXNGYWN0b3J5LFxuICAgICAgICAgIHdlYkdMQ29udGV4dCA9IF9yZWYxOC53ZWJHTENvbnRleHQsXG4gICAgICAgICAgX3JlZjE4JHVzZVJlcXVlc3RBbmltID0gX3JlZjE4LnVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSxcbiAgICAgICAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBfcmVmMTgkdXNlUmVxdWVzdEFuaW0gPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjE4JHVzZVJlcXVlc3RBbmltLFxuICAgICAgICAgIF9yZWYxOCRwZGZCdWcgPSBfcmVmMTgucGRmQnVnLFxuICAgICAgICAgIHBkZkJ1ZyA9IF9yZWYxOCRwZGZCdWcgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjE4JHBkZkJ1ZztcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludGVybmFsUmVuZGVyVGFzayk7XG5cbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IG51bGw7XG4gICAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IG9wZXJhdG9yTGlzdDtcbiAgICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgICB0aGlzLndlYkdMQ29udGV4dCA9IHdlYkdMQ29udGV4dDtcbiAgICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5ncmFwaGljc1JlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHRydWUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmNhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICB0aGlzLnRhc2sgPSBuZXcgUmVuZGVyVGFzayh0aGlzKTtcbiAgICAgIHRoaXMuX2NvbnRpbnVlQm91bmQgPSB0aGlzLl9jb250aW51ZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQgPSB0aGlzLl9zY2hlZHVsZU5leHQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX25leHRCb3VuZCA9IHRoaXMuX25leHQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2NhbnZhcyA9IHBhcmFtcy5jYW52YXNDb250ZXh0LmNhbnZhcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSW50ZXJuYWxSZW5kZXJUYXNrLCBbe1xuICAgICAga2V5OiBcImNvbXBsZXRlZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhcGFiaWxpdHkucHJvbWlzZVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW5pdGlhbGl6ZUdyYXBoaWNzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZUdyYXBoaWNzKF9yZWYxOSkge1xuICAgICAgICB2YXIgX2dsb2JhbFRoaXMkU3RlcHBlck1hO1xuXG4gICAgICAgIHZhciBfcmVmMTkkdHJhbnNwYXJlbmN5ID0gX3JlZjE5LnRyYW5zcGFyZW5jeSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW5jeSA9IF9yZWYxOSR0cmFuc3BhcmVuY3kgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjE5JHRyYW5zcGFyZW5jeSxcbiAgICAgICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZyA9IF9yZWYxOS5vcHRpb25hbENvbnRlbnRDb25maWc7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgICAgIGlmIChjYW52YXNJblJlbmRlcmluZy5oYXModGhpcy5fY2FudmFzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSB0aGUgc2FtZSBjYW52YXMgZHVyaW5nIG11bHRpcGxlIHJlbmRlcigpIG9wZXJhdGlvbnMuIFwiICsgXCJVc2UgZGlmZmVyZW50IGNhbnZhcyBvciBlbnN1cmUgcHJldmlvdXMgb3BlcmF0aW9ucyB3ZXJlIFwiICsgXCJjYW5jZWxsZWQgb3IgY29tcGxldGVkLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYW52YXNJblJlbmRlcmluZy5hZGQodGhpcy5fY2FudmFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9wZGZCdWcgJiYgKF9nbG9iYWxUaGlzJFN0ZXBwZXJNYSA9IGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXIpICE9PSBudWxsICYmIF9nbG9iYWxUaGlzJFN0ZXBwZXJNYSAhPT0gdm9pZCAwICYmIF9nbG9iYWxUaGlzJFN0ZXBwZXJNYS5lbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5zdGVwcGVyID0gZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlci5jcmVhdGUodGhpcy5fcGFnZUluZGV4KTtcbiAgICAgICAgICB0aGlzLnN0ZXBwZXIuaW5pdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgICAgICAgdGhpcy5zdGVwcGVyLm5leHRCcmVha1BvaW50ID0gdGhpcy5zdGVwcGVyLmdldE5leHRCcmVha1BvaW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3RoaXMkcGFyYW1zID0gdGhpcy5wYXJhbXMsXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0ID0gX3RoaXMkcGFyYW1zLmNhbnZhc0NvbnRleHQsXG4gICAgICAgICAgICB2aWV3cG9ydCA9IF90aGlzJHBhcmFtcy52aWV3cG9ydCxcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IF90aGlzJHBhcmFtcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBpbWFnZUxheWVyID0gX3RoaXMkcGFyYW1zLmltYWdlTGF5ZXIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kID0gX3RoaXMkcGFyYW1zLmJhY2tncm91bmQ7XG4gICAgICAgIHRoaXMuZ2Z4ID0gbmV3IF9jYW52YXMuQ2FudmFzR3JhcGhpY3MoY2FudmFzQ29udGV4dCwgdGhpcy5jb21tb25PYmpzLCB0aGlzLm9ianMsIHRoaXMuY2FudmFzRmFjdG9yeSwgdGhpcy53ZWJHTENvbnRleHQsIGltYWdlTGF5ZXIsIG9wdGlvbmFsQ29udGVudENvbmZpZyk7XG4gICAgICAgIHRoaXMuZ2Z4LmJlZ2luRHJhd2luZyh7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgICAgIHRyYW5zcGFyZW5jeTogdHJhbnNwYXJlbmN5LFxuICAgICAgICAgIGJhY2tncm91bmQ6IGJhY2tncm91bmRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gMDtcbiAgICAgICAgdGhpcy5ncmFwaGljc1JlYWR5ID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2spIHtcbiAgICAgICAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNhbmNlbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIGVycm9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLmdmeCkge1xuICAgICAgICAgIHRoaXMuZ2Z4LmVuZERyYXdpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgICAgICBjYW52YXNJblJlbmRlcmluZ1tcImRlbGV0ZVwiXSh0aGlzLl9jYW52YXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayhlcnJvciB8fCBuZXcgX2Rpc3BsYXlfdXRpbHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKFwiUmVuZGVyaW5nIGNhbmNlbGxlZCwgcGFnZSBcIi5jb25jYXQodGhpcy5fcGFnZUluZGV4ICsgMSksIFwiY2FudmFzXCIpKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib3BlcmF0b3JMaXN0Q2hhbmdlZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZXJhdG9yTGlzdENoYW5nZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaGljc1JlYWR5KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgPSB0aGlzLl9jb250aW51ZUJvdW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0ZXBwZXIpIHtcbiAgICAgICAgICB0aGlzLnN0ZXBwZXIudXBkYXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250aW51ZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfY29udGludWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udGludWUoKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudGFzay5vbkNvbnRpbnVlKSB7XG4gICAgICAgICAgdGhpcy50YXNrLm9uQ29udGludWUodGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NjaGVkdWxlTmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zY2hlZHVsZU5leHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2NoZWR1bGVOZXh0KCkge1xuICAgICAgICB2YXIgX3RoaXMxNiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMxNi5fbmV4dEJvdW5kKClbXCJjYXRjaFwiXShfdGhpczE2LmNhbmNlbC5iaW5kKF90aGlzMTYpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKHRoaXMuX25leHRCb3VuZClbXCJjYXRjaFwiXSh0aGlzLmNhbmNlbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfbmV4dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9uZXh0MiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gdGhpcy5nZnguZXhlY3V0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCwgdGhpcy5vcGVyYXRvckxpc3RJZHgsIHRoaXMuX2NvbnRpbnVlQm91bmQsIHRoaXMuc3RlcHBlcik7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdElkeCA9PT0gdGhpcy5vcGVyYXRvckxpc3QuYXJnc0FycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZnguZW5kRHJhd2luZygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzSW5SZW5kZXJpbmdbXCJkZWxldGVcIl0odGhpcy5fY2FudmFzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9uZXh0KCkge1xuICAgICAgICAgIHJldHVybiBfbmV4dDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfbmV4dDtcbiAgICAgIH0oKVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbnRlcm5hbFJlbmRlclRhc2s7XG4gIH0oKTtcblxuICByZXR1cm4gSW50ZXJuYWxSZW5kZXJUYXNrO1xufSgpO1xuXG52YXIgdmVyc2lvbiA9ICcyLjguMTczJztcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG52YXIgYnVpbGQgPSAnYmM4MzRkNTEwJztcbmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcbnZhciBwdXRCaW5hcnlJbWFnZURhdGEgPSBfY2FudmFzLkNhbnZhc0dyYXBoaWNzLnB1dEJpbmFyeUltYWdlRGF0YTtcbmV4cG9ydHMucHV0QmluYXJ5SW1hZ2VEYXRhID0gcHV0QmluYXJ5SW1hZ2VEYXRhO1xuXG4vKioqLyB9KSxcbi8qIDEzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5Gb250TG9hZGVyID0gZXhwb3J0cy5Gb250RmFjZU9iamVjdCA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193X3BkZmpzX3JlcXVpcmVfXygyKSk7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgQmFzZUZvbnRMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlRm9udExvYWRlcihfcmVmKSB7XG4gICAgdmFyIGRvY0lkID0gX3JlZi5kb2NJZCxcbiAgICAgICAgb25VbnN1cHBvcnRlZEZlYXR1cmUgPSBfcmVmLm9uVW5zdXBwb3J0ZWRGZWF0dXJlLFxuICAgICAgICBfcmVmJG93bmVyRG9jdW1lbnQgPSBfcmVmLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIG93bmVyRG9jdW1lbnQgPSBfcmVmJG93bmVyRG9jdW1lbnQgPT09IHZvaWQgMCA/IGdsb2JhbFRoaXMuZG9jdW1lbnQgOiBfcmVmJG93bmVyRG9jdW1lbnQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUZvbnRMb2FkZXIpO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VGb250TG9hZGVyKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZUZvbnRMb2FkZXIuXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZG9jSWQgPSBkb2NJZDtcbiAgICB0aGlzLl9vblVuc3VwcG9ydGVkRmVhdHVyZSA9IG9uVW5zdXBwb3J0ZWRGZWF0dXJlO1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcyA9IFtdO1xuICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlRm9udExvYWRlciwgW3tcbiAgICBrZXk6IFwiYWRkTmF0aXZlRm9udEZhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLnB1c2gobmF0aXZlRm9udEZhY2UpO1xuXG4gICAgICB0aGlzLl9kb2N1bWVudC5mb250cy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRSdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSkge1xuICAgICAgdmFyIHN0eWxlRWxlbWVudCA9IHRoaXMuc3R5bGVFbGVtZW50O1xuXG4gICAgICBpZiAoIXN0eWxlRWxlbWVudCkge1xuICAgICAgICBzdHlsZUVsZW1lbnQgPSB0aGlzLnN0eWxlRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgc3R5bGVFbGVtZW50LmlkID0gXCJQREZKU19GT05UX1NUWUxFX1RBR19cIi5jb25jYXQodGhpcy5kb2NJZCk7XG5cbiAgICAgICAgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGVTaGVldCA9IHN0eWxlRWxlbWVudC5zaGVldDtcbiAgICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZShydWxlLCBzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5uYXRpdmVGb250RmFjZXMuZm9yRWFjaChmdW5jdGlvbiAobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgICAgX3RoaXMuX2RvY3VtZW50LmZvbnRzW1wiZGVsZXRlXCJdKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5uYXRpdmVGb250RmFjZXMubGVuZ3RoID0gMDtcblxuICAgICAgaWYgKHRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9iaW5kID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShmb250KSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBuYXRpdmVGb250RmFjZSwgcnVsZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIShmb250LmF0dGFjaGVkIHx8IGZvbnQubWlzc2luZ0ZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGZvbnQuYXR0YWNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5hdGl2ZUZvbnRGYWNlID0gZm9udC5jcmVhdGVOYXRpdmVGb250RmFjZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVGb250RmFjZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDc7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVGb250RmFjZS5sb2FkZWQ7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDcpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fb25VbnN1cHBvcnRlZEZlYXR1cmUoe1xuICAgICAgICAgICAgICAgICAgZmVhdHVyZUlkOiBfdXRpbC5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvckZvbnRMb2FkTmF0aXZlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJGYWlsZWQgdG8gbG9hZCBmb250ICdcIi5jb25jYXQobmF0aXZlRm9udEZhY2UuZmFtaWx5LCBcIic6ICdcIikuY29uY2F0KF9jb250ZXh0LnQwLCBcIicuXCIpKTtcbiAgICAgICAgICAgICAgICBmb250LmRpc2FibGVGb250RmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQudDA7XG5cbiAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgcnVsZSA9IGZvbnQuY3JlYXRlRm9udEZhY2VSdWxlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gX3RoaXMyLl9xdWV1ZUxvYWRpbmdDYWxsYmFjayhyZXNvbHZlKTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMyLl9wcmVwYXJlRm9udExvYWRFdmVudChbcnVsZV0sIFtmb250XSwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzcsIDEyXV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBiaW5kKF94KSB7XG4gICAgICAgIHJldHVybiBfYmluZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmluZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfcXVldWVMb2FkaW5nQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfcXVldWVMb2FkaW5nQ2FsbGJhY2tgLlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzJF9kb2N1bWVudDtcblxuICAgICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZFwiLCAhISgoX3RoaXMkX2RvY3VtZW50ID0gdGhpcy5fZG9jdW1lbnQpICE9PSBudWxsICYmIF90aGlzJF9kb2N1bWVudCAhPT0gdm9pZCAwICYmIF90aGlzJF9kb2N1bWVudC5mb250cykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRgLlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvYWRUZXN0Rm9udFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2xvYWRUZXN0Rm9udGAuXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcHJlcGFyZUZvbnRMb2FkRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVGb250TG9hZEV2ZW50KHJ1bGVzLCBmb250c1RvTG9hZCwgcmVxdWVzdCkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX3ByZXBhcmVGb250TG9hZEV2ZW50YC5cIik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VGb250TG9hZGVyO1xufSgpO1xuXG52YXIgRm9udExvYWRlcjtcbmV4cG9ydHMuRm9udExvYWRlciA9IEZvbnRMb2FkZXI7XG57XG4gIGV4cG9ydHMuRm9udExvYWRlciA9IEZvbnRMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlRm9udExvYWRlcikge1xuICAgIF9pbmhlcml0cyhHZW5lcmljRm9udExvYWRlciwgX0Jhc2VGb250TG9hZGVyKTtcblxuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoR2VuZXJpY0ZvbnRMb2FkZXIpO1xuXG4gICAgZnVuY3Rpb24gR2VuZXJpY0ZvbnRMb2FkZXIocGFyYW1zKSB7XG4gICAgICB2YXIgX3RoaXMzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2VuZXJpY0ZvbnRMb2FkZXIpO1xuXG4gICAgICBfdGhpczMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgICAgX3RoaXMzLmxvYWRpbmdDb250ZXh0ID0ge1xuICAgICAgICByZXF1ZXN0czogW10sXG4gICAgICAgIG5leHRSZXF1ZXN0SWQ6IDBcbiAgICAgIH07XG4gICAgICBfdGhpczMubG9hZFRlc3RGb250SWQgPSAwO1xuICAgICAgcmV0dXJuIF90aGlzMztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoR2VuZXJpY0ZvbnRMb2FkZXIsIFt7XG4gICAgICBrZXk6IFwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgc3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtID0gL01vemlsbGFcXC81LjAuKj9ydjooXFxkKykuKj8gR2Vja28vLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgICAgICAgICBpZiAoKG0gPT09IG51bGwgfHwgbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbVsxXSkgPj0gMTQpIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRcIiwgc3VwcG9ydGVkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3F1ZXVlTG9hZGluZ0NhbGxiYWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlUmVxdWVzdCgpIHtcbiAgICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSghcmVxdWVzdC5kb25lLCBcImNvbXBsZXRlUmVxdWVzdCgpIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2UuXCIpO1xuICAgICAgICAgIHJlcXVlc3QuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICB3aGlsZSAoY29udGV4dC5yZXF1ZXN0cy5sZW5ndGggPiAwICYmIGNvbnRleHQucmVxdWVzdHNbMF0uZG9uZSkge1xuICAgICAgICAgICAgdmFyIG90aGVyUmVxdWVzdCA9IGNvbnRleHQucmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQob3RoZXJSZXF1ZXN0LmNhbGxiYWNrLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMubG9hZGluZ0NvbnRleHQ7XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgIGlkOiBcInBkZmpzLWZvbnQtbG9hZGluZy1cIi5jb25jYXQoY29udGV4dC5uZXh0UmVxdWVzdElkKyspLFxuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVJlcXVlc3QsXG4gICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgIH07XG4gICAgICAgIGNvbnRleHQucmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9sb2FkVGVzdEZvbnRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgZ2V0TG9hZFRlc3RGb250ID0gZnVuY3Rpb24gZ2V0TG9hZFRlc3RGb250KCkge1xuICAgICAgICAgIHJldHVybiBhdG9iKFwiVDFSVVR3QUxBSUFBQXdBd1EwWkdJREh0Wmc0QUFBT1lBQUFBZ1VaR1ZFMWxrelp3QUFBRUhBQUFBQnhIUkVWR0FCUUFcIiArIFwiRlFBQUJEZ0FBQUFlVDFNdk1sWU5Zd2tBQUFFZ0FBQUFZR050WVhBQkRRTFVBQUFDTkFBQUFVSm9aV0ZrL3hWRkRRQUFcIiArIFwiQUx3QUFBQTJhR2hsWVFka0Erb0FBQUQwQUFBQUpHaHRkSGdENkFBQUFBQUVXQUFBQUFadFlYaHdBQUpRQUFBQUFSZ0FcIiArIFwiQUFBR2JtRnRaVmptZEg0QUFBR0FBQUFBc1hCdmMzVC9oZ0F6QUFBRGVBQUFBQ0FBQVFBQUFBRUFBTFpSRnNSZkR6ejFcIiArIFwiQUFzRDZBQUFBQURPQk9UTEFBQUFBTTRLSER3QUFBQUFBK2dESVFBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFESVFBQUFGb0RcIiArIFwiNkFBQUFBQUQ2QUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBVUFBQUFnQUFBQVFENkFIMEFBVUFBQUtLQXJ3QUFBQ01cIiArIFwiQW9vQ3ZBQUFBZUFBTVFFQ0FBQUNBQVlKQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFGQm1SV1FBd0FBdUFDNERcIiArIFwiSVA4NEFGb0RJUUFBQUFBQUFRQUFBQUFBQUFBQUFDQUFJQUFCQUFBQURnQ3VBQUVBQUFBQUFBQUFBUUFBQUFFQUFBQUFcIiArIFwiQUFFQUFRQUFBQUVBQUFBQUFBSUFBUUFBQUFFQUFBQUFBQU1BQVFBQUFBRUFBQUFBQUFRQUFRQUFBQUVBQUFBQUFBVUFcIiArIFwiQVFBQUFBRUFBQUFBQUFZQUFRQUFBQU1BQVFRSkFBQUFBZ0FCQUFNQUFRUUpBQUVBQWdBQkFBTUFBUVFKQUFJQUFnQUJcIiArIFwiQUFNQUFRUUpBQU1BQWdBQkFBTUFBUVFKQUFRQUFnQUJBQU1BQVFRSkFBVUFBZ0FCQUFNQUFRUUpBQVlBQWdBQldBQllcIiArIFwiQUFBQUFBQUFBd0FBQUFNQUFBQWNBQUVBQUFBQUFEd0FBd0FCQUFBQUhBQUVBQ0FBQUFBRUFBUUFBUUFBQUM3Ly93QUFcIiArIFwiQUM3Ly8vL1RBQUVBQUFBQUFBQUJCZ0FBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUFBQUFBQUFEL2d3QXlBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQkFBUUVBQUVCQVFKWUFBRUJBU0g0RHdENEd3SEVBdmdjQS9nWEJJd01BWXVMK256NXRRWGtENWozQ0JMbkVRQUNcIiArIFwiQVFFQklWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZQUFBQkFRQUFEd0FDQVFFRUUvdDNcIiArIFwiRG92NmZBSDZmQVQrZlBwOCtud0hEb3NNQ3ZtMUN2bTFEQXo2ZkJRQUFBQUFBQUFCQUFBQUFNbUpiekVBQUFBQXpnVGpcIiArIFwiRlFBQUFBRE9CT1FwQUFFQUFBQUFBQUFBREFBVUFBUUFBQUFCQUFBQUFnQUJBQUFBQUFBQUFBQUQ2QUFBQUFBQUFBPT1cIik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2xvYWRUZXN0Rm9udFwiLCBnZXRMb2FkVGVzdEZvbnQoKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9wcmVwYXJlRm9udExvYWRFdmVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlRm9udExvYWRFdmVudChydWxlcywgZm9udHMsIHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gaW50MzIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDggfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMykgJiAweGZmO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3BsaWNlU3RyaW5nKHMsIG9mZnNldCwgcmVtb3ZlLCBpbnNlcnQpIHtcbiAgICAgICAgICB2YXIgY2h1bmsxID0gcy5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbiAgICAgICAgICB2YXIgY2h1bmsyID0gcy5zdWJzdHJpbmcob2Zmc2V0ICsgcmVtb3ZlKTtcbiAgICAgICAgICByZXR1cm4gY2h1bmsxICsgaW5zZXJ0ICsgY2h1bmsyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGksIGlpO1xuXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgdmFyIGNhbGxlZCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNGb250UmVhZHkobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsZWQrKztcblxuICAgICAgICAgIGlmIChjYWxsZWQgPiAzMCkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LmZvbnQgPSBcIjMwcHggXCIgKyBuYW1lO1xuICAgICAgICAgIGN0eC5maWxsVGV4dChcIi5cIiwgMCwgMjApO1xuICAgICAgICAgIHZhciBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuXG4gICAgICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KGlzRm9udFJlYWR5LmJpbmQobnVsbCwgbmFtZSwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2FkVGVzdEZvbnRJZCA9IFwibHRcIi5jb25jYXQoRGF0ZS5ub3coKSkuY29uY2F0KHRoaXMubG9hZFRlc3RGb250SWQrKyk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fbG9hZFRlc3RGb250O1xuICAgICAgICB2YXIgQ09NTUVOVF9PRkZTRVQgPSA5NzY7XG4gICAgICAgIGRhdGEgPSBzcGxpY2VTdHJpbmcoZGF0YSwgQ09NTUVOVF9PRkZTRVQsIGxvYWRUZXN0Rm9udElkLmxlbmd0aCwgbG9hZFRlc3RGb250SWQpO1xuICAgICAgICB2YXIgQ0ZGX0NIRUNLU1VNX09GRlNFVCA9IDE2O1xuICAgICAgICB2YXIgWFhYWF9WQUxVRSA9IDB4NTg1ODU4NTg7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IGludDMyKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gbG9hZFRlc3RGb250SWQubGVuZ3RoIC0gMzsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgICAgICBjaGVja3N1bSA9IGNoZWNrc3VtIC0gWFhYWF9WQUxVRSArIGludDMyKGxvYWRUZXN0Rm9udElkLCBpKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA8IGxvYWRUZXN0Rm9udElkLmxlbmd0aCkge1xuICAgICAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0gLSBYWFhYX1ZBTFVFICsgaW50MzIobG9hZFRlc3RGb250SWQgKyBcIlhYWFwiLCBpKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQsIDQsICgwLCBfdXRpbC5zdHJpbmczMikoY2hlY2tzdW0pKTtcbiAgICAgICAgdmFyIHVybCA9IFwidXJsKGRhdGE6Zm9udC9vcGVudHlwZTtiYXNlNjQsXCIuY29uY2F0KGJ0b2EoZGF0YSksIFwiKTtcIik7XG4gICAgICAgIHZhciBydWxlID0gXCJAZm9udC1mYWNlIHtmb250LWZhbWlseTpcXFwiXCIuY29uY2F0KGxvYWRUZXN0Rm9udElkLCBcIlxcXCI7c3JjOlwiKS5jb25jYXQodXJsLCBcIn1cIik7XG4gICAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgICAgdmFyIG5hbWVzID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBmb250cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgbmFtZXMucHVzaChmb250c1tpXS5sb2FkZWROYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWVzLnB1c2gobG9hZFRlc3RGb250SWQpO1xuXG4gICAgICAgIHZhciBkaXYgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgIGRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9IFwiMTBweFwiO1xuICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIGRpdi5zdHlsZS50b3AgPSBkaXYuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG5cbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgdmFyIHNwYW4gPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblxuICAgICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIkhpXCI7XG4gICAgICAgICAgc3Bhbi5zdHlsZS5mb250RmFtaWx5ID0gbmFtZXNbaV07XG4gICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuXG4gICAgICAgIGlzRm9udFJlYWR5KGxvYWRUZXN0Rm9udElkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM0Ll9kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG5cbiAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBHZW5lcmljRm9udExvYWRlcjtcbiAgfShCYXNlRm9udExvYWRlcik7XG59XG5cbnZhciBGb250RmFjZU9iamVjdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZvbnRGYWNlT2JqZWN0KHRyYW5zbGF0ZWREYXRhLCBfcmVmMikge1xuICAgIHZhciBfcmVmMiRpc0V2YWxTdXBwb3J0ZWQgPSBfcmVmMi5pc0V2YWxTdXBwb3J0ZWQsXG4gICAgICAgIGlzRXZhbFN1cHBvcnRlZCA9IF9yZWYyJGlzRXZhbFN1cHBvcnRlZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYyJGlzRXZhbFN1cHBvcnRlZCxcbiAgICAgICAgX3JlZjIkZGlzYWJsZUZvbnRGYWNlID0gX3JlZjIuZGlzYWJsZUZvbnRGYWNlLFxuICAgICAgICBkaXNhYmxlRm9udEZhY2UgPSBfcmVmMiRkaXNhYmxlRm9udEZhY2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkZGlzYWJsZUZvbnRGYWNlLFxuICAgICAgICBfcmVmMiRpZ25vcmVFcnJvcnMgPSBfcmVmMi5pZ25vcmVFcnJvcnMsXG4gICAgICAgIGlnbm9yZUVycm9ycyA9IF9yZWYyJGlnbm9yZUVycm9ycyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRpZ25vcmVFcnJvcnMsXG4gICAgICAgIG9uVW5zdXBwb3J0ZWRGZWF0dXJlID0gX3JlZjIub25VbnN1cHBvcnRlZEZlYXR1cmUsXG4gICAgICAgIF9yZWYyJGZvbnRSZWdpc3RyeSA9IF9yZWYyLmZvbnRSZWdpc3RyeSxcbiAgICAgICAgZm9udFJlZ2lzdHJ5ID0gX3JlZjIkZm9udFJlZ2lzdHJ5ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjIkZm9udFJlZ2lzdHJ5O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvbnRGYWNlT2JqZWN0KTtcblxuICAgIHRoaXMuY29tcGlsZWRHbHlwaHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgZm9yICh2YXIgaSBpbiB0cmFuc2xhdGVkRGF0YSkge1xuICAgICAgdGhpc1tpXSA9IHRyYW5zbGF0ZWREYXRhW2ldO1xuICAgIH1cblxuICAgIHRoaXMuaXNFdmFsU3VwcG9ydGVkID0gaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgICB0aGlzLmRpc2FibGVGb250RmFjZSA9IGRpc2FibGVGb250RmFjZSA9PT0gdHJ1ZTtcbiAgICB0aGlzLmlnbm9yZUVycm9ycyA9IGlnbm9yZUVycm9ycyA9PT0gdHJ1ZTtcbiAgICB0aGlzLl9vblVuc3VwcG9ydGVkRmVhdHVyZSA9IG9uVW5zdXBwb3J0ZWRGZWF0dXJlO1xuICAgIHRoaXMuZm9udFJlZ2lzdHJ5ID0gZm9udFJlZ2lzdHJ5O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZvbnRGYWNlT2JqZWN0LCBbe1xuICAgIGtleTogXCJjcmVhdGVOYXRpdmVGb250RmFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVOYXRpdmVGb250RmFjZSgpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGlzYWJsZUZvbnRGYWNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmF0aXZlRm9udEZhY2UgPSBuZXcgRm9udEZhY2UodGhpcy5sb2FkZWROYW1lLCB0aGlzLmRhdGEsIHt9KTtcblxuICAgICAgaWYgKHRoaXMuZm9udFJlZ2lzdHJ5KSB7XG4gICAgICAgIHRoaXMuZm9udFJlZ2lzdHJ5LnJlZ2lzdGVyRm9udCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZUZvbnRGYWNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVGb250RmFjZVJ1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRm9udEZhY2VSdWxlKCkge1xuICAgICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gKDAsIF91dGlsLmJ5dGVzVG9TdHJpbmcpKG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSkpO1xuICAgICAgdmFyIHVybCA9IFwidXJsKGRhdGE6XCIuY29uY2F0KHRoaXMubWltZXR5cGUsIFwiO2Jhc2U2NCxcIikuY29uY2F0KGJ0b2EoZGF0YSksIFwiKTtcIik7XG4gICAgICB2YXIgcnVsZSA9IFwiQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XFxcIlwiLmNvbmNhdCh0aGlzLmxvYWRlZE5hbWUsIFwiXFxcIjtzcmM6XCIpLmNvbmNhdCh1cmwsIFwifVwiKTtcblxuICAgICAgaWYgKHRoaXMuZm9udFJlZ2lzdHJ5KSB7XG4gICAgICAgIHRoaXMuZm9udFJlZ2lzdHJ5LnJlZ2lzdGVyRm9udCh0aGlzLCB1cmwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGF0aEdlbmVyYXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXRoR2VuZXJhdG9yKG9ianMsIGNoYXJhY3Rlcikge1xuICAgICAgaWYgKHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl07XG4gICAgICB9XG5cbiAgICAgIHZhciBjbWRzLCBjdXJyZW50O1xuXG4gICAgICB0cnkge1xuICAgICAgICBjbWRzID0gb2Jqcy5nZXQodGhpcy5sb2FkZWROYW1lICsgXCJfcGF0aF9cIiArIGNoYXJhY3Rlcik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBpZiAoIXRoaXMuaWdub3JlRXJyb3JzKSB7XG4gICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vblVuc3VwcG9ydGVkRmVhdHVyZSh7XG4gICAgICAgICAgZmVhdHVyZUlkOiBfdXRpbC5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvckZvbnRHZXRQYXRoXG4gICAgICAgIH0pO1xuXG4gICAgICAgICgwLCBfdXRpbC53YXJuKShcImdldFBhdGhHZW5lcmF0b3IgLSBpZ25vcmluZyBjaGFyYWN0ZXI6IFxcXCJcIi5jb25jYXQoZXgsIFwiXFxcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNFdmFsU3VwcG9ydGVkICYmIF91dGlsLklzRXZhbFN1cHBvcnRlZENhY2hlZC52YWx1ZSkge1xuICAgICAgICB2YXIgYXJncyxcbiAgICAgICAgICAgIGpzID0gXCJcIjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjbWRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBjdXJyZW50ID0gY21kc1tpXTtcblxuICAgICAgICAgIGlmIChjdXJyZW50LmFyZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXJncyA9IGN1cnJlbnQuYXJncy5qb2luKFwiLFwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncyA9IFwiXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAganMgKz0gXCJjLlwiICsgY3VycmVudC5jbWQgKyBcIihcIiArIGFyZ3MgKyBcIik7XFxuXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gbmV3IEZ1bmN0aW9uKFwiY1wiLCBcInNpemVcIiwganMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gZnVuY3Rpb24gKGMsIHNpemUpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfaWkgPSBjbWRzLmxlbmd0aDsgX2kgPCBfaWk7IF9pKyspIHtcbiAgICAgICAgICBjdXJyZW50ID0gY21kc1tfaV07XG5cbiAgICAgICAgICBpZiAoY3VycmVudC5jbWQgPT09IFwic2NhbGVcIikge1xuICAgICAgICAgICAgY3VycmVudC5hcmdzID0gW3NpemUsIC1zaXplXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjW2N1cnJlbnQuY21kXS5hcHBseShjLCBjdXJyZW50LmFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb250RmFjZU9iamVjdDtcbn0oKTtcblxuZXhwb3J0cy5Gb250RmFjZU9iamVjdCA9IEZvbnRGYWNlT2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDEzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5Ob2RlQ01hcFJlYWRlckZhY3RvcnkgPSBleHBvcnRzLk5vZGVDYW52YXNGYWN0b3J5ID0gdm9pZCAwO1xuXG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2lzX25vZGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgTm9kZUNhbnZhc0ZhY3RvcnkgPSBmdW5jdGlvbiBOb2RlQ2FudmFzRmFjdG9yeSgpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVDYW52YXNGYWN0b3J5KTtcblxuICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiTm90IGltcGxlbWVudGVkOiBOb2RlQ2FudmFzRmFjdG9yeVwiKTtcbn07XG5cbmV4cG9ydHMuTm9kZUNhbnZhc0ZhY3RvcnkgPSBOb2RlQ2FudmFzRmFjdG9yeTtcblxudmFyIE5vZGVDTWFwUmVhZGVyRmFjdG9yeSA9IGZ1bmN0aW9uIE5vZGVDTWFwUmVhZGVyRmFjdG9yeSgpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVDTWFwUmVhZGVyRmFjdG9yeSk7XG5cbiAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIk5vdCBpbXBsZW1lbnRlZDogTm9kZUNNYXBSZWFkZXJGYWN0b3J5XCIpO1xufTtcblxuZXhwb3J0cy5Ob2RlQ01hcFJlYWRlckZhY3RvcnkgPSBOb2RlQ01hcFJlYWRlckZhY3Rvcnk7XG5cbmlmIChfaXNfbm9kZS5pc05vZGVKUykge1xuICBleHBvcnRzLk5vZGVDYW52YXNGYWN0b3J5ID0gTm9kZUNhbnZhc0ZhY3RvcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQ2FudmFzRmFjdG9yeSkge1xuICAgIF9pbmhlcml0cyhOb2RlQ2FudmFzRmFjdG9yeSwgX0Jhc2VDYW52YXNGYWN0b3J5KTtcblxuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTm9kZUNhbnZhc0ZhY3RvcnkpO1xuXG4gICAgZnVuY3Rpb24gTm9kZUNhbnZhc0ZhY3RvcnkoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUNhbnZhc0ZhY3RvcnkpO1xuXG4gICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE5vZGVDYW52YXNGYWN0b3J5LCBbe1xuICAgICAga2V5OiBcImNyZWF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBDYW52YXMgPSByZXF1aXJlKFwiY2FudmFzXCIpO1xuXG4gICAgICAgIHZhciBjYW52YXMgPSBDYW52YXMuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbnZhczogY2FudmFzLFxuICAgICAgICAgIGNvbnRleHQ6IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIilcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTm9kZUNhbnZhc0ZhY3Rvcnk7XG4gIH0oX2Rpc3BsYXlfdXRpbHMuQmFzZUNhbnZhc0ZhY3RvcnkpO1xuXG4gIGV4cG9ydHMuTm9kZUNNYXBSZWFkZXJGYWN0b3J5ID0gTm9kZUNNYXBSZWFkZXJGYWN0b3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUNNYXBSZWFkZXJGYWN0b3IpIHtcbiAgICBfaW5oZXJpdHMoTm9kZUNNYXBSZWFkZXJGYWN0b3J5LCBfQmFzZUNNYXBSZWFkZXJGYWN0b3IpO1xuXG4gICAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoTm9kZUNNYXBSZWFkZXJGYWN0b3J5KTtcblxuICAgIGZ1bmN0aW9uIE5vZGVDTWFwUmVhZGVyRmFjdG9yeSgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlQ01hcFJlYWRlckZhY3RvcnkpO1xuXG4gICAgICByZXR1cm4gX3N1cGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhOb2RlQ01hcFJlYWRlckZhY3RvcnksIFt7XG4gICAgICBrZXk6IFwiX2ZldGNoRGF0YVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mZXRjaERhdGEodXJsLCBjb21wcmVzc2lvblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5cbiAgICAgICAgICBmcy5yZWFkRmlsZSh1cmwsIGZ1bmN0aW9uIChlcnJvciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgY01hcERhdGE6IG5ldyBVaW50OEFycmF5KGRhdGEpLFxuICAgICAgICAgICAgICBjb21wcmVzc2lvblR5cGU6IGNvbXByZXNzaW9uVHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBOb2RlQ01hcFJlYWRlckZhY3Rvcnk7XG4gIH0oX2Rpc3BsYXlfdXRpbHMuQmFzZUNNYXBSZWFkZXJGYWN0b3J5KTtcbn1cblxuLyoqKi8gfSksXG4vKiAxMzggKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkFubm90YXRpb25TdG9yYWdlID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBBbm5vdGF0aW9uU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbm5vdGF0aW9uU3RvcmFnZSk7XG5cbiAgICB0aGlzLl9zdG9yYWdlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX21vZGlmaWVkID0gZmFsc2U7XG4gICAgdGhpcy5vblNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQW5ub3RhdGlvblN0b3JhZ2UsIFt7XG4gICAga2V5OiBcImdldE9yQ3JlYXRlVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JDcmVhdGVWYWx1ZShrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX3N0b3JhZ2UuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0b3JhZ2Uuc2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcblxuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3N0b3JhZ2UuZ2V0KGtleSk7XG5cbiAgICAgIHZhciBtb2RpZmllZCA9IGZhbHNlO1xuXG4gICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGVudHJpZXMgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7IF9pIDwgX09iamVjdCRlbnRyaWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciBfT2JqZWN0JGVudHJpZXMkX2kgPSBfc2xpY2VkVG9BcnJheShfT2JqZWN0JGVudHJpZXNbX2ldLCAyKSxcbiAgICAgICAgICAgICAgZW50cnkgPSBfT2JqZWN0JGVudHJpZXMkX2lbMF0sXG4gICAgICAgICAgICAgIHZhbCA9IF9PYmplY3QkZW50cmllcyRfaVsxXTtcblxuICAgICAgICAgIGlmIChvYmpbZW50cnldICE9PSB2YWwpIHtcbiAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9ialtlbnRyeV0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdG9yYWdlLnNldChrZXksIHZhbHVlKTtcblxuICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICB0aGlzLl9zZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsKCkge1xuICAgICAgaWYgKHRoaXMuX3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgwLCBfdXRpbC5vYmplY3RGcm9tRW50cmllcykodGhpcy5fc3RvcmFnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRNb2RpZmllZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0TW9kaWZpZWQoKSB7XG4gICAgICBpZiAoIXRoaXMuX21vZGlmaWVkKSB7XG4gICAgICAgIHRoaXMuX21vZGlmaWVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub25TZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5vblNldE1vZGlmaWVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRNb2RpZmllZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldE1vZGlmaWVkKCkge1xuICAgICAgaWYgKHRoaXMuX21vZGlmaWVkKSB7XG4gICAgICAgIHRoaXMuX21vZGlmaWVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uUmVzZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhpcy5vblJlc2V0TW9kaWZpZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbm5vdGF0aW9uU3RvcmFnZTtcbn0oKTtcblxuZXhwb3J0cy5Bbm5vdGF0aW9uU3RvcmFnZSA9IEFubm90YXRpb25TdG9yYWdlO1xuXG4vKioqLyB9KSxcbi8qIDEzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuYXBpQ29tcGF0aWJpbGl0eVBhcmFtcyA9IHZvaWQgMDtcblxudmFyIF9pc19ub2RlID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcblxudmFyIGNvbXBhdGliaWxpdHlQYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xue1xuICAoZnVuY3Rpb24gY2hlY2tGb250RmFjZSgpIHtcbiAgICBpZiAoX2lzX25vZGUuaXNOb2RlSlMpIHtcbiAgICAgIGNvbXBhdGliaWxpdHlQYXJhbXMuZGlzYWJsZUZvbnRGYWNlID0gdHJ1ZTtcbiAgICB9XG4gIH0pKCk7XG59XG52YXIgYXBpQ29tcGF0aWJpbGl0eVBhcmFtcyA9IE9iamVjdC5mcmVlemUoY29tcGF0aWJpbGl0eVBhcmFtcyk7XG5leHBvcnRzLmFwaUNvbXBhdGliaWxpdHlQYXJhbXMgPSBhcGlDb21wYXRpYmlsaXR5UGFyYW1zO1xuXG4vKioqLyB9KSxcbi8qIDE0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQ2FudmFzR3JhcGhpY3MgPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG5cbnZhciBfcGF0dGVybl9oZWxwZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0MSk7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIE1JTl9GT05UX1NJWkUgPSAxNjtcbnZhciBNQVhfRk9OVF9TSVpFID0gMTAwO1xudmFyIE1BWF9HUk9VUF9TSVpFID0gNDA5NjtcbnZhciBDT01QSUxFX1RZUEUzX0dMWVBIUyA9IGZhbHNlO1xudmFyIE1BWF9TSVpFX1RPX0NPTVBJTEUgPSAxMDAwO1xudmFyIEZVTExfQ0hVTktfSEVJR0hUID0gMTY7XG5cbmZ1bmN0aW9uIGFkZENvbnRleHRDdXJyZW50VHJhbnNmb3JtKGN0eCkge1xuICBpZiAoIWN0eC5tb3pDdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgY3R4Ll9vcmlnaW5hbFNhdmUgPSBjdHguc2F2ZTtcbiAgICBjdHguX29yaWdpbmFsUmVzdG9yZSA9IGN0eC5yZXN0b3JlO1xuICAgIGN0eC5fb3JpZ2luYWxSb3RhdGUgPSBjdHgucm90YXRlO1xuICAgIGN0eC5fb3JpZ2luYWxTY2FsZSA9IGN0eC5zY2FsZTtcbiAgICBjdHguX29yaWdpbmFsVHJhbnNsYXRlID0gY3R4LnRyYW5zbGF0ZTtcbiAgICBjdHguX29yaWdpbmFsVHJhbnNmb3JtID0gY3R4LnRyYW5zZm9ybTtcbiAgICBjdHguX29yaWdpbmFsU2V0VHJhbnNmb3JtID0gY3R4LnNldFRyYW5zZm9ybTtcbiAgICBjdHguX3RyYW5zZm9ybU1hdHJpeCA9IGN0eC5fdHJhbnNmb3JtTWF0cml4IHx8IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICBjdHguX3RyYW5zZm9ybVN0YWNrID0gW107XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgXCJtb3pDdXJyZW50VHJhbnNmb3JtXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybU1hdHJpeDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBcIm1vekN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5fdHJhbnNmb3JtTWF0cml4O1xuICAgICAgICB2YXIgYSA9IG1bMF0sXG4gICAgICAgICAgICBiID0gbVsxXSxcbiAgICAgICAgICAgIGMgPSBtWzJdLFxuICAgICAgICAgICAgZCA9IG1bM10sXG4gICAgICAgICAgICBlID0gbVs0XSxcbiAgICAgICAgICAgIGYgPSBtWzVdO1xuICAgICAgICB2YXIgYWRfYmMgPSBhICogZCAtIGIgKiBjO1xuICAgICAgICB2YXIgYmNfYWQgPSBiICogYyAtIGEgKiBkO1xuICAgICAgICByZXR1cm4gW2QgLyBhZF9iYywgYiAvIGJjX2FkLCBjIC8gYmNfYWQsIGEgLyBhZF9iYywgKGQgKiBlIC0gYyAqIGYpIC8gYmNfYWQsIChiICogZSAtIGEgKiBmKSAvIGFkX2JjXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGN0eC5zYXZlID0gZnVuY3Rpb24gY3R4U2F2ZSgpIHtcbiAgICAgIHZhciBvbGQgPSB0aGlzLl90cmFuc2Zvcm1NYXRyaXg7XG5cbiAgICAgIHRoaXMuX3RyYW5zZm9ybVN0YWNrLnB1c2gob2xkKTtcblxuICAgICAgdGhpcy5fdHJhbnNmb3JtTWF0cml4ID0gb2xkLnNsaWNlKDAsIDYpO1xuXG4gICAgICB0aGlzLl9vcmlnaW5hbFNhdmUoKTtcbiAgICB9O1xuXG4gICAgY3R4LnJlc3RvcmUgPSBmdW5jdGlvbiBjdHhSZXN0b3JlKCkge1xuICAgICAgdmFyIHByZXYgPSB0aGlzLl90cmFuc2Zvcm1TdGFjay5wb3AoKTtcblxuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtTWF0cml4ID0gcHJldjtcblxuICAgICAgICB0aGlzLl9vcmlnaW5hbFJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY3R4LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIGN0eFRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgICB2YXIgbSA9IHRoaXMuX3RyYW5zZm9ybU1hdHJpeDtcbiAgICAgIG1bNF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICAgIG1bNV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcblxuICAgICAgdGhpcy5fb3JpZ2luYWxUcmFuc2xhdGUoeCwgeSk7XG4gICAgfTtcblxuICAgIGN0eC5zY2FsZSA9IGZ1bmN0aW9uIGN0eFNjYWxlKHgsIHkpIHtcbiAgICAgIHZhciBtID0gdGhpcy5fdHJhbnNmb3JtTWF0cml4O1xuICAgICAgbVswXSA9IG1bMF0gKiB4O1xuICAgICAgbVsxXSA9IG1bMV0gKiB4O1xuICAgICAgbVsyXSA9IG1bMl0gKiB5O1xuICAgICAgbVszXSA9IG1bM10gKiB5O1xuXG4gICAgICB0aGlzLl9vcmlnaW5hbFNjYWxlKHgsIHkpO1xuICAgIH07XG5cbiAgICBjdHgudHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIHZhciBtID0gdGhpcy5fdHJhbnNmb3JtTWF0cml4O1xuICAgICAgdGhpcy5fdHJhbnNmb3JtTWF0cml4ID0gW21bMF0gKiBhICsgbVsyXSAqIGIsIG1bMV0gKiBhICsgbVszXSAqIGIsIG1bMF0gKiBjICsgbVsyXSAqIGQsIG1bMV0gKiBjICsgbVszXSAqIGQsIG1bMF0gKiBlICsgbVsyXSAqIGYgKyBtWzRdLCBtWzFdICogZSArIG1bM10gKiBmICsgbVs1XV07XG5cbiAgICAgIGN0eC5fb3JpZ2luYWxUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgfTtcblxuICAgIGN0eC5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBjdHhTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtTWF0cml4ID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuXG4gICAgICBjdHguX29yaWdpbmFsU2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIH07XG5cbiAgICBjdHgucm90YXRlID0gZnVuY3Rpb24gY3R4Um90YXRlKGFuZ2xlKSB7XG4gICAgICB2YXIgY29zVmFsdWUgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgc2luVmFsdWUgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB2YXIgbSA9IHRoaXMuX3RyYW5zZm9ybU1hdHJpeDtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybU1hdHJpeCA9IFttWzBdICogY29zVmFsdWUgKyBtWzJdICogc2luVmFsdWUsIG1bMV0gKiBjb3NWYWx1ZSArIG1bM10gKiBzaW5WYWx1ZSwgbVswXSAqIC1zaW5WYWx1ZSArIG1bMl0gKiBjb3NWYWx1ZSwgbVsxXSAqIC1zaW5WYWx1ZSArIG1bM10gKiBjb3NWYWx1ZSwgbVs0XSwgbVs1XV07XG5cbiAgICAgIHRoaXMuX29yaWdpbmFsUm90YXRlKGFuZ2xlKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBDYWNoZWRDYW52YXNlcyA9IGZ1bmN0aW9uIENhY2hlZENhbnZhc2VzQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gQ2FjaGVkQ2FudmFzZXMoY2FudmFzRmFjdG9yeSkge1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBDYWNoZWRDYW52YXNlcy5wcm90b3R5cGUgPSB7XG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbiBDYWNoZWRDYW52YXNlc19nZXRDYW52YXMoaWQsIHdpZHRoLCBoZWlnaHQsIHRyYWNrVHJhbnNmb3JtKSB7XG4gICAgICB2YXIgY2FudmFzRW50cnk7XG5cbiAgICAgIGlmICh0aGlzLmNhY2hlW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5yZXNldChjYW52YXNFbnRyeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNhbnZhc0VudHJ5LmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmNhY2hlW2lkXSA9IGNhbnZhc0VudHJ5O1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2tUcmFuc2Zvcm0pIHtcbiAgICAgICAgYWRkQ29udGV4dEN1cnJlbnRUcmFuc2Zvcm0oY2FudmFzRW50cnkuY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYW52YXNFbnRyeTtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgdmFyIGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5kZXN0cm95KGNhbnZhc0VudHJ5KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIENhY2hlZENhbnZhc2VzO1xufSgpO1xuXG5mdW5jdGlvbiBjb21waWxlVHlwZTNHbHlwaChpbWdEYXRhKSB7XG4gIHZhciBQT0lOVF9UT19QUk9DRVNTX0xJTUlUID0gMTAwMDtcbiAgdmFyIHdpZHRoID0gaW1nRGF0YS53aWR0aCxcbiAgICAgIGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgICAgd2lkdGgxID0gd2lkdGggKyAxO1xuICB2YXIgaSwgaWksIGosIGowO1xuICB2YXIgcG9pbnRzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgxICogKGhlaWdodCArIDEpKTtcbiAgdmFyIFBPSU5UX1RZUEVTID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDIsIDQsIDAsIDEsIDAsIDUsIDQsIDgsIDEwLCAwLCA4LCAwLCAyLCAxLCAwXSk7XG4gIHZhciBsaW5lU2l6ZSA9IHdpZHRoICsgNyAmIH43LFxuICAgICAgZGF0YTAgPSBpbWdEYXRhLmRhdGE7XG4gIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobGluZVNpemUgKiBoZWlnaHQpO1xuICB2YXIgcG9zID0gMDtcblxuICBmb3IgKGkgPSAwLCBpaSA9IGRhdGEwLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICB2YXIgZWxlbSA9IGRhdGEwW2ldO1xuICAgIHZhciBtYXNrID0gMTI4O1xuXG4gICAgd2hpbGUgKG1hc2sgPiAwKSB7XG4gICAgICBkYXRhW3BvcysrXSA9IGVsZW0gJiBtYXNrID8gMCA6IDI1NTtcbiAgICAgIG1hc2sgPj49IDE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvdW50ID0gMDtcbiAgcG9zID0gMDtcblxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzWzBdID0gMTtcbiAgICArK2NvdW50O1xuICB9XG5cbiAgZm9yIChqID0gMTsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICBpZiAoZGF0YVtwb3NdICE9PSBkYXRhW3BvcyArIDFdKSB7XG4gICAgICBwb2ludHNbal0gPSBkYXRhW3Bvc10gPyAyIDogMTtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2pdID0gMjtcbiAgICArK2NvdW50O1xuICB9XG5cbiAgZm9yIChpID0gMTsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgcG9zID0gaSAqIGxpbmVTaXplO1xuICAgIGowID0gaSAqIHdpZHRoMTtcblxuICAgIGlmIChkYXRhW3BvcyAtIGxpbmVTaXplXSAhPT0gZGF0YVtwb3NdKSB7XG4gICAgICBwb2ludHNbajBdID0gZGF0YVtwb3NdID8gMSA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cblxuICAgIHZhciBzdW0gPSAoZGF0YVtwb3NdID8gNCA6IDApICsgKGRhdGFbcG9zIC0gbGluZVNpemVdID8gOCA6IDApO1xuXG4gICAgZm9yIChqID0gMTsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgIHN1bSA9IChzdW0gPj4gMikgKyAoZGF0YVtwb3MgKyAxXSA/IDQgOiAwKSArIChkYXRhW3BvcyAtIGxpbmVTaXplICsgMV0gPyA4IDogMCk7XG5cbiAgICAgIGlmIChQT0lOVF9UWVBFU1tzdW1dKSB7XG4gICAgICAgIHBvaW50c1tqMCArIGpdID0gUE9JTlRfVFlQRVNbc3VtXTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgaWYgKGRhdGFbcG9zIC0gbGluZVNpemVdICE9PSBkYXRhW3Bvc10pIHtcbiAgICAgIHBvaW50c1tqMCArIGpdID0gZGF0YVtwb3NdID8gMiA6IDQ7XG4gICAgICArK2NvdW50O1xuICAgIH1cblxuICAgIGlmIChjb3VudCA+IFBPSU5UX1RPX1BST0NFU1NfTElNSVQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHBvcyA9IGxpbmVTaXplICogKGhlaWdodCAtIDEpO1xuICBqMCA9IGkgKiB3aWR0aDE7XG5cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqMF0gPSA4O1xuICAgICsrY291bnQ7XG4gIH1cblxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqMCArIGpdID0gZGF0YVtwb3NdID8gNCA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqMCArIGpdID0gNDtcbiAgICArK2NvdW50O1xuICB9XG5cbiAgaWYgKGNvdW50ID4gUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHN0ZXBzID0gbmV3IEludDMyQXJyYXkoWzAsIHdpZHRoMSwgLTEsIDAsIC13aWR0aDEsIDAsIDAsIDAsIDFdKTtcbiAgdmFyIG91dGxpbmVzID0gW107XG5cbiAgZm9yIChpID0gMDsgY291bnQgJiYgaSA8PSBoZWlnaHQ7IGkrKykge1xuICAgIHZhciBwID0gaSAqIHdpZHRoMTtcbiAgICB2YXIgZW5kID0gcCArIHdpZHRoO1xuXG4gICAgd2hpbGUgKHAgPCBlbmQgJiYgIXBvaW50c1twXSkge1xuICAgICAgcCsrO1xuICAgIH1cblxuICAgIGlmIChwID09PSBlbmQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjb29yZHMgPSBbcCAlIHdpZHRoMSwgaV07XG4gICAgdmFyIHAwID0gcDtcbiAgICB2YXIgdHlwZSA9IHBvaW50c1twXTtcblxuICAgIGRvIHtcbiAgICAgIHZhciBzdGVwID0gc3RlcHNbdHlwZV07XG5cbiAgICAgIGRvIHtcbiAgICAgICAgcCArPSBzdGVwO1xuICAgICAgfSB3aGlsZSAoIXBvaW50c1twXSk7XG5cbiAgICAgIHZhciBwcCA9IHBvaW50c1twXTtcblxuICAgICAgaWYgKHBwICE9PSA1ICYmIHBwICE9PSAxMCkge1xuICAgICAgICB0eXBlID0gcHA7XG4gICAgICAgIHBvaW50c1twXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gcHAgJiAweDMzICogdHlwZSA+PiA0O1xuICAgICAgICBwb2ludHNbcF0gJj0gdHlwZSA+PiAyIHwgdHlwZSA8PCAyO1xuICAgICAgfVxuXG4gICAgICBjb29yZHMucHVzaChwICUgd2lkdGgxKTtcbiAgICAgIGNvb3Jkcy5wdXNoKHAgLyB3aWR0aDEgfCAwKTtcblxuICAgICAgaWYgKCFwb2ludHNbcF0pIHtcbiAgICAgICAgLS1jb3VudDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChwMCAhPT0gcCk7XG5cbiAgICBvdXRsaW5lcy5wdXNoKGNvb3Jkcyk7XG4gICAgLS1pO1xuICB9XG5cbiAgdmFyIGRyYXdPdXRsaW5lID0gZnVuY3Rpb24gZHJhd091dGxpbmUoYykge1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgYy50cmFuc2xhdGUoMCwgLWhlaWdodCk7XG4gICAgYy5iZWdpblBhdGgoKTtcblxuICAgIGZvciAodmFyIGsgPSAwLCBrayA9IG91dGxpbmVzLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgIHZhciBvID0gb3V0bGluZXNba107XG4gICAgICBjLm1vdmVUbyhvWzBdLCBvWzFdKTtcblxuICAgICAgZm9yICh2YXIgbCA9IDIsIGxsID0gby5sZW5ndGg7IGwgPCBsbDsgbCArPSAyKSB7XG4gICAgICAgIGMubGluZVRvKG9bbF0sIG9bbCArIDFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjLmZpbGwoKTtcbiAgICBjLmJlZ2luUGF0aCgpO1xuICAgIGMucmVzdG9yZSgpO1xuICB9O1xuXG4gIHJldHVybiBkcmF3T3V0bGluZTtcbn1cblxudmFyIENhbnZhc0V4dHJhU3RhdGUgPSBmdW5jdGlvbiBDYW52YXNFeHRyYVN0YXRlQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gQ2FudmFzRXh0cmFTdGF0ZSgpIHtcbiAgICB0aGlzLmFscGhhSXNTaGFwZSA9IGZhbHNlO1xuICAgIHRoaXMuZm9udFNpemUgPSAwO1xuICAgIHRoaXMuZm9udFNpemVTY2FsZSA9IDE7XG4gICAgdGhpcy50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICB0aGlzLmZvbnRNYXRyaXggPSBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLmxlYWRpbmcgPSAwO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLmxpbmVYID0gMDtcbiAgICB0aGlzLmxpbmVZID0gMDtcbiAgICB0aGlzLmNoYXJTcGFjaW5nID0gMDtcbiAgICB0aGlzLndvcmRTcGFjaW5nID0gMDtcbiAgICB0aGlzLnRleHRIU2NhbGUgPSAxO1xuICAgIHRoaXMudGV4dFJlbmRlcmluZ01vZGUgPSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMO1xuICAgIHRoaXMudGV4dFJpc2UgPSAwO1xuICAgIHRoaXMuZmlsbENvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgdGhpcy5zdHJva2VDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgIHRoaXMucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG4gICAgdGhpcy5zdHJva2VBbHBoYSA9IDE7XG4gICAgdGhpcy5saW5lV2lkdGggPSAxO1xuICAgIHRoaXMuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIHRoaXMucmVzdW1lU01hc2tDdHggPSBudWxsO1xuICAgIHRoaXMudHJhbnNmZXJNYXBzID0gbnVsbDtcbiAgfVxuXG4gIENhbnZhc0V4dHJhU3RhdGUucHJvdG90eXBlID0ge1xuICAgIGNsb25lOiBmdW5jdGlvbiBDYW52YXNFeHRyYVN0YXRlX2Nsb25lKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfSxcbiAgICBzZXRDdXJyZW50UG9pbnQ6IGZ1bmN0aW9uIENhbnZhc0V4dHJhU3RhdGVfc2V0Q3VycmVudFBvaW50KHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIENhbnZhc0V4dHJhU3RhdGU7XG59KCk7XG5cbnZhciBDYW52YXNHcmFwaGljcyA9IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzQ2xvc3VyZSgpIHtcbiAgdmFyIEVYRUNVVElPTl9USU1FID0gMTU7XG4gIHZhciBFWEVDVVRJT05fU1RFUFMgPSAxMDtcblxuICBmdW5jdGlvbiBDYW52YXNHcmFwaGljcyhjYW52YXNDdHgsIGNvbW1vbk9ianMsIG9ianMsIGNhbnZhc0ZhY3RvcnksIHdlYkdMQ29udGV4dCwgaW1hZ2VMYXllciwgb3B0aW9uYWxDb250ZW50Q29uZmlnKSB7XG4gICAgdGhpcy5jdHggPSBjYW52YXNDdHg7XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUoKTtcbiAgICB0aGlzLnN0YXRlU3RhY2sgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLnJlcyA9IG51bGw7XG4gICAgdGhpcy54b2JqcyA9IG51bGw7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy53ZWJHTENvbnRleHQgPSB3ZWJHTENvbnRleHQ7XG4gICAgdGhpcy5pbWFnZUxheWVyID0gaW1hZ2VMYXllcjtcbiAgICB0aGlzLmdyb3VwU3RhY2sgPSBbXTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCA9IDA7XG4gICAgdGhpcy5zbWFza1N0YWNrID0gW107XG4gICAgdGhpcy5zbWFza0NvdW50ZXIgPSAwO1xuICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjayA9IFtdO1xuICAgIHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnID0gb3B0aW9uYWxDb250ZW50Q29uZmlnO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMgPSBuZXcgQ2FjaGVkQ2FudmFzZXModGhpcy5jYW52YXNGYWN0b3J5KTtcblxuICAgIGlmIChjYW52YXNDdHgpIHtcbiAgICAgIGFkZENvbnRleHRDdXJyZW50VHJhbnNmb3JtKGNhbnZhc0N0eCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwdXRCaW5hcnlJbWFnZURhdGEoY3R4LCBpbWdEYXRhKSB7XG4gICAgdmFyIHRyYW5zZmVyTWFwcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgSW1hZ2VEYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgICAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgdmFyIHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIHZhciBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICB2YXIgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gICAgdmFyIGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB2YXIgc3JjUG9zID0gMCxcbiAgICAgICAgZGVzdFBvcztcbiAgICB2YXIgc3JjID0gaW1nRGF0YS5kYXRhO1xuICAgIHZhciBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gICAgdmFyIGksIGosIHRoaXNDaHVua0hlaWdodCwgZWxlbXNJblRoaXNDaHVuaztcbiAgICB2YXIgdHJhbnNmZXJNYXBSZWQsIHRyYW5zZmVyTWFwR3JlZW4sIHRyYW5zZmVyTWFwQmx1ZSwgdHJhbnNmZXJNYXBHcmF5O1xuXG4gICAgaWYgKHRyYW5zZmVyTWFwcykge1xuICAgICAgc3dpdGNoICh0cmFuc2Zlck1hcHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0cmFuc2Zlck1hcFJlZCA9IHRyYW5zZmVyTWFwc1swXTtcbiAgICAgICAgICB0cmFuc2Zlck1hcEdyZWVuID0gdHJhbnNmZXJNYXBzWzBdO1xuICAgICAgICAgIHRyYW5zZmVyTWFwQmx1ZSA9IHRyYW5zZmVyTWFwc1swXTtcbiAgICAgICAgICB0cmFuc2Zlck1hcEdyYXkgPSB0cmFuc2Zlck1hcHNbMF07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHRyYW5zZmVyTWFwUmVkID0gdHJhbnNmZXJNYXBzWzBdO1xuICAgICAgICAgIHRyYW5zZmVyTWFwR3JlZW4gPSB0cmFuc2Zlck1hcHNbMV07XG4gICAgICAgICAgdHJhbnNmZXJNYXBCbHVlID0gdHJhbnNmZXJNYXBzWzJdO1xuICAgICAgICAgIHRyYW5zZmVyTWFwR3JheSA9IHRyYW5zZmVyTWFwc1szXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW1nRGF0YS5raW5kID09PSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFApIHtcbiAgICAgIHZhciBzcmNMZW5ndGggPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICAgIHZhciBkZXN0MzIgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIsIDAsIGRlc3QuYnl0ZUxlbmd0aCA+PiAyKTtcbiAgICAgIHZhciBkZXN0MzJEYXRhTGVuZ3RoID0gZGVzdDMyLmxlbmd0aDtcbiAgICAgIHZhciBmdWxsU3JjRGlmZiA9IHdpZHRoICsgNyA+PiAzO1xuICAgICAgdmFyIHdoaXRlID0gMHhmZmZmZmZmZjtcbiAgICAgIHZhciBibGFjayA9IF91dGlsLklzTGl0dGxlRW5kaWFuQ2FjaGVkLnZhbHVlID8gMHhmZjAwMDAwMCA6IDB4MDAwMDAwZmY7XG5cbiAgICAgIGlmICh0cmFuc2Zlck1hcEdyYXkpIHtcbiAgICAgICAgaWYgKHRyYW5zZmVyTWFwR3JheVswXSA9PT0gMHhmZiAmJiB0cmFuc2Zlck1hcEdyYXlbMHhmZl0gPT09IDApIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IFtibGFjaywgd2hpdGVdO1xuICAgICAgICAgIHdoaXRlID0gX3JlZlswXTtcbiAgICAgICAgICBibGFjayA9IF9yZWZbMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgICAgZGVzdFBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXNDaHVua0hlaWdodDsgaisrKSB7XG4gICAgICAgICAgdmFyIHNyY0RpZmYgPSBzcmNMZW5ndGggLSBzcmNQb3M7XG4gICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgIHZhciBrRW5kID0gc3JjRGlmZiA+IGZ1bGxTcmNEaWZmID8gd2lkdGggOiBzcmNEaWZmICogOCAtIDc7XG4gICAgICAgICAgdmFyIGtFbmRVbnJvbGxlZCA9IGtFbmQgJiB+NztcbiAgICAgICAgICB2YXIgbWFzayA9IDA7XG4gICAgICAgICAgdmFyIHNyY0J5dGUgPSAwO1xuXG4gICAgICAgICAgZm9yICg7IGsgPCBrRW5kVW5yb2xsZWQ7IGsgKz0gOCkge1xuICAgICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxMjggPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgNjQgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMzIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTYgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgOCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMSA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICg7IGsgPCBrRW5kOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICAgIHNyY0J5dGUgPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgICAgICBtYXNrID0gMTI4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiBtYXNrID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGRlc3RQb3MgPCBkZXN0MzJEYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbWdEYXRhLmtpbmQgPT09IF91dGlsLkltYWdlS2luZC5SR0JBXzMyQlBQKSB7XG4gICAgICB2YXIgaGFzVHJhbnNmZXJNYXBzID0gISEodHJhbnNmZXJNYXBSZWQgfHwgdHJhbnNmZXJNYXBHcmVlbiB8fCB0cmFuc2Zlck1hcEJsdWUpO1xuICAgICAgaiA9IDA7XG4gICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiBGVUxMX0NIVU5LX0hFSUdIVCAqIDQ7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY1Bvcywgc3JjUG9zICsgZWxlbXNJblRoaXNDaHVuaykpO1xuICAgICAgICBzcmNQb3MgKz0gZWxlbXNJblRoaXNDaHVuaztcblxuICAgICAgICBpZiAoaGFzVHJhbnNmZXJNYXBzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IGVsZW1zSW5UaGlzQ2h1bms7IF9rICs9IDQpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcFJlZCkge1xuICAgICAgICAgICAgICBkZXN0W19rICsgMF0gPSB0cmFuc2Zlck1hcFJlZFtkZXN0W19rICsgMF1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJNYXBHcmVlbikge1xuICAgICAgICAgICAgICBkZXN0W19rICsgMV0gPSB0cmFuc2Zlck1hcEdyZWVuW2Rlc3RbX2sgKyAxXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcEJsdWUpIHtcbiAgICAgICAgICAgICAgZGVzdFtfayArIDJdID0gdHJhbnNmZXJNYXBCbHVlW2Rlc3RbX2sgKyAyXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgICAgICBqICs9IEZVTExfQ0hVTktfSEVJR0hUO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IHRvdGFsQ2h1bmtzKSB7XG4gICAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHBhcnRpYWxDaHVua0hlaWdodCAqIDQ7XG4gICAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcblxuICAgICAgICBpZiAoaGFzVHJhbnNmZXJNYXBzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2syID0gMDsgX2syIDwgZWxlbXNJblRoaXNDaHVuazsgX2syICs9IDQpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcFJlZCkge1xuICAgICAgICAgICAgICBkZXN0W19rMiArIDBdID0gdHJhbnNmZXJNYXBSZWRbZGVzdFtfazIgKyAwXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcEdyZWVuKSB7XG4gICAgICAgICAgICAgIGRlc3RbX2syICsgMV0gPSB0cmFuc2Zlck1hcEdyZWVuW2Rlc3RbX2syICsgMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJNYXBCbHVlKSB7XG4gICAgICAgICAgICAgIGRlc3RbX2syICsgMl0gPSB0cmFuc2Zlck1hcEJsdWVbZGVzdFtfazIgKyAyXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSBfdXRpbC5JbWFnZUtpbmQuUkdCXzI0QlBQKSB7XG4gICAgICB2YXIgX2hhc1RyYW5zZmVyTWFwcyA9ICEhKHRyYW5zZmVyTWFwUmVkIHx8IHRyYW5zZmVyTWFwR3JlZW4gfHwgdHJhbnNmZXJNYXBCbHVlKTtcblxuICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICAgIGlmIChpID49IGZ1bGxDaHVua3MpIHtcbiAgICAgICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogdGhpc0NodW5rSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdFBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChqID0gZWxlbXNJblRoaXNDaHVuazsgai0tOykge1xuICAgICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IDI1NTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfaGFzVHJhbnNmZXJNYXBzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2szID0gMDsgX2szIDwgZGVzdFBvczsgX2szICs9IDQpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcFJlZCkge1xuICAgICAgICAgICAgICBkZXN0W19rMyArIDBdID0gdHJhbnNmZXJNYXBSZWRbZGVzdFtfazMgKyAwXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcEdyZWVuKSB7XG4gICAgICAgICAgICAgIGRlc3RbX2szICsgMV0gPSB0cmFuc2Zlck1hcEdyZWVuW2Rlc3RbX2szICsgMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJNYXBCbHVlKSB7XG4gICAgICAgICAgICAgIGRlc3RbX2szICsgMl0gPSB0cmFuc2Zlck1hcEJsdWVbZGVzdFtfazMgKyAyXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBpbWFnZSBraW5kOiBcIi5jb25jYXQoaW1nRGF0YS5raW5kKSk7XG4gICAgfVxuICB9XG5cbiAgQ2FudmFzR3JhcGhpY3MucHV0QmluYXJ5SW1hZ2VEYXRhID0gcHV0QmluYXJ5SW1hZ2VEYXRhO1xuXG4gIGZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlTWFzayhjdHgsIGltZ0RhdGEpIHtcbiAgICB2YXIgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQsXG4gICAgICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICB2YXIgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgdmFyIGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIHZhciB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgICB2YXIgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICAgIHZhciBzcmNQb3MgPSAwO1xuICAgIHZhciBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gICAgdmFyIGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgdmFyIHRoaXNDaHVua0hlaWdodCA9IGkgPCBmdWxsQ2h1bmtzID8gRlVMTF9DSFVOS19IRUlHSFQgOiBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICB2YXIgZGVzdFBvcyA9IDM7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpc0NodW5rSGVpZ2h0OyBqKyspIHtcbiAgICAgICAgdmFyIGVsZW0gPSB2b2lkIDAsXG4gICAgICAgICAgICBtYXNrID0gMDtcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHdpZHRoOyBrKyspIHtcbiAgICAgICAgICBpZiAoIW1hc2spIHtcbiAgICAgICAgICAgIGVsZW0gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgICAgbWFzayA9IDEyODtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXN0W2Rlc3RQb3NdID0gZWxlbSAmIG1hc2sgPyAwIDogMjU1O1xuICAgICAgICAgIGRlc3RQb3MgKz0gNDtcbiAgICAgICAgICBtYXNrID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlDdHhTdGF0ZShzb3VyY2VDdHgsIGRlc3RDdHgpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IFtcInN0cm9rZVN0eWxlXCIsIFwiZmlsbFN0eWxlXCIsIFwiZmlsbFJ1bGVcIiwgXCJnbG9iYWxBbHBoYVwiLCBcImxpbmVXaWR0aFwiLCBcImxpbmVDYXBcIiwgXCJsaW5lSm9pblwiLCBcIm1pdGVyTGltaXRcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgXCJmb250XCJdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuXG4gICAgICBpZiAoc291cmNlQ3R4W3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlc3RDdHhbcHJvcGVydHldID0gc291cmNlQ3R4W3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc291cmNlQ3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3RDdHguc2V0TGluZURhc2goc291cmNlQ3R4LmdldExpbmVEYXNoKCkpO1xuICAgICAgZGVzdEN0eC5saW5lRGFzaE9mZnNldCA9IHNvdXJjZUN0eC5saW5lRGFzaE9mZnNldDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEN0eFRvRGVmYXVsdChjdHgpIHtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIiMwMDAwMDBcIjtcbiAgICBjdHguZmlsbFN0eWxlID0gXCIjMDAwMDAwXCI7XG4gICAgY3R4LmZpbGxSdWxlID0gXCJub256ZXJvXCI7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBjdHgubGluZUNhcCA9IFwiYnV0dFwiO1xuICAgIGN0eC5saW5lSm9pbiA9IFwibWl0ZXJcIjtcbiAgICBjdHgubWl0ZXJMaW1pdCA9IDEwO1xuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgY3R4LmZvbnQgPSBcIjEwcHggc2Fucy1zZXJpZlwiO1xuXG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wb3NlU01hc2tCYWNrZHJvcChieXRlcywgcjAsIGcwLCBiMCkge1xuICAgIHZhciBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMzsgaSA8IGxlbmd0aDsgaSArPSA0KSB7XG4gICAgICB2YXIgYWxwaGEgPSBieXRlc1tpXTtcblxuICAgICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICAgIGJ5dGVzW2kgLSAzXSA9IHIwO1xuICAgICAgICBieXRlc1tpIC0gMl0gPSBnMDtcbiAgICAgICAgYnl0ZXNbaSAtIDFdID0gYjA7XG4gICAgICB9IGVsc2UgaWYgKGFscGhhIDwgMjU1KSB7XG4gICAgICAgIHZhciBhbHBoYV8gPSAyNTUgLSBhbHBoYTtcbiAgICAgICAgYnl0ZXNbaSAtIDNdID0gYnl0ZXNbaSAtIDNdICogYWxwaGEgKyByMCAqIGFscGhhXyA+PiA4O1xuICAgICAgICBieXRlc1tpIC0gMl0gPSBieXRlc1tpIC0gMl0gKiBhbHBoYSArIGcwICogYWxwaGFfID4+IDg7XG4gICAgICAgIGJ5dGVzW2kgLSAxXSA9IGJ5dGVzW2kgLSAxXSAqIGFscGhhICsgYjAgKiBhbHBoYV8gPj4gODtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wb3NlU01hc2tBbHBoYShtYXNrRGF0YSwgbGF5ZXJEYXRhLCB0cmFuc2Zlck1hcCkge1xuICAgIHZhciBsZW5ndGggPSBtYXNrRGF0YS5sZW5ndGg7XG4gICAgdmFyIHNjYWxlID0gMSAvIDI1NTtcblxuICAgIGZvciAodmFyIGkgPSAzOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIHZhciBhbHBoYSA9IHRyYW5zZmVyTWFwID8gdHJhbnNmZXJNYXBbbWFza0RhdGFbaV1dIDogbWFza0RhdGFbaV07XG4gICAgICBsYXllckRhdGFbaV0gPSBsYXllckRhdGFbaV0gKiBhbHBoYSAqIHNjYWxlIHwgMDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wb3NlU01hc2tMdW1pbm9zaXR5KG1hc2tEYXRhLCBsYXllckRhdGEsIHRyYW5zZmVyTWFwKSB7XG4gICAgdmFyIGxlbmd0aCA9IG1hc2tEYXRhLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAzOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIHZhciB5ID0gbWFza0RhdGFbaSAtIDNdICogNzcgKyBtYXNrRGF0YVtpIC0gMl0gKiAxNTIgKyBtYXNrRGF0YVtpIC0gMV0gKiAyODtcbiAgICAgIGxheWVyRGF0YVtpXSA9IHRyYW5zZmVyTWFwID8gbGF5ZXJEYXRhW2ldICogdHJhbnNmZXJNYXBbeSA+PiA4XSA+PiA4IDogbGF5ZXJEYXRhW2ldICogeSA+PiAxNjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmljQ29tcG9zZVNNYXNrKG1hc2tDdHgsIGxheWVyQ3R4LCB3aWR0aCwgaGVpZ2h0LCBzdWJ0eXBlLCBiYWNrZHJvcCwgdHJhbnNmZXJNYXApIHtcbiAgICB2YXIgaGFzQmFja2Ryb3AgPSAhIWJhY2tkcm9wO1xuICAgIHZhciByMCA9IGhhc0JhY2tkcm9wID8gYmFja2Ryb3BbMF0gOiAwO1xuICAgIHZhciBnMCA9IGhhc0JhY2tkcm9wID8gYmFja2Ryb3BbMV0gOiAwO1xuICAgIHZhciBiMCA9IGhhc0JhY2tkcm9wID8gYmFja2Ryb3BbMl0gOiAwO1xuICAgIHZhciBjb21wb3NlRm47XG5cbiAgICBpZiAoc3VidHlwZSA9PT0gXCJMdW1pbm9zaXR5XCIpIHtcbiAgICAgIGNvbXBvc2VGbiA9IGNvbXBvc2VTTWFza0x1bWlub3NpdHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvc2VGbiA9IGNvbXBvc2VTTWFza0FscGhhO1xuICAgIH1cblxuICAgIHZhciBQSVhFTFNfVE9fUFJPQ0VTUyA9IDEwNDg1NzY7XG4gICAgdmFyIGNodW5rU2l6ZSA9IE1hdGgubWluKGhlaWdodCwgTWF0aC5jZWlsKFBJWEVMU19UT19QUk9DRVNTIC8gd2lkdGgpKTtcblxuICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGhlaWdodDsgcm93ICs9IGNodW5rU2l6ZSkge1xuICAgICAgdmFyIGNodW5rSGVpZ2h0ID0gTWF0aC5taW4oY2h1bmtTaXplLCBoZWlnaHQgLSByb3cpO1xuICAgICAgdmFyIG1hc2tEYXRhID0gbWFza0N0eC5nZXRJbWFnZURhdGEoMCwgcm93LCB3aWR0aCwgY2h1bmtIZWlnaHQpO1xuICAgICAgdmFyIGxheWVyRGF0YSA9IGxheWVyQ3R4LmdldEltYWdlRGF0YSgwLCByb3csIHdpZHRoLCBjaHVua0hlaWdodCk7XG5cbiAgICAgIGlmIChoYXNCYWNrZHJvcCkge1xuICAgICAgICBjb21wb3NlU01hc2tCYWNrZHJvcChtYXNrRGF0YS5kYXRhLCByMCwgZzAsIGIwKTtcbiAgICAgIH1cblxuICAgICAgY29tcG9zZUZuKG1hc2tEYXRhLmRhdGEsIGxheWVyRGF0YS5kYXRhLCB0cmFuc2Zlck1hcCk7XG4gICAgICBtYXNrQ3R4LnB1dEltYWdlRGF0YShsYXllckRhdGEsIDAsIHJvdyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcG9zZVNNYXNrKGN0eCwgc21hc2ssIGxheWVyQ3R4LCB3ZWJHTENvbnRleHQpIHtcbiAgICB2YXIgbWFzayA9IHNtYXNrLmNhbnZhcztcbiAgICB2YXIgbWFza0N0eCA9IHNtYXNrLmNvbnRleHQ7XG4gICAgY3R4LnNldFRyYW5zZm9ybShzbWFzay5zY2FsZVgsIDAsIDAsIHNtYXNrLnNjYWxlWSwgc21hc2sub2Zmc2V0WCwgc21hc2sub2Zmc2V0WSk7XG4gICAgdmFyIGJhY2tkcm9wID0gc21hc2suYmFja2Ryb3AgfHwgbnVsbDtcblxuICAgIGlmICghc21hc2sudHJhbnNmZXJNYXAgJiYgd2ViR0xDb250ZXh0LmlzRW5hYmxlZCkge1xuICAgICAgdmFyIGNvbXBvc2VkID0gd2ViR0xDb250ZXh0LmNvbXBvc2VTTWFzayh7XG4gICAgICAgIGxheWVyOiBsYXllckN0eC5jYW52YXMsXG4gICAgICAgIG1hc2s6IG1hc2ssXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBzdWJ0eXBlOiBzbWFzay5zdWJ0eXBlLFxuICAgICAgICAgIGJhY2tkcm9wOiBiYWNrZHJvcFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBjdHguZHJhd0ltYWdlKGNvbXBvc2VkLCBzbWFzay5vZmZzZXRYLCBzbWFzay5vZmZzZXRZKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnZW5lcmljQ29tcG9zZVNNYXNrKG1hc2tDdHgsIGxheWVyQ3R4LCBtYXNrLndpZHRoLCBtYXNrLmhlaWdodCwgc21hc2suc3VidHlwZSwgYmFja2Ryb3AsIHNtYXNrLnRyYW5zZmVyTWFwKTtcbiAgICBjdHguZHJhd0ltYWdlKG1hc2ssIDAsIDApO1xuICB9XG5cbiAgdmFyIExJTkVfQ0FQX1NUWUxFUyA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcbiAgdmFyIExJTkVfSk9JTl9TVFlMRVMgPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG4gIHZhciBOT1JNQUxfQ0xJUCA9IHt9O1xuICB2YXIgRU9fQ0xJUCA9IHt9O1xuICBDYW52YXNHcmFwaGljcy5wcm90b3R5cGUgPSB7XG4gICAgYmVnaW5EcmF3aW5nOiBmdW5jdGlvbiBiZWdpbkRyYXdpbmcoX3JlZjIpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBfcmVmMi50cmFuc2Zvcm0sXG4gICAgICAgICAgdmlld3BvcnQgPSBfcmVmMi52aWV3cG9ydCxcbiAgICAgICAgICBfcmVmMiR0cmFuc3BhcmVuY3kgPSBfcmVmMi50cmFuc3BhcmVuY3ksXG4gICAgICAgICAgdHJhbnNwYXJlbmN5ID0gX3JlZjIkdHJhbnNwYXJlbmN5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJHRyYW5zcGFyZW5jeSxcbiAgICAgICAgICBfcmVmMiRiYWNrZ3JvdW5kID0gX3JlZjIuYmFja2dyb3VuZCxcbiAgICAgICAgICBiYWNrZ3JvdW5kID0gX3JlZjIkYmFja2dyb3VuZCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYyJGJhY2tncm91bmQ7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmN0eC5jYW52YXMud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5jdHguY2FudmFzLmhlaWdodDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmQgfHwgXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIjtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuXG4gICAgICBpZiAodHJhbnNwYXJlbmN5KSB7XG4gICAgICAgIHZhciB0cmFuc3BhcmVudENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwidHJhbnNwYXJlbnRcIiwgd2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY29tcG9zaXRlQ3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSB0cmFuc3BhcmVudENhbnZhcy5jYW52YXM7XG4gICAgICAgIHRoaXMuY3R4ID0gdHJhbnNwYXJlbnRDYW52YXMuY29udGV4dDtcbiAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHkodGhpcy5jdHgsIHRoaXMuY29tcG9zaXRlQ3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5KHRoaXMuY3R4LCB0cmFuc2Zvcm0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHkodGhpcy5jdHgsIHZpZXdwb3J0LnRyYW5zZm9ybSk7XG4gICAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmN0eC5tb3pDdXJyZW50VHJhbnNmb3JtLnNsaWNlKCk7XG4gICAgICB0aGlzLl9jb21iaW5lZFNjYWxlRmFjdG9yID0gTWF0aC5oeXBvdCh0aGlzLmJhc2VUcmFuc2Zvcm1bMF0sIHRoaXMuYmFzZVRyYW5zZm9ybVsyXSk7XG5cbiAgICAgIGlmICh0aGlzLmltYWdlTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5pbWFnZUxheWVyLmJlZ2luTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGVjdXRlT3BlcmF0b3JMaXN0OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCwgZXhlY3V0aW9uU3RhcnRJZHgsIGNvbnRpbnVlQ2FsbGJhY2ssIHN0ZXBwZXIpIHtcbiAgICAgIHZhciBhcmdzQXJyYXkgPSBvcGVyYXRvckxpc3QuYXJnc0FycmF5O1xuICAgICAgdmFyIGZuQXJyYXkgPSBvcGVyYXRvckxpc3QuZm5BcnJheTtcbiAgICAgIHZhciBpID0gZXhlY3V0aW9uU3RhcnRJZHggfHwgMDtcbiAgICAgIHZhciBhcmdzQXJyYXlMZW4gPSBhcmdzQXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJnc0FycmF5TGVuID09PSBpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2h1bmtPcGVyYXRpb25zID0gYXJnc0FycmF5TGVuIC0gaSA+IEVYRUNVVElPTl9TVEVQUyAmJiB0eXBlb2YgY29udGludWVDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgdmFyIGVuZFRpbWUgPSBjaHVua09wZXJhdGlvbnMgPyBEYXRlLm5vdygpICsgRVhFQ1VUSU9OX1RJTUUgOiAwO1xuICAgICAgdmFyIHN0ZXBzID0gMDtcbiAgICAgIHZhciBjb21tb25PYmpzID0gdGhpcy5jb21tb25PYmpzO1xuICAgICAgdmFyIG9ianMgPSB0aGlzLm9ianM7XG4gICAgICB2YXIgZm5JZDtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKHN0ZXBwZXIgIT09IHVuZGVmaW5lZCAmJiBpID09PSBzdGVwcGVyLm5leHRCcmVha1BvaW50KSB7XG4gICAgICAgICAgc3RlcHBlci5icmVha0l0KGksIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm5JZCA9IGZuQXJyYXlbaV07XG5cbiAgICAgICAgaWYgKGZuSWQgIT09IF91dGlsLk9QUy5kZXBlbmRlbmN5KSB7XG4gICAgICAgICAgdGhpcy5zZXRDdXJyZW50T3BlcmF0b3JJbmRleChpKTtcbiAgICAgICAgICB0aGlzW2ZuSWRdLmFwcGx5KHRoaXMsIGFyZ3NBcnJheVtpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGFyZ3NBcnJheVtpXSksXG4gICAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBkZXBPYmpJZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICB2YXIgb2Jqc1Bvb2wgPSBkZXBPYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyBjb21tb25PYmpzIDogb2JqcztcblxuICAgICAgICAgICAgICBpZiAoIW9ianNQb29sLmhhcyhkZXBPYmpJZCkpIHtcbiAgICAgICAgICAgICAgICBvYmpzUG9vbC5nZXQoZGVwT2JqSWQsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGkrKztcblxuICAgICAgICBpZiAoaSA9PT0gYXJnc0FycmF5TGVuKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2h1bmtPcGVyYXRpb25zICYmICsrc3RlcHMgPiBFWEVDVVRJT05fU1RFUFMpIHtcbiAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGVuZFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0ZXBzID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVzdG9yZUluaXRpYWxTdGF0ZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcmVzdG9yZUluaXRpYWxTdGF0ZSgpIHtcbiAgICAgIHdoaWxlICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoIHx8IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuXG4gICAgICBpZiAodGhpcy50cmFuc3BhcmVudENhbnZhcykge1xuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY29tcG9zaXRlQ3R4O1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMudHJhbnNwYXJlbnRDYW52YXMsIDAsIDApO1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW5kRHJhd2luZzogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfZW5kRHJhd2luZygpIHtcbiAgICAgIHRoaXMucmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgICAgdGhpcy5jYWNoZWRDYW52YXNlcy5jbGVhcigpO1xuICAgICAgdGhpcy53ZWJHTENvbnRleHQuY2xlYXIoKTtcblxuICAgICAgaWYgKHRoaXMuaW1hZ2VMYXllcikge1xuICAgICAgICB0aGlzLmltYWdlTGF5ZXIuZW5kTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRMaW5lV2lkdGg6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldExpbmVXaWR0aCh3aWR0aCkge1xuICAgICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gd2lkdGg7XG4gICAgfSxcbiAgICBzZXRMaW5lQ2FwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRMaW5lQ2FwKHN0eWxlKSB7XG4gICAgICB0aGlzLmN0eC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgICB9LFxuICAgIHNldExpbmVKb2luOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRMaW5lSm9pbihzdHlsZSkge1xuICAgICAgdGhpcy5jdHgubGluZUpvaW4gPSBMSU5FX0pPSU5fU1RZTEVTW3N0eWxlXTtcbiAgICB9LFxuICAgIHNldE1pdGVyTGltaXQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldE1pdGVyTGltaXQobGltaXQpIHtcbiAgICAgIHRoaXMuY3R4Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgICB9LFxuICAgIHNldERhc2g6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldERhc2goZGFzaEFycmF5LCBkYXNoUGhhc2UpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcblxuICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRSZW5kZXJpbmdJbnRlbnQ6IGZ1bmN0aW9uIHNldFJlbmRlcmluZ0ludGVudChpbnRlbnQpIHt9LFxuICAgIHNldEZsYXRuZXNzOiBmdW5jdGlvbiBzZXRGbGF0bmVzcyhmbGF0bmVzcykge30sXG4gICAgc2V0R1N0YXRlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRHU3RhdGUoc3RhdGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBzdGF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgICAgIHZhciBrZXkgPSBzdGF0ZVswXTtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGVbMV07XG5cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIkxDXCI6XG4gICAgICAgICAgICB0aGlzLnNldExpbmVDYXAodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4odmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICB0aGlzLnNldERhc2godmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgICB0aGlzLnNldEZvbnQodmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIkNBXCI6XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSBzdGF0ZVsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gc3RhdGVbMV07XG4gICAgICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHN0YXRlWzFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiQk1cIjpcbiAgICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiU01hc2tcIjpcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2spIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPiAwICYmIHRoaXMuc3RhdGVTdGFja1t0aGlzLnN0YXRlU3RhY2subGVuZ3RoIC0gMV0uYWN0aXZlU01hc2sgPT09IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VzcGVuZFNNYXNrR3JvdXAoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFNNYXNrR3JvdXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSB2YWx1ZSA/IHRoaXMudGVtcFNNYXNrIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaykge1xuICAgICAgICAgICAgICB0aGlzLmJlZ2luU01hc2tHcm91cCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJUUlwiOlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWdpblNNYXNrR3JvdXA6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luU01hc2tHcm91cCgpIHtcbiAgICAgIHZhciBhY3RpdmVTTWFzayA9IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaztcbiAgICAgIHZhciBkcmF3bldpZHRoID0gYWN0aXZlU01hc2suY2FudmFzLndpZHRoO1xuICAgICAgdmFyIGRyYXduSGVpZ2h0ID0gYWN0aXZlU01hc2suY2FudmFzLmhlaWdodDtcbiAgICAgIHZhciBjYWNoZUlkID0gXCJzbWFza0dyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICAgIHZhciBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQsIHRydWUpO1xuICAgICAgdmFyIGN1cnJlbnRDdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBjdXJyZW50VHJhbnNmb3JtID0gY3VycmVudEN0eC5tb3pDdXJyZW50VHJhbnNmb3JtO1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdmFyIGdyb3VwQ3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgICAgZ3JvdXBDdHguc2NhbGUoMSAvIGFjdGl2ZVNNYXNrLnNjYWxlWCwgMSAvIGFjdGl2ZVNNYXNrLnNjYWxlWSk7XG4gICAgICBncm91cEN0eC50cmFuc2xhdGUoLWFjdGl2ZVNNYXNrLm9mZnNldFgsIC1hY3RpdmVTTWFzay5vZmZzZXRZKTtcbiAgICAgIGdyb3VwQ3R4LnRyYW5zZm9ybS5hcHBseShncm91cEN0eCwgY3VycmVudFRyYW5zZm9ybSk7XG4gICAgICBhY3RpdmVTTWFzay5zdGFydFRyYW5zZm9ybUludmVyc2UgPSBncm91cEN0eC5tb3pDdXJyZW50VHJhbnNmb3JtSW52ZXJzZTtcbiAgICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgICB0aGlzLmN0eCA9IGdyb3VwQ3R4O1xuICAgICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICAgICAgdGhpcy5ncm91cFN0YWNrLnB1c2goY3VycmVudEN0eCk7XG4gICAgICB0aGlzLmdyb3VwTGV2ZWwrKztcbiAgICB9LFxuICAgIHN1c3BlbmRTTWFza0dyb3VwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRTTWFza0dyb3VwKCkge1xuICAgICAgdmFyIGdyb3VwQ3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuICAgICAgY29tcG9zZVNNYXNrKHRoaXMuY3R4LCB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2ssIGdyb3VwQ3R4LCB0aGlzLndlYkdMQ29udGV4dCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICBjb3B5Q3R4U3RhdGUoZ3JvdXBDdHgsIHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuY3VycmVudC5yZXN1bWVTTWFza0N0eCA9IGdyb3VwQ3R4O1xuXG4gICAgICB2YXIgZGVsdGFUcmFuc2Zvcm0gPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2suc3RhcnRUcmFuc2Zvcm1JbnZlcnNlLCBncm91cEN0eC5tb3pDdXJyZW50VHJhbnNmb3JtKTtcblxuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5KHRoaXMuY3R4LCBkZWx0YVRyYW5zZm9ybSk7XG4gICAgICBncm91cEN0eC5zYXZlKCk7XG4gICAgICBncm91cEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBncm91cEN0eC5jbGVhclJlY3QoMCwgMCwgZ3JvdXBDdHguY2FudmFzLndpZHRoLCBncm91cEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIGdyb3VwQ3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIHJlc3VtZVNNYXNrR3JvdXA6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3Jlc3VtZVNNYXNrR3JvdXAoKSB7XG4gICAgICB2YXIgZ3JvdXBDdHggPSB0aGlzLmN1cnJlbnQucmVzdW1lU01hc2tDdHg7XG4gICAgICB2YXIgY3VycmVudEN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICAgIHRoaXMuZ3JvdXBTdGFjay5wdXNoKGN1cnJlbnRDdHgpO1xuICAgICAgdGhpcy5ncm91cExldmVsKys7XG4gICAgfSxcbiAgICBlbmRTTWFza0dyb3VwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRTTWFza0dyb3VwKCkge1xuICAgICAgdmFyIGdyb3VwQ3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuICAgICAgY29tcG9zZVNNYXNrKHRoaXMuY3R4LCB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2ssIGdyb3VwQ3R4LCB0aGlzLndlYkdMQ29udGV4dCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICBjb3B5Q3R4U3RhdGUoZ3JvdXBDdHgsIHRoaXMuY3R4KTtcblxuICAgICAgdmFyIGRlbHRhVHJhbnNmb3JtID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0odGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrLnN0YXJ0VHJhbnNmb3JtSW52ZXJzZSwgZ3JvdXBDdHgubW96Q3VycmVudFRyYW5zZm9ybSk7XG5cbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseSh0aGlzLmN0eCwgZGVsdGFUcmFuc2Zvcm0pO1xuICAgIH0sXG4gICAgc2F2ZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2F2ZSgpIHtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICB0aGlzLnN0YXRlU3RhY2sucHVzaChvbGQpO1xuICAgICAgdGhpcy5jdXJyZW50ID0gb2xkLmNsb25lKCk7XG4gICAgICB0aGlzLmN1cnJlbnQucmVzdW1lU01hc2tDdHggPSBudWxsO1xuICAgIH0sXG4gICAgcmVzdG9yZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcmVzdG9yZSgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnQucmVzdW1lU01hc2tDdHgpIHtcbiAgICAgICAgdGhpcy5yZXN1bWVTTWFza0dyb3VwKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgIT09IG51bGwgJiYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPT09IDAgfHwgdGhpcy5zdGF0ZVN0YWNrW3RoaXMuc3RhdGVTdGFjay5sZW5ndGggLSAxXS5hY3RpdmVTTWFzayAhPT0gdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrKSkge1xuICAgICAgICB0aGlzLmVuZFNNYXNrR3JvdXAoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3RyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuY3R4Lm5lZWREZWxlZ2F0ZUlubGluZUltYWdlR3JvdXAgPT09IFwiZnVuY3Rpb25cIiAmJiB0aGlzLmN0eC5uZWVkRGVsZWdhdGVJbmxpbmVJbWFnZUdyb3VwKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB9LFxuICAgIGNvbnN0cnVjdFBhdGg6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2NvbnN0cnVjdFBhdGgob3BzLCBhcmdzKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgIHZhciB4ID0gY3VycmVudC54LFxuICAgICAgICAgIHkgPSBjdXJyZW50Lnk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMCwgaWkgPSBvcHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBzd2l0Y2ggKG9wc1tpXSB8IDApIHtcbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5yZWN0YW5nbGU6XG4gICAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBhcmdzW2orK107XG4gICAgICAgICAgICB2YXIgeHcgPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICB2YXIgeWggPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcblxuICAgICAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5KTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4dywgeWgpO1xuICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHloKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5tb3ZlVG86XG4gICAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmxpbmVUbzpcbiAgICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzpcbiAgICAgICAgICAgIHggPSBhcmdzW2ogKyA0XTtcbiAgICAgICAgICAgIHkgPSBhcmdzW2ogKyA1XTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCBhcmdzW2ogKyAyXSwgYXJnc1tqICsgM10sIHgsIHkpO1xuICAgICAgICAgICAgaiArPSA2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMjpcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCBhcmdzW2ogKyAyXSwgYXJnc1tqICsgM10pO1xuICAgICAgICAgICAgeCA9IGFyZ3NbaiArIDJdO1xuICAgICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgICAgaiArPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMzpcbiAgICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCB4LCB5LCB4LCB5KTtcbiAgICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VQYXRoOlxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudC5zZXRDdXJyZW50UG9pbnQoeCwgeSk7XG4gICAgfSxcbiAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2Nsb3NlUGF0aCgpIHtcbiAgICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG4gICAgc3Ryb2tlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zdHJva2UoY29uc3VtZVBhdGgpIHtcbiAgICAgIGNvbnN1bWVQYXRoID0gdHlwZW9mIGNvbnN1bWVQYXRoICE9PSBcInVuZGVmaW5lZFwiID8gY29uc3VtZVBhdGggOiB0cnVlO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgdmFyIHN0cm9rZUNvbG9yID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhO1xuXG4gICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICBpZiAoX3R5cGVvZihzdHJva2VDb2xvcikgPT09IFwib2JqZWN0XCIgJiYgc3Ryb2tlQ29sb3IgIT09IG51bGwgJiYgc3Ryb2tlQ29sb3IgIT09IHZvaWQgMCAmJiBzdHJva2VDb2xvci5nZXRQYXR0ZXJuKSB7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gY3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm07XG5cbiAgICAgICAgICB2YXIgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSlbMF07XG5cbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcyk7XG4gICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuICAgICAgICAgIHZhciBzY2FsZWRMaW5lV2lkdGggPSB0aGlzLmN1cnJlbnQubGluZVdpZHRoICogc2NhbGU7XG5cbiAgICAgICAgICBpZiAobGluZVdpZHRoIDwgMCAmJiAtbGluZVdpZHRoID49IHNjYWxlZExpbmVXaWR0aCkge1xuICAgICAgICAgICAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLl9jb21iaW5lZFNjYWxlRmFjdG9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWF4KGxpbmVXaWR0aCwgc2NhbGVkTGluZVdpZHRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2xpbmVXaWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuXG4gICAgICAgICAgaWYgKF9saW5lV2lkdGggPCAwICYmIC1fbGluZVdpZHRoID49IHRoaXMuY3VycmVudC5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuX2NvbWJpbmVkU2NhbGVGYWN0b3IpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWF4KF9saW5lV2lkdGgsIHRoaXMuY3VycmVudC5saW5lV2lkdGgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuZmlsbEFscGhhO1xuICAgIH0sXG4gICAgY2xvc2VTdHJva2U6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2Nsb3NlU3Ryb2tlKCkge1xuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19maWxsKGNvbnN1bWVQYXRoLCBpc0ZpbGxTdHJva2VDb21ibykge1xuICAgICAgY29uc3VtZVBhdGggPSB0eXBlb2YgY29uc3VtZVBhdGggIT09IFwidW5kZWZpbmVkXCIgPyBjb25zdW1lUGF0aCA6IHRydWU7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICAgIHZhciBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgICAgdmFyIG5lZWRSZXN0b3JlID0gZmFsc2U7XG5cbiAgICAgIGlmIChpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuYmFzZVRyYW5zZm9ybSkge1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0uYXBwbHkoY3R4LCB0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcyk7XG4gICAgICAgIG5lZWRSZXN0b3JlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgaWYgKGN0eC5pc0xNVkNhbnZhc0NvbnRleHQgJiYgdHlwZW9mIGN0eC5pc0xNVkNhbnZhc0NvbnRleHQgPT09IFwiZnVuY3Rpb25cIiAmJiBjdHguaXNMTVZDYW52YXNDb250ZXh0KCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nRU9GaWxsKSB7XG4gICAgICAgICAgICBjdHguZmlsbCgnZXZlbm9kZCcsIGlzRmlsbFN0cm9rZUNvbWJvKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguZmlsbChpc0ZpbGxTdHJva2VDb21ibyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdFT0ZpbGwpIHtcbiAgICAgICAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRSZXN0b3JlKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25zdW1lUGF0aCkge1xuICAgICAgICB0aGlzLmNvbnN1bWVQYXRoKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlb0ZpbGw6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VvRmlsbCgpIHtcbiAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgICB0aGlzLmZpbGwoKTtcbiAgICB9LFxuICAgIGZpbGxTdHJva2U6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2ZpbGxTdHJva2UoKSB7XG4gICAgICB0aGlzLmZpbGwoZmFsc2UsIHRydWUpO1xuICAgICAgdGhpcy5zdHJva2UoZmFsc2UpO1xuICAgICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICAgIH0sXG4gICAgZW9GaWxsU3Ryb2tlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lb0ZpbGxTdHJva2UoKSB7XG4gICAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgfSxcbiAgICBjbG9zZUZpbGxTdHJva2U6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2Nsb3NlRmlsbFN0cm9rZSgpIHtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgICB9LFxuICAgIGNsb3NlRU9GaWxsU3Ryb2tlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19jbG9zZUVPRmlsbFN0cm9rZSgpIHtcbiAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgfSxcbiAgICBlbmRQYXRoOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRQYXRoKCkge1xuICAgICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICAgIH0sXG4gICAgY2xpcDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfY2xpcCgpIHtcbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBOT1JNQUxfQ0xJUDtcbiAgICB9LFxuICAgIGVvQ2xpcDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfZW9DbGlwKCkge1xuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IEVPX0NMSVA7XG4gICAgfSxcbiAgICBiZWdpblRleHQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luVGV4dCgpIHtcbiAgICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCA9IDA7XG4gICAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSA9IDA7XG4gICAgfSxcbiAgICBlbmRUZXh0OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRUZXh0KCkge1xuICAgICAgdmFyIHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuXG4gICAgICBpZiAocGF0aHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtLmFwcGx5KGN0eCwgcGF0aC50cmFuc2Zvcm0pO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHBhdGgueCwgcGF0aC55KTtcbiAgICAgICAgcGF0aC5hZGRUb1BhdGgoY3R4LCBwYXRoLmZvbnRTaXplKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICAgIH0sXG4gICAgc2V0Q2hhclNwYWNpbmc6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldENoYXJTcGFjaW5nKHNwYWNpbmcpIHtcbiAgICAgIHRoaXMuY3VycmVudC5jaGFyU3BhY2luZyA9IHNwYWNpbmc7XG4gICAgfSxcbiAgICBzZXRXb3JkU3BhY2luZzogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0V29yZFNwYWNpbmcoc3BhY2luZykge1xuICAgICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gc3BhY2luZztcbiAgICB9LFxuICAgIHNldEhTY2FsZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0SFNjYWxlKHNjYWxlKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudGV4dEhTY2FsZSA9IHNjYWxlIC8gMTAwO1xuICAgIH0sXG4gICAgc2V0TGVhZGluZzogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0TGVhZGluZyhsZWFkaW5nKSB7XG4gICAgICB0aGlzLmN1cnJlbnQubGVhZGluZyA9IC1sZWFkaW5nO1xuICAgIH0sXG4gICAgc2V0Rm9udDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0Rm9udChmb250UmVmTmFtZSwgc2l6ZSkge1xuICAgICAgdmFyIGZvbnRPYmogPSB0aGlzLmNvbW1vbk9ianMuZ2V0KGZvbnRSZWZOYW1lKTtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuXG4gICAgICBpZiAoIWZvbnRPYmopIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBmb250IGZvciBcIi5jb25jYXQoZm9udFJlZk5hbWUpKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudC5mb250TWF0cml4ID0gZm9udE9iai5mb250TWF0cml4IHx8IF91dGlsLkZPTlRfSURFTlRJVFlfTUFUUklYO1xuXG4gICAgICBpZiAoY3VycmVudC5mb250TWF0cml4WzBdID09PSAwIHx8IGN1cnJlbnQuZm9udE1hdHJpeFszXSA9PT0gMCkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJJbnZhbGlkIGZvbnQgbWF0cml4IGZvciBmb250IFwiICsgZm9udFJlZk5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgICAgc2l6ZSA9IC1zaXplO1xuICAgICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudC5mb250ID0gZm9udE9iajtcbiAgICAgIHRoaXMuY3VycmVudC5mb250U2l6ZSA9IHNpemU7XG5cbiAgICAgIGlmIChmb250T2JqLmlzVHlwZTNGb250KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBmb250T2JqLmxvYWRlZE5hbWUgfHwgXCJzYW5zLXNlcmlmXCI7XG4gICAgICB2YXIgYm9sZCA9IFwibm9ybWFsXCI7XG5cbiAgICAgIGlmIChmb250T2JqLmJsYWNrKSB7XG4gICAgICAgIGJvbGQgPSBcIjkwMFwiO1xuICAgICAgfSBlbHNlIGlmIChmb250T2JqLmJvbGQpIHtcbiAgICAgICAgYm9sZCA9IFwiYm9sZFwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRhbGljID0gZm9udE9iai5pdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIjtcbiAgICAgIHZhciB0eXBlZmFjZSA9IFwiXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIsIFwiKS5jb25jYXQoZm9udE9iai5mYWxsYmFja05hbWUpO1xuICAgICAgdmFyIGJyb3dzZXJGb250U2l6ZSA9IHNpemU7XG5cbiAgICAgIGlmIChzaXplIDwgTUlOX0ZPTlRfU0laRSkge1xuICAgICAgICBicm93c2VyRm9udFNpemUgPSBNSU5fRk9OVF9TSVpFO1xuICAgICAgfSBlbHNlIGlmIChzaXplID4gTUFYX0ZPTlRfU0laRSkge1xuICAgICAgICBicm93c2VyRm9udFNpemUgPSBNQVhfRk9OVF9TSVpFO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnQuZm9udFNpemVTY2FsZSA9IHNpemUgLyBicm93c2VyRm9udFNpemU7XG4gICAgICB0aGlzLmN0eC5mb250ID0gXCJcIi5jb25jYXQoaXRhbGljLCBcIiBcIikuY29uY2F0KGJvbGQsIFwiIFwiKS5jb25jYXQoYnJvd3NlckZvbnRTaXplLCBcInB4IFwiKS5jb25jYXQodHlwZWZhY2UpO1xuICAgIH0sXG4gICAgc2V0VGV4dFJlbmRlcmluZ01vZGU6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldFRleHRSZW5kZXJpbmdNb2RlKG1vZGUpIHtcbiAgICAgIHRoaXMuY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9IG1vZGU7XG4gICAgfSxcbiAgICBzZXRUZXh0UmlzZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0VGV4dFJpc2UocmlzZSkge1xuICAgICAgdGhpcy5jdXJyZW50LnRleHRSaXNlID0gcmlzZTtcbiAgICB9LFxuICAgIG1vdmVUZXh0OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19tb3ZlVGV4dCh4LCB5KSB7XG4gICAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCArPSB4O1xuICAgICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgKz0geTtcbiAgICB9LFxuICAgIHNldExlYWRpbmdNb3ZlVGV4dDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0TGVhZGluZ01vdmVUZXh0KHgsIHkpIHtcbiAgICAgIHRoaXMuc2V0TGVhZGluZygteSk7XG4gICAgICB0aGlzLm1vdmVUZXh0KHgsIHkpO1xuICAgIH0sXG4gICAgc2V0VGV4dE1hdHJpeDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0VGV4dE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgPSAwO1xuICAgIH0sXG4gICAgbmV4dExpbmU6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX25leHRMaW5lKCkge1xuICAgICAgdGhpcy5tb3ZlVGV4dCgwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gICAgfSxcbiAgICBwYWludENoYXI6IGZ1bmN0aW9uIHBhaW50Q2hhcihjaGFyYWN0ZXIsIHgsIHksIHBhdHRlcm5UcmFuc2Zvcm0sIHJlc2V0TGluZVdpZHRoVG9PbmUpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgdmFyIGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgICB2YXIgdGV4dFJlbmRlcmluZ01vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlO1xuICAgICAgdmFyIGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZSAvIGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICAgIHZhciBmaWxsU3Ryb2tlTW9kZSA9IHRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcbiAgICAgIHZhciBpc0FkZFRvUGF0aFNldCA9ICEhKHRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRyk7XG4gICAgICB2YXIgcGF0dGVybkZpbGwgPSBjdXJyZW50LnBhdHRlcm5GaWxsICYmICFmb250Lm1pc3NpbmdGaWxlO1xuICAgICAgdmFyIGFkZFRvUGF0aDtcblxuICAgICAgaWYgKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IGlzQWRkVG9QYXRoU2V0IHx8IHBhdHRlcm5GaWxsKSB7XG4gICAgICAgIGFkZFRvUGF0aCA9IGZvbnQuZ2V0UGF0aEdlbmVyYXRvcih0aGlzLmNvbW1vbk9ianMsIGNoYXJhY3Rlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb1BhdGggJiYgKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IHBhdHRlcm5GaWxsKSkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKGNoYXJhY3RlciwgeCwgeSwgZm9udCwgZm9udFNpemUpO1xuICAgICAgICBhZGRUb1BhdGgoY3R4LCBmb250U2l6ZSk7XG5cbiAgICAgICAgaWYgKHBhdHRlcm5UcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtLmFwcGx5KGN0eCwgcGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICAgIGlmIChyZXNldExpbmVXaWR0aFRvT25lKSB7XG4gICAgICAgICAgICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuX2NvbWJpbmVkU2NhbGVGYWN0b3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3RlciwgeCwgeSwgdW5kZWZpbmVkLCBmb250LCBmb250U2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgICBpZiAocmVzZXRMaW5lV2lkdGhUb09uZSkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLnJvdW5kKHRoaXMuX2NvbWJpbmVkU2NhbGVGYWN0b3IpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQoY2hhcmFjdGVyLCAwLCAwLCB1bmRlZmluZWQsIGZvbnQsIGZvbnRTaXplKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KGNoYXJhY3RlciwgeCwgeSwgdW5kZWZpbmVkLCBmb250LCBmb250U2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb1BhdGggJiYgaXNBZGRUb1BhdGhTZXQpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzIHx8ICh0aGlzLnBlbmRpbmdUZXh0UGF0aHMgPSBbXSk7XG4gICAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICAgIHRyYW5zZm9ybTogY3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGZvbnRTaXplOiBmb250U2l6ZSxcbiAgICAgICAgICBhZGRUb1BhdGg6IGFkZFRvUGF0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0IGlzRm9udFN1YnBpeGVsQUFFbmFibGVkKCkge1xuICAgICAgdmFyIF90aGlzJGNhY2hlZENhbnZhc2VzJCA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgMTAsIDEwKSxcbiAgICAgICAgICBjdHggPSBfdGhpcyRjYWNoZWRDYW52YXNlcyQuY29udGV4dDtcblxuICAgICAgY3R4LnNjYWxlKDEuNSwgMSk7XG4gICAgICBjdHguZmlsbFRleHQoXCJJXCIsIDAsIDEwKTtcbiAgICAgIHZhciBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxMCwgMTApLmRhdGE7XG4gICAgICB2YXIgZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMzsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgaWYgKGRhdGFbaV0gPiAwICYmIGRhdGFbaV0gPCAyNTUpIHtcbiAgICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgICB9LFxuXG4gICAgc2hvd1RleHQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3Nob3dUZXh0KGdseXBocykge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICB2YXIgZm9udCA9IGN1cnJlbnQuZm9udDtcblxuICAgICAgaWYgKGZvbnQuaXNUeXBlM0ZvbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvd1R5cGUzVGV4dChnbHlwaHMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuXG4gICAgICBpZiAoZm9udFNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgdmFyIGZvbnRTaXplU2NhbGUgPSBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgICB2YXIgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgICAgdmFyIHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICAgIHZhciBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgICAgdmFyIHRleHRIU2NhbGUgPSBjdXJyZW50LnRleHRIU2NhbGUgKiBmb250RGlyZWN0aW9uO1xuICAgICAgdmFyIGdseXBoc0xlbmd0aCA9IGdseXBocy5sZW5ndGg7XG4gICAgICB2YXIgdmVydGljYWwgPSBmb250LnZlcnRpY2FsO1xuICAgICAgdmFyIHNwYWNpbmdEaXIgPSB2ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICAgIHZhciBkZWZhdWx0Vk1ldHJpY3MgPSBmb250LmRlZmF1bHRWTWV0cmljcztcbiAgICAgIHZhciB3aWR0aEFkdmFuY2VTY2FsZSA9IGZvbnRTaXplICogY3VycmVudC5mb250TWF0cml4WzBdO1xuICAgICAgdmFyIHNpbXBsZUZpbGxUZXh0ID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCAmJiAhZm9udC5kaXNhYmxlRm9udEZhY2UgJiYgIWN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIHBhdHRlcm5UcmFuc2Zvcm07XG5cbiAgICAgIGlmIChjdXJyZW50LnBhdHRlcm5GaWxsKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gY3VycmVudC5maWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMpO1xuICAgICAgICBwYXR0ZXJuVHJhbnNmb3JtID0gY3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm07XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgICAgfVxuXG4gICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkgKyBjdXJyZW50LnRleHRSaXNlKTtcblxuICAgICAgaWYgKGZvbnREaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCAtMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lV2lkdGggPSBjdXJyZW50LmxpbmVXaWR0aDtcbiAgICAgIHZhciByZXNldExpbmVXaWR0aFRvT25lID0gZmFsc2U7XG4gICAgICB2YXIgc2NhbGUgPSBjdXJyZW50LnRleHRNYXRyaXhTY2FsZTtcblxuICAgICAgaWYgKHNjYWxlID09PSAwIHx8IGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICB2YXIgZmlsbFN0cm9rZU1vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcblxuICAgICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICAgICAgICBsaW5lV2lkdGggPSB0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKTtcbiAgICAgICAgICByZXNldExpbmVXaWR0aFRvT25lID0gbGluZVdpZHRoIDwgMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZVdpZHRoIC89IHNjYWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9udFNpemVTY2FsZSAhPT0gMS4wKSB7XG4gICAgICAgIGN0eC5zY2FsZShmb250U2l6ZVNjYWxlLCBmb250U2l6ZVNjYWxlKTtcbiAgICAgICAgbGluZVdpZHRoIC89IGZvbnRTaXplU2NhbGU7XG4gICAgICB9XG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICB2YXIgeCA9IDAsXG4gICAgICAgICAgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGdseXBoc0xlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcblxuICAgICAgICBpZiAoKDAsIF91dGlsLmlzTnVtKShnbHlwaCkpIHtcbiAgICAgICAgICB4ICs9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN0b3JlTmVlZGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICAgIHZhciBjaGFyYWN0ZXIgPSBnbHlwaC5mb250Q2hhcjtcbiAgICAgICAgdmFyIGFjY2VudCA9IGdseXBoLmFjY2VudDtcbiAgICAgICAgdmFyIHNjYWxlZFggPSB2b2lkIDAsXG4gICAgICAgICAgICBzY2FsZWRZID0gdm9pZCAwO1xuICAgICAgICB2YXIgd2lkdGggPSBnbHlwaC53aWR0aDtcblxuICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICB2YXIgdm1ldHJpYyA9IGdseXBoLnZtZXRyaWMgfHwgZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgICAgIHZhciB2eCA9IC0oZ2x5cGgudm1ldHJpYyA/IHZtZXRyaWNbMV0gOiB3aWR0aCAqIDAuNSkgKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgICB2YXIgdnkgPSB2bWV0cmljWzJdICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgICAgd2lkdGggPSB2bWV0cmljID8gLXZtZXRyaWNbMF0gOiB3aWR0aDtcbiAgICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgIHNjYWxlZFkgPSAoeCArIHZ5KSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgIHNjYWxlZFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvbnQucmVtZWFzdXJlICYmIHdpZHRoID4gMCkge1xuICAgICAgICAgIHZhciBtZWFzdXJlZFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3Rlcikud2lkdGggKiAxMDAwIC8gZm9udFNpemUgKiBmb250U2l6ZVNjYWxlO1xuXG4gICAgICAgICAgaWYgKHdpZHRoIDwgbWVhc3VyZWRXaWR0aCAmJiB0aGlzLmlzRm9udFN1YnBpeGVsQUFFbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgY2hhcmFjdGVyU2NhbGVYID0gd2lkdGggLyBtZWFzdXJlZFdpZHRoO1xuICAgICAgICAgICAgcmVzdG9yZU5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKGNoYXJhY3RlclNjYWxlWCwgMSk7XG4gICAgICAgICAgICBzY2FsZWRYIC89IGNoYXJhY3RlclNjYWxlWDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdpZHRoICE9PSBtZWFzdXJlZFdpZHRoKSB7XG4gICAgICAgICAgICBzY2FsZWRYICs9ICh3aWR0aCAtIG1lYXN1cmVkV2lkdGgpIC8gMjAwMCAqIGZvbnRTaXplIC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSAmJiAoZ2x5cGguaXNJbkZvbnQgfHwgZm9udC5taXNzaW5nRmlsZSkpIHtcbiAgICAgICAgICBpZiAoc2ltcGxlRmlsbFRleHQgJiYgIWFjY2VudCkge1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSwgcGF0dGVyblRyYW5zZm9ybSwgcmVzZXRMaW5lV2lkdGhUb09uZSk7XG5cbiAgICAgICAgICAgIGlmIChhY2NlbnQpIHtcbiAgICAgICAgICAgICAgdmFyIHNjYWxlZEFjY2VudFggPSBzY2FsZWRYICsgZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgICB2YXIgc2NhbGVkQWNjZW50WSA9IHNjYWxlZFkgLSBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGFjY2VudC5mb250Q2hhciwgc2NhbGVkQWNjZW50WCwgc2NhbGVkQWNjZW50WSwgcGF0dGVyblRyYW5zZm9ybSwgcmVzZXRMaW5lV2lkdGhUb09uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYXJXaWR0aCA9IHZvaWQgMDtcblxuICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICBjaGFyV2lkdGggPSB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhcldpZHRoID0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSArIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgeCArPSBjaGFyV2lkdGg7XG5cbiAgICAgICAgaWYgKHJlc3RvcmVOZWVkZWQpIHtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBjdXJyZW50LnkgLT0geDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIHNob3dUeXBlM1RleHQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3Nob3dUeXBlM1RleHQoZ2x5cGhzKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgIHZhciBmb250ID0gY3VycmVudC5mb250O1xuICAgICAgdmFyIGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICAgIHZhciBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgICAgdmFyIHNwYWNpbmdEaXIgPSBmb250LnZlcnRpY2FsID8gMSA6IC0xO1xuICAgICAgdmFyIGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICAgIHZhciB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgICB2YXIgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgICB2YXIgZm9udE1hdHJpeCA9IGN1cnJlbnQuZm9udE1hdHJpeCB8fCBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICAgIHZhciBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgICAgdmFyIGlzVGV4dEludmlzaWJsZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLklOVklTSUJMRTtcbiAgICAgIHZhciBpLCBnbHlwaCwgd2lkdGgsIHNwYWNpbmdMZW5ndGg7XG5cbiAgICAgIGlmIChpc1RleHRJbnZpc2libGUgfHwgZm9udFNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkpO1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIGZvbnREaXJlY3Rpb24pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG5cbiAgICAgICAgaWYgKCgwLCBfdXRpbC5pc051bSkoZ2x5cGgpKSB7XG4gICAgICAgICAgc3BhY2luZ0xlbmd0aCA9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoc3BhY2luZ0xlbmd0aCwgMCk7XG4gICAgICAgICAgY3VycmVudC54ICs9IHNwYWNpbmdMZW5ndGggKiB0ZXh0SFNjYWxlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgICAgdmFyIG9wZXJhdG9yTGlzdCA9IGZvbnQuY2hhclByb2NPcGVyYXRvckxpc3RbZ2x5cGgub3BlcmF0b3JMaXN0SWRdO1xuXG4gICAgICAgIGlmICghb3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVHlwZTMgY2hhcmFjdGVyIFxcXCJcIi5jb25jYXQoZ2x5cGgub3BlcmF0b3JMaXN0SWQsIFwiXFxcIiBpcyBub3QgYXZhaWxhYmxlLlwiKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gZ2x5cGg7XG4gICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgY3R4LnNjYWxlKGZvbnRTaXplLCBmb250U2l6ZSk7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIGZvbnRNYXRyaXgpO1xuICAgICAgICAgIHRoaXMuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbZ2x5cGgud2lkdGgsIDBdLCBmb250TWF0cml4KTtcblxuICAgICAgICB3aWR0aCA9IHRyYW5zZm9ybWVkWzBdICogZm9udFNpemUgKyBzcGFjaW5nO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCAwKTtcbiAgICAgICAgY3VycmVudC54ICs9IHdpZHRoICogdGV4dEhTY2FsZTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gbnVsbDtcbiAgICB9LFxuICAgIHNldENoYXJXaWR0aDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0Q2hhcldpZHRoKHhXaWR0aCwgeVdpZHRoKSB7fSxcbiAgICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldENoYXJXaWR0aEFuZEJvdW5kcyh4V2lkdGgsIHlXaWR0aCwgbGx4LCBsbHksIHVyeCwgdXJ5KSB7XG4gICAgICB0aGlzLmN0eC5yZWN0KGxseCwgbGx5LCB1cnggLSBsbHgsIHVyeSAtIGxseSk7XG4gICAgICB0aGlzLmNsaXAoKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH0sXG4gICAgZ2V0Q29sb3JOX1BhdHRlcm46IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2dldENvbG9yTl9QYXR0ZXJuKElSKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcGF0dGVybjtcblxuICAgICAgaWYgKElSWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgICB2YXIgY29sb3IgPSBJUlsxXTtcbiAgICAgICAgdmFyIGJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm0gfHwgdGhpcy5jdHgubW96Q3VycmVudFRyYW5zZm9ybS5zbGljZSgpO1xuICAgICAgICB2YXIgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0ge1xuICAgICAgICAgIGNyZWF0ZUNhbnZhc0dyYXBoaWNzOiBmdW5jdGlvbiBjcmVhdGVDYW52YXNHcmFwaGljcyhjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FudmFzR3JhcGhpY3MoY3R4LCBfdGhpcy5jb21tb25PYmpzLCBfdGhpcy5vYmpzLCBfdGhpcy5jYW52YXNGYWN0b3J5LCBfdGhpcy53ZWJHTENvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcGF0dGVybiA9IG5ldyBfcGF0dGVybl9oZWxwZXIuVGlsaW5nUGF0dGVybihJUiwgY29sb3IsIHRoaXMuY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0dGVybiA9ICgwLCBfcGF0dGVybl9oZWxwZXIuZ2V0U2hhZGluZ1BhdHRlcm5Gcm9tSVIpKElSKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfSxcbiAgICBzZXRTdHJva2VDb2xvck46IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldFN0cm9rZUNvbG9yTigpIHtcbiAgICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4oYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldEZpbGxDb2xvck46IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldEZpbGxDb2xvck4oKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gdGhpcy5nZXRDb2xvck5fUGF0dGVybihhcmd1bWVudHMpO1xuICAgICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gdHJ1ZTtcbiAgICB9LFxuICAgIHNldFN0cm9rZVJHQkNvbG9yOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRTdHJva2VSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgICB2YXIgY29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcblxuICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IGNvbG9yO1xuICAgIH0sXG4gICAgc2V0RmlsbFJHQkNvbG9yOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRGaWxsUkdCQ29sb3IociwgZywgYikge1xuICAgICAgdmFyIGNvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IociwgZywgYik7XG5cbiAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IGNvbG9yO1xuICAgICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gICAgfSxcbiAgICBzaGFkaW5nRmlsbDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2hhZGluZ0ZpbGwocGF0dGVybklSKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLnNhdmUoKTtcbiAgICAgIHZhciBwYXR0ZXJuID0gKDAsIF9wYXR0ZXJuX2hlbHBlci5nZXRTaGFkaW5nUGF0dGVybkZyb21JUikocGF0dGVybklSKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuLmdldFBhdHRlcm4oY3R4LCB0aGlzLCB0cnVlKTtcbiAgICAgIHZhciBpbnYgPSBjdHgubW96Q3VycmVudFRyYW5zZm9ybUludmVyc2U7XG5cbiAgICAgIGlmIChpbnYpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgICAgIHZhciB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGJsID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgMF0sIGludik7XG5cbiAgICAgICAgdmFyIGJyID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgaGVpZ2h0XSwgaW52KTtcblxuICAgICAgICB2YXIgdWwgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt3aWR0aCwgMF0sIGludik7XG5cbiAgICAgICAgdmFyIHVyID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbd2lkdGgsIGhlaWdodF0sIGludik7XG5cbiAgICAgICAgdmFyIHgwID0gTWF0aC5taW4oYmxbMF0sIGJyWzBdLCB1bFswXSwgdXJbMF0pO1xuICAgICAgICB2YXIgeTAgPSBNYXRoLm1pbihibFsxXSwgYnJbMV0sIHVsWzFdLCB1clsxXSk7XG4gICAgICAgIHZhciB4MSA9IE1hdGgubWF4KGJsWzBdLCBiclswXSwgdWxbMF0sIHVyWzBdKTtcbiAgICAgICAgdmFyIHkxID0gTWF0aC5tYXgoYmxbMV0sIGJyWzFdLCB1bFsxXSwgdXJbMV0pO1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QoLTFlMTAsIC0xZTEwLCAyZTEwLCAyZTEwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBiZWdpbklubGluZUltYWdlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19iZWdpbklubGluZUltYWdlKCkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIlNob3VsZCBub3QgY2FsbCBiZWdpbklubGluZUltYWdlXCIpO1xuICAgIH0sXG4gICAgYmVnaW5JbWFnZURhdGE6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luSW1hZ2VEYXRhKCkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIlNob3VsZCBub3QgY2FsbCBiZWdpbkltYWdlRGF0YVwiKTtcbiAgICB9LFxuICAgIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcGFpbnRGb3JtWE9iamVjdEJlZ2luKG1hdHJpeCwgYmJveCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wdXNoKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdHJpeCkgJiYgbWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5hcHBseSh0aGlzLCBtYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmN0eC5tb3pDdXJyZW50VHJhbnNmb3JtO1xuXG4gICAgICBpZiAoYmJveCkge1xuICAgICAgICB2YXIgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICAgICAgICB0aGlzLmN0eC5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmNsaXAoKTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYWludEZvcm1YT2JqZWN0RW5kOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19wYWludEZvcm1YT2JqZWN0RW5kKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgICB9LFxuICAgIGJlZ2luR3JvdXA6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luR3JvdXAoZ3JvdXApIHtcbiAgICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgdmFyIGN1cnJlbnRDdHggPSB0aGlzLmN0eDtcblxuICAgICAgaWYgKCFncm91cC5pc29sYXRlZCkge1xuICAgICAgICAoMCwgX3V0aWwuaW5mbykoXCJUT0RPOiBTdXBwb3J0IG5vbi1pc29sYXRlZCBncm91cHMuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3JvdXAua25vY2tvdXQpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiS25vY2tvdXQgZ3JvdXBzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoISh0aGlzLmN0eC5iZWdpbkNoaWxkR3JvdXAgJiYgdHlwZW9mIHRoaXMuY3R4LmJlZ2luQ2hpbGRHcm91cCA9PT0gXCJmdW5jdGlvblwiICYmIHRoaXMuY3R4LmJlZ2luQ2hpbGRHcm91cChncm91cCkpKSB7XG4gICAgICAgIHZhciBjdXJyZW50VHJhbnNmb3JtID0gY3VycmVudEN0eC5tb3pDdXJyZW50VHJhbnNmb3JtO1xuXG4gICAgICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgICAgICBjdXJyZW50Q3R4LnRyYW5zZm9ybS5hcHBseShjdXJyZW50Q3R4LCBncm91cC5tYXRyaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFncm91cC5iYm94KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm91bmRpbmcgYm94IGlzIHJlcXVpcmVkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib3VuZHMgPSBfdXRpbC5VdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KGdyb3VwLmJib3gsIGN1cnJlbnRDdHgubW96Q3VycmVudFRyYW5zZm9ybSk7XG5cbiAgICAgICAgdmFyIGNhbnZhc0JvdW5kcyA9IFswLCAwLCBjdXJyZW50Q3R4LmNhbnZhcy53aWR0aCwgY3VycmVudEN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICAgICAgYm91bmRzID0gX3V0aWwuVXRpbC5pbnRlcnNlY3QoYm91bmRzLCBjYW52YXNCb3VuZHMpIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgICAgdmFyIG9mZnNldFggPSBNYXRoLmZsb29yKGJvdW5kc1swXSk7XG4gICAgICAgIHZhciBvZmZzZXRZID0gTWF0aC5mbG9vcihib3VuZHNbMV0pO1xuICAgICAgICB2YXIgZHJhd25XaWR0aCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbMl0pIC0gb2Zmc2V0WCwgMSk7XG4gICAgICAgIHZhciBkcmF3bkhlaWdodCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbM10pIC0gb2Zmc2V0WSwgMSk7XG4gICAgICAgIHZhciBzY2FsZVggPSAxLFxuICAgICAgICAgICAgc2NhbGVZID0gMTtcblxuICAgICAgICBpZiAoZHJhd25XaWR0aCA+IE1BWF9HUk9VUF9TSVpFKSB7XG4gICAgICAgICAgc2NhbGVYID0gZHJhd25XaWR0aCAvIE1BWF9HUk9VUF9TSVpFO1xuICAgICAgICAgIGRyYXduV2lkdGggPSBNQVhfR1JPVVBfU0laRTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmF3bkhlaWdodCA+IE1BWF9HUk9VUF9TSVpFKSB7XG4gICAgICAgICAgc2NhbGVZID0gZHJhd25IZWlnaHQgLyBNQVhfR1JPVVBfU0laRTtcbiAgICAgICAgICBkcmF3bkhlaWdodCA9IE1BWF9HUk9VUF9TSVpFO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhY2hlSWQgPSBcImdyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcblxuICAgICAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgICAgICBjYWNoZUlkICs9IFwiX3NtYXNrX1wiICsgdGhpcy5zbWFza0NvdW50ZXIrKyAlIDI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0LCB0cnVlKTtcbiAgICAgICAgdmFyIGdyb3VwQ3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgICAgICBncm91cEN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgZ3JvdXBDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgICAgIGdyb3VwQ3R4LnRyYW5zZm9ybS5hcHBseShncm91cEN0eCwgY3VycmVudFRyYW5zZm9ybSk7XG5cbiAgICAgICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICAgICAgdGhpcy5zbWFza1N0YWNrLnB1c2goe1xuICAgICAgICAgICAgY2FudmFzOiBzY3JhdGNoQ2FudmFzLmNhbnZhcyxcbiAgICAgICAgICAgIGNvbnRleHQ6IGdyb3VwQ3R4LFxuICAgICAgICAgICAgb2Zmc2V0WDogb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFk6IG9mZnNldFksXG4gICAgICAgICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICAgICAgc3VidHlwZTogZ3JvdXAuc21hc2suc3VidHlwZSxcbiAgICAgICAgICAgIGJhY2tkcm9wOiBncm91cC5zbWFzay5iYWNrZHJvcCxcbiAgICAgICAgICAgIHRyYW5zZmVyTWFwOiBncm91cC5zbWFzay50cmFuc2Zlck1hcCB8fCBudWxsLFxuICAgICAgICAgICAgc3RhcnRUcmFuc2Zvcm1JbnZlcnNlOiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgY3VycmVudEN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgICAgY3VycmVudEN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb3B5Q3R4U3RhdGUoY3VycmVudEN0eCwgZ3JvdXBDdHgpO1xuICAgICAgICB0aGlzLmN0eCA9IGdyb3VwQ3R4O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldEdTdGF0ZShbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXSwgW1wiY2FcIiwgMV0sIFtcIkNBXCIsIDFdXSk7XG4gICAgICB0aGlzLmdyb3VwU3RhY2sucHVzaChjdXJyZW50Q3R4KTtcbiAgICAgIHRoaXMuZ3JvdXBMZXZlbCsrO1xuICAgICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB9LFxuICAgIGVuZEdyb3VwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRHcm91cChncm91cCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ncm91cExldmVsLS07XG4gICAgICB2YXIgZ3JvdXBDdHggPSB0aGlzLmN0eDtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuXG4gICAgICBpZiAoISh0aGlzLmN0eC5lbmRDaGlsZEdyb3VwICYmIHR5cGVvZiB0aGlzLmN0eC5lbmRDaGlsZEdyb3VwID09PSBcImZ1bmN0aW9uXCIgJiYgdGhpcy5jdHguZW5kQ2hpbGRHcm91cChncm91cCkpKSB7XG4gICAgICAgIGlmICh0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICAgICAgdGhpcy50ZW1wU01hc2sgPSB0aGlzLnNtYXNrU3RhY2sucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGdyb3VwQ3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBiZWdpbkFubm90YXRpb25zOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19iZWdpbkFubm90YXRpb25zKCkge30sXG4gICAgZW5kQW5ub3RhdGlvbnM6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZEFubm90YXRpb25zKCkge30sXG4gICAgYmVnaW5Bbm5vdGF0aW9uOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19iZWdpbkFubm90YXRpb24ocmVjdCwgdHJhbnNmb3JtLCBtYXRyaXgpIHtcbiAgICAgIHRoaXMucmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgIGlmICh0aGlzLmJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtLmFwcGx5KHRoaXMuY3R4LCB0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuY3VycmVudCA9IG5ldyBDYW52YXNFeHRyYVN0YXRlKCk7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlY3QpICYmIHJlY3QubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3RbMl0gLSByZWN0WzBdO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdFszXSAtIHJlY3RbMV07XG4gICAgICAgIHRoaXMuY3R4LnJlY3QocmVjdFswXSwgcmVjdFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuY2xpcCgpO1xuICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmFuc2Zvcm0uYXBwbHkodGhpcywgdHJhbnNmb3JtKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtLmFwcGx5KHRoaXMsIG1hdHJpeCk7XG4gICAgfSxcbiAgICBlbmRBbm5vdGF0aW9uOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRBbm5vdGF0aW9uKCkge30sXG4gICAgcGFpbnRKcGVnWE9iamVjdDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcGFpbnRKcGVnWE9iamVjdChvYmpJZCwgdywgaCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRvbUltYWdlID0gdGhpcy5wcm9jZXNzaW5nVHlwZTMgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KG9iaklkKSA6IHRoaXMub2Jqcy5nZXQob2JqSWQpO1xuXG4gICAgICBpZiAoIWRvbUltYWdlKSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguc2NhbGUoMSAvIHcsIC0xIC8gaCk7XG4gICAgICBjdHguZHJhd0ltYWdlKGRvbUltYWdlLCAwLCAwLCBkb21JbWFnZS53aWR0aCwgZG9tSW1hZ2UuaGVpZ2h0LCAwLCAtaCwgdywgaCk7XG5cbiAgICAgIGlmICh0aGlzLmltYWdlTGF5ZXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUcmFuc2Zvcm0gPSBjdHgubW96Q3VycmVudFRyYW5zZm9ybUludmVyc2U7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0Q2FudmFzUG9zaXRpb24oMCwgMCk7XG4gICAgICAgIHRoaXMuaW1hZ2VMYXllci5hcHBlbmRJbWFnZSh7XG4gICAgICAgICAgb2JqSWQ6IG9iaklkLFxuICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uWzBdLFxuICAgICAgICAgIHRvcDogcG9zaXRpb25bMV0sXG4gICAgICAgICAgd2lkdGg6IHcgLyBjdXJyZW50VHJhbnNmb3JtWzBdLFxuICAgICAgICAgIGhlaWdodDogaCAvIGN1cnJlbnRUcmFuc2Zvcm1bM11cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19wYWludEltYWdlTWFza1hPYmplY3QoaW1nKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgd2lkdGggPSBpbWcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgIHZhciBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgICAgdmFyIGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgICB2YXIgZ2x5cGggPSB0aGlzLnByb2Nlc3NpbmdUeXBlMztcblxuICAgICAgaWYgKENPTVBJTEVfVFlQRTNfR0xZUEhTICYmIGdseXBoICYmIGdseXBoLmNvbXBpbGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHdpZHRoIDw9IE1BWF9TSVpFX1RPX0NPTVBJTEUgJiYgaGVpZ2h0IDw9IE1BWF9TSVpFX1RPX0NPTVBJTEUpIHtcbiAgICAgICAgICBnbHlwaC5jb21waWxlZCA9IGNvbXBpbGVUeXBlM0dseXBoKHtcbiAgICAgICAgICAgIGRhdGE6IGltZy5kYXRhLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbHlwaC5jb21waWxlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdseXBoICE9PSBudWxsICYmIGdseXBoICE9PSB2b2lkIDAgJiYgZ2x5cGguY29tcGlsZWQpIHtcbiAgICAgICAgZ2x5cGguY29tcGlsZWQoY3R4KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBtYXNrQ3R4ID0gbWFza0NhbnZhcy5jb250ZXh0O1xuICAgICAgbWFza0N0eC5zYXZlKCk7XG4gICAgICBwdXRCaW5hcnlJbWFnZU1hc2sobWFza0N0eCwgaW1nKTtcbiAgICAgIG1hc2tDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtaW5cIjtcbiAgICAgIG1hc2tDdHguZmlsbFN0eWxlID0gaXNQYXR0ZXJuRmlsbCA/IGZpbGxDb2xvci5nZXRQYXR0ZXJuKG1hc2tDdHgsIHRoaXMpIDogZmlsbENvbG9yO1xuICAgICAgbWFza0N0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIG1hc2tDdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChtYXNrQ2FudmFzLmNhbnZhcyk7XG4gICAgfSxcbiAgICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQ6IGZ1bmN0aW9uIHBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdChpbWdEYXRhLCBzY2FsZVgpIHtcbiAgICAgIHZhciBza2V3WCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHZhciBza2V3WSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICAgIHZhciBzY2FsZVkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBwb3NpdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIHZhciBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgICAgdmFyIGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgICB2YXIgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBtYXNrQ3R4ID0gbWFza0NhbnZhcy5jb250ZXh0O1xuICAgICAgbWFza0N0eC5zYXZlKCk7XG4gICAgICBwdXRCaW5hcnlJbWFnZU1hc2sobWFza0N0eCwgaW1nRGF0YSk7XG4gICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihtYXNrQ3R4LCB0aGlzKSA6IGZpbGxDb2xvcjtcbiAgICAgIG1hc2tDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybShzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCBwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV0pO1xuICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKG1hc2tDYW52YXMuY2FudmFzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAtMSwgMSwgMSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYWludEltYWdlTWFza1hPYmplY3RHcm91cDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXAoaW1hZ2VzKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICAgIHZhciBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBpbWFnZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB2YXIgaW1hZ2UgPSBpbWFnZXNbaV07XG4gICAgICAgIHZhciB3aWR0aCA9IGltYWdlLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICB2YXIgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIG1hc2tDdHggPSBtYXNrQ2FudmFzLmNvbnRleHQ7XG4gICAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgICBwdXRCaW5hcnlJbWFnZU1hc2sobWFza0N0eCwgaW1hZ2UpO1xuICAgICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgICAgIG1hc2tDdHguZmlsbFN0eWxlID0gaXNQYXR0ZXJuRmlsbCA/IGZpbGxDb2xvci5nZXRQYXR0ZXJuKG1hc2tDdHgsIHRoaXMpIDogZmlsbENvbG9yO1xuICAgICAgICBtYXNrQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIGltYWdlLnRyYW5zZm9ybSk7XG4gICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcy5jYW52YXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIC0xLCAxLCAxKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhaW50SW1hZ2VYT2JqZWN0OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19wYWludEltYWdlWE9iamVjdChvYmpJZCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGltZ0RhdGEgPSBvYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KG9iaklkKSA6IHRoaXMub2Jqcy5nZXQob2JqSWQpO1xuXG4gICAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEpO1xuICAgIH0sXG4gICAgcGFpbnRJbWFnZVhPYmplY3RSZXBlYXQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3BhaW50SW1hZ2VYT2JqZWN0UmVwZWF0KG9iaklkLCBzY2FsZVgsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nRGF0YSA9IG9iaklkLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IHRoaXMuY29tbW9uT2Jqcy5nZXQob2JqSWQpIDogdGhpcy5vYmpzLmdldChvYmpJZCk7XG5cbiAgICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgbWFwID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IFtzY2FsZVgsIDAsIDAsIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdXSxcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgdzogd2lkdGgsXG4gICAgICAgICAgaDogaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAoaW1nRGF0YSwgbWFwKTtcbiAgICB9LFxuICAgIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19wYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICBjdHguc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgICB2YXIgY3VycmVudFRyYW5zZm9ybSA9IGN0eC5tb3pDdXJyZW50VHJhbnNmb3JtSW52ZXJzZTtcbiAgICAgIHZhciB3aWR0aFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChjdXJyZW50VHJhbnNmb3JtWzBdLCBjdXJyZW50VHJhbnNmb3JtWzFdKSwgMSk7XG4gICAgICB2YXIgaGVpZ2h0U2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGN1cnJlbnRUcmFuc2Zvcm1bMl0sIGN1cnJlbnRUcmFuc2Zvcm1bM10pLCAxKTtcbiAgICAgIHZhciBpbWdUb1BhaW50LCB0bXBDYW52YXMsIHRtcEN0eDtcblxuICAgICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCAhaW1nRGF0YS5kYXRhKSB7XG4gICAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICAgIHB1dEJpbmFyeUltYWdlRGF0YSh0bXBDdHgsIGltZ0RhdGEsIHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMpO1xuICAgICAgICBpbWdUb1BhaW50ID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgIH1cblxuICAgICAgdmFyIHBhaW50V2lkdGggPSB3aWR0aCxcbiAgICAgICAgICBwYWludEhlaWdodCA9IGhlaWdodDtcbiAgICAgIHZhciB0bXBDYW52YXNJZCA9IFwicHJlc2NhbGUxXCI7XG5cbiAgICAgIHdoaWxlICh3aWR0aFNjYWxlID4gMiAmJiBwYWludFdpZHRoID4gMSB8fCBoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICAgIHZhciBuZXdXaWR0aCA9IHBhaW50V2lkdGgsXG4gICAgICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodDtcblxuICAgICAgICBpZiAod2lkdGhTY2FsZSA+IDIgJiYgcGFpbnRXaWR0aCA+IDEpIHtcbiAgICAgICAgICBuZXdXaWR0aCA9IE1hdGguY2VpbChwYWludFdpZHRoIC8gMik7XG4gICAgICAgICAgd2lkdGhTY2FsZSAvPSBwYWludFdpZHRoIC8gbmV3V2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgICAgIG5ld0hlaWdodCA9IE1hdGguY2VpbChwYWludEhlaWdodCAvIDIpO1xuICAgICAgICAgIGhlaWdodFNjYWxlIC89IHBhaW50SGVpZ2h0IC8gbmV3SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXModG1wQ2FudmFzSWQsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgICB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgdG1wQ3R4LmRyYXdJbWFnZShpbWdUb1BhaW50LCAwLCAwLCBwYWludFdpZHRoLCBwYWludEhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICAgIGltZ1RvUGFpbnQgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgICAgICBwYWludFdpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgIHBhaW50SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICB0bXBDYW52YXNJZCA9IHRtcENhbnZhc0lkID09PSBcInByZXNjYWxlMVwiID8gXCJwcmVzY2FsZTJcIiA6IFwicHJlc2NhbGUxXCI7XG4gICAgICB9XG5cbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nVG9QYWludCwgMCwgMCwgcGFpbnRXaWR0aCwgcGFpbnRIZWlnaHQsIDAsIC1oZWlnaHQsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBpZiAodGhpcy5pbWFnZUxheWVyKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0Q2FudmFzUG9zaXRpb24oMCwgLWhlaWdodCk7XG4gICAgICAgIHRoaXMuaW1hZ2VMYXllci5hcHBlbmRJbWFnZSh7XG4gICAgICAgICAgaW1nRGF0YTogaW1nRGF0YSxcbiAgICAgICAgICBsZWZ0OiBwb3NpdGlvblswXSxcbiAgICAgICAgICB0b3A6IHBvc2l0aW9uWzFdLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIGN1cnJlbnRUcmFuc2Zvcm1bMF0sXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLyBjdXJyZW50VHJhbnNmb3JtWzNdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXA6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3BhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAoaW1nRGF0YSwgbWFwKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgdyA9IGltZ0RhdGEud2lkdGg7XG4gICAgICB2YXIgaCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgICAgdmFyIHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgdywgaCk7XG4gICAgICB2YXIgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhLCB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbWFwLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gbWFwW2ldO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgZW50cnkudHJhbnNmb3JtKTtcbiAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0bXBDYW52YXMuY2FudmFzLCBlbnRyeS54LCBlbnRyeS55LCBlbnRyeS53LCBlbnRyeS5oLCAwLCAtMSwgMSwgMSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VMYXllcikge1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0Q2FudmFzUG9zaXRpb24oZW50cnkueCwgZW50cnkueSk7XG4gICAgICAgICAgdGhpcy5pbWFnZUxheWVyLmFwcGVuZEltYWdlKHtcbiAgICAgICAgICAgIGltZ0RhdGE6IGltZ0RhdGEsXG4gICAgICAgICAgICBsZWZ0OiBwb3NpdGlvblswXSxcbiAgICAgICAgICAgIHRvcDogcG9zaXRpb25bMV0sXG4gICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgIGhlaWdodDogaFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhaW50U29saWRDb2xvckltYWdlTWFzazogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgfSxcbiAgICBtYXJrUG9pbnQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX21hcmtQb2ludCh0YWcpIHt9LFxuICAgIG1hcmtQb2ludFByb3BzOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19tYXJrUG9pbnRQcm9wcyh0YWcsIHByb3BlcnRpZXMpIHt9LFxuICAgIGJlZ2luTWFya2VkQ29udGVudDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfYmVnaW5NYXJrZWRDb250ZW50KHRhZykge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5jdHguYmVnaW5NYXJrZWRDb250ZW50KSB7XG4gICAgICAgIHRoaXMuY3R4LmJlZ2luTWFya2VkQ29udGVudCh0YWcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYmVnaW5NYXJrZWRDb250ZW50UHJvcHM6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luTWFya2VkQ29udGVudFByb3BzKHRhZywgcHJvcGVydGllcykge1xuICAgICAgaWYgKHRhZyA9PT0gXCJPQ1wiKSB7XG4gICAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICAgIHZpc2libGU6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLmlzVmlzaWJsZShwcm9wZXJ0aWVzKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5jdHguYmVnaW5NYXJrZWRDb250ZW50UHJvcHMpIHtcbiAgICAgICAgdGhpcy5jdHguYmVnaW5NYXJrZWRDb250ZW50UHJvcHModGFnLCBwcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuZE1hcmtlZENvbnRlbnQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZE1hcmtlZENvbnRlbnQoKSB7XG4gICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5jdHguZW5kTWFya2VkQ29udGVudCkge1xuICAgICAgICB0aGlzLmN0eC5lbmRNYXJrZWRDb250ZW50KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRDdXJyZW50T3BlcmF0b3JJbmRleDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0Q3VycmVudE9wZXJhdG9ySW5kZXgoaW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLmN0eC5zZXRDdXJyZW50T3BlcmF0b3JJbmRleCkge1xuICAgICAgICB0aGlzLmN0eC5zZXRDdXJyZW50T3BlcmF0b3JJbmRleChpbmRleCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWdpbkNvbXBhdDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfYmVnaW5Db21wYXQoKSB7fSxcbiAgICBlbmRDb21wYXQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZENvbXBhdCgpIHt9LFxuICAgIGNvbnN1bWVQYXRoOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19jb25zdW1lUGF0aCgpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcblxuICAgICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NsaXAgPT09IEVPX0NMSVApIHtcbiAgICAgICAgICBjdHguY2xpcChcImV2ZW5vZGRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgfSxcbiAgICBnZXRTaW5nbGVQaXhlbFdpZHRoOiBmdW5jdGlvbiBnZXRTaW5nbGVQaXhlbFdpZHRoKCkge1xuICAgICAgaWYgKHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IDFlLTEwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aDtcbiAgICB9LFxuICAgIGdldENhbnZhc1Bvc2l0aW9uOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19nZXRDYW52YXNQb3NpdGlvbih4LCB5KSB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5jdHgubW96Q3VycmVudFRyYW5zZm9ybTtcbiAgICAgIHJldHVybiBbdHJhbnNmb3JtWzBdICogeCArIHRyYW5zZm9ybVsyXSAqIHkgKyB0cmFuc2Zvcm1bNF0sIHRyYW5zZm9ybVsxXSAqIHggKyB0cmFuc2Zvcm1bM10gKiB5ICsgdHJhbnNmb3JtWzVdXTtcbiAgICB9LFxuICAgIGlzQ29udGVudFZpc2libGU6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2lzQ29udGVudFZpc2libGUoKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5tYXJrZWRDb250ZW50U3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hcmtlZENvbnRlbnRTdGFja1tpXS52aXNpYmxlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBvcCBpbiBfdXRpbC5PUFMpIHtcbiAgICBDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbX3V0aWwuT1BTW29wXV0gPSBDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbb3BdO1xuICB9XG5cbiAgcmV0dXJuIENhbnZhc0dyYXBoaWNzO1xufSgpO1xuXG5leHBvcnRzLkNhbnZhc0dyYXBoaWNzID0gQ2FudmFzR3JhcGhpY3M7XG5cbi8qKiovIH0pLFxuLyogMTQxICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5nZXRTaGFkaW5nUGF0dGVybkZyb21JUiA9IGdldFNoYWRpbmdQYXR0ZXJuRnJvbUlSO1xuZXhwb3J0cy5UaWxpbmdQYXR0ZXJuID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xuXG52YXIgU2hhZGluZ0lScyA9IHt9O1xuXG5mdW5jdGlvbiBhcHBseUJvdW5kaW5nQm94KGN0eCwgYmJveCkge1xuICBpZiAoIWJib3ggfHwgdHlwZW9mIFBhdGgyRCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICB2YXIgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gIHZhciByZWdpb24gPSBuZXcgUGF0aDJEKCk7XG4gIHJlZ2lvbi5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICBjdHguY2xpcChyZWdpb24pO1xufVxuXG5TaGFkaW5nSVJzLlJhZGlhbEF4aWFsID0ge1xuICBmcm9tSVI6IGZ1bmN0aW9uIFJhZGlhbEF4aWFsX2Zyb21JUihyYXcpIHtcbiAgICB2YXIgdHlwZSA9IHJhd1sxXTtcbiAgICB2YXIgYmJveCA9IHJhd1syXTtcbiAgICB2YXIgY29sb3JTdG9wcyA9IHJhd1szXTtcbiAgICB2YXIgcDAgPSByYXdbNF07XG4gICAgdmFyIHAxID0gcmF3WzVdO1xuICAgIHZhciByMCA9IHJhd1s2XTtcbiAgICB2YXIgcjEgPSByYXdbN107XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFBhdHRlcm46IGZ1bmN0aW9uIFJhZGlhbEF4aWFsX2dldFBhdHRlcm4oY3R4KSB7XG4gICAgICAgIGFwcGx5Qm91bmRpbmdCb3goY3R4LCBiYm94KTtcbiAgICAgICAgdmFyIGdyYWQ7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiYXhpYWxcIikge1xuICAgICAgICAgIGdyYWQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQocDBbMF0sIHAwWzFdLCBwMVswXSwgcDFbMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwicmFkaWFsXCIpIHtcbiAgICAgICAgICBncmFkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHAwWzBdLCBwMFsxXSwgcjAsIHAxWzBdLCBwMVsxXSwgcjEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyYWQpIHtcbiAgICAgICAgICBncmFkLnJhd0RhdGEgPSByYXc7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb2xvclN0b3BzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICB2YXIgYyA9IGNvbG9yU3RvcHNbaV07XG4gICAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoY1swXSwgY1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JhZDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG52YXIgY3JlYXRlTWVzaENhbnZhcyA9IGZ1bmN0aW9uIGNyZWF0ZU1lc2hDYW52YXNDbG9zdXJlKCkge1xuICBmdW5jdGlvbiBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcDEsIHAyLCBwMywgYzEsIGMyLCBjMykge1xuICAgIHZhciBjb29yZHMgPSBjb250ZXh0LmNvb3JkcyxcbiAgICAgICAgY29sb3JzID0gY29udGV4dC5jb2xvcnM7XG4gICAgdmFyIGJ5dGVzID0gZGF0YS5kYXRhLFxuICAgICAgICByb3dTaXplID0gZGF0YS53aWR0aCAqIDQ7XG4gICAgdmFyIHRtcDtcblxuICAgIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgICB0bXAgPSBwMTtcbiAgICAgIHAxID0gcDI7XG4gICAgICBwMiA9IHRtcDtcbiAgICAgIHRtcCA9IGMxO1xuICAgICAgYzEgPSBjMjtcbiAgICAgIGMyID0gdG1wO1xuICAgIH1cblxuICAgIGlmIChjb29yZHNbcDIgKyAxXSA+IGNvb3Jkc1twMyArIDFdKSB7XG4gICAgICB0bXAgPSBwMjtcbiAgICAgIHAyID0gcDM7XG4gICAgICBwMyA9IHRtcDtcbiAgICAgIHRtcCA9IGMyO1xuICAgICAgYzIgPSBjMztcbiAgICAgIGMzID0gdG1wO1xuICAgIH1cblxuICAgIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgICB0bXAgPSBwMTtcbiAgICAgIHAxID0gcDI7XG4gICAgICBwMiA9IHRtcDtcbiAgICAgIHRtcCA9IGMxO1xuICAgICAgYzEgPSBjMjtcbiAgICAgIGMyID0gdG1wO1xuICAgIH1cblxuICAgIHZhciB4MSA9IChjb29yZHNbcDFdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICAgIHZhciB5MSA9IChjb29yZHNbcDEgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgICB2YXIgeDIgPSAoY29vcmRzW3AyXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgICB2YXIgeTIgPSAoY29vcmRzW3AyICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gICAgdmFyIHgzID0gKGNvb3Jkc1twM10gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gICAgdmFyIHkzID0gKGNvb3Jkc1twMyArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuXG4gICAgaWYgKHkxID49IHkzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGMxciA9IGNvbG9yc1tjMV0sXG4gICAgICAgIGMxZyA9IGNvbG9yc1tjMSArIDFdLFxuICAgICAgICBjMWIgPSBjb2xvcnNbYzEgKyAyXTtcbiAgICB2YXIgYzJyID0gY29sb3JzW2MyXSxcbiAgICAgICAgYzJnID0gY29sb3JzW2MyICsgMV0sXG4gICAgICAgIGMyYiA9IGNvbG9yc1tjMiArIDJdO1xuICAgIHZhciBjM3IgPSBjb2xvcnNbYzNdLFxuICAgICAgICBjM2cgPSBjb2xvcnNbYzMgKyAxXSxcbiAgICAgICAgYzNiID0gY29sb3JzW2MzICsgMl07XG4gICAgdmFyIG1pblkgPSBNYXRoLnJvdW5kKHkxKSxcbiAgICAgICAgbWF4WSA9IE1hdGgucm91bmQoeTMpO1xuICAgIHZhciB4YSwgY2FyLCBjYWcsIGNhYjtcbiAgICB2YXIgeGIsIGNiciwgY2JnLCBjYmI7XG5cbiAgICBmb3IgKHZhciB5ID0gbWluWTsgeSA8PSBtYXhZOyB5KyspIHtcbiAgICAgIGlmICh5IDwgeTIpIHtcbiAgICAgICAgdmFyIF9rID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh5IDwgeTEpIHtcbiAgICAgICAgICBfayA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoeTEgPT09IHkyKSB7XG4gICAgICAgICAgX2sgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9rID0gKHkxIC0geSkgLyAoeTEgLSB5Mik7XG4gICAgICAgIH1cblxuICAgICAgICB4YSA9IHgxIC0gKHgxIC0geDIpICogX2s7XG4gICAgICAgIGNhciA9IGMxciAtIChjMXIgLSBjMnIpICogX2s7XG4gICAgICAgIGNhZyA9IGMxZyAtIChjMWcgLSBjMmcpICogX2s7XG4gICAgICAgIGNhYiA9IGMxYiAtIChjMWIgLSBjMmIpICogX2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2syID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh5ID4geTMpIHtcbiAgICAgICAgICBfazIgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHkyID09PSB5Mykge1xuICAgICAgICAgIF9rMiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2syID0gKHkyIC0geSkgLyAoeTIgLSB5Myk7XG4gICAgICAgIH1cblxuICAgICAgICB4YSA9IHgyIC0gKHgyIC0geDMpICogX2syO1xuICAgICAgICBjYXIgPSBjMnIgLSAoYzJyIC0gYzNyKSAqIF9rMjtcbiAgICAgICAgY2FnID0gYzJnIC0gKGMyZyAtIGMzZykgKiBfazI7XG4gICAgICAgIGNhYiA9IGMyYiAtIChjMmIgLSBjM2IpICogX2syO1xuICAgICAgfVxuXG4gICAgICB2YXIgayA9IHZvaWQgMDtcblxuICAgICAgaWYgKHkgPCB5MSkge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IHkzKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9ICh5MSAtIHkpIC8gKHkxIC0geTMpO1xuICAgICAgfVxuXG4gICAgICB4YiA9IHgxIC0gKHgxIC0geDMpICogaztcbiAgICAgIGNiciA9IGMxciAtIChjMXIgLSBjM3IpICogaztcbiAgICAgIGNiZyA9IGMxZyAtIChjMWcgLSBjM2cpICogaztcbiAgICAgIGNiYiA9IGMxYiAtIChjMWIgLSBjM2IpICogaztcbiAgICAgIHZhciB4MV8gPSBNYXRoLnJvdW5kKE1hdGgubWluKHhhLCB4YikpO1xuICAgICAgdmFyIHgyXyA9IE1hdGgucm91bmQoTWF0aC5tYXgoeGEsIHhiKSk7XG4gICAgICB2YXIgaiA9IHJvd1NpemUgKiB5ICsgeDFfICogNDtcblxuICAgICAgZm9yICh2YXIgeCA9IHgxXzsgeCA8PSB4Ml87IHgrKykge1xuICAgICAgICBrID0gKHhhIC0geCkgLyAoeGEgLSB4Yik7XG5cbiAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgayA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoayA+IDEpIHtcbiAgICAgICAgICBrID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ5dGVzW2orK10gPSBjYXIgLSAoY2FyIC0gY2JyKSAqIGsgfCAwO1xuICAgICAgICBieXRlc1tqKytdID0gY2FnIC0gKGNhZyAtIGNiZykgKiBrIHwgMDtcbiAgICAgICAgYnl0ZXNbaisrXSA9IGNhYiAtIChjYWIgLSBjYmIpICogayB8IDA7XG4gICAgICAgIGJ5dGVzW2orK10gPSAyNTU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpIHtcbiAgICB2YXIgcHMgPSBmaWd1cmUuY29vcmRzO1xuICAgIHZhciBjcyA9IGZpZ3VyZS5jb2xvcnM7XG4gICAgdmFyIGksIGlpO1xuXG4gICAgc3dpdGNoIChmaWd1cmUudHlwZSkge1xuICAgICAgY2FzZSBcImxhdHRpY2VcIjpcbiAgICAgICAgdmFyIHZlcnRpY2VzUGVyUm93ID0gZmlndXJlLnZlcnRpY2VzUGVyUm93O1xuICAgICAgICB2YXIgcm93cyA9IE1hdGguZmxvb3IocHMubGVuZ3RoIC8gdmVydGljZXNQZXJSb3cpIC0gMTtcbiAgICAgICAgdmFyIGNvbHMgPSB2ZXJ0aWNlc1BlclJvdyAtIDE7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgIHZhciBxID0gaSAqIHZlcnRpY2VzUGVyUm93O1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2xzOyBqKyssIHErKykge1xuICAgICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3FdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3FdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwidHJpYW5nbGVzXCI6XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gcHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1tpXSwgcHNbaSArIDFdLCBwc1tpICsgMl0sIGNzW2ldLCBjc1tpICsgMV0sIGNzW2kgKyAyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBmaWd1cmVcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTWVzaENhbnZhcyhib3VuZHMsIGNvbWJpbmVzU2NhbGUsIGNvb3JkcywgY29sb3JzLCBmaWd1cmVzLCBiYWNrZ3JvdW5kQ29sb3IsIGNhY2hlZENhbnZhc2VzLCB3ZWJHTENvbnRleHQpIHtcbiAgICB2YXIgRVhQRUNURURfU0NBTEUgPSAxLjE7XG4gICAgdmFyIE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuICAgIHZhciBCT1JERVJfU0laRSA9IDI7XG4gICAgdmFyIG9mZnNldFggPSBNYXRoLmZsb29yKGJvdW5kc1swXSk7XG4gICAgdmFyIG9mZnNldFkgPSBNYXRoLmZsb29yKGJvdW5kc1sxXSk7XG4gICAgdmFyIGJvdW5kc1dpZHRoID0gTWF0aC5jZWlsKGJvdW5kc1syXSkgLSBvZmZzZXRYO1xuICAgIHZhciBib3VuZHNIZWlnaHQgPSBNYXRoLmNlaWwoYm91bmRzWzNdKSAtIG9mZnNldFk7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc1dpZHRoICogY29tYmluZXNTY2FsZVswXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIHZhciBoZWlnaHQgPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzSGVpZ2h0ICogY29tYmluZXNTY2FsZVsxXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIHZhciBzY2FsZVggPSBib3VuZHNXaWR0aCAvIHdpZHRoO1xuICAgIHZhciBzY2FsZVkgPSBib3VuZHNIZWlnaHQgLyBoZWlnaHQ7XG4gICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgIGNvbG9yczogY29sb3JzLFxuICAgICAgb2Zmc2V0WDogLW9mZnNldFgsXG4gICAgICBvZmZzZXRZOiAtb2Zmc2V0WSxcbiAgICAgIHNjYWxlWDogMSAvIHNjYWxlWCxcbiAgICAgIHNjYWxlWTogMSAvIHNjYWxlWVxuICAgIH07XG4gICAgdmFyIHBhZGRlZFdpZHRoID0gd2lkdGggKyBCT1JERVJfU0laRSAqIDI7XG4gICAgdmFyIHBhZGRlZEhlaWdodCA9IGhlaWdodCArIEJPUkRFUl9TSVpFICogMjtcbiAgICB2YXIgY2FudmFzLCB0bXBDYW52YXMsIGksIGlpO1xuXG4gICAgaWYgKHdlYkdMQ29udGV4dC5pc0VuYWJsZWQpIHtcbiAgICAgIGNhbnZhcyA9IHdlYkdMQ29udGV4dC5kcmF3RmlndXJlcyh7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBmaWd1cmVzOiBmaWd1cmVzLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICB9KTtcbiAgICAgIHRtcENhbnZhcyA9IGNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1lc2hcIiwgcGFkZGVkV2lkdGgsIHBhZGRlZEhlaWdodCwgZmFsc2UpO1xuICAgICAgdG1wQ2FudmFzLmNvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgQk9SREVSX1NJWkUsIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNhbnZhcyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcENhbnZhcyA9IGNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1lc2hcIiwgcGFkZGVkV2lkdGgsIHBhZGRlZEhlaWdodCwgZmFsc2UpO1xuICAgICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdmFyIGRhdGEgPSB0bXBDdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHZhciBieXRlcyA9IGRhdGEuZGF0YTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGJ5dGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgICAgICBieXRlc1tpXSA9IGJhY2tncm91bmRDb2xvclswXTtcbiAgICAgICAgICBieXRlc1tpICsgMV0gPSBiYWNrZ3JvdW5kQ29sb3JbMV07XG4gICAgICAgICAgYnl0ZXNbaSArIDJdID0gYmFja2dyb3VuZENvbG9yWzJdO1xuICAgICAgICAgIGJ5dGVzW2kgKyAzXSA9IDI1NTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZmlndXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZXNbaV0sIGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB0bXBDdHgucHV0SW1hZ2VEYXRhKGRhdGEsIEJPUkRFUl9TSVpFLCBCT1JERVJfU0laRSk7XG4gICAgICBjYW52YXMgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgIG9mZnNldFg6IG9mZnNldFggLSBCT1JERVJfU0laRSAqIHNjYWxlWCxcbiAgICAgIG9mZnNldFk6IG9mZnNldFkgLSBCT1JERVJfU0laRSAqIHNjYWxlWSxcbiAgICAgIHNjYWxlWDogc2NhbGVYLFxuICAgICAgc2NhbGVZOiBzY2FsZVlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZU1lc2hDYW52YXM7XG59KCk7XG5cblNoYWRpbmdJUnMuTWVzaCA9IHtcbiAgZnJvbUlSOiBmdW5jdGlvbiBNZXNoX2Zyb21JUihyYXcpIHtcbiAgICB2YXIgY29vcmRzID0gcmF3WzJdO1xuICAgIHZhciBjb2xvcnMgPSByYXdbM107XG4gICAgdmFyIGZpZ3VyZXMgPSByYXdbNF07XG4gICAgdmFyIGJvdW5kcyA9IHJhd1s1XTtcbiAgICB2YXIgbWF0cml4ID0gcmF3WzZdO1xuICAgIHZhciBiYm94ID0gcmF3WzddO1xuICAgIHZhciBiYWNrZ3JvdW5kID0gcmF3WzhdO1xuICAgIHJldHVybiB7XG4gICAgICBnZXRQYXR0ZXJuOiBmdW5jdGlvbiBNZXNoX2dldFBhdHRlcm4oY3R4LCBvd25lciwgc2hhZGluZ0ZpbGwpIHtcbiAgICAgICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIGJib3gpO1xuICAgICAgICB2YXIgc2NhbGU7XG5cbiAgICAgICAgaWYgKHNoYWRpbmdGaWxsKSB7XG4gICAgICAgICAgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKGN0eC5tb3pDdXJyZW50VHJhbnNmb3JtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUob3duZXIuYmFzZVRyYW5zZm9ybSk7XG5cbiAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICB2YXIgbWF0cml4U2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG1hdHJpeCk7XG5cbiAgICAgICAgICAgIHNjYWxlID0gW3NjYWxlWzBdICogbWF0cml4U2NhbGVbMF0sIHNjYWxlWzFdICogbWF0cml4U2NhbGVbMV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gY3JlYXRlTWVzaENhbnZhcyhib3VuZHMsIHNjYWxlLCBjb29yZHMsIGNvbG9ycywgZmlndXJlcywgc2hhZGluZ0ZpbGwgPyBudWxsIDogYmFja2dyb3VuZCwgb3duZXIuY2FjaGVkQ2FudmFzZXMsIG93bmVyLndlYkdMQ29udGV4dCk7XG5cbiAgICAgICAgaWYgKCFzaGFkaW5nRmlsbCkge1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0uYXBwbHkoY3R4LCBvd25lci5iYXNlVHJhbnNmb3JtKTtcblxuICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCBtYXRyaXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgICAgICBjdHguc2NhbGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICAgICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcIm5vLXJlcGVhdFwiKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuU2hhZGluZ0lScy5EdW1teSA9IHtcbiAgZnJvbUlSOiBmdW5jdGlvbiBEdW1teV9mcm9tSVIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFBhdHRlcm46IGZ1bmN0aW9uIER1bW15X2Zyb21JUl9nZXRQYXR0ZXJuKCkge1xuICAgICAgICByZXR1cm4gXCJob3RwaW5rXCI7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0U2hhZGluZ1BhdHRlcm5Gcm9tSVIocmF3KSB7XG4gIHZhciBzaGFkaW5nSVIgPSBTaGFkaW5nSVJzW3Jhd1swXV07XG5cbiAgaWYgKCFzaGFkaW5nSVIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIElSIHR5cGU6IFwiLmNvbmNhdChyYXdbMF0pKTtcbiAgfVxuXG4gIHJldHVybiBzaGFkaW5nSVIuZnJvbUlSKHJhdyk7XG59XG5cbnZhciBUaWxpbmdQYXR0ZXJuID0gZnVuY3Rpb24gVGlsaW5nUGF0dGVybkNsb3N1cmUoKSB7XG4gIHZhciBQYWludFR5cGUgPSB7XG4gICAgQ09MT1JFRDogMSxcbiAgICBVTkNPTE9SRUQ6IDJcbiAgfTtcbiAgdmFyIE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuXG4gIGZ1bmN0aW9uIFRpbGluZ1BhdHRlcm4oSVIsIGNvbG9yLCBjdHgsIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSwgYmFzZVRyYW5zZm9ybSkge1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gSVJbMl07XG4gICAgdGhpcy5tYXRyaXggPSBJUlszXSB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgdGhpcy5iYm94ID0gSVJbNF07XG4gICAgdGhpcy54c3RlcCA9IElSWzVdO1xuICAgIHRoaXMueXN0ZXAgPSBJUls2XTtcbiAgICB0aGlzLnBhaW50VHlwZSA9IElSWzddO1xuICAgIHRoaXMudGlsaW5nVHlwZSA9IElSWzhdO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICB9XG5cbiAgVGlsaW5nUGF0dGVybi5wcm90b3R5cGUgPSB7XG4gICAgY3JlYXRlUGF0dGVybkNhbnZhczogZnVuY3Rpb24gVGlsaW5QYXR0ZXJuX2NyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIpIHtcbiAgICAgIHZhciBvcGVyYXRvckxpc3QgPSB0aGlzLm9wZXJhdG9yTGlzdDtcbiAgICAgIHZhciBiYm94ID0gdGhpcy5iYm94O1xuICAgICAgdmFyIHhzdGVwID0gdGhpcy54c3RlcDtcbiAgICAgIHZhciB5c3RlcCA9IHRoaXMueXN0ZXA7XG4gICAgICB2YXIgcGFpbnRUeXBlID0gdGhpcy5wYWludFR5cGU7XG4gICAgICB2YXIgdGlsaW5nVHlwZSA9IHRoaXMudGlsaW5nVHlwZTtcbiAgICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICB2YXIgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0gdGhpcy5jYW52YXNHcmFwaGljc0ZhY3Rvcnk7XG4gICAgICAoMCwgX3V0aWwuaW5mbykoXCJUaWxpbmdUeXBlOiBcIiArIHRpbGluZ1R5cGUpO1xuICAgICAgdmFyIHgwID0gYmJveFswXSxcbiAgICAgICAgICB5MCA9IGJib3hbMV0sXG4gICAgICAgICAgeDEgPSBiYm94WzJdLFxuICAgICAgICAgIHkxID0gYmJveFszXTtcblxuICAgICAgdmFyIG1hdHJpeFNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLm1hdHJpeCk7XG5cbiAgICAgIHZhciBjdXJNYXRyaXhTY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5iYXNlVHJhbnNmb3JtKTtcblxuICAgICAgdmFyIGNvbWJpbmVkU2NhbGUgPSBbbWF0cml4U2NhbGVbMF0gKiBjdXJNYXRyaXhTY2FsZVswXSwgbWF0cml4U2NhbGVbMV0gKiBjdXJNYXRyaXhTY2FsZVsxXV07XG4gICAgICB2YXIgZGlteCA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKHhzdGVwLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIGNvbWJpbmVkU2NhbGVbMF0pO1xuICAgICAgdmFyIGRpbXkgPSB0aGlzLmdldFNpemVBbmRTY2FsZSh5c3RlcCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCwgY29tYmluZWRTY2FsZVsxXSk7XG4gICAgICB2YXIgdG1wQ2FudmFzID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVyblwiLCBkaW14LnNpemUsIGRpbXkuc2l6ZSwgdHJ1ZSk7XG4gICAgICB2YXIgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICB2YXIgZ3JhcGhpY3MgPSBjYW52YXNHcmFwaGljc0ZhY3RvcnkuY3JlYXRlQ2FudmFzR3JhcGhpY3ModG1wQ3R4KTtcbiAgICAgIGdyYXBoaWNzLmdyb3VwTGV2ZWwgPSBvd25lci5ncm91cExldmVsO1xuICAgICAgdGhpcy5zZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQoZ3JhcGhpY3MsIHBhaW50VHlwZSwgY29sb3IpO1xuICAgICAgZ3JhcGhpY3MudHJhbnNmb3JtKGRpbXguc2NhbGUsIDAsIDAsIGRpbXkuc2NhbGUsIDAsIDApO1xuICAgICAgZ3JhcGhpY3MudHJhbnNmb3JtKDEsIDAsIDAsIDEsIC14MCwgLXkwKTtcbiAgICAgIHRoaXMuY2xpcEJib3goZ3JhcGhpY3MsIGJib3gsIHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgIGdyYXBoaWNzLmV4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0KTtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCAxLCB4MCwgeTApO1xuICAgICAgdGhpcy5jdHguc2NhbGUoMSAvIGRpbXguc2NhbGUsIDEgLyBkaW15LnNjYWxlKTtcbiAgICAgIHJldHVybiB0bXBDYW52YXMuY2FudmFzO1xuICAgIH0sXG4gICAgZ2V0U2l6ZUFuZFNjYWxlOiBmdW5jdGlvbiBUaWxpbmdQYXR0ZXJuX2dldFNpemVBbmRTY2FsZShzdGVwLCByZWFsT3V0cHV0U2l6ZSwgc2NhbGUpIHtcbiAgICAgIHN0ZXAgPSBNYXRoLmFicyhzdGVwKTtcbiAgICAgIHZhciBtYXhTaXplID0gTWF0aC5tYXgoTUFYX1BBVFRFUk5fU0laRSwgcmVhbE91dHB1dFNpemUpO1xuICAgICAgdmFyIHNpemUgPSBNYXRoLmNlaWwoc3RlcCAqIHNjYWxlKTtcblxuICAgICAgaWYgKHNpemUgPj0gbWF4U2l6ZSkge1xuICAgICAgICBzaXplID0gbWF4U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjYWxlID0gc2l6ZSAvIHN0ZXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNsaXBCYm94OiBmdW5jdGlvbiBjbGlwQmJveChncmFwaGljcywgYmJveCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGJib3gpICYmIGJib3gubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHZhciBiYm94V2lkdGggPSB4MSAtIHgwO1xuICAgICAgICB2YXIgYmJveEhlaWdodCA9IHkxIC0geTA7XG4gICAgICAgIGdyYXBoaWNzLmN0eC5yZWN0KHgwLCB5MCwgYmJveFdpZHRoLCBiYm94SGVpZ2h0KTtcbiAgICAgICAgZ3JhcGhpY3MuY2xpcCgpO1xuICAgICAgICBncmFwaGljcy5lbmRQYXRoKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQ6IGZ1bmN0aW9uIHNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcikge1xuICAgICAgdmFyIGNvbnRleHQgPSBncmFwaGljcy5jdHgsXG4gICAgICAgICAgY3VycmVudCA9IGdyYXBoaWNzLmN1cnJlbnQ7XG5cbiAgICAgIHN3aXRjaCAocGFpbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgUGFpbnRUeXBlLkNPTE9SRUQ6XG4gICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICAgIGN1cnJlbnQuZmlsbENvbG9yID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGFpbnRUeXBlLlVOQ09MT1JFRDpcbiAgICAgICAgICB2YXIgY3NzQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdKTtcblxuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3NzQ29sb3I7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNzc0NvbG9yO1xuICAgICAgICAgIGN1cnJlbnQuZmlsbENvbG9yID0gY3NzQ29sb3I7XG4gICAgICAgICAgY3VycmVudC5zdHJva2VDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IF91dGlsLkZvcm1hdEVycm9yKFwiVW5zdXBwb3J0ZWQgcGFpbnQgdHlwZTogXCIuY29uY2F0KHBhaW50VHlwZSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UGF0dGVybjogZnVuY3Rpb24gVGlsaW5nUGF0dGVybl9nZXRQYXR0ZXJuKGN0eCwgb3duZXIpIHtcbiAgICAgIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY3R4LnNldFRyYW5zZm9ybS5hcHBseShjdHgsIHRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgdGhpcy5tYXRyaXgpO1xuICAgICAgdmFyIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSB0aGlzLmNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIpO1xuICAgICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMsIFwicmVwZWF0XCIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFRpbGluZ1BhdHRlcm47XG59KCk7XG5cbmV4cG9ydHMuVGlsaW5nUGF0dGVybiA9IFRpbGluZ1BhdHRlcm47XG5cbi8qKiovIH0pLFxuLyogMTQyICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5HbG9iYWxXb3JrZXJPcHRpb25zID0gdm9pZCAwO1xudmFyIEdsb2JhbFdvcmtlck9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0cy5HbG9iYWxXb3JrZXJPcHRpb25zID0gR2xvYmFsV29ya2VyT3B0aW9ucztcbkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydCA9IEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydDtcbkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID0gR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYztcblxuLyoqKi8gfSksXG4vKiAxNDMgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk1lc3NhZ2VIYW5kbGVyID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dfcGRmanNfcmVxdWlyZV9fKDIpKTtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgQ2FsbGJhY2tLaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBEQVRBOiAxLFxuICBFUlJPUjogMlxufTtcbnZhciBTdHJlYW1LaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBDQU5DRUw6IDEsXG4gIENBTkNFTF9DT01QTEVURTogMixcbiAgQ0xPU0U6IDMsXG4gIEVOUVVFVUU6IDQsXG4gIEVSUk9SOiA1LFxuICBQVUxMOiA2LFxuICBQVUxMX0NPTVBMRVRFOiA3LFxuICBTVEFSVF9DT01QTEVURTogOFxufTtcblxuZnVuY3Rpb24gd3JhcFJlYXNvbihyZWFzb24pIHtcbiAgaWYgKF90eXBlb2YocmVhc29uKSAhPT0gXCJvYmplY3RcIiB8fCByZWFzb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4gcmVhc29uO1xuICB9XG5cbiAgc3dpdGNoIChyZWFzb24ubmFtZSkge1xuICAgIGNhc2UgXCJBYm9ydEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSk7XG5cbiAgICBjYXNlIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKTtcblxuICAgIGNhc2UgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uc3RhdHVzKTtcblxuICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5rbm93bkVycm9yRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uZGV0YWlscyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5Vbmtub3duRXJyb3JFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi50b1N0cmluZygpKTtcbiAgfVxufVxuXG52YXIgTWVzc2FnZUhhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNZXNzYWdlSGFuZGxlcihzb3VyY2VOYW1lLCB0YXJnZXROYW1lLCBjb21PYmopIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc3NhZ2VIYW5kbGVyKTtcblxuICAgIHRoaXMuc291cmNlTmFtZSA9IHNvdXJjZU5hbWU7XG4gICAgdGhpcy50YXJnZXROYW1lID0gdGFyZ2V0TmFtZTtcbiAgICB0aGlzLmNvbU9iaiA9IGNvbU9iajtcbiAgICB0aGlzLmNhbGxiYWNrSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtSWQgPSAxO1xuICAgIHRoaXMucG9zdE1lc3NhZ2VUcmFuc2ZlcnMgPSB0cnVlO1xuICAgIHRoaXMuc3RyZWFtU2lua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aW9uSGFuZGxlciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB0aGlzLl9vbkNvbU9iak9uTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgICBpZiAoZGF0YS50YXJnZXROYW1lICE9PSBfdGhpcy5zb3VyY2VOYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuc3RyZWFtKSB7XG4gICAgICAgIF90aGlzLl9wcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFja0lkID0gZGF0YS5jYWxsYmFja0lkO1xuICAgICAgICB2YXIgY2FwYWJpbGl0eSA9IF90aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuXG4gICAgICAgIGlmICghY2FwYWJpbGl0eSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGNhbGxiYWNrIFwiLmNvbmNhdChjYWxsYmFja0lkKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgX3RoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG5cbiAgICAgICAgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5EQVRBKSB7XG4gICAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkVSUk9SKSB7XG4gICAgICAgICAgY2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2FsbGJhY2sgY2FzZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjdGlvbiA9IF90aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuXG4gICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFjdGlvbiBmcm9tIHdvcmtlcjogXCIuY29uY2F0KGRhdGEuYWN0aW9uKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrSWQpIHtcbiAgICAgICAgdmFyIGNiU291cmNlTmFtZSA9IF90aGlzLnNvdXJjZU5hbWU7XG4gICAgICAgIHZhciBjYlRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWU7XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShhY3Rpb24oZGF0YS5kYXRhKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBjYlNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiBjYlRhcmdldE5hbWUsXG4gICAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkRBVEEsXG4gICAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBjYlNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiBjYlRhcmdldE5hbWUsXG4gICAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkVSUk9SLFxuICAgICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuc3RyZWFtSWQpIHtcbiAgICAgICAgX3RoaXMuX2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhY3Rpb24oZGF0YS5kYXRhKTtcbiAgICB9O1xuXG4gICAgY29tT2JqLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uQ29tT2JqT25NZXNzYWdlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNZXNzYWdlSGFuZGxlciwgW3tcbiAgICBrZXk6IFwib25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oYWN0aW9uTmFtZSwgaGFuZGxlcikge1xuICAgICAgdmFyIGFoID0gdGhpcy5hY3Rpb25IYW5kbGVyO1xuXG4gICAgICBpZiAoYWhbYWN0aW9uTmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCBcXFwiXCIuY29uY2F0KGFjdGlvbk5hbWUsIFwiXFxcIlwiKSk7XG4gICAgICB9XG5cbiAgICAgIGFoW2FjdGlvbk5hbWVdID0gaGFuZGxlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgICAgdGhpcy5fcG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kV2l0aFByb21pc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZFdpdGhQcm9taXNlKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgICAgdmFyIGNhbGxiYWNrSWQgPSB0aGlzLmNhbGxiYWNrSWQrKztcbiAgICAgIHZhciBjYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXSA9IGNhcGFiaWxpdHk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3Bvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZTogdGhpcy50YXJnZXROYW1lLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgICBjYWxsYmFja0lkOiBjYWxsYmFja0lkLFxuICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGNhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFdpdGhTdHJlYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZFdpdGhTdHJlYW0oYWN0aW9uTmFtZSwgZGF0YSwgcXVldWVpbmdTdHJhdGVneSwgdHJhbnNmZXJzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHN0cmVhbUlkID0gdGhpcy5zdHJlYW1JZCsrO1xuICAgICAgdmFyIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWU7XG4gICAgICB2YXIgdGFyZ2V0TmFtZSA9IHRoaXMudGFyZ2V0TmFtZTtcbiAgICAgIHZhciBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIHZhciBzdGFydENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICAgICAgX3RoaXMyLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSA9IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IGNvbnRyb2xsZXIsXG4gICAgICAgICAgICBzdGFydENhbGw6IHN0YXJ0Q2FwYWJpbGl0eSxcbiAgICAgICAgICAgIHB1bGxDYWxsOiBudWxsLFxuICAgICAgICAgICAgY2FuY2VsQ2FsbDogbnVsbCxcbiAgICAgICAgICAgIGlzQ2xvc2VkOiBmYWxzZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGhpczIuX3Bvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWU6IHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiB0YXJnZXROYW1lLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgICAgfSwgdHJhbnNmZXJzKTtcblxuICAgICAgICAgIHJldHVybiBzdGFydENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVsbDogZnVuY3Rpb24gcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgdmFyIHB1bGxDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgICAgIF90aGlzMi5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0ucHVsbENhbGwgPSBwdWxsQ2FwYWJpbGl0eTtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZTogc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWU6IHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTCxcbiAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHB1bGxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKHJlYXNvbikge1xuICAgICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImNhbmNlbCBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG4gICAgICAgICAgdmFyIGNhbmNlbENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICAgICAgX3RoaXMyLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jYW5jZWxDYWxsID0gY2FuY2VsQ2FwYWJpbGl0eTtcbiAgICAgICAgICBfdGhpczIuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZTogc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWU6IHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gY2FuY2VsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICB9LCBxdWV1ZWluZ1N0cmF0ZWd5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVN0cmVhbVNpbmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgICB2YXIgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkO1xuICAgICAgdmFyIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWU7XG4gICAgICB2YXIgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZTtcbiAgICAgIHZhciBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICAgIHZhciBzdHJlYW1TaW5rID0ge1xuICAgICAgICBlbnF1ZXVlOiBmdW5jdGlvbiBlbnF1ZXVlKGNodW5rKSB7XG4gICAgICAgICAgdmFyIHNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICAgICAgdmFyIHRyYW5zZmVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGFzdERlc2lyZWRTaXplID0gdGhpcy5kZXNpcmVkU2l6ZTtcbiAgICAgICAgICB0aGlzLmRlc2lyZWRTaXplIC09IHNpemU7XG5cbiAgICAgICAgICBpZiAobGFzdERlc2lyZWRTaXplID4gMCAmJiB0aGlzLmRlc2lyZWRTaXplIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2lua0NhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICAgICAgICB0aGlzLnJlYWR5ID0gdGhpcy5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuX3Bvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWU6IHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVOUVVFVUUsXG4gICAgICAgICAgICBzdHJlYW1JZDogc3RyZWFtSWQsXG4gICAgICAgICAgICBjaHVuazogY2h1bmtcbiAgICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZTogc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWU6IHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0xPU0UsXG4gICAgICAgICAgICBzdHJlYW1JZDogc3RyZWFtSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgc2VsZi5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcihyZWFzb24pIHtcbiAgICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJlcnJvciBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZTogdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FUlJPUixcbiAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNpbmtDYXBhYmlsaXR5OiAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCksXG4gICAgICAgIG9uUHVsbDogbnVsbCxcbiAgICAgICAgb25DYW5jZWw6IG51bGwsXG4gICAgICAgIGlzQ2FuY2VsbGVkOiBmYWxzZSxcbiAgICAgICAgZGVzaXJlZFNpemU6IGRhdGEuZGVzaXJlZFNpemUsXG4gICAgICAgIHJlYWR5OiBudWxsXG4gICAgICB9O1xuICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICBzdHJlYW1TaW5rLnJlYWR5ID0gc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0gPSBzdHJlYW1TaW5rO1xuICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShhY3Rpb24oZGF0YS5kYXRhLCBzdHJlYW1TaW5rKSk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lOiBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWU6IHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWU6IHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZTogdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wcm9jZXNzU3RyZWFtTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSkge1xuICAgICAgdmFyIHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZDtcbiAgICAgIHZhciBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lO1xuICAgICAgdmFyIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWU7XG4gICAgICB2YXIgY29tT2JqID0gdGhpcy5jb21PYmo7XG5cbiAgICAgIHN3aXRjaCAoZGF0YS5zdHJlYW0pIHtcbiAgICAgICAgY2FzZSBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFOlxuICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnN0YXJ0Q2FsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnN0YXJ0Q2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFOlxuICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnB1bGxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0ucHVsbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTDpcbiAgICAgICAgICBpZiAoIXRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdKSB7XG4gICAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBzb3VyY2VOYW1lOiBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICB0YXJnZXROYW1lOiB0YXJnZXROYW1lLFxuICAgICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXS5kZXNpcmVkU2l6ZSA8PSAwICYmIGRhdGEuZGVzaXJlZFNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXS5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0uZGVzaXJlZFNpemUgPSBkYXRhLmRlc2lyZWRTaXplO1xuICAgICAgICAgIHZhciBvblB1bGwgPSB0aGlzLnN0cmVhbVNpbmtzW2RhdGEuc3RyZWFtSWRdLm9uUHVsbDtcbiAgICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShvblB1bGwgJiYgb25QdWxsKCkpO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgc291cmNlTmFtZTogc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgdGFyZ2V0TmFtZTogdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgc291cmNlTmFtZTogc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgdGFyZ2V0TmFtZTogdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3RyZWFtS2luZC5FTlFVRVVFOlxuICAgICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLCBcImVucXVldWUgc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhLmNodW5rKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN0cmVhbUtpbmQuQ0xPU0U6XG4gICAgICAgICAgKDAsIF91dGlsLmFzc2VydCkodGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0sIFwiY2xvc2Ugc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jb250cm9sbGVyLmNsb3NlKCk7XG5cbiAgICAgICAgICB0aGlzLl9kZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUlkKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3RyZWFtS2luZC5FUlJPUjpcbiAgICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSwgXCJlcnJvciBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jb250cm9sbGVyLmVycm9yKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcblxuICAgICAgICAgIHRoaXMuX2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtSWQpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURTpcbiAgICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jYW5jZWxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uY2FuY2VsQ2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtSWQpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTDpcbiAgICAgICAgICBpZiAoIXRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb25DYW5jZWwgPSB0aGlzLnN0cmVhbVNpbmtzW2RhdGEuc3RyZWFtSWRdLm9uQ2FuY2VsO1xuICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKG9uQ2FuY2VsICYmIG9uQ2FuY2VsKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKSk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBzb3VyY2VOYW1lOiBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICB0YXJnZXROYW1lOiB0YXJnZXROYW1lLFxuICAgICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgICBzdHJlYW1JZDogc3RyZWFtSWQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIHNvdXJjZU5hbWU6IHNvdXJjZU5hbWUsXG4gICAgICAgICAgICAgIHRhcmdldE5hbWU6IHRhcmdldE5hbWUsXG4gICAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdLnNpbmtDYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0uaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgc3RyZWFtIGNhc2VcIik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZWxldGVTdHJlYW1Db250cm9sbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZGVsZXRlU3RyZWFtQ29udHJvbGxlcjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKHN0cmVhbUlkKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsU2V0dGxlZChbdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uc3RhcnRDYWxsLCB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5wdWxsQ2FsbCwgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uY2FuY2VsQ2FsbF0ubWFwKGZ1bmN0aW9uIChjYXBhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FwYWJpbGl0eSAmJiBjYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF07XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfZGVsZXRlU3RyZWFtQ29udHJvbGxlcihfeCkge1xuICAgICAgICByZXR1cm4gX2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZGVsZXRlU3RyZWFtQ29udHJvbGxlcjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfcG9zdE1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Bvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVycykge1xuICAgICAgaWYgKHRyYW5zZmVycyAmJiB0aGlzLnBvc3RNZXNzYWdlVHJhbnNmZXJzKSB7XG4gICAgICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5jb21PYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZXNzYWdlSGFuZGxlcjtcbn0oKTtcblxuZXhwb3J0cy5NZXNzYWdlSGFuZGxlciA9IE1lc3NhZ2VIYW5kbGVyO1xuXG4vKioqLyB9KSxcbi8qIDE0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuTWV0YWRhdGEgPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG5cbnZhciBfeG1sX3BhcnNlciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQ1KTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgTWV0YWRhdGEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNZXRhZGF0YShkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1ldGFkYXRhKTtcblxuICAgICgwLCBfdXRpbC5hc3NlcnQpKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiLCBcIk1ldGFkYXRhOiBpbnB1dCBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgZGF0YSA9IHRoaXMuX3JlcGFpcihkYXRhKTtcbiAgICB2YXIgcGFyc2VyID0gbmV3IF94bWxfcGFyc2VyLlNpbXBsZVhNTFBhcnNlcih7XG4gICAgICBsb3dlckNhc2VOYW1lOiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIHhtbERvY3VtZW50ID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhkYXRhKTtcbiAgICB0aGlzLl9tZXRhZGF0YU1hcCA9IG5ldyBNYXAoKTtcblxuICAgIGlmICh4bWxEb2N1bWVudCkge1xuICAgICAgdGhpcy5fcGFyc2UoeG1sRG9jdW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1ldGFkYXRhLCBbe1xuICAgIGtleTogXCJfcmVwYWlyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXBhaXIoZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvXltePF0rLywgXCJcIikucmVwbGFjZSgvPlxcXFwzNzZcXFxcMzc3KFtePF0rKS9nLCBmdW5jdGlvbiAoYWxsLCBjb2Rlcykge1xuICAgICAgICB2YXIgYnl0ZXMgPSBjb2Rlcy5yZXBsYWNlKC9cXFxcKFswLTNdKShbMC03XSkoWzAtN10pL2csIGZ1bmN0aW9uIChjb2RlLCBkMSwgZDIsIGQzKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZDEgKiA2NCArIGQyICogOCArIGQzICogMSk7XG4gICAgICAgIH0pLnJlcGxhY2UoLyYoYW1wfGFwb3N8Z3R8bHR8cXVvdCk7L2csIGZ1bmN0aW9uIChzdHIsIG5hbWUpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbXBcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiJlwiO1xuXG4gICAgICAgICAgICBjYXNlIFwiYXBvc1wiOlxuICAgICAgICAgICAgICByZXR1cm4gXCInXCI7XG5cbiAgICAgICAgICAgIGNhc2UgXCJndFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCI+XCI7XG5cbiAgICAgICAgICAgIGNhc2UgXCJsdFwiOlxuICAgICAgICAgICAgICByZXR1cm4gXCI8XCI7XG5cbiAgICAgICAgICAgIGNhc2UgXCJxdW90XCI6XG4gICAgICAgICAgICAgIHJldHVybiAnXCInO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIl9yZXBhaXI6IFwiLmNvbmNhdChuYW1lLCBcIiBpc24ndCBkZWZpbmVkLlwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY2hhcnMgPSBcIlwiO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGJ5dGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICB2YXIgY29kZSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSkgKiAyNTYgKyBieXRlcy5jaGFyQ29kZUF0KGkgKyAxKTtcblxuICAgICAgICAgIGlmIChjb2RlID49IDMyICYmIGNvZGUgPCAxMjcgJiYgY29kZSAhPT0gNjAgJiYgY29kZSAhPT0gNjIgJiYgY29kZSAhPT0gMzgpIHtcbiAgICAgICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYXJzICs9IFwiJiN4XCIgKyAoMHgxMDAwMCArIGNvZGUpLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSkgKyBcIjtcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCI+XCIgKyBjaGFycztcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U2VxdWVuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNlcXVlbmNlKGVudHJ5KSB7XG4gICAgICB2YXIgbmFtZSA9IGVudHJ5Lm5vZGVOYW1lO1xuXG4gICAgICBpZiAobmFtZSAhPT0gXCJyZGY6YmFnXCIgJiYgbmFtZSAhPT0gXCJyZGY6c2VxXCIgJiYgbmFtZSAhPT0gXCJyZGY6YWx0XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeS5jaGlsZE5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5ub2RlTmFtZSA9PT0gXCJyZGY6bGlcIjtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q3JlYXRvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENyZWF0b3JzKGVudHJ5KSB7XG4gICAgICBpZiAoZW50cnkubm9kZU5hbWUgIT09IFwiZGM6Y3JlYXRvclwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbnRyeS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXFOb2RlID0gZW50cnkuY2hpbGROb2Rlc1swXTtcbiAgICAgIHZhciBhdXRob3JzID0gdGhpcy5fZ2V0U2VxdWVuY2Uoc2VxTm9kZSkgfHwgW107XG5cbiAgICAgIHRoaXMuX21ldGFkYXRhTWFwLnNldChlbnRyeS5ub2RlTmFtZSwgYXV0aG9ycy5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudGV4dENvbnRlbnQudHJpbSgpO1xuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZSh4bWxEb2N1bWVudCkge1xuICAgICAgdmFyIHJkZiA9IHhtbERvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgaWYgKHJkZi5ub2RlTmFtZSAhPT0gXCJyZGY6cmRmXCIpIHtcbiAgICAgICAgcmRmID0gcmRmLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKHJkZiAmJiByZGYubm9kZU5hbWUgIT09IFwicmRmOnJkZlwiKSB7XG4gICAgICAgICAgcmRmID0gcmRmLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcmRmIHx8IHJkZi5ub2RlTmFtZSAhPT0gXCJyZGY6cmRmXCIgfHwgIXJkZi5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocmRmLmNoaWxkTm9kZXMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBkZXNjID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBpZiAoZGVzYy5ub2RlTmFtZSAhPT0gXCJyZGY6ZGVzY3JpcHRpb25cIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkZXNjLmNoaWxkTm9kZXMpLFxuICAgICAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVudHJ5Lm5vZGVOYW1lO1xuXG4gICAgICAgICAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9nZXRDcmVhdG9ycyhlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhTWFwLnNldChuYW1lLCBlbnRyeS50ZXh0Q29udGVudC50cmltKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmF3KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgICAgdmFyIF90aGlzJF9tZXRhZGF0YU1hcCRnZTtcblxuICAgICAgcmV0dXJuIChfdGhpcyRfbWV0YWRhdGFNYXAkZ2UgPSB0aGlzLl9tZXRhZGF0YU1hcC5nZXQobmFtZSkpICE9PSBudWxsICYmIF90aGlzJF9tZXRhZGF0YU1hcCRnZSAhPT0gdm9pZCAwID8gX3RoaXMkX21ldGFkYXRhTWFwJGdlIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsbCgpIHtcbiAgICAgIHJldHVybiAoMCwgX3V0aWwub2JqZWN0RnJvbUVudHJpZXMpKHRoaXMuX21ldGFkYXRhTWFwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFNYXAuaGFzKG5hbWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZXRhZGF0YTtcbn0oKTtcblxuZXhwb3J0cy5NZXRhZGF0YSA9IE1ldGFkYXRhO1xuXG4vKioqLyB9KSxcbi8qIDE0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5YTUxQYXJzZXJFcnJvckNvZGUgPSBleHBvcnRzLlhNTFBhcnNlckJhc2UgPSBleHBvcnRzLlNpbXBsZVhNTFBhcnNlciA9IGV4cG9ydHMuU2ltcGxlRE9NTm9kZSA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgdGhyb3cgX2UyOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMykgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTM7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIFhNTFBhcnNlckVycm9yQ29kZSA9IHtcbiAgTm9FcnJvcjogMCxcbiAgRW5kT2ZEb2N1bWVudDogLTEsXG4gIFVudGVybWluYXRlZENkYXQ6IC0yLFxuICBVbnRlcm1pbmF0ZWRYbWxEZWNsYXJhdGlvbjogLTMsXG4gIFVudGVybWluYXRlZERvY3R5cGVEZWNsYXJhdGlvbjogLTQsXG4gIFVudGVybWluYXRlZENvbW1lbnQ6IC01LFxuICBNYWxmb3JtZWRFbGVtZW50OiAtNixcbiAgT3V0T2ZNZW1vcnk6IC03LFxuICBVbnRlcm1pbmF0ZWRBdHRyaWJ1dGVWYWx1ZTogLTgsXG4gIFVudGVybWluYXRlZEVsZW1lbnQ6IC05LFxuICBFbGVtZW50TmV2ZXJCZWd1bjogLTEwXG59O1xuZXhwb3J0cy5YTUxQYXJzZXJFcnJvckNvZGUgPSBYTUxQYXJzZXJFcnJvckNvZGU7XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShzLCBpbmRleCkge1xuICB2YXIgY2ggPSBzW2luZGV4XTtcbiAgcmV0dXJuIGNoID09PSBcIiBcIiB8fCBjaCA9PT0gXCJcXG5cIiB8fCBjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHRcIjtcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlU3RyaW5nKHMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgaWYgKCFpc1doaXRlc3BhY2UocywgaSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIFhNTFBhcnNlckJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYTUxQYXJzZXJCYXNlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYTUxQYXJzZXJCYXNlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhYTUxQYXJzZXJCYXNlLCBbe1xuICAgIGtleTogXCJfcmVzb2x2ZUVudGl0aWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNvbHZlRW50aXRpZXMocykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIHMucmVwbGFjZSgvJihbXjtdKyk7L2csIGZ1bmN0aW9uIChhbGwsIGVudGl0eSkge1xuICAgICAgICBpZiAoZW50aXR5LnN1YnN0cmluZygwLCAyKSA9PT0gXCIjeFwiKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KGVudGl0eS5zdWJzdHJpbmcoMiksIDE2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZW50aXR5LnN1YnN0cmluZygwLCAxKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQoZW50aXR5LnN1YnN0cmluZygxKSwgMTApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZW50aXR5KSB7XG4gICAgICAgICAgY2FzZSBcImx0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCI8XCI7XG5cbiAgICAgICAgICBjYXNlIFwiZ3RcIjpcbiAgICAgICAgICAgIHJldHVybiBcIj5cIjtcblxuICAgICAgICAgIGNhc2UgXCJhbXBcIjpcbiAgICAgICAgICAgIHJldHVybiBcIiZcIjtcblxuICAgICAgICAgIGNhc2UgXCJxdW90XCI6XG4gICAgICAgICAgICByZXR1cm4gJ1wiJztcblxuICAgICAgICAgIGNhc2UgXCJhcG9zXCI6XG4gICAgICAgICAgICByZXR1cm4gXCInXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMub25SZXNvbHZlRW50aXR5KGVudGl0eSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhcnNlQ29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VDb250ZW50KHMsIHN0YXJ0KSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuICAgICAgdmFyIHBvcyA9IHN0YXJ0O1xuXG4gICAgICBmdW5jdGlvbiBza2lwV3MoKSB7XG4gICAgICAgIHdoaWxlIChwb3MgPCBzLmxlbmd0aCAmJiBpc1doaXRlc3BhY2UocywgcG9zKSkge1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwb3MgPCBzLmxlbmd0aCAmJiAhaXNXaGl0ZXNwYWNlKHMsIHBvcykgJiYgc1twb3NdICE9PSBcIj5cIiAmJiBzW3Bvc10gIT09IFwiL1wiKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHMuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgc2tpcFdzKCk7XG5cbiAgICAgIHdoaWxlIChwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT09IFwiPlwiICYmIHNbcG9zXSAhPT0gXCIvXCIgJiYgc1twb3NdICE9PSBcIj9cIikge1xuICAgICAgICBza2lwV3MoKTtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gXCJcIixcbiAgICAgICAgICAgIGF0dHJWYWx1ZSA9IFwiXCI7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IHMubGVuZ3RoICYmICFpc1doaXRlc3BhY2UocywgcG9zKSAmJiBzW3Bvc10gIT09IFwiPVwiKSB7XG4gICAgICAgICAgYXR0ck5hbWUgKz0gc1twb3NdO1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgc2tpcFdzKCk7XG5cbiAgICAgICAgaWYgKHNbcG9zXSAhPT0gXCI9XCIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgICsrcG9zO1xuICAgICAgICBza2lwV3MoKTtcbiAgICAgICAgdmFyIGF0dHJFbmRDaGFyID0gc1twb3NdO1xuXG4gICAgICAgIGlmIChhdHRyRW5kQ2hhciAhPT0gJ1wiJyAmJiBhdHRyRW5kQ2hhciAhPT0gXCInXCIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRyRW5kSW5kZXggPSBzLmluZGV4T2YoYXR0ckVuZENoYXIsICsrcG9zKTtcblxuICAgICAgICBpZiAoYXR0ckVuZEluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0clZhbHVlID0gcy5zdWJzdHJpbmcocG9zLCBhdHRyRW5kSW5kZXgpO1xuICAgICAgICBhdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IGF0dHJOYW1lLFxuICAgICAgICAgIHZhbHVlOiB0aGlzLl9yZXNvbHZlRW50aXRpZXMoYXR0clZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgICAgcG9zID0gYXR0ckVuZEluZGV4ICsgMTtcbiAgICAgICAgc2tpcFdzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIHBhcnNlZDogcG9zIC0gc3RhcnRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wYXJzZVByb2Nlc3NpbmdJbnN0cnVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ocywgc3RhcnQpIHtcbiAgICAgIHZhciBwb3MgPSBzdGFydDtcblxuICAgICAgZnVuY3Rpb24gc2tpcFdzKCkge1xuICAgICAgICB3aGlsZSAocG9zIDwgcy5sZW5ndGggJiYgaXNXaGl0ZXNwYWNlKHMsIHBvcykpIHtcbiAgICAgICAgICArK3BvcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAocG9zIDwgcy5sZW5ndGggJiYgIWlzV2hpdGVzcGFjZShzLCBwb3MpICYmIHNbcG9zXSAhPT0gXCI+XCIgJiYgc1twb3NdICE9PSBcIi9cIikge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBzLnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgIHNraXBXcygpO1xuICAgICAgdmFyIGF0dHJTdGFydCA9IHBvcztcblxuICAgICAgd2hpbGUgKHBvcyA8IHMubGVuZ3RoICYmIChzW3Bvc10gIT09IFwiP1wiIHx8IHNbcG9zICsgMV0gIT09IFwiPlwiKSkge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gcy5zdWJzdHJpbmcoYXR0clN0YXJ0LCBwb3MpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBwYXJzZWQ6IHBvcyAtIHN0YXJ0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVhtbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVhtbChzKSB7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoID0gc1tpXTtcbiAgICAgICAgdmFyIGogPSBpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gXCI8XCIpIHtcbiAgICAgICAgICArK2o7XG4gICAgICAgICAgdmFyIGNoMiA9IHNbal07XG4gICAgICAgICAgdmFyIHEgPSB2b2lkIDA7XG5cbiAgICAgICAgICBzd2l0Y2ggKGNoMikge1xuICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICBxID0gcy5pbmRleE9mKFwiPlwiLCBqKTtcblxuICAgICAgICAgICAgICBpZiAocSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoWE1MUGFyc2VyRXJyb3JDb2RlLlVudGVybWluYXRlZEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMub25FbmRFbGVtZW50KHMuc3Vic3RyaW5nKGosIHEpKTtcbiAgICAgICAgICAgICAgaiA9IHEgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgICAgKytqO1xuXG4gICAgICAgICAgICAgIHZhciBwaSA9IHRoaXMuX3BhcnNlUHJvY2Vzc2luZ0luc3RydWN0aW9uKHMsIGopO1xuXG4gICAgICAgICAgICAgIGlmIChzLnN1YnN0cmluZyhqICsgcGkucGFyc2VkLCBqICsgcGkucGFyc2VkICsgMikgIT09IFwiPz5cIikge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihYTUxQYXJzZXJFcnJvckNvZGUuVW50ZXJtaW5hdGVkWG1sRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMub25QaShwaS5uYW1lLCBwaS52YWx1ZSk7XG4gICAgICAgICAgICAgIGogKz0gcGkucGFyc2VkICsgMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCIhXCI6XG4gICAgICAgICAgICAgIGlmIChzLnN1YnN0cmluZyhqICsgMSwgaiArIDMpID09PSBcIi0tXCIpIHtcbiAgICAgICAgICAgICAgICBxID0gcy5pbmRleE9mKFwiLS0+XCIsIGogKyAzKTtcblxuICAgICAgICAgICAgICAgIGlmIChxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5VbnRlcm1pbmF0ZWRDb21tZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29tbWVudChzLnN1YnN0cmluZyhqICsgMywgcSkpO1xuICAgICAgICAgICAgICAgIGogPSBxICsgMztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzLnN1YnN0cmluZyhqICsgMSwgaiArIDgpID09PSBcIltDREFUQVtcIikge1xuICAgICAgICAgICAgICAgIHEgPSBzLmluZGV4T2YoXCJdXT5cIiwgaiArIDgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoWE1MUGFyc2VyRXJyb3JDb2RlLlVudGVybWluYXRlZENkYXQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMub25DZGF0YShzLnN1YnN0cmluZyhqICsgOCwgcSkpO1xuICAgICAgICAgICAgICAgIGogPSBxICsgMztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzLnN1YnN0cmluZyhqICsgMSwgaiArIDgpID09PSBcIkRPQ1RZUEVcIikge1xuICAgICAgICAgICAgICAgIHZhciBxMiA9IHMuaW5kZXhPZihcIltcIiwgaiArIDgpO1xuICAgICAgICAgICAgICAgIHZhciBjb21wbGV4RG9jdHlwZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHEgPSBzLmluZGV4T2YoXCI+XCIsIGogKyA4KTtcblxuICAgICAgICAgICAgICAgIGlmIChxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5VbnRlcm1pbmF0ZWREb2N0eXBlRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChxMiA+IDAgJiYgcSA+IHEyKSB7XG4gICAgICAgICAgICAgICAgICBxID0gcy5pbmRleE9mKFwiXT5cIiwgaiArIDgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAocSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5VbnRlcm1pbmF0ZWREb2N0eXBlRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGNvbXBsZXhEb2N0eXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZG9jdHlwZUNvbnRlbnQgPSBzLnN1YnN0cmluZyhqICsgOCwgcSArIChjb21wbGV4RG9jdHlwZSA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRvY3R5cGUoZG9jdHlwZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGogPSBxICsgKGNvbXBsZXhEb2N0eXBlID8gMiA6IDEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihYTUxQYXJzZXJFcnJvckNvZGUuTWFsZm9ybWVkRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5fcGFyc2VDb250ZW50KHMsIGopO1xuXG4gICAgICAgICAgICAgIGlmIChjb250ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5NYWxmb3JtZWRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgaXNDbG9zZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAocy5zdWJzdHJpbmcoaiArIGNvbnRlbnQucGFyc2VkLCBqICsgY29udGVudC5wYXJzZWQgKyAyKSA9PT0gXCIvPlwiKSB7XG4gICAgICAgICAgICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHMuc3Vic3RyaW5nKGogKyBjb250ZW50LnBhcnNlZCwgaiArIGNvbnRlbnQucGFyc2VkICsgMSkgIT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5VbnRlcm1pbmF0ZWRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLm9uQmVnaW5FbGVtZW50KGNvbnRlbnQubmFtZSwgY29udGVudC5hdHRyaWJ1dGVzLCBpc0Nsb3NlZCk7XG4gICAgICAgICAgICAgIGogKz0gY29udGVudC5wYXJzZWQgKyAoaXNDbG9zZWQgPyAyIDogMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAoaiA8IHMubGVuZ3RoICYmIHNbal0gIT09IFwiPFwiKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRleHQgPSBzLnN1YnN0cmluZyhpLCBqKTtcbiAgICAgICAgICB0aGlzLm9uVGV4dCh0aGlzLl9yZXNvbHZlRW50aXRpZXModGV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaSA9IGo7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uUmVzb2x2ZUVudGl0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlc29sdmVFbnRpdHkobmFtZSkge1xuICAgICAgcmV0dXJuIFwiJlwiLmNvbmNhdChuYW1lLCBcIjtcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uUGlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25QaShuYW1lLCB2YWx1ZSkge31cbiAgfSwge1xuICAgIGtleTogXCJvbkNvbW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Db21tZW50KHRleHQpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwib25DZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNkYXRhKHRleHQpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Eb2N0eXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRG9jdHlwZShkb2N0eXBlQ29udGVudCkge31cbiAgfSwge1xuICAgIGtleTogXCJvblRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25UZXh0KHRleHQpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwib25CZWdpbkVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25CZWdpbkVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgaXNFbXB0eSkge31cbiAgfSwge1xuICAgIGtleTogXCJvbkVuZEVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25FbmRFbGVtZW50KG5hbWUpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwib25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVycm9yKGNvZGUpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gWE1MUGFyc2VyQmFzZTtcbn0oKTtcblxuZXhwb3J0cy5YTUxQYXJzZXJCYXNlID0gWE1MUGFyc2VyQmFzZTtcblxudmFyIFNpbXBsZURPTU5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaW1wbGVET01Ob2RlKG5vZGVOYW1lLCBub2RlVmFsdWUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2ltcGxlRE9NTm9kZSk7XG5cbiAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG4gICAgdGhpcy5ub2RlVmFsdWUgPSBub2RlVmFsdWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyZW50Tm9kZVwiLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2ltcGxlRE9NTm9kZSwgW3tcbiAgICBrZXk6IFwiZmlyc3RDaGlsZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2RlcyAmJiB0aGlzLmNoaWxkTm9kZXNbMF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHRTaWJsaW5nXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xuXG4gICAgICBpZiAoIWNoaWxkTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gY2hpbGROb2Rlcy5pbmRleE9mKHRoaXMpO1xuXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGlsZE5vZGVzW2luZGV4ICsgMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRDb250ZW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuY2hpbGROb2Rlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlVmFsdWUgfHwgXCJcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZC50ZXh0Q29udGVudDtcbiAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0NoaWxkTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQ2hpbGROb2RlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkTm9kZXMgJiYgdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCA+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlYXJjaE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VhcmNoTm9kZShwYXRocywgcG9zKSB7XG4gICAgICBpZiAocG9zID49IHBhdGhzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudCA9IHBhdGhzW3Bvc107XG4gICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgIHZhciBub2RlID0gdGhpcztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5uYW1lID09PSBub2RlLm5vZGVOYW1lKSB7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudC5wb3MgPT09IDApIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBub2RlLnNlYXJjaE5vZGUocGF0aHMsIHBvcyArIDEpO1xuXG4gICAgICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX3N0YWNrJHBvcCA9IHN0YWNrLnBvcCgpLFxuICAgICAgICAgICAgICAgIF9zdGFjayRwb3AyID0gX3NsaWNlZFRvQXJyYXkoX3N0YWNrJHBvcCwgMSksXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gX3N0YWNrJHBvcDJbMF07XG5cbiAgICAgICAgICAgIHZhciBzaWJsaW5nUG9zID0gMDtcblxuICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBhcmVudC5jaGlsZE5vZGVzKSxcbiAgICAgICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQubmFtZSA9PT0gY2hpbGQubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nUG9zID09PSBjb21wb25lbnQucG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5zZWFyY2hOb2RlKHBhdGhzLCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgc2libGluZ1BvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zZWFyY2hOb2RlKHBhdGhzLCBwb3MgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5jaGlsZE5vZGVzICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBzdGFjay5wdXNoKFtub2RlLCAwXSk7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgX3N0YWNrJHBvcDMgPSBzdGFjay5wb3AoKSxcbiAgICAgICAgICAgICAgICBfc3RhY2skcG9wNCA9IF9zbGljZWRUb0FycmF5KF9zdGFjayRwb3AzLCAyKSxcbiAgICAgICAgICAgICAgICBfcGFyZW50ID0gX3N0YWNrJHBvcDRbMF0sXG4gICAgICAgICAgICAgICAgY3VycmVudFBvcyA9IF9zdGFjayRwb3A0WzFdO1xuXG4gICAgICAgICAgICB2YXIgbmV3UG9zID0gY3VycmVudFBvcyArIDE7XG5cbiAgICAgICAgICAgIGlmIChuZXdQb3MgPCBfcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goW19wYXJlbnQsIG5ld1Bvc10pO1xuICAgICAgICAgICAgICBub2RlID0gX3BhcmVudC5jaGlsZE5vZGVzW25ld1Bvc107XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkdW1wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGR1bXAoYnVmZmVyKSB7XG4gICAgICBpZiAodGhpcy5ub2RlTmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKCgwLCBfdXRpbC5lbmNvZGVUb1htbFN0cmluZykodGhpcy5ub2RlVmFsdWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBidWZmZXIucHVzaChcIjxcIi5jb25jYXQodGhpcy5ub2RlTmFtZSkpO1xuXG4gICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5hdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goXCIgXCIuY29uY2F0KGF0dHJpYnV0ZS5uYW1lLCBcIj1cXFwiXCIpLmNvbmNhdCgoMCwgX3V0aWwuZW5jb2RlVG9YbWxTdHJpbmcpKGF0dHJpYnV0ZS52YWx1ZSksIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goXCI+XCIpO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5jaGlsZE5vZGVzKSxcbiAgICAgICAgICAgIF9zdGVwMztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgICBjaGlsZC5kdW1wKGJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlci5wdXNoKFwiPC9cIi5jb25jYXQodGhpcy5ub2RlTmFtZSwgXCI+XCIpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5ub2RlVmFsdWUpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goXCI+XCIuY29uY2F0KCgwLCBfdXRpbC5lbmNvZGVUb1htbFN0cmluZykodGhpcy5ub2RlVmFsdWUpLCBcIjwvXCIpLmNvbmNhdCh0aGlzLm5vZGVOYW1lLCBcIj5cIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyLnB1c2goXCIvPlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2ltcGxlRE9NTm9kZTtcbn0oKTtcblxuZXhwb3J0cy5TaW1wbGVET01Ob2RlID0gU2ltcGxlRE9NTm9kZTtcblxudmFyIFNpbXBsZVhNTFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1hNTFBhcnNlckJhc2UpIHtcbiAgX2luaGVyaXRzKFNpbXBsZVhNTFBhcnNlciwgX1hNTFBhcnNlckJhc2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU2ltcGxlWE1MUGFyc2VyKTtcblxuICBmdW5jdGlvbiBTaW1wbGVYTUxQYXJzZXIoX3JlZikge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICB2YXIgX3JlZiRoYXNBdHRyaWJ1dGVzID0gX3JlZi5oYXNBdHRyaWJ1dGVzLFxuICAgICAgICBoYXNBdHRyaWJ1dGVzID0gX3JlZiRoYXNBdHRyaWJ1dGVzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaGFzQXR0cmlidXRlcyxcbiAgICAgICAgX3JlZiRsb3dlckNhc2VOYW1lID0gX3JlZi5sb3dlckNhc2VOYW1lLFxuICAgICAgICBsb3dlckNhc2VOYW1lID0gX3JlZiRsb3dlckNhc2VOYW1lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkbG93ZXJDYXNlTmFtZTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaW1wbGVYTUxQYXJzZXIpO1xuXG4gICAgX3RoaXMyID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMyLl9jdXJyZW50RnJhZ21lbnQgPSBudWxsO1xuICAgIF90aGlzMi5fc3RhY2sgPSBudWxsO1xuICAgIF90aGlzMi5fZXJyb3JDb2RlID0gWE1MUGFyc2VyRXJyb3JDb2RlLk5vRXJyb3I7XG4gICAgX3RoaXMyLl9oYXNBdHRyaWJ1dGVzID0gaGFzQXR0cmlidXRlcztcbiAgICBfdGhpczIuX2xvd2VyQ2FzZU5hbWUgPSBsb3dlckNhc2VOYW1lO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2ltcGxlWE1MUGFyc2VyLCBbe1xuICAgIGtleTogXCJwYXJzZUZyb21TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VGcm9tU3RyaW5nKGRhdGEpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRGcmFnbWVudCA9IFtdO1xuICAgICAgdGhpcy5fc3RhY2sgPSBbXTtcbiAgICAgIHRoaXMuX2Vycm9yQ29kZSA9IFhNTFBhcnNlckVycm9yQ29kZS5Ob0Vycm9yO1xuICAgICAgdGhpcy5wYXJzZVhtbChkYXRhKTtcblxuICAgICAgaWYgKHRoaXMuX2Vycm9yQ29kZSAhPT0gWE1MUGFyc2VyRXJyb3JDb2RlLk5vRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJF9jdXJyZW50RnJhZ21lbiA9IF9zbGljZWRUb0FycmF5KHRoaXMuX2N1cnJlbnRGcmFnbWVudCwgMSksXG4gICAgICAgICAgZG9jdW1lbnRFbGVtZW50ID0gX3RoaXMkX2N1cnJlbnRGcmFnbWVuWzBdO1xuXG4gICAgICBpZiAoIWRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb2N1bWVudEVsZW1lbnQ6IGRvY3VtZW50RWxlbWVudFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25UZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVGV4dCh0ZXh0KSB7XG4gICAgICBpZiAoaXNXaGl0ZXNwYWNlU3RyaW5nKHRleHQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBuZXcgU2ltcGxlRE9NTm9kZShcIiN0ZXh0XCIsIHRleHQpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50RnJhZ21lbnQucHVzaChub2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25DZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNkYXRhKHRleHQpIHtcbiAgICAgIHZhciBub2RlID0gbmV3IFNpbXBsZURPTU5vZGUoXCIjdGV4dFwiLCB0ZXh0KTtcblxuICAgICAgdGhpcy5fY3VycmVudEZyYWdtZW50LnB1c2gobm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uQmVnaW5FbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQmVnaW5FbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIGlzRW1wdHkpIHtcbiAgICAgIGlmICh0aGlzLl9sb3dlckNhc2VOYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gbmV3IFNpbXBsZURPTU5vZGUobmFtZSk7XG4gICAgICBub2RlLmNoaWxkTm9kZXMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuX2hhc0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY3VycmVudEZyYWdtZW50LnB1c2gobm9kZSk7XG5cbiAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RhY2sucHVzaCh0aGlzLl9jdXJyZW50RnJhZ21lbnQpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50RnJhZ21lbnQgPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uRW5kRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVuZEVsZW1lbnQobmFtZSkge1xuICAgICAgdGhpcy5fY3VycmVudEZyYWdtZW50ID0gdGhpcy5fc3RhY2sucG9wKCkgfHwgW107XG4gICAgICB2YXIgbGFzdEVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RnJhZ21lbnRbdGhpcy5fY3VycmVudEZyYWdtZW50Lmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIWxhc3RFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGFzdEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGxhc3RFbGVtZW50LmNoaWxkTm9kZXNbaV0ucGFyZW50Tm9kZSA9IGxhc3RFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRXJyb3IoY29kZSkge1xuICAgICAgdGhpcy5fZXJyb3JDb2RlID0gY29kZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2ltcGxlWE1MUGFyc2VyO1xufShYTUxQYXJzZXJCYXNlKTtcblxuZXhwb3J0cy5TaW1wbGVYTUxQYXJzZXIgPSBTaW1wbGVYTUxQYXJzZXI7XG5cbi8qKiovIH0pLFxuLyogMTQ2ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5PcHRpb25hbENvbnRlbnRDb25maWcgPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIE9wdGlvbmFsQ29udGVudEdyb3VwID0gZnVuY3Rpb24gT3B0aW9uYWxDb250ZW50R3JvdXAobmFtZSwgaW50ZW50KSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcHRpb25hbENvbnRlbnRHcm91cCk7XG5cbiAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5pbnRlbnQgPSBpbnRlbnQ7XG59O1xuXG52YXIgT3B0aW9uYWxDb250ZW50Q29uZmlnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT3B0aW9uYWxDb250ZW50Q29uZmlnKGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3B0aW9uYWxDb250ZW50Q29uZmlnKTtcblxuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5jcmVhdG9yID0gbnVsbDtcbiAgICB0aGlzLl9vcmRlciA9IG51bGw7XG4gICAgdGhpcy5fZ3JvdXBzID0gbmV3IE1hcCgpO1xuXG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdGhpcy5jcmVhdG9yID0gZGF0YS5jcmVhdG9yO1xuICAgIHRoaXMuX29yZGVyID0gZGF0YS5vcmRlcjtcblxuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkYXRhLmdyb3VwcyksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfZ3JvdXAgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICB0aGlzLl9ncm91cHMuc2V0KF9ncm91cC5pZCwgbmV3IE9wdGlvbmFsQ29udGVudEdyb3VwKF9ncm91cC5uYW1lLCBfZ3JvdXAuaW50ZW50KSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmJhc2VTdGF0ZSA9PT0gXCJPRkZcIikge1xuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLl9ncm91cHMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgZ3JvdXAudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGEub24pLFxuICAgICAgICBfc3RlcDM7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIG9uID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICB0aGlzLl9ncm91cHMuZ2V0KG9uKS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICB9XG5cbiAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGEub2ZmKSxcbiAgICAgICAgX3N0ZXA0O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBvZmYgPSBfc3RlcDQudmFsdWU7XG4gICAgICAgIHRoaXMuX2dyb3Vwcy5nZXQob2ZmKS52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE9wdGlvbmFsQ29udGVudENvbmZpZywgW3tcbiAgICBrZXk6IFwiaXNWaXNpYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVmlzaWJsZShncm91cCkge1xuICAgICAgaWYgKCFncm91cCkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC50eXBlID09PSBcIk9DR1wiKSB7XG4gICAgICAgIGlmICghdGhpcy5fZ3JvdXBzLmhhcyhncm91cC5pZCkpIHtcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogXCIuY29uY2F0KGdyb3VwLmlkKSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBzLmdldChncm91cC5pZCkudmlzaWJsZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ01EXCIpIHtcbiAgICAgICAgaWYgKGdyb3VwLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJWaXNpYmlsaXR5IGV4cHJlc3Npb24gbm90IHN1cHBvcnRlZCB5ZXQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFncm91cC5wb2xpY3kgfHwgZ3JvdXAucG9saWN5ID09PSBcIkFueU9uXCIpIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGdyb3VwLmlkcyksXG4gICAgICAgICAgICAgIF9zdGVwNTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgaWQgPSBfc3RlcDUudmFsdWU7XG5cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIk9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiBcIi5jb25jYXQoaWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9ncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9uXCIpIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGdyb3VwLmlkcyksXG4gICAgICAgICAgICAgIF9zdGVwNjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX2lkID0gX3N0ZXA2LnZhbHVlO1xuXG4gICAgICAgICAgICAgIGlmICghdGhpcy5fZ3JvdXBzLmhhcyhfaWQpKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6IFwiLmNvbmNhdChfaWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghdGhpcy5fZ3JvdXBzLmdldChfaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQW55T2ZmXCIpIHtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGdyb3VwLmlkcyksXG4gICAgICAgICAgICAgIF9zdGVwNztcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjcucygpOyAhKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX2lkMiA9IF9zdGVwNy52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoIXRoaXMuX2dyb3Vwcy5oYXMoX2lkMikpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogXCIuY29uY2F0KF9pZDIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghdGhpcy5fZ3JvdXBzLmdldChfaWQyKS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I3LmYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9mZlwiKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihncm91cC5pZHMpLFxuICAgICAgICAgICAgICBfc3RlcDg7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9pZDMgPSBfc3RlcDgudmFsdWU7XG5cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ncm91cHMuaGFzKF9pZDMpKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6IFwiLmNvbmNhdChfaWQzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodGhpcy5fZ3JvdXBzLmdldChfaWQzKS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I4LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yOC5mKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmtub3duIG9wdGlvbmFsIGNvbnRlbnQgcG9saWN5IFwiLmNvbmNhdChncm91cC5wb2xpY3ksIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAoMCwgX3V0aWwud2FybikoXCJVbmtub3duIGdyb3VwIHR5cGUgXCIuY29uY2F0KGdyb3VwLnR5cGUsIFwiLlwiKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VmlzaWJpbGl0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWaXNpYmlsaXR5KGlkKSB7XG4gICAgICB2YXIgdmlzaWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgaWYgKCF0aGlzLl9ncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogXCIuY29uY2F0KGlkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZ3JvdXBzLmdldChpZCkudmlzaWJsZSA9ICEhdmlzaWJsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JkZXIoKSB7XG4gICAgICBpZiAoIXRoaXMuX2dyb3Vwcy5zaXplKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fb3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGVyLnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2dyb3Vwcy5rZXlzKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRHcm91cHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R3JvdXBzKCkge1xuICAgICAgaWYgKCF0aGlzLl9ncm91cHMuc2l6ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgwLCBfdXRpbC5vYmplY3RGcm9tRW50cmllcykodGhpcy5fZ3JvdXBzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0R3JvdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R3JvdXAoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ncm91cHMuZ2V0KGlkKSB8fCBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPcHRpb25hbENvbnRlbnRDb25maWc7XG59KCk7XG5cbmV4cG9ydHMuT3B0aW9uYWxDb250ZW50Q29uZmlnID0gT3B0aW9uYWxDb250ZW50Q29uZmlnO1xuXG4vKioqLyB9KSxcbi8qIDE0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuUERGRGF0YVRyYW5zcG9ydFN0cmVhbSA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193X3BkZmpzX3JlcXVpcmVfXygyKSk7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBQREZEYXRhVHJhbnNwb3J0U3RyZWFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGRGF0YVRyYW5zcG9ydFN0cmVhbShwYXJhbXMsIHBkZkRhdGFSYW5nZVRyYW5zcG9ydCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGRGF0YVRyYW5zcG9ydFN0cmVhbSk7XG5cbiAgICAoMCwgX3V0aWwuYXNzZXJ0KShwZGZEYXRhUmFuZ2VUcmFuc3BvcnQsICdQREZEYXRhVHJhbnNwb3J0U3RyZWFtIC0gbWlzc2luZyByZXF1aXJlZCBcInBkZkRhdGFSYW5nZVRyYW5zcG9ydFwiIGFyZ3VtZW50LicpO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHBhcmFtcy5wcm9ncmVzc2l2ZURvbmUgfHwgZmFsc2U7XG4gICAgdmFyIGluaXRpYWxEYXRhID0gcGFyYW1zLmluaXRpYWxEYXRhO1xuXG4gICAgaWYgKChpbml0aWFsRGF0YSA9PT0gbnVsbCB8fCBpbml0aWFsRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdGlhbERhdGEubGVuZ3RoKSA+IDApIHtcbiAgICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShpbml0aWFsRGF0YSkuYnVmZmVyO1xuXG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgIH1cblxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydCA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFwYXJhbXMuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXBhcmFtcy5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVhZGVycyA9IFtdO1xuXG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFJhbmdlTGlzdGVuZXIoZnVuY3Rpb24gKGJlZ2luLCBjaHVuaykge1xuICAgICAgX3RoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBiZWdpbjogYmVnaW4sXG4gICAgICAgIGNodW5rOiBjaHVua1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NMaXN0ZW5lcihmdW5jdGlvbiAobG9hZGVkLCB0b3RhbCkge1xuICAgICAgX3RoaXMuX29uUHJvZ3Jlc3Moe1xuICAgICAgICBsb2FkZWQ6IGxvYWRlZCxcbiAgICAgICAgdG90YWw6IHRvdGFsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIF90aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgY2h1bms6IGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fb25Qcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC50cmFuc3BvcnRSZWFkeSgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERkRhdGFUcmFuc3BvcnRTdHJlYW0sIFt7XG4gICAga2V5OiBcIl9vblJlY2VpdmVEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblJlY2VpdmVEYXRhKGFyZ3MpIHtcbiAgICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShhcmdzLmNodW5rKS5idWZmZXI7XG5cbiAgICAgIGlmIChhcmdzLmJlZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZm91bmQgPSB0aGlzLl9yYW5nZVJlYWRlcnMuc29tZShmdW5jdGlvbiAocmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgICBpZiAocmFuZ2VSZWFkZXIuX2JlZ2luICE9PSBhcmdzLmJlZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmFuZ2VSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShmb3VuZCwgXCJfb25SZWNlaXZlRGF0YSAtIG5vIGBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXJgIGluc3RhbmNlIGZvdW5kLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Byb2dyZXNzaXZlRGF0YUxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzJF9mdWxsUmVxdWVzdFJlYSwgX3RoaXMkX2Z1bGxSZXF1ZXN0UmVhMjtcblxuICAgICAgcmV0dXJuIChfdGhpcyRfZnVsbFJlcXVlc3RSZWEgPSAoX3RoaXMkX2Z1bGxSZXF1ZXN0UmVhMiA9IHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSA9PT0gbnVsbCB8fCBfdGhpcyRfZnVsbFJlcXVlc3RSZWEyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfZnVsbFJlcXVlc3RSZWEyLl9sb2FkZWQpICE9PSBudWxsICYmIF90aGlzJF9mdWxsUmVxdWVzdFJlYSAhPT0gdm9pZCAwID8gX3RoaXMkX2Z1bGxSZXF1ZXN0UmVhIDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgICBpZiAoZXZ0LnRvdGFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpcnN0UmVhZGVyID0gdGhpcy5fcmFuZ2VSZWFkZXJzWzBdO1xuXG4gICAgICAgIGlmIChmaXJzdFJlYWRlciAhPT0gbnVsbCAmJiBmaXJzdFJlYWRlciAhPT0gdm9pZCAwICYmIGZpcnN0UmVhZGVyLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBmaXJzdFJlYWRlci5vblByb2dyZXNzKHtcbiAgICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZnVsbFJlYWRlciA9IHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuXG4gICAgICAgIGlmIChmdWxsUmVhZGVyICE9PSBudWxsICYmIGZ1bGxSZWFkZXIgIT09IHZvaWQgMCAmJiBmdWxsUmVhZGVyLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBmdWxsUmVhZGVyLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblByb2dyZXNzaXZlRG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Qcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIucHJvZ3Jlc3NpdmVEb25lKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVSYW5nZVJlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlUmFuZ2VSZWFkZXIocmVhZGVyKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX3JhbmdlUmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG5cbiAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnVsbFJlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGdWxsUmVhZGVyKCkge1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgICB2YXIgcXVldWVkQ2h1bmtzID0gdGhpcy5fcXVldWVkQ2h1bmtzO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gbnVsbDtcbiAgICAgIHJldHVybiBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlcih0aGlzLCBxdWV1ZWRDaHVua3MsIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJhbmdlUmVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVhZGVyID0gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcblxuICAgICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCk7XG5cbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVycy5wdXNoKHJlYWRlcik7XG5cbiAgICAgIHJldHVybiByZWFkZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbEFsbFJlcXVlc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVhZGVycyA9IHRoaXMuX3JhbmdlUmVhZGVycy5zbGljZSgwKTtcblxuICAgICAgcmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZVJlYWRlcikge1xuICAgICAgICByYW5nZVJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWJvcnQoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGRGF0YVRyYW5zcG9ydFN0cmVhbTtcbn0oKTtcblxuZXhwb3J0cy5QREZEYXRhVHJhbnNwb3J0U3RyZWFtID0gUERGRGF0YVRyYW5zcG9ydFN0cmVhbTtcblxudmFyIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyKHN0cmVhbSwgcXVldWVkQ2h1bmtzKSB7XG4gICAgdmFyIHByb2dyZXNzaXZlRG9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlcik7XG5cbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fZG9uZSA9IHByb2dyZXNzaXZlRG9uZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gcXVldWVkQ2h1bmtzIHx8IFtdO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG5cbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5fcXVldWVkQ2h1bmtzKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGNodW5rID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2hlYWRlcnNSZWFkeSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHN0cmVhbS5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlciwgW3tcbiAgICBrZXk6IFwiX2VucXVldWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VucXVldWUoY2h1bmspIHtcbiAgICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcblxuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZWFkZXJzUmVhZHlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVhZHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbGVuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUmFuZ2VTdXBwb3J0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU3RyZWFtaW5nU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGVudExlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5fY29udGVudExlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlYWQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgY2h1bmssIHJlcXVlc3RDYXBhYmlsaXR5O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX3F1ZXVlZENodW5rcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kb25lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICByZXR1cm4gX3JlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlYWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9yZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0Q2FwYWJpbGl0eSkge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvZ3Jlc3NpdmVEb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXI7XG59KCk7XG5cbnZhciBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIoc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcik7XG5cbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fYmVnaW4gPSBiZWdpbjtcbiAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyLCBbe1xuICAgIGtleTogXCJfZW5xdWV1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5xdWV1ZShjaHVuaykge1xuICAgICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVxdWVzdHNDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcblxuICAgICAgICByZXF1ZXN0c0NhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3RDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTdHJlYW1pbmdTdXBwb3J0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlYWQyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBjaHVuaywgcmVxdWVzdENhcGFiaWxpdHk7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcXVldWVkQ2h1bmspIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZG9uZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICByZXR1cm4gX3JlYWQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWFkO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwocmVhc29uKSB7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fcmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdENhcGFiaWxpdHkpIHtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG5cbiAgICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcjtcbn0oKTtcblxuLyoqKi8gfSksXG4vKiAxNDggKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLldlYkdMQ29udGV4dCA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgV2ViR0xDb250ZXh0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV2ViR0xDb250ZXh0KF9yZWYpIHtcbiAgICB2YXIgX3JlZiRlbmFibGUgPSBfcmVmLmVuYWJsZSxcbiAgICAgICAgZW5hYmxlID0gX3JlZiRlbmFibGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRlbmFibGU7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0xDb250ZXh0KTtcblxuICAgIHRoaXMuX2VuYWJsZWQgPSBlbmFibGUgPT09IHRydWU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2ViR0xDb250ZXh0LCBbe1xuICAgIGtleTogXCJpc0VuYWJsZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBlbmFibGVkID0gdGhpcy5fZW5hYmxlZDtcblxuICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgZW5hYmxlZCA9IFdlYkdMVXRpbHMudHJ5SW5pdEdMKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImlzRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9zZVNNYXNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvc2VTTWFzayhfcmVmMikge1xuICAgICAgdmFyIGxheWVyID0gX3JlZjIubGF5ZXIsXG4gICAgICAgICAgbWFzayA9IF9yZWYyLm1hc2ssXG4gICAgICAgICAgcHJvcGVydGllcyA9IF9yZWYyLnByb3BlcnRpZXM7XG4gICAgICByZXR1cm4gV2ViR0xVdGlscy5jb21wb3NlU01hc2sobGF5ZXIsIG1hc2ssIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3RmlndXJlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3RmlndXJlcyhfcmVmMykge1xuICAgICAgdmFyIHdpZHRoID0gX3JlZjMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3JlZjMuaGVpZ2h0LFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IF9yZWYzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICBmaWd1cmVzID0gX3JlZjMuZmlndXJlcyxcbiAgICAgICAgICBjb250ZXh0ID0gX3JlZjMuY29udGV4dDtcbiAgICAgIHJldHVybiBXZWJHTFV0aWxzLmRyYXdGaWd1cmVzKHdpZHRoLCBoZWlnaHQsIGJhY2tncm91bmRDb2xvciwgZmlndXJlcywgY29udGV4dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgV2ViR0xVdGlscy5jbGVhbnVwKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlYkdMQ29udGV4dDtcbn0oKTtcblxuZXhwb3J0cy5XZWJHTENvbnRleHQgPSBXZWJHTENvbnRleHQ7XG5cbnZhciBXZWJHTFV0aWxzID0gZnVuY3Rpb24gV2ViR0xVdGlsc0Nsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIGxvYWRTaGFkZXIoZ2wsIGNvZGUsIHNoYWRlclR5cGUpIHtcbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIGNvZGUpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICB2YXIgY29tcGlsZWQgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyk7XG5cbiAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICB2YXIgZXJyb3JNc2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBkdXJpbmcgc2hhZGVyIGNvbXBpbGF0aW9uOiBcIiArIGVycm9yTXNnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVmVydGV4U2hhZGVyKGdsLCBjb2RlKSB7XG4gICAgcmV0dXJuIGxvYWRTaGFkZXIoZ2wsIGNvZGUsIGdsLlZFUlRFWF9TSEFERVIpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRTaGFkZXIoZ2wsIGNvZGUpIHtcbiAgICByZXR1cm4gbG9hZFNoYWRlcihnbCwgY29kZSwgZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wsIHNoYWRlcnMpIHtcbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHNoYWRlcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcnNbaV0pO1xuICAgIH1cblxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIHZhciBsaW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKTtcblxuICAgIGlmICghbGlua2VkKSB7XG4gICAgICB2YXIgZXJyb3JNc2cgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGR1cmluZyBwcm9ncmFtIGxpbmtpbmc6IFwiICsgZXJyb3JNc2cpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShnbCwgaW1hZ2UsIHRleHR1cmVJZCkge1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZUlkKTtcbiAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRHTCwgY3VycmVudENhbnZhcztcblxuICBmdW5jdGlvbiBnZW5lcmF0ZUdMKCkge1xuICAgIGlmIChjdXJyZW50R0wpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjdXJyZW50R0wgPSBjdXJyZW50Q2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCB7XG4gICAgICBwcmVtdWx0aXBsaWVkYWxwaGE6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgc21hc2tWZXJ0ZXhTaGFkZXJDb2RlID0gXCJcXFxuICBhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIGF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHZvaWQgbWFpbigpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICB2ZWMyIGNsaXBTcGFjZSA9IChhX3Bvc2l0aW9uIC8gdV9yZXNvbHV0aW9uKSAqIDIuMCAtIDEuMDsgICBcXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2UgKiB2ZWMyKDEsIC0xKSwgMCwgMSk7ICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiO1xuICB2YXIgc21hc2tGcmFnbWVudFNoYWRlckNvZGUgPSBcIlxcXG4gIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB1bmlmb3JtIHZlYzQgdV9iYWNrZHJvcDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHVuaWZvcm0gaW50IHVfc3VidHlwZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X21hc2s7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHZvaWQgbWFpbigpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICB2ZWM0IGltYWdlQ29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7ICAgICAgICAgICBcXFxuICAgIHZlYzQgbWFza0NvbG9yID0gdGV4dHVyZTJEKHVfbWFzaywgdl90ZXhDb29yZCk7ICAgICAgICAgICAgIFxcXG4gICAgaWYgKHVfYmFja2Ryb3AuYSA+IDAuMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgIG1hc2tDb2xvci5yZ2IgPSBtYXNrQ29sb3IucmdiICogbWFza0NvbG9yLmEgKyAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgIHVfYmFja2Ryb3AucmdiICogKDEuMCAtIG1hc2tDb2xvci5hKTsgICAgIFxcXG4gICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICBmbG9hdCBsdW07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIGlmICh1X3N1YnR5cGUgPT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICBsdW0gPSBtYXNrQ29sb3IuYTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgbHVtID0gbWFza0NvbG9yLnIgKiAwLjMgKyBtYXNrQ29sb3IuZyAqIDAuNTkgKyAgICAgICAgICAgIFxcXG4gICAgICAgICAgICBtYXNrQ29sb3IuYiAqIDAuMTE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIGltYWdlQ29sb3IuYSAqPSBsdW07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgaW1hZ2VDb2xvci5yZ2IgKj0gaW1hZ2VDb2xvci5hOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICBnbF9GcmFnQ29sb3IgPSBpbWFnZUNvbG9yOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiO1xuICB2YXIgc21hc2tDYWNoZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gaW5pdFNtYXNrR0woKSB7XG4gICAgZ2VuZXJhdGVHTCgpO1xuICAgIHZhciBjYW52YXMgPSBjdXJyZW50Q2FudmFzO1xuICAgIGN1cnJlbnRDYW52YXMgPSBudWxsO1xuICAgIHZhciBnbCA9IGN1cnJlbnRHTDtcbiAgICBjdXJyZW50R0wgPSBudWxsO1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBjcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wsIHNtYXNrVmVydGV4U2hhZGVyQ29kZSk7XG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gY3JlYXRlRnJhZ21lbnRTaGFkZXIoZ2wsIHNtYXNrRnJhZ21lbnRTaGFkZXJDb2RlKTtcbiAgICB2YXIgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICB2YXIgY2FjaGUgPSB7fTtcbiAgICBjYWNoZS5nbCA9IGdsO1xuICAgIGNhY2hlLmNhbnZhcyA9IGNhbnZhcztcbiAgICBjYWNoZS5yZXNvbHV0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3Jlc29sdXRpb25cIik7XG4gICAgY2FjaGUucG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICBjYWNoZS5iYWNrZHJvcExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9iYWNrZHJvcFwiKTtcbiAgICBjYWNoZS5zdWJ0eXBlTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3N1YnR5cGVcIik7XG4gICAgdmFyIHRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfdGV4Q29vcmRcIik7XG4gICAgdmFyIHRleExheWVyTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X2ltYWdlXCIpO1xuICAgIHZhciB0ZXhNYXNrTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X21hc2tcIik7XG4gICAgdmFyIHRleENvb3JkQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAxLjAsIDEuMCwgMC4wLCAxLjAsIDEuMF0pLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGV4Q29vcmRMb2NhdGlvbik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLnVuaWZvcm0xaSh0ZXhMYXllckxvY2F0aW9uLCAwKTtcbiAgICBnbC51bmlmb3JtMWkodGV4TWFza0xvY2F0aW9uLCAxKTtcbiAgICBzbWFza0NhY2hlID0gY2FjaGU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wb3NlU01hc2sobGF5ZXIsIG1hc2ssIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgd2lkdGggPSBsYXllci53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gbGF5ZXIuaGVpZ2h0O1xuXG4gICAgaWYgKCFzbWFza0NhY2hlKSB7XG4gICAgICBpbml0U21hc2tHTCgpO1xuICAgIH1cblxuICAgIHZhciBjYWNoZSA9IHNtYXNrQ2FjaGUsXG4gICAgICAgIGNhbnZhcyA9IGNhY2hlLmNhbnZhcyxcbiAgICAgICAgZ2wgPSBjYWNoZS5nbDtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gICAgZ2wudW5pZm9ybTJmKGNhY2hlLnJlc29sdXRpb25Mb2NhdGlvbiwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBpZiAocHJvcGVydGllcy5iYWNrZHJvcCkge1xuICAgICAgZ2wudW5pZm9ybTRmKGNhY2hlLnJlc29sdXRpb25Mb2NhdGlvbiwgcHJvcGVydGllcy5iYWNrZHJvcFswXSwgcHJvcGVydGllcy5iYWNrZHJvcFsxXSwgcHJvcGVydGllcy5iYWNrZHJvcFsyXSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnVuaWZvcm00ZihjYWNoZS5yZXNvbHV0aW9uTG9jYXRpb24sIDAsIDAsIDAsIDApO1xuICAgIH1cblxuICAgIGdsLnVuaWZvcm0xaShjYWNoZS5zdWJ0eXBlTG9jYXRpb24sIHByb3BlcnRpZXMuc3VidHlwZSA9PT0gXCJMdW1pbm9zaXR5XCIgPyAxIDogMCk7XG4gICAgdmFyIHRleHR1cmUgPSBjcmVhdGVUZXh0dXJlKGdsLCBsYXllciwgZ2wuVEVYVFVSRTApO1xuICAgIHZhciBtYXNrVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoZ2wsIG1hc2ssIGdsLlRFWFRVUkUxKTtcbiAgICB2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIHdpZHRoLCAwLCAwLCBoZWlnaHQsIDAsIGhlaWdodCwgd2lkdGgsIDAsIHdpZHRoLCBoZWlnaHRdKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNhY2hlLnBvc2l0aW9uTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY2FjaGUucG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDYpO1xuICAgIGdsLmZsdXNoKCk7XG4gICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICBnbC5kZWxldGVUZXh0dXJlKG1hc2tUZXh0dXJlKTtcbiAgICBnbC5kZWxldGVCdWZmZXIoYnVmZmVyKTtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgdmFyIGZpZ3VyZXNWZXJ0ZXhTaGFkZXJDb2RlID0gXCJcXFxuICBhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIGF0dHJpYnV0ZSB2ZWMzIGFfY29sb3I7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHVuaWZvcm0gdmVjMiB1X3NjYWxlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdW5pZm9ybSB2ZWMyIHVfb2Zmc2V0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHZhcnlpbmcgdmVjNCB2X2NvbG9yOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB2b2lkIG1haW4oKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgdmVjMiBwb3NpdGlvbiA9IChhX3Bvc2l0aW9uICsgdV9vZmZzZXQpICogdV9zY2FsZTsgICAgICAgICAgXFxcbiAgICB2ZWMyIGNsaXBTcGFjZSA9IChwb3NpdGlvbiAvIHVfcmVzb2x1dGlvbikgKiAyLjAgLSAxLjA7ICAgICBcXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2UgKiB2ZWMyKDEsIC0xKSwgMCwgMSk7ICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICB2X2NvbG9yID0gdmVjNChhX2NvbG9yIC8gMjU1LjAsIDEuMCk7ICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiO1xuICB2YXIgZmlndXJlc0ZyYWdtZW50U2hhZGVyQ29kZSA9IFwiXFxcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHZhcnlpbmcgdmVjNCB2X2NvbG9yOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB2b2lkIG1haW4oKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjtcbiAgdmFyIGZpZ3VyZXNDYWNoZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gaW5pdEZpZ3VyZXNHTCgpIHtcbiAgICBnZW5lcmF0ZUdMKCk7XG4gICAgdmFyIGNhbnZhcyA9IGN1cnJlbnRDYW52YXM7XG4gICAgY3VycmVudENhbnZhcyA9IG51bGw7XG4gICAgdmFyIGdsID0gY3VycmVudEdMO1xuICAgIGN1cnJlbnRHTCA9IG51bGw7XG4gICAgdmFyIHZlcnRleFNoYWRlciA9IGNyZWF0ZVZlcnRleFNoYWRlcihnbCwgZmlndXJlc1ZlcnRleFNoYWRlckNvZGUpO1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGNyZWF0ZUZyYWdtZW50U2hhZGVyKGdsLCBmaWd1cmVzRnJhZ21lbnRTaGFkZXJDb2RlKTtcbiAgICB2YXIgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICB2YXIgY2FjaGUgPSB7fTtcbiAgICBjYWNoZS5nbCA9IGdsO1xuICAgIGNhY2hlLmNhbnZhcyA9IGNhbnZhcztcbiAgICBjYWNoZS5yZXNvbHV0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3Jlc29sdXRpb25cIik7XG4gICAgY2FjaGUuc2NhbGVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfc2NhbGVcIik7XG4gICAgY2FjaGUub2Zmc2V0TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X29mZnNldFwiKTtcbiAgICBjYWNoZS5wb3NpdGlvbkxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX3Bvc2l0aW9uXCIpO1xuICAgIGNhY2hlLmNvbG9yTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfY29sb3JcIik7XG4gICAgZmlndXJlc0NhY2hlID0gY2FjaGU7XG4gIH1cblxuICBmdW5jdGlvbiBkcmF3RmlndXJlcyh3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kQ29sb3IsIGZpZ3VyZXMsIGNvbnRleHQpIHtcbiAgICBpZiAoIWZpZ3VyZXNDYWNoZSkge1xuICAgICAgaW5pdEZpZ3VyZXNHTCgpO1xuICAgIH1cblxuICAgIHZhciBjYWNoZSA9IGZpZ3VyZXNDYWNoZSxcbiAgICAgICAgY2FudmFzID0gY2FjaGUuY2FudmFzLFxuICAgICAgICBnbCA9IGNhY2hlLmdsO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICBnbC51bmlmb3JtMmYoY2FjaGUucmVzb2x1dGlvbkxvY2F0aW9uLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZmlndXJlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBzd2l0Y2ggKGZpZ3VyZXNbaV0udHlwZSkge1xuICAgICAgICBjYXNlIFwibGF0dGljZVwiOlxuICAgICAgICAgIHZhciByb3dzID0gZmlndXJlc1tpXS5jb29yZHMubGVuZ3RoIC8gZmlndXJlc1tpXS52ZXJ0aWNlc1BlclJvdyB8IDA7XG4gICAgICAgICAgY291bnQgKz0gKHJvd3MgLSAxKSAqIChmaWd1cmVzW2ldLnZlcnRpY2VzUGVyUm93IC0gMSkgKiA2O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJ0cmlhbmdsZXNcIjpcbiAgICAgICAgICBjb3VudCArPSBmaWd1cmVzW2ldLmNvb3Jkcy5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoY291bnQgKiAyKTtcbiAgICB2YXIgY29sb3JzID0gbmV3IFVpbnQ4QXJyYXkoY291bnQgKiAzKTtcbiAgICB2YXIgY29vcmRzTWFwID0gY29udGV4dC5jb29yZHMsXG4gICAgICAgIGNvbG9yc01hcCA9IGNvbnRleHQuY29sb3JzO1xuICAgIHZhciBwSW5kZXggPSAwLFxuICAgICAgICBjSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfaWkgPSBmaWd1cmVzLmxlbmd0aDsgX2kgPCBfaWk7IF9pKyspIHtcbiAgICAgIHZhciBmaWd1cmUgPSBmaWd1cmVzW19pXSxcbiAgICAgICAgICBwcyA9IGZpZ3VyZS5jb29yZHMsXG4gICAgICAgICAgY3MgPSBmaWd1cmUuY29sb3JzO1xuXG4gICAgICBzd2l0Y2ggKGZpZ3VyZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJsYXR0aWNlXCI6XG4gICAgICAgICAgdmFyIGNvbHMgPSBmaWd1cmUudmVydGljZXNQZXJSb3c7XG5cbiAgICAgICAgICB2YXIgX3Jvd3MgPSBwcy5sZW5ndGggLyBjb2xzIHwgMDtcblxuICAgICAgICAgIGZvciAodmFyIHJvdyA9IDE7IHJvdyA8IF9yb3dzOyByb3crKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHJvdyAqIGNvbHMgKyAxO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAxOyBjb2wgPCBjb2xzOyBjb2wrKywgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleF0gPSBjb29yZHNNYXBbcHNbb2Zmc2V0IC0gY29scyAtIDFdXTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDFdID0gY29vcmRzTWFwW3BzW29mZnNldCAtIGNvbHMgLSAxXSArIDFdO1xuICAgICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgMl0gPSBjb29yZHNNYXBbcHNbb2Zmc2V0IC0gY29sc11dO1xuICAgICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgM10gPSBjb29yZHNNYXBbcHNbb2Zmc2V0IC0gY29sc10gKyAxXTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDRdID0gY29vcmRzTWFwW3BzW29mZnNldCAtIDFdXTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDVdID0gY29vcmRzTWFwW3BzW29mZnNldCAtIDFdICsgMV07XG4gICAgICAgICAgICAgIGNvbG9yc1tjSW5kZXhdID0gY29sb3JzTWFwW2NzW29mZnNldCAtIGNvbHMgLSAxXV07XG4gICAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyAxXSA9IGNvbG9yc01hcFtjc1tvZmZzZXQgLSBjb2xzIC0gMV0gKyAxXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDJdID0gY29sb3JzTWFwW2NzW29mZnNldCAtIGNvbHMgLSAxXSArIDJdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgM10gPSBjb2xvcnNNYXBbY3Nbb2Zmc2V0IC0gY29sc11dO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgNF0gPSBjb2xvcnNNYXBbY3Nbb2Zmc2V0IC0gY29sc10gKyAxXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDVdID0gY29sb3JzTWFwW2NzW29mZnNldCAtIGNvbHNdICsgMl07XG4gICAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyA2XSA9IGNvbG9yc01hcFtjc1tvZmZzZXQgLSAxXV07XG4gICAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyA3XSA9IGNvbG9yc01hcFtjc1tvZmZzZXQgLSAxXSArIDFdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgOF0gPSBjb2xvcnNNYXBbY3Nbb2Zmc2V0IC0gMV0gKyAyXTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDZdID0gY29vcmRzW3BJbmRleCArIDJdO1xuICAgICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgN10gPSBjb29yZHNbcEluZGV4ICsgM107XG4gICAgICAgICAgICAgIGNvb3Jkc1twSW5kZXggKyA4XSA9IGNvb3Jkc1twSW5kZXggKyA0XTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDldID0gY29vcmRzW3BJbmRleCArIDVdO1xuICAgICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgMTBdID0gY29vcmRzTWFwW3BzW29mZnNldF1dO1xuICAgICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgMTFdID0gY29vcmRzTWFwW3BzW29mZnNldF0gKyAxXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDldID0gY29sb3JzW2NJbmRleCArIDNdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTBdID0gY29sb3JzW2NJbmRleCArIDRdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTFdID0gY29sb3JzW2NJbmRleCArIDVdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTJdID0gY29sb3JzW2NJbmRleCArIDZdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTNdID0gY29sb3JzW2NJbmRleCArIDddO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTRdID0gY29sb3JzW2NJbmRleCArIDhdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTVdID0gY29sb3JzTWFwW2NzW29mZnNldF1dO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTZdID0gY29sb3JzTWFwW2NzW29mZnNldF0gKyAxXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDE3XSA9IGNvbG9yc01hcFtjc1tvZmZzZXRdICsgMl07XG4gICAgICAgICAgICAgIHBJbmRleCArPSAxMjtcbiAgICAgICAgICAgICAgY0luZGV4ICs9IDE4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJ0cmlhbmdsZXNcIjpcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBwcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICBjb29yZHNbcEluZGV4XSA9IGNvb3Jkc01hcFtwc1tqXV07XG4gICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgMV0gPSBjb29yZHNNYXBbcHNbal0gKyAxXTtcbiAgICAgICAgICAgIGNvbG9yc1tjSW5kZXhdID0gY29sb3JzTWFwW2NzW2pdXTtcbiAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyAxXSA9IGNvbG9yc01hcFtjc1tqXSArIDFdO1xuICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDJdID0gY29sb3JzTWFwW2NzW2pdICsgMl07XG4gICAgICAgICAgICBwSW5kZXggKz0gMjtcbiAgICAgICAgICAgIGNJbmRleCArPSAzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGdsLmNsZWFyQ29sb3IoYmFja2dyb3VuZENvbG9yWzBdIC8gMjU1LCBiYWNrZ3JvdW5kQ29sb3JbMV0gLyAyNTUsIGJhY2tncm91bmRDb2xvclsyXSAvIDI1NSwgMS4wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICB9XG5cbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICB2YXIgY29vcmRzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGNvb3Jkc0J1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGNvb3JkcywgZ2wuU1RBVElDX0RSQVcpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNhY2hlLnBvc2l0aW9uTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY2FjaGUucG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICB2YXIgY29sb3JzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGNvbG9yc0J1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGNvbG9ycywgZ2wuU1RBVElDX0RSQVcpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNhY2hlLmNvbG9yTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY2FjaGUuY29sb3JMb2NhdGlvbiwgMywgZ2wuVU5TSUdORURfQllURSwgZmFsc2UsIDAsIDApO1xuICAgIGdsLnVuaWZvcm0yZihjYWNoZS5zY2FsZUxvY2F0aW9uLCBjb250ZXh0LnNjYWxlWCwgY29udGV4dC5zY2FsZVkpO1xuICAgIGdsLnVuaWZvcm0yZihjYWNoZS5vZmZzZXRMb2NhdGlvbiwgY29udGV4dC5vZmZzZXRYLCBjb250ZXh0Lm9mZnNldFkpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBjb3VudCk7XG4gICAgZ2wuZmx1c2goKTtcbiAgICBnbC5kZWxldGVCdWZmZXIoY29vcmRzQnVmZmVyKTtcbiAgICBnbC5kZWxldGVCdWZmZXIoY29sb3JzQnVmZmVyKTtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0cnlJbml0R0w6IGZ1bmN0aW9uIHRyeUluaXRHTCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGdlbmVyYXRlR0woKTtcbiAgICAgICAgcmV0dXJuICEhY3VycmVudEdMO1xuICAgICAgfSBjYXRjaCAoZXgpIHt9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGNvbXBvc2VTTWFzazogY29tcG9zZVNNYXNrLFxuICAgIGRyYXdGaWd1cmVzOiBkcmF3RmlndXJlcyxcbiAgICBjbGVhbnVwOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgdmFyIF9zbWFza0NhY2hlLCBfZmlndXJlc0NhY2hlO1xuXG4gICAgICBpZiAoKF9zbWFza0NhY2hlID0gc21hc2tDYWNoZSkgIT09IG51bGwgJiYgX3NtYXNrQ2FjaGUgIT09IHZvaWQgMCAmJiBfc21hc2tDYWNoZS5jYW52YXMpIHtcbiAgICAgICAgc21hc2tDYWNoZS5jYW52YXMud2lkdGggPSAwO1xuICAgICAgICBzbWFza0NhY2hlLmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoKF9maWd1cmVzQ2FjaGUgPSBmaWd1cmVzQ2FjaGUpICE9PSBudWxsICYmIF9maWd1cmVzQ2FjaGUgIT09IHZvaWQgMCAmJiBfZmlndXJlc0NhY2hlLmNhbnZhcykge1xuICAgICAgICBmaWd1cmVzQ2FjaGUuY2FudmFzLndpZHRoID0gMDtcbiAgICAgICAgZmlndXJlc0NhY2hlLmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgfVxuXG4gICAgICBzbWFza0NhY2hlID0gbnVsbDtcbiAgICAgIGZpZ3VyZXNDYWNoZSA9IG51bGw7XG4gICAgfVxuICB9O1xufSgpO1xuXG4vKioqLyB9KSxcbi8qIDE0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5Bbm5vdGF0aW9uTGF5ZXIgPSB2b2lkIDA7XG5cbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG5cbnZhciBfYW5ub3RhdGlvbl9zdG9yYWdlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzgpO1xuXG52YXIgX3NjcmlwdGluZ191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUwKTtcblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IHRocm93IF9lMjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTMpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UzOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIEFubm90YXRpb25FbGVtZW50RmFjdG9yeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb25FbGVtZW50RmFjdG9yeSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnksIG51bGwsIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUocGFyYW1ldGVycykge1xuICAgICAgdmFyIHN1YnR5cGUgPSBwYXJhbWV0ZXJzLmRhdGEuYW5ub3RhdGlvblR5cGU7XG5cbiAgICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkxJTks6XG4gICAgICAgICAgcmV0dXJuIG5ldyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5URVhUOlxuICAgICAgICAgIHJldHVybiBuZXcgVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuV0lER0VUOlxuICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSBwYXJhbWV0ZXJzLmRhdGEuZmllbGRUeXBlO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJUeFwiOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICAgICAgY2FzZSBcIkJ0blwiOlxuICAgICAgICAgICAgICBpZiAocGFyYW1ldGVycy5kYXRhLnJhZGlvQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMuZGF0YS5jaGVja0JveCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICAgICAgICBjYXNlIFwiQ2hcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3IFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuUE9QVVA6XG4gICAgICAgICAgcmV0dXJuIG5ldyBQb3B1cEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuRlJFRVRFWFQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuTElORTpcbiAgICAgICAgICByZXR1cm4gbmV3IExpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNRVUFSRTpcbiAgICAgICAgICByZXR1cm4gbmV3IFNxdWFyZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuQ0lSQ0xFOlxuICAgICAgICAgIHJldHVybiBuZXcgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5QT0xZTElORTpcbiAgICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5DQVJFVDpcbiAgICAgICAgICByZXR1cm4gbmV3IENhcmV0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5JTks6XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlBPTFlHT046XG4gICAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5ISUdITElHSFQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlVOREVSTElORTpcbiAgICAgICAgICByZXR1cm4gbmV3IFVuZGVybGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuU1FVSUdHTFk6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuU1RSSUtFT1VUOlxuICAgICAgICAgIHJldHVybiBuZXcgU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5TVEFNUDpcbiAgICAgICAgICByZXR1cm4gbmV3IFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5GSUxFQVRUQUNITUVOVDpcbiAgICAgICAgICByZXR1cm4gbmV3IEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbmV3IEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbm5vdGF0aW9uRWxlbWVudEZhY3Rvcnk7XG59KCk7XG5cbnZhciBBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgIF9yZWYkaXNSZW5kZXJhYmxlID0gX3JlZi5pc1JlbmRlcmFibGUsXG4gICAgICAgIGlzUmVuZGVyYWJsZSA9IF9yZWYkaXNSZW5kZXJhYmxlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaXNSZW5kZXJhYmxlLFxuICAgICAgICBfcmVmJGlnbm9yZUJvcmRlciA9IF9yZWYuaWdub3JlQm9yZGVyLFxuICAgICAgICBpZ25vcmVCb3JkZXIgPSBfcmVmJGlnbm9yZUJvcmRlciA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGlnbm9yZUJvcmRlcixcbiAgICAgICAgX3JlZiRjcmVhdGVRdWFkcmlsYXRlID0gX3JlZi5jcmVhdGVRdWFkcmlsYXRlcmFscyxcbiAgICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHMgPSBfcmVmJGNyZWF0ZVF1YWRyaWxhdGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRjcmVhdGVRdWFkcmlsYXRlO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFubm90YXRpb25FbGVtZW50KTtcblxuICAgIHRoaXMuaXNSZW5kZXJhYmxlID0gaXNSZW5kZXJhYmxlO1xuICAgIHRoaXMuZGF0YSA9IHBhcmFtZXRlcnMuZGF0YTtcbiAgICB0aGlzLmxheWVyID0gcGFyYW1ldGVycy5sYXllcjtcbiAgICB0aGlzLnBhZ2UgPSBwYXJhbWV0ZXJzLnBhZ2U7XG4gICAgdGhpcy52aWV3cG9ydCA9IHBhcmFtZXRlcnMudmlld3BvcnQ7XG4gICAgdGhpcy5saW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIgPSBwYXJhbWV0ZXJzLmRvd25sb2FkTWFuYWdlcjtcbiAgICB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCA9IHBhcmFtZXRlcnMuaW1hZ2VSZXNvdXJjZXNQYXRoO1xuICAgIHRoaXMucmVuZGVySW50ZXJhY3RpdmVGb3JtcyA9IHBhcmFtZXRlcnMucmVuZGVySW50ZXJhY3RpdmVGb3JtcztcbiAgICB0aGlzLnN2Z0ZhY3RvcnkgPSBwYXJhbWV0ZXJzLnN2Z0ZhY3Rvcnk7XG4gICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZSA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgdGhpcy5lbmFibGVTY3JpcHRpbmcgPSBwYXJhbWV0ZXJzLmVuYWJsZVNjcmlwdGluZztcbiAgICB0aGlzLmhhc0pTQWN0aW9ucyA9IHBhcmFtZXRlcnMuaGFzSlNBY3Rpb25zO1xuICAgIHRoaXMuX21vdXNlU3RhdGUgPSBwYXJhbWV0ZXJzLm1vdXNlU3RhdGU7XG5cbiAgICBpZiAoaXNSZW5kZXJhYmxlKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpO1xuICAgIH1cblxuICAgIGlmIChjcmVhdGVRdWFkcmlsYXRlcmFscykge1xuICAgICAgdGhpcy5xdWFkcmlsYXRlcmFscyA9IHRoaXMuX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKGlnbm9yZUJvcmRlcik7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJfY3JlYXRlQ29udGFpbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVDb250YWluZXIoKSB7XG4gICAgICB2YXIgaWdub3JlQm9yZGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICAgIHBhZ2UgPSB0aGlzLnBhZ2UsXG4gICAgICAgICAgdmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0O1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIpO1xuICAgICAgdmFyIHdpZHRoID0gZGF0YS5yZWN0WzJdIC0gZGF0YS5yZWN0WzBdO1xuICAgICAgdmFyIGhlaWdodCA9IGRhdGEucmVjdFszXSAtIGRhdGEucmVjdFsxXTtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFubm90YXRpb24taWRcIiwgZGF0YS5pZCk7XG5cbiAgICAgIHZhciByZWN0ID0gX3V0aWwuVXRpbC5ub3JtYWxpemVSZWN0KFtkYXRhLnJlY3RbMF0sIHBhZ2Uudmlld1szXSAtIGRhdGEucmVjdFsxXSArIHBhZ2Uudmlld1sxXSwgZGF0YS5yZWN0WzJdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbM10gKyBwYWdlLnZpZXdbMV1dKTtcblxuICAgICAgY29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9IFwibWF0cml4KFwiLmNvbmNhdCh2aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIiksIFwiKVwiKTtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcIlwiLmNvbmNhdCgtcmVjdFswXSwgXCJweCBcIikuY29uY2F0KC1yZWN0WzFdLCBcInB4XCIpO1xuXG4gICAgICBpZiAoIWlnbm9yZUJvcmRlciAmJiBkYXRhLmJvcmRlclN0eWxlLndpZHRoID4gMCkge1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyV2lkdGggPSBcIlwiLmNvbmNhdChkYXRhLmJvcmRlclN0eWxlLndpZHRoLCBcInB4XCIpO1xuXG4gICAgICAgIGlmIChkYXRhLmJvcmRlclN0eWxlLnN0eWxlICE9PSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlVOREVSTElORSkge1xuICAgICAgICAgIHdpZHRoID0gd2lkdGggLSAyICogZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgLSAyICogZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBob3Jpem9udGFsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS5ob3Jpem9udGFsQ29ybmVyUmFkaXVzO1xuICAgICAgICB2YXIgdmVydGljYWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLnZlcnRpY2FsQ29ybmVyUmFkaXVzO1xuXG4gICAgICAgIGlmIChob3Jpem9udGFsUmFkaXVzID4gMCB8fCB2ZXJ0aWNhbFJhZGl1cyA+IDApIHtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gXCJcIi5jb25jYXQoaG9yaXpvbnRhbFJhZGl1cywgXCJweCAvIFwiKS5jb25jYXQodmVydGljYWxSYWRpdXMsIFwicHhcIik7XG4gICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZGF0YS5ib3JkZXJTdHlsZS5zdHlsZSkge1xuICAgICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5TT0xJRDpcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJTdHlsZSA9IFwic29saWRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkRBU0hFRDpcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJTdHlsZSA9IFwiZGFzaGVkXCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5CRVZFTEVEOlxuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGJldmVsZWRcIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5JTlNFVDpcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBpbnNldFwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlVOREVSTElORTpcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJCb3R0b21TdHlsZSA9IFwic29saWRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuY29sb3IpIHtcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihkYXRhLmNvbG9yWzBdIHwgMCwgZGF0YS5jb2xvclsxXSB8IDAsIGRhdGEuY29sb3JbMl0gfCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQocmVjdFswXSwgXCJweFwiKTtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdChyZWN0WzFdLCBcInB4XCIpO1xuICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIik7XG4gICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVF1YWRyaWxhdGVyYWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVRdWFkcmlsYXRlcmFscygpIHtcbiAgICAgIHZhciBpZ25vcmVCb3JkZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoIXRoaXMuZGF0YS5xdWFkUG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcXVhZHJpbGF0ZXJhbHMgPSBbXTtcbiAgICAgIHZhciBzYXZlZFJlY3QgPSB0aGlzLmRhdGEucmVjdDtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZGF0YS5xdWFkUG9pbnRzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcXVhZFBvaW50ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdGhpcy5kYXRhLnJlY3QgPSBbcXVhZFBvaW50WzJdLngsIHF1YWRQb2ludFsyXS55LCBxdWFkUG9pbnRbMV0ueCwgcXVhZFBvaW50WzFdLnldO1xuICAgICAgICAgIHF1YWRyaWxhdGVyYWxzLnB1c2godGhpcy5fY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcikpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YS5yZWN0ID0gc2F2ZWRSZWN0O1xuICAgICAgcmV0dXJuIHF1YWRyaWxhdGVyYWxzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlUG9wdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVBvcHVwKHRyaWdnZXIsIGRhdGEpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcblxuICAgICAgaWYgKHRoaXMucXVhZHJpbGF0ZXJhbHMpIHtcbiAgICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgdGhpcy5xdWFkcmlsYXRlcmFscztcbiAgICAgICAgY29udGFpbmVyID0gdGhpcy5xdWFkcmlsYXRlcmFsc1swXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0cmlnZ2VyKSB7XG4gICAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0cmlnZ2VyLnN0eWxlLmhlaWdodCA9IGNvbnRhaW5lci5zdHlsZS5oZWlnaHQ7XG4gICAgICAgIHRyaWdnZXIuc3R5bGUud2lkdGggPSBjb250YWluZXIuc3R5bGUud2lkdGg7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0cmlnZ2VyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvcHVwRWxlbWVudCA9IG5ldyBQb3B1cEVsZW1lbnQoe1xuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgdHJpZ2dlcjogdHJpZ2dlcixcbiAgICAgICAgY29sb3I6IGRhdGEuY29sb3IsXG4gICAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlOiBkYXRhLm1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICAgIGNvbnRlbnRzOiBkYXRhLmNvbnRlbnRzLFxuICAgICAgICBoaWRlV3JhcHBlcjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB2YXIgcG9wdXAgPSBwb3B1cEVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBwb3B1cC5zdHlsZS5sZWZ0ID0gY29udGFpbmVyLnN0eWxlLndpZHRoO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBvcHVwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbmRlclF1YWRyaWxhdGVyYWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJRdWFkcmlsYXRlcmFscyhjbGFzc05hbWUpIHtcbiAgICAgIHRoaXMucXVhZHJpbGF0ZXJhbHMuZm9yRWFjaChmdW5jdGlvbiAocXVhZHJpbGF0ZXJhbCkge1xuICAgICAgICBxdWFkcmlsYXRlcmFsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMucXVhZHJpbGF0ZXJhbHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBBbm5vdGF0aW9uRWxlbWVudC5yZW5kZXJgIGNhbGxlZFwiKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQW5ub3RhdGlvbkVsZW1lbnQ7XG59KCk7XG5cbnZhciBMaW5rQW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudCkge1xuICBfaW5oZXJpdHMoTGlua0Fubm90YXRpb25FbGVtZW50LCBfQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTGlua0Fubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBMaW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5rQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS51cmwgfHwgcGFyYW1ldGVycy5kYXRhLmRlc3QgfHwgcGFyYW1ldGVycy5kYXRhLmFjdGlvbiB8fCBwYXJhbWV0ZXJzLmRhdGEuaXNUb29sdGlwT25seSB8fCBwYXJhbWV0ZXJzLmRhdGEuYWN0aW9ucyAmJiAocGFyYW1ldGVycy5kYXRhLmFjdGlvbnMuQWN0aW9uIHx8IHBhcmFtZXRlcnMuZGF0YS5hY3Rpb25zW1wiTW91c2UgVXBcIl0gfHwgcGFyYW1ldGVycy5kYXRhLmFjdGlvbnNbXCJNb3VzZSBEb3duXCJdKSk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5rQW5ub3RhdGlvbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICBsaW5rU2VydmljZSA9IHRoaXMubGlua1NlcnZpY2U7XG4gICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXG4gICAgICBpZiAoZGF0YS51cmwpIHtcbiAgICAgICAgKDAsIF9kaXNwbGF5X3V0aWxzLmFkZExpbmtBdHRyaWJ1dGVzKShsaW5rLCB7XG4gICAgICAgICAgdXJsOiBkYXRhLnVybCxcbiAgICAgICAgICB0YXJnZXQ6IGRhdGEubmV3V2luZG93ID8gX2Rpc3BsYXlfdXRpbHMuTGlua1RhcmdldC5CTEFOSyA6IGxpbmtTZXJ2aWNlLmV4dGVybmFsTGlua1RhcmdldCxcbiAgICAgICAgICByZWw6IGxpbmtTZXJ2aWNlLmV4dGVybmFsTGlua1JlbCxcbiAgICAgICAgICBlbmFibGVkOiBsaW5rU2VydmljZS5leHRlcm5hbExpbmtFbmFibGVkXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmFjdGlvbikge1xuICAgICAgICB0aGlzLl9iaW5kTmFtZWRBY3Rpb24obGluaywgZGF0YS5hY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmRlc3QpIHtcbiAgICAgICAgdGhpcy5fYmluZExpbmsobGluaywgZGF0YS5kZXN0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb25zICYmIChkYXRhLmFjdGlvbnMuQWN0aW9uIHx8IGRhdGEuYWN0aW9uc1tcIk1vdXNlIFVwXCJdIHx8IGRhdGEuYWN0aW9uc1tcIk1vdXNlIERvd25cIl0pICYmIHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuX2JpbmRKU0FjdGlvbihsaW5rLCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIFwiXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5xdWFkcmlsYXRlcmFscykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUXVhZHJpbGF0ZXJhbHMoXCJsaW5rQW5ub3RhdGlvblwiKS5tYXAoZnVuY3Rpb24gKHF1YWRyaWxhdGVyYWwsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGxpbmtFbGVtZW50ID0gaW5kZXggPT09IDAgPyBsaW5rIDogbGluay5jbG9uZU5vZGUoKTtcbiAgICAgICAgICBxdWFkcmlsYXRlcmFsLmFwcGVuZENoaWxkKGxpbmtFbGVtZW50KTtcbiAgICAgICAgICByZXR1cm4gcXVhZHJpbGF0ZXJhbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwibGlua0Fubm90YXRpb25cIjtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGxpbmspO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYmluZExpbmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRMaW5rKGxpbmssIGRlc3RpbmF0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldERlc3RpbmF0aW9uSGFzaChkZXN0aW5hdGlvbik7XG5cbiAgICAgIGxpbmsub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgX3RoaXMubGlua1NlcnZpY2UuZ29Ub0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChkZXN0aW5hdGlvbiB8fCBkZXN0aW5hdGlvbiA9PT0gXCJcIikge1xuICAgICAgICBsaW5rLmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxMaW5rXCI7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9iaW5kTmFtZWRBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmROYW1lZEFjdGlvbihsaW5rLCBhY3Rpb24pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcblxuICAgICAgbGluay5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIubGlua1NlcnZpY2UuZXhlY3V0ZU5hbWVkQWN0aW9uKGFjdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgbGluay5jbGFzc05hbWUgPSBcImludGVybmFsTGlua1wiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYmluZEpTQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kSlNBY3Rpb24obGluaywgZGF0YSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoW1tcIkFjdGlvblwiLCBcIm9uY2xpY2tcIl0sIFtcIk1vdXNlIFVwXCIsIFwib25tb3VzZXVwXCJdLCBbXCJNb3VzZSBEb3duXCIsIFwib25tb3VzZWRvd25cIl1dKTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIHZhciBuYW1lID0gX09iamVjdCRrZXlzW19pXTtcbiAgICAgICAgdmFyIGpzTmFtZSA9IG1hcC5nZXQobmFtZSk7XG5cbiAgICAgICAgaWYgKCFqc05hbWUpIHtcbiAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlua1tqc05hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpczMkbGlua1NlcnZpY2UkZXY7XG5cbiAgICAgICAgICAoX3RoaXMzJGxpbmtTZXJ2aWNlJGV2ID0gX3RoaXMzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzKSA9PT0gbnVsbCB8fCBfdGhpczMkbGlua1NlcnZpY2UkZXYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzMyRsaW5rU2VydmljZSRldi5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgc291cmNlOiBfdGhpczMsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKGRhdGEuYWN0aW9ucyk7IF9pIDwgX09iamVjdCRrZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX3JldCA9IF9sb29wKCk7XG5cbiAgICAgICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxpbmsuY2xhc3NOYW1lID0gXCJpbnRlcm5hbExpbmtcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGlua0Fubm90YXRpb25FbGVtZW50O1xufShBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBUZXh0QW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDIpIHtcbiAgX2luaGVyaXRzKFRleHRBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50Mik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoVGV4dEFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICByZXR1cm4gX3N1cGVyMi5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV4dEFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJ0ZXh0QW5ub3RhdGlvblwiO1xuICAgICAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIGltYWdlLnN0eWxlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLnN0eWxlLmhlaWdodDtcbiAgICAgIGltYWdlLnN0eWxlLndpZHRoID0gdGhpcy5jb250YWluZXIuc3R5bGUud2lkdGg7XG4gICAgICBpbWFnZS5zcmMgPSB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCArIFwiYW5ub3RhdGlvbi1cIiArIHRoaXMuZGF0YS5uYW1lLnRvTG93ZXJDYXNlKCkgKyBcIi5zdmdcIjtcbiAgICAgIGltYWdlLmFsdCA9IFwiW3t7dHlwZX19IEFubm90YXRpb25dXCI7XG4gICAgICBpbWFnZS5kYXRhc2V0LmwxMG5JZCA9IFwidGV4dF9hbm5vdGF0aW9uX3R5cGVcIjtcbiAgICAgIGltYWdlLmRhdGFzZXQubDEwbkFyZ3MgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHR5cGU6IHRoaXMuZGF0YS5uYW1lXG4gICAgICB9KTtcblxuICAgICAgaWYgKCF0aGlzLmRhdGEuaGFzUG9wdXApIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoaW1hZ2UsIHRoaXMuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGltYWdlKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dEFubm90YXRpb25FbGVtZW50O1xufShBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fubm90YXRpb25FbGVtZW50Mykge1xuICBfaW5oZXJpdHMoV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQsIF9Bbm5vdGF0aW9uRWxlbWVudDMpO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKFdpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICh0aGlzLmRhdGEuYWx0ZXJuYXRpdmVUZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnRpdGxlID0gdGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0S2V5TW9kaWZpZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEtleU1vZGlmaWVyKGV2ZW50KSB7XG4gICAgICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtLmluY2x1ZGVzKFwiV2luXCIpICYmIGV2ZW50LmN0cmxLZXkgfHwgbmF2aWdhdG9yLnBsYXRmb3JtLmluY2x1ZGVzKFwiTWFjXCIpICYmIGV2ZW50Lm1ldGFLZXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGJhc2VOYW1lLCBldmVudE5hbWUsIHZhbHVlR2V0dGVyKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKGJhc2VOYW1lLmluY2x1ZGVzKFwibW91c2VcIikpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VOYW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXM0JGxpbmtTZXJ2aWNlJGV2O1xuXG4gICAgICAgICAgKF90aGlzNCRsaW5rU2VydmljZSRldiA9IF90aGlzNC5saW5rU2VydmljZS5ldmVudEJ1cykgPT09IG51bGwgfHwgX3RoaXM0JGxpbmtTZXJ2aWNlJGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpczQkbGlua1NlcnZpY2UkZXYuZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogX3RoaXM0LFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgIGlkOiBfdGhpczQuZGF0YS5pZCxcbiAgICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpLFxuICAgICAgICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICAgIG1vZGlmaWVyOiBfdGhpczQuX2dldEtleU1vZGlmaWVyKGV2ZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlTmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIF90aGlzNCRsaW5rU2VydmljZSRldjI7XG5cbiAgICAgICAgICAoX3RoaXM0JGxpbmtTZXJ2aWNlJGV2MiA9IF90aGlzNC5saW5rU2VydmljZS5ldmVudEJ1cykgPT09IG51bGwgfHwgX3RoaXM0JGxpbmtTZXJ2aWNlJGV2MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXM0JGxpbmtTZXJ2aWNlJGV2Mi5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgc291cmNlOiBfdGhpczQsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgaWQ6IF90aGlzNC5kYXRhLmlkLFxuICAgICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBuYW1lcywgZ2V0dGVyKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG5hbWVzKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF90aGlzJGRhdGEkYWN0aW9ucztcblxuICAgICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLFxuICAgICAgICAgICAgICBiYXNlTmFtZSA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgZXZlbnROYW1lID0gX3N0ZXAyJHZhbHVlWzFdO1xuXG4gICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJBY3Rpb25cIiB8fCAoX3RoaXMkZGF0YSRhY3Rpb25zID0gdGhpcy5kYXRhLmFjdGlvbnMpICE9PSBudWxsICYmIF90aGlzJGRhdGEkYWN0aW9ucyAhPT0gdm9pZCAwICYmIF90aGlzJGRhdGEkYWN0aW9uc1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGJhc2VOYW1lLCBldmVudE5hbWUsIGdldHRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1dpZGdldEFubm90YXRpb25FbGVtKSB7XG4gIF9pbmhlcml0cyhUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQsIF9XaWRnZXRBbm5vdGF0aW9uRWxlbSk7XG5cbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9IHBhcmFtZXRlcnMucmVuZGVySW50ZXJhY3RpdmVGb3JtcyB8fCAhcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2UgJiYgISFwYXJhbWV0ZXJzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICByZXR1cm4gX3N1cGVyNC5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICAgIHZhciBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwidGV4dFdpZGdldEFubm90YXRpb25cIjtcbiAgICAgIHZhciBlbGVtZW50ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMucmVuZGVySW50ZXJhY3RpdmVGb3Jtcykge1xuICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSBzdG9yYWdlLmdldE9yQ3JlYXRlVmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICAgICAgfSkudmFsdWU7XG4gICAgICAgIHZhciBlbGVtZW50RGF0YSA9IHtcbiAgICAgICAgICB1c2VyVmFsdWU6IG51bGwsXG4gICAgICAgICAgZm9ybWF0dGVkVmFsdWU6IG51bGwsXG4gICAgICAgICAgYmVmb3JlSW5wdXRTZWxlY3Rpb25SYW5nZTogbnVsbCxcbiAgICAgICAgICBiZWZvcmVJbnB1dFZhbHVlOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgIGVsZW1lbnQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgdGV4dENvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdGV4dENvbnRlbnQ7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBibHVyTGlzdGVuZXIgPSBmdW5jdGlvbiBibHVyTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV2ZW50LnRhcmdldC5zZXRTZWxlY3Rpb25SYW5nZSgwLCAwKTtcbiAgICAgICAgICBlbGVtZW50RGF0YS5iZWZvcmVJbnB1dFNlbGVjdGlvblJhbmdlID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkZGF0YSRhY3Rpb25zMjtcblxuICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnREYXRhLnVzZXJWYWx1ZSkge1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZGV0YWlsID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgdmFyIGFjdGlvbnMgPSB7XG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSBkZXRhaWwudmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZWxlbWVudERhdGEudXNlclZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHZhbHVlQXNTdHJpbmc6IGZ1bmN0aW9uIHZhbHVlQXNTdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBkZXRhaWwudmFsdWVBc1N0cmluZyB8fCBcIlwiO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWU6IGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQuZm9jdXMoe1xuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHVzZXJOYW1lOiBmdW5jdGlvbiB1c2VyTmFtZSgpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQudGl0bGUgPSBkZXRhaWwudXNlck5hbWU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGhpZGRlbjogZnVuY3Rpb24gaGlkZGVuKCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5zdHlsZS52aXNpYmlsaXR5ID0gZGV0YWlsLmhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgICBoaWRkZW46IGRldGFpbC5oaWRkZW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZWRpdGFibGU6IGZ1bmN0aW9uIGVkaXRhYmxlKCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9ICFkZXRhaWwuZWRpdGFibGU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNlbFJhbmdlOiBmdW5jdGlvbiBzZWxSYW5nZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2RldGFpbCRzZWxSYW5nZSA9IF9zbGljZWRUb0FycmF5KGRldGFpbC5zZWxSYW5nZSwgMiksXG4gICAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0ID0gX2RldGFpbCRzZWxSYW5nZVswXSxcbiAgICAgICAgICAgICAgICAgICAgc2VsRW5kID0gX2RldGFpbCRzZWxSYW5nZVsxXTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxTdGFydCA+PSAwICYmIHNlbEVuZCA8IGV2ZW50LnRhcmdldC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5zZXRTZWxlY3Rpb25SYW5nZShzZWxTdGFydCwgc2VsRW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBmdW5jdGlvbiBzdHJva2VDb2xvcigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBkZXRhaWwuc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnN0eWxlLmNvbG9yID0gX3NjcmlwdGluZ191dGlscy5Db2xvckNvbnZlcnRlcnNbXCJcIi5jb25jYXQoY29sb3JbMF0sIFwiX0hUTUxcIildKGNvbG9yLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRldGFpbCkuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuYW1lIGluIGFjdGlvbnM7XG4gICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhY3Rpb25zW25hbWVdKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF90aGlzNSRsaW5rU2VydmljZSRldjtcblxuICAgICAgICAgICAgZWxlbWVudERhdGEuYmVmb3JlSW5wdXRWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBjb21taXRLZXkgPSAtMTtcblxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgICBjb21taXRLZXkgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgICBjb21taXRLZXkgPSAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiVGFiXCIpIHtcbiAgICAgICAgICAgICAgY29tbWl0S2V5ID0gMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbW1pdEtleSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICAoX3RoaXM1JGxpbmtTZXJ2aWNlJGV2ID0gX3RoaXM1LmxpbmtTZXJ2aWNlLmV2ZW50QnVzKSA9PT0gbnVsbCB8fCBfdGhpczUkbGlua1NlcnZpY2UkZXYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzNSRsaW5rU2VydmljZSRldi5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IF90aGlzNSxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbW1pdEtleTogY29tbWl0S2V5LFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBfYmx1ckxpc3RlbmVyID0gYmx1ckxpc3RlbmVyO1xuICAgICAgICAgIGJsdXJMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczUuX21vdXNlU3RhdGUuaXNEb3duKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczUkbGlua1NlcnZpY2UkZXYyO1xuXG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgICAgKF90aGlzNSRsaW5rU2VydmljZSRldjIgPSBfdGhpczUubGlua1NlcnZpY2UuZXZlbnRCdXMpID09PSBudWxsIHx8IF90aGlzNSRsaW5rU2VydmljZSRldjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzNSRsaW5rU2VydmljZSRldjIuZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IF90aGlzNSxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICBzZWxFbmQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfYmx1ckxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5iZWZvcmVJbnB1dFZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgZWxlbWVudERhdGEuYmVmb3JlSW5wdXRTZWxlY3Rpb25SYW5nZSA9IG51bGw7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnNlbGVjdGlvblN0YXJ0ID09PSBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLmJlZm9yZUlucHV0U2VsZWN0aW9uUmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmJlZm9yZUlucHV0U2VsZWN0aW9uUmFuZ2UgPSBbZXZlbnQudGFyZ2V0LnNlbGVjdGlvblN0YXJ0LCBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICgoX3RoaXMkZGF0YSRhY3Rpb25zMiA9IHRoaXMuZGF0YS5hY3Rpb25zKSAhPT0gbnVsbCAmJiBfdGhpcyRkYXRhJGFjdGlvbnMyICE9PSB2b2lkIDAgJiYgX3RoaXMkZGF0YSRhY3Rpb25zMi5LZXlzdHJva2UpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM1JGxpbmtTZXJ2aWNlJGV2MztcblxuICAgICAgICAgICAgICB2YXIgc2VsU3RhcnQgPSAtMTtcbiAgICAgICAgICAgICAgdmFyIHNlbEVuZCA9IC0xO1xuXG4gICAgICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5iZWZvcmVJbnB1dFNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9lbGVtZW50RGF0YSRiZWZvcmVJbiA9IF9zbGljZWRUb0FycmF5KGVsZW1lbnREYXRhLmJlZm9yZUlucHV0U2VsZWN0aW9uUmFuZ2UsIDIpO1xuXG4gICAgICAgICAgICAgICAgc2VsU3RhcnQgPSBfZWxlbWVudERhdGEkYmVmb3JlSW5bMF07XG4gICAgICAgICAgICAgICAgc2VsRW5kID0gX2VsZW1lbnREYXRhJGJlZm9yZUluWzFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgKF90aGlzNSRsaW5rU2VydmljZSRldjMgPSBfdGhpczUubGlua1NlcnZpY2UuZXZlbnRCdXMpID09PSBudWxsIHx8IF90aGlzNSRsaW5rU2VydmljZSRldjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzNSRsaW5rU2VydmljZSRldjMuZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IF90aGlzNSxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZWxlbWVudERhdGEuYmVmb3JlSW5wdXRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIGNoYW5nZTogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgc2VsU3RhcnQ6IHNlbFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgc2VsRW5kOiBzZWxFbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgW1tcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmx1ckxpc3RlbmVyKSB7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyTGlzdGVuZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5kaXNhYmxlZCA9IHRoaXMuZGF0YS5yZWFkT25seTtcbiAgICAgICAgZWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcblxuICAgICAgICBpZiAodGhpcy5kYXRhLm1heExlbiAhPT0gbnVsbCkge1xuICAgICAgICAgIGVsZW1lbnQubWF4TGVuZ3RoID0gdGhpcy5kYXRhLm1heExlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRhdGEuY29tYikge1xuICAgICAgICAgIHZhciBmaWVsZFdpZHRoID0gdGhpcy5kYXRhLnJlY3RbMl0gLSB0aGlzLmRhdGEucmVjdFswXTtcbiAgICAgICAgICB2YXIgY29tYldpZHRoID0gZmllbGRXaWR0aCAvIHRoaXMuZGF0YS5tYXhMZW47XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiY29tYlwiKTtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSBcImNhbGMoXCIuY29uY2F0KGNvbWJXaWR0aCwgXCJweCAtIDFjaClcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IFwibWlkZGxlXCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwidGFibGUtY2VsbFwiO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGUoZWxlbWVudCk7XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0VGV4dFN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRUZXh0U3R5bGUoZWxlbWVudCkge1xuICAgICAgdmFyIFRFWFRfQUxJR05NRU5UID0gW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCJdO1xuICAgICAgdmFyIF90aGlzJGRhdGEkZGVmYXVsdEFwcCA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEsXG4gICAgICAgICAgZm9udFNpemUgPSBfdGhpcyRkYXRhJGRlZmF1bHRBcHAuZm9udFNpemUsXG4gICAgICAgICAgZm9udENvbG9yID0gX3RoaXMkZGF0YSRkZWZhdWx0QXBwLmZvbnRDb2xvcjtcbiAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG5cbiAgICAgIGlmIChmb250U2l6ZSkge1xuICAgICAgICBzdHlsZS5mb250U2l6ZSA9IFwiXCIuY29uY2F0KGZvbnRTaXplLCBcInB4XCIpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZS5jb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKGZvbnRDb2xvclswXSwgZm9udENvbG9yWzFdLCBmb250Q29sb3JbMl0pO1xuXG4gICAgICBpZiAodGhpcy5kYXRhLnRleHRBbGlnbm1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgc3R5bGUudGV4dEFsaWduID0gVEVYVF9BTElHTk1FTlRbdGhpcy5kYXRhLnRleHRBbGlnbm1lbnRdO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQ7XG59KFdpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9XaWRnZXRBbm5vdGF0aW9uRWxlbTIpIHtcbiAgX2luaGVyaXRzKENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQsIF9XaWRnZXRBbm5vdGF0aW9uRWxlbTIpO1xuXG4gIHZhciBfc3VwZXI1ID0gX2NyZWF0ZVN1cGVyKENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxuICAgIHJldHVybiBfc3VwZXI1LmNhbGwodGhpcywgcGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckludGVyYWN0aXZlRm9ybXNcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB2YXIgaWQgPSBkYXRhLmlkO1xuICAgICAgdmFyIHZhbHVlID0gc3RvcmFnZS5nZXRPckNyZWF0ZVZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBkYXRhLmZpZWxkVmFsdWUgJiYgZGF0YS5maWVsZFZhbHVlICE9PSBcIk9mZlwiXG4gICAgICB9KS52YWx1ZTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvbiBjaGVja0JveFwiO1xuICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICAgIGVsZW1lbnQudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICAgIGVsZW1lbnQubmFtZSA9IHRoaXMuZGF0YS5maWVsZE5hbWU7XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgbmFtZSA9IGV2ZW50LnRhcmdldC5uYW1lO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUobmFtZSkpLFxuICAgICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBjaGVja2JveCA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGNoZWNrYm94ICE9PSBldmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGNoZWNrYm94LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1hbm5vdGF0aW9uLWlkXCIpLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgZGV0YWlsID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgIHZhciBhY3Rpb25zID0ge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGRldGFpbC52YWx1ZSAhPT0gXCJPZmZcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQuZm9jdXMoe1xuICAgICAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZGVuOiBmdW5jdGlvbiBoaWRkZW4oKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5zdHlsZS52aXNpYmlsaXR5ID0gZGV0YWlsLmhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIGhpZGRlbjogZGV0YWlsLmhpZGRlblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlZGl0YWJsZTogZnVuY3Rpb24gZWRpdGFibGUoKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9ICFkZXRhaWwuZWRpdGFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhkZXRhaWwpLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgaW4gYWN0aW9ucztcbiAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uc1tuYW1lXSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBbW1wiY2hhbmdlXCIsIFwiVmFsaWRhdGVcIl0sIFtcImNoYW5nZVwiLCBcIkFjdGlvblwiXSwgW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50O1xufShXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfV2lkZ2V0QW5ub3RhdGlvbkVsZW0zKSB7XG4gIF9pbmhlcml0cyhSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50LCBfV2lkZ2V0QW5ub3RhdGlvbkVsZW0zKTtcblxuICB2YXIgX3N1cGVyNiA9IF9jcmVhdGVTdXBlcihSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICByZXR1cm4gX3N1cGVyNi5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvbiByYWRpb0J1dHRvblwiO1xuICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB2YXIgaWQgPSBkYXRhLmlkO1xuICAgICAgdmFyIHZhbHVlID0gc3RvcmFnZS5nZXRPckNyZWF0ZVZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBkYXRhLmZpZWxkVmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWVcbiAgICAgIH0pLnZhbHVlO1xuICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICAgIGVsZW1lbnQudHlwZSA9IFwicmFkaW9cIjtcbiAgICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInBkZkJ1dHRvblZhbHVlXCIsIGRhdGEuYnV0dG9uVmFsdWUpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSh0YXJnZXQubmFtZSkpLFxuICAgICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciByYWRpbyA9IF9zdGVwNC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHJhZGlvICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5nZXRBdHRyaWJ1dGUoXCJpZFwiKSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiB0YXJnZXQuY2hlY2tlZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIGRldGFpbCA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICB2YXIgYWN0aW9ucyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgICAgdmFyIGZpZWxkVmFsdWUgPSBkZXRhaWwudmFsdWU7XG5cbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShldmVudC50YXJnZXQubmFtZSkpLFxuICAgICAgICAgICAgICAgICAgX3N0ZXA1O1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICAgIHZhciByYWRpbyA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIHZhciByYWRpb0lkID0gcmFkaW8uZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlID09PSByYWRpby5nZXRBdHRyaWJ1dGUoXCJwZGZCdXR0b25WYWx1ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICByYWRpby5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW9JZCwge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGRlbjogZnVuY3Rpb24gaGlkZGVuKCkge1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQuc3R5bGUudmlzaWJpbGl0eSA9IGRldGFpbC5oaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICBoaWRkZW46IGRldGFpbC5oaWRkZW5cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZWRpdGFibGU6IGZ1bmN0aW9uIGVkaXRhYmxlKCkge1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQuZGlzYWJsZWQgPSAhZGV0YWlsLmVkaXRhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmtleXMoZGV0YWlsKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lIGluIGFjdGlvbnM7XG4gICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbnNbbmFtZV0oKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgW1tcImNoYW5nZVwiLCBcIlZhbGlkYXRlXCJdLCBbXCJjaGFuZ2VcIiwgXCJBY3Rpb25cIl0sIFtcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudDtcbn0oV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGlua0Fubm90YXRpb25FbGVtZW4pIHtcbiAgX2luaGVyaXRzKFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCwgX0xpbmtBbm5vdGF0aW9uRWxlbWVuKTtcblxuICB2YXIgX3N1cGVyNyA9IF9jcmVhdGVTdXBlcihQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxuICAgIHJldHVybiBfc3VwZXI3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IF9nZXQoX2dldFByb3RvdHlwZU9mKFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudC5wcm90b3R5cGUpLCBcInJlbmRlclwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uIHB1c2hCdXR0b25cIjtcblxuICAgICAgaWYgKHRoaXMuZGF0YS5hbHRlcm5hdGl2ZVRleHQpIHtcbiAgICAgICAgY29udGFpbmVyLnRpdGxlID0gdGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50O1xufShMaW5rQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9XaWRnZXRBbm5vdGF0aW9uRWxlbTQpIHtcbiAgX2luaGVyaXRzKENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50LCBfV2lkZ2V0QW5ub3RhdGlvbkVsZW00KTtcblxuICB2YXIgX3N1cGVyOCA9IF9jcmVhdGVTdXBlcihDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICByZXR1cm4gX3N1cGVyOC5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJjaG9pY2VXaWRnZXRBbm5vdGF0aW9uXCI7XG4gICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgICB2YXIgaWQgPSB0aGlzLmRhdGEuaWQ7XG4gICAgICBzdG9yYWdlLmdldE9yQ3JlYXRlVmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuZGF0YS5maWVsZFZhbHVlLmxlbmd0aCA+IDAgPyB0aGlzLmRhdGEuZmllbGRWYWx1ZVswXSA6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICB2YXIgc2VsZWN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG4gICAgICBzZWxlY3RFbGVtZW50LmRpc2FibGVkID0gdGhpcy5kYXRhLnJlYWRPbmx5O1xuICAgICAgc2VsZWN0RWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcbiAgICAgIHNlbGVjdEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuXG4gICAgICBpZiAoIXRoaXMuZGF0YS5jb21ibykge1xuICAgICAgICBzZWxlY3RFbGVtZW50LnNpemUgPSB0aGlzLmRhdGEub3B0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aVNlbGVjdCkge1xuICAgICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5kYXRhLm9wdGlvbnMpLFxuICAgICAgICAgIF9zdGVwNjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgb3B0aW9uID0gX3N0ZXA2LnZhbHVlO1xuICAgICAgICAgIHZhciBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9uLmRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gb3B0aW9uLmV4cG9ydFZhbHVlO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZGF0YS5maWVsZFZhbHVlLmluY2x1ZGVzKG9wdGlvbi5leHBvcnRWYWx1ZSkpIHtcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmRDaGlsZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKGV2ZW50LCBpc0V4cG9ydCkge1xuICAgICAgICB2YXIgbmFtZSA9IGlzRXhwb3J0ID8gXCJ2YWx1ZVwiIDogXCJ0ZXh0Q29udGVudFwiO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuXG4gICAgICAgIGlmICghZXZlbnQudGFyZ2V0Lm11bHRpcGxlKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBudWxsIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdW25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChvcHRpb25zLCBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbi5zZWxlY3RlZDtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9uW25hbWVdO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBnZXRJdGVtcyA9IGZ1bmN0aW9uIGdldEl0ZW1zKGV2ZW50KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwob3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXNwbGF5VmFsdWU6IG9wdGlvbi50ZXh0Q29udGVudCxcbiAgICAgICAgICAgIGV4cG9ydFZhbHVlOiBvcHRpb24udmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgZGV0YWlsID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgIHZhciBhY3Rpb25zID0ge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHNlbGVjdEVsZW1lbnQub3B0aW9ucztcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGV0YWlsLnZhbHVlO1xuICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IFNldChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSk7XG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwob3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlcy5oYXMob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUoZXZlbnQsIHRydWUpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxlU2VsZWN0aW9uOiBmdW5jdGlvbiBtdWx0aXBsZVNlbGVjdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgICAgIHZhciBvcHRpb25zID0gc2VsZWN0RWxlbWVudC5vcHRpb25zO1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBkZXRhaWwucmVtb3ZlO1xuICAgICAgICAgICAgICBvcHRpb25zW2luZGV4XS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZShpbmRleCk7XG5cbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleC5jYWxsKG9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb24uc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUoZXZlbnQsIHRydWUpLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICAgICAgICB3aGlsZSAoc2VsZWN0RWxlbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoKSB7XG4gICAgICAgICAgICAgIHZhciBfZGV0YWlsJGluc2VydCA9IGRldGFpbC5pbnNlcnQsXG4gICAgICAgICAgICAgICAgICBpbmRleCA9IF9kZXRhaWwkaW5zZXJ0LmluZGV4LFxuICAgICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlID0gX2RldGFpbCRpbnNlcnQuZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICAgICAgZXhwb3J0VmFsdWUgPSBfZGV0YWlsJGluc2VydC5leHBvcnRWYWx1ZTtcbiAgICAgICAgICAgICAgdmFyIG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gZXhwb3J0VmFsdWU7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuaW5zZXJ0QmVmb3JlKG9wdGlvbkVsZW1lbnQsIHNlbGVjdEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdKTtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZShldmVudCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpdGVtczogZnVuY3Rpb24gaXRlbXMoKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtcyA9IGRldGFpbC5pdGVtcztcblxuICAgICAgICAgICAgICB3aGlsZSAoc2VsZWN0RWxlbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaXRlbXMpLFxuICAgICAgICAgICAgICAgICAgX3N0ZXA3O1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXA3LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgdmFyIGRpc3BsYXlWYWx1ZSA9IGl0ZW0uZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydFZhbHVlID0gaXRlbS5leHBvcnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBkaXNwbGF5VmFsdWU7XG4gICAgICAgICAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gZXhwb3J0VmFsdWU7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZENoaWxkKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yNy5lKGVycik7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoc2VsZWN0RWxlbWVudC5vcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZShldmVudCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmRpY2VzOiBmdW5jdGlvbiBpbmRpY2VzKCkge1xuICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBTZXQoZGV0YWlsLmluZGljZXMpO1xuICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24sIGkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpbmRpY2VzLmhhcyhpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUoZXZlbnQsIHRydWUpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5mb2N1cyh7XG4gICAgICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaWRkZW46IGZ1bmN0aW9uIGhpZGRlbigpIHtcbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnN0eWxlLnZpc2liaWxpdHkgPSBkZXRhaWwuaGlkZGVuID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgaGlkZGVuOiBkZXRhaWwuaGlkZGVuXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBmdW5jdGlvbiBlZGl0YWJsZSgpIHtcbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmRpc2FibGVkID0gIWRldGFpbC5lZGl0YWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5rZXlzKGRldGFpbCkuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZSBpbiBhY3Rpb25zO1xuICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25zW25hbWVdKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXM2JGxpbmtTZXJ2aWNlJGV2O1xuXG4gICAgICAgICAgdmFyIGV4cG9ydFZhbHVlID0gZ2V0VmFsdWUoZXZlbnQsIHRydWUpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKGV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgdmFsdWU6IGV4cG9ydFZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgKF90aGlzNiRsaW5rU2VydmljZSRldiA9IF90aGlzNi5saW5rU2VydmljZS5ldmVudEJ1cykgPT09IG51bGwgfHwgX3RoaXM2JGxpbmtTZXJ2aWNlJGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpczYkbGlua1NlcnZpY2UkZXYuZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogX3RoaXM2LFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICBjaGFuZ2VFeDogZXhwb3J0VmFsdWUsXG4gICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgICAga2V5RG93bjogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoc2VsZWN0RWxlbWVudCwgW1tcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl0sIFtcImlucHV0XCIsIFwiQWN0aW9uXCJdXSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5jaGVja2VkO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZShldmVudClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGVjdEVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudDtcbn0oV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fubm90YXRpb25FbGVtZW50NCkge1xuICBfaW5oZXJpdHMoUG9wdXBBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50NCk7XG5cbiAgdmFyIF9zdXBlcjkgPSBfY3JlYXRlU3VwZXIoUG9wdXBBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gUG9wdXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHJldHVybiBfc3VwZXI5LmNhbGwodGhpcywgcGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGVcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb3B1cEFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIElHTk9SRV9UWVBFUyA9IFtcIkxpbmVcIiwgXCJTcXVhcmVcIiwgXCJDaXJjbGVcIiwgXCJQb2x5TGluZVwiLCBcIlBvbHlnb25cIiwgXCJJbmtcIl07XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcInBvcHVwQW5ub3RhdGlvblwiO1xuXG4gICAgICBpZiAoSUdOT1JFX1RZUEVTLmluY2x1ZGVzKHRoaXMuZGF0YS5wYXJlbnRUeXBlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxlY3RvciA9IFwiW2RhdGEtYW5ub3RhdGlvbi1pZD1cXFwiXCIuY29uY2F0KHRoaXMuZGF0YS5wYXJlbnRJZCwgXCJcXFwiXVwiKTtcbiAgICAgIHZhciBwYXJlbnRFbGVtZW50cyA9IHRoaXMubGF5ZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cbiAgICAgIGlmIChwYXJlbnRFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9wdXAgPSBuZXcgUG9wdXBFbGVtZW50KHtcbiAgICAgICAgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgdHJpZ2dlcjogQXJyYXkuZnJvbShwYXJlbnRFbGVtZW50cyksXG4gICAgICAgIGNvbG9yOiB0aGlzLmRhdGEuY29sb3IsXG4gICAgICAgIHRpdGxlOiB0aGlzLmRhdGEudGl0bGUsXG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IHRoaXMuZGF0YS5tb2RpZmljYXRpb25EYXRlLFxuICAgICAgICBjb250ZW50czogdGhpcy5kYXRhLmNvbnRlbnRzXG4gICAgICB9KTtcbiAgICAgIHZhciBwYWdlID0gdGhpcy5wYWdlO1xuXG4gICAgICB2YXIgcmVjdCA9IF91dGlsLlV0aWwubm9ybWFsaXplUmVjdChbdGhpcy5kYXRhLnBhcmVudFJlY3RbMF0sIHBhZ2Uudmlld1szXSAtIHRoaXMuZGF0YS5wYXJlbnRSZWN0WzFdICsgcGFnZS52aWV3WzFdLCB0aGlzLmRhdGEucGFyZW50UmVjdFsyXSwgcGFnZS52aWV3WzNdIC0gdGhpcy5kYXRhLnBhcmVudFJlY3RbM10gKyBwYWdlLnZpZXdbMV1dKTtcblxuICAgICAgdmFyIHBvcHVwTGVmdCA9IHJlY3RbMF0gKyB0aGlzLmRhdGEucGFyZW50UmVjdFsyXSAtIHRoaXMuZGF0YS5wYXJlbnRSZWN0WzBdO1xuICAgICAgdmFyIHBvcHVwVG9wID0gcmVjdFsxXTtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IFwiXCIuY29uY2F0KC1wb3B1cExlZnQsIFwicHggXCIpLmNvbmNhdCgtcG9wdXBUb3AsIFwicHhcIik7XG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQocG9wdXBMZWZ0LCBcInB4XCIpO1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudG9wID0gXCJcIi5jb25jYXQocG9wdXBUb3AsIFwicHhcIik7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChwb3B1cC5yZW5kZXIoKSk7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIFBvcHVwRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvcHVwRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHVwRWxlbWVudCk7XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IHBhcmFtZXRlcnMuY29udGFpbmVyO1xuICAgIHRoaXMudHJpZ2dlciA9IHBhcmFtZXRlcnMudHJpZ2dlcjtcbiAgICB0aGlzLmNvbG9yID0gcGFyYW1ldGVycy5jb2xvcjtcbiAgICB0aGlzLnRpdGxlID0gcGFyYW1ldGVycy50aXRsZTtcbiAgICB0aGlzLm1vZGlmaWNhdGlvbkRhdGUgPSBwYXJhbWV0ZXJzLm1vZGlmaWNhdGlvbkRhdGU7XG4gICAgdGhpcy5jb250ZW50cyA9IHBhcmFtZXRlcnMuY29udGVudHM7XG4gICAgdGhpcy5oaWRlV3JhcHBlciA9IHBhcmFtZXRlcnMuaGlkZVdyYXBwZXIgfHwgZmFsc2U7XG4gICAgdGhpcy5waW5uZWQgPSBmYWxzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb3B1cEVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIEJBQ0tHUk9VTkRfRU5MSUdIVCA9IDAuNztcbiAgICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gXCJwb3B1cFdyYXBwZXJcIjtcbiAgICAgIHRoaXMuaGlkZUVsZW1lbnQgPSB0aGlzLmhpZGVXcmFwcGVyID8gd3JhcHBlciA6IHRoaXMuY29udGFpbmVyO1xuICAgICAgdGhpcy5oaWRlRWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgICAgdmFyIHBvcHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHBvcHVwLmNsYXNzTmFtZSA9IFwicG9wdXBcIjtcbiAgICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3I7XG5cbiAgICAgIGlmIChjb2xvcikge1xuICAgICAgICB2YXIgciA9IEJBQ0tHUk9VTkRfRU5MSUdIVCAqICgyNTUgLSBjb2xvclswXSkgKyBjb2xvclswXTtcbiAgICAgICAgdmFyIGcgPSBCQUNLR1JPVU5EX0VOTElHSFQgKiAoMjU1IC0gY29sb3JbMV0pICsgY29sb3JbMV07XG4gICAgICAgIHZhciBiID0gQkFDS0dST1VORF9FTkxJR0hUICogKDI1NSAtIGNvbG9yWzJdKSArIGNvbG9yWzJdO1xuICAgICAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyIHwgMCwgZyB8IDAsIGIgfCAwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgxXCIpO1xuICAgICAgdGl0bGUudGV4dENvbnRlbnQgPSB0aGlzLnRpdGxlO1xuICAgICAgcG9wdXAuYXBwZW5kQ2hpbGQodGl0bGUpO1xuXG4gICAgICB2YXIgZGF0ZU9iamVjdCA9IF9kaXNwbGF5X3V0aWxzLlBERkRhdGVTdHJpbmcudG9EYXRlT2JqZWN0KHRoaXMubW9kaWZpY2F0aW9uRGF0ZSk7XG5cbiAgICAgIGlmIChkYXRlT2JqZWN0KSB7XG4gICAgICAgIHZhciBtb2RpZmljYXRpb25EYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGUudGV4dENvbnRlbnQgPSBcInt7ZGF0ZX19LCB7e3RpbWV9fVwiO1xuICAgICAgICBtb2RpZmljYXRpb25EYXRlLmRhdGFzZXQubDEwbklkID0gXCJhbm5vdGF0aW9uX2RhdGVfc3RyaW5nXCI7XG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGUuZGF0YXNldC5sMTBuQXJncyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBkYXRlOiBkYXRlT2JqZWN0LnRvTG9jYWxlRGF0ZVN0cmluZygpLFxuICAgICAgICAgIHRpbWU6IGRhdGVPYmplY3QudG9Mb2NhbGVUaW1lU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICAgIHBvcHVwLmFwcGVuZENoaWxkKG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGVudHMgPSB0aGlzLl9mb3JtYXRDb250ZW50cyh0aGlzLmNvbnRlbnRzKTtcblxuICAgICAgcG9wdXAuYXBwZW5kQ2hpbGQoY29udGVudHMpO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy50cmlnZ2VyKSkge1xuICAgICAgICB0aGlzLnRyaWdnZXIgPSBbdGhpcy50cmlnZ2VyXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmlnZ2VyLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX3RoaXM3Ll90b2dnbGUuYmluZChfdGhpczcpKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIF90aGlzNy5fc2hvdy5iaW5kKF90aGlzNywgZmFsc2UpKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgX3RoaXM3Ll9oaWRlLmJpbmQoX3RoaXM3LCBmYWxzZSkpO1xuICAgICAgfSk7XG4gICAgICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5faGlkZS5iaW5kKHRoaXMsIHRydWUpKTtcbiAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQocG9wdXApO1xuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9mb3JtYXRDb250ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZm9ybWF0Q29udGVudHMoY29udGVudHMpIHtcbiAgICAgIHZhciBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICB2YXIgbGluZXMgPSBjb250ZW50cy5zcGxpdCgvKD86XFxyXFxuP3xcXG4pLyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpbmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSk7XG5cbiAgICAgICAgaWYgKGkgPCBpaSAtIDEpIHtcbiAgICAgICAgICBwLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl90b2dnbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RvZ2dsZSgpIHtcbiAgICAgIGlmICh0aGlzLnBpbm5lZCkge1xuICAgICAgICB0aGlzLl9oaWRlKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2hvdyh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Nob3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3coKSB7XG4gICAgICB2YXIgcGluID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgaWYgKHBpbikge1xuICAgICAgICB0aGlzLnBpbm5lZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhpZGVFbGVtZW50LmhpZGRlbikge1xuICAgICAgICB0aGlzLmhpZGVFbGVtZW50LmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS56SW5kZXggKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoKSB7XG4gICAgICB2YXIgdW5waW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cbiAgICAgIGlmICh1bnBpbikge1xuICAgICAgICB0aGlzLnBpbm5lZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGlkZUVsZW1lbnQuaGlkZGVuICYmICF0aGlzLnBpbm5lZCkge1xuICAgICAgICB0aGlzLmhpZGVFbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnpJbmRleCAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb3B1cEVsZW1lbnQ7XG59KCk7XG5cbnZhciBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5ub3RhdGlvbkVsZW1lbnQ1KSB7XG4gIF9pbmhlcml0cyhGcmVlVGV4dEFubm90YXRpb25FbGVtZW50LCBfQW5ub3RhdGlvbkVsZW1lbnQ1KTtcblxuICB2YXIgX3N1cGVyMTAgPSBfY3JlYXRlU3VwZXIoRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICByZXR1cm4gX3N1cGVyMTAuY2FsbCh0aGlzLCBwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImZyZWVUZXh0QW5ub3RhdGlvblwiO1xuXG4gICAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQb3B1cChudWxsLCB0aGlzLmRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIExpbmVBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fubm90YXRpb25FbGVtZW50Nikge1xuICBfaW5oZXJpdHMoTGluZUFubm90YXRpb25FbGVtZW50LCBfQW5ub3RhdGlvbkVsZW1lbnQ2KTtcblxuICB2YXIgX3N1cGVyMTEgPSBfY3JlYXRlU3VwZXIoTGluZUFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBMaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICByZXR1cm4gX3N1cGVyMTEuY2FsbCh0aGlzLCBwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpbmVBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwibGluZUFubm90YXRpb25cIjtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgdmFyIHdpZHRoID0gZGF0YS5yZWN0WzJdIC0gZGF0YS5yZWN0WzBdO1xuICAgICAgdmFyIGhlaWdodCA9IGRhdGEucmVjdFszXSAtIGRhdGEucmVjdFsxXTtcbiAgICAgIHZhciBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpsaW5lXCIpO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ4MVwiLCBkYXRhLnJlY3RbMl0gLSBkYXRhLmxpbmVDb29yZGluYXRlc1swXSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkxXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzFdKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDJcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMl0pO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ5MlwiLCBkYXRhLnJlY3RbM10gLSBkYXRhLmxpbmVDb29yZGluYXRlc1szXSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZChsaW5lKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuXG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cChsaW5lLCBkYXRhKTtcblxuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5lQW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIFNxdWFyZUFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5ub3RhdGlvbkVsZW1lbnQ3KSB7XG4gIF9pbmhlcml0cyhTcXVhcmVBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50Nyk7XG5cbiAgdmFyIF9zdXBlcjEyID0gX2NyZWF0ZVN1cGVyKFNxdWFyZUFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNxdWFyZUFubm90YXRpb25FbGVtZW50KTtcblxuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgcmV0dXJuIF9zdXBlcjEyLmNhbGwodGhpcywgcGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTcXVhcmVBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwic3F1YXJlQW5ub3RhdGlvblwiO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB2YXIgd2lkdGggPSBkYXRhLnJlY3RbMl0gLSBkYXRhLnJlY3RbMF07XG4gICAgICB2YXIgaGVpZ2h0ID0gZGF0YS5yZWN0WzNdIC0gZGF0YS5yZWN0WzFdO1xuICAgICAgdmFyIHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgICAgdmFyIHNxdWFyZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieFwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInlcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCAtIGJvcmRlcldpZHRoKTtcbiAgICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0IC0gYm9yZGVyV2lkdGgpO1xuICAgICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZChzcXVhcmUpO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHNxdWFyZSwgZGF0YSk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIENpcmNsZUFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5ub3RhdGlvbkVsZW1lbnQ4KSB7XG4gIF9pbmhlcml0cyhDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50OCk7XG5cbiAgdmFyIF9zdXBlcjEzID0gX2NyZWF0ZVN1cGVyKENpcmNsZUFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZUFubm90YXRpb25FbGVtZW50KTtcblxuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgcmV0dXJuIF9zdXBlcjEzLmNhbGwodGhpcywgcGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiY2lyY2xlQW5ub3RhdGlvblwiO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB2YXIgd2lkdGggPSBkYXRhLnJlY3RbMl0gLSBkYXRhLnJlY3RbMF07XG4gICAgICB2YXIgaGVpZ2h0ID0gZGF0YS5yZWN0WzNdIC0gZGF0YS5yZWN0WzFdO1xuICAgICAgdmFyIHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgICAgdmFyIGNpcmNsZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmVsbGlwc2VcIik7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3hcIiwgd2lkdGggLyAyKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBoZWlnaHQgLyAyKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeFwiLCB3aWR0aCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJ5XCIsIGhlaWdodCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZChjaXJjbGUpO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKGNpcmNsZSwgZGF0YSk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDkpIHtcbiAgX2luaGVyaXRzKFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQsIF9Bbm5vdGF0aW9uRWxlbWVudDkpO1xuXG4gIHZhciBfc3VwZXIxNCA9IF9jcmVhdGVTdXBlcihQb2x5bGluZUFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBQb2x5bGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICB2YXIgX3RoaXM4O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICBfdGhpczggPSBfc3VwZXIxNC5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgX3RoaXM4LmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWxpbmVBbm5vdGF0aW9uXCI7XG4gICAgX3RoaXM4LnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgICByZXR1cm4gX3RoaXM4O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZTtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgdmFyIHdpZHRoID0gZGF0YS5yZWN0WzJdIC0gZGF0YS5yZWN0WzBdO1xuICAgICAgdmFyIGhlaWdodCA9IGRhdGEucmVjdFszXSAtIGRhdGEucmVjdFsxXTtcbiAgICAgIHZhciBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGEudmVydGljZXMpLFxuICAgICAgICAgIF9zdGVwODtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY29vcmRpbmF0ZSA9IF9zdGVwOC52YWx1ZTtcbiAgICAgICAgICB2YXIgeCA9IGNvb3JkaW5hdGUueCAtIGRhdGEucmVjdFswXTtcbiAgICAgICAgICB2YXIgeSA9IGRhdGEucmVjdFszXSAtIGNvb3JkaW5hdGUueTtcbiAgICAgICAgICBwb2ludHMucHVzaCh4ICsgXCIsXCIgKyB5KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjguZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yOC5mKCk7XG4gICAgICB9XG5cbiAgICAgIHBvaW50cyA9IHBvaW50cy5qb2luKFwiIFwiKTtcbiAgICAgIHZhciBwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50cyk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICBzdmcuYXBwZW5kQ2hpbGQocG9seWxpbmUpO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHBvbHlsaW5lLCBkYXRhKTtcblxuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb2x5bGluZUFubm90YXRpb25FbGVtZW50O1xufShBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Qb2x5bGluZUFubm90YXRpb25FbCkge1xuICBfaW5oZXJpdHMoUG9seWdvbkFubm90YXRpb25FbGVtZW50LCBfUG9seWxpbmVBbm5vdGF0aW9uRWwpO1xuXG4gIHZhciBfc3VwZXIxNSA9IF9jcmVhdGVTdXBlcihQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIF90aGlzOTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgX3RoaXM5ID0gX3N1cGVyMTUuY2FsbCh0aGlzLCBwYXJhbWV0ZXJzKTtcbiAgICBfdGhpczkuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5Z29uQW5ub3RhdGlvblwiO1xuICAgIF90aGlzOS5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlnb25cIjtcbiAgICByZXR1cm4gX3RoaXM5O1xuICB9XG5cbiAgcmV0dXJuIFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudDtcbn0oUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBDYXJldEFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5ub3RhdGlvbkVsZW1lbnQxMCkge1xuICBfaW5oZXJpdHMoQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50MTApO1xuXG4gIHZhciBfc3VwZXIxNiA9IF9jcmVhdGVTdXBlcihDYXJldEFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBDYXJldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHJldHVybiBfc3VwZXIxNi5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiY2FyZXRBbm5vdGF0aW9uXCI7XG5cbiAgICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKG51bGwsIHRoaXMuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FyZXRBbm5vdGF0aW9uRWxlbWVudDtcbn0oQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgSW5rQW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDExKSB7XG4gIF9pbmhlcml0cyhJbmtBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50MTEpO1xuXG4gIHZhciBfc3VwZXIxNyA9IF9jcmVhdGVTdXBlcihJbmtBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gSW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczEwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElua0Fubm90YXRpb25FbGVtZW50KTtcblxuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgX3RoaXMxMCA9IF9zdXBlcjE3LmNhbGwodGhpcywgcGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBpc1JlbmRlcmFibGUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICBfdGhpczEwLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwiaW5rQW5ub3RhdGlvblwiO1xuICAgIF90aGlzMTAuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5bGluZVwiO1xuICAgIHJldHVybiBfdGhpczEwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKElua0Fubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy5jb250YWluZXJDbGFzc05hbWU7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHZhciB3aWR0aCA9IGRhdGEucmVjdFsyXSAtIGRhdGEucmVjdFswXTtcbiAgICAgIHZhciBoZWlnaHQgPSBkYXRhLnJlY3RbM10gLSBkYXRhLnJlY3RbMV07XG4gICAgICB2YXIgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjkgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkYXRhLmlua0xpc3RzKSxcbiAgICAgICAgICBfc3RlcDk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yOS5zKCk7ICEoX3N0ZXA5ID0gX2l0ZXJhdG9yOS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGlua0xpc3QgPSBfc3RlcDkudmFsdWU7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjEwID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaW5rTGlzdCksXG4gICAgICAgICAgICAgIF9zdGVwMTA7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IxMC5zKCk7ICEoX3N0ZXAxMCA9IF9pdGVyYXRvcjEwLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSBfc3RlcDEwLnZhbHVlO1xuICAgICAgICAgICAgICB2YXIgeCA9IGNvb3JkaW5hdGUueCAtIGRhdGEucmVjdFswXTtcbiAgICAgICAgICAgICAgdmFyIHkgPSBkYXRhLnJlY3RbM10gLSBjb29yZGluYXRlLnk7XG4gICAgICAgICAgICAgIHBvaW50cy5wdXNoKFwiXCIuY29uY2F0KHgsIFwiLFwiKS5jb25jYXQoeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMTAuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IxMC5mKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9pbnRzID0gcG9pbnRzLmpvaW4oXCIgXCIpO1xuICAgICAgICAgIHZhciBwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgICAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xuICAgICAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgICAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgICAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJub25lXCIpO1xuXG4gICAgICAgICAgdGhpcy5fY3JlYXRlUG9wdXAocG9seWxpbmUsIGRhdGEpO1xuXG4gICAgICAgICAgc3ZnLmFwcGVuZENoaWxkKHBvbHlsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjkuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yOS5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbmtBbm5vdGF0aW9uRWxlbWVudDtcbn0oQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDEyKSB7XG4gIF9pbmhlcml0cyhIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50MTIpO1xuXG4gIHZhciBfc3VwZXIxOCA9IF9jcmVhdGVTdXBlcihIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHJldHVybiBfc3VwZXIxOC5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKG51bGwsIHRoaXMuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJRdWFkcmlsYXRlcmFscyhcImhpZ2hsaWdodEFubm90YXRpb25cIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiaGlnaGxpZ2h0QW5ub3RhdGlvblwiO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudDtcbn0oQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDEzKSB7XG4gIF9pbmhlcml0cyhVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50MTMpO1xuXG4gIHZhciBfc3VwZXIxOSA9IF9jcmVhdGVTdXBlcihVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHJldHVybiBfc3VwZXIxOS5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKG51bGwsIHRoaXMuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJRdWFkcmlsYXRlcmFscyhcInVuZGVybGluZUFubm90YXRpb25cIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwidW5kZXJsaW5lQW5ub3RhdGlvblwiO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudDtcbn0oQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fubm90YXRpb25FbGVtZW50MTQpIHtcbiAgX2luaGVyaXRzKFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQsIF9Bbm5vdGF0aW9uRWxlbWVudDE0KTtcblxuICB2YXIgX3N1cGVyMjAgPSBfY3JlYXRlU3VwZXIoU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICByZXR1cm4gX3N1cGVyMjAuY2FsbCh0aGlzLCBwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKG51bGwsIHRoaXMuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJRdWFkcmlsYXRlcmFscyhcInNxdWlnZ2x5QW5ub3RhdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJzcXVpZ2dseUFubm90YXRpb25cIjtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudDtcbn0oQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDE1KSB7XG4gIF9pbmhlcml0cyhTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50MTUpO1xuXG4gIHZhciBfc3VwZXIyMSA9IF9jcmVhdGVTdXBlcihTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHJldHVybiBfc3VwZXIyMS5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogaXNSZW5kZXJhYmxlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKG51bGwsIHRoaXMuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJRdWFkcmlsYXRlcmFscyhcInN0cmlrZW91dEFubm90YXRpb25cIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwic3RyaWtlb3V0QW5ub3RhdGlvblwiO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudDtcbn0oQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fubm90YXRpb25FbGVtZW50MTYpIHtcbiAgX2luaGVyaXRzKFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQsIF9Bbm5vdGF0aW9uRWxlbWVudDE2KTtcblxuICB2YXIgX3N1cGVyMjIgPSBfY3JlYXRlU3VwZXIoU3RhbXBBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gU3RhbXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICByZXR1cm4gX3N1cGVyMjIuY2FsbCh0aGlzLCBwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IGlzUmVuZGVyYWJsZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcInN0YW1wQW5ub3RhdGlvblwiO1xuXG4gICAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQb3B1cChudWxsLCB0aGlzLmRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDE3KSB7XG4gIF9pbmhlcml0cyhGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50LCBfQW5ub3RhdGlvbkVsZW1lbnQxNyk7XG5cbiAgdmFyIF9zdXBlcjIzID0gX2NyZWF0ZVN1cGVyKEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczExJGxpbmtTZXJ2aWNlJGU7XG5cbiAgICB2YXIgX3RoaXMxMTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50KTtcblxuICAgIF90aGlzMTEgPSBfc3VwZXIyMy5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciBfdGhpczExJGRhdGEkZmlsZSA9IF90aGlzMTEuZGF0YS5maWxlLFxuICAgICAgICBmaWxlbmFtZSA9IF90aGlzMTEkZGF0YSRmaWxlLmZpbGVuYW1lLFxuICAgICAgICBjb250ZW50ID0gX3RoaXMxMSRkYXRhJGZpbGUuY29udGVudDtcbiAgICBfdGhpczExLmZpbGVuYW1lID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEZpbGVuYW1lRnJvbVVybCkoZmlsZW5hbWUpO1xuICAgIF90aGlzMTEuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgKF90aGlzMTEkbGlua1NlcnZpY2UkZSA9IF90aGlzMTEubGlua1NlcnZpY2UuZXZlbnRCdXMpID09PSBudWxsIHx8IF90aGlzMTEkbGlua1NlcnZpY2UkZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMxMSRsaW5rU2VydmljZSRlLmRpc3BhdGNoKFwiZmlsZWF0dGFjaG1lbnRhbm5vdGF0aW9uXCIsIHtcbiAgICAgIHNvdXJjZTogX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczExKSxcbiAgICAgIGlkOiAoMCwgX3V0aWwuc3RyaW5nVG9QREZTdHJpbmcpKGZpbGVuYW1lKSxcbiAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXMxMTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJmaWxlQXR0YWNobWVudEFubm90YXRpb25cIjtcbiAgICAgIHZhciB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRyaWdnZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIuc3R5bGUuaGVpZ2h0O1xuICAgICAgdHJpZ2dlci5zdHlsZS53aWR0aCA9IHRoaXMuY29udGFpbmVyLnN0eWxlLndpZHRoO1xuICAgICAgdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgdGhpcy5fZG93bmxvYWQuYmluZCh0aGlzKSk7XG5cbiAgICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwICYmICh0aGlzLmRhdGEudGl0bGUgfHwgdGhpcy5kYXRhLmNvbnRlbnRzKSkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQb3B1cCh0cmlnZ2VyLCB0aGlzLmRhdGEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0cmlnZ2VyKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rvd25sb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kb3dubG9hZCgpIHtcbiAgICAgIGlmICghdGhpcy5kb3dubG9hZE1hbmFnZXIpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiRG93bmxvYWQgY2Fubm90IGJlIHN0YXJ0ZWQgZHVlIHRvIHVuYXZhaWxhYmxlIGRvd25sb2FkIG1hbmFnZXJcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb3dubG9hZE1hbmFnZXIuZG93bmxvYWREYXRhKHRoaXMuY29udGVudCwgdGhpcy5maWxlbmFtZSwgXCJcIik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIEFubm90YXRpb25MYXllciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb25MYXllcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5ub3RhdGlvbkxheWVyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBbm5vdGF0aW9uTGF5ZXIsIG51bGwsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocGFyYW1ldGVycykge1xuICAgICAgdmFyIHNvcnRlZEFubm90YXRpb25zID0gW10sXG4gICAgICAgICAgcG9wdXBBbm5vdGF0aW9ucyA9IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMTEgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwYXJhbWV0ZXJzLmFubm90YXRpb25zKSxcbiAgICAgICAgICBfc3RlcDExO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjExLnMoKTsgIShfc3RlcDExID0gX2l0ZXJhdG9yMTEubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfZGF0YSA9IF9zdGVwMTEudmFsdWU7XG5cbiAgICAgICAgICBpZiAoIV9kYXRhKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2RhdGEuYW5ub3RhdGlvblR5cGUgPT09IF91dGlsLkFubm90YXRpb25UeXBlLlBPUFVQKSB7XG4gICAgICAgICAgICBwb3B1cEFubm90YXRpb25zLnB1c2goX2RhdGEpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc29ydGVkQW5ub3RhdGlvbnMucHVzaChfZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxMS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxMS5mKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3B1cEFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgICBzb3J0ZWRBbm5vdGF0aW9ucy5wdXNoLmFwcGx5KHNvcnRlZEFubm90YXRpb25zLCBwb3B1cEFubm90YXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3NvcnRlZEFubm90YXRpb25zID0gc29ydGVkQW5ub3RhdGlvbnM7IF9pMiA8IF9zb3J0ZWRBbm5vdGF0aW9ucy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3NvcnRlZEFubm90YXRpb25zW19pMl07XG4gICAgICAgIHZhciBlbGVtZW50ID0gQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5LmNyZWF0ZSh7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBsYXllcjogcGFyYW1ldGVycy5kaXYsXG4gICAgICAgICAgcGFnZTogcGFyYW1ldGVycy5wYWdlLFxuICAgICAgICAgIHZpZXdwb3J0OiBwYXJhbWV0ZXJzLnZpZXdwb3J0LFxuICAgICAgICAgIGxpbmtTZXJ2aWNlOiBwYXJhbWV0ZXJzLmxpbmtTZXJ2aWNlLFxuICAgICAgICAgIGRvd25sb2FkTWFuYWdlcjogcGFyYW1ldGVycy5kb3dubG9hZE1hbmFnZXIsXG4gICAgICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBwYXJhbWV0ZXJzLmltYWdlUmVzb3VyY2VzUGF0aCB8fCBcIlwiLFxuICAgICAgICAgIHJlbmRlckludGVyYWN0aXZlRm9ybXM6IHR5cGVvZiBwYXJhbWV0ZXJzLnJlbmRlckludGVyYWN0aXZlRm9ybXMgPT09IFwiYm9vbGVhblwiID8gcGFyYW1ldGVycy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zIDogdHJ1ZSxcbiAgICAgICAgICBzdmdGYWN0b3J5OiBuZXcgX2Rpc3BsYXlfdXRpbHMuRE9NU1ZHRmFjdG9yeSgpLFxuICAgICAgICAgIGFubm90YXRpb25TdG9yYWdlOiBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlIHx8IG5ldyBfYW5ub3RhdGlvbl9zdG9yYWdlLkFubm90YXRpb25TdG9yYWdlKCksXG4gICAgICAgICAgZW5hYmxlU2NyaXB0aW5nOiBwYXJhbWV0ZXJzLmVuYWJsZVNjcmlwdGluZyxcbiAgICAgICAgICBoYXNKU0FjdGlvbnM6IHBhcmFtZXRlcnMuaGFzSlNBY3Rpb25zLFxuICAgICAgICAgIG1vdXNlU3RhdGU6IHBhcmFtZXRlcnMubW91c2VTdGF0ZSB8fCB7XG4gICAgICAgICAgICBpc0Rvd246IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgICB2YXIgcmVuZGVyZWQgPSBlbGVtZW50LnJlbmRlcigpO1xuXG4gICAgICAgICAgaWYgKGRhdGEuaGlkZGVuKSB7XG4gICAgICAgICAgICByZW5kZXJlZC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZW5kZXJlZCkpIHtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3IxMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHJlbmRlcmVkKSxcbiAgICAgICAgICAgICAgICBfc3RlcDEyO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjEyLnMoKTsgIShfc3RlcDEyID0gX2l0ZXJhdG9yMTIubigpKS5kb25lOykge1xuICAgICAgICAgICAgICAgIHZhciByZW5kZXJlZEVsZW1lbnQgPSBfc3RlcDEyLnZhbHVlO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZGl2LmFwcGVuZENoaWxkKHJlbmRlcmVkRWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IxMi5lKGVycik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IxMi5mKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmRpdi5wcmVwZW5kKHJlbmRlcmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmFtZXRlcnMuZGl2LmFwcGVuZENoaWxkKHJlbmRlcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gXCJtYXRyaXgoXCIuY29uY2F0KHBhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpLCBcIilcIik7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IxMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBhcmFtZXRlcnMuYW5ub3RhdGlvbnMpLFxuICAgICAgICAgIF9zdGVwMTM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTMucygpOyAhKF9zdGVwMTMgPSBfaXRlcmF0b3IxMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBfc3RlcDEzLnZhbHVlO1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHBhcmFtZXRlcnMuZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1hbm5vdGF0aW9uLWlkPVxcXCJcIi5jb25jYXQoZGF0YS5pZCwgXCJcXFwiXVwiKSk7XG5cbiAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxMy5mKCk7XG4gICAgICB9XG5cbiAgICAgIHBhcmFtZXRlcnMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbm5vdGF0aW9uTGF5ZXI7XG59KCk7XG5cbmV4cG9ydHMuQW5ub3RhdGlvbkxheWVyID0gQW5ub3RhdGlvbkxheWVyO1xuXG4vKioqLyB9KSxcbi8qIDE1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQ29sb3JDb252ZXJ0ZXJzID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIG1ha2VDb2xvckNvbXAobikge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBuKSkgKiAyNTUpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG59XG5cbnZhciBDb2xvckNvbnZlcnRlcnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb2xvckNvbnZlcnRlcnMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yQ29udmVydGVycyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29sb3JDb252ZXJ0ZXJzLCBudWxsLCBbe1xuICAgIGtleTogXCJDTVlLX0dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gQ01ZS19HKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDQpLFxuICAgICAgICAgIGMgPSBfcmVmMlswXSxcbiAgICAgICAgICB5ID0gX3JlZjJbMV0sXG4gICAgICAgICAgbSA9IF9yZWYyWzJdLFxuICAgICAgICAgIGsgPSBfcmVmMlszXTtcblxuICAgICAgcmV0dXJuIFtcIkdcIiwgMSAtIE1hdGgubWluKDEsIDAuMyAqIGMgKyAwLjU5ICogbSArIDAuMTEgKiB5ICsgayldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJHX0NNWUtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gR19DTVlLKF9yZWYzKSB7XG4gICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMSksXG4gICAgICAgICAgZyA9IF9yZWY0WzBdO1xuXG4gICAgICByZXR1cm4gW1wiQ01ZS1wiLCAwLCAwLCAwLCAxIC0gZ107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkdfUkdCXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIEdfUkdCKF9yZWY1KSB7XG4gICAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMSksXG4gICAgICAgICAgZyA9IF9yZWY2WzBdO1xuXG4gICAgICByZXR1cm4gW1wiUkdCXCIsIGcsIGcsIGddO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJHX0hUTUxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gR19IVE1MKF9yZWY3KSB7XG4gICAgICB2YXIgX3JlZjggPSBfc2xpY2VkVG9BcnJheShfcmVmNywgMSksXG4gICAgICAgICAgZyA9IF9yZWY4WzBdO1xuXG4gICAgICB2YXIgRyA9IG1ha2VDb2xvckNvbXAoZyk7XG4gICAgICByZXR1cm4gXCIjXCIuY29uY2F0KEcpLmNvbmNhdChHKS5jb25jYXQoRyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIlJHQl9HXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIFJHQl9HKF9yZWY5KSB7XG4gICAgICB2YXIgX3JlZjEwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjksIDMpLFxuICAgICAgICAgIHIgPSBfcmVmMTBbMF0sXG4gICAgICAgICAgZyA9IF9yZWYxMFsxXSxcbiAgICAgICAgICBiID0gX3JlZjEwWzJdO1xuXG4gICAgICByZXR1cm4gW1wiR1wiLCAwLjMgKiByICsgMC41OSAqIGcgKyAwLjExICogYl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIlJHQl9IVE1MXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIFJHQl9IVE1MKF9yZWYxMSkge1xuICAgICAgdmFyIF9yZWYxMiA9IF9zbGljZWRUb0FycmF5KF9yZWYxMSwgMyksXG4gICAgICAgICAgciA9IF9yZWYxMlswXSxcbiAgICAgICAgICBnID0gX3JlZjEyWzFdLFxuICAgICAgICAgIGIgPSBfcmVmMTJbMl07XG5cbiAgICAgIHZhciBSID0gbWFrZUNvbG9yQ29tcChyKTtcbiAgICAgIHZhciBHID0gbWFrZUNvbG9yQ29tcChnKTtcbiAgICAgIHZhciBCID0gbWFrZUNvbG9yQ29tcChiKTtcbiAgICAgIHJldHVybiBcIiNcIi5jb25jYXQoUikuY29uY2F0KEcpLmNvbmNhdChCKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiVF9IVE1MXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIFRfSFRNTCgpIHtcbiAgICAgIHJldHVybiBcIiMwMDAwMDAwMFwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJDTVlLX1JHQlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBDTVlLX1JHQihfcmVmMTMpIHtcbiAgICAgIHZhciBfcmVmMTQgPSBfc2xpY2VkVG9BcnJheShfcmVmMTMsIDQpLFxuICAgICAgICAgIGMgPSBfcmVmMTRbMF0sXG4gICAgICAgICAgeSA9IF9yZWYxNFsxXSxcbiAgICAgICAgICBtID0gX3JlZjE0WzJdLFxuICAgICAgICAgIGsgPSBfcmVmMTRbM107XG5cbiAgICAgIHJldHVybiBbXCJSR0JcIiwgMSAtIE1hdGgubWluKDEsIGMgKyBrKSwgMSAtIE1hdGgubWluKDEsIG0gKyBrKSwgMSAtIE1hdGgubWluKDEsIHkgKyBrKV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkNNWUtfSFRNTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBDTVlLX0hUTUwoY29tcG9uZW50cykge1xuICAgICAgcmV0dXJuIHRoaXMuUkdCX0hUTUwodGhpcy5DTVlLX1JHQihjb21wb25lbnRzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIlJHQl9DTVlLXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIFJHQl9DTVlLKF9yZWYxNSkge1xuICAgICAgdmFyIF9yZWYxNiA9IF9zbGljZWRUb0FycmF5KF9yZWYxNSwgMyksXG4gICAgICAgICAgciA9IF9yZWYxNlswXSxcbiAgICAgICAgICBnID0gX3JlZjE2WzFdLFxuICAgICAgICAgIGIgPSBfcmVmMTZbMl07XG5cbiAgICAgIHZhciBjID0gMSAtIHI7XG4gICAgICB2YXIgbSA9IDEgLSBnO1xuICAgICAgdmFyIHkgPSAxIC0gYjtcbiAgICAgIHZhciBrID0gTWF0aC5taW4oYywgbSwgeSk7XG4gICAgICByZXR1cm4gW1wiQ01ZS1wiLCBjLCBtLCB5LCBrXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29sb3JDb252ZXJ0ZXJzO1xufSgpO1xuXG5leHBvcnRzLkNvbG9yQ29udmVydGVycyA9IENvbG9yQ29udmVydGVycztcblxuLyoqKi8gfSksXG4vKiAxNTEgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLnJlbmRlclRleHRMYXllciA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcblxudmFyIHJlbmRlclRleHRMYXllciA9IGZ1bmN0aW9uIHJlbmRlclRleHRMYXllckNsb3N1cmUoKSB7XG4gIHZhciBNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUiA9IDEwMDAwMDtcbiAgdmFyIE5vbldoaXRlc3BhY2VSZWdleHAgPSAvXFxTLztcblxuICBmdW5jdGlvbiBpc0FsbFdoaXRlc3BhY2Uoc3RyKSB7XG4gICAgcmV0dXJuICFOb25XaGl0ZXNwYWNlUmVnZXhwLnRlc3Qoc3RyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZFRleHQodGFzaywgZ2VvbSwgc3R5bGVzKSB7XG4gICAgdmFyIHRleHREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHZhciB0ZXh0RGl2UHJvcGVydGllcyA9IHtcbiAgICAgIGFuZ2xlOiAwLFxuICAgICAgY2FudmFzV2lkdGg6IDAsXG4gICAgICBpc1doaXRlc3BhY2U6IGZhbHNlLFxuICAgICAgb3JpZ2luYWxUcmFuc2Zvcm06IG51bGwsXG4gICAgICBwYWRkaW5nQm90dG9tOiAwLFxuICAgICAgcGFkZGluZ0xlZnQ6IDAsXG4gICAgICBwYWRkaW5nUmlnaHQ6IDAsXG4gICAgICBwYWRkaW5nVG9wOiAwLFxuICAgICAgc2NhbGU6IDFcbiAgICB9O1xuXG4gICAgdGFzay5fdGV4dERpdnMucHVzaCh0ZXh0RGl2KTtcblxuICAgIGlmIChpc0FsbFdoaXRlc3BhY2UoZ2VvbS5zdHIpKSB7XG4gICAgICB0ZXh0RGl2UHJvcGVydGllcy5pc1doaXRlc3BhY2UgPSB0cnVlO1xuXG4gICAgICB0YXNrLl90ZXh0RGl2UHJvcGVydGllcy5zZXQodGV4dERpdiwgdGV4dERpdlByb3BlcnRpZXMpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHR4ID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0odGFzay5fdmlld3BvcnQudHJhbnNmb3JtLCBnZW9tLnRyYW5zZm9ybSk7XG5cbiAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHR4WzFdLCB0eFswXSk7XG4gICAgdmFyIHN0eWxlID0gc3R5bGVzW2dlb20uZm9udE5hbWVdO1xuXG4gICAgaWYgKHN0eWxlLnZlcnRpY2FsKSB7XG4gICAgICBhbmdsZSArPSBNYXRoLlBJIC8gMjtcbiAgICB9XG5cbiAgICB2YXIgZm9udEhlaWdodCA9IE1hdGguaHlwb3QodHhbMl0sIHR4WzNdKTtcbiAgICB2YXIgZm9udEFzY2VudCA9IGZvbnRIZWlnaHQ7XG5cbiAgICBpZiAoc3R5bGUuYXNjZW50KSB7XG4gICAgICBmb250QXNjZW50ID0gc3R5bGUuYXNjZW50ICogZm9udEFzY2VudDtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLmRlc2NlbnQpIHtcbiAgICAgIGZvbnRBc2NlbnQgPSAoMSArIHN0eWxlLmRlc2NlbnQpICogZm9udEFzY2VudDtcbiAgICB9XG5cbiAgICB2YXIgbGVmdCwgdG9wO1xuXG4gICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICBsZWZ0ID0gdHhbNF07XG4gICAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSB0eFs0XSArIGZvbnRBc2NlbnQgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgfVxuXG4gICAgdGV4dERpdi5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQobGVmdCwgXCJweFwiKTtcbiAgICB0ZXh0RGl2LnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KHRvcCwgXCJweFwiKTtcbiAgICB0ZXh0RGl2LnN0eWxlLmZvbnRTaXplID0gXCJcIi5jb25jYXQoZm9udEhlaWdodCwgXCJweFwiKTtcbiAgICB0ZXh0RGl2LnN0eWxlLmZvbnRGYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5O1xuXG4gICAgaWYgKHRhc2suX2NvbnRhaW5lci5jbGFzc0xpc3QgJiYgdGFzay5fY29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhcInZpc2libGVcIikgJiYgZ2VvbS5maWxsQ29sb3IpIHtcbiAgICAgIHRleHREaXYuc3R5bGUuY29sb3IgPSBcInJnYihcIi5jb25jYXQoZ2VvbS5maWxsQ29sb3JbMF0sIFwiLCBcIikuY29uY2F0KGdlb20uZmlsbENvbG9yWzFdLCBcIiwgXCIpLmNvbmNhdChnZW9tLmZpbGxDb2xvclsyXSwgXCIpO1wiKTtcbiAgICB9XG5cbiAgICB0ZXh0RGl2LnRleHRDb250ZW50ID0gZ2VvbS5zdHI7XG4gICAgdGV4dERpdi5kaXIgPSBnZW9tLmRpcjtcblxuICAgIGlmICh0YXNrLl9mb250SW5zcGVjdG9yRW5hYmxlZCkge1xuICAgICAgdGV4dERpdi5kYXRhc2V0LmZvbnROYW1lID0gZ2VvbS5mb250TmFtZTtcbiAgICB9XG5cbiAgICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmFuZ2xlID0gYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFNjYWxlVGV4dCA9IGZhbHNlO1xuXG4gICAgaWYgKGdlb20uc3RyLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChnZW9tLnRyYW5zZm9ybVswXSAhPT0gZ2VvbS50cmFuc2Zvcm1bM10pIHtcbiAgICAgIHZhciBhYnNTY2FsZVggPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVswXSksXG4gICAgICAgICAgYWJzU2NhbGVZID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bM10pO1xuXG4gICAgICBpZiAoYWJzU2NhbGVYICE9PSBhYnNTY2FsZVkgJiYgTWF0aC5tYXgoYWJzU2NhbGVYLCBhYnNTY2FsZVkpIC8gTWF0aC5taW4oYWJzU2NhbGVYLCBhYnNTY2FsZVkpID4gMS41KSB7XG4gICAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFNjYWxlVGV4dCkge1xuICAgICAgaWYgKHN0eWxlLnZlcnRpY2FsKSB7XG4gICAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoID0gZ2VvbS5oZWlnaHQgKiB0YXNrLl92aWV3cG9ydC5zY2FsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoID0gZ2VvbS53aWR0aCAqIHRhc2suX3ZpZXdwb3J0LnNjYWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRhc2suX3RleHREaXZQcm9wZXJ0aWVzLnNldCh0ZXh0RGl2LCB0ZXh0RGl2UHJvcGVydGllcyk7XG5cbiAgICBpZiAodGFzay5fdGV4dENvbnRlbnRTdHJlYW0pIHtcbiAgICAgIHRhc2suX2xheW91dFRleHQodGV4dERpdik7XG4gICAgfVxuXG4gICAgaWYgKHRhc2suX2VuaGFuY2VUZXh0U2VsZWN0aW9uKSB7XG4gICAgICB2YXIgYW5nbGVDb3MgPSAxLFxuICAgICAgICAgIGFuZ2xlU2luID0gMDtcblxuICAgICAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgICAgIGFuZ2xlQ29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBhbmdsZVNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpdldpZHRoID0gKHN0eWxlLnZlcnRpY2FsID8gZ2VvbS5oZWlnaHQgOiBnZW9tLndpZHRoKSAqIHRhc2suX3ZpZXdwb3J0LnNjYWxlO1xuICAgICAgdmFyIGRpdkhlaWdodCA9IGZvbnRIZWlnaHQ7XG4gICAgICB2YXIgbSwgYjtcblxuICAgICAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgICAgIG0gPSBbYW5nbGVDb3MsIGFuZ2xlU2luLCAtYW5nbGVTaW4sIGFuZ2xlQ29zLCBsZWZ0LCB0b3BdO1xuICAgICAgICBiID0gX3V0aWwuVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgZGl2V2lkdGgsIGRpdkhlaWdodF0sIG0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYiA9IFtsZWZ0LCB0b3AsIGxlZnQgKyBkaXZXaWR0aCwgdG9wICsgZGl2SGVpZ2h0XTtcbiAgICAgIH1cblxuICAgICAgdGFzay5fYm91bmRzLnB1c2goe1xuICAgICAgICBsZWZ0OiBiWzBdLFxuICAgICAgICB0b3A6IGJbMV0sXG4gICAgICAgIHJpZ2h0OiBiWzJdLFxuICAgICAgICBib3R0b206IGJbM10sXG4gICAgICAgIGRpdjogdGV4dERpdixcbiAgICAgICAgc2l6ZTogW2RpdldpZHRoLCBkaXZIZWlnaHRdLFxuICAgICAgICBtOiBtXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXIodGFzaykge1xuICAgIGlmICh0YXNrLl9jYW5jZWxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0RGl2cyA9IHRhc2suX3RleHREaXZzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gdGFzay5fY2FwYWJpbGl0eTtcbiAgICB2YXIgdGV4dERpdnNMZW5ndGggPSB0ZXh0RGl2cy5sZW5ndGg7XG5cbiAgICBpZiAodGV4dERpdnNMZW5ndGggPiBNQVhfVEVYVF9ESVZTX1RPX1JFTkRFUikge1xuICAgICAgdGFzay5fcmVuZGVyaW5nRG9uZSA9IHRydWU7XG4gICAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRhc2suX3RleHRDb250ZW50U3RyZWFtKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHREaXZzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFzay5fbGF5b3V0VGV4dCh0ZXh0RGl2c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGFzay5fcmVuZGVyaW5nRG9uZSA9IHRydWU7XG4gICAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kUG9zaXRpdmVNaW4odHMsIG9mZnNldCwgY291bnQpIHtcbiAgICB2YXIgcmVzdWx0ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgdmFyIHQgPSB0c1tvZmZzZXQrK107XG5cbiAgICAgIGlmICh0ID4gMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgPyBNYXRoLm1pbih0LCByZXN1bHQpIDogdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwYW5kKHRhc2spIHtcbiAgICB2YXIgYm91bmRzID0gdGFzay5fYm91bmRzO1xuICAgIHZhciB2aWV3cG9ydCA9IHRhc2suX3ZpZXdwb3J0O1xuICAgIHZhciBleHBhbmRlZCA9IGV4cGFuZEJvdW5kcyh2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0LCBib3VuZHMpO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgdmFyIGRpdiA9IGJvdW5kc1tpXS5kaXY7XG5cbiAgICAgIHZhciBkaXZQcm9wZXJ0aWVzID0gdGFzay5fdGV4dERpdlByb3BlcnRpZXMuZ2V0KGRpdik7XG5cbiAgICAgIGlmIChkaXZQcm9wZXJ0aWVzLmFuZ2xlID09PSAwKSB7XG4gICAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ0xlZnQgPSBib3VuZHNbaV0ubGVmdCAtIGV4cGFuZGVkW2ldLmxlZnQ7XG4gICAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ1RvcCA9IGJvdW5kc1tpXS50b3AgLSBleHBhbmRlZFtpXS50b3A7XG4gICAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ1JpZ2h0ID0gZXhwYW5kZWRbaV0ucmlnaHQgLSBib3VuZHNbaV0ucmlnaHQ7XG4gICAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ0JvdHRvbSA9IGV4cGFuZGVkW2ldLmJvdHRvbSAtIGJvdW5kc1tpXS5ib3R0b207XG5cbiAgICAgICAgdGFzay5fdGV4dERpdlByb3BlcnRpZXMuc2V0KGRpdiwgZGl2UHJvcGVydGllcyk7XG5cbiAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIGUgPSBleHBhbmRlZFtpXSxcbiAgICAgICAgICBiID0gYm91bmRzW2ldO1xuICAgICAgdmFyIG0gPSBiLm0sXG4gICAgICAgICAgYyA9IG1bMF0sXG4gICAgICAgICAgcyA9IG1bMV07XG4gICAgICB2YXIgcG9pbnRzID0gW1swLCAwXSwgWzAsIGIuc2l6ZVsxXV0sIFtiLnNpemVbMF0sIDBdLCBiLnNpemVdO1xuICAgICAgdmFyIHRzID0gbmV3IEZsb2F0NjRBcnJheSg2NCk7XG4gICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocCwgaikge1xuICAgICAgICB2YXIgdCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0ocCwgbSk7XG5cbiAgICAgICAgdHNbaiArIDBdID0gYyAmJiAoZS5sZWZ0IC0gdFswXSkgLyBjO1xuICAgICAgICB0c1tqICsgNF0gPSBzICYmIChlLnRvcCAtIHRbMV0pIC8gcztcbiAgICAgICAgdHNbaiArIDhdID0gYyAmJiAoZS5yaWdodCAtIHRbMF0pIC8gYztcbiAgICAgICAgdHNbaiArIDEyXSA9IHMgJiYgKGUuYm90dG9tIC0gdFsxXSkgLyBzO1xuICAgICAgICB0c1tqICsgMTZdID0gcyAmJiAoZS5sZWZ0IC0gdFswXSkgLyAtcztcbiAgICAgICAgdHNbaiArIDIwXSA9IGMgJiYgKGUudG9wIC0gdFsxXSkgLyBjO1xuICAgICAgICB0c1tqICsgMjRdID0gcyAmJiAoZS5yaWdodCAtIHRbMF0pIC8gLXM7XG4gICAgICAgIHRzW2ogKyAyOF0gPSBjICYmIChlLmJvdHRvbSAtIHRbMV0pIC8gYztcbiAgICAgICAgdHNbaiArIDMyXSA9IGMgJiYgKGUubGVmdCAtIHRbMF0pIC8gLWM7XG4gICAgICAgIHRzW2ogKyAzNl0gPSBzICYmIChlLnRvcCAtIHRbMV0pIC8gLXM7XG4gICAgICAgIHRzW2ogKyA0MF0gPSBjICYmIChlLnJpZ2h0IC0gdFswXSkgLyAtYztcbiAgICAgICAgdHNbaiArIDQ0XSA9IHMgJiYgKGUuYm90dG9tIC0gdFsxXSkgLyAtcztcbiAgICAgICAgdHNbaiArIDQ4XSA9IHMgJiYgKGUubGVmdCAtIHRbMF0pIC8gcztcbiAgICAgICAgdHNbaiArIDUyXSA9IGMgJiYgKGUudG9wIC0gdFsxXSkgLyAtYztcbiAgICAgICAgdHNbaiArIDU2XSA9IHMgJiYgKGUucmlnaHQgLSB0WzBdKSAvIHM7XG4gICAgICAgIHRzW2ogKyA2MF0gPSBjICYmIChlLmJvdHRvbSAtIHRbMV0pIC8gLWM7XG4gICAgICB9KTtcbiAgICAgIHZhciBib3hTY2FsZSA9IDEgKyBNYXRoLm1pbihNYXRoLmFicyhjKSwgTWF0aC5hYnMocykpO1xuICAgICAgZGl2UHJvcGVydGllcy5wYWRkaW5nTGVmdCA9IGZpbmRQb3NpdGl2ZU1pbih0cywgMzIsIDE2KSAvIGJveFNjYWxlO1xuICAgICAgZGl2UHJvcGVydGllcy5wYWRkaW5nVG9wID0gZmluZFBvc2l0aXZlTWluKHRzLCA0OCwgMTYpIC8gYm94U2NhbGU7XG4gICAgICBkaXZQcm9wZXJ0aWVzLnBhZGRpbmdSaWdodCA9IGZpbmRQb3NpdGl2ZU1pbih0cywgMCwgMTYpIC8gYm94U2NhbGU7XG4gICAgICBkaXZQcm9wZXJ0aWVzLnBhZGRpbmdCb3R0b20gPSBmaW5kUG9zaXRpdmVNaW4odHMsIDE2LCAxNikgLyBib3hTY2FsZTtcblxuICAgICAgdGFzay5fdGV4dERpdlByb3BlcnRpZXMuc2V0KGRpdiwgZGl2UHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwYW5kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGFuZEJvdW5kcyh3aWR0aCwgaGVpZ2h0LCBib3hlcykge1xuICAgIHZhciBib3VuZHMgPSBib3hlcy5tYXAoZnVuY3Rpb24gKGJveCwgaSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IGJveC5sZWZ0LFxuICAgICAgICB5MTogYm94LnRvcCxcbiAgICAgICAgeDI6IGJveC5yaWdodCxcbiAgICAgICAgeTI6IGJveC5ib3R0b20sXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICB4MU5ldzogdW5kZWZpbmVkLFxuICAgICAgICB4Mk5ldzogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGV4cGFuZEJvdW5kc0xUUih3aWR0aCwgYm91bmRzKTtcbiAgICB2YXIgZXhwYW5kZWQgPSBuZXcgQXJyYXkoYm94ZXMubGVuZ3RoKTtcbiAgICBib3VuZHMuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgdmFyIGkgPSBiLmluZGV4O1xuICAgICAgZXhwYW5kZWRbaV0gPSB7XG4gICAgICAgIGxlZnQ6IGIueDFOZXcsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IGIueDJOZXcsXG4gICAgICAgIGJvdHRvbTogMFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBib3hlcy5tYXAoZnVuY3Rpb24gKGJveCwgaSkge1xuICAgICAgdmFyIGUgPSBleHBhbmRlZFtpXSxcbiAgICAgICAgICBiID0gYm91bmRzW2ldO1xuICAgICAgYi54MSA9IGJveC50b3A7XG4gICAgICBiLnkxID0gd2lkdGggLSBlLnJpZ2h0O1xuICAgICAgYi54MiA9IGJveC5ib3R0b207XG4gICAgICBiLnkyID0gd2lkdGggLSBlLmxlZnQ7XG4gICAgICBiLmluZGV4ID0gaTtcbiAgICAgIGIueDFOZXcgPSB1bmRlZmluZWQ7XG4gICAgICBiLngyTmV3ID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGV4cGFuZEJvdW5kc0xUUihoZWlnaHQsIGJvdW5kcyk7XG4gICAgYm91bmRzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgIHZhciBpID0gYi5pbmRleDtcbiAgICAgIGV4cGFuZGVkW2ldLnRvcCA9IGIueDFOZXc7XG4gICAgICBleHBhbmRlZFtpXS5ib3R0b20gPSBiLngyTmV3O1xuICAgIH0pO1xuICAgIHJldHVybiBleHBhbmRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGFuZEJvdW5kc0xUUih3aWR0aCwgYm91bmRzKSB7XG4gICAgYm91bmRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLngxIC0gYi54MSB8fCBhLmluZGV4IC0gYi5pbmRleDtcbiAgICB9KTtcbiAgICB2YXIgZmFrZUJvdW5kYXJ5ID0ge1xuICAgICAgeDE6IC1JbmZpbml0eSxcbiAgICAgIHkxOiAtSW5maW5pdHksXG4gICAgICB4MjogMCxcbiAgICAgIHkyOiBJbmZpbml0eSxcbiAgICAgIGluZGV4OiAtMSxcbiAgICAgIHgxTmV3OiAwLFxuICAgICAgeDJOZXc6IDBcbiAgICB9O1xuICAgIHZhciBob3Jpem9uID0gW3tcbiAgICAgIHN0YXJ0OiAtSW5maW5pdHksXG4gICAgICBlbmQ6IEluZmluaXR5LFxuICAgICAgYm91bmRhcnk6IGZha2VCb3VuZGFyeVxuICAgIH1dO1xuICAgIGJvdW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChib3VuZGFyeSkge1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IGhvcml6b24ubGVuZ3RoICYmIGhvcml6b25baV0uZW5kIDw9IGJvdW5kYXJ5LnkxKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgdmFyIGogPSBob3Jpem9uLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChqID49IDAgJiYgaG9yaXpvbltqXS5zdGFydCA+PSBib3VuZGFyeS55Mikge1xuICAgICAgICBqLS07XG4gICAgICB9XG5cbiAgICAgIHZhciBob3Jpem9uUGFydCwgYWZmZWN0ZWRCb3VuZGFyeTtcbiAgICAgIHZhciBxLFxuICAgICAgICAgIGssXG4gICAgICAgICAgbWF4WE5ldyA9IC1JbmZpbml0eTtcblxuICAgICAgZm9yIChxID0gaTsgcSA8PSBqOyBxKyspIHtcbiAgICAgICAgaG9yaXpvblBhcnQgPSBob3Jpem9uW3FdO1xuICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5ID0gaG9yaXpvblBhcnQuYm91bmRhcnk7XG4gICAgICAgIHZhciB4TmV3ID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChhZmZlY3RlZEJvdW5kYXJ5LngyID4gYm91bmRhcnkueDEpIHtcbiAgICAgICAgICB4TmV3ID0gYWZmZWN0ZWRCb3VuZGFyeS5pbmRleCA+IGJvdW5kYXJ5LmluZGV4ID8gYWZmZWN0ZWRCb3VuZGFyeS54MU5ldyA6IGJvdW5kYXJ5LngxO1xuICAgICAgICB9IGVsc2UgaWYgKGFmZmVjdGVkQm91bmRhcnkueDJOZXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHhOZXcgPSAoYWZmZWN0ZWRCb3VuZGFyeS54MiArIGJvdW5kYXJ5LngxKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeE5ldyA9IGFmZmVjdGVkQm91bmRhcnkueDJOZXc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeE5ldyA+IG1heFhOZXcpIHtcbiAgICAgICAgICBtYXhYTmV3ID0geE5ldztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBib3VuZGFyeS54MU5ldyA9IG1heFhOZXc7XG5cbiAgICAgIGZvciAocSA9IGk7IHEgPD0gajsgcSsrKSB7XG4gICAgICAgIGhvcml6b25QYXJ0ID0gaG9yaXpvbltxXTtcbiAgICAgICAgYWZmZWN0ZWRCb3VuZGFyeSA9IGhvcml6b25QYXJ0LmJvdW5kYXJ5O1xuXG4gICAgICAgIGlmIChhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoYWZmZWN0ZWRCb3VuZGFyeS54MiA+IGJvdW5kYXJ5LngxKSB7XG4gICAgICAgICAgICBpZiAoYWZmZWN0ZWRCb3VuZGFyeS5pbmRleCA+IGJvdW5kYXJ5LmluZGV4KSB7XG4gICAgICAgICAgICAgIGFmZmVjdGVkQm91bmRhcnkueDJOZXcgPSBhZmZlY3RlZEJvdW5kYXJ5LngyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID0gbWF4WE5ldztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWZmZWN0ZWRCb3VuZGFyeS54Mk5ldyA+IG1heFhOZXcpIHtcbiAgICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID0gTWF0aC5tYXgobWF4WE5ldywgYWZmZWN0ZWRCb3VuZGFyeS54Mik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5nZWRIb3Jpem9uID0gW107XG4gICAgICB2YXIgbGFzdEJvdW5kYXJ5ID0gbnVsbDtcblxuICAgICAgZm9yIChxID0gaTsgcSA8PSBqOyBxKyspIHtcbiAgICAgICAgaG9yaXpvblBhcnQgPSBob3Jpem9uW3FdO1xuICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5ID0gaG9yaXpvblBhcnQuYm91bmRhcnk7XG4gICAgICAgIHZhciB1c2VCb3VuZGFyeSA9IGFmZmVjdGVkQm91bmRhcnkueDIgPiBib3VuZGFyeS54MiA/IGFmZmVjdGVkQm91bmRhcnkgOiBib3VuZGFyeTtcblxuICAgICAgICBpZiAobGFzdEJvdW5kYXJ5ID09PSB1c2VCb3VuZGFyeSkge1xuICAgICAgICAgIGNoYW5nZWRIb3Jpem9uW2NoYW5nZWRIb3Jpem9uLmxlbmd0aCAtIDFdLmVuZCA9IGhvcml6b25QYXJ0LmVuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGFuZ2VkSG9yaXpvbi5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBob3Jpem9uUGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogaG9yaXpvblBhcnQuZW5kLFxuICAgICAgICAgICAgYm91bmRhcnk6IHVzZUJvdW5kYXJ5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGFzdEJvdW5kYXJ5ID0gdXNlQm91bmRhcnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhvcml6b25baV0uc3RhcnQgPCBib3VuZGFyeS55MSkge1xuICAgICAgICBjaGFuZ2VkSG9yaXpvblswXS5zdGFydCA9IGJvdW5kYXJ5LnkxO1xuICAgICAgICBjaGFuZ2VkSG9yaXpvbi51bnNoaWZ0KHtcbiAgICAgICAgICBzdGFydDogaG9yaXpvbltpXS5zdGFydCxcbiAgICAgICAgICBlbmQ6IGJvdW5kYXJ5LnkxLFxuICAgICAgICAgIGJvdW5kYXJ5OiBob3Jpem9uW2ldLmJvdW5kYXJ5XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnkueTIgPCBob3Jpem9uW2pdLmVuZCkge1xuICAgICAgICBjaGFuZ2VkSG9yaXpvbltjaGFuZ2VkSG9yaXpvbi5sZW5ndGggLSAxXS5lbmQgPSBib3VuZGFyeS55MjtcbiAgICAgICAgY2hhbmdlZEhvcml6b24ucHVzaCh7XG4gICAgICAgICAgc3RhcnQ6IGJvdW5kYXJ5LnkyLFxuICAgICAgICAgIGVuZDogaG9yaXpvbltqXS5lbmQsXG4gICAgICAgICAgYm91bmRhcnk6IGhvcml6b25bal0uYm91bmRhcnlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAocSA9IGk7IHEgPD0gajsgcSsrKSB7XG4gICAgICAgIGhvcml6b25QYXJ0ID0gaG9yaXpvbltxXTtcbiAgICAgICAgYWZmZWN0ZWRCb3VuZGFyeSA9IGhvcml6b25QYXJ0LmJvdW5kYXJ5O1xuXG4gICAgICAgIGlmIChhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChrID0gaSAtIDE7ICF1c2VkICYmIGsgPj0gMCAmJiBob3Jpem9uW2tdLnN0YXJ0ID49IGFmZmVjdGVkQm91bmRhcnkueTE7IGstLSkge1xuICAgICAgICAgIHVzZWQgPSBob3Jpem9uW2tdLmJvdW5kYXJ5ID09PSBhZmZlY3RlZEJvdW5kYXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrID0gaiArIDE7ICF1c2VkICYmIGsgPCBob3Jpem9uLmxlbmd0aCAmJiBob3Jpem9uW2tdLmVuZCA8PSBhZmZlY3RlZEJvdW5kYXJ5LnkyOyBrKyspIHtcbiAgICAgICAgICB1c2VkID0gaG9yaXpvbltrXS5ib3VuZGFyeSA9PT0gYWZmZWN0ZWRCb3VuZGFyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoayA9IDA7ICF1c2VkICYmIGsgPCBjaGFuZ2VkSG9yaXpvbi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIHVzZWQgPSBjaGFuZ2VkSG9yaXpvbltrXS5ib3VuZGFyeSA9PT0gYWZmZWN0ZWRCb3VuZGFyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXNlZCkge1xuICAgICAgICAgIGFmZmVjdGVkQm91bmRhcnkueDJOZXcgPSBtYXhYTmV3O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoaG9yaXpvbiwgW2ksIGogLSBpICsgMV0uY29uY2F0KGNoYW5nZWRIb3Jpem9uKSk7XG4gICAgfSk7XG4gICAgaG9yaXpvbi5mb3JFYWNoKGZ1bmN0aW9uIChob3Jpem9uUGFydCkge1xuICAgICAgdmFyIGFmZmVjdGVkQm91bmRhcnkgPSBob3Jpem9uUGFydC5ib3VuZGFyeTtcblxuICAgICAgaWYgKGFmZmVjdGVkQm91bmRhcnkueDJOZXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID0gTWF0aC5tYXgod2lkdGgsIGFmZmVjdGVkQm91bmRhcnkueDIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gVGV4dExheWVyUmVuZGVyVGFzayhfcmVmKSB7XG4gICAgdmFyIF9nbG9iYWxUaGlzJEZvbnRJbnNwZSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRleHRDb250ZW50ID0gX3JlZi50ZXh0Q29udGVudCxcbiAgICAgICAgdGV4dENvbnRlbnRTdHJlYW0gPSBfcmVmLnRleHRDb250ZW50U3RyZWFtLFxuICAgICAgICBjb250YWluZXIgPSBfcmVmLmNvbnRhaW5lcixcbiAgICAgICAgdmlld3BvcnQgPSBfcmVmLnZpZXdwb3J0LFxuICAgICAgICB0ZXh0RGl2cyA9IF9yZWYudGV4dERpdnMsXG4gICAgICAgIHRleHRDb250ZW50SXRlbXNTdHIgPSBfcmVmLnRleHRDb250ZW50SXRlbXNTdHIsXG4gICAgICAgIGVuaGFuY2VUZXh0U2VsZWN0aW9uID0gX3JlZi5lbmhhbmNlVGV4dFNlbGVjdGlvbjtcbiAgICB0aGlzLl90ZXh0Q29udGVudCA9IHRleHRDb250ZW50O1xuICAgIHRoaXMuX3RleHRDb250ZW50U3RyZWFtID0gdGV4dENvbnRlbnRTdHJlYW07XG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuX2RvY3VtZW50ID0gY29udGFpbmVyLm93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5fdmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLl90ZXh0RGl2cyA9IHRleHREaXZzIHx8IFtdO1xuICAgIHRoaXMuX3RleHRDb250ZW50SXRlbXNTdHIgPSB0ZXh0Q29udGVudEl0ZW1zU3RyIHx8IFtdO1xuICAgIHRoaXMuX2VuaGFuY2VUZXh0U2VsZWN0aW9uID0gISFlbmhhbmNlVGV4dFNlbGVjdGlvbjtcbiAgICB0aGlzLl9mb250SW5zcGVjdG9yRW5hYmxlZCA9ICEhKChfZ2xvYmFsVGhpcyRGb250SW5zcGUgPSBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3IpICE9PSBudWxsICYmIF9nbG9iYWxUaGlzJEZvbnRJbnNwZSAhPT0gdm9pZCAwICYmIF9nbG9iYWxUaGlzJEZvbnRJbnNwZS5lbmFibGVkKTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xheW91dFRleHRMYXN0Rm9udFNpemUgPSBudWxsO1xuICAgIHRoaXMuX2xheW91dFRleHRMYXN0Rm9udEZhbWlseSA9IG51bGw7XG4gICAgdGhpcy5fbGF5b3V0VGV4dEN0eCA9IG51bGw7XG4gICAgdGhpcy5fdGV4dERpdlByb3BlcnRpZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX3JlbmRlcmluZ0RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgdGhpcy5fcmVuZGVyVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IFtdO1xuXG4gICAgdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlW1wiZmluYWxseVwiXShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuX2xheW91dFRleHRDdHgpIHtcbiAgICAgICAgX3RoaXMuX2xheW91dFRleHRDdHguY2FudmFzLndpZHRoID0gMDtcbiAgICAgICAgX3RoaXMuX2xheW91dFRleHRDdHguY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICAgIF90aGlzLl9sYXlvdXRUZXh0Q3R4ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgfVxuXG4gIFRleHRMYXllclJlbmRlclRhc2sucHJvdG90eXBlID0ge1xuICAgIGdldCBwcm9taXNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9LFxuXG4gICAgY2FuY2VsOiBmdW5jdGlvbiBUZXh0TGF5ZXJfY2FuY2VsKCkge1xuICAgICAgdGhpcy5fY2FuY2VsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5fcmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX3JlYWRlci5jYW5jZWwobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwiVGV4dExheWVyIHRhc2sgY2FuY2VsbGVkLlwiKSk7XG5cbiAgICAgICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JlbmRlclRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZW5kZXJUaW1lcik7XG4gICAgICAgIHRoaXMuX3JlbmRlclRpbWVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiVGV4dExheWVyIHRhc2sgY2FuY2VsbGVkLlwiKSk7XG4gICAgfSxcbiAgICBfcHJvY2Vzc0l0ZW1zOiBmdW5jdGlvbiBfcHJvY2Vzc0l0ZW1zKGl0ZW1zLCBzdHlsZUNhY2hlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fdGV4dENvbnRlbnRJdGVtc1N0ci5wdXNoKGl0ZW1zW2ldLnN0cik7XG5cbiAgICAgICAgYXBwZW5kVGV4dCh0aGlzLCBpdGVtc1tpXSwgc3R5bGVDYWNoZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfbGF5b3V0VGV4dDogZnVuY3Rpb24gX2xheW91dFRleHQodGV4dERpdikge1xuICAgICAgdmFyIHRleHREaXZQcm9wZXJ0aWVzID0gdGhpcy5fdGV4dERpdlByb3BlcnRpZXMuZ2V0KHRleHREaXYpO1xuXG4gICAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zZm9ybSA9IFwiXCI7XG5cbiAgICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCAhPT0gMCkge1xuICAgICAgICB2YXIgX3RleHREaXYkc3R5bGUgPSB0ZXh0RGl2LnN0eWxlLFxuICAgICAgICAgICAgZm9udFNpemUgPSBfdGV4dERpdiRzdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBfdGV4dERpdiRzdHlsZS5mb250RmFtaWx5O1xuXG4gICAgICAgIGlmIChmb250U2l6ZSAhPT0gdGhpcy5fbGF5b3V0VGV4dExhc3RGb250U2l6ZSB8fCBmb250RmFtaWx5ICE9PSB0aGlzLl9sYXlvdXRUZXh0TGFzdEZvbnRGYW1pbHkpIHtcbiAgICAgICAgICB0aGlzLl9sYXlvdXRUZXh0Q3R4LmZvbnQgPSBcIlwiLmNvbmNhdChmb250U2l6ZSwgXCIgXCIpLmNvbmNhdChmb250RmFtaWx5KTtcbiAgICAgICAgICB0aGlzLl9sYXlvdXRUZXh0TGFzdEZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgICAgdGhpcy5fbGF5b3V0VGV4dExhc3RGb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdGhpcyRfbGF5b3V0VGV4dEN0eCQgPSB0aGlzLl9sYXlvdXRUZXh0Q3R4Lm1lYXN1cmVUZXh0KHRleHREaXYudGV4dENvbnRlbnQpLFxuICAgICAgICAgICAgd2lkdGggPSBfdGhpcyRfbGF5b3V0VGV4dEN0eCQud2lkdGg7XG5cbiAgICAgICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgICAgIHRleHREaXZQcm9wZXJ0aWVzLnNjYWxlID0gdGV4dERpdlByb3BlcnRpZXMuY2FudmFzV2lkdGggLyB3aWR0aDtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBcInNjYWxlWChcIi5jb25jYXQodGV4dERpdlByb3BlcnRpZXMuc2NhbGUsIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuYW5nbGUgIT09IDApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gXCJyb3RhdGUoXCIuY29uY2F0KHRleHREaXZQcm9wZXJ0aWVzLmFuZ2xlLCBcImRlZykgXCIpLmNvbmNhdCh0cmFuc2Zvcm0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX2VuaGFuY2VUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgdGV4dERpdlByb3BlcnRpZXMub3JpZ2luYWxUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0RGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGV4dERpdlByb3BlcnRpZXMuc2V0KHRleHREaXYsIHRleHREaXZQcm9wZXJ0aWVzKTtcblxuICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRleHREaXYpO1xuICAgIH0sXG4gICAgX3JlbmRlcjogZnVuY3Rpb24gVGV4dExheWVyX3JlbmRlcih0aW1lb3V0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICB2YXIgc3R5bGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXG4gICAgICBjYW52YXMubW96T3BhcXVlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2xheW91dFRleHRDdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgYWxwaGE6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuX3RleHRDb250ZW50KSB7XG4gICAgICAgIHZhciB0ZXh0SXRlbXMgPSB0aGlzLl90ZXh0Q29udGVudC5pdGVtcztcbiAgICAgICAgdmFyIHRleHRTdHlsZXMgPSB0aGlzLl90ZXh0Q29udGVudC5zdHlsZXM7XG5cbiAgICAgICAgdGhpcy5fcHJvY2Vzc0l0ZW1zKHRleHRJdGVtcywgdGV4dFN0eWxlcyk7XG5cbiAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3RleHRDb250ZW50U3RyZWFtKSB7XG4gICAgICAgIHZhciBwdW1wID0gZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgICBfdGhpczIuX3JlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgICAgICAgICAgICAgIGRvbmUgPSBfcmVmMi5kb25lO1xuXG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlQ2FjaGUsIHZhbHVlLnN0eWxlcyk7XG5cbiAgICAgICAgICAgIF90aGlzMi5fcHJvY2Vzc0l0ZW1zKHZhbHVlLml0ZW1zLCBzdHlsZUNhY2hlKTtcblxuICAgICAgICAgICAgcHVtcCgpO1xuICAgICAgICAgIH0sIGNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9yZWFkZXIgPSB0aGlzLl90ZXh0Q29udGVudFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgcHVtcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWl0aGVyIFwidGV4dENvbnRlbnRcIiBub3IgXCJ0ZXh0Q29udGVudFN0cmVhbVwiJyArIFwiIHBhcmFtZXRlcnMgc3BlY2lmaWVkLlwiKTtcbiAgICAgIH1cblxuICAgICAgY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHlsZUNhY2hlID0gbnVsbDtcblxuICAgICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICByZW5kZXIoX3RoaXMyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIuX3JlbmRlclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZW5kZXIoX3RoaXMyKTtcbiAgICAgICAgICAgIF90aGlzMi5fcmVuZGVyVGltZXIgPSBudWxsO1xuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLl9jYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgfSxcbiAgICBleHBhbmRUZXh0RGl2czogZnVuY3Rpb24gVGV4dExheWVyX2V4cGFuZFRleHREaXZzKGV4cGFuZERpdnMpIHtcbiAgICAgIGlmICghdGhpcy5fZW5oYW5jZVRleHRTZWxlY3Rpb24gfHwgIXRoaXMuX3JlbmRlcmluZ0RvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm91bmRzICE9PSBudWxsKSB7XG4gICAgICAgIGV4cGFuZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zZm9ybUJ1ZiA9IFtdLFxuICAgICAgICAgIHBhZGRpbmdCdWYgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5fdGV4dERpdnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB2YXIgZGl2ID0gdGhpcy5fdGV4dERpdnNbaV07XG5cbiAgICAgICAgdmFyIGRpdlByb3BzID0gdGhpcy5fdGV4dERpdlByb3BlcnRpZXMuZ2V0KGRpdik7XG5cbiAgICAgICAgaWYgKGRpdlByb3BzLmlzV2hpdGVzcGFjZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cGFuZERpdnMpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1CdWYubGVuZ3RoID0gMDtcbiAgICAgICAgICBwYWRkaW5nQnVmLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICBpZiAoZGl2UHJvcHMub3JpZ2luYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUJ1Zi5wdXNoKGRpdlByb3BzLm9yaWdpbmFsVHJhbnNmb3JtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGl2UHJvcHMucGFkZGluZ1RvcCA+IDApIHtcbiAgICAgICAgICAgIHBhZGRpbmdCdWYucHVzaChcIlwiLmNvbmNhdChkaXZQcm9wcy5wYWRkaW5nVG9wLCBcInB4XCIpKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybUJ1Zi5wdXNoKFwidHJhbnNsYXRlWShcIi5jb25jYXQoLWRpdlByb3BzLnBhZGRpbmdUb3AsIFwicHgpXCIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFkZGluZ0J1Zi5wdXNoKDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaXZQcm9wcy5wYWRkaW5nUmlnaHQgPiAwKSB7XG4gICAgICAgICAgICBwYWRkaW5nQnVmLnB1c2goXCJcIi5jb25jYXQoZGl2UHJvcHMucGFkZGluZ1JpZ2h0IC8gZGl2UHJvcHMuc2NhbGUsIFwicHhcIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWRkaW5nQnVmLnB1c2goMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRpdlByb3BzLnBhZGRpbmdCb3R0b20gPiAwKSB7XG4gICAgICAgICAgICBwYWRkaW5nQnVmLnB1c2goXCJcIi5jb25jYXQoZGl2UHJvcHMucGFkZGluZ0JvdHRvbSwgXCJweFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhZGRpbmdCdWYucHVzaCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGl2UHJvcHMucGFkZGluZ0xlZnQgPiAwKSB7XG4gICAgICAgICAgICBwYWRkaW5nQnVmLnB1c2goXCJcIi5jb25jYXQoZGl2UHJvcHMucGFkZGluZ0xlZnQgLyBkaXZQcm9wcy5zY2FsZSwgXCJweFwiKSk7XG4gICAgICAgICAgICB0cmFuc2Zvcm1CdWYucHVzaChcInRyYW5zbGF0ZVgoXCIuY29uY2F0KC1kaXZQcm9wcy5wYWRkaW5nTGVmdCAvIGRpdlByb3BzLnNjYWxlLCBcInB4KVwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhZGRpbmdCdWYucHVzaCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXYuc3R5bGUucGFkZGluZyA9IHBhZGRpbmdCdWYuam9pbihcIiBcIik7XG5cbiAgICAgICAgICBpZiAodHJhbnNmb3JtQnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgZGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybUJ1Zi5qb2luKFwiIFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGl2LnN0eWxlLnBhZGRpbmcgPSBudWxsO1xuICAgICAgICAgIGRpdi5zdHlsZS50cmFuc2Zvcm0gPSBkaXZQcm9wcy5vcmlnaW5hbFRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiByZW5kZXJUZXh0TGF5ZXIocmVuZGVyUGFyYW1ldGVycykge1xuICAgIHZhciB0YXNrID0gbmV3IFRleHRMYXllclJlbmRlclRhc2soe1xuICAgICAgdGV4dENvbnRlbnQ6IHJlbmRlclBhcmFtZXRlcnMudGV4dENvbnRlbnQsXG4gICAgICB0ZXh0Q29udGVudFN0cmVhbTogcmVuZGVyUGFyYW1ldGVycy50ZXh0Q29udGVudFN0cmVhbSxcbiAgICAgIGNvbnRhaW5lcjogcmVuZGVyUGFyYW1ldGVycy5jb250YWluZXIsXG4gICAgICB2aWV3cG9ydDogcmVuZGVyUGFyYW1ldGVycy52aWV3cG9ydCxcbiAgICAgIHRleHREaXZzOiByZW5kZXJQYXJhbWV0ZXJzLnRleHREaXZzLFxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0cjogcmVuZGVyUGFyYW1ldGVycy50ZXh0Q29udGVudEl0ZW1zU3RyLFxuICAgICAgZW5oYW5jZVRleHRTZWxlY3Rpb246IHJlbmRlclBhcmFtZXRlcnMuZW5oYW5jZVRleHRTZWxlY3Rpb25cbiAgICB9KTtcblxuICAgIHRhc2suX3JlbmRlcihyZW5kZXJQYXJhbWV0ZXJzLnRpbWVvdXQpO1xuXG4gICAgcmV0dXJuIHRhc2s7XG4gIH1cblxuICByZXR1cm4gcmVuZGVyVGV4dExheWVyO1xufSgpO1xuXG5leHBvcnRzLnJlbmRlclRleHRMYXllciA9IHJlbmRlclRleHRMYXllcjtcblxuLyoqKi8gfSksXG4vKiAxNTIgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlNWR0dyYXBoaWNzID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2lzX25vZGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyB0aHJvdyBfZTI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UzKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMzsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBTVkdHcmFwaGljcyA9IGZ1bmN0aW9uIFNWR0dyYXBoaWNzKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQ6IFNWR0dyYXBoaWNzXCIpO1xufTtcblxuZXhwb3J0cy5TVkdHcmFwaGljcyA9IFNWR0dyYXBoaWNzO1xue1xuICB2YXIgb3BMaXN0VG9UcmVlID0gZnVuY3Rpb24gb3BMaXN0VG9UcmVlKG9wTGlzdCkge1xuICAgIHZhciBvcFRyZWUgPSBbXTtcbiAgICB2YXIgdG1wID0gW107XG5cbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob3BMaXN0KSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIG9wTGlzdEVsZW1lbnQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICBpZiAob3BMaXN0RWxlbWVudC5mbiA9PT0gXCJzYXZlXCIpIHtcbiAgICAgICAgICBvcFRyZWUucHVzaCh7XG4gICAgICAgICAgICBmbklkOiA5MixcbiAgICAgICAgICAgIGZuOiBcImdyb3VwXCIsXG4gICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0bXAucHVzaChvcFRyZWUpO1xuICAgICAgICAgIG9wVHJlZSA9IG9wVHJlZVtvcFRyZWUubGVuZ3RoIC0gMV0uaXRlbXM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3BMaXN0RWxlbWVudC5mbiA9PT0gXCJyZXN0b3JlXCIpIHtcbiAgICAgICAgICBvcFRyZWUgPSB0bXAucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BUcmVlLnB1c2gob3BMaXN0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wVHJlZTtcbiAgfTtcblxuICB2YXIgcGYgPSBmdW5jdGlvbiBwZih2YWx1ZSkge1xuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgdmFyIHMgPSB2YWx1ZS50b0ZpeGVkKDEwKTtcbiAgICB2YXIgaSA9IHMubGVuZ3RoIC0gMTtcblxuICAgIGlmIChzW2ldICE9PSBcIjBcIikge1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgaS0tO1xuICAgIH0gd2hpbGUgKHNbaV0gPT09IFwiMFwiKTtcblxuICAgIHJldHVybiBzLnN1YnN0cmluZygwLCBzW2ldID09PSBcIi5cIiA/IGkgOiBpICsgMSk7XG4gIH07XG5cbiAgdmFyIHBtID0gZnVuY3Rpb24gcG0obSkge1xuICAgIGlmIChtWzRdID09PSAwICYmIG1bNV0gPT09IDApIHtcbiAgICAgIGlmIChtWzFdID09PSAwICYmIG1bMl0gPT09IDApIHtcbiAgICAgICAgaWYgKG1bMF0gPT09IDEgJiYgbVszXSA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwic2NhbGUoXCIuY29uY2F0KHBmKG1bMF0pLCBcIiBcIikuY29uY2F0KHBmKG1bM10pLCBcIilcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChtWzBdID09PSBtWzNdICYmIG1bMV0gPT09IC1tWzJdKSB7XG4gICAgICAgIHZhciBhID0gTWF0aC5hY29zKG1bMF0pICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgcmV0dXJuIFwicm90YXRlKFwiLmNvbmNhdChwZihhKSwgXCIpXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobVswXSA9PT0gMSAmJiBtWzFdID09PSAwICYmIG1bMl0gPT09IDAgJiYgbVszXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHBmKG1bNF0pLCBcIiBcIikuY29uY2F0KHBmKG1bNV0pLCBcIilcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFwibWF0cml4KFwiLmNvbmNhdChwZihtWzBdKSwgXCIgXCIpLmNvbmNhdChwZihtWzFdKSwgXCIgXCIpLmNvbmNhdChwZihtWzJdKSwgXCIgXCIpLmNvbmNhdChwZihtWzNdKSwgXCIgXCIpLmNvbmNhdChwZihtWzRdKSwgXCIgXCIpICsgXCJcIi5jb25jYXQocGYobVs1XSksIFwiKVwiKTtcbiAgfTtcblxuICB2YXIgU1ZHX0RFRkFVTFRTID0ge1xuICAgIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICAgIGZpbGxDb2xvcjogXCIjMDAwMDAwXCJcbiAgfTtcbiAgdmFyIFhNTF9OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCI7XG4gIHZhciBYTElOS19OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiO1xuICB2YXIgTElORV9DQVBfU1RZTEVTID0gW1wiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJdO1xuICB2YXIgTElORV9KT0lOX1NUWUxFUyA9IFtcIm1pdGVyXCIsIFwicm91bmRcIiwgXCJiZXZlbFwiXTtcblxuICB2YXIgY29udmVydEltZ0RhdGFUb1BuZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgUE5HX0hFQURFUiA9IG5ldyBVaW50OEFycmF5KFsweDg5LCAweDUwLCAweDRlLCAweDQ3LCAweDBkLCAweDBhLCAweDFhLCAweDBhXSk7XG4gICAgdmFyIENIVU5LX1dSQVBQRVJfU0laRSA9IDEyO1xuICAgIHZhciBjcmNUYWJsZSA9IG5ldyBJbnQzMkFycmF5KDI1Nik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGk7XG5cbiAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgODsgaCsrKSB7XG4gICAgICAgIGlmIChjICYgMSkge1xuICAgICAgICAgIGMgPSAweGVkYjg4MzIwIF4gYyA+PiAxICYgMHg3ZmZmZmZmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjID0gYyA+PiAxICYgMHg3ZmZmZmZmZjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjcmNUYWJsZVtpXSA9IGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JjMzIoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGNyYyA9IC0xO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IHN0YXJ0OyBfaSA8IGVuZDsgX2krKykge1xuICAgICAgICB2YXIgYSA9IChjcmMgXiBkYXRhW19pXSkgJiAweGZmO1xuICAgICAgICB2YXIgYiA9IGNyY1RhYmxlW2FdO1xuICAgICAgICBjcmMgPSBjcmMgPj4+IDggXiBiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JjIF4gLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JpdGVQbmdDaHVuayh0eXBlLCBib2R5LCBkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHZhciBwID0gb2Zmc2V0O1xuICAgICAgdmFyIGxlbiA9IGJvZHkubGVuZ3RoO1xuICAgICAgZGF0YVtwXSA9IGxlbiA+PiAyNCAmIDB4ZmY7XG4gICAgICBkYXRhW3AgKyAxXSA9IGxlbiA+PiAxNiAmIDB4ZmY7XG4gICAgICBkYXRhW3AgKyAyXSA9IGxlbiA+PiA4ICYgMHhmZjtcbiAgICAgIGRhdGFbcCArIDNdID0gbGVuICYgMHhmZjtcbiAgICAgIHAgKz0gNDtcbiAgICAgIGRhdGFbcF0gPSB0eXBlLmNoYXJDb2RlQXQoMCkgJiAweGZmO1xuICAgICAgZGF0YVtwICsgMV0gPSB0eXBlLmNoYXJDb2RlQXQoMSkgJiAweGZmO1xuICAgICAgZGF0YVtwICsgMl0gPSB0eXBlLmNoYXJDb2RlQXQoMikgJiAweGZmO1xuICAgICAgZGF0YVtwICsgM10gPSB0eXBlLmNoYXJDb2RlQXQoMykgJiAweGZmO1xuICAgICAgcCArPSA0O1xuICAgICAgZGF0YS5zZXQoYm9keSwgcCk7XG4gICAgICBwICs9IGJvZHkubGVuZ3RoO1xuICAgICAgdmFyIGNyYyA9IGNyYzMyKGRhdGEsIG9mZnNldCArIDQsIHApO1xuICAgICAgZGF0YVtwXSA9IGNyYyA+PiAyNCAmIDB4ZmY7XG4gICAgICBkYXRhW3AgKyAxXSA9IGNyYyA+PiAxNiAmIDB4ZmY7XG4gICAgICBkYXRhW3AgKyAyXSA9IGNyYyA+PiA4ICYgMHhmZjtcbiAgICAgIGRhdGFbcCArIDNdID0gY3JjICYgMHhmZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGxlcjMyKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBhID0gMTtcbiAgICAgIHZhciBiID0gMDtcblxuICAgICAgZm9yICh2YXIgX2kyID0gc3RhcnQ7IF9pMiA8IGVuZDsgKytfaTIpIHtcbiAgICAgICAgYSA9IChhICsgKGRhdGFbX2kyXSAmIDB4ZmYpKSAlIDY1NTIxO1xuICAgICAgICBiID0gKGIgKyBhKSAlIDY1NTIxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYiA8PCAxNiB8IGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmbGF0ZVN5bmMobGl0ZXJhbHMpIHtcbiAgICAgIGlmICghX2lzX25vZGUuaXNOb2RlSlMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmxhdGVTeW5jVW5jb21wcmVzc2VkKGxpdGVyYWxzKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGlucHV0O1xuXG4gICAgICAgIGlmIChwYXJzZUludChwcm9jZXNzLnZlcnNpb25zLm5vZGUpID49IDgpIHtcbiAgICAgICAgICBpbnB1dCA9IGxpdGVyYWxzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0ID0gQnVmZmVyLmZyb20obGl0ZXJhbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IHJlcXVpcmUoXCJ6bGliXCIpLmRlZmxhdGVTeW5jKGlucHV0LCB7XG4gICAgICAgICAgbGV2ZWw6IDlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBvdXRwdXQgOiBuZXcgVWludDhBcnJheShvdXRwdXQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJOb3QgY29tcHJlc3NpbmcgUE5HIGJlY2F1c2UgemxpYi5kZWZsYXRlU3luYyBpcyB1bmF2YWlsYWJsZTogXCIgKyBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZmxhdGVTeW5jVW5jb21wcmVzc2VkKGxpdGVyYWxzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZsYXRlU3luY1VuY29tcHJlc3NlZChsaXRlcmFscykge1xuICAgICAgdmFyIGxlbiA9IGxpdGVyYWxzLmxlbmd0aDtcbiAgICAgIHZhciBtYXhCbG9ja0xlbmd0aCA9IDB4ZmZmZjtcbiAgICAgIHZhciBkZWZsYXRlQmxvY2tzID0gTWF0aC5jZWlsKGxlbiAvIG1heEJsb2NrTGVuZ3RoKTtcbiAgICAgIHZhciBpZGF0ID0gbmV3IFVpbnQ4QXJyYXkoMiArIGxlbiArIGRlZmxhdGVCbG9ja3MgKiA1ICsgNCk7XG4gICAgICB2YXIgcGkgPSAwO1xuICAgICAgaWRhdFtwaSsrXSA9IDB4Nzg7XG4gICAgICBpZGF0W3BpKytdID0gMHg5YztcbiAgICAgIHZhciBwb3MgPSAwO1xuXG4gICAgICB3aGlsZSAobGVuID4gbWF4QmxvY2tMZW5ndGgpIHtcbiAgICAgICAgaWRhdFtwaSsrXSA9IDB4MDA7XG4gICAgICAgIGlkYXRbcGkrK10gPSAweGZmO1xuICAgICAgICBpZGF0W3BpKytdID0gMHhmZjtcbiAgICAgICAgaWRhdFtwaSsrXSA9IDB4MDA7XG4gICAgICAgIGlkYXRbcGkrK10gPSAweDAwO1xuICAgICAgICBpZGF0LnNldChsaXRlcmFscy5zdWJhcnJheShwb3MsIHBvcyArIG1heEJsb2NrTGVuZ3RoKSwgcGkpO1xuICAgICAgICBwaSArPSBtYXhCbG9ja0xlbmd0aDtcbiAgICAgICAgcG9zICs9IG1heEJsb2NrTGVuZ3RoO1xuICAgICAgICBsZW4gLT0gbWF4QmxvY2tMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlkYXRbcGkrK10gPSAweDAxO1xuICAgICAgaWRhdFtwaSsrXSA9IGxlbiAmIDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gbGVuID4+IDggJiAweGZmO1xuICAgICAgaWRhdFtwaSsrXSA9IH5sZW4gJiAweGZmZmYgJiAweGZmO1xuICAgICAgaWRhdFtwaSsrXSA9ICh+bGVuICYgMHhmZmZmKSA+PiA4ICYgMHhmZjtcbiAgICAgIGlkYXQuc2V0KGxpdGVyYWxzLnN1YmFycmF5KHBvcyksIHBpKTtcbiAgICAgIHBpICs9IGxpdGVyYWxzLmxlbmd0aCAtIHBvcztcbiAgICAgIHZhciBhZGxlciA9IGFkbGVyMzIobGl0ZXJhbHMsIDAsIGxpdGVyYWxzLmxlbmd0aCk7XG4gICAgICBpZGF0W3BpKytdID0gYWRsZXIgPj4gMjQgJiAweGZmO1xuICAgICAgaWRhdFtwaSsrXSA9IGFkbGVyID4+IDE2ICYgMHhmZjtcbiAgICAgIGlkYXRbcGkrK10gPSBhZGxlciA+PiA4ICYgMHhmZjtcbiAgICAgIGlkYXRbcGkrK10gPSBhZGxlciAmIDB4ZmY7XG4gICAgICByZXR1cm4gaWRhdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmNvZGUoaW1nRGF0YSwga2luZCwgZm9yY2VEYXRhU2NoZW1hLCBpc01hc2spIHtcbiAgICAgIHZhciB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgYml0RGVwdGgsIGNvbG9yVHlwZSwgbGluZVNpemU7XG4gICAgICB2YXIgYnl0ZXMgPSBpbWdEYXRhLmRhdGE7XG5cbiAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICBjYXNlIF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUDpcbiAgICAgICAgICBjb2xvclR5cGUgPSAwO1xuICAgICAgICAgIGJpdERlcHRoID0gMTtcbiAgICAgICAgICBsaW5lU2l6ZSA9IHdpZHRoICsgNyA+PiAzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuSW1hZ2VLaW5kLlJHQl8yNEJQUDpcbiAgICAgICAgICBjb2xvclR5cGUgPSAyO1xuICAgICAgICAgIGJpdERlcHRoID0gODtcbiAgICAgICAgICBsaW5lU2l6ZSA9IHdpZHRoICogMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIF91dGlsLkltYWdlS2luZC5SR0JBXzMyQlBQOlxuICAgICAgICAgIGNvbG9yVHlwZSA9IDY7XG4gICAgICAgICAgYml0RGVwdGggPSA4O1xuICAgICAgICAgIGxpbmVTaXplID0gd2lkdGggKiA0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXRcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaXRlcmFscyA9IG5ldyBVaW50OEFycmF5KCgxICsgbGluZVNpemUpICogaGVpZ2h0KTtcbiAgICAgIHZhciBvZmZzZXRMaXRlcmFscyA9IDAsXG4gICAgICAgICAgb2Zmc2V0Qnl0ZXMgPSAwO1xuXG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgIGxpdGVyYWxzW29mZnNldExpdGVyYWxzKytdID0gMDtcbiAgICAgICAgbGl0ZXJhbHMuc2V0KGJ5dGVzLnN1YmFycmF5KG9mZnNldEJ5dGVzLCBvZmZzZXRCeXRlcyArIGxpbmVTaXplKSwgb2Zmc2V0TGl0ZXJhbHMpO1xuICAgICAgICBvZmZzZXRCeXRlcyArPSBsaW5lU2l6ZTtcbiAgICAgICAgb2Zmc2V0TGl0ZXJhbHMgKz0gbGluZVNpemU7XG4gICAgICB9XG5cbiAgICAgIGlmIChraW5kID09PSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFAgJiYgaXNNYXNrKSB7XG4gICAgICAgIG9mZnNldExpdGVyYWxzID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfeSA9IDA7IF95IDwgaGVpZ2h0OyBfeSsrKSB7XG4gICAgICAgICAgb2Zmc2V0TGl0ZXJhbHMrKztcblxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxpbmVTaXplOyBfaTMrKykge1xuICAgICAgICAgICAgbGl0ZXJhbHNbb2Zmc2V0TGl0ZXJhbHMrK10gXj0gMHhmZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGloZHIgPSBuZXcgVWludDhBcnJheShbd2lkdGggPj4gMjQgJiAweGZmLCB3aWR0aCA+PiAxNiAmIDB4ZmYsIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsIGhlaWdodCA+PiAyNCAmIDB4ZmYsIGhlaWdodCA+PiAxNiAmIDB4ZmYsIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZiwgYml0RGVwdGgsIGNvbG9yVHlwZSwgMHgwMCwgMHgwMCwgMHgwMF0pO1xuICAgICAgdmFyIGlkYXQgPSBkZWZsYXRlU3luYyhsaXRlcmFscyk7XG4gICAgICB2YXIgcG5nTGVuZ3RoID0gUE5HX0hFQURFUi5sZW5ndGggKyBDSFVOS19XUkFQUEVSX1NJWkUgKiAzICsgaWhkci5sZW5ndGggKyBpZGF0Lmxlbmd0aDtcbiAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocG5nTGVuZ3RoKTtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgZGF0YS5zZXQoUE5HX0hFQURFUiwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBQTkdfSEVBREVSLmxlbmd0aDtcbiAgICAgIHdyaXRlUG5nQ2h1bmsoXCJJSERSXCIsIGloZHIsIGRhdGEsIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gQ0hVTktfV1JBUFBFUl9TSVpFICsgaWhkci5sZW5ndGg7XG4gICAgICB3cml0ZVBuZ0NodW5rKFwiSURBVEFcIiwgaWRhdCwgZGF0YSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBDSFVOS19XUkFQUEVSX1NJWkUgKyBpZGF0Lmxlbmd0aDtcbiAgICAgIHdyaXRlUG5nQ2h1bmsoXCJJRU5EXCIsIG5ldyBVaW50OEFycmF5KDApLCBkYXRhLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuICgwLCBfdXRpbC5jcmVhdGVPYmplY3RVUkwpKGRhdGEsIFwiaW1hZ2UvcG5nXCIsIGZvcmNlRGF0YVNjaGVtYSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbnZlcnRJbWdEYXRhVG9QbmcoaW1nRGF0YSwgZm9yY2VEYXRhU2NoZW1hLCBpc01hc2spIHtcbiAgICAgIHZhciBraW5kID0gaW1nRGF0YS5raW5kID09PSB1bmRlZmluZWQgPyBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFAgOiBpbWdEYXRhLmtpbmQ7XG4gICAgICByZXR1cm4gZW5jb2RlKGltZ0RhdGEsIGtpbmQsIGZvcmNlRGF0YVNjaGVtYSwgaXNNYXNrKTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIFNWR0V4dHJhU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNWR0V4dHJhU3RhdGUoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU1ZHRXh0cmFTdGF0ZSk7XG5cbiAgICAgIHRoaXMuZm9udFNpemVTY2FsZSA9IDE7XG4gICAgICB0aGlzLmZvbnRXZWlnaHQgPSBTVkdfREVGQVVMVFMuZm9udFdlaWdodDtcbiAgICAgIHRoaXMuZm9udFNpemUgPSAwO1xuICAgICAgdGhpcy50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgICAgdGhpcy5mb250TWF0cml4ID0gX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgICB0aGlzLmxlYWRpbmcgPSAwO1xuICAgICAgdGhpcy50ZXh0UmVuZGVyaW5nTW9kZSA9IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEw7XG4gICAgICB0aGlzLnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHRoaXMubGluZVggPSAwO1xuICAgICAgdGhpcy5saW5lWSA9IDA7XG4gICAgICB0aGlzLmNoYXJTcGFjaW5nID0gMDtcbiAgICAgIHRoaXMud29yZFNwYWNpbmcgPSAwO1xuICAgICAgdGhpcy50ZXh0SFNjYWxlID0gMTtcbiAgICAgIHRoaXMudGV4dFJpc2UgPSAwO1xuICAgICAgdGhpcy5maWxsQ29sb3IgPSBTVkdfREVGQVVMVFMuZmlsbENvbG9yO1xuICAgICAgdGhpcy5zdHJva2VDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuICAgICAgdGhpcy5zdHJva2VBbHBoYSA9IDE7XG4gICAgICB0aGlzLmxpbmVXaWR0aCA9IDE7XG4gICAgICB0aGlzLmxpbmVKb2luID0gXCJcIjtcbiAgICAgIHRoaXMubGluZUNhcCA9IFwiXCI7XG4gICAgICB0aGlzLm1pdGVyTGltaXQgPSAwO1xuICAgICAgdGhpcy5kYXNoQXJyYXkgPSBbXTtcbiAgICAgIHRoaXMuZGFzaFBoYXNlID0gMDtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gW107XG4gICAgICB0aGlzLmFjdGl2ZUNsaXBVcmwgPSBudWxsO1xuICAgICAgdGhpcy5jbGlwR3JvdXAgPSBudWxsO1xuICAgICAgdGhpcy5tYXNrSWQgPSBcIlwiO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTVkdFeHRyYVN0YXRlLCBbe1xuICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRDdXJyZW50UG9pbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXJyZW50UG9pbnQoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTVkdFeHRyYVN0YXRlO1xuICB9KCk7XG5cbiAgdmFyIGNsaXBDb3VudCA9IDA7XG4gIHZhciBtYXNrQ291bnQgPSAwO1xuICB2YXIgc2hhZGluZ0NvdW50ID0gMDtcblxuICBleHBvcnRzLlNWR0dyYXBoaWNzID0gU1ZHR3JhcGhpY3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNWR0dyYXBoaWNzKGNvbW1vbk9ianMsIG9ianMpIHtcbiAgICAgIHZhciBmb3JjZURhdGFTY2hlbWEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU1ZHR3JhcGhpY3MpO1xuXG4gICAgICB0aGlzLnN2Z0ZhY3RvcnkgPSBuZXcgX2Rpc3BsYXlfdXRpbHMuRE9NU1ZHRmFjdG9yeSgpO1xuICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IFNWR0V4dHJhU3RhdGUoKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgICAgdGhpcy50cmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgICAgdGhpcy5leHRyYVN0YWNrID0gW107XG4gICAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgICB0aGlzLmVtYmVkRm9udHMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW1iZWRkZWRGb250cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmNzc1N0eWxlID0gbnVsbDtcbiAgICAgIHRoaXMuZm9yY2VEYXRhU2NoZW1hID0gISFmb3JjZURhdGFTY2hlbWE7XG4gICAgICB0aGlzLl9vcGVyYXRvcklkTWFwcGluZyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBvcCBpbiBfdXRpbC5PUFMpIHtcbiAgICAgICAgdGhpcy5fb3BlcmF0b3JJZE1hcHBpbmdbX3V0aWwuT1BTW29wXV0gPSBvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU1ZHR3JhcGhpY3MsIFt7XG4gICAgICBrZXk6IFwic2F2ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgIHZhciBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuZXh0cmFTdGFjay5wdXNoKG9sZCk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG9sZC5jbG9uZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZXN0b3JlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdG9yZSgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSB0aGlzLnRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmV4dHJhU3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgICB0aGlzLnRncnAgPSBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJncm91cFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdyb3VwKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICB0aGlzLmV4ZWN1dGVPcFRyZWUoaXRlbXMpO1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibG9hZERlcGVuZGVuY2llc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWREZXBlbmRlbmNpZXMob3BlcmF0b3JMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGZuQXJyYXkgPSBvcGVyYXRvckxpc3QuZm5BcnJheTtcbiAgICAgICAgdmFyIGFyZ3NBcnJheSA9IG9wZXJhdG9yTGlzdC5hcmdzQXJyYXk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZm5BcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgaWYgKGZuQXJyYXlbaV0gIT09IF91dGlsLk9QUy5kZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGFyZ3NBcnJheVtpXSksXG4gICAgICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICAgICAgdmFyIG9iaiA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgICAgdmFyIG9ianNQb29sID0gb2JqLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IF90aGlzLmNvbW1vbk9ianMgOiBfdGhpcy5vYmpzO1xuICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgb2Jqc1Bvb2wuZ2V0KG9iaiwgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF90aGlzLmN1cnJlbnQuZGVwZW5kZW5jaWVzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgICBfbG9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLmN1cnJlbnQuZGVwZW5kZW5jaWVzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidHJhbnNmb3JtXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybU1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybU1hdHJpeCwgdHJhbnNmb3JtTWF0cml4KTtcbiAgICAgICAgdGhpcy50Z3JwID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0U1ZHXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U1ZHKG9wZXJhdG9yTGlzdCwgdmlld3BvcnQpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuXG4gICAgICAgIHZhciBzdmdFbGVtZW50ID0gdGhpcy5faW5pdGlhbGl6ZSh2aWV3cG9ydCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZERlcGVuZGVuY2llcyhvcGVyYXRvckxpc3QpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi50cmFuc2Zvcm1NYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG5cbiAgICAgICAgICBfdGhpczIuZXhlY3V0ZU9wVHJlZShfdGhpczIuY29udmVydE9wTGlzdChvcGVyYXRvckxpc3QpKTtcblxuICAgICAgICAgIHJldHVybiBzdmdFbGVtZW50O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY29udmVydE9wTGlzdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnRPcExpc3Qob3BlcmF0b3JMaXN0KSB7XG4gICAgICAgIHZhciBvcGVyYXRvcklkTWFwcGluZyA9IHRoaXMuX29wZXJhdG9ySWRNYXBwaW5nO1xuICAgICAgICB2YXIgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICAgICAgdmFyIGZuQXJyYXkgPSBvcGVyYXRvckxpc3QuZm5BcnJheTtcbiAgICAgICAgdmFyIG9wTGlzdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZuQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIHZhciBmbklkID0gZm5BcnJheVtpXTtcbiAgICAgICAgICBvcExpc3QucHVzaCh7XG4gICAgICAgICAgICBmbklkOiBmbklkLFxuICAgICAgICAgICAgZm46IG9wZXJhdG9ySWRNYXBwaW5nW2ZuSWRdLFxuICAgICAgICAgICAgYXJnczogYXJnc0FycmF5W2ldXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3BMaXN0VG9UcmVlKG9wTGlzdCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImV4ZWN1dGVPcFRyZWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjdXRlT3BUcmVlKG9wVHJlZSkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG9wVHJlZSksXG4gICAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIG9wVHJlZUVsZW1lbnQgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgICB2YXIgZm4gPSBvcFRyZWVFbGVtZW50LmZuO1xuICAgICAgICAgICAgdmFyIGZuSWQgPSBvcFRyZWVFbGVtZW50LmZuSWQ7XG4gICAgICAgICAgICB2YXIgYXJncyA9IG9wVHJlZUVsZW1lbnQuYXJncztcblxuICAgICAgICAgICAgc3dpdGNoIChmbklkIHwgMCkge1xuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5iZWdpblRleHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5iZWdpblRleHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5kZXBlbmRlbmN5OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExlYWRpbmc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMZWFkaW5nKGFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExlYWRpbmdNb3ZlVGV4dDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldExlYWRpbmdNb3ZlVGV4dChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGb250OlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9udChhcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zaG93VGV4dDpcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dUZXh0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNob3dTcGFjZWRUZXh0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1RleHQoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW5kVGV4dDpcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFRleHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5tb3ZlVGV4dDpcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVUZXh0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldENoYXJTcGFjaW5nOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2hhclNwYWNpbmcoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0V29yZFNwYWNpbmc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRXb3JkU3BhY2luZyhhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRIU2NhbGU6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIU2NhbGUoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0VGV4dE1hdHJpeDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRleHRNYXRyaXgoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0VGV4dFJpc2U6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUZXh0UmlzZShhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRUZXh0UmVuZGVyaW5nTW9kZTpcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRleHRSZW5kZXJpbmdNb2RlKGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExpbmVXaWR0aDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMaW5lSm9pbjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldExpbmVKb2luKGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExpbmVDYXA6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMaW5lQ2FwKGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldE1pdGVyTGltaXQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNaXRlckxpbWl0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEZpbGxSR0JDb2xvcjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZpbGxSR0JDb2xvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRTdHJva2VSR0JDb2xvcjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0cm9rZVJHQkNvbG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFN0cm9rZUNvbG9yTjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0cm9rZUNvbG9yTihhcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGaWxsQ29sb3JOOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmlsbENvbG9yTihhcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zaGFkaW5nRmlsbDpcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRpbmdGaWxsKGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldERhc2g6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREYXNoKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFJlbmRlcmluZ0ludGVudDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGbGF0bmVzczpcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZsYXRuZXNzKGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEdTdGF0ZTpcbiAgICAgICAgICAgICAgICB0aGlzLnNldEdTdGF0ZShhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5maWxsOlxuICAgICAgICAgICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmVvRmlsbDpcbiAgICAgICAgICAgICAgICB0aGlzLmVvRmlsbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnN0cm9rZTpcbiAgICAgICAgICAgICAgICB0aGlzLnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmZpbGxTdHJva2U6XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW9GaWxsU3Ryb2tlOlxuICAgICAgICAgICAgICAgIHRoaXMuZW9GaWxsU3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xpcDpcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXAoXCJub256ZXJvXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmVvQ2xpcDpcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXAoXCJldmVub2RkXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50U29saWRDb2xvckltYWdlTWFzazpcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50U29saWRDb2xvckltYWdlTWFzaygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50SW1hZ2VYT2JqZWN0OlxuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRJbWFnZVhPYmplY3QoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3Q6XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludEltYWdlTWFza1hPYmplY3Q6XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludEltYWdlTWFza1hPYmplY3QoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRGb3JtWE9iamVjdEJlZ2luOlxuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRGb3JtWE9iamVjdEJlZ2luKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50Rm9ybVhPYmplY3RFbmQ6XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludEZvcm1YT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VQYXRoOlxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VTdHJva2U6XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlRmlsbFN0cm9rZTpcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlRmlsbFN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlRU9GaWxsU3Ryb2tlOlxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VFT0ZpbGxTdHJva2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5uZXh0TGluZTpcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMudHJhbnNmb3JtOlxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmNvbnN0cnVjdFBhdGg6XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RQYXRoKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmVuZFBhdGg6XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA5MjpcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwKG9wVHJlZUVsZW1lbnQuaXRlbXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVW5pbXBsZW1lbnRlZCBvcGVyYXRvciBcIi5jb25jYXQoZm4pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFdvcmRTcGFjaW5nXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0V29yZFNwYWNpbmcod29yZFNwYWNpbmcpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gd29yZFNwYWNpbmc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldENoYXJTcGFjaW5nXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2hhclNwYWNpbmcoY2hhclNwYWNpbmcpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gY2hhclNwYWNpbmc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm5leHRMaW5lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dExpbmUoKSB7XG4gICAgICAgIHRoaXMubW92ZVRleHQoMCwgdGhpcy5jdXJyZW50LmxlYWRpbmcpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRUZXh0TWF0cml4XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGV4dE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICBjdXJyZW50LnRleHRNYXRyaXggPSBjdXJyZW50LmxpbmVNYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICAgIGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICAgICAgY3VycmVudC54ID0gY3VycmVudC5saW5lWCA9IDA7XG4gICAgICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgPSAwO1xuICAgICAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICAgICAgY3VycmVudC55Y29vcmRzID0gW107XG4gICAgICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtZmFtaWx5XCIsIGN1cnJlbnQuZm9udEZhbWlseSk7XG4gICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXNpemVcIiwgXCJcIi5jb25jYXQocGYoY3VycmVudC5mb250U2l6ZSksIFwicHhcIikpO1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgICAgIGN1cnJlbnQudHh0RWxlbWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRleHRcIik7XG4gICAgICAgIGN1cnJlbnQudHh0RWxlbWVudC5hcHBlbmRDaGlsZChjdXJyZW50LnRzcGFuKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYmVnaW5UZXh0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYmVnaW5UZXh0KCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgY3VycmVudC54ID0gY3VycmVudC5saW5lWCA9IDA7XG4gICAgICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgPSAwO1xuICAgICAgICBjdXJyZW50LnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgICAgIGN1cnJlbnQubGluZU1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICAgICAgY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgICAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgICAgIGN1cnJlbnQudHh0RWxlbWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRleHRcIik7XG4gICAgICAgIGN1cnJlbnQudHh0Z3JwID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICAgICAgY3VycmVudC54Y29vcmRzID0gW107XG4gICAgICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJtb3ZlVGV4dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUZXh0KHgsIHkpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggKz0geDtcbiAgICAgICAgY3VycmVudC55ID0gY3VycmVudC5saW5lWSArPSB5O1xuICAgICAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICAgICAgY3VycmVudC55Y29vcmRzID0gW107XG4gICAgICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtZmFtaWx5XCIsIGN1cnJlbnQuZm9udEZhbWlseSk7XG4gICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXNpemVcIiwgXCJcIi5jb25jYXQocGYoY3VycmVudC5mb250U2l6ZSksIFwicHhcIikpO1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNob3dUZXh0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2hvd1RleHQoZ2x5cGhzKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICB2YXIgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcblxuICAgICAgICBpZiAoZm9udFNpemUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9udFNpemVTY2FsZSA9IGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICAgICAgdmFyIGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICAgICAgdmFyIHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICAgICAgdmFyIGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgICAgIHZhciB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICAgICAgdmFyIHZlcnRpY2FsID0gZm9udC52ZXJ0aWNhbDtcbiAgICAgICAgdmFyIHNwYWNpbmdEaXIgPSB2ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICAgICAgdmFyIGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgICB2YXIgd2lkdGhBZHZhbmNlU2NhbGUgPSBmb250U2l6ZSAqIGN1cnJlbnQuZm9udE1hdHJpeFswXTtcbiAgICAgICAgdmFyIHggPSAwO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZ2x5cGhzKSxcbiAgICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChnbHlwaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB4ICs9IGZvbnREaXJlY3Rpb24gKiB3b3JkU3BhY2luZztcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgwLCBfdXRpbC5pc051bSkoZ2x5cGgpKSB7XG4gICAgICAgICAgICAgIHggKz0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXIgPSBnbHlwaC5mb250Q2hhcjtcbiAgICAgICAgICAgIHZhciBzY2FsZWRYID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHNjYWxlZFkgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBnbHlwaC53aWR0aDtcblxuICAgICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgIHZhciB2eCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgdmFyIHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgICAgICAgdnggPSBnbHlwaC52bWV0cmljID8gdm1ldHJpY1sxXSA6IHdpZHRoICogMC41O1xuICAgICAgICAgICAgICB2eCA9IC12eCAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICAgICAgICB2YXIgdnkgPSB2bWV0cmljWzJdICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgICAgICAgIHdpZHRoID0gdm1ldHJpYyA/IC12bWV0cmljWzBdIDogd2lkdGg7XG4gICAgICAgICAgICAgIHNjYWxlZFggPSB2eCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICAgIHNjYWxlZFkgPSAoeCArIHZ5KSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzY2FsZWRYID0geCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICAgIHNjYWxlZFkgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ2x5cGguaXNJbkZvbnQgfHwgZm9udC5taXNzaW5nRmlsZSkge1xuICAgICAgICAgICAgICBjdXJyZW50Lnhjb29yZHMucHVzaChjdXJyZW50LnggKyBzY2FsZWRYKTtcblxuICAgICAgICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Lnljb29yZHMucHVzaCgtY3VycmVudC55ICsgc2NhbGVkWSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdXJyZW50LnRzcGFuLnRleHRDb250ZW50ICs9IGNoYXJhY3RlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7fVxuXG4gICAgICAgICAgICB2YXIgY2hhcldpZHRoID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICAgICAgY2hhcldpZHRoID0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAtIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhcldpZHRoID0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSArIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4ICs9IGNoYXJXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgY3VycmVudC54Y29vcmRzLm1hcChwZikuam9pbihcIiBcIikpO1xuXG4gICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIGN1cnJlbnQueWNvb3Jkcy5tYXAocGYpLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICBjdXJyZW50LnkgLT0geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50LnggKz0geCAqIHRleHRIU2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1mYW1pbHlcIiwgY3VycmVudC5mb250RmFtaWx5KTtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtc2l6ZVwiLCBcIlwiLmNvbmNhdChwZihjdXJyZW50LmZvbnRTaXplKSwgXCJweFwiKSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQuZm9udFN0eWxlICE9PSBTVkdfREVGQVVMVFMuZm9udFN0eWxlKSB7XG4gICAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtc3R5bGVcIiwgY3VycmVudC5mb250U3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQuZm9udFdlaWdodCAhPT0gU1ZHX0RFRkFVTFRTLmZvbnRXZWlnaHQpIHtcbiAgICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC13ZWlnaHRcIiwgY3VycmVudC5mb250V2VpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuXG4gICAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5maWxsQ29sb3IgIT09IFNWR19ERUZBVUxUUy5maWxsQ29sb3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIGN1cnJlbnQuZmlsbENvbG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudC5maWxsQWxwaGEgPCAxKSB7XG4gICAgICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1vcGFjaXR5XCIsIGN1cnJlbnQuZmlsbEFscGhhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEgpIHtcbiAgICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICAgIHZhciBsaW5lV2lkdGhTY2FsZSA9IDEgLyAoY3VycmVudC50ZXh0TWF0cml4U2NhbGUgfHwgMSk7XG5cbiAgICAgICAgICB0aGlzLl9zZXRTdHJva2VBdHRyaWJ1dGVzKGN1cnJlbnQudHNwYW4sIGxpbmVXaWR0aFNjYWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0TWF0cml4ID0gY3VycmVudC50ZXh0TWF0cml4O1xuXG4gICAgICAgIGlmIChjdXJyZW50LnRleHRSaXNlICE9PSAwKSB7XG4gICAgICAgICAgdGV4dE1hdHJpeCA9IHRleHRNYXRyaXguc2xpY2UoKTtcbiAgICAgICAgICB0ZXh0TWF0cml4WzVdICs9IGN1cnJlbnQudGV4dFJpc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50LnR4dEVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgXCJcIi5jb25jYXQocG0odGV4dE1hdHJpeCksIFwiIHNjYWxlKFwiKS5jb25jYXQocGYodGV4dEhTY2FsZSksIFwiLCAtMSlcIikpO1xuICAgICAgICBjdXJyZW50LnR4dEVsZW1lbnQuc2V0QXR0cmlidXRlTlMoWE1MX05TLCBcInhtbDpzcGFjZVwiLCBcInByZXNlcnZlXCIpO1xuICAgICAgICBjdXJyZW50LnR4dEVsZW1lbnQuYXBwZW5kQ2hpbGQoY3VycmVudC50c3Bhbik7XG4gICAgICAgIGN1cnJlbnQudHh0Z3JwLmFwcGVuZENoaWxkKGN1cnJlbnQudHh0RWxlbWVudCk7XG5cbiAgICAgICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmRDaGlsZChjdXJyZW50LnR4dEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRMZWFkaW5nTW92ZVRleHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMZWFkaW5nTW92ZVRleHQoeCwgeSkge1xuICAgICAgICB0aGlzLnNldExlYWRpbmcoLXkpO1xuICAgICAgICB0aGlzLm1vdmVUZXh0KHgsIHkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRGb250U3R5bGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGb250U3R5bGUoZm9udE9iaikge1xuICAgICAgICBpZiAoIWZvbnRPYmouZGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEZvbnRTdHlsZTogTm8gZm9udCBkYXRhIGF2YWlsYWJsZSwgXCIgKyAnZW5zdXJlIHRoYXQgdGhlIFwiZm9udEV4dHJhUHJvcGVydGllc1wiIEFQSSBwYXJhbWV0ZXIgaXMgc2V0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmNzc1N0eWxlKSB7XG4gICAgICAgICAgdGhpcy5jc3NTdHlsZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnN0eWxlXCIpO1xuICAgICAgICAgIHRoaXMuY3NzU3R5bGUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0eXBlXCIsIFwidGV4dC9jc3NcIik7XG4gICAgICAgICAgdGhpcy5kZWZzLmFwcGVuZENoaWxkKHRoaXMuY3NzU3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVybCA9ICgwLCBfdXRpbC5jcmVhdGVPYmplY3RVUkwpKGZvbnRPYmouZGF0YSwgZm9udE9iai5taW1ldHlwZSwgdGhpcy5mb3JjZURhdGFTY2hlbWEpO1xuICAgICAgICB0aGlzLmNzc1N0eWxlLnRleHRDb250ZW50ICs9IFwiQGZvbnQtZmFjZSB7IGZvbnQtZmFtaWx5OiBcXFwiXCIuY29uY2F0KGZvbnRPYmoubG9hZGVkTmFtZSwgXCJcXFwiO1wiKSArIFwiIHNyYzogdXJsKFwiLmNvbmNhdCh1cmwsIFwiKTsgfVxcblwiKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0Rm9udFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZvbnQoZGV0YWlscykge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgdmFyIGZvbnRPYmogPSB0aGlzLmNvbW1vbk9ianMuZ2V0KGRldGFpbHNbMF0pO1xuICAgICAgICB2YXIgc2l6ZSA9IGRldGFpbHNbMV07XG4gICAgICAgIGN1cnJlbnQuZm9udCA9IGZvbnRPYmo7XG5cbiAgICAgICAgaWYgKHRoaXMuZW1iZWRGb250cyAmJiAhZm9udE9iai5taXNzaW5nRmlsZSAmJiAhdGhpcy5lbWJlZGRlZEZvbnRzW2ZvbnRPYmoubG9hZGVkTmFtZV0pIHtcbiAgICAgICAgICB0aGlzLmFkZEZvbnRTdHlsZShmb250T2JqKTtcbiAgICAgICAgICB0aGlzLmVtYmVkZGVkRm9udHNbZm9udE9iai5sb2FkZWROYW1lXSA9IGZvbnRPYmo7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgICAgIHZhciBib2xkID0gXCJub3JtYWxcIjtcblxuICAgICAgICBpZiAoZm9udE9iai5ibGFjaykge1xuICAgICAgICAgIGJvbGQgPSBcIjkwMFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGZvbnRPYmouYm9sZCkge1xuICAgICAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGFsaWMgPSBmb250T2JqLml0YWxpYyA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiO1xuXG4gICAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudC5mb250U2l6ZSA9IHNpemU7XG4gICAgICAgIGN1cnJlbnQuZm9udEZhbWlseSA9IGZvbnRPYmoubG9hZGVkTmFtZTtcbiAgICAgICAgY3VycmVudC5mb250V2VpZ2h0ID0gYm9sZDtcbiAgICAgICAgY3VycmVudC5mb250U3R5bGUgPSBpdGFsaWM7XG4gICAgICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgICAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICAgICAgY3VycmVudC55Y29vcmRzID0gW107XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVuZFRleHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRUZXh0KCkge1xuICAgICAgICB2YXIgX2N1cnJlbnQkdHh0RWxlbWVudDtcblxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcblxuICAgICAgICBpZiAoY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcgJiYgKF9jdXJyZW50JHR4dEVsZW1lbnQgPSBjdXJyZW50LnR4dEVsZW1lbnQpICE9PSBudWxsICYmIF9jdXJyZW50JHR4dEVsZW1lbnQgIT09IHZvaWQgMCAmJiBfY3VycmVudCR0eHRFbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGN1cnJlbnQuZWxlbWVudCA9IGN1cnJlbnQudHh0RWxlbWVudDtcbiAgICAgICAgICB0aGlzLmNsaXAoXCJub256ZXJvXCIpO1xuICAgICAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldExpbmVXaWR0aFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldExpbmVXaWR0aCh3aWR0aCkge1xuICAgICAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldExpbmVDYXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMaW5lQ2FwKHN0eWxlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0TGluZUpvaW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMaW5lSm9pbihzdHlsZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnQubGluZUpvaW4gPSBMSU5FX0pPSU5fU1RZTEVTW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0TWl0ZXJMaW1pdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1pdGVyTGltaXQobGltaXQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0U3Ryb2tlQWxwaGFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdHJva2VBbHBoYShzdHJva2VBbHBoYSkge1xuICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSBzdHJva2VBbHBoYTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0U3Ryb2tlUkdCQ29sb3JcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdHJva2VSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRGaWxsQWxwaGFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGaWxsQWxwaGEoZmlsbEFscGhhKSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5maWxsQWxwaGEgPSBmaWxsQWxwaGE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldEZpbGxSR0JDb2xvclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZpbGxSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgICAgICAgdGhpcy5jdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgICAgIHRoaXMuY3VycmVudC54Y29vcmRzID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudC55Y29vcmRzID0gW107XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFN0cm9rZUNvbG9yTlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0cm9rZUNvbG9yTihhcmdzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IHRoaXMuX21ha2VDb2xvck5fUGF0dGVybihhcmdzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0RmlsbENvbG9yTlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZpbGxDb2xvck4oYXJncykge1xuICAgICAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gdGhpcy5fbWFrZUNvbG9yTl9QYXR0ZXJuKGFyZ3MpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzaGFkaW5nRmlsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNoYWRpbmdGaWxsKGFyZ3MpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy52aWV3cG9ydC53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMudmlld3BvcnQuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBpbnYgPSBfdXRpbC5VdGlsLmludmVyc2VUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuXG4gICAgICAgIHZhciBibCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIDBdLCBpbnYpO1xuXG4gICAgICAgIHZhciBiciA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIGhlaWdodF0sIGludik7XG5cbiAgICAgICAgdmFyIHVsID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbd2lkdGgsIDBdLCBpbnYpO1xuXG4gICAgICAgIHZhciB1ciA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3dpZHRoLCBoZWlnaHRdLCBpbnYpO1xuXG4gICAgICAgIHZhciB4MCA9IE1hdGgubWluKGJsWzBdLCBiclswXSwgdWxbMF0sIHVyWzBdKTtcbiAgICAgICAgdmFyIHkwID0gTWF0aC5taW4oYmxbMV0sIGJyWzFdLCB1bFsxXSwgdXJbMV0pO1xuICAgICAgICB2YXIgeDEgPSBNYXRoLm1heChibFswXSwgYnJbMF0sIHVsWzBdLCB1clswXSk7XG4gICAgICAgIHZhciB5MSA9IE1hdGgubWF4KGJsWzFdLCBiclsxXSwgdWxbMV0sIHVyWzFdKTtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4MCk7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHkwKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHgxIC0geDApO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHkxIC0geTApO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCB0aGlzLl9tYWtlU2hhZGluZ1BhdHRlcm4oYXJncykpO1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQuZmlsbEFscGhhIDwgMSkge1xuICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLW9wYWNpdHlcIiwgdGhpcy5jdXJyZW50LmZpbGxBbHBoYSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZENoaWxkKHJlY3QpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfbWFrZUNvbG9yTl9QYXR0ZXJuXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VDb2xvck5fUGF0dGVybihhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlVGlsaW5nUGF0dGVybihhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYWtlU2hhZGluZ1BhdHRlcm4oYXJncyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9tYWtlVGlsaW5nUGF0dGVyblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlVGlsaW5nUGF0dGVybihhcmdzKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBvcGVyYXRvckxpc3QgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgbWF0cml4ID0gYXJnc1szXSB8fCBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG5cbiAgICAgICAgdmFyIF9hcmdzJCA9IF9zbGljZWRUb0FycmF5KGFyZ3NbNF0sIDQpLFxuICAgICAgICAgICAgeDAgPSBfYXJncyRbMF0sXG4gICAgICAgICAgICB5MCA9IF9hcmdzJFsxXSxcbiAgICAgICAgICAgIHgxID0gX2FyZ3MkWzJdLFxuICAgICAgICAgICAgeTEgPSBfYXJncyRbM107XG5cbiAgICAgICAgdmFyIHhzdGVwID0gYXJnc1s1XTtcbiAgICAgICAgdmFyIHlzdGVwID0gYXJnc1s2XTtcbiAgICAgICAgdmFyIHBhaW50VHlwZSA9IGFyZ3NbN107XG4gICAgICAgIHZhciB0aWxpbmdJZCA9IFwic2hhZGluZ1wiLmNvbmNhdChzaGFkaW5nQ291bnQrKyk7XG5cbiAgICAgICAgdmFyIF9VdGlsJGFwcGx5VHJhbnNmb3JtID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeDAsIHkwXSwgbWF0cml4KSxcbiAgICAgICAgICAgIF9VdGlsJGFwcGx5VHJhbnNmb3JtMiA9IF9zbGljZWRUb0FycmF5KF9VdGlsJGFwcGx5VHJhbnNmb3JtLCAyKSxcbiAgICAgICAgICAgIHR4MCA9IF9VdGlsJGFwcGx5VHJhbnNmb3JtMlswXSxcbiAgICAgICAgICAgIHR5MCA9IF9VdGlsJGFwcGx5VHJhbnNmb3JtMlsxXTtcblxuICAgICAgICB2YXIgX1V0aWwkYXBwbHlUcmFuc2Zvcm0zID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeDEsIHkxXSwgbWF0cml4KSxcbiAgICAgICAgICAgIF9VdGlsJGFwcGx5VHJhbnNmb3JtNCA9IF9zbGljZWRUb0FycmF5KF9VdGlsJGFwcGx5VHJhbnNmb3JtMywgMiksXG4gICAgICAgICAgICB0eDEgPSBfVXRpbCRhcHBseVRyYW5zZm9ybTRbMF0sXG4gICAgICAgICAgICB0eTEgPSBfVXRpbCRhcHBseVRyYW5zZm9ybTRbMV07XG5cbiAgICAgICAgdmFyIF9VdGlsJHNpbmd1bGFyVmFsdWVEZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUobWF0cml4KSxcbiAgICAgICAgICAgIF9VdGlsJHNpbmd1bGFyVmFsdWVEZTIgPSBfc2xpY2VkVG9BcnJheShfVXRpbCRzaW5ndWxhclZhbHVlRGUsIDIpLFxuICAgICAgICAgICAgeHNjYWxlID0gX1V0aWwkc2luZ3VsYXJWYWx1ZURlMlswXSxcbiAgICAgICAgICAgIHlzY2FsZSA9IF9VdGlsJHNpbmd1bGFyVmFsdWVEZTJbMV07XG5cbiAgICAgICAgdmFyIHR4c3RlcCA9IHhzdGVwICogeHNjYWxlO1xuICAgICAgICB2YXIgdHlzdGVwID0geXN0ZXAgKiB5c2NhbGU7XG4gICAgICAgIHZhciB0aWxpbmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpwYXR0ZXJuXCIpO1xuICAgICAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCB0aWxpbmdJZCk7XG4gICAgICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInBhdHRlcm5Vbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xuICAgICAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCB0eHN0ZXApO1xuICAgICAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgdHlzdGVwKTtcbiAgICAgICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBcIlwiLmNvbmNhdCh0eDApKTtcbiAgICAgICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBcIlwiLmNvbmNhdCh0eTApKTtcbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMuc3ZnO1xuICAgICAgICB2YXIgdHJhbnNmb3JtTWF0cml4ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXg7XG4gICAgICAgIHZhciBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgICAgICB2YXIgc3Ryb2tlQ29sb3IgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3I7XG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh0eDEgLSB0eDAsIHR5MSAtIHR5MCk7XG4gICAgICAgIHRoaXMuc3ZnID0gYmJveDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBtYXRyaXg7XG5cbiAgICAgICAgaWYgKHBhaW50VHlwZSA9PT0gMikge1xuICAgICAgICAgIHZhciBjc3NDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yLmFwcGx5KF91dGlsLlV0aWwsIF90b0NvbnN1bWFibGVBcnJheShjb2xvcikpO1xuXG4gICAgICAgICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5leGVjdXRlT3BUcmVlKHRoaXMuY29udmVydE9wTGlzdChvcGVyYXRvckxpc3QpKTtcbiAgICAgICAgdGhpcy5zdmcgPSBzdmc7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gdHJhbnNmb3JtTWF0cml4O1xuICAgICAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gZmlsbENvbG9yO1xuICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBzdHJva2VDb2xvcjtcbiAgICAgICAgdGlsaW5nLmFwcGVuZENoaWxkKGJib3guY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIHRoaXMuZGVmcy5hcHBlbmRDaGlsZCh0aWxpbmcpO1xuICAgICAgICByZXR1cm4gXCJ1cmwoI1wiLmNvbmNhdCh0aWxpbmdJZCwgXCIpXCIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfbWFrZVNoYWRpbmdQYXR0ZXJuXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKSB7XG4gICAgICAgIHN3aXRjaCAoYXJnc1swXSkge1xuICAgICAgICAgIGNhc2UgXCJSYWRpYWxBeGlhbFwiOlxuICAgICAgICAgICAgdmFyIHNoYWRpbmdJZCA9IFwic2hhZGluZ1wiLmNvbmNhdChzaGFkaW5nQ291bnQrKyk7XG4gICAgICAgICAgICB2YXIgY29sb3JTdG9wcyA9IGFyZ3NbM107XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnQ7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoYXJnc1sxXSkge1xuICAgICAgICAgICAgICBjYXNlIFwiYXhpYWxcIjpcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQwID0gYXJnc1s0XTtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQxID0gYXJnc1s1XTtcbiAgICAgICAgICAgICAgICBncmFkaWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmxpbmVhckdyYWRpZW50XCIpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaWRcIiwgc2hhZGluZ0lkKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImdyYWRpZW50VW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIngxXCIsIHBvaW50MFswXSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5MVwiLCBwb2ludDBbMV0pO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieDJcIiwgcG9pbnQxWzBdKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInkyXCIsIHBvaW50MVsxXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInJhZGlhbFwiOlxuICAgICAgICAgICAgICAgIHZhciBmb2NhbFBvaW50ID0gYXJnc1s0XTtcbiAgICAgICAgICAgICAgICB2YXIgY2lyY2xlUG9pbnQgPSBhcmdzWzVdO1xuICAgICAgICAgICAgICAgIHZhciBmb2NhbFJhZGl1cyA9IGFyZ3NbNl07XG4gICAgICAgICAgICAgICAgdmFyIGNpcmNsZVJhZGl1cyA9IGFyZ3NbN107XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyYWRpYWxHcmFkaWVudFwiKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHNoYWRpbmdJZCk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJncmFkaWVudFVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIik7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeFwiLCBjaXJjbGVQb2ludFswXSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeVwiLCBjaXJjbGVQb2ludFsxXSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJyXCIsIGNpcmNsZVJhZGl1cyk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmeFwiLCBmb2NhbFBvaW50WzBdKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZ5XCIsIGZvY2FsUG9pbnRbMV0pO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZnJcIiwgZm9jYWxSYWRpdXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBSYWRpYWxBeGlhbCB0eXBlOiBcIi5jb25jYXQoYXJnc1sxXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGNvbG9yU3RvcHMpLFxuICAgICAgICAgICAgICAgIF9zdGVwNTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3JTdG9wID0gX3N0ZXA1LnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBzdG9wID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6c3RvcFwiKTtcbiAgICAgICAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwib2Zmc2V0XCIsIGNvbG9yU3RvcFswXSk7XG4gICAgICAgICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0b3AtY29sb3JcIiwgY29sb3JTdG9wWzFdKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5hcHBlbmRDaGlsZChzdG9wKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGVmcy5hcHBlbmRDaGlsZChncmFkaWVudCk7XG4gICAgICAgICAgICByZXR1cm4gXCJ1cmwoI1wiLmNvbmNhdChzaGFkaW5nSWQsIFwiKVwiKTtcblxuICAgICAgICAgIGNhc2UgXCJNZXNoXCI6XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIHBhdHRlcm4gTWVzaFwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgY2FzZSBcIkR1bW15XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJob3RwaW5rXCI7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBJUiB0eXBlOiBcIi5jb25jYXQoYXJnc1swXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldERhc2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXNoKGRhc2hBcnJheSwgZGFzaFBoYXNlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG4gICAgICAgIHRoaXMuY3VycmVudC5kYXNoUGhhc2UgPSBkYXNoUGhhc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbnN0cnVjdFBhdGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdHJ1Y3RQYXRoKG9wcywgYXJncykge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgdmFyIHggPSBjdXJyZW50LngsXG4gICAgICAgICAgICB5ID0gY3VycmVudC55O1xuICAgICAgICB2YXIgZCA9IFtdO1xuICAgICAgICB2YXIgaiA9IDA7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvcHMpLFxuICAgICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBvcCA9IF9zdGVwNi52YWx1ZTtcblxuICAgICAgICAgICAgc3dpdGNoIChvcCB8IDApIHtcbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMucmVjdGFuZ2xlOlxuICAgICAgICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBhcmdzW2orK107XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgICAgICB2YXIgeHcgPSB4ICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcbiAgICAgICAgICAgICAgICBkLnB1c2goXCJNXCIsIHBmKHgpLCBwZih5KSwgXCJMXCIsIHBmKHh3KSwgcGYoeSksIFwiTFwiLCBwZih4dyksIHBmKHloKSwgXCJMXCIsIHBmKHgpLCBwZih5aCksIFwiWlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5tb3ZlVG86XG4gICAgICAgICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgICAgIGQucHVzaChcIk1cIiwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5saW5lVG86XG4gICAgICAgICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgICAgIGQucHVzaChcIkxcIiwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvOlxuICAgICAgICAgICAgICAgIHggPSBhcmdzW2ogKyA0XTtcbiAgICAgICAgICAgICAgICB5ID0gYXJnc1tqICsgNV07XG4gICAgICAgICAgICAgICAgZC5wdXNoKFwiQ1wiLCBwZihhcmdzW2pdKSwgcGYoYXJnc1tqICsgMV0pLCBwZihhcmdzW2ogKyAyXSksIHBmKGFyZ3NbaiArIDNdKSwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICAgICAgICBqICs9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzI6XG4gICAgICAgICAgICAgICAgZC5wdXNoKFwiQ1wiLCBwZih4KSwgcGYoeSksIHBmKGFyZ3Nbal0pLCBwZihhcmdzW2ogKyAxXSksIHBmKGFyZ3NbaiArIDJdKSwgcGYoYXJnc1tqICsgM10pKTtcbiAgICAgICAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMzpcbiAgICAgICAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgICAgICAgIGQucHVzaChcIkNcIiwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoeCksIHBmKHkpLCBwZih4KSwgcGYoeSkpO1xuICAgICAgICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZVBhdGg6XG4gICAgICAgICAgICAgICAgZC5wdXNoKFwiWlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZCA9IGQuam9pbihcIiBcIik7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQucGF0aCAmJiBvcHMubGVuZ3RoID4gMCAmJiBvcHNbMF0gIT09IF91dGlsLk9QUy5yZWN0YW5nbGUgJiYgb3BzWzBdICE9PSBfdXRpbC5PUFMubW92ZVRvKSB7XG4gICAgICAgICAgZCA9IGN1cnJlbnQucGF0aC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIikgKyBkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnQucGF0aCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnBhdGhcIik7XG5cbiAgICAgICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZENoaWxkKGN1cnJlbnQucGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50LnBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIGQpO1xuICAgICAgICBjdXJyZW50LnBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgY3VycmVudC5lbGVtZW50ID0gY3VycmVudC5wYXRoO1xuICAgICAgICBjdXJyZW50LnNldEN1cnJlbnRQb2ludCh4LCB5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZW5kUGF0aFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuZFBhdGgoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICBjdXJyZW50LnBhdGggPSBudWxsO1xuXG4gICAgICAgIGlmICghdGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY3VycmVudC5lbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNsaXBJZCA9IFwiY2xpcHBhdGhcIi5jb25jYXQoY2xpcENvdW50KyspO1xuICAgICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpjbGlwUGF0aFwiKTtcbiAgICAgICAgY2xpcFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBjbGlwSWQpO1xuICAgICAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBwbSh0aGlzLnRyYW5zZm9ybU1hdHJpeCkpO1xuICAgICAgICB2YXIgY2xpcEVsZW1lbnQgPSBjdXJyZW50LmVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwID09PSBcImV2ZW5vZGRcIikge1xuICAgICAgICAgIGNsaXBFbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xpcC1ydWxlXCIsIFwiZXZlbm9kZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGlwRWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcnVsZVwiLCBcIm5vbnplcm9cIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgICAgY2xpcFBhdGguYXBwZW5kQ2hpbGQoY2xpcEVsZW1lbnQpO1xuICAgICAgICB0aGlzLmRlZnMuYXBwZW5kQ2hpbGQoY2xpcFBhdGgpO1xuXG4gICAgICAgIGlmIChjdXJyZW50LmFjdGl2ZUNsaXBVcmwpIHtcbiAgICAgICAgICBjdXJyZW50LmNsaXBHcm91cCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5leHRyYVN0YWNrLmZvckVhY2goZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYuY2xpcEdyb3VwID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcGF0aFwiLCBjdXJyZW50LmFjdGl2ZUNsaXBVcmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudC5hY3RpdmVDbGlwVXJsID0gXCJ1cmwoI1wiLmNvbmNhdChjbGlwSWQsIFwiKVwiKTtcbiAgICAgICAgdGhpcy50Z3JwID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xpcFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsaXAodHlwZSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdDbGlwID0gdHlwZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VQYXRoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VQYXRoKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcblxuICAgICAgICBpZiAoY3VycmVudC5wYXRoKSB7XG4gICAgICAgICAgdmFyIGQgPSBcIlwiLmNvbmNhdChjdXJyZW50LnBhdGguZ2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIpLCBcIlpcIik7XG4gICAgICAgICAgY3VycmVudC5wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRMZWFkaW5nXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGVhZGluZyhsZWFkaW5nKSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5sZWFkaW5nID0gLWxlYWRpbmc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFRleHRSaXNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGV4dFJpc2UodGV4dFJpc2UpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LnRleHRSaXNlID0gdGV4dFJpc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFRleHRSZW5kZXJpbmdNb2RlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGV4dFJlbmRlcmluZ01vZGUodGV4dFJlbmRlcmluZ01vZGUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID0gdGV4dFJlbmRlcmluZ01vZGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldEhTY2FsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhTY2FsZShzY2FsZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnQudGV4dEhTY2FsZSA9IHNjYWxlIC8gMTAwO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRSZW5kZXJpbmdJbnRlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KSB7fVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRGbGF0bmVzc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZsYXRuZXNzKGZsYXRuZXNzKSB7fVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRHU3RhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRHU3RhdGUoc3RhdGVzKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3RhdGVzKSxcbiAgICAgICAgICAgIF9zdGVwNztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX3N0ZXA3JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA3LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgICBrZXkgPSBfc3RlcDckdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfc3RlcDckdmFsdWVbMV07XG5cbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJMV1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiTENcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldExpbmVDYXAodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJMSlwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4odmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJNTFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldERhc2godmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiUklcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIkZMXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZvbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJDQVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlQWxwaGEodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJjYVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmlsbEFscGhhKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIlVuaW1wbGVtZW50ZWQgZ3JhcGhpYyBzdGF0ZSBvcGVyYXRvciBcIi5jb25jYXQoa2V5KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3I3LmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmaWxsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbCgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgICAgIGN1cnJlbnQuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgY3VycmVudC5maWxsQ29sb3IpO1xuICAgICAgICAgIGN1cnJlbnQuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtb3BhY2l0eVwiLCBjdXJyZW50LmZpbGxBbHBoYSk7XG4gICAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3Ryb2tlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3Ryb2tlKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcblxuICAgICAgICBpZiAoY3VycmVudC5lbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5fc2V0U3Ryb2tlQXR0cmlidXRlcyhjdXJyZW50LmVsZW1lbnQpO1xuXG4gICAgICAgICAgY3VycmVudC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldFN0cm9rZUF0dHJpYnV0ZXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U3Ryb2tlQXR0cmlidXRlcyhlbGVtZW50KSB7XG4gICAgICAgIHZhciBsaW5lV2lkdGhTY2FsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIHZhciBkYXNoQXJyYXkgPSBjdXJyZW50LmRhc2hBcnJheTtcblxuICAgICAgICBpZiAobGluZVdpZHRoU2NhbGUgIT09IDEgJiYgZGFzaEFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkYXNoQXJyYXkgPSBkYXNoQXJyYXkubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVXaWR0aFNjYWxlICogdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlXCIsIGN1cnJlbnQuc3Ryb2tlQ29sb3IpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLW9wYWNpdHlcIiwgY3VycmVudC5zdHJva2VBbHBoYSk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtbWl0ZXJsaW1pdFwiLCBwZihjdXJyZW50Lm1pdGVyTGltaXQpKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1saW5lY2FwXCIsIGN1cnJlbnQubGluZUNhcCk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtbGluZWpvaW5cIiwgY3VycmVudC5saW5lSm9pbik7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2Utd2lkdGhcIiwgcGYobGluZVdpZHRoU2NhbGUgKiBjdXJyZW50LmxpbmVXaWR0aCkgKyBcInB4XCIpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLWRhc2hhcnJheVwiLCBkYXNoQXJyYXkubWFwKHBmKS5qb2luKFwiIFwiKSk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtZGFzaG9mZnNldFwiLCBwZihsaW5lV2lkdGhTY2FsZSAqIGN1cnJlbnQuZGFzaFBoYXNlKSArIFwicHhcIik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVvRmlsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVvRmlsbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5lbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZpbGxTdHJva2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsU3Ryb2tlKCkge1xuICAgICAgICB0aGlzLnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmZpbGwoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZW9GaWxsU3Ryb2tlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW9GaWxsU3Ryb2tlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50LmVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtcnVsZVwiLCBcImV2ZW5vZGRcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VTdHJva2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZVN0cm9rZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VGaWxsU3Ryb2tlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VGaWxsU3Ryb2tlKCkge1xuICAgICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VFT0ZpbGxTdHJva2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZUVPRmlsbFN0cm9rZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5lb0ZpbGxTdHJva2UoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgXCIwXCIpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgXCIxcHhcIik7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgXCIxcHhcIik7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIHRoaXMuY3VycmVudC5maWxsQ29sb3IpO1xuXG4gICAgICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kQ2hpbGQocmVjdCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhaW50SW1hZ2VYT2JqZWN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFpbnRJbWFnZVhPYmplY3Qob2JqSWQpIHtcbiAgICAgICAgdmFyIGltZ0RhdGEgPSBvYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KG9iaklkKSA6IHRoaXMub2Jqcy5nZXQob2JqSWQpO1xuXG4gICAgICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIkRlcGVuZGVudCBpbWFnZSB3aXRoIG9iamVjdCBJRCBcIi5jb25jYXQob2JqSWQsIFwiIGlzIG5vdCByZWFkeSB5ZXRcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhaW50SW5saW5lSW1hZ2VYT2JqZWN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSwgbWFzaykge1xuICAgICAgICB2YXIgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICAgIHZhciBpbWdTcmMgPSBjb252ZXJ0SW1nRGF0YVRvUG5nKGltZ0RhdGEsIHRoaXMuZm9yY2VEYXRhU2NoZW1hLCAhIW1hc2spO1xuICAgICAgICB2YXIgY2xpcHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgXCIwXCIpO1xuICAgICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHBmKHdpZHRoKSk7XG4gICAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHBmKGhlaWdodCkpO1xuICAgICAgICB0aGlzLmN1cnJlbnQuZWxlbWVudCA9IGNsaXByZWN0O1xuICAgICAgICB0aGlzLmNsaXAoXCJub256ZXJvXCIpO1xuICAgICAgICB2YXIgaW1nRWwgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzppbWFnZVwiKTtcbiAgICAgICAgaW1nRWwuc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIFwieGxpbms6aHJlZlwiLCBpbWdTcmMpO1xuICAgICAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgICAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWhlaWdodCkpO1xuICAgICAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHBmKHdpZHRoKSArIFwicHhcIik7XG4gICAgICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHBmKGhlaWdodCkgKyBcInB4XCIpO1xuICAgICAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBcInNjYWxlKFwiLmNvbmNhdChwZigxIC8gd2lkdGgpLCBcIiBcIikuY29uY2F0KHBmKC0xIC8gaGVpZ2h0KSwgXCIpXCIpKTtcblxuICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgIG1hc2suYXBwZW5kQ2hpbGQoaW1nRWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kQ2hpbGQoaW1nRWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhaW50SW1hZ2VNYXNrWE9iamVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhaW50SW1hZ2VNYXNrWE9iamVjdChpbWdEYXRhKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICB2YXIgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICAgIHZhciBmaWxsQ29sb3IgPSBjdXJyZW50LmZpbGxDb2xvcjtcbiAgICAgICAgY3VycmVudC5tYXNrSWQgPSBcIm1hc2tcIi5jb25jYXQobWFza0NvdW50KyspO1xuICAgICAgICB2YXIgbWFzayA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOm1hc2tcIik7XG4gICAgICAgIG1hc2suc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBjdXJyZW50Lm1hc2tJZCk7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBcIjBcIik7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHBmKGhlaWdodCkpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBmaWxsQ29sb3IpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwibWFza1wiLCBcInVybCgjXCIuY29uY2F0KGN1cnJlbnQubWFza0lkLCBcIilcIikpO1xuICAgICAgICB0aGlzLmRlZnMuYXBwZW5kQ2hpbGQobWFzayk7XG5cbiAgICAgICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmRDaGlsZChyZWN0KTtcblxuICAgICAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEsIG1hc2spO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwYWludEZvcm1YT2JqZWN0QmVnaW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYWludEZvcm1YT2JqZWN0QmVnaW4obWF0cml4LCBiYm94KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdHJpeCkgJiYgbWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgICAgIHRoaXMudHJhbnNmb3JtKG1hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbMl0sIG1hdHJpeFszXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJib3gpIHtcbiAgICAgICAgICB2YXIgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gICAgICAgICAgdmFyIGNsaXByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICAgICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgYmJveFswXSk7XG4gICAgICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIGJib3hbMV0pO1xuICAgICAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpKTtcbiAgICAgICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpKTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuZWxlbWVudCA9IGNsaXByZWN0O1xuICAgICAgICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGFpbnRGb3JtWE9iamVjdEVuZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhaW50Rm9ybVhPYmplY3RFbmQoKSB7fVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaW5pdGlhbGl6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0aWFsaXplKHZpZXdwb3J0KSB7XG4gICAgICAgIHZhciBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQpO1xuICAgICAgICB2YXIgZGVmaW5pdGlvbnMgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpkZWZzXCIpO1xuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoZGVmaW5pdGlvbnMpO1xuICAgICAgICB0aGlzLmRlZnMgPSBkZWZpbml0aW9ucztcbiAgICAgICAgdmFyIHJvb3RHcm91cCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgICAgIHJvb3RHcm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBwbSh2aWV3cG9ydC50cmFuc2Zvcm0pKTtcbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKHJvb3RHcm91cCk7XG4gICAgICAgIHRoaXMuc3ZnID0gcm9vdEdyb3VwO1xuICAgICAgICByZXR1cm4gc3ZnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZW5zdXJlQ2xpcEdyb3VwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Vuc3VyZUNsaXBHcm91cCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnQuY2xpcEdyb3VwKSB7XG4gICAgICAgICAgdmFyIGNsaXBHcm91cCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgICAgICAgY2xpcEdyb3VwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xpcC1wYXRoXCIsIHRoaXMuY3VycmVudC5hY3RpdmVDbGlwVXJsKTtcbiAgICAgICAgICB0aGlzLnN2Zy5hcHBlbmRDaGlsZChjbGlwR3JvdXApO1xuICAgICAgICAgIHRoaXMuY3VycmVudC5jbGlwR3JvdXAgPSBjbGlwR3JvdXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50LmNsaXBHcm91cDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2Vuc3VyZVRyYW5zZm9ybUdyb3VwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkge1xuICAgICAgICBpZiAoIXRoaXMudGdycCkge1xuICAgICAgICAgIHRoaXMudGdycCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgICAgICAgdGhpcy50Z3JwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIHBtKHRoaXMudHJhbnNmb3JtTWF0cml4KSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZUNsaXBVcmwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZUNsaXBHcm91cCgpLmFwcGVuZENoaWxkKHRoaXMudGdycCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3ZnLmFwcGVuZENoaWxkKHRoaXMudGdycCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGdycDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU1ZHR3JhcGhpY3M7XG4gIH0oKTtcbn1cblxuLyoqKi8gfSksXG4vKiAxNTMgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuUERGTm9kZVN0cmVhbSA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193X3BkZmpzX3JlcXVpcmVfXygyKSk7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG5cbnZhciBfbmV0d29ya191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTU0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbjtcblxudmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xuXG52YXIgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuXG52YXIgaHR0cHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG5cbnZhciB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuXG52YXIgZmlsZVVyaVJlZ2V4ID0gL15maWxlOlxcL1xcL1xcL1thLXpBLVpdOlxcLy87XG5cbmZ1bmN0aW9uIHBhcnNlVXJsKHNvdXJjZVVybCkge1xuICB2YXIgcGFyc2VkVXJsID0gdXJsLnBhcnNlKHNvdXJjZVVybCk7XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gXCJmaWxlOlwiIHx8IHBhcnNlZFVybC5ob3N0KSB7XG4gICAgcmV0dXJuIHBhcnNlZFVybDtcbiAgfVxuXG4gIGlmICgvXlthLXpdOlsvXFxcXF0vaS50ZXN0KHNvdXJjZVVybCkpIHtcbiAgICByZXR1cm4gdXJsLnBhcnNlKFwiZmlsZTovLy9cIi5jb25jYXQoc291cmNlVXJsKSk7XG4gIH1cblxuICBpZiAoIXBhcnNlZFVybC5ob3N0KSB7XG4gICAgcGFyc2VkVXJsLnByb3RvY29sID0gXCJmaWxlOlwiO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZFVybDtcbn1cblxudmFyIFBERk5vZGVTdHJlYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZOb2RlU3RyZWFtKHNvdXJjZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZOb2RlU3RyZWFtKTtcblxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gcGFyc2VVcmwoc291cmNlLnVybCk7XG4gICAgdGhpcy5pc0h0dHAgPSB0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHRoaXMudXJsLnByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICAgIHRoaXMuaXNGc1VybCA9IHRoaXMudXJsLnByb3RvY29sID09PSBcImZpbGU6XCI7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIHNvdXJjZS5odHRwSGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERk5vZGVTdHJlYW0sIFt7XG4gICAga2V5OiBcIl9wcm9ncmVzc2l2ZURhdGFMZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfdGhpcyRfZnVsbFJlcXVlc3RSZWEsIF90aGlzJF9mdWxsUmVxdWVzdFJlYTI7XG5cbiAgICAgIHJldHVybiAoX3RoaXMkX2Z1bGxSZXF1ZXN0UmVhID0gKF90aGlzJF9mdWxsUmVxdWVzdFJlYTIgPSB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcikgPT09IG51bGwgfHwgX3RoaXMkX2Z1bGxSZXF1ZXN0UmVhMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkX2Z1bGxSZXF1ZXN0UmVhMi5fbG9hZGVkKSAhPT0gbnVsbCAmJiBfdGhpcyRfZnVsbFJlcXVlc3RSZWEgIT09IHZvaWQgMCA/IF90aGlzJF9mdWxsUmVxdWVzdFJlYSA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bGxSZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnVsbFJlYWRlcigpIHtcbiAgICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZOb2RlU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzLmlzRnNVcmwgPyBuZXcgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcih0aGlzKSA6IG5ldyBQREZOb2RlU3RyZWFtRnVsbFJlYWRlcih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmFuZ2VSZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2VSZWFkZXIoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZVJlYWRlciA9IHRoaXMuaXNGc1VybCA/IG5ldyBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKSA6IG5ldyBQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgc3RhcnQsIGVuZCk7XG5cbiAgICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyYW5nZVJlYWRlcik7XG5cbiAgICAgIHJldHVybiByYW5nZVJlYWRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsQWxsUmVxdWVzdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWFkZXJzID0gdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKTtcblxuICAgICAgcmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERk5vZGVTdHJlYW07XG59KCk7XG5cbmV4cG9ydHMuUERGTm9kZVN0cmVhbSA9IFBERk5vZGVTdHJlYW07XG5cbnZhciBCYXNlRnVsbFJlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VGdWxsUmVhZGVyKHN0cmVhbSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlRnVsbFJlYWRlcik7XG5cbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB2YXIgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuXG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZUZ1bGxSZWFkZXIsIFt7XG4gICAga2V5OiBcImhlYWRlcnNSZWFkeVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbGVuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRMZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1JhbmdlU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTdHJlYW1pbmdTdXBwb3J0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlYWQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgY2h1bmssIGJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kb25lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShjaHVuayA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZWFkKCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbDogdGhpcy5fY29udGVudExlbmd0aFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgIHJldHVybiBfcmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJjYW5jZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKHJlYXNvbikge1xuICAgICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Vycm9yKHJlYXNvbikge1xuICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG5cbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFJlYWRhYmxlU3RyZWFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwicmVhZGFibGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgX3RoaXMuX2RvbmUgPSB0cnVlO1xuXG4gICAgICAgIF90aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBfdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwic3RyZWFtaW5nIGlzIGRpc2FibGVkXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlRnVsbFJlYWRlcjtcbn0oKTtcblxudmFyIEJhc2VSYW5nZVJlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VSYW5nZVJlYWRlcihzdHJlYW0pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZVJhbmdlUmVhZGVyKTtcblxuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgIHZhciBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VSYW5nZVJlYWRlciwgW3tcbiAgICBrZXk6IFwiaXNTdHJlYW1pbmdTdXBwb3J0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlYWQyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBjaHVuaywgYnVmZmVyO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZG9uZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoY2h1bmsgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5yZWFkKCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFkMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJjYW5jZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKHJlYXNvbikge1xuICAgICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Vycm9yKHJlYXNvbikge1xuICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG5cbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFJlYWRhYmxlU3RyZWFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICBfdGhpczIuX2RvbmUgPSB0cnVlO1xuXG4gICAgICAgIF90aGlzMi5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgX3RoaXMyLl9lcnJvcihyZWFzb24pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZVJhbmdlUmVhZGVyO1xufSgpO1xuXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0T3B0aW9ucyhwYXJzZWRVcmwsIGhlYWRlcnMpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogcGFyc2VkVXJsLnByb3RvY29sLFxuICAgIGF1dGg6IHBhcnNlZFVybC5hdXRoLFxuICAgIGhvc3Q6IHBhcnNlZFVybC5ob3N0bmFtZSxcbiAgICBwb3J0OiBwYXJzZWRVcmwucG9ydCxcbiAgICBwYXRoOiBwYXJzZWRVcmwucGF0aCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyczogaGVhZGVyc1xuICB9O1xufVxuXG52YXIgUERGTm9kZVN0cmVhbUZ1bGxSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlRnVsbFJlYWRlcikge1xuICBfaW5oZXJpdHMoUERGTm9kZVN0cmVhbUZ1bGxSZWFkZXIsIF9CYXNlRnVsbFJlYWRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQREZOb2RlU3RyZWFtRnVsbFJlYWRlcik7XG5cbiAgZnVuY3Rpb24gUERGTm9kZVN0cmVhbUZ1bGxSZWFkZXIoc3RyZWFtKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZOb2RlU3RyZWFtRnVsbFJlYWRlcik7XG5cbiAgICBfdGhpczMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzdHJlYW0pO1xuXG4gICAgdmFyIGhhbmRsZVJlc3BvbnNlID0gZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oXCJNaXNzaW5nIFBERiBcXFwiXCIuY29uY2F0KF90aGlzMy5fdXJsLCBcIlxcXCIuXCIpKTtcbiAgICAgICAgX3RoaXMzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuXG4gICAgICAgIF90aGlzMy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzMy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuXG4gICAgICBfdGhpczMuX3NldFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlKTtcblxuICAgICAgdmFyIGdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24gZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLl9yZWFkYWJsZVN0cmVhbS5oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICB9O1xuXG4gICAgICB2YXIgX3ZhbGlkYXRlUmFuZ2VSZXF1ZXN0ID0gKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICAgIGdldFJlc3BvbnNlSGVhZGVyOiBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgICAgaXNIdHRwOiBzdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogX3RoaXMzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiBfdGhpczMuX2Rpc2FibGVSYW5nZVxuICAgICAgfSksXG4gICAgICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzID0gX3ZhbGlkYXRlUmFuZ2VSZXF1ZXN0LmFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgICAgICBzdWdnZXN0ZWRMZW5ndGggPSBfdmFsaWRhdGVSYW5nZVJlcXVlc3Quc3VnZ2VzdGVkTGVuZ3RoO1xuXG4gICAgICBfdGhpczMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICBfdGhpczMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgX3RoaXMzLl9jb250ZW50TGVuZ3RoO1xuICAgICAgX3RoaXMzLl9maWxlbmFtZSA9ICgwLCBfbmV0d29ya191dGlscy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKShnZXRSZXNwb25zZUhlYWRlcik7XG4gICAgfTtcblxuICAgIF90aGlzMy5fcmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAoX3RoaXMzLl91cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIikge1xuICAgICAgX3RoaXMzLl9yZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKF90aGlzMy5fdXJsLCBzdHJlYW0uaHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzMy5fcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnMoX3RoaXMzLl91cmwsIHN0cmVhbS5odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBfdGhpczMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBfdGhpczMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuXG4gICAgICBfdGhpczMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgIH0pO1xuXG4gICAgX3RoaXMzLl9yZXF1ZXN0LmVuZCgpO1xuXG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHJldHVybiBQREZOb2RlU3RyZWFtRnVsbFJlYWRlcjtcbn0oQmFzZUZ1bGxSZWFkZXIpO1xuXG52YXIgUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVJhbmdlUmVhZGVyKSB7XG4gIF9pbmhlcml0cyhQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIsIF9CYXNlUmFuZ2VSZWFkZXIpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKFBERk5vZGVTdHJlYW1SYW5nZVJlYWRlcik7XG5cbiAgZnVuY3Rpb24gUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyKHN0cmVhbSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBfdGhpczQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyKTtcblxuICAgIF90aGlzNCA9IF9zdXBlcjIuY2FsbCh0aGlzLCBzdHJlYW0pO1xuICAgIF90aGlzNC5faHR0cEhlYWRlcnMgPSB7fTtcblxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHN0cmVhbS5odHRwSGVhZGVycykge1xuICAgICAgdmFyIHZhbHVlID0gc3RyZWFtLmh0dHBIZWFkZXJzW3Byb3BlcnR5XTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgX3RoaXM0Ll9odHRwSGVhZGVyc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBfdGhpczQuX2h0dHBIZWFkZXJzLlJhbmdlID0gXCJieXRlcz1cIi5jb25jYXQoc3RhcnQsIFwiLVwiKS5jb25jYXQoZW5kIC0gMSk7XG5cbiAgICB2YXIgaGFuZGxlUmVzcG9uc2UgPSBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihcIk1pc3NpbmcgUERGIFxcXCJcIi5jb25jYXQoX3RoaXM0Ll91cmwsIFwiXFxcIi5cIikpO1xuICAgICAgICBfdGhpczQuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXM0Ll9zZXRSZWFkYWJsZVN0cmVhbShyZXNwb25zZSk7XG4gICAgfTtcblxuICAgIF90aGlzNC5fcmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAoX3RoaXM0Ll91cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIikge1xuICAgICAgX3RoaXM0Ll9yZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKF90aGlzNC5fdXJsLCBfdGhpczQuX2h0dHBIZWFkZXJzKSwgaGFuZGxlUmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpczQuX3JlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKF90aGlzNC5fdXJsLCBfdGhpczQuX2h0dHBIZWFkZXJzKSwgaGFuZGxlUmVzcG9uc2UpO1xuICAgIH1cblxuICAgIF90aGlzNC5fcmVxdWVzdC5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIF90aGlzNC5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgfSk7XG5cbiAgICBfdGhpczQuX3JlcXVlc3QuZW5kKCk7XG5cbiAgICByZXR1cm4gX3RoaXM0O1xuICB9XG5cbiAgcmV0dXJuIFBERk5vZGVTdHJlYW1SYW5nZVJlYWRlcjtcbn0oQmFzZVJhbmdlUmVhZGVyKTtcblxudmFyIFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlRnVsbFJlYWRlcjIpIHtcbiAgX2luaGVyaXRzKFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIsIF9CYXNlRnVsbFJlYWRlcjIpO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIpO1xuXG4gIGZ1bmN0aW9uIFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIoc3RyZWFtKSB7XG4gICAgdmFyIF90aGlzNTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyKTtcblxuICAgIF90aGlzNSA9IF9zdXBlcjMuY2FsbCh0aGlzLCBzdHJlYW0pO1xuICAgIHZhciBwYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KF90aGlzNS5fdXJsLnBhdGgpO1xuXG4gICAgaWYgKGZpbGVVcmlSZWdleC50ZXN0KF90aGlzNS5fdXJsLmhyZWYpKSB7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgfVxuXG4gICAgZnMubHN0YXQocGF0aCwgZnVuY3Rpb24gKGVycm9yLCBzdGF0KSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKFwiTWlzc2luZyBQREYgXFxcIlwiLmNvbmNhdChwYXRoLCBcIlxcXCIuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNS5fc3RvcmVkRXJyb3IgPSBlcnJvcjtcblxuICAgICAgICBfdGhpczUuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpczUuX2NvbnRlbnRMZW5ndGggPSBzdGF0LnNpemU7XG5cbiAgICAgIF90aGlzNS5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoKSk7XG5cbiAgICAgIF90aGlzNS5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpczU7XG4gIH1cblxuICByZXR1cm4gUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcjtcbn0oQmFzZUZ1bGxSZWFkZXIpO1xuXG52YXIgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlUmFuZ2VSZWFkZXIyKSB7XG4gIF9pbmhlcml0cyhQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlciwgX0Jhc2VSYW5nZVJlYWRlcjIpO1xuXG4gIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyKTtcblxuICBmdW5jdGlvbiBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgX3RoaXM2O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyKTtcblxuICAgIF90aGlzNiA9IF9zdXBlcjQuY2FsbCh0aGlzLCBzdHJlYW0pO1xuICAgIHZhciBwYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KF90aGlzNi5fdXJsLnBhdGgpO1xuXG4gICAgaWYgKGZpbGVVcmlSZWdleC50ZXN0KF90aGlzNi5fdXJsLmhyZWYpKSB7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgfVxuXG4gICAgX3RoaXM2Ll9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgsIHtcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kIC0gMVxuICAgIH0pKTtcblxuICAgIHJldHVybiBfdGhpczY7XG4gIH1cblxuICByZXR1cm4gUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXI7XG59KEJhc2VSYW5nZVJlYWRlcik7XG5cbi8qKiovIH0pLFxuLyogMTU0ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yID0gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcjtcbmV4cG9ydHMuZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlciA9IGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXI7XG5leHBvcnRzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzID0gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXM7XG5leHBvcnRzLnZhbGlkYXRlUmVzcG9uc2VTdGF0dXMgPSB2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2NvbnRlbnRfZGlzcG9zaXRpb24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1NSk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKF9yZWYpIHtcbiAgdmFyIGdldFJlc3BvbnNlSGVhZGVyID0gX3JlZi5nZXRSZXNwb25zZUhlYWRlcixcbiAgICAgIGlzSHR0cCA9IF9yZWYuaXNIdHRwLFxuICAgICAgcmFuZ2VDaHVua1NpemUgPSBfcmVmLnJhbmdlQ2h1bmtTaXplLFxuICAgICAgZGlzYWJsZVJhbmdlID0gX3JlZi5kaXNhYmxlUmFuZ2U7XG4gICgwLCBfdXRpbC5hc3NlcnQpKHJhbmdlQ2h1bmtTaXplID4gMCwgXCJSYW5nZSBjaHVuayBzaXplIG11c3QgYmUgbGFyZ2VyIHRoYW4gemVyb1wiKTtcbiAgdmFyIHJldHVyblZhbHVlcyA9IHtcbiAgICBhbGxvd1JhbmdlUmVxdWVzdHM6IGZhbHNlLFxuICAgIHN1Z2dlc3RlZExlbmd0aDogdW5kZWZpbmVkXG4gIH07XG4gIHZhciBsZW5ndGggPSBwYXJzZUludChnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtTGVuZ3RoXCIpLCAxMCk7XG5cbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG5cbiAgcmV0dXJuVmFsdWVzLnN1Z2dlc3RlZExlbmd0aCA9IGxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDw9IDIgKiByYW5nZUNodW5rU2l6ZSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cblxuICBpZiAoZGlzYWJsZVJhbmdlIHx8ICFpc0h0dHApIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG5cbiAgaWYgKGdldFJlc3BvbnNlSGVhZGVyKFwiQWNjZXB0LVJhbmdlc1wiKSAhPT0gXCJieXRlc1wiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuXG4gIHZhciBjb250ZW50RW5jb2RpbmcgPSBnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRW5jb2RpbmdcIikgfHwgXCJpZGVudGl0eVwiO1xuXG4gIGlmIChjb250ZW50RW5jb2RpbmcgIT09IFwiaWRlbnRpdHlcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cblxuICByZXR1cm5WYWx1ZXMuYWxsb3dSYW5nZVJlcXVlc3RzID0gdHJ1ZTtcbiAgcmV0dXJuIHJldHVyblZhbHVlcztcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihnZXRSZXNwb25zZUhlYWRlcikge1xuICB2YXIgY29udGVudERpc3Bvc2l0aW9uID0gZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIpO1xuXG4gIGlmIChjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgICB2YXIgZmlsZW5hbWUgPSAoMCwgX2NvbnRlbnRfZGlzcG9zaXRpb24uZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKShjb250ZW50RGlzcG9zaXRpb24pO1xuXG4gICAgaWYgKGZpbGVuYW1lLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmlsZW5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQoZmlsZW5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXgpIHt9XG4gICAgfVxuXG4gICAgaWYgKC9cXC5wZGYkL2kudGVzdChmaWxlbmFtZSkpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcihzdGF0dXMsIHVybCkge1xuICBpZiAoc3RhdHVzID09PSA0MDQgfHwgc3RhdHVzID09PSAwICYmIHVybC5zdGFydHNXaXRoKFwiZmlsZTpcIikpIHtcbiAgICByZXR1cm4gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oJ01pc3NpbmcgUERGIFwiJyArIHVybCArICdcIi4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKFwiVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2UgKFwiICsgc3RhdHVzICsgJykgd2hpbGUgcmV0cmlldmluZyBQREYgXCInICsgdXJsICsgJ1wiLicsIHN0YXR1cyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2VTdGF0dXMoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNjtcbn1cblxuLyoqKi8gfSksXG4vKiAxNTUgKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlciA9IGdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcjtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICB2YXIgbmVlZHNFbmNvZGluZ0ZpeHVwID0gdHJ1ZTtcbiAgdmFyIHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG5cbiAgaWYgKHRtcCkge1xuICAgIHRtcCA9IHRtcFsxXTtcbiAgICB2YXIgZmlsZW5hbWUgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuICAgIGZpbGVuYW1lID0gdW5lc2NhcGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjNTk4N2RlY29kZShmaWxlbmFtZSk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cblxuICB0bXAgPSByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uKTtcblxuICBpZiAodG1wKSB7XG4gICAgdmFyIF9maWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUodG1wKTtcblxuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKF9maWxlbmFtZSk7XG4gIH1cblxuICB0bXAgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcIiwgXCJpXCIpLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uKTtcblxuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuXG4gICAgdmFyIF9maWxlbmFtZTIgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuXG4gICAgX2ZpbGVuYW1lMiA9IHJmYzIwNDdkZWNvZGUoX2ZpbGVuYW1lMik7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoX2ZpbGVuYW1lMik7XG4gIH1cblxuICBmdW5jdGlvbiB0b1BhcmFtUmVnRXhwKGF0dHJpYnV0ZVBhdHRlcm4sIGZsYWdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpefDspXFxcXHMqXCIgKyBhdHRyaWJ1dGVQYXR0ZXJuICsgXCJcXFxccyo9XFxcXHMqXCIgKyBcIihcIiArICdbXlwiO1xcXFxzXVteO1xcXFxzXSonICsgXCJ8XCIgKyAnXCIoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcXCI/KStcIj8nICsgXCIpXCIsIGZsYWdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRkZWNvZGUoZW5jb2RpbmcsIHZhbHVlKSB7XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICBpZiAoIS9eW1xceDAwLVxceEZGXSskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBieXRlcyA9IEFycmF5LmZyb20odmFsdWUsIGZ1bmN0aW9uIChjaCkge1xuICAgICAgICAgIHJldHVybiBjaC5jaGFyQ29kZUF0KDApICYgMHhmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhbHVlID0gZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICAgICAgbmVlZHNFbmNvZGluZ0ZpeHVwID0gZmFsc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICgvXnV0Zi0/OCQvaS50ZXN0KGVuY29kaW5nKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUodmFsdWUpKTtcbiAgICAgICAgICAgIG5lZWRzRW5jb2RpbmdGaXh1cCA9IGZhbHNlO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpeHVwRW5jb2RpbmcodmFsdWUpIHtcbiAgICBpZiAobmVlZHNFbmNvZGluZ0ZpeHVwICYmIC9bXFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwidXRmLThcIiwgdmFsdWUpO1xuXG4gICAgICBpZiAobmVlZHNFbmNvZGluZ0ZpeHVwKSB7XG4gICAgICAgIHZhbHVlID0gdGV4dGRlY29kZShcImlzby04ODU5LTFcIiwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb25TdHIpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBtYXRjaDtcbiAgICB2YXIgaXRlciA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqKCg/ITBcXFxcZClcXFxcZCspKFxcXFwqPylcIiwgXCJpZ1wiKTtcblxuICAgIHdoaWxlICgobWF0Y2ggPSBpdGVyLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uU3RyKSkgIT09IG51bGwpIHtcbiAgICAgIHZhciBfbWF0Y2ggPSBtYXRjaCxcbiAgICAgICAgICBfbWF0Y2gyID0gX3NsaWNlZFRvQXJyYXkoX21hdGNoLCA0KSxcbiAgICAgICAgICBuID0gX21hdGNoMlsxXSxcbiAgICAgICAgICBxdW90ID0gX21hdGNoMlsyXSxcbiAgICAgICAgICBwYXJ0ID0gX21hdGNoMlszXTtcblxuICAgICAgbiA9IHBhcnNlSW50KG4sIDEwKTtcblxuICAgICAgaWYgKG4gaW4gbWF0Y2hlcykge1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoZXNbbl0gPSBbcXVvdCwgcGFydF07XG4gICAgfVxuXG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICBmb3IgKHZhciBfbjIgPSAwOyBfbjIgPCBtYXRjaGVzLmxlbmd0aDsgKytfbjIpIHtcbiAgICAgIGlmICghKF9uMiBpbiBtYXRjaGVzKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIF9tYXRjaGVzJF9uID0gX3NsaWNlZFRvQXJyYXkobWF0Y2hlc1tfbjJdLCAyKSxcbiAgICAgICAgICBfcXVvdCA9IF9tYXRjaGVzJF9uWzBdLFxuICAgICAgICAgIF9wYXJ0ID0gX21hdGNoZXMkX25bMV07XG5cbiAgICAgIF9wYXJ0ID0gcmZjMjYxNnVucXVvdGUoX3BhcnQpO1xuXG4gICAgICBpZiAoX3F1b3QpIHtcbiAgICAgICAgX3BhcnQgPSB1bmVzY2FwZShfcGFydCk7XG5cbiAgICAgICAgaWYgKF9uMiA9PT0gMCkge1xuICAgICAgICAgIF9wYXJ0ID0gcmZjNTk4N2RlY29kZShfcGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGFydHMucHVzaChfcGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gIH1cblxuICBmdW5jdGlvbiByZmMyNjE2dW5xdW90ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgICB2YXIgcGFydHMgPSB2YWx1ZS5zbGljZSgxKS5zcGxpdCgnXFxcXFwiJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHF1b3RpbmRleCA9IHBhcnRzW2ldLmluZGV4T2YoJ1wiJyk7XG5cbiAgICAgICAgaWYgKHF1b3RpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnNsaWNlKDAsIHF1b3RpbmRleCk7XG4gICAgICAgICAgcGFydHMubGVuZ3RoID0gaSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnJlcGxhY2UoL1xcXFwoLikvZywgXCIkMVwiKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCdcIicpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJmYzU5ODdkZWNvZGUoZXh0dmFsdWUpIHtcbiAgICB2YXIgZW5jb2RpbmdlbmQgPSBleHR2YWx1ZS5pbmRleE9mKFwiJ1wiKTtcblxuICAgIGlmIChlbmNvZGluZ2VuZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBleHR2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgZW5jb2RpbmcgPSBleHR2YWx1ZS5zbGljZSgwLCBlbmNvZGluZ2VuZCk7XG4gICAgdmFyIGxhbmd2YWx1ZSA9IGV4dHZhbHVlLnNsaWNlKGVuY29kaW5nZW5kICsgMSk7XG4gICAgdmFyIHZhbHVlID0gbGFuZ3ZhbHVlLnJlcGxhY2UoL15bXiddKicvLCBcIlwiKTtcbiAgICByZXR1cm4gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmZjMjA0N2RlY29kZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUuc3RhcnRzV2l0aChcIj0/XCIpIHx8IC9bXFx4MDAtXFx4MTlcXHg4MC1cXHhmZl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLz1cXD8oW1xcdy1dKilcXD8oW1FxQmJdKVxcPygoPzpbXj9dfFxcPyg/IT0pKSopXFw/PS9nLCBmdW5jdGlvbiAobWF0Y2hlcywgY2hhcnNldCwgZW5jb2RpbmcsIHRleHQpIHtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJxXCIgfHwgZW5jb2RpbmcgPT09IFwiUVwiKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL18vZywgXCIgXCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC89KFswLTlhLWZBLUZdezJ9KS9nLCBmdW5jdGlvbiAobWF0Y2gsIGhleCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB0ZXh0ID0gYXRvYih0ZXh0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFwiXCI7XG59XG5cbi8qKiovIH0pLFxuLyogMTU2ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5QREZOZXR3b3JrU3RyZWFtID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dfcGRmanNfcmVxdWlyZV9fKDIpKTtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcblxudmFyIF9uZXR3b3JrX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG47XG52YXIgT0tfUkVTUE9OU0UgPSAyMDA7XG52YXIgUEFSVElBTF9DT05URU5UX1JFU1BPTlNFID0gMjA2O1xuXG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcih4aHIpIHtcbiAgdmFyIGRhdGEgPSB4aHIucmVzcG9uc2U7XG5cbiAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYXJyYXkgPSAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykoZGF0YSk7XG4gIHJldHVybiBhcnJheS5idWZmZXI7XG59XG5cbnZhciBOZXR3b3JrTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5ldHdvcmtNYW5hZ2VyKHVybCwgYXJncykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOZXR3b3JrTWFuYWdlcik7XG5cbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3QodXJsKTtcbiAgICB0aGlzLmh0dHBIZWFkZXJzID0gdGhpcy5pc0h0dHAgJiYgYXJncy5odHRwSGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGFyZ3Mud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuXG4gICAgdGhpcy5nZXRYaHIgPSBhcmdzLmdldFhociB8fCBmdW5jdGlvbiBOZXR3b3JrTWFuYWdlcl9nZXRYaHIoKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfTtcblxuICAgIHRoaXMuY3VyclhocklkID0gMDtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTmV0d29ya01hbmFnZXIsIFt7XG4gICAga2V5OiBcInJlcXVlc3RSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1ZXN0UmFuZ2UoYmVnaW4sIGVuZCwgbGlzdGVuZXJzKSB7XG4gICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgYmVnaW46IGJlZ2luLFxuICAgICAgICBlbmQ6IGVuZFxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgYXJnc1twcm9wXSA9IGxpc3RlbmVyc1twcm9wXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVxdWVzdEZ1bGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWVzdEZ1bGwobGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGxpc3RlbmVycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWVzdChhcmdzKSB7XG4gICAgICB2YXIgeGhyID0gdGhpcy5nZXRYaHIoKTtcbiAgICAgIHZhciB4aHJJZCA9IHRoaXMuY3VyclhocklkKys7XG4gICAgICB2YXIgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0gPSB7XG4gICAgICAgIHhocjogeGhyXG4gICAgICB9O1xuICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgdGhpcy51cmwpO1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuXG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzLmh0dHBIZWFkZXJzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaHR0cEhlYWRlcnNbcHJvcGVydHldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzSHR0cCAmJiBcImJlZ2luXCIgaW4gYXJncyAmJiBcImVuZFwiIGluIGFyZ3MpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBcImJ5dGVzPVwiLmNvbmNhdChhcmdzLmJlZ2luLCBcIi1cIikuY29uY2F0KGFyZ3MuZW5kIC0gMSkpO1xuICAgICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gT0tfUkVTUE9OU0U7XG4gICAgICB9XG5cbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG5cbiAgICAgIGlmIChhcmdzLm9uRXJyb3IpIHtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgYXJncy5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcywgeGhySWQpO1xuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLm9uUHJvZ3Jlc3MuYmluZCh0aGlzLCB4aHJJZCk7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCA9IGFyZ3Mub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUgPSBhcmdzLm9uRG9uZTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IgPSBhcmdzLm9uRXJyb3I7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzID0gYXJncy5vblByb2dyZXNzO1xuICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICByZXR1cm4geGhySWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Qcm9ncmVzcyh4aHJJZCwgZXZ0KSB7XG4gICAgICB2YXIgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG5cbiAgICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcykge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzKGV2dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uU3RhdGVDaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TdGF0ZUNoYW5nZSh4aHJJZCwgZXZ0KSB7XG4gICAgICB2YXIgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG5cbiAgICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gcGVuZGluZ1JlcXVlc3QueGhyO1xuXG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPj0gMiAmJiBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCkge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCgpO1xuICAgICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghKHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG5cbiAgICAgIGlmICh4aHIuc3RhdHVzID09PSAwICYmIHRoaXMuaXNIdHRwKSB7XG4gICAgICAgIGlmIChwZW5kaW5nUmVxdWVzdC5vbkVycm9yKSB7XG4gICAgICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHhoclN0YXR1cyA9IHhoci5zdGF0dXMgfHwgT0tfUkVTUE9OU0U7XG4gICAgICB2YXIgb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCA9IHhoclN0YXR1cyA9PT0gT0tfUkVTUE9OU0UgJiYgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcblxuICAgICAgaWYgKCFva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ICYmIHhoclN0YXR1cyAhPT0gcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMpIHtcbiAgICAgICAgaWYgKHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IpIHtcbiAgICAgICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2h1bmsgPSBnZXRBcnJheUJ1ZmZlcih4aHIpO1xuXG4gICAgICBpZiAoeGhyU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UpIHtcbiAgICAgICAgdmFyIHJhbmdlSGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1SYW5nZVwiKTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAvYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKS8uZXhlYyhyYW5nZUhlYWRlcik7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgICAgYmVnaW46IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKSxcbiAgICAgICAgICBjaHVuazogY2h1bmtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgICAgYmVnaW46IDAsXG4gICAgICAgICAgY2h1bms6IGNodW5rXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwZW5kaW5nUmVxdWVzdC5vbkVycm9yKSB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJlcXVlc3RYaHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVxdWVzdFhocih4aHJJZCkge1xuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUGVuZGluZ1JlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNQZW5kaW5nUmVxdWVzdCh4aHJJZCkge1xuICAgICAgcmV0dXJuIHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhYm9ydFJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnRSZXF1ZXN0KHhocklkKSB7XG4gICAgICB2YXIgeGhyID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgICB4aHIuYWJvcnQoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTmV0d29ya01hbmFnZXI7XG59KCk7XG5cbnZhciBQREZOZXR3b3JrU3RyZWFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGTmV0d29ya1N0cmVhbShzb3VyY2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGTmV0d29ya1N0cmVhbSk7XG5cbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fbWFuYWdlciA9IG5ldyBOZXR3b3JrTWFuYWdlcihzb3VyY2UudXJsLCB7XG4gICAgICBodHRwSGVhZGVyczogc291cmNlLmh0dHBIZWFkZXJzLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBzb3VyY2Uud2l0aENyZWRlbnRpYWxzXG4gICAgfSk7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZOZXR3b3JrU3RyZWFtLCBbe1xuICAgIGtleTogXCJfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkKHJlYWRlcikge1xuICAgICAgdmFyIGkgPSB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcblxuICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnVsbFJlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGdWxsUmVhZGVyKCkge1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIodGhpcy5fbWFuYWdlciwgdGhpcy5fc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmFuZ2VSZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIGJlZ2luLCBlbmQpO1xuICAgICAgcmVhZGVyLm9uQ2xvc2VkID0gdGhpcy5fb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQuYmluZCh0aGlzKTtcblxuICAgICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJlYWRlcik7XG5cbiAgICAgIHJldHVybiByZWFkZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbEFsbFJlcXVlc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVhZGVycyA9IHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCk7XG5cbiAgICAgIHJlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVhZGVyKSB7XG4gICAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZOZXR3b3JrU3RyZWFtO1xufSgpO1xuXG5leHBvcnRzLlBERk5ldHdvcmtTdHJlYW0gPSBQREZOZXR3b3JrU3RyZWFtO1xuXG52YXIgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyKG1hbmFnZXIsIHNvdXJjZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIpO1xuXG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdmFyIGFyZ3MgPSB7XG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuX3VybCA9IHNvdXJjZS51cmw7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdEZ1bGwoYXJncyk7XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuXG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciwgW3tcbiAgICBrZXk6IFwiX29uSGVhZGVyc1JlY2VpdmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkhlYWRlcnNSZWNlaXZlZCgpIHtcbiAgICAgIHZhciBmdWxsUmVxdWVzdFhocklkID0gdGhpcy5fZnVsbFJlcXVlc3RJZDtcblxuICAgICAgdmFyIGZ1bGxSZXF1ZXN0WGhyID0gdGhpcy5fbWFuYWdlci5nZXRSZXF1ZXN0WGhyKGZ1bGxSZXF1ZXN0WGhySWQpO1xuXG4gICAgICB2YXIgZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbiBnZXRSZXNwb25zZUhlYWRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdWxsUmVxdWVzdFhoci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBfdmFsaWRhdGVSYW5nZVJlcXVlc3QgPSAoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMpKHtcbiAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGdldFJlc3BvbnNlSGVhZGVyLFxuICAgICAgICBpc0h0dHA6IHRoaXMuX21hbmFnZXIuaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgICB9KSxcbiAgICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMgPSBfdmFsaWRhdGVSYW5nZVJlcXVlc3QuYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgICAgIHN1Z2dlc3RlZExlbmd0aCA9IF92YWxpZGF0ZVJhbmdlUmVxdWVzdC5zdWdnZXN0ZWRMZW5ndGg7XG5cbiAgICAgIGlmIChhbGxvd1JhbmdlUmVxdWVzdHMpIHtcbiAgICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsIF9uZXR3b3JrX3V0aWxzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIpKGdldFJlc3BvbnNlSGVhZGVyKTtcblxuICAgICAgaWYgKHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QoZnVsbFJlcXVlc3RYaHJJZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25Eb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvbmUoYXJncykge1xuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgICB2YWx1ZTogYXJncy5jaHVuayxcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVkQ2h1bmtzLnB1c2goYXJncy5jaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3RDYXBhYmlsaXR5KSB7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25FcnJvcihzdGF0dXMpIHtcbiAgICAgIHZhciB1cmwgPSB0aGlzLl91cmw7XG4gICAgICB2YXIgZXhjZXB0aW9uID0gKDAsIF9uZXR3b3JrX3V0aWxzLmNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IpKHN0YXR1cywgdXJsKTtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXhjZXB0aW9uO1xuXG4gICAgICB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnJlamVjdChleGNlcHRpb24pO1xuXG4gICAgICB0aGlzLl9yZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0Q2FwYWJpbGl0eSkge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgICAgdGhpcy5fY2FjaGVkQ2h1bmtzID0gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblByb2dyZXNzKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5vblByb2dyZXNzKHtcbiAgICAgICAgICBsb2FkZWQ6IGRhdGEubG9hZGVkLFxuICAgICAgICAgIHRvdGFsOiBkYXRhLmxlbmd0aENvbXB1dGFibGUgPyBkYXRhLnRvdGFsIDogdGhpcy5fY29udGVudExlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsZW5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNSYW5nZVN1cHBvcnRlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU3RyZWFtaW5nU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRMZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZWFkZXJzUmVhZHlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWFkID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIGNodW5rLCByZXF1ZXN0Q2FwYWJpbGl0eTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2h1bmsgPSB0aGlzLl9jYWNoZWRDaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZG9uZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgIHJldHVybiBfcmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJjYW5jZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKHJlYXNvbikge1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3RDYXBhYmlsaXR5KSB7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5fbWFuYWdlci5pc1BlbmRpbmdSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpKSB7XG4gICAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlcjtcbn0oKTtcblxudmFyIFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyKG1hbmFnZXIsIGJlZ2luLCBlbmQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlcik7XG5cbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB2YXIgYXJncyA9IHtcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuX3JlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdFJhbmdlKGJlZ2luLCBlbmQsIGFyZ3MpO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMub25DbG9zZWQgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIsIFt7XG4gICAga2V5OiBcIl9jbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xvc2UoKSB7XG4gICAgICBpZiAodGhpcy5vbkNsb3NlZCkge1xuICAgICAgICB0aGlzLm9uQ2xvc2VkKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25Eb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvbmUoZGF0YSkge1xuICAgICAgdmFyIGNodW5rID0gZGF0YS5jaHVuaztcblxuICAgICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcblxuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fcmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdENhcGFiaWxpdHkpIHtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG5cbiAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblByb2dyZXNzKGV2dCkge1xuICAgICAgaWYgKCF0aGlzLmlzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMub25Qcm9ncmVzcykge1xuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTdHJlYW1pbmdTdXBwb3J0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlYWQyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBjaHVuaywgcmVxdWVzdENhcGFiaWxpdHk7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX3F1ZXVlZENodW5rICE9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kb25lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgIHJldHVybiBfcmVhZDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlYWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9yZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0Q2FwYWJpbGl0eSkge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpKSB7XG4gICAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXI7XG59KCk7XG5cbi8qKiovIH0pLFxuLyogMTU3ICovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5QREZGZXRjaFN0cmVhbSA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193X3BkZmpzX3JlcXVpcmVfXygyKSk7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG5cbnZhciBfbmV0d29ya191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTU0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuO1xuXG5mdW5jdGlvbiBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgd2l0aENyZWRlbnRpYWxzLCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyczogaGVhZGVycyxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgY3JlZGVudGlhbHM6IHdpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJzYW1lLW9yaWdpblwiLFxuICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnMoaHR0cEhlYWRlcnMpIHtcbiAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuXG4gIGZvciAodmFyIHByb3BlcnR5IGluIGh0dHBIZWFkZXJzKSB7XG4gICAgdmFyIHZhbHVlID0gaHR0cEhlYWRlcnNbcHJvcGVydHldO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaGVhZGVycy5hcHBlbmQocHJvcGVydHksIHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG52YXIgUERGRmV0Y2hTdHJlYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZGZXRjaFN0cmVhbShzb3VyY2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGRmV0Y2hTdHJlYW0pO1xuXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHNvdXJjZS51cmwpO1xuICAgIHRoaXMuaHR0cEhlYWRlcnMgPSB0aGlzLmlzSHR0cCAmJiBzb3VyY2UuaHR0cEhlYWRlcnMgfHwge307XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZGZXRjaFN0cmVhbSwgW3tcbiAgICBrZXk6IFwiX3Byb2dyZXNzaXZlRGF0YUxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF90aGlzJF9mdWxsUmVxdWVzdFJlYSwgX3RoaXMkX2Z1bGxSZXF1ZXN0UmVhMjtcblxuICAgICAgcmV0dXJuIChfdGhpcyRfZnVsbFJlcXVlc3RSZWEgPSAoX3RoaXMkX2Z1bGxSZXF1ZXN0UmVhMiA9IHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSA9PT0gbnVsbCB8fCBfdGhpcyRfZnVsbFJlcXVlc3RSZWEyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfZnVsbFJlcXVlc3RSZWEyLl9sb2FkZWQpICE9PSBudWxsICYmIF90aGlzJF9mdWxsUmVxdWVzdFJlYSAhPT0gdm9pZCAwID8gX3RoaXMkX2Z1bGxSZXF1ZXN0UmVhIDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnVsbFJlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGdWxsUmVhZGVyKCkge1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkZldGNoU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SZWFkZXIodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJhbmdlUmVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgYmVnaW4sIGVuZCk7XG5cbiAgICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuXG4gICAgICByZXR1cm4gcmVhZGVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5jZWxBbGxSZXF1ZXN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICAgIGlmICh0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcikge1xuICAgICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlYWRlcnMgPSB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApO1xuXG4gICAgICByZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlYWRlcikge1xuICAgICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGRmV0Y2hTdHJlYW07XG59KCk7XG5cbmV4cG9ydHMuUERGRmV0Y2hTdHJlYW0gPSBQREZGZXRjaFN0cmVhbTtcblxudmFyIFBERkZldGNoU3RyZWFtUmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGRmV0Y2hTdHJlYW1SZWFkZXIoc3RyZWFtKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZGZXRjaFN0cmVhbVJlYWRlcik7XG5cbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB2YXIgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG5cbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5faGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5fc3RyZWFtLmh0dHBIZWFkZXJzKTtcbiAgICB2YXIgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyh0aGlzLl9oZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAoISgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKShyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXG4gICAgICBfdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuXG4gICAgICB2YXIgZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbiBnZXRSZXNwb25zZUhlYWRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5oZWFkZXJzLmdldChuYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBfdmFsaWRhdGVSYW5nZVJlcXVlc3QgPSAoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMpKHtcbiAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGdldFJlc3BvbnNlSGVhZGVyLFxuICAgICAgICBpc0h0dHA6IF90aGlzLl9zdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogX3RoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2U6IF90aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pLFxuICAgICAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyA9IF92YWxpZGF0ZVJhbmdlUmVxdWVzdC5hbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgICAgc3VnZ2VzdGVkTGVuZ3RoID0gX3ZhbGlkYXRlUmFuZ2VSZXF1ZXN0LnN1Z2dlc3RlZExlbmd0aDtcblxuICAgICAgX3RoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICBfdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCBfdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIF90aGlzLl9maWxlbmFtZSA9ICgwLCBfbmV0d29ya191dGlscy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKShnZXRSZXNwb25zZUhlYWRlcik7XG5cbiAgICAgIGlmICghX3RoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIF90aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIF90aGlzLmNhbmNlbChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJTdHJlYW1pbmcgaXMgZGlzYWJsZWQuXCIpKTtcbiAgICAgIH1cbiAgICB9KVtcImNhdGNoXCJdKHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZGZXRjaFN0cmVhbVJlYWRlciwgW3tcbiAgICBrZXk6IFwiaGVhZGVyc1JlYWR5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsZW5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGVudExlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUmFuZ2VTdXBwb3J0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1N0cmVhbWluZ1N1cHBvcnRlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVhZCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBfeWllbGQkdGhpcyRfcmVhZGVyJHIsIHZhbHVlLCBkb25lLCBidWZmZXI7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRlci5yZWFkKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIF95aWVsZCR0aGlzJF9yZWFkZXIkciA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfeWllbGQkdGhpcyRfcmVhZGVyJHIudmFsdWU7XG4gICAgICAgICAgICAgICAgZG9uZSA9IF95aWVsZCR0aGlzJF9yZWFkZXIkci5kb25lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgZG9uZTogZG9uZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbDogdGhpcy5fY29udGVudExlbmd0aFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgIHJldHVybiBfcmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJjYW5jZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKHJlYXNvbikge1xuICAgICAgaWYgKHRoaXMuX3JlYWRlcikge1xuICAgICAgICB0aGlzLl9yZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9hYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERkZldGNoU3RyZWFtUmVhZGVyO1xufSgpO1xuXG52YXIgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIoc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlcik7XG5cbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHZhciBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHNvdXJjZS53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG5cbiAgICBpZiAodHlwZW9mIEFib3J0Q29udHJvbGxlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIH1cblxuICAgIHRoaXMuX2hlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuX3N0cmVhbS5odHRwSGVhZGVycyk7XG5cbiAgICB0aGlzLl9oZWFkZXJzLmFwcGVuZChcIlJhbmdlXCIsIFwiYnl0ZXM9XCIuY29uY2F0KGJlZ2luLCBcIi1cIikuY29uY2F0KGVuZCAtIDEpKTtcblxuICAgIHZhciB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKHRoaXMuX2hlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmVzcG9uc2VTdGF0dXMpKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9uZXR3b3JrX3V0aWxzLmNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IpKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMyLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG5cbiAgICAgIF90aGlzMi5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmICgocmVhc29uID09PSBudWxsIHx8IHJlYXNvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVhc29uLm5hbWUpID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRocm93IHJlYXNvbjtcbiAgICB9KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIsIFt7XG4gICAga2V5OiBcImlzU3RyZWFtaW5nU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWFkMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgX3lpZWxkJHRoaXMkX3JlYWRlciRyMiwgdmFsdWUsIGRvbmUsIGJ1ZmZlcjtcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZGVyLnJlYWQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgX3lpZWxkJHRoaXMkX3JlYWRlciRyMiA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgIHZhbHVlID0gX3lpZWxkJHRoaXMkX3JlYWRlciRyMi52YWx1ZTtcbiAgICAgICAgICAgICAgICBkb25lID0gX3lpZWxkJHRoaXMkX3JlYWRlciRyMi5kb25lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICBkb25lOiBkb25lXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHZhbHVlKS5idWZmZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICByZXR1cm4gX3JlYWQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWFkO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwocmVhc29uKSB7XG4gICAgICBpZiAodGhpcy5fcmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX3JlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2Fib3J0Q29udHJvbGxlcikge1xuICAgICAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlcjtcbn0oKTtcblxuLyoqKi8gfSlcbi8qKioqKiovIFx0XSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd19wZGZqc19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRfX3dfcGRmanNfcmVxdWlyZV9fLm5tZCA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdFx0bW9kdWxlLnBhdGhzID0gW107XG4vKioqKioqLyBcdFx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gbW9kdWxlO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBtb2R1bGUgZXhwb3J0cyBtdXN0IGJlIHJldHVybmVkIGZyb20gcnVudGltZSBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193X3BkZmpzX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pKClcbjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGRmLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@adsk/pdfjs-dist/legacy/build/pdf.js\n");

/***/ }),

/***/ "./extensions/PDF/PDFFontExtractor.js":
/*!********************************************!*\
  !*** ./extensions/PDF/PDFFontExtractor.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cssFontExtractor: () => (/* binding */ cssFontExtractor)\n/* harmony export */ });\n/* harmony import */ var opentype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! opentype.js */ \"./node_modules/opentype.js/dist/opentype.js\");\n/* harmony import */ var opentype_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(opentype_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\n * In PDF, text encoding was handled differently, all the char code was transcoded\n * When we want to show the text in the browser, we have to transcode it back\n * Then user can see the correct font type and also can do selection/copy\n * If we don't transcode it back, we have to do the unicode for each text,\n * and select/copy will not be possible\n *\n * @param {Number} encoded\n * @param {PDF.FontFaceObject} fontInfo\n */\nfunction locateCharacter(encoded, fontFace) {\n  // Locate the index of the charecter\n  let index = -1;\n  for (var i = 0; i < fontFace.toFontChar.length; i++) {\n    if (fontFace.toFontChar[i] === encoded) {\n      index = i;\n      break;\n    }\n  }\n\n  if (index != -1 && fontFace.toUnicode._map) {\n    let character = fontFace.toUnicode._map[index];\n    let width = fontFace.widths[index];\n    return {\n      character,\n      width\n    };\n  } else {\n\n    // it might be white space or font part\n  }}\n\nfunction cssFontExtractor(page, loadedFonts) {\n  loadedFonts = loadedFonts || {};\n  var commonObjs = page.commonObjs.objs;\n  var fonts = [];\n  for (let key in commonObjs) {\n    var obj = commonObjs[key].data;\n    // check it is a font\n    if (obj.loadedName && obj.fallbackName && obj.data) {\n      if (loadedFonts[obj.loadedName]) {\n        continue;\n      }\n\n      let font = opentype_js__WEBPACK_IMPORTED_MODULE_0__.parse(obj.data.buffer);\n\n      // need to locate the charector and change the glyph\n      // PDF use swapped charactor code mapping, in order to make browser work\n      // we have to change the glyph back to the original ascii/unicode value\n      let glyphs = font.glyphs.glyphs;\n      for (let glyphKey in glyphs) {\n        let glyph = glyphs[glyphKey];\n        if (!glyph.name && !glyph.unicode) {\n          // undefined name will trigger exception in the encoding stage\n          glyph.name = \"\";\n        } else {\n          let charInfo = locateCharacter(glyph.unicode, obj);\n          if (!charInfo || charInfo.character == undefined) {\n            // undefined name will trigger exception in the encoding stage\n            glyph.name = \"\";\n          } else {\n            glyph.name = charInfo.character;\n            glyph.unicode = charInfo.character.charCodeAt(0);\n            glyph.unicodes = [glyph.unicode];\n          }\n        }\n      }\n      fonts.push({\n        fontName: key,\n        data: font\n      });\n      font.names.fontFamily.en = key;\n      font.names.fontSubfamily.en = \"Regular\";\n    }\n  }\n\n  var promises = fonts.map((font) => {\n    return new Promise((resolve, reject) => {\n      var reader = new FileReader();\n      // font.data.toArrayBuffer is slow\n      // Forked the opentype.js and make the encoding part much faster\n      // Consider to do a PR to opentype.js in future\n      var dataView = new DataView(font.data.toArrayBuffer());\n      var blob = new Blob([dataView], { type: 'font/opentype' });\n      reader.readAsDataURL(blob);\n      reader.onloadend = function () {\n        resolve({\n          css: `\n                    @font-face {\n                        font-family: ${font.fontName};\n                        src: url('${reader.result}');\n                    }`,\n          name: font.fontName\n        });\n      };\n    });\n  });\n\n  return Promise.all(promises).then((data) => {\n    return data;\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2YsQ0FBQyxDQUFDO0FBQ04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9QREYvUERGRm9udEV4dHJhY3Rvci5qcz9lYjAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG9wZW50eXBlIGZyb20gXCJvcGVudHlwZS5qc1wiO1xuXG4vKipcbiAqIEluIFBERiwgdGV4dCBlbmNvZGluZyB3YXMgaGFuZGxlZCBkaWZmZXJlbnRseSwgYWxsIHRoZSBjaGFyIGNvZGUgd2FzIHRyYW5zY29kZWRcbiAqIFdoZW4gd2Ugd2FudCB0byBzaG93IHRoZSB0ZXh0IGluIHRoZSBicm93c2VyLCB3ZSBoYXZlIHRvIHRyYW5zY29kZSBpdCBiYWNrXG4gKiBUaGVuIHVzZXIgY2FuIHNlZSB0aGUgY29ycmVjdCBmb250IHR5cGUgYW5kIGFsc28gY2FuIGRvIHNlbGVjdGlvbi9jb3B5XG4gKiBJZiB3ZSBkb24ndCB0cmFuc2NvZGUgaXQgYmFjaywgd2UgaGF2ZSB0byBkbyB0aGUgdW5pY29kZSBmb3IgZWFjaCB0ZXh0LFxuICogYW5kIHNlbGVjdC9jb3B5IHdpbGwgbm90IGJlIHBvc3NpYmxlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGVuY29kZWRcbiAqIEBwYXJhbSB7UERGLkZvbnRGYWNlT2JqZWN0fSBmb250SW5mb1xuICovXG5mdW5jdGlvbiBsb2NhdGVDaGFyYWN0ZXIoZW5jb2RlZCwgZm9udEZhY2UpIHtcbiAgICAvLyBMb2NhdGUgdGhlIGluZGV4IG9mIHRoZSBjaGFyZWN0ZXJcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbnRGYWNlLnRvRm9udENoYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZvbnRGYWNlLnRvRm9udENoYXJbaV0gPT09IGVuY29kZWQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9IC0xICYmIGZvbnRGYWNlLnRvVW5pY29kZS5fbWFwKSB7XG4gICAgICAgIGxldCBjaGFyYWN0ZXIgPSBmb250RmFjZS50b1VuaWNvZGUuX21hcFtpbmRleF07XG4gICAgICAgIGxldCB3aWR0aCA9IGZvbnRGYWNlLndpZHRoc1tpbmRleF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFyYWN0ZXIsXG4gICAgICAgICAgICB3aWR0aFxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGl0IG1pZ2h0IGJlIHdoaXRlIHNwYWNlIG9yIGZvbnQgcGFydFxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNzc0ZvbnRFeHRyYWN0b3IocGFnZSwgbG9hZGVkRm9udHMpIHtcbiAgICBsb2FkZWRGb250cyA9IGxvYWRlZEZvbnRzIHx8IHt9O1xuICAgIHZhciBjb21tb25PYmpzID0gcGFnZS5jb21tb25PYmpzLm9ianM7XG4gICAgdmFyIGZvbnRzID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIGNvbW1vbk9ianMpIHtcbiAgICAgICAgdmFyIG9iaiA9IGNvbW1vbk9ianNba2V5XS5kYXRhO1xuICAgICAgICAvLyBjaGVjayBpdCBpcyBhIGZvbnRcbiAgICAgICAgaWYgKG9iai5sb2FkZWROYW1lICYmIG9iai5mYWxsYmFja05hbWUgJiYgb2JqLmRhdGEpIHtcbiAgICAgICAgICAgIGlmKGxvYWRlZEZvbnRzW29iai5sb2FkZWROYW1lXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZm9udCA9IG9wZW50eXBlLnBhcnNlKG9iai5kYXRhLmJ1ZmZlcik7XG5cbiAgICAgICAgICAgIC8vIG5lZWQgdG8gbG9jYXRlIHRoZSBjaGFyZWN0b3IgYW5kIGNoYW5nZSB0aGUgZ2x5cGhcbiAgICAgICAgICAgIC8vIFBERiB1c2Ugc3dhcHBlZCBjaGFyYWN0b3IgY29kZSBtYXBwaW5nLCBpbiBvcmRlciB0byBtYWtlIGJyb3dzZXIgd29ya1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBjaGFuZ2UgdGhlIGdseXBoIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGFzY2lpL3VuaWNvZGUgdmFsdWVcbiAgICAgICAgICAgIGxldCBnbHlwaHMgPSBmb250LmdseXBocy5nbHlwaHM7XG4gICAgICAgICAgICBmb3IobGV0IGdseXBoS2V5IGluIGdseXBocykge1xuICAgICAgICAgICAgICAgIGxldCBnbHlwaCA9IGdseXBoc1tnbHlwaEtleV07XG4gICAgICAgICAgICAgICAgaWYoIWdseXBoLm5hbWUgJiYgIWdseXBoLnVuaWNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIG5hbWUgd2lsbCB0cmlnZ2VyIGV4Y2VwdGlvbiBpbiB0aGUgZW5jb2Rpbmcgc3RhZ2VcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGgubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoYXJJbmZvID0gbG9jYXRlQ2hhcmFjdGVyKGdseXBoLnVuaWNvZGUsIG9iaik7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFjaGFySW5mbyB8fCBjaGFySW5mby5jaGFyYWN0ZXIgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgbmFtZSB3aWxsIHRyaWdnZXIgZXhjZXB0aW9uIGluIHRoZSBlbmNvZGluZyBzdGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2x5cGgubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbHlwaC5uYW1lID0gY2hhckluZm8uY2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2x5cGgudW5pY29kZSA9IGNoYXJJbmZvLmNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2x5cGgudW5pY29kZXMgPSBbZ2x5cGgudW5pY29kZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb250cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBmb250TmFtZToga2V5LFxuICAgICAgICAgICAgICAgIGRhdGE6IGZvbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9udC5uYW1lcy5mb250RmFtaWx5LmVuID0ga2V5O1xuICAgICAgICAgICAgZm9udC5uYW1lcy5mb250U3ViZmFtaWx5LmVuID0gXCJSZWd1bGFyXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZXMgPSBmb250cy5tYXAoKGZvbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgLy8gZm9udC5kYXRhLnRvQXJyYXlCdWZmZXIgaXMgc2xvd1xuICAgICAgICAgICAgLy8gRm9ya2VkIHRoZSBvcGVudHlwZS5qcyBhbmQgbWFrZSB0aGUgZW5jb2RpbmcgcGFydCBtdWNoIGZhc3RlclxuICAgICAgICAgICAgLy8gQ29uc2lkZXIgdG8gZG8gYSBQUiB0byBvcGVudHlwZS5qcyBpbiBmdXR1cmVcbiAgICAgICAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhmb250LmRhdGEudG9BcnJheUJ1ZmZlcigpKTtcbiAgICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2RhdGFWaWV3XSwgeyB0eXBlOiAnZm9udC9vcGVudHlwZScgfSk7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNzczogYFxuICAgICAgICAgICAgICAgICAgICBAZm9udC1mYWNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQtZmFtaWx5OiAke2ZvbnQuZm9udE5hbWV9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiB1cmwoJyR7cmVhZGVyLnJlc3VsdH0nKTtcbiAgICAgICAgICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGZvbnQuZm9udE5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pO1xufSJdLCJuYW1lcyI6WyJvcGVudHlwZSIsImxvY2F0ZUNoYXJhY3RlciIsImVuY29kZWQiLCJmb250RmFjZSIsImluZGV4IiwiaSIsInRvRm9udENoYXIiLCJsZW5ndGgiLCJ0b1VuaWNvZGUiLCJfbWFwIiwiY2hhcmFjdGVyIiwid2lkdGgiLCJ3aWR0aHMiLCJjc3NGb250RXh0cmFjdG9yIiwicGFnZSIsImxvYWRlZEZvbnRzIiwiY29tbW9uT2JqcyIsIm9ianMiLCJmb250cyIsImtleSIsIm9iaiIsImRhdGEiLCJsb2FkZWROYW1lIiwiZmFsbGJhY2tOYW1lIiwiZm9udCIsInBhcnNlIiwiYnVmZmVyIiwiZ2x5cGhzIiwiZ2x5cGhLZXkiLCJnbHlwaCIsIm5hbWUiLCJ1bmljb2RlIiwiY2hhckluZm8iLCJ1bmRlZmluZWQiLCJjaGFyQ29kZUF0IiwidW5pY29kZXMiLCJwdXNoIiwiZm9udE5hbWUiLCJuYW1lcyIsImZvbnRGYW1pbHkiLCJlbiIsImZvbnRTdWJmYW1pbHkiLCJwcm9taXNlcyIsIm1hcCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhZGVyIiwiRmlsZVJlYWRlciIsImRhdGFWaWV3IiwiRGF0YVZpZXciLCJ0b0FycmF5QnVmZmVyIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwicmVhZEFzRGF0YVVSTCIsIm9ubG9hZGVuZCIsImNzcyIsInJlc3VsdCIsImFsbCIsInRoZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./extensions/PDF/PDFFontExtractor.js\n");

/***/ }),

/***/ "./extensions/PDF/PDFLoader.js":
/*!*************************************!*\
  !*** ./extensions/PDF/PDFLoader.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PDFLoader: () => (/* binding */ PDFLoader)\n/* harmony export */ });\n/* harmony import */ var _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adsk/pdfjs-dist */ \"./node_modules/@adsk/pdfjs-dist/legacy/build/pdf.js\");\n/* harmony import */ var _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _font_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./font-engine */ \"./extensions/PDF/font-engine.js\");\n\n\n\n\n\n// Delay-init variables that require Autodesk.Extension.CompGeom\nlet LmvCanvasContext = null;\nlet isRef = null;\nlet refKey = null;\nconst MOBILE_DIM_CAP = 2048;\nconst FIREFOX_DIM_CAP = 4096;\nconst DEFAULT_DIM_CAP = 8192;\n\nconst initCompGeom = () => {\n  LmvCanvasContext = Autodesk.Extensions.CompGeom.LmvCanvasContext;\n  isRef = LmvCanvasContext.isRef;\n  refKey = LmvCanvasContext.refKey;\n};\n\n// LMV-5060 When user change model, we don't know the intent why?\n// User might navigate to another page in the same PDF or trying to load a new different model\n// In order to save loading time, we need to use this object try to defer the destroy method of previous PDF worker\n// Then we can try to avoid memory leak in the meantime to make it much faster to navigate between pages\nconst PDFWorkingReferenceMap = {};\nconst DefferedDestroyTime = 3000; // 3 seconds\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\n\n/** @constructor */\nfunction PDFLoader(parent) {\n\n  initCompGeom();\n\n  this.isPdfLoader = true; // For QA only\n  this.viewer3DImpl = parent;\n  this.setGlobalManager(this.viewer3DImpl.globalManager);\n  this.loading = false;\n  this.tmpMatrix = new THREE.Matrix4();\n\n  this.logger = avp.logger;\n  this.loadTime = 0;\n  this.notifiesFirstPixel = true;\n\n  // time stamp when the first mesh was received\n  this.t1_firstPixel = undefined;\n\n  this.dtor = this.dtor.bind(this);\n  this.viewer3DImpl.api.addEventListener(av.VIEWER_UNINITIALIZED, this.dtor, { once: true });\n}\n\nav.GlobalManagerMixin.call(PDFLoader.prototype);\n\n/**\n * BubbleNode Structure for PDF data will help to do page navigation\n * @param {PDF} pdf PDF object from pdf.js\n */\nPDFLoader.prototype.createPDFDocument = function (pdf) {\n  var numPages = pdf.numPages;\n  var guid = pdf.fingerprint;\n  var me = this;\n  // Let the generator stay along with document lifecycle, it will give us a chance to maximum the caching\n  // to get the best performance\n  var parent = {\n    guid: guid,\n    type: \"design\",\n    \"hasThumbnail\": \"false\",\n    \"progress\": \"complete\",\n    \"status\": \"success\",\n    \"success\": \"100%\",\n    \"name\": \"PDF\",\n    \"isVectorPDF\": true,\n    \"role\": \"viewable\",\n    totalRasterPixels: 0,\n    getPDF: function () {// this can avoid issue in searilization\n      if (pdf && pdf._transport && !pdf._transport.destroyed) {\n        return pdf;\n      } else {\n        return null;\n      }\n    }\n  };\n\n  var children = [];\n\n  for (var i = 1; i <= numPages; i++) {\n    children.push({\n      guid: guid + \"/\" + i,\n      type: \"geometry\",\n      role: \"2d\",\n      status: \"success\",\n      progress: \"complete\",\n      viewableID: guid + \"/\" + i,\n      name: av.i18n.translate(\"Page %(i)\", { i }),\n      page: i,\n      children: [{\n        role: av.BubbleNode.PDF_PAGE_NODE.role,\n        page: i,\n        type: \"resource\",\n        status: \"success\",\n        progress: \"complete\",\n        urn: me.svfUrn\n      }]\n    });\n  }\n\n  parent.children = children;\n  return new av.Document(parent);\n};\n\n\nPDFLoader.prototype.dtor = function () {\n  if (this.svf && this.svf.propDbLoader) {\n    this.svf.propDbLoader.dtor();\n    this.svf.propDbLoader = null;\n  }\n\n  this.currentLoadPath = null;\n  this.isf2d = undefined;\n  this.viewer3DImpl.api.removeEventListener(av.VIEWER_UNINITIALIZED, this.dtor);\n\n  if (this.pdf) {\n    // Reset the flag synchronized here\n    delete PDFWorkingReferenceMap[this.pdf.fingerprint];\n    setTimeout(() => {\n      // If the PDF is used in DefferedDestroyTime time, the PDF will be still alive\n      // Otherwise the pdf worker is gonna be destroyed, and the document has been load again.\n      if (!PDFWorkingReferenceMap[this.pdf.fingerprint]) {\n        this.pdf.destroy();\n        this.pdf = null;\n      }\n    }, DefferedDestroyTime);\n  }\n\n  if (this._renderTask) {\n    this._renderTask.cancel();\n    this._renderTask = null;\n  }\n\n  this.svf = null;\n  this.options = null;\n  avp.logger.log(\"PDFLoader destroy\");\n};\n\n\nPDFLoader.prototype.loadFile = function (path, options, onSuccess, onWorkerStart) {\n  if (this.loading) {\n    avp.logger.log(\"Loading of PDF already in progress. Ignoring new request.\");\n    return false;\n  }\n  this.loading = true;\n\n  const urnIdx = path.indexOf('urn:');\n  if (urnIdx !== -1) {\n    // Extract urn:adsk.viewing:foo.bar.whateverjunks out of the path URL and bind it to logger.\n    // From now on, we can send logs to viewing service, and logs are grouped by urn to make Splunk work.\n    path = decodeURIComponent(path);\n    const urn = path.substr(urnIdx, path.substr(urnIdx).indexOf('/'));\n    avp.logger.log(\"Extracted URN: \" + urn);\n\n    // Extract urn(just base64 code)\n    const _index = urn.lastIndexOf(':');\n    this.svfUrn = urn.substr(_index + 1);\n\n    //V2 only accepts URL encoded paths\n    const qIdx = path.indexOf(\"?\", urnIdx);\n    if (qIdx !== -1) {\n      path = path.slice(0, urnIdx) + encodeURIComponent(path.slice(urnIdx, qIdx)) + path.slice(qIdx);\n    } else\n    {\n      path = path.slice(0, urnIdx) + encodeURIComponent(path.slice(urnIdx));\n    }\n  } else {\n    this.svfUrn = path;\n  }\n\n  this.sharedDbPath = options.sharedPropertyDbPath;\n  this.currentLoadPath = path;\n  this.acmSessionId = options.acmSessionId;\n\n  //This is done to avoid CORS errors on content served from proxy or browser cache\n  //The cache will respond with a previously received response, but the Access-Control-Allow-Origin\n  //response header might not match the current Origin header (e.g. localhost vs. developer.api.autodesk.com)\n  //which will cause a CORS error on the second request for the same resource.\n  this.queryParams = [\n  this.acmSessionId && `acmsession=${this.acmSessionId}`,\n  av.endpoint.getQueryParams()].\n  filter((p) => p).join('&');\n\n  this.options = options;\n\n  if (this.options.placementTransform) {\n    //NOTE: The scale of the placement transform is not always sufficient to\n    //determine the correct scale for line widths. This is because when a 2D model (in inches) is\n    //loaded into a 3d scene in feet, the transform includes all the scaling needed to get into feet\n    //but the model space line weight for the drawing is relative to the drawing itself, so an extra\n    //factor of 12 would be needed in such case to cancel out the 1/12 needed for inch->foot.\n    //This could probably be automatically derived, but in an error prone way, so I'm leaving it\n    //up to the application layer that does the model aggregation to pass in the right model scale as an option.\n    this.modelScale = this.options.modelScale || this.options.placementTransform.getMaxScaleOnAxis();\n  } else {\n    this.modelScale = this.options.modelScale || 1;\n  }\n\n  var scope = this;\n\n  scope.loadFydoCB(path, options, onSuccess, onWorkerStart);\n\n  return true;\n};\n\nPDFLoader.prototype.getDocument = function () {\n  return this.options.bubbleNode.getRootNode().data;\n};\n\nPDFLoader.prototype.getFontGenerator = function () {\n  return this.viewer3DImpl.api.loadExtension(\"Autodesk.MSDF\").then(() => {\n    const generator = new Autodesk.MSDF.Generator();\n    generator.setGlobalManager(this.globalManager);\n    return generator;\n  });\n};\n\nPDFLoader.prototype.createFontAtlas = function (page, cacheKey) {\n  if (PDFLoader.enableMSDFText) {\n    // Fetching the operation list will trigger the font loading\n    // The loaded font event will be trigger in next tick\n    // So we need use timeout to let the app continue\n    return new Promise((resolve, reject) => {\n      this.getOperatorList(page).then(() => {\n        setTimeout(() => {\n          this.getFontGenerator().then((generator) => {\n            generator.createFontAtlasForPDF(page, cacheKey).then((fontAtlas) => {\n              resolve(fontAtlas);\n            });\n          });\n        }, 0);\n      });\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\nPDFLoader.prototype.evaluatePageLineStyles = function (page) {\n  return this.getOperatorList(page).then((data) => {\n    let w = 0;\n    let cacheSet = new Set();\n\n    for (var i = 0; i < data.fnArray.length; i++) {\n      if (data.fnArray[i] == _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.setDash) {\n        w = Math.max(w, data.argsArray[i][0].length);\n        let key = data.argsArray[i].join(\"/\");\n        cacheSet.add(key);\n      }\n    }\n\n    let h = cacheSet.size + 1;\n    this.pageLineStyleParams = {\n      width: w,\n      height: h\n    };\n  });\n};\n\nPDFLoader.prototype.detectSmallImageSequences = function (page) {\n  const MAX_OP_DISTANCE = 12;\n  const MIN_OPS = 5 * MAX_OP_DISTANCE;\n  const MAX_PAGE_UNIT_DISTANCE = 100;\n\n  //console.time(\"detectSmallImageSequences\");\n  return this.getOperatorList(page).then((data) => {\n\n    function isSmallImage(index) {\n      const op = data.fnArray[index];\n      if (op === _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.paintJpegXObject || op === _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.paintImageXObject) {\n        const w = data.argsArray[index][1];\n        const h = data.argsArray[index][2];\n        return w <= 2 || h <= 2;\n      }\n      if (op === _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.paintImageMaskXObject || op === _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.paintInlineImageXObject) {\n        const w = data.argsArray[index][0].width;\n        const h = data.argsArray[index][0].height;\n        return w <= 2 || h <= 2;\n      }\n      return false;\n    }\n\n    function findSequenceStart(index) {\n      // scan backwards for at most MAX_OP_DISTANCE ops and find the first PDFJS.OPS.save\n      // on the way, no PDFJS.OPS.restore or anything text-related must be found\n      // this logic is supposed to detect cases like (index points to \"image\")\n      //   - save transform image restore\n      //   - save transform constructpath clip endpath save transform image restore restore\n      const end = Math.max(-1, index - MAX_OP_DISTANCE);\n      let i = index - 1;\n      let q = -1; // if no PDFJS.OPS.save is found, -1 will signal \"no sequence\"\n      let qCount = 0;\n      for (; i > end; i--) {\n        const op = data.fnArray[i];\n        switch (op) {\n          case _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.save:\n            q = i;\n            qCount++;\n            break;\n          case _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.showText:\n          case _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.showSpacedText:\n          case _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.nextLineShowText:\n          case _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.nextLineSetSpacingShowText:\n          case _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.restore:\n            i = end;\n            break;\n        }\n      }\n\n      return { q, qCount };\n    }\n\n    function findSequenceEnd(index, qCount) {\n      // scan forwards for at most MAX_OP_DISTANCE ops and find the qCount'th PDFJS.OPS.restore\n      const end = Math.min(data.fnArray.length, index + MAX_OP_DISTANCE);\n      let i = index + 1;\n      let q = index + 1;\n      for (; i < end && qCount > 0; i++) {\n        const op = data.fnArray[i];\n        if (op == _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.restore) {\n          q = i;\n          qCount--;\n        }\n      }\n\n      // if not enough PDFJS.OPS.restore are found, mark sequence as broken\n      return qCount > 0 ? -1 : q;\n    }\n\n    function addPointBBox(bbox, x, y) {\n      bbox[0] = Math.min(bbox[0], x);\n      bbox[1] = Math.min(bbox[1], y);\n      bbox[2] = Math.max(bbox[2], x);\n      bbox[3] = Math.max(bbox[3], y);\n    }\n\n    function addImageBBox(bbox, xform) {\n      // images use a fixed [0, 0]x[1, 1] space => transform each corner and add to bbox\n      // xform uses the canvas context convention: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/transform\n      addPointBBox(bbox, xform[4], xform[5]);\n      addPointBBox(bbox, 1 * xform[2] + xform[4], 1 * xform[3] + xform[5]);\n      addPointBBox(bbox, 1 * xform[0] + xform[4], 1 * xform[1] + xform[5]);\n      addPointBBox(bbox, 1 * xform[0] + 1 * xform[2] + xform[4], 1 * xform[1] + 1 * xform[3] + xform[5]);\n    }\n\n    function process() {\n      let sequenceStart = { q: -1, qCount: 0 };\n      let lastSmallImage = -1;\n      let smallImageSequences = [];\n      let currXform = [1, 0, 0, 1, 0, 0];\n      let xformStack = [];\n      let bbox = [1e10, 1e10, -1e10, -1e10]; // [minx, miny, maxx, maxy]\n\n      const beginSequence = function (i) {\n        sequenceStart = findSequenceStart(i);\n        lastSmallImage = i;\n        bbox = [1e10, 1e10, -1e10, -1e10];\n      };\n\n      const endSequence = function () {\n        const end = findSequenceEnd(lastSmallImage, sequenceStart.qCount);\n        // if the sequence is too short, ignore it (performance gain would be too small)\n        if (end >= 0 && end > sequenceStart.q + MIN_OPS) {\n          // sequence ended correctly\n          smallImageSequences.push({\n            start: sequenceStart.q,\n            end,\n            bbox\n          });\n        }\n      };\n\n      for (let i = 0; i < data.fnArray.length; i++) {\n        const op = data.fnArray[i];\n        if (op == _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.save) {\n          xformStack.push(currXform);\n          currXform = currXform.slice(0, 6);\n        } else if (op == _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.transform) {\n          const m = currXform;\n          const a = data.argsArray[i];\n          currXform = [m[0] * a[0] + m[2] * a[1],\n          m[1] * a[0] + m[3] * a[1],\n          m[0] * a[2] + m[2] * a[3],\n          m[1] * a[2] + m[3] * a[3],\n          m[0] * a[4] + m[2] * a[5] + m[4],\n          m[1] * a[4] + m[3] * a[5] + m[5]];\n        } else if (op == _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.restore) {\n          currXform = xformStack.pop() || [1, 0, 0, 1, 0, 0];\n        } else if (isSmallImage(i)) {\n          // is this a new sequence?\n          if (sequenceStart.q < 0) {\n            beginSequence(i);\n          } else if (i > lastSmallImage + MAX_OP_DISTANCE) {\n            // too many operators between the previous small image and the current -> end sequence and start a new one\n            endSequence();\n            beginSequence(i);\n          } else {\n            // check if the image is too far away from last image (i.e., it should start new sequence)\n            let bboxImg = [1e10, 1e10, -1e10, -1e10];\n            addImageBBox(bboxImg, currXform);\n            // skip the check for the first few images as the sequence needs to establish a reasonable line length first\n            if (i - sequenceStart.q > MIN_OPS && (\n            bboxImg[2] < bbox[0] - MAX_PAGE_UNIT_DISTANCE || bboxImg[0] > bbox[2] + MAX_PAGE_UNIT_DISTANCE ||\n            bboxImg[3] < bbox[1] - MAX_PAGE_UNIT_DISTANCE || bboxImg[1] > bbox[3] + MAX_PAGE_UNIT_DISTANCE)) {\n\n              // end sequence and start a new one\n              endSequence();\n              beginSequence(i);\n            } else {\n              // just add to current sequence\n              lastSmallImage = i;\n            }\n          }\n\n          if (lastSmallImage >= 0) {\n            addImageBBox(bbox, currXform);\n          }\n        }\n      }\n\n      // end last sequence\n      if (lastSmallImage >= 0) {\n        endSequence();\n      }\n\n      return smallImageSequences;\n    }\n\n    this.smallImageSequences = process();\n    //console.timeEnd(\"detectSmallImageSequences\");\n  }).catch(avp.logger.log);\n};\n\nPDFLoader.prototype.fixTilingPatternsWithHugeGaps = function (page) {\n  const MAX_GAP_FACTOR = 10;\n  const BUFFER_FACTOR = 2;\n\n  // addresses BLMV-7214 and VIZX-191\n  return this.getOperatorList(page).then((data) => {\n    for (let i = 0; i < data.fnArray.length; i++) {\n      // search for tiling pattern definitions\n      const op = data.fnArray[i];\n      if (op != _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.setFillColorN) {continue;}\n      let args = data.argsArray[i];\n      if (!args || args.length < 7) {continue;}\n      if (args[0] != \"TilingPattern\") {continue;}\n\n      // look at the pattern parameters\n      const bbox = args[4];\n      const xstep = args[5];\n      const ystep = args[6];\n\n      const bboxWidth = bbox[2] - bbox[0];\n      const bboxHeight = bbox[3] - bbox[1];\n\n      // if step is more than MAX_GAP_FACTOR times the size of the bbox, assume that there is no actual tiling intended\n      if (xstep > MAX_GAP_FACTOR * bboxWidth && ystep > MAX_GAP_FACTOR * bboxHeight) {\n        // ideally, we would then use a texture without repeat, but there is no such option in our materials\n        // instead, add a bit of buffer in case some area outside the pattern bbox is visible\n        args[5] = BUFFER_FACTOR * bboxWidth;\n        args[6] = BUFFER_FACTOR * bboxHeight;\n      }\n    }\n  });\n};\n\n/**\n * When we do synchronized loading pdf referenced object, it might return empty if that content was not loaded\n * Asynchronized way is better, but it increases the complexity of loading it\n * This function is prefly for parsing those references\n */\nPDFLoader.prototype.loadMarkedContentPropertiesReferences = function (pdf, page) {\n  var referenceObjMap = {};\n\n  function getRefObj(ref) {\n    return pdf.getObject(ref).then((data) => {\n      referenceObjMap[refKey(data.key)] = data.value;\n      // loop in one more level for dictionary\n      var childPromises = [];\n      if (data.isDictionary) {\n        for (let itemKey in data.value) {\n          if (isRef(data.value[itemKey])) {\n            if (referenceObjMap[refKey(data.value[itemKey])]) {\n              data.value[itemKey] = referenceObjMap[refKey(data.value[itemKey])];\n            } else {\n              childPromises.push(pdf.getObject(data.value[itemKey]).then((data1) => {\n                data.value[itemKey] = data1.value;\n                referenceObjMap[refKey(data1.key)] = data1.value;\n              }).catch(avp.logger.log));\n            }\n          }\n        }\n      }\n\n      return Promise.all(childPromises);\n    }).catch(avp.logger.log); // for any missing reference object, just ignore and continue\n  }\n\n  return this.getOperatorList(page).then((ops) => {\n    var promises = [];\n    for (var i = 0; i < ops.fnArray.length; i++) {\n\n      if (ops.fnArray[i] == _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.beginMarkedContent || ops.fnArray[i] == _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.beginMarkedContentProps) {\n        var args1 = ops.argsArray[i];\n        for (let j = 0; args1 && j < args1.length; j++) {\n          if (isRef(args1[j])) {\n            let promise = getRefObj(args1[j]);\n            promises.push(promise);\n          } else if (typeof args1[j] == \"object\") {\n            for (let key in args1[j]) {\n              if (isRef(args1[j][key])) {\n                let promise = getRefObj(args1[j][key]);\n                promises.push(promise);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return Promise.all(promises)\n    // This is a nice to have feature, in case of anything wrong, ust ignore and continue\n    .catch(avp.logger.log).\n    then(() => {\n      return referenceObjMap;\n    });\n  });\n};\n\nPDFLoader.prototype.loadFydoCB = function (path, options, onSuccess, onWorkerStart) {\n  this.t0 = Date.now();\n\n  var svfPath = avp.pathToURL(path);\n  if (this.queryParams) {\n    svfPath += '?' + this.queryParams;\n  }\n\n  var scope = this;\n\n  if (onWorkerStart)\n  onWorkerStart();\n\n  let cMapUrl = options.cMapUrl;\n  let cMapPacked = options.cMapPacked;\n  if (!cMapUrl) {\n    cMapUrl = avp.getResourceUrl('extensions/PDF/cmaps/');\n    cMapPacked = true;\n  }\n\n  var params = {\n    url: svfPath,\n    disableFontFace: true,\n    stopAtErrors: false,\n    isEvalSupported: false,\n    cMapUrl,\n    cMapPacked\n  };\n\n  if (av.endpoint.getUseCookie()) {\n    params.withCredentials = true;\n  } else {\n    params.httpHeaders = av.endpoint.HTTP_REQUEST_HEADERS;\n  }\n\n  this.viewer3DImpl._signalNoMeshes();\n\n  let fe = _font_engine__WEBPACK_IMPORTED_MODULE_1__.theFontEngine;\n\n  //Start loading fonts.\n  let loadFontsAsync = fe.loadFonts();\n\n  function getInternalLinks(pdf, page) {\n    return page.getAnnotations().then((annotations) => {\n      if (annotations && annotations.length > 0) {\n        return Promise.all(annotations.map((annotation) => {\n          // internal page link\n          if (annotation.subtype == \"Link\" && !annotation.url) {\n            var pageIndexPromise;\n\n            // So far I found 2 ways of annotion destination, it might be more, extend this part if we have new case\n            if (typeof annotation.dest == \"string\") {\n              pageIndexPromise = pdf.getDestination(annotation.dest).then((destInfo) => {\n                return pdf.getPageIndex(destInfo[0]);\n              });\n            } else {\n              if (annotation.dest instanceof Array) {\n                pageIndexPromise = pdf.getPageIndex(annotation.dest[0]);\n              }\n            }\n            if (pageIndexPromise) {\n              return pageIndexPromise.then((pageIndex) => {\n                // need to register the rect to pageIndex\n                // pdf getPage function start from 1, so here need add extra 1\n                annotation.pageIndex = pageIndex + 1;\n                return annotation;\n              });\n            }\n          } else {\n\n            // external link, will add support here, if needed\n          }})).then((internalLinks) => {\n          return internalLinks.filter((item) => item != undefined);\n        }).catch((error) => {\n          // If we have difficulty of parsing annotations, we should let the loading continue\n          return [];\n        });\n      }\n    });\n  }\n\n  function updateLinkBounds(renderContext, viewport, internalLinks) {\n    var dbIdLinks = [];\n    // Use negative dbId since hotArea is added by us\n    var dbId = -2;\n    var transform = renderContext.getCurrentTransform();\n    for (var i = 0; internalLinks && i < internalLinks.length; i++) {\n      const rect = createRectByViewportTransform(renderContext, transform, viewport, internalLinks[i].rect);\n      var linkNode = scope.svf.loadOptions.bubbleNode.getRootNode().children[internalLinks[i].pageIndex - 1];\n      dbIdLinks.push({\n        dbId: dbId--,\n        properties: [{\n          displayValue: linkNode.data.viewableID\n        }],\n        box: [\n        Math.min(rect[0], rect[2]),\n        Math.min(rect[1], rect[3]),\n        Math.max(rect[0], rect[2]),\n        Math.max(rect[1], rect[3])]\n\n      });\n    }\n    scope.dbIdLinks = dbIdLinks;\n  }\n\n  function createRectByViewportTransform(renderContext, transform, viewport, tempRect) {\n    let rect = viewport.convertToViewportRectangle(tempRect);\n    rect = [renderContext.tx(rect[0], rect[1], transform),\n    renderContext.ty(rect[0], rect[1], transform),\n    renderContext.tx(rect[2], rect[3], transform),\n    renderContext.ty(rect[2], rect[3], transform)];\n    return rect;\n  }\n\n  function rotateAround(p, center, angle) {\n    let c = Math.cos(angle);\n    let s = Math.sin(angle);\n\n    let x = p.x - center.x;\n    let y = p.y - center.y;\n\n    p.x = x * c - y * s + center.x;\n    p.y = x * s + y * c + center.y;\n  }\n\n  /**\n   * Format strings output from PDF page\n   * @param {Object} renderCtx - Render context of current page rendering.\n   * @param {Object} pageInfo - dimensions of current page.\n   * @param {Object} viewport - Viewport based on Page properties.\n   * @param {Array} vectorStrings - Array with all strings from Vector PDF.\n   * @param {Object} formattedGlyphs - Object which contains glyphs and their properties.\n   * @returns {Object} - Object with list of strings and their stringBoxes.\n   */\n  function formatVectorPdfStrings(renderCtx, pageInfo, viewport, vectorStrings, formattedGlyphs) {\n    const strings = [];\n    const stringBoxes = [];\n    const stringAngles = [];\n    const stringCharWidths = [];\n    const stringPositions = [];\n    const stringHeights = [];\n    const stringWidths = [];\n    const renderCtxTransform = renderCtx.viewport.transform;\n    const currentTransform = renderCtx.getCurrentTransform();\n\n    // Transform function that combines values from Render Context Transform and Transform of a string\n    const transformFunc = (m1, m2) => {\n      return [\n      m1[0] * m2[0] + m1[2] * m2[1],\n      m1[1] * m2[0] + m1[3] * m2[1],\n      m1[0] * m2[2] + m1[2] * m2[3],\n      m1[1] * m2[2] + m1[3] * m2[3],\n      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n\n    };\n\n    //Strings in PDF.js are grouped, hence 2 loops needed to extract every expression.\n    for (let i = 0; i < vectorStrings.length; i++) {\n      if (vectorStrings[i].items) {\n        const items = vectorStrings[i].items;\n\n        for (let j = 0; j < items.length; j++) {\n          const tempObject = items[j];\n          const tempCharWidth = [];\n          // tempObject contains characters map with corresponding width values for each char\n          // formattedGlyphs stores font families by name and char and widths\n          for (let k = 0; k < tempObject.str.length; k++) {\n            const tempFontName = formattedGlyphs[tempObject.fontName];\n            const tempString = tempObject.str[k];\n            // Fix for BLMV-5151, need to verify that specific character exist, otherwise it can prevent PDF from loading\n            if (!tempFontName[tempString]) {\n              console.warn(`Cannot find ${tempString}'s width in glyph dictionary`);\n              tempCharWidth.push(0);\n            } else {\n              tempCharWidth.push(tempFontName[tempString].width);\n            }\n          }\n          stringCharWidths.push(tempCharWidth);\n          const textWidth = tempObject.width;\n          const textHeight = tempObject.height;\n\n          // Get bounding box's angle of a string by using viewport and strings transform\n          // Rotation of bbox applied on UI side based on angle\n          const strTx = transformFunc(renderCtxTransform, tempObject.transform);\n          const strAngle = Math.atan2(strTx[1], strTx[0]);\n\n          // Creating Bounding box based on transform values from pdf.js object\n          // 4-th place in array is vertical offset of string\n          // 5-th place in array is horizontal offset of string\n          const minX = tempObject.transform[4];\n          const maxX = tempObject.transform[4] + textWidth;\n          const minY = tempObject.transform[5];\n          const maxY = tempObject.transform[5] + textHeight;\n\n          const box = new THREE.Box2().setFromPoints([new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY)]);\n          rotateAround(box.max, box.min, THREE.Math.degToRad(pageInfo.rotate));\n\n          const tempRect = [box.min.x, box.min.y, box.max.x, box.max.y];\n\n          const rect = createRectByViewportTransform(renderCtx, currentTransform, viewport, tempRect);\n\n          strings.push(tempObject.str);\n          stringBoxes.push(rect[0], rect[1], rect[2], rect[3]);\n          stringAngles.push(strAngle);\n          stringPositions.push([rect[0], rect[1]]);\n          stringHeights.push(textHeight);\n          stringWidths.push(textWidth);\n        }\n      }\n    }\n    return { strings, stringBoxes, stringAngles, stringCharWidths, stringPositions, stringHeights, stringWidths };\n  }\n\n  /**\n   * Extracts the viewports from the PDF\n   * @param {PDFPageProxy} page\n   * @param {LmvCanvasContext} renderContext\n   * @returns {Object[]} The extracted viewports\n   */\n  PDFLoader.prototype.buildViewports = function (page, renderContext) {\n    let viewports = [];\n    return this.getOperatorList(page).then((ops) => {\n      for (let i = 0; i < ops.fnArray.length; i++) {\n\n        if (ops.fnArray[i] == _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.beginMarkedContent || ops.fnArray[i] == _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.beginMarkedContentProps) {\n          if (ops.argsArray[i]) {\n            let properties = ops.fnArray[i] == _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.beginMarkedContent ? ops.argsArray[i][0] : ops.argsArray[i][1];\n\n            if (properties) {\n              properties = renderContext._processProperties(properties);\n\n              if (properties.VP) {\n                const vp = renderContext._getModelToViewportMatrix(properties.VP, !!properties.UNITS);\n                viewports.push(renderContext.createViewPortData(vp, properties.UNITS, properties.PRECISION));\n              }\n            }\n          }\n        }\n      }\n      return viewports;\n    });\n  };\n\n  function buildLayers(page) {\n    return scope.getOperatorList(page).then((ops) => {\n      let fnArray = ops.fnArray;\n      let argsArray = ops.argsArray;\n      let layers = {};\n      let layerStartIndex = 1;\n\n      for (var i = 0; fnArray && i < fnArray.length; i++) {\n        let fn = fnArray[i];\n        if (fn === _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.beginMarkedContentProps) {\n          if (argsArray[i] && argsArray[i][0] == \"OC\" && argsArray[i][1] !== null) {\n            const key = LmvCanvasContext.getLayerKey(argsArray[i][1]);\n            if (key !== undefined && layers[key] === undefined) {\n              layers[key] = layerStartIndex++;\n            }\n          }\n        }\n      }\n      return layers;\n    })\n    // It should not have error, but we don't test enough for PDF\n    // In case of potential error happened, we still want to show the contents\n    .catch(avp.logger.log).\n    then((layers) => {\n      return scope.pdf.getPageOCGNames(page.ref).\n      catch(avp.logger.log).\n      then((layerNameMap) => {\n        layerNameMap = layerNameMap || {};\n        var layersRoot = { name: 'root', id: 'root', children: [], isLayer: false };\n        var layersMap = { \"0\": 0 };\n        var layerCount = 1;\n        for (var layerKey in layers) {var _l;\n          var l = layerNameMap[layerKey];\n          var name = typeof l === 'object' && Object.prototype.hasOwnProperty.call(l, 'name') ? l.name : layerKey;\n\n          var layer = {\n            name: name,\n            id: 'group-' + layers[layerKey],\n            isLayer: true,\n            index: layers[layerKey],\n            visible: ((_l = l) === null || _l === void 0 ? void 0 : _l.visible) ?? true,\n            children: []\n          };\n          // for layers, the first drawing layer should be at the bottom of the list\n          layersRoot.children.unshift(layer);\n          layerCount++;\n          layersMap[layers[layerKey]] = layers[layerKey];\n        }\n\n        return {\n          layerCount,\n          layersRoot,\n          layersMap,\n          layers\n        };\n      });\n    });\n  }\n\n  function getStrings(page) {\n    const documentStrings = [];\n    const readableStream = page.streamTextContent({ normalizeWhitespace: true, combineTextItems: true });\n    return new Promise((resolve, reject) => {\n      let pump = () => {\n        reader.read().then((_ref) => {let { value, done } = _ref;\n          if (done) {\n            resolve(documentStrings);\n            return;\n          }\n          documentStrings.push(value);\n          pump();\n        }, reject);\n      };\n      const reader = readableStream.getReader();\n      pump();\n    });\n  }\n\n  function renderPage(pageNumber) {\n    var pdf = scope.pdf;\n    PDFWorkingReferenceMap[pdf.fingerprint] = 1;\n\n    if (pageNumber <= 0 || pageNumber > pdf.numPages) {\n      pageNumber = 1;\n    }\n\n    if (scope.model) {\n      scope.viewer3DImpl.unloadModel(scope.model);\n      scope.model = undefined;\n    }\n    var context = {};\n    let documentStrings = [];\n    return pdf.getPage(pageNumber).then((page) => {\n      return scope.createFontAtlas(page, pdf.fingerprint).then((fontAtlas) => {\n        context.fontAtlas = fontAtlas;\n        return getInternalLinks(pdf, page).then((internalLinks) => {\n          context.internalLinks = internalLinks;\n        });\n      }).then(() => {\n        // Get PDF strings from page\n        // options Feature Flag disables by default PDF.js strings fetch\n        return options.extendStringsFetching ? getStrings(page) : [];\n      }).then((strings) => {\n        documentStrings = strings;\n        return scope.detectCircle(page);\n      }).then(() => {\n        // Load any large font files that need to be used by the current PDF.\n        return scope.loadOnDemandFonts(page, fe);\n      }).then(() => {\n        return scope.loadMarkedContentPropertiesReferences(pdf, page).then((map) => {\n          context.pdfRefObjMap = map;\n        });\n      }).then(() => {\n        return scope.evaluatePageLineStyles(page);\n      }).then(() => {\n        return scope.detectSmallImageSequences(page);\n      }).then(() => {\n        return scope.fixTilingPatternsWithHugeGaps(page);\n      }).then(() => {var _scope$options$bubble, _scope$options$placem, _scope$options$placem2;\n        let internalLinks = context.internalLinks;\n        var view = page.view;\n        view = view.slice(0);\n\n        // LMV-5149: Apply the page rotation to the page_width and page_height\n        var rotationMatrix = new THREE.Matrix4().makeRotationZ(page.rotate / 180 * Math.PI);\n        var rotatedViewVec1 = new THREE.Vector3(view[0], view[1], 0).applyMatrix4(rotationMatrix);\n        var rotatedViewVec2 = new THREE.Vector3(view[2], view[3], 0).applyMatrix4(rotationMatrix);\n\n\n        // Apply the rotation vector to the view\n        // These values are used to calculate the page_width and the page_height\n        view[0] = Math.min(rotatedViewVec1.x, rotatedViewVec2.x);\n        view[1] = Math.min(rotatedViewVec1.y, rotatedViewVec2.y);\n        view[2] = Math.max(rotatedViewVec1.x, rotatedViewVec2.x);\n        view[3] = Math.max(rotatedViewVec1.y, rotatedViewVec2.y);\n\n        // need to put a cap on 1 dimention : 8192 for desktop / 4096 for firefox / 2048 for mobile\n        // LMV-4731: If we set the viewport too large, it will fail to load in Firefox\n        var maxDim = Math.max(view[2] - view[0], view[3] - view[1]);\n        const capDim = av.isMobileDevice() ? MOBILE_DIM_CAP : av.isFirefox() ? FIREFOX_DIM_CAP : DEFAULT_DIM_CAP;\n        const scaleByDim = capDim / maxDim;\n\n        const DPI = 300;\n        //Render the PDF at 300 pixels/inch instead of 72 points/inch.\n        //This seems to match what Adobe Reader does at max zoom.\n        const scaleByDPI = DPI / 72;\n\n        // scale as much as possible without exceeding capDim\n        const pageToCanvasScale = Math.min(scaleByDPI, scaleByDim);\n\n        // Important: the measure tool expects inches\n        // take userUnit into account: PDF specs define userUnit as a factor on the size of a pt, so the conversion to inches is not 1/72, but userUnit/72\n        const userUnit = page.userUnit || 1;\n        const canvasToInchesScale = userUnit / 72 / pageToCanvasScale;\n\n        // Convert to source file unit's if supplied in the bubble.\n        let targetUnits = ((_scope$options$bubble = scope.options.bubbleNode) === null || _scope$options$bubble === void 0 ? void 0 : _scope$options$bubble.getSourceFileUnits()) || avp.ModelUnits.INCH;\n\n        const inchesToTargetUnitsScale = Autodesk.Viewing.Private.convertUnits(avp.ModelUnits.INCH, targetUnits, 1, 1);\n        const canvasToTargetUnitScale = canvasToInchesScale * inchesToTargetUnitsScale;\n\n        //Negative rotation because we skip the y-flip.\n        //TODO: need to check if this is right for all rotations, if not just let it flip y and negate that in the canvas context.\n        // viewport will use canvas units\n        var options = {\n          scale: pageToCanvasScale,\n          rotation: -page.rotate,\n          dontFlip: true\n        };\n        var viewport = page.getViewport(options);\n        viewport.clipToViewport = true;\n\n        scope.renderContext = new LmvCanvasContext(viewport, canvasToTargetUnitScale, scope.processReceivedMesh2D.bind(scope), fe, PDFLoader.useTextLayer, context.fontAtlas, context.pdfRefObjMap);\n\n        // update lineStyles\n        scope.renderContext.setLineStyleParam(scope.pageLineStyleParams);\n        scope.viewer3DImpl.matman().setLineStyleTexture(scope.renderContext.lineStyleTexture);\n        scope.renderContext.setSmallImageSequences(scope.smallImageSequences);\n\n        scope.renderContext.setCircleInfo(scope.circleInfo);\n\n        // Assign consecutive dbIds. The only purpose of these IDs is to split the page down into smaller shapes, so that\n        // we can use the ID buffer to quickly find shapes for snapping.\n        scope.renderContext.consecutiveIds = true;\n\n        const bounds = scope.renderContext.bounds;\n\n        scope.svf = {\n          is2d: true,\n          isPdf: true,\n          viewports: [],\n          layersMap: { \"0\": 0 },\n          layerCount: 1,\n          bbox: new THREE.Box3(new THREE.Vector3(bounds.x, bounds.y, 0), new THREE.Vector3(bounds.z, bounds.w, 0)),\n          metadata: {\n            page_dimensions: {\n              page_width: (view[2] - view[0]) * inchesToTargetUnitsScale * userUnit / 72,\n              page_height: (view[3] - view[1]) * inchesToTargetUnitsScale * userUnit / 72,\n              logical_width: viewport.width * inchesToTargetUnitsScale,\n              logical_height: viewport.height * inchesToTargetUnitsScale,\n              logical_offset_x: viewport.offsetX * inchesToTargetUnitsScale,\n              logical_offset_y: viewport.offsetY * inchesToTargetUnitsScale,\n              page_units: targetUnits,\n              rotation: viewport.rotation\n            },\n            currentPage: pageNumber\n          },\n          placementTransform: (_scope$options$placem = scope.options.placementTransform) === null || _scope$options$placem === void 0 ? void 0 : _scope$options$placem.clone(),\n          placementWithOffset: (_scope$options$placem2 = scope.options.placementTransform) === null || _scope$options$placem2 === void 0 ? void 0 : _scope$options$placem2.clone(),\n          strings: [],\n          stringDbIds: [],\n          getPDF: function () {\n            return scope.pdf;\n          }\n        };\n\n        var t0 = performance.now();\n\n        // layers information is required before we call onSuccess\n        buildLayers(page).then((layersInfo) => {\n          scope.svf.layersRoot = layersInfo.layersRoot;\n          scope.svf.layerCount = layersInfo.layerCount;\n          scope.svf.layersMap = layersInfo.layersMap;\n          scope.renderContext.layers = layersInfo.layers;\n        })\n        // Ignore any potential error and let the rendering continue\n        .catch(avp.logger.log).\n        then(() => scope.buildViewports(page, scope.renderContext)).\n        then((viewports) => {\n          // store viewports\n          scope.svf.viewports = scope.renderContext.viewports = scope.renderContext.viewports.concat(viewports);\n\n          if (scope.currentLoadPath === null) {\n            const errorMsg = \"PDF loader was destroyed\";\n            onSuccess && onSuccess(errorMsg);\n            return Promise.reject(errorMsg);\n          }\n\n          scope.onModelRootLoadDone(scope.svf);\n          if (onSuccess) {\n            onSuccess(null, scope.model);\n          }\n          scope.viewer3DImpl.api.fireEvent({ type: av.MODEL_ROOT_LOADED_EVENT, svf: scope.svf, model: scope.model });\n        }).then(() => {\n          //\n          // Render PDF page into canvas context\n          //\n          loadFontsAsync.then(() => {\n            var renderTask = scope._renderTask = page.render(scope.renderContext, this);\n            renderTask.promise.then(() => {var _documentStrings, _model$getDocumentNod;\n              if (internalLinks && internalLinks.length > 0) {\n                // render hot area in the canvas to enable internal links\n                // Need to render the hotArea after main page was rendered,\n                // because extra dbID will be assigned to hotArea\n                if (PDFLoader.enableHyperlinks) {\n                  updateLinkBounds(scope.renderContext, viewport, internalLinks);\n                  scope.svf.metadata.hyperLinks = scope.dbIdLinks;\n                  scope.viewer3DImpl.api.loadExtension(\"Autodesk.Hyperlink\");\n                }\n              }\n\n              // Format PDF document strings\n              if (((_documentStrings = documentStrings) === null || _documentStrings === void 0 ? void 0 : _documentStrings.length) > 0) {var _page$commonObjs;\n                const pdfObjects = page === null || page === void 0 || (_page$commonObjs = page.commonObjs) === null || _page$commonObjs === void 0 ? void 0 : _page$commonObjs._objs;\n                const formattedGlyphs = {};\n                // pdfObjects contain information regarding fonts and their properties as size, width, style etc.\n                // By iterating this object, we can obtain compact object with relevant characters for further calculations\n                // Final structure of formattedGlyphs object: Family Name-> Character -> character width\n                for (let pdfObject in pdfObjects) {var _pdfObjects$pdfObject;\n                  if ((_pdfObjects$pdfObject = pdfObjects[pdfObject].data) !== null && _pdfObjects$pdfObject !== void 0 && _pdfObjects$pdfObject.glyphCache) {\n                    const glyphCache = pdfObjects[pdfObject].data.glyphCache;\n                    const fontName = pdfObjects[pdfObject].data.loadedName;\n                    const tempGlyphs = {};\n                    for (let char in glyphCache) {\n                      const unicodeChar = glyphCache[char].unicode;\n                      tempGlyphs[unicodeChar] = {\n                        width: glyphCache[char].width\n                      };\n                    }\n                    formattedGlyphs[fontName] = Object.assign({}, tempGlyphs, formattedGlyphs[fontName]);\n                  }\n                }\n\n                const formattedStrings = formatVectorPdfStrings(scope.renderContext, page._pageInfo, viewport, documentStrings, formattedGlyphs);\n                scope.svf.strings = formattedStrings.strings;\n                scope.svf.stringBoxes = formattedStrings.stringBoxes;\n                scope.svf.stringAngles = formattedStrings.stringAngles;\n                scope.svf.stringCharWidths = formattedStrings.stringCharWidths;\n                scope.svf.stringPositions = formattedStrings.stringPositions;\n                scope.svf.stringHeights = formattedStrings.stringHeights;\n                scope.svf.stringWidths = formattedStrings.stringWidths;\n              }\n\n              scope.renderContext.finish();\n              scope.svf.minLineWidth = scope.renderContext.currentVbb.minLineWidth;\n              scope.svf.maxObjectNumber = scope.renderContext.maxDbId;\n              scope.onGeomLoadDone();\n\n              var t1 = performance.now();\n              const pdfLoadTime = t1 - t0;\n              console.log(\"PDF load time\", pdfLoadTime);\n\n              const firstPixelTime = scope.t1_firstPixel - t0;\n              console.log(\"First Pixel Time\", firstPixelTime);\n\n              const model = scope.model;\n              const geomList = model.getGeometryList();\n\n              const dataToTrack = {\n                load_time: scope.loadTime,\n                pdf_load_time: pdfLoadTime,\n                polygons: geomList.geomPolyCount,\n                fragments: model.getFragmentList().getCount(),\n                mem_usage: geomList.gpuMeshMemory,\n                time_to_first_pixel: firstPixelTime,\n                total_raster_pixels: (_model$getDocumentNod = model.getDocumentNode()) === null || _model$getDocumentNod === void 0 || (_model$getDocumentNod = _model$getDocumentNod.data) === null || _model$getDocumentNod === void 0 ? void 0 : _model$getDocumentNod.totalRasterPixels,\n                viewable_type: '2d',\n                url: scope.currentLoadPath,\n                urn: scope.svfUrn\n              };\n              avp.analytics.track('viewer.model.loaded', dataToTrack);\n\n              //These are needed in order to free the PDF loader context (it caches all PDF opcodes\n              //in a giant array). Ideally we will modify the pdf.js library to not accumulate opcodes\n              //that are already processed, so we don't spike memory at load time.\n              renderTask._canvas = null;\n            }).catch((err) => {\n              // Usually happens when the switching to another PDF page while\n              // the current one is still getting rendered.\n              avp.logger.log(err);\n            }).finally(() => {\n              scope._renderTask = null;\n              page.cleanup();\n              scope.cleanup();\n            });\n          });\n        });\n      });\n    }).catch((error) => {\n      return Promise.reject(error);\n    });\n  }\n\n  Promise.resolve().then(\n    () => {\n      if (options.bubbleNode && typeof options.bubbleNode.getRootNode().data.getPDF == \"function\" && options.bubbleNode.getRootNode().data.getPDF()) {\n        scope.pdf = options.bubbleNode.getRootNode().data.getPDF();\n        scope.loading = false;\n        renderPage(options.bubbleNode.data.page);\n      } else {\n        var pdfTask = _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.getDocument(params);\n        pdfTask.onProgress = (_ref2) => {let { loaded, total } = _ref2;\n          const percentLoaded = Math.round(loaded * 100 / total);\n          scope.viewer3DImpl.signalProgress(percentLoaded, av.ProgressState.LOADING);\n        };\n        // keep pdfTask reference for cleanup later\n        scope.pdfTask = pdfTask;\n\n        return pdfTask.promise.then((pdf) => {\n          scope.pdf = pdf;\n          scope.loading = false;\n          var pageNumber = options.page || parseInt(avp.getParameterByName(\"page\")) || 1;\n\n          if (scope.options && !scope.options.bubbleNode) {\n            var pdfMain = scope.createPDFDocument(pdf);\n            scope.options.bubbleNode = pdfMain.getRoot().children[pageNumber - 1];\n          }\n\n          return renderPage(pageNumber);\n        }).catch((error) => {\n          onSuccess && onSuccess(error);\n        });\n      }\n\n    }\n  );\n\n  return true;\n};\n\nPDFLoader.prototype.loadOnDemandFonts = function (page, fe) {\n  const commonObjs = page.commonObjs._objs;\n  const loadedFonts = {};\n  const loadPromises = [];\n  for (let name in commonObjs) {var _font$data;\n    const font = commonObjs[name];\n    if (font !== null && font !== void 0 && (_font$data = font.data) !== null && _font$data !== void 0 && _font$data.missingFile) {var _font$data2;\n      const fontName = font === null || font === void 0 || (_font$data2 = font.data) === null || _font$data2 === void 0 ? void 0 : _font$data2.name;\n      if (fontName) {\n        const fontDescriptor = fe.getOnDemandFont(fontName);\n        if (fontDescriptor && !loadedFonts[fontDescriptor.name]) {\n          loadPromises.push(fe.loadFont(fontDescriptor));\n          loadedFonts[fontDescriptor.name] = true;\n        }\n      }\n    }\n  }\n\n  if (loadPromises.length === 0) {\n    return;\n  }\n\n  return Promise.all(loadPromises);\n};\n\n\n/**\n * Loop all the operator command to detect whether it is a circle.\n */\nPDFLoader.prototype.detectCircle = function (page) {\n  const threshold = 0.001;\n  const magic = 4 / 3 * Math.tan(Math.PI / 8);\n  const magic2 = magic * magic;\n  let p1 = new THREE.Vector2();\n  let p2 = new THREE.Vector2();\n  let p3 = new THREE.Vector2();\n  let p4 = new THREE.Vector2();\n\n  function equal(a, b) {\n    return Math.abs(a - b) <= threshold;\n  }\n\n  function relativelyEqual(a, b) {\n    return a > 0 && b > 0 && equal(Math.abs(a - b) / a, threshold);\n  }\n\n  /**\n   *  if it is a primitive circle\n   *  it will have a 13, 15, 15, 15, 15, [18]\n   *  Reference: https://stackoverflow.com/questions/1734745/how-to-create-circle-with-b%C3%A9zier-curves\n   * @param {*} fnArray\n   * @param {*} argsArray\n   */\n  function checkPattern(fnArray, argsArray) {\n    if ((fnArray.length == 5 || fnArray.length == 6) && argsArray.length == 26) {\n      if (fnArray[0] == 13 && fnArray[1] == 15 && fnArray[2] == 15 && fnArray[3] == 15 && fnArray[4] == 15 && (fnArray[5] == 18 || fnArray[5] == undefined)) {\n        // do the math to figure out whether it is a circle\n        for (let i = 0; i < argsArray.length - 6; i += 6) {\n          p1.set(argsArray[i], argsArray[i + 1]);\n          p2.set(argsArray[i + 2], argsArray[i + 3]);\n          p3.set(argsArray[i + 4], argsArray[i + 5]);\n          p4.set(argsArray[i + 6], argsArray[i + 7]);\n          if (!checkQuaterCircle(p1, p2, p3, p4)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function checkQuaterCircle(p1, p2, p3, p4) {\n    let p12 = p2.clone().sub(p1);\n    let p43 = p3.clone().sub(p4);\n    let l12 = p12.lengthSq();\n    let l43 = p43.lengthSq();\n    let radius = p4.distanceToSquared(p1) / 2;\n\n    let result = l12 > 0 && l43 > 0 && relativelyEqual(l12, l43) &&\n    equal(p12.normalize().dot(p43.normalize()), 0) &&\n    equal(l12 / radius, magic2) &&\n    equal(l43 / radius, magic2);\n\n    return result;\n  }\n\n  return this.getOperatorList(page).then((ops) => {\n    let circleInfo = {};\n    for (let i = 0; i < ops.fnArray.length; i++) {\n      if (ops.fnArray[i] == _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.constructPath) {\n        // need try to detect whether there is circle in this command\n        let fn1 = ops.argsArray[i][0];\n        let args1 = ops.argsArray[i][1];\n\n        if (checkPattern(fn1, args1)) {\n          p1.set(args1[0], args1[1]);\n          p2.set(args1[6], args1[7]);\n          p3.set(args1[12], args1[13]);\n          p4.set(args1[18], args1[19]);\n\n          let p12 = p2.clone().sub(p1);\n          let p23 = p3.clone().sub(p2);\n\n          let l12 = p12.lengthSq();\n          let l23 = p23.lengthSq();\n          let l34 = p3.distanceToSquared(p4);\n          let l41 = p4.distanceToSquared(p1);\n\n          // check the 4 points is a square\n          if (relativelyEqual(l12, l23) && relativelyEqual(l34, l41) && relativelyEqual(l12, l41) && equal(p12.normalize().dot(p23.normalize()), 0)) {\n            let x = 0,y = 0;\n            for (var k = 0; k < args1.length - 6; k += 6) {\n              x += args1[k];\n              y += args1[k + 1];\n            }\n\n            circleInfo[i] = [x / 4, y / 4];\n          }\n        }\n      }\n    }\n\n    this.circleInfo = circleInfo;\n  });\n};\n\n\nPDFLoader.prototype.processReceivedMesh = function (mdata) {\n\n  //Find all fragments that instance this mesh\n  var meshid = mdata.packId + \":\" + mdata.meshIndex;\n\n  var svf = this.svf;\n  var fragments = svf.fragments;\n\n  var fragIndexes = fragments.mesh2frag[meshid];\n  if (fragIndexes === undefined) {\n    avp.logger.warn(\"Mesh \" + meshid + \" was not referenced by any fragments.\");\n    return;\n  }\n  if (!Array.isArray(fragIndexes))\n  fragIndexes = [fragIndexes];\n\n  var rm = this.model;\n\n  // Background dbid is -1. Hide it when hideBackground is set.\n  // This line has to be before calling meshToGeometry, because mdata.mesh is set to null inside of it.\n  if (mdata.mesh.dbIds[-1] && this.options.hideBackground) {\n    rm.changePaperVisibility(false);\n  }\n\n  //Convert the received mesh to THREE buffer geometry\n  const geometry = avp.BufferGeometryUtils.meshToGeometry(mdata);\n\n\n  // Add geometry to ensure PDF data is taken into account for gpu memory limits\n  const geomId = rm.getGeometryList().addGeometry(geometry, fragIndexes.length, mdata.meshIndex + 1);\n\n  const polyCount = avp.getPolygonCount(geometry);\n\n  //For each fragment, add a mesh instance to the renderer\n  for (var i = 0; i < fragIndexes.length; i++) {\n    var fragId = 0 | fragIndexes[i];\n\n    //We get the matrix from the fragments and we set it back there\n    //with the activateFragment call, but this is to maintain the\n    //ability to add a plain THREE.Mesh -- otherwise it could be simpler\n    rm.getFragmentList().getOriginalWorldMatrix(fragId, this.tmpMatrix);\n\n    if (this.options.placementTransform) {\n      this.tmpMatrix = new THREE.Matrix4().multiplyMatrices(this.options.placementTransform, this.tmpMatrix);\n    }\n\n    var materialId = fragments.materials[fragId].toString();\n\n    if (fragments.polygonCounts)\n    fragments.polygonCounts[fragId] = polyCount;\n\n    var m = this.viewer3DImpl.setupMesh(this.model, geometry, materialId, this.tmpMatrix);\n    rm.activateFragment(fragId, m);\n  }\n\n  //don't need this mapping anymore.\n  fragments.mesh2frag[meshid] = null;\n\n  //Repaint and progress reporting\n  fragments.numLoaded += fragIndexes.length;\n\n  this.viewer3DImpl.signalNewGeometryAdded(geomId, this.model);\n\n  if (!this.t1_firstPixel) {\n    this.t1_firstPixel = performance.now();\n  }\n\n  //repaint every once in a while -- more initially, less as the load drags on.\n  if (fragments.numLoaded > fragments.nextRepaint) {\n    //avp.logger.log(\"num loaded \" + fragments.numLoaded);\n    svf.numRepaints++;\n    fragments.nextRepaint += 6 * Math.pow(1.75, svf.numRepaints);\n    this.viewer3DImpl.api.dispatchEvent({ type: av.LOADER_REPAINT_REQUEST_EVENT, loader: this, model: this.model });\n  }\n};\n\nPDFLoader.prototype.processReceivedMesh2D = function (mesh, mindex) {\n\n  var mdata = { mesh: mesh, is2d: true, packId: \"0\", meshIndex: mindex };\n\n  var meshId = \"0:\" + mindex;\n\n  var frags = this.svf.fragments;\n\n  //Remember the list of all dbIds referenced by this mesh.\n  //In the 2D case this is 1->many (1 frag = many dbIds) mapping instead of\n  // 1 dbId -> many fragments like in the SVF 3D case.\n  var dbIds = Object.keys(mdata.mesh.dbIds).map(function (item) {return parseInt(item);});\n  frags.fragId2dbId[mindex] = dbIds;\n\n  //TODO: dbId2fragId is not really necessary if we have a good instance tree for the 2D drawing (e.g. Revit, AutoCAD)\n  //so we can get rid of this mapping if we can convert Viewer3DImpl.highlightFragment to use the same logic for 2D as for 3D.\n  for (var j = 0; j < dbIds.length; j++) {\n    var dbId = dbIds[j];\n    var fragIds = frags.dbId2fragId[dbId];\n    if (Array.isArray(fragIds))\n    fragIds.push(mindex);else\n    if (typeof fragIds !== \"undefined\") {\n      frags.dbId2fragId[dbId] = [fragIds, mindex];\n    } else\n    {\n      frags.dbId2fragId[dbId] = mindex;\n    }\n  }\n\n  const modelFrags = this.model.getFragmentList();\n\n  frags.mesh2frag[meshId] = mindex;\n  mesh.material.modelScale = this.modelScale;\n  mesh.material.doNotCut = this.options.doNotCut || (modelFrags === null || modelFrags === void 0 ? void 0 : modelFrags.getDoNotCut());\n  if (modelFrags !== null && modelFrags !== void 0 && modelFrags.viewBounds) {\n    const bounds = modelFrags.viewBounds;\n    mesh.material.viewportBounds = new THREE.Vector4(bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y);\n  }\n\n  frags.materials[mindex] = this.viewer3DImpl.matman().create2DMaterial(this.model, mesh.material);\n\n  frags.length++;\n\n  this.processReceivedMesh(mdata);\n\n};\n\nPDFLoader.prototype.onModelRootLoadDone = function (svf) {\n\n  //In the 2d case we create and build up the fragments mapping\n  //on the receiving end.\n  svf.fragments = {};\n  svf.fragments.mesh2frag = {};\n  svf.fragments.materials = [];\n  svf.fragments.fragId2dbId = [];\n  svf.fragments.dbId2fragId = [];\n  svf.fragments.length = 0;\n  svf.fragments.initialized = true;\n\n\n  svf.geomPolyCount = 0;\n  svf.instancePolyCount = 0;\n  svf.fragments.numLoaded = 0;\n  svf.fragments.nextRepaint = 5;\n  svf.meshCount = 0;\n\n  svf.nextRepaintPolys = 10000;\n  svf.numRepaints = 0;\n\n  svf.urn = this.svfUrn;\n  svf.acmSessionId = this.acmSessionId;\n\n  svf.basePath = \"\";\n  var lastSlash = this.currentLoadPath.lastIndexOf(\"/\");\n  if (lastSlash !== -1)\n  svf.basePath = this.currentLoadPath.substr(0, lastSlash + 1);\n\n  svf.loadOptions = this.options;\n\n  var t1 = Date.now();\n  avp.logger.log(\"PDF root load: \" + (t1 - this.t0));\n\n  this.t1 = t1;\n\n  //The BBox object loses knowledge of its\n  //type when going across the worker thread boundary...\n  svf.bbox = new THREE.Box3().copy(svf.bbox);\n  svf.modelSpaceBBox = svf.bbox.clone();\n\n  if (svf.placementTransform) {\n    svf.bbox.applyMatrix4(svf.placementTransform);\n  }\n\n  //Create the API Model object and its render proxy\n  var model = this.model = new av.Model(svf);\n  model.loader = this;\n\n  model.initialize();\n\n  // Update viewport bounds according to model clipped bounds. (See LmvCanvasContext)\n  model.setViewportBounds(this.viewer3DImpl.matman(), svf.modelSpaceBBox);\n\n  if (!this.options.skipPropertyDb) {\n    this.svf.propDbLoader = new avp.PropDbLoader(this.sharedDbPath, this.model, this.viewer3DImpl.api);\n  }\n\n  avp.logger.log(\"scene bounds: \" + JSON.stringify(svf.bbox));\n\n  var metadataStats = {\n    category: \"metadata_load_stats\",\n    urn: svf.urn,\n    layers: svf.layerCount\n  };\n  avp.logger.track(metadataStats);\n\n  this.viewer3DImpl.setDoNotCut(model, !!this.options.doNotCut);\n\n  this.viewer3DImpl.signalProgress(5, av.ProgressState.ROOT_LOADED, model);\n};\n\n\nPDFLoader.prototype.onGeomLoadDone = function () {\n  this.svf.loadDone = true;\n\n  // Don't need these anymore\n  this.svf.fragments.entityIndexes = null;\n  this.svf.fragments.mesh2frag = null;\n\n  var t2 = Date.now();\n  var msg = \"Fragments load time: \" + (t2 - this.t1);\n  this.loadTime = t2 - this.t0;\n\n  if (!this.options.skipPropertyDb) {\n    this.loadPropertyDb();\n  }\n\n  avp.logger.log(msg);\n\n  var modelStats = {\n    category: \"model_load_stats\",\n    is_f2d: true,\n    has_prism: this.viewer3DImpl.matman().hasPrism,\n    load_time: this.loadTime,\n    geometry_size: this.model.getGeometryList().geomMemory,\n    meshes_count: this.model.getGeometryList().getCount(),\n    urn: this.svfUrn\n  };\n  avp.logger.track(modelStats, true);\n\n  this.viewer3DImpl.onLoadComplete(this.model);\n};\n\nPDFLoader.prototype.loadPropertyDb = function () {\n\n  if (this.svf.propDbLoader) {\n    this.svf.propDbLoader.load();\n  }\n};\n\nPDFLoader.prototype.is3d = function () {\n  return false;\n};\n\nPDFLoader.prototype.cleanup = function () {\n  if (this.renderContext) {\n    this.renderContext.destroy();\n    this.renderContext = null;\n  }\n\n  if (this.pdf) {\n    this.pdf.cleanup();\n  }\n};\n\nPDFLoader.prototype.getOperatorList = function (page) {\n  // Use the same 'display' intent for everything, in order to save memory.\n  return page.getOperatorList('display');\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNDLFlBQVksQ0FBQytpQixJQUFJLENBQUMsQ0FBQztFQUNoQztBQUNKLENBQUM7O0FBRURubUIsU0FBUyxDQUFDdUIsU0FBUyxDQUFDNmtCLElBQUksR0FBRyxZQUFZO0VBQ25DLE9BQU8sS0FBSztBQUNoQixDQUFDOztBQUVEcG1CLFNBQVMsQ0FBQ3VCLFNBQVMsQ0FBQ2djLE9BQU8sR0FBRyxZQUFXO0VBQ3JDLElBQUksSUFBSSxDQUFDNU8sYUFBYSxFQUFFO0lBQ3BCLElBQUksQ0FBQ0EsYUFBYSxDQUFDbEwsT0FBTyxDQUFDLENBQUM7SUFDNUIsSUFBSSxDQUFDa0wsYUFBYSxHQUFHLElBQUk7RUFDN0I7O0VBRUEsSUFBRyxJQUFJLENBQUNsTixHQUFHLEVBQUU7SUFDVCxJQUFJLENBQUNBLEdBQUcsQ0FBQzhiLE9BQU8sQ0FBQyxDQUFDO0VBQ3RCO0FBQ0osQ0FBQzs7QUFFRHZkLFNBQVMsQ0FBQ3VCLFNBQVMsQ0FBQ2tGLGVBQWUsR0FBRyxVQUFVNUQsSUFBSSxFQUFFO0VBQ2xEO0VBQ0EsT0FBT0EsSUFBSSxDQUFDNEQsZUFBZSxDQUFDLFNBQVMsQ0FBQztBQUMxQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQXV0b2Rlc2suRXh0ZW5zaW9ucy8uL2V4dGVuc2lvbnMvUERGL1BERkxvYWRlci5qcz8zMzM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFBERkpTIGZyb20gXCJAYWRzay9wZGZqcy1kaXN0XCI7XG5cbmltcG9ydCB7IHRoZUZvbnRFbmdpbmUgfSBmcm9tIFwiLi9mb250LWVuZ2luZVwiO1xuXG5cbi8vIERlbGF5LWluaXQgdmFyaWFibGVzIHRoYXQgcmVxdWlyZSBBdXRvZGVzay5FeHRlbnNpb24uQ29tcEdlb21cbmxldCBMbXZDYW52YXNDb250ZXh0ID0gbnVsbDtcbmxldCBpc1JlZiA9IG51bGw7XG5sZXQgcmVmS2V5ID0gbnVsbDtcbmNvbnN0IE1PQklMRV9ESU1fQ0FQID0gMjA0ODtcbmNvbnN0IEZJUkVGT1hfRElNX0NBUCA9IDQwOTY7XG5jb25zdCBERUZBVUxUX0RJTV9DQVAgPSA4MTkyO1xuXG5jb25zdCBpbml0Q29tcEdlb20gPSAoKSA9PiB7XG4gICAgTG12Q2FudmFzQ29udGV4dCA9IEF1dG9kZXNrLkV4dGVuc2lvbnMuQ29tcEdlb20uTG12Q2FudmFzQ29udGV4dDtcbiAgICBpc1JlZiAgPSBMbXZDYW52YXNDb250ZXh0LmlzUmVmO1xuICAgIHJlZktleSA9IExtdkNhbnZhc0NvbnRleHQucmVmS2V5O1xufTtcblxuLy8gTE1WLTUwNjAgV2hlbiB1c2VyIGNoYW5nZSBtb2RlbCwgd2UgZG9uJ3Qga25vdyB0aGUgaW50ZW50IHdoeT9cbi8vIFVzZXIgbWlnaHQgbmF2aWdhdGUgdG8gYW5vdGhlciBwYWdlIGluIHRoZSBzYW1lIFBERiBvciB0cnlpbmcgdG8gbG9hZCBhIG5ldyBkaWZmZXJlbnQgbW9kZWxcbi8vIEluIG9yZGVyIHRvIHNhdmUgbG9hZGluZyB0aW1lLCB3ZSBuZWVkIHRvIHVzZSB0aGlzIG9iamVjdCB0cnkgdG8gZGVmZXIgdGhlIGRlc3Ryb3kgbWV0aG9kIG9mIHByZXZpb3VzIFBERiB3b3JrZXJcbi8vIFRoZW4gd2UgY2FuIHRyeSB0byBhdm9pZCBtZW1vcnkgbGVhayBpbiB0aGUgbWVhbnRpbWUgdG8gbWFrZSBpdCBtdWNoIGZhc3RlciB0byBuYXZpZ2F0ZSBiZXR3ZWVuIHBhZ2VzXG5jb25zdCBQREZXb3JraW5nUmVmZXJlbmNlTWFwID0ge307XG5jb25zdCBEZWZmZXJlZERlc3Ryb3lUaW1lID0gMzAwMDsgLy8gMyBzZWNvbmRzXG5cbmNvbnN0IGF2ID0gQXV0b2Rlc2suVmlld2luZztcbmNvbnN0IGF2cCA9IGF2LlByaXZhdGU7XG5cbi8qKiBAY29uc3RydWN0b3IgKi9cbmV4cG9ydCBmdW5jdGlvbiBQREZMb2FkZXIocGFyZW50KSB7XG5cbiAgICBpbml0Q29tcEdlb20oKTtcblxuICAgIHRoaXMuaXNQZGZMb2FkZXIgPSB0cnVlOyAvLyBGb3IgUUEgb25seVxuICAgIHRoaXMudmlld2VyM0RJbXBsID0gcGFyZW50O1xuICAgIHRoaXMuc2V0R2xvYmFsTWFuYWdlcih0aGlzLnZpZXdlcjNESW1wbC5nbG9iYWxNYW5hZ2VyKTtcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnRtcE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgICB0aGlzLmxvZ2dlciA9IGF2cC5sb2dnZXI7XG4gICAgdGhpcy5sb2FkVGltZSA9IDA7XG4gICAgdGhpcy5ub3RpZmllc0ZpcnN0UGl4ZWwgPSB0cnVlO1xuXG4gICAgLy8gdGltZSBzdGFtcCB3aGVuIHRoZSBmaXJzdCBtZXNoIHdhcyByZWNlaXZlZFxuICAgIHRoaXMudDFfZmlyc3RQaXhlbCA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuZHRvciA9IHRoaXMuZHRvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMudmlld2VyM0RJbXBsLmFwaS5hZGRFdmVudExpc3RlbmVyKGF2LlZJRVdFUl9VTklOSVRJQUxJWkVELCB0aGlzLmR0b3IsIHsgb25jZTogdHJ1ZSB9KTtcbn1cblxuYXYuR2xvYmFsTWFuYWdlck1peGluLmNhbGwoUERGTG9hZGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQnViYmxlTm9kZSBTdHJ1Y3R1cmUgZm9yIFBERiBkYXRhIHdpbGwgaGVscCB0byBkbyBwYWdlIG5hdmlnYXRpb25cbiAqIEBwYXJhbSB7UERGfSBwZGYgUERGIG9iamVjdCBmcm9tIHBkZi5qc1xuICovXG5QREZMb2FkZXIucHJvdG90eXBlLmNyZWF0ZVBERkRvY3VtZW50ID0gZnVuY3Rpb24gKHBkZikge1xuICAgIHZhciBudW1QYWdlcyA9IHBkZi5udW1QYWdlcztcbiAgICB2YXIgZ3VpZCA9IHBkZi5maW5nZXJwcmludDtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIC8vIExldCB0aGUgZ2VuZXJhdG9yIHN0YXkgYWxvbmcgd2l0aCBkb2N1bWVudCBsaWZlY3ljbGUsIGl0IHdpbGwgZ2l2ZSB1cyBhIGNoYW5jZSB0byBtYXhpbXVtIHRoZSBjYWNoaW5nXG4gICAgLy8gdG8gZ2V0IHRoZSBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdmFyIHBhcmVudCA9IHtcbiAgICAgICAgZ3VpZDogZ3VpZCxcbiAgICAgICAgdHlwZTogXCJkZXNpZ25cIixcbiAgICAgICAgXCJoYXNUaHVtYm5haWxcIjogXCJmYWxzZVwiLFxuICAgICAgICBcInByb2dyZXNzXCI6IFwiY29tcGxldGVcIixcbiAgICAgICAgXCJzdGF0dXNcIjogXCJzdWNjZXNzXCIsXG4gICAgICAgIFwic3VjY2Vzc1wiOiBcIjEwMCVcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiUERGXCIsXG4gICAgICAgIFwiaXNWZWN0b3JQREZcIjogdHJ1ZSxcbiAgICAgICAgXCJyb2xlXCI6IFwidmlld2FibGVcIixcbiAgICAgICAgdG90YWxSYXN0ZXJQaXhlbHM6IDAsXG4gICAgICAgIGdldFBERjogZnVuY3Rpb24gKCkgeyAgICAvLyB0aGlzIGNhbiBhdm9pZCBpc3N1ZSBpbiBzZWFyaWxpemF0aW9uXG4gICAgICAgICAgICBpZiAocGRmICYmIHBkZi5fdHJhbnNwb3J0ICYmICFwZGYuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGRmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG51bVBhZ2VzOyBpKyspIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICBndWlkOiBndWlkICsgXCIvXCIgKyBpLFxuICAgICAgICAgICAgdHlwZTogXCJnZW9tZXRyeVwiLFxuICAgICAgICAgICAgcm9sZTogXCIyZFwiLFxuICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIHByb2dyZXNzOiBcImNvbXBsZXRlXCIsXG4gICAgICAgICAgICB2aWV3YWJsZUlEOiBndWlkICsgXCIvXCIgKyBpLFxuICAgICAgICAgICAgbmFtZTogYXYuaTE4bi50cmFuc2xhdGUoXCJQYWdlICUoaSlcIiwgeyBpIH0pLFxuICAgICAgICAgICAgcGFnZTogaSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgICAgIHJvbGU6IGF2LkJ1YmJsZU5vZGUuUERGX1BBR0VfTk9ERS5yb2xlLFxuICAgICAgICAgICAgICAgIHBhZ2U6IGksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZXNvdXJjZVwiLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IFwiY29tcGxldGVcIixcbiAgICAgICAgICAgICAgICB1cm46IG1lLnN2ZlVyblxuICAgICAgICAgICAgfV1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGFyZW50LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIG5ldyBhdi5Eb2N1bWVudChwYXJlbnQpO1xufTtcblxuXG5QREZMb2FkZXIucHJvdG90eXBlLmR0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3ZmICYmIHRoaXMuc3ZmLnByb3BEYkxvYWRlcikge1xuICAgICAgICB0aGlzLnN2Zi5wcm9wRGJMb2FkZXIuZHRvcigpO1xuICAgICAgICB0aGlzLnN2Zi5wcm9wRGJMb2FkZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudExvYWRQYXRoID0gbnVsbDtcbiAgICB0aGlzLmlzZjJkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmlld2VyM0RJbXBsLmFwaS5yZW1vdmVFdmVudExpc3RlbmVyKGF2LlZJRVdFUl9VTklOSVRJQUxJWkVELCB0aGlzLmR0b3IpO1xuXG4gICAgaWYgKHRoaXMucGRmKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBmbGFnIHN5bmNocm9uaXplZCBoZXJlXG4gICAgICAgIGRlbGV0ZSBQREZXb3JraW5nUmVmZXJlbmNlTWFwW3RoaXMucGRmLmZpbmdlcnByaW50XTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgUERGIGlzIHVzZWQgaW4gRGVmZmVyZWREZXN0cm95VGltZSB0aW1lLCB0aGUgUERGIHdpbGwgYmUgc3RpbGwgYWxpdmVcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgcGRmIHdvcmtlciBpcyBnb25uYSBiZSBkZXN0cm95ZWQsIGFuZCB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gbG9hZCBhZ2Fpbi5cbiAgICAgICAgICAgIGlmICghUERGV29ya2luZ1JlZmVyZW5jZU1hcFt0aGlzLnBkZi5maW5nZXJwcmludF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBkZi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZGYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBEZWZmZXJlZERlc3Ryb3lUaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVuZGVyVGFzaykge1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXNrLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXNrID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnN2ZiA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgICBhdnAubG9nZ2VyLmxvZyhcIlBERkxvYWRlciBkZXN0cm95XCIpO1xufTtcblxuXG5QREZMb2FkZXIucHJvdG90eXBlLmxvYWRGaWxlID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMsIG9uU3VjY2Vzcywgb25Xb3JrZXJTdGFydCkge1xuICAgIGlmICh0aGlzLmxvYWRpbmcpIHtcbiAgICAgICAgYXZwLmxvZ2dlci5sb2coXCJMb2FkaW5nIG9mIFBERiBhbHJlYWR5IGluIHByb2dyZXNzLiBJZ25vcmluZyBuZXcgcmVxdWVzdC5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcblxuICAgIGNvbnN0IHVybklkeCA9IHBhdGguaW5kZXhPZigndXJuOicpO1xuICAgIGlmICh1cm5JZHggIT09IC0xKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgdXJuOmFkc2sudmlld2luZzpmb28uYmFyLndoYXRldmVyanVua3Mgb3V0IG9mIHRoZSBwYXRoIFVSTCBhbmQgYmluZCBpdCB0byBsb2dnZXIuXG4gICAgICAgIC8vIEZyb20gbm93IG9uLCB3ZSBjYW4gc2VuZCBsb2dzIHRvIHZpZXdpbmcgc2VydmljZSwgYW5kIGxvZ3MgYXJlIGdyb3VwZWQgYnkgdXJuIHRvIG1ha2UgU3BsdW5rIHdvcmsuXG4gICAgICAgIHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQocGF0aCk7XG4gICAgICAgIGNvbnN0IHVybiA9IHBhdGguc3Vic3RyKHVybklkeCwgcGF0aC5zdWJzdHIodXJuSWR4KS5pbmRleE9mKCcvJykpO1xuICAgICAgICBhdnAubG9nZ2VyLmxvZyhcIkV4dHJhY3RlZCBVUk46IFwiICsgdXJuKTtcblxuICAgICAgICAvLyBFeHRyYWN0IHVybihqdXN0IGJhc2U2NCBjb2RlKVxuICAgICAgICBjb25zdCBfaW5kZXggPSB1cm4ubGFzdEluZGV4T2YoJzonKTtcbiAgICAgICAgdGhpcy5zdmZVcm4gPSB1cm4uc3Vic3RyKF9pbmRleCArIDEpO1xuXG4gICAgICAgIC8vVjIgb25seSBhY2NlcHRzIFVSTCBlbmNvZGVkIHBhdGhzXG4gICAgICAgIGNvbnN0IHFJZHggPSBwYXRoLmluZGV4T2YoXCI/XCIsIHVybklkeCk7XG4gICAgICAgIGlmIChxSWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgdXJuSWR4KSArIGVuY29kZVVSSUNvbXBvbmVudChwYXRoLnNsaWNlKHVybklkeCwgcUlkeCkpICsgcGF0aC5zbGljZShxSWR4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHVybklkeCkgKyBlbmNvZGVVUklDb21wb25lbnQocGF0aC5zbGljZSh1cm5JZHgpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3ZmVXJuID0gcGF0aDtcbiAgICB9XG5cbiAgICB0aGlzLnNoYXJlZERiUGF0aCA9IG9wdGlvbnMuc2hhcmVkUHJvcGVydHlEYlBhdGg7XG4gICAgdGhpcy5jdXJyZW50TG9hZFBhdGggPSBwYXRoO1xuICAgIHRoaXMuYWNtU2Vzc2lvbklkID0gb3B0aW9ucy5hY21TZXNzaW9uSWQ7XG5cbiAgICAvL1RoaXMgaXMgZG9uZSB0byBhdm9pZCBDT1JTIGVycm9ycyBvbiBjb250ZW50IHNlcnZlZCBmcm9tIHByb3h5IG9yIGJyb3dzZXIgY2FjaGVcbiAgICAvL1RoZSBjYWNoZSB3aWxsIHJlc3BvbmQgd2l0aCBhIHByZXZpb3VzbHkgcmVjZWl2ZWQgcmVzcG9uc2UsIGJ1dCB0aGUgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXG4gICAgLy9yZXNwb25zZSBoZWFkZXIgbWlnaHQgbm90IG1hdGNoIHRoZSBjdXJyZW50IE9yaWdpbiBoZWFkZXIgKGUuZy4gbG9jYWxob3N0IHZzLiBkZXZlbG9wZXIuYXBpLmF1dG9kZXNrLmNvbSlcbiAgICAvL3doaWNoIHdpbGwgY2F1c2UgYSBDT1JTIGVycm9yIG9uIHRoZSBzZWNvbmQgcmVxdWVzdCBmb3IgdGhlIHNhbWUgcmVzb3VyY2UuXG4gICAgdGhpcy5xdWVyeVBhcmFtcyA9IFtcbiAgICAgICAgdGhpcy5hY21TZXNzaW9uSWQgJiYgYGFjbXNlc3Npb249JHt0aGlzLmFjbVNlc3Npb25JZH1gLFxuICAgICAgICBhdi5lbmRwb2ludC5nZXRRdWVyeVBhcmFtcygpLFxuICAgIF0uZmlsdGVyKHAgPT4gcCkuam9pbignJicpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGxhY2VtZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIC8vTk9URTogVGhlIHNjYWxlIG9mIHRoZSBwbGFjZW1lbnQgdHJhbnNmb3JtIGlzIG5vdCBhbHdheXMgc3VmZmljaWVudCB0b1xuICAgICAgICAvL2RldGVybWluZSB0aGUgY29ycmVjdCBzY2FsZSBmb3IgbGluZSB3aWR0aHMuIFRoaXMgaXMgYmVjYXVzZSB3aGVuIGEgMkQgbW9kZWwgKGluIGluY2hlcykgaXNcbiAgICAgICAgLy9sb2FkZWQgaW50byBhIDNkIHNjZW5lIGluIGZlZXQsIHRoZSB0cmFuc2Zvcm0gaW5jbHVkZXMgYWxsIHRoZSBzY2FsaW5nIG5lZWRlZCB0byBnZXQgaW50byBmZWV0XG4gICAgICAgIC8vYnV0IHRoZSBtb2RlbCBzcGFjZSBsaW5lIHdlaWdodCBmb3IgdGhlIGRyYXdpbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGRyYXdpbmcgaXRzZWxmLCBzbyBhbiBleHRyYVxuICAgICAgICAvL2ZhY3RvciBvZiAxMiB3b3VsZCBiZSBuZWVkZWQgaW4gc3VjaCBjYXNlIHRvIGNhbmNlbCBvdXQgdGhlIDEvMTIgbmVlZGVkIGZvciBpbmNoLT5mb290LlxuICAgICAgICAvL1RoaXMgY291bGQgcHJvYmFibHkgYmUgYXV0b21hdGljYWxseSBkZXJpdmVkLCBidXQgaW4gYW4gZXJyb3IgcHJvbmUgd2F5LCBzbyBJJ20gbGVhdmluZyBpdFxuICAgICAgICAvL3VwIHRvIHRoZSBhcHBsaWNhdGlvbiBsYXllciB0aGF0IGRvZXMgdGhlIG1vZGVsIGFnZ3JlZ2F0aW9uIHRvIHBhc3MgaW4gdGhlIHJpZ2h0IG1vZGVsIHNjYWxlIGFzIGFuIG9wdGlvbi5cbiAgICAgICAgdGhpcy5tb2RlbFNjYWxlID0gdGhpcy5vcHRpb25zLm1vZGVsU2NhbGUgfHwgdGhpcy5vcHRpb25zLnBsYWNlbWVudFRyYW5zZm9ybS5nZXRNYXhTY2FsZU9uQXhpcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW9kZWxTY2FsZSA9IHRoaXMub3B0aW9ucy5tb2RlbFNjYWxlIHx8IDE7XG4gICAgfVxuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHNjb3BlLmxvYWRGeWRvQ0IocGF0aCwgb3B0aW9ucywgb25TdWNjZXNzLCBvbldvcmtlclN0YXJ0KTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuUERGTG9hZGVyLnByb3RvdHlwZS5nZXREb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJ1YmJsZU5vZGUuZ2V0Um9vdE5vZGUoKS5kYXRhO1xufTtcblxuUERGTG9hZGVyLnByb3RvdHlwZS5nZXRGb250R2VuZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdlcjNESW1wbC5hcGkubG9hZEV4dGVuc2lvbihcIkF1dG9kZXNrLk1TREZcIikudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvciA9IG5ldyBBdXRvZGVzay5NU0RGLkdlbmVyYXRvcigpO1xuICAgICAgICBnZW5lcmF0b3Iuc2V0R2xvYmFsTWFuYWdlcih0aGlzLmdsb2JhbE1hbmFnZXIpO1xuICAgICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH0pO1xufTtcblxuUERGTG9hZGVyLnByb3RvdHlwZS5jcmVhdGVGb250QXRsYXMgPSBmdW5jdGlvbiAocGFnZSwgY2FjaGVLZXkpIHtcbiAgICBpZiAoUERGTG9hZGVyLmVuYWJsZU1TREZUZXh0KSB7XG4gICAgICAgIC8vIEZldGNoaW5nIHRoZSBvcGVyYXRpb24gbGlzdCB3aWxsIHRyaWdnZXIgdGhlIGZvbnQgbG9hZGluZ1xuICAgICAgICAvLyBUaGUgbG9hZGVkIGZvbnQgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyIGluIG5leHQgdGlja1xuICAgICAgICAvLyBTbyB3ZSBuZWVkIHVzZSB0aW1lb3V0IHRvIGxldCB0aGUgYXBwIGNvbnRpbnVlXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdldE9wZXJhdG9yTGlzdChwYWdlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRGb250R2VuZXJhdG9yKCkudGhlbigoZ2VuZXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3IuY3JlYXRlRm9udEF0bGFzRm9yUERGKHBhZ2UsIGNhY2hlS2V5KS50aGVuKChmb250QXRsYXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZvbnRBdGxhcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbn07XG5cblBERkxvYWRlci5wcm90b3R5cGUuZXZhbHVhdGVQYWdlTGluZVN0eWxlcyA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRPcGVyYXRvckxpc3QocGFnZSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBsZXQgdyA9IDA7XG4gICAgICAgIGxldCBjYWNoZVNldCA9IG5ldyBTZXQoKTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS5mbkFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZihkYXRhLmZuQXJyYXlbaV0gPT0gUERGSlMuT1BTLnNldERhc2gpIHtcbiAgICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgodywgZGF0YS5hcmdzQXJyYXlbaV1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gZGF0YS5hcmdzQXJyYXlbaV0uam9pbihcIi9cIik7XG4gICAgICAgICAgICAgICAgY2FjaGVTZXQuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaCA9IGNhY2hlU2V0LnNpemUgKyAxO1xuICAgICAgICB0aGlzLnBhZ2VMaW5lU3R5bGVQYXJhbXMgPSB7XG4gICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgIGhlaWdodDogaFxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxuUERGTG9hZGVyLnByb3RvdHlwZS5kZXRlY3RTbWFsbEltYWdlU2VxdWVuY2VzID0gZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICBjb25zdCBNQVhfT1BfRElTVEFOQ0UgPSAxMjtcbiAgICBjb25zdCBNSU5fT1BTID0gNSpNQVhfT1BfRElTVEFOQ0U7XG4gICAgY29uc3QgTUFYX1BBR0VfVU5JVF9ESVNUQU5DRSA9IDEwMDtcblxuICAgIC8vY29uc29sZS50aW1lKFwiZGV0ZWN0U21hbGxJbWFnZVNlcXVlbmNlc1wiKTtcbiAgICByZXR1cm4gdGhpcy5nZXRPcGVyYXRvckxpc3QocGFnZSkudGhlbigoZGF0YSkgPT4ge1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzU21hbGxJbWFnZShpbmRleCkge1xuICAgICAgICAgICAgY29uc3Qgb3AgPSBkYXRhLmZuQXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG9wID09PSBQREZKUy5PUFMucGFpbnRKcGVnWE9iamVjdCB8fCBvcCA9PT0gUERGSlMuT1BTLnBhaW50SW1hZ2VYT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdyA9IGRhdGEuYXJnc0FycmF5W2luZGV4XVsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gZGF0YS5hcmdzQXJyYXlbaW5kZXhdWzJdO1xuICAgICAgICAgICAgICAgIHJldHVybiAodyA8PSAyIHx8IGggPD0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3AgPT09IFBERkpTLk9QUy5wYWludEltYWdlTWFza1hPYmplY3QgfHwgb3AgPT09IFBERkpTLk9QUy5wYWludElubGluZUltYWdlWE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHcgPSBkYXRhLmFyZ3NBcnJheVtpbmRleF1bMF0ud2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgaCA9IGRhdGEuYXJnc0FycmF5W2luZGV4XVswXS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh3IDw9IDIgfHwgaCA8PSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmRTZXF1ZW5jZVN0YXJ0KGluZGV4KSB7XG4gICAgICAgICAgICAvLyBzY2FuIGJhY2t3YXJkcyBmb3IgYXQgbW9zdCBNQVhfT1BfRElTVEFOQ0Ugb3BzIGFuZCBmaW5kIHRoZSBmaXJzdCBQREZKUy5PUFMuc2F2ZVxuICAgICAgICAgICAgLy8gb24gdGhlIHdheSwgbm8gUERGSlMuT1BTLnJlc3RvcmUgb3IgYW55dGhpbmcgdGV4dC1yZWxhdGVkIG11c3QgYmUgZm91bmRcbiAgICAgICAgICAgIC8vIHRoaXMgbG9naWMgaXMgc3VwcG9zZWQgdG8gZGV0ZWN0IGNhc2VzIGxpa2UgKGluZGV4IHBvaW50cyB0byBcImltYWdlXCIpXG4gICAgICAgICAgICAvLyAgIC0gc2F2ZSB0cmFuc2Zvcm0gaW1hZ2UgcmVzdG9yZVxuICAgICAgICAgICAgLy8gICAtIHNhdmUgdHJhbnNmb3JtIGNvbnN0cnVjdHBhdGggY2xpcCBlbmRwYXRoIHNhdmUgdHJhbnNmb3JtIGltYWdlIHJlc3RvcmUgcmVzdG9yZVxuICAgICAgICAgICAgY29uc3QgZW5kID0gTWF0aC5tYXgoLTEsIGluZGV4LU1BWF9PUF9ESVNUQU5DRSk7XG4gICAgICAgICAgICBsZXQgaSA9IGluZGV4LTE7XG4gICAgICAgICAgICBsZXQgcSA9IC0xOyAvLyBpZiBubyBQREZKUy5PUFMuc2F2ZSBpcyBmb3VuZCwgLTEgd2lsbCBzaWduYWwgXCJubyBzZXF1ZW5jZVwiXG4gICAgICAgICAgICBsZXQgcUNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpID4gZW5kOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcCA9IGRhdGEuZm5BcnJheVtpXTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUERGSlMuT1BTLnNhdmU6XG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUERGSlMuT1BTLnNob3dUZXh0OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFBERkpTLk9QUy5zaG93U3BhY2VkVGV4dDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQREZKUy5PUFMubmV4dExpbmVTaG93VGV4dDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBQREZKUy5PUFMubmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUERGSlMuT1BTLnJlc3RvcmU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge3EsIHFDb3VudH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5kU2VxdWVuY2VFbmQoaW5kZXgsIHFDb3VudCkge1xuICAgICAgICAgICAgLy8gc2NhbiBmb3J3YXJkcyBmb3IgYXQgbW9zdCBNQVhfT1BfRElTVEFOQ0Ugb3BzIGFuZCBmaW5kIHRoZSBxQ291bnQndGggUERGSlMuT1BTLnJlc3RvcmVcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKGRhdGEuZm5BcnJheS5sZW5ndGgsIGluZGV4K01BWF9PUF9ESVNUQU5DRSk7XG4gICAgICAgICAgICBsZXQgaSA9IGluZGV4KzE7XG4gICAgICAgICAgICBsZXQgcSA9IGluZGV4KzE7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGVuZCAmJiBxQ291bnQ+MDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3AgPSBkYXRhLmZuQXJyYXlbaV07XG4gICAgICAgICAgICAgICAgaWYgKG9wID09IFBERkpTLk9QUy5yZXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBpO1xuICAgICAgICAgICAgICAgICAgICBxQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIG5vdCBlbm91Z2ggUERGSlMuT1BTLnJlc3RvcmUgYXJlIGZvdW5kLCBtYXJrIHNlcXVlbmNlIGFzIGJyb2tlblxuICAgICAgICAgICAgcmV0dXJuIHFDb3VudD4wID8gLTEgOiBxO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkUG9pbnRCQm94KGJib3gsIHgsIHkpIHtcbiAgICAgICAgICAgIGJib3hbMF0gPSBNYXRoLm1pbihiYm94WzBdLCB4KTtcbiAgICAgICAgICAgIGJib3hbMV0gPSBNYXRoLm1pbihiYm94WzFdLCB5KTtcbiAgICAgICAgICAgIGJib3hbMl0gPSBNYXRoLm1heChiYm94WzJdLCB4KTtcbiAgICAgICAgICAgIGJib3hbM10gPSBNYXRoLm1heChiYm94WzNdLCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEltYWdlQkJveChiYm94LCB4Zm9ybSkge1xuICAgICAgICAgICAgLy8gaW1hZ2VzIHVzZSBhIGZpeGVkIFswLCAwXXhbMSwgMV0gc3BhY2UgPT4gdHJhbnNmb3JtIGVhY2ggY29ybmVyIGFuZCBhZGQgdG8gYmJveFxuICAgICAgICAgICAgLy8geGZvcm0gdXNlcyB0aGUgY2FudmFzIGNvbnRleHQgY29udmVudGlvbjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC90cmFuc2Zvcm1cbiAgICAgICAgICAgIGFkZFBvaW50QkJveChiYm94LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Zm9ybVs0XSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGZvcm1bNV0pO1xuICAgICAgICAgICAgYWRkUG9pbnRCQm94KGJib3gsICAgICAgICAgICAgICAgIDEgKiB4Zm9ybVsyXSArIHhmb3JtWzRdLCAgICAgICAgICAgICAgICAxICogeGZvcm1bM10gKyB4Zm9ybVs1XSk7XG4gICAgICAgICAgICBhZGRQb2ludEJCb3goYmJveCwgMSAqIHhmb3JtWzBdICAgICAgICAgICAgICAgICsgeGZvcm1bNF0sIDEgKiB4Zm9ybVsxXSAgICAgICAgICAgICAgICArIHhmb3JtWzVdKTtcbiAgICAgICAgICAgIGFkZFBvaW50QkJveChiYm94LCAxICogeGZvcm1bMF0gKyAxICogeGZvcm1bMl0gKyB4Zm9ybVs0XSwgMSAqIHhmb3JtWzFdICsgMSAqIHhmb3JtWzNdICsgeGZvcm1bNV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgICAgICAgIGxldCBzZXF1ZW5jZVN0YXJ0ID0ge3E6IC0xLCBxQ291bnQ6IDB9O1xuICAgICAgICAgICAgbGV0IGxhc3RTbWFsbEltYWdlID0gLTE7XG4gICAgICAgICAgICBsZXQgc21hbGxJbWFnZVNlcXVlbmNlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGN1cnJYZm9ybSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICAgICAgICAgIGxldCB4Zm9ybVN0YWNrID0gW107XG4gICAgICAgICAgICBsZXQgYmJveCA9IFsxZTEwLCAxZTEwLCAtMWUxMCwgLTFlMTBdOyAgLy8gW21pbngsIG1pbnksIG1heHgsIG1heHldXG5cbiAgICAgICAgICAgIGNvbnN0IGJlZ2luU2VxdWVuY2UgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VTdGFydCA9IGZpbmRTZXF1ZW5jZVN0YXJ0KGkpO1xuICAgICAgICAgICAgICAgIGxhc3RTbWFsbEltYWdlID0gaTtcbiAgICAgICAgICAgICAgICBiYm94ID0gWzFlMTAsIDFlMTAsIC0xZTEwLCAtMWUxMF07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBlbmRTZXF1ZW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IGZpbmRTZXF1ZW5jZUVuZChsYXN0U21hbGxJbWFnZSwgc2VxdWVuY2VTdGFydC5xQ291bnQpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzZXF1ZW5jZSBpcyB0b28gc2hvcnQsIGlnbm9yZSBpdCAocGVyZm9ybWFuY2UgZ2FpbiB3b3VsZCBiZSB0b28gc21hbGwpXG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+PSAwICYmIGVuZCA+IHNlcXVlbmNlU3RhcnQucSArIE1JTl9PUFMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VxdWVuY2UgZW5kZWQgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsSW1hZ2VTZXF1ZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VxdWVuY2VTdGFydC5xLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuZm5BcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wID0gZGF0YS5mbkFycmF5W2ldO1xuICAgICAgICAgICAgICAgIGlmIChvcCA9PSBQREZKUy5PUFMuc2F2ZSkge1xuICAgICAgICAgICAgICAgICAgICB4Zm9ybVN0YWNrLnB1c2goY3Vyclhmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgY3Vyclhmb3JtID0gY3Vyclhmb3JtLnNsaWNlKDAsIDYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AgPT0gUERGSlMuT1BTLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtID0gY3Vyclhmb3JtO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gZGF0YS5hcmdzQXJyYXlbaV07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJYZm9ybSA9IFsgbVswXSAqIGFbMF0gKyBtWzJdICogYVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtWzFdICogYVswXSArIG1bM10gKiBhWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1bMF0gKiBhWzJdICsgbVsyXSAqIGFbM10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbVsxXSAqIGFbMl0gKyBtWzNdICogYVszXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtWzBdICogYVs0XSArIG1bMl0gKiBhWzVdICsgbVs0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtWzFdICogYVs0XSArIG1bM10gKiBhWzVdICsgbVs1XSBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3AgPT0gUERGSlMuT1BTLnJlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Vyclhmb3JtID0geGZvcm1TdGFjay5wb3AoKSB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1NtYWxsSW1hZ2UoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgdGhpcyBhIG5ldyBzZXF1ZW5jZT9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlU3RhcnQucSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luU2VxdWVuY2UoaSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IGxhc3RTbWFsbEltYWdlICsgTUFYX09QX0RJU1RBTkNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0b28gbWFueSBvcGVyYXRvcnMgYmV0d2VlbiB0aGUgcHJldmlvdXMgc21hbGwgaW1hZ2UgYW5kIHRoZSBjdXJyZW50IC0+IGVuZCBzZXF1ZW5jZSBhbmQgc3RhcnQgYSBuZXcgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW5TZXF1ZW5jZShpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBpbWFnZSBpcyB0b28gZmFyIGF3YXkgZnJvbSBsYXN0IGltYWdlIChpLmUuLCBpdCBzaG91bGQgc3RhcnQgbmV3IHNlcXVlbmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJib3hJbWcgPSBbMWUxMCwgMWUxMCwgLTFlMTAsIC0xZTEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEltYWdlQkJveChiYm94SW1nLCBjdXJyWGZvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCB0aGUgY2hlY2sgZm9yIHRoZSBmaXJzdCBmZXcgaW1hZ2VzIGFzIHRoZSBzZXF1ZW5jZSBuZWVkcyB0byBlc3RhYmxpc2ggYSByZWFzb25hYmxlIGxpbmUgbGVuZ3RoIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSAtIHNlcXVlbmNlU3RhcnQucSA+IE1JTl9PUFMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmJveEltZ1syXSA8IGJib3hbMF0gLSBNQVhfUEFHRV9VTklUX0RJU1RBTkNFIHx8IGJib3hJbWdbMF0gPiBiYm94WzJdICsgTUFYX1BBR0VfVU5JVF9ESVNUQU5DRSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYm94SW1nWzNdIDwgYmJveFsxXSAtIE1BWF9QQUdFX1VOSVRfRElTVEFOQ0UgfHwgYmJveEltZ1sxXSA+IGJib3hbM10gKyBNQVhfUEFHRV9VTklUX0RJU1RBTkNFKSkgIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuZCBzZXF1ZW5jZSBhbmQgc3RhcnQgYSBuZXcgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpblNlcXVlbmNlKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGFkZCB0byBjdXJyZW50IHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNtYWxsSW1hZ2UgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RTbWFsbEltYWdlID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEltYWdlQkJveChiYm94LCBjdXJyWGZvcm0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBlbmQgbGFzdCBzZXF1ZW5jZVxuICAgICAgICAgICAgaWYgKGxhc3RTbWFsbEltYWdlID49IDApIHtcbiAgICAgICAgICAgICAgICBlbmRTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc21hbGxJbWFnZVNlcXVlbmNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc21hbGxJbWFnZVNlcXVlbmNlcyA9IHByb2Nlc3MoKTtcbiAgICAgICAgLy9jb25zb2xlLnRpbWVFbmQoXCJkZXRlY3RTbWFsbEltYWdlU2VxdWVuY2VzXCIpO1xuICAgIH0pLmNhdGNoKGF2cC5sb2dnZXIubG9nKTtcbn07XG5cblBERkxvYWRlci5wcm90b3R5cGUuZml4VGlsaW5nUGF0dGVybnNXaXRoSHVnZUdhcHMgPSBmdW5jdGlvbiAocGFnZSkge1xuICAgIGNvbnN0IE1BWF9HQVBfRkFDVE9SID0gMTA7XG4gICAgY29uc3QgQlVGRkVSX0ZBQ1RPUiA9IDI7XG5cbiAgICAvLyBhZGRyZXNzZXMgQkxNVi03MjE0IGFuZCBWSVpYLTE5MVxuICAgIHJldHVybiB0aGlzLmdldE9wZXJhdG9yTGlzdChwYWdlKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5mbkFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzZWFyY2ggZm9yIHRpbGluZyBwYXR0ZXJuIGRlZmluaXRpb25zXG4gICAgICAgICAgICBjb25zdCBvcCA9IGRhdGEuZm5BcnJheVtpXTtcbiAgICAgICAgICAgIGlmIChvcCAhPSBQREZKUy5PUFMuc2V0RmlsbENvbG9yTikgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgbGV0IGFyZ3MgPSBkYXRhLmFyZ3NBcnJheVtpXTtcbiAgICAgICAgICAgIGlmICghYXJncyB8fCBhcmdzLmxlbmd0aCA8IDcpIHsgY29udGludWU7IH1cbiAgICAgICAgICAgIGlmIChhcmdzWzBdICE9IFwiVGlsaW5nUGF0dGVyblwiKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIC8vIGxvb2sgYXQgdGhlIHBhdHRlcm4gcGFyYW1ldGVyc1xuICAgICAgICAgICAgY29uc3QgYmJveCA9IGFyZ3NbNF07XG4gICAgICAgICAgICBjb25zdCB4c3RlcCA9IGFyZ3NbNV07XG4gICAgICAgICAgICBjb25zdCB5c3RlcCA9IGFyZ3NbNl07XG5cbiAgICAgICAgICAgIGNvbnN0IGJib3hXaWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgICAgICAgICAgY29uc3QgYmJveEhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuXG4gICAgICAgICAgICAvLyBpZiBzdGVwIGlzIG1vcmUgdGhhbiBNQVhfR0FQX0ZBQ1RPUiB0aW1lcyB0aGUgc2l6ZSBvZiB0aGUgYmJveCwgYXNzdW1lIHRoYXQgdGhlcmUgaXMgbm8gYWN0dWFsIHRpbGluZyBpbnRlbmRlZFxuICAgICAgICAgICAgaWYgKHhzdGVwID4gTUFYX0dBUF9GQUNUT1IqYmJveFdpZHRoICYmIHlzdGVwID4gTUFYX0dBUF9GQUNUT1IqYmJveEhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIGlkZWFsbHksIHdlIHdvdWxkIHRoZW4gdXNlIGEgdGV4dHVyZSB3aXRob3V0IHJlcGVhdCwgYnV0IHRoZXJlIGlzIG5vIHN1Y2ggb3B0aW9uIGluIG91ciBtYXRlcmlhbHNcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkLCBhZGQgYSBiaXQgb2YgYnVmZmVyIGluIGNhc2Ugc29tZSBhcmVhIG91dHNpZGUgdGhlIHBhdHRlcm4gYmJveCBpcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgYXJnc1s1XSA9IEJVRkZFUl9GQUNUT1IgKiBiYm94V2lkdGg7XG4gICAgICAgICAgICAgICAgYXJnc1s2XSA9IEJVRkZFUl9GQUNUT1IgKiBiYm94SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFdoZW4gd2UgZG8gc3luY2hyb25pemVkIGxvYWRpbmcgcGRmIHJlZmVyZW5jZWQgb2JqZWN0LCBpdCBtaWdodCByZXR1cm4gZW1wdHkgaWYgdGhhdCBjb250ZW50IHdhcyBub3QgbG9hZGVkXG4gKiBBc3luY2hyb25pemVkIHdheSBpcyBiZXR0ZXIsIGJ1dCBpdCBpbmNyZWFzZXMgdGhlIGNvbXBsZXhpdHkgb2YgbG9hZGluZyBpdFxuICogVGhpcyBmdW5jdGlvbiBpcyBwcmVmbHkgZm9yIHBhcnNpbmcgdGhvc2UgcmVmZXJlbmNlc1xuICovXG5QREZMb2FkZXIucHJvdG90eXBlLmxvYWRNYXJrZWRDb250ZW50UHJvcGVydGllc1JlZmVyZW5jZXMgPSBmdW5jdGlvbiAocGRmLCBwYWdlKSB7XG4gICAgdmFyIHJlZmVyZW5jZU9iak1hcCA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0UmVmT2JqKHJlZikge1xuICAgICAgICByZXR1cm4gcGRmLmdldE9iamVjdChyZWYpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZU9iak1hcFtyZWZLZXkoZGF0YS5rZXkpXSA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgICAvLyBsb29wIGluIG9uZSBtb3JlIGxldmVsIGZvciBkaWN0aW9uYXJ5XG4gICAgICAgICAgICB2YXIgY2hpbGRQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGRhdGEuaXNEaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaXRlbUtleSBpbiBkYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JlZihkYXRhLnZhbHVlW2l0ZW1LZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU9iak1hcFtyZWZLZXkoZGF0YS52YWx1ZVtpdGVtS2V5XSldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS52YWx1ZVtpdGVtS2V5XSA9IHJlZmVyZW5jZU9iak1hcFtyZWZLZXkoZGF0YS52YWx1ZVtpdGVtS2V5XSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFByb21pc2VzLnB1c2gocGRmLmdldE9iamVjdChkYXRhLnZhbHVlW2l0ZW1LZXldKS50aGVuKChkYXRhMSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnZhbHVlW2l0ZW1LZXldID0gZGF0YTEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU9iak1hcFtyZWZLZXkoZGF0YTEua2V5KV0gPSBkYXRhMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChhdnAubG9nZ2VyLmxvZykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2hpbGRQcm9taXNlcyk7XG4gICAgICAgIH0pLmNhdGNoKGF2cC5sb2dnZXIubG9nKTsgICAgIC8vIGZvciBhbnkgbWlzc2luZyByZWZlcmVuY2Ugb2JqZWN0LCBqdXN0IGlnbm9yZSBhbmQgY29udGludWVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXRPcGVyYXRvckxpc3QocGFnZSkudGhlbigob3BzKSA9PiB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5mbkFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGlmIChvcHMuZm5BcnJheVtpXSA9PSBQREZKUy5PUFMuYmVnaW5NYXJrZWRDb250ZW50IHx8IG9wcy5mbkFycmF5W2ldID09IFBERkpTLk9QUy5iZWdpbk1hcmtlZENvbnRlbnRQcm9wcykge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzMSA9IG9wcy5hcmdzQXJyYXlbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGFyZ3MxICYmIGogPCBhcmdzMS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWYoYXJnczFbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFJlZk9iaihhcmdzMVtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAoYXJnczFbal0pID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBhcmdzMVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JlZihhcmdzMVtqXVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvbWlzZSA9IGdldFJlZk9iaihhcmdzMVtqXVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbmljZSB0byBoYXZlIGZlYXR1cmUsIGluIGNhc2Ugb2YgYW55dGhpbmcgd3JvbmcsIHVzdCBpZ25vcmUgYW5kIGNvbnRpbnVlXG4gICAgICAgICAgICAuY2F0Y2goYXZwLmxvZ2dlci5sb2cpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZU9iak1hcDtcbiAgICAgICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuUERGTG9hZGVyLnByb3RvdHlwZS5sb2FkRnlkb0NCID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMsIG9uU3VjY2Vzcywgb25Xb3JrZXJTdGFydCkge1xuICAgIHRoaXMudDAgPSBEYXRlLm5vdygpO1xuXG4gICAgdmFyIHN2ZlBhdGggPSBhdnAucGF0aFRvVVJMKHBhdGgpO1xuICAgIGlmICh0aGlzLnF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIHN2ZlBhdGggKz0gJz8nICsgdGhpcy5xdWVyeVBhcmFtcztcbiAgICB9XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgaWYgKG9uV29ya2VyU3RhcnQpXG4gICAgICAgIG9uV29ya2VyU3RhcnQoKTtcblxuICAgIGxldCBjTWFwVXJsID0gb3B0aW9ucy5jTWFwVXJsO1xuICAgIGxldCBjTWFwUGFja2VkID0gb3B0aW9ucy5jTWFwUGFja2VkO1xuICAgIGlmICghY01hcFVybCkge1xuICAgICAgICBjTWFwVXJsID0gYXZwLmdldFJlc291cmNlVXJsKCdleHRlbnNpb25zL1BERi9jbWFwcy8nKTtcbiAgICAgICAgY01hcFBhY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgdXJsOiBzdmZQYXRoLFxuICAgICAgICBkaXNhYmxlRm9udEZhY2U6IHRydWUsXG4gICAgICAgIHN0b3BBdEVycm9yczogZmFsc2UsXG4gICAgICAgIGlzRXZhbFN1cHBvcnRlZDogZmFsc2UsXG4gICAgICAgIGNNYXBVcmwsXG4gICAgICAgIGNNYXBQYWNrZWQsXG4gICAgfTtcblxuICAgIGlmIChhdi5lbmRwb2ludC5nZXRVc2VDb29raWUoKSkge1xuICAgICAgICBwYXJhbXMud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMuaHR0cEhlYWRlcnMgPSBhdi5lbmRwb2ludC5IVFRQX1JFUVVFU1RfSEVBREVSUztcbiAgICB9XG5cbiAgICB0aGlzLnZpZXdlcjNESW1wbC5fc2lnbmFsTm9NZXNoZXMoKTtcblxuICAgIGxldCBmZSA9IHRoZUZvbnRFbmdpbmU7XG5cbiAgICAvL1N0YXJ0IGxvYWRpbmcgZm9udHMuXG4gICAgbGV0IGxvYWRGb250c0FzeW5jID0gZmUubG9hZEZvbnRzKCk7XG5cbiAgICBmdW5jdGlvbiBnZXRJbnRlcm5hbExpbmtzKHBkZiwgcGFnZSkge1xuICAgICAgICByZXR1cm4gcGFnZS5nZXRBbm5vdGF0aW9ucygpLnRoZW4oYW5ub3RhdGlvbnMgPT4ge1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zICYmIGFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYW5ub3RhdGlvbnMubWFwKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVybmFsIHBhZ2UgbGlua1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbi5zdWJ0eXBlID09IFwiTGlua1wiICYmICFhbm5vdGF0aW9uLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhZ2VJbmRleFByb21pc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvIGZhciBJIGZvdW5kIDIgd2F5cyBvZiBhbm5vdGlvbiBkZXN0aW5hdGlvbiwgaXQgbWlnaHQgYmUgbW9yZSwgZXh0ZW5kIHRoaXMgcGFydCBpZiB3ZSBoYXZlIG5ldyBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChhbm5vdGF0aW9uLmRlc3QpID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlSW5kZXhQcm9taXNlID0gcGRmLmdldERlc3RpbmF0aW9uKGFubm90YXRpb24uZGVzdCkudGhlbigoZGVzdEluZm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBkZi5nZXRQYWdlSW5kZXgoZGVzdEluZm9bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbi5kZXN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUluZGV4UHJvbWlzZSA9IHBkZi5nZXRQYWdlSW5kZXgoYW5ub3RhdGlvbi5kZXN0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFnZUluZGV4UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWdlSW5kZXhQcm9taXNlLnRoZW4oKHBhZ2VJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHJlZ2lzdGVyIHRoZSByZWN0IHRvIHBhZ2VJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwZGYgZ2V0UGFnZSBmdW5jdGlvbiBzdGFydCBmcm9tIDEsIHNvIGhlcmUgbmVlZCBhZGQgZXh0cmEgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLnBhZ2VJbmRleCA9IHBhZ2VJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZXJuYWwgbGluaywgd2lsbCBhZGQgc3VwcG9ydCBoZXJlLCBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKS50aGVuKChpbnRlcm5hbExpbmtzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbExpbmtzLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGRpZmZpY3VsdHkgb2YgcGFyc2luZyBhbm5vdGF0aW9ucywgd2Ugc2hvdWxkIGxldCB0aGUgbG9hZGluZyBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxpbmtCb3VuZHMocmVuZGVyQ29udGV4dCwgdmlld3BvcnQsIGludGVybmFsTGlua3MpIHtcbiAgICAgICAgdmFyIGRiSWRMaW5rcyA9IFtdO1xuICAgICAgICAvLyBVc2UgbmVnYXRpdmUgZGJJZCBzaW5jZSBob3RBcmVhIGlzIGFkZGVkIGJ5IHVzXG4gICAgICAgIHZhciBkYklkID0gLTI7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSByZW5kZXJDb250ZXh0LmdldEN1cnJlbnRUcmFuc2Zvcm0oKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGludGVybmFsTGlua3MgJiYgaSA8IGludGVybmFsTGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBjcmVhdGVSZWN0QnlWaWV3cG9ydFRyYW5zZm9ybShyZW5kZXJDb250ZXh0LCB0cmFuc2Zvcm0sIHZpZXdwb3J0LCBpbnRlcm5hbExpbmtzW2ldLnJlY3QpO1xuICAgICAgICAgICAgdmFyIGxpbmtOb2RlID0gc2NvcGUuc3ZmLmxvYWRPcHRpb25zLmJ1YmJsZU5vZGUuZ2V0Um9vdE5vZGUoKS5jaGlsZHJlbltpbnRlcm5hbExpbmtzW2ldLnBhZ2VJbmRleCAtIDFdO1xuICAgICAgICAgICAgZGJJZExpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIGRiSWQ6IGRiSWQtLSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbe1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWU6IGxpbmtOb2RlLmRhdGEudmlld2FibGVJRFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIGJveDogW1xuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihyZWN0WzBdLCByZWN0WzJdKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4ocmVjdFsxXSwgcmVjdFszXSksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHJlY3RbMF0sIHJlY3RbMl0pLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChyZWN0WzFdLCByZWN0WzNdKVxuICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUuZGJJZExpbmtzID0gZGJJZExpbmtzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3RCeVZpZXdwb3J0VHJhbnNmb3JtKHJlbmRlckNvbnRleHQsIHRyYW5zZm9ybSwgdmlld3BvcnQsIHRlbXBSZWN0KSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHZpZXdwb3J0LmNvbnZlcnRUb1ZpZXdwb3J0UmVjdGFuZ2xlKHRlbXBSZWN0KTtcbiAgICAgICAgICAgIHJlY3QgPSBbcmVuZGVyQ29udGV4dC50eChyZWN0WzBdLCByZWN0WzFdLCB0cmFuc2Zvcm0pLFxuICAgICAgICAgICAgICAgIHJlbmRlckNvbnRleHQudHkocmVjdFswXSwgcmVjdFsxXSwgdHJhbnNmb3JtKSxcbiAgICAgICAgICAgICAgICByZW5kZXJDb250ZXh0LnR4KHJlY3RbMl0sIHJlY3RbM10sIHRyYW5zZm9ybSksXG4gICAgICAgICAgICAgICAgcmVuZGVyQ29udGV4dC50eShyZWN0WzJdLCByZWN0WzNdLCB0cmFuc2Zvcm0pXTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlQXJvdW5kKHAsIGNlbnRlciwgYW5nbGUpIHtcbiAgICAgICAgbGV0IGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcbiAgICAgICAgbGV0IHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcblxuICAgICAgICBsZXQgeCA9IHAueCAtIGNlbnRlci54O1xuICAgICAgICBsZXQgeSA9IHAueSAtIGNlbnRlci55O1xuXG4gICAgICAgIHAueCA9IHggKiBjIC0geSAqIHMgKyBjZW50ZXIueDtcbiAgICAgICAgcC55ID0geCAqIHMgKyB5ICogYyArIGNlbnRlci55O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBzdHJpbmdzIG91dHB1dCBmcm9tIFBERiBwYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlbmRlckN0eCAtIFJlbmRlciBjb250ZXh0IG9mIGN1cnJlbnQgcGFnZSByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhZ2VJbmZvIC0gZGltZW5zaW9ucyBvZiBjdXJyZW50IHBhZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZpZXdwb3J0IC0gVmlld3BvcnQgYmFzZWQgb24gUGFnZSBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZlY3RvclN0cmluZ3MgLSBBcnJheSB3aXRoIGFsbCBzdHJpbmdzIGZyb20gVmVjdG9yIFBERi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZm9ybWF0dGVkR2x5cGhzIC0gT2JqZWN0IHdoaWNoIGNvbnRhaW5zIGdseXBocyBhbmQgdGhlaXIgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIE9iamVjdCB3aXRoIGxpc3Qgb2Ygc3RyaW5ncyBhbmQgdGhlaXIgc3RyaW5nQm94ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0VmVjdG9yUGRmU3RyaW5ncyhyZW5kZXJDdHgsIHBhZ2VJbmZvLCB2aWV3cG9ydCwgdmVjdG9yU3RyaW5ncywgZm9ybWF0dGVkR2x5cGhzKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RyaW5nQm94ZXMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RyaW5nQW5nbGVzID0gW107XG4gICAgICAgIGNvbnN0IHN0cmluZ0NoYXJXaWR0aHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RyaW5nUG9zaXRpb25zID0gW107XG4gICAgICAgIGNvbnN0IHN0cmluZ0hlaWdodHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RyaW5nV2lkdGhzID0gW107XG4gICAgICAgIGNvbnN0IHJlbmRlckN0eFRyYW5zZm9ybSA9IHJlbmRlckN0eC52aWV3cG9ydC50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSByZW5kZXJDdHguZ2V0Q3VycmVudFRyYW5zZm9ybSgpO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSBmdW5jdGlvbiB0aGF0IGNvbWJpbmVzIHZhbHVlcyBmcm9tIFJlbmRlciBDb250ZXh0IFRyYW5zZm9ybSBhbmQgVHJhbnNmb3JtIG9mIGEgc3RyaW5nXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybUZ1bmMgPSAobTEsIG0yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG0xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdLFxuICAgICAgICAgICAgICAgIG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdLFxuICAgICAgICAgICAgICAgIG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdLFxuICAgICAgICAgICAgICAgIG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdLFxuICAgICAgICAgICAgICAgIG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF0sXG4gICAgICAgICAgICAgICAgbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9TdHJpbmdzIGluIFBERi5qcyBhcmUgZ3JvdXBlZCwgaGVuY2UgMiBsb29wcyBuZWVkZWQgdG8gZXh0cmFjdCBldmVyeSBleHByZXNzaW9uLlxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmVjdG9yU3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHZlY3RvclN0cmluZ3NbaV0uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IHZlY3RvclN0cmluZ3NbaV0uaXRlbXM7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBPYmplY3QgPSBpdGVtc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcENoYXJXaWR0aCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyB0ZW1wT2JqZWN0IGNvbnRhaW5zIGNoYXJhY3RlcnMgbWFwIHdpdGggY29ycmVzcG9uZGluZyB3aWR0aCB2YWx1ZXMgZm9yIGVhY2ggY2hhclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3JtYXR0ZWRHbHlwaHMgc3RvcmVzIGZvbnQgZmFtaWxpZXMgYnkgbmFtZSBhbmQgY2hhciBhbmQgd2lkdGhzXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGVtcE9iamVjdC5zdHIubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBGb250TmFtZSA9IGZvcm1hdHRlZEdseXBoc1t0ZW1wT2JqZWN0LmZvbnROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBTdHJpbmcgPSB0ZW1wT2JqZWN0LnN0cltrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpeCBmb3IgQkxNVi01MTUxLCBuZWVkIHRvIHZlcmlmeSB0aGF0IHNwZWNpZmljIGNoYXJhY3RlciBleGlzdCwgb3RoZXJ3aXNlIGl0IGNhbiBwcmV2ZW50IFBERiBmcm9tIGxvYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVtcEZvbnROYW1lW3RlbXBTdHJpbmddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBDYW5ub3QgZmluZCAke3RlbXBTdHJpbmd9J3Mgd2lkdGggaW4gZ2x5cGggZGljdGlvbmFyeWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBDaGFyV2lkdGgucHVzaCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcENoYXJXaWR0aC5wdXNoKHRlbXBGb250TmFtZVt0ZW1wU3RyaW5nXS53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nQ2hhcldpZHRocy5wdXNoKHRlbXBDaGFyV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSB0ZW1wT2JqZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0SGVpZ2h0ID0gdGVtcE9iamVjdC5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGJvdW5kaW5nIGJveCdzIGFuZ2xlIG9mIGEgc3RyaW5nIGJ5IHVzaW5nIHZpZXdwb3J0IGFuZCBzdHJpbmdzIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICAvLyBSb3RhdGlvbiBvZiBiYm94IGFwcGxpZWQgb24gVUkgc2lkZSBiYXNlZCBvbiBhbmdsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJUeCA9IHRyYW5zZm9ybUZ1bmMocmVuZGVyQ3R4VHJhbnNmb3JtLCB0ZW1wT2JqZWN0LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ckFuZ2xlID0gTWF0aC5hdGFuMihzdHJUeFsxXSwgc3RyVHhbMF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0aW5nIEJvdW5kaW5nIGJveCBiYXNlZCBvbiB0cmFuc2Zvcm0gdmFsdWVzIGZyb20gcGRmLmpzIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyA0LXRoIHBsYWNlIGluIGFycmF5IGlzIHZlcnRpY2FsIG9mZnNldCBvZiBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gNS10aCBwbGFjZSBpbiBhcnJheSBpcyBob3Jpem9udGFsIG9mZnNldCBvZiBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluWCA9IHRlbXBPYmplY3QudHJhbnNmb3JtWzRdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhYID0gdGVtcE9iamVjdC50cmFuc2Zvcm1bNF0gKyB0ZXh0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pblkgPSB0ZW1wT2JqZWN0LnRyYW5zZm9ybVs1XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4WSA9IHRlbXBPYmplY3QudHJhbnNmb3JtWzVdICsgdGV4dEhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3ggPSBuZXcgVEhSRUUuQm94MigpLnNldEZyb21Qb2ludHMoWyBuZXcgVEhSRUUuVmVjdG9yMihtaW5YLCBtaW5ZKSwgbmV3IFRIUkVFLlZlY3RvcjIobWF4WCwgbWF4WSldKTtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlQXJvdW5kKGJveC5tYXgsIGJveC5taW4sIFRIUkVFLk1hdGguZGVnVG9SYWQocGFnZUluZm8ucm90YXRlKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcFJlY3QgPSBbYm94Lm1pbi54LCBib3gubWluLnksIGJveC5tYXgueCwgYm94Lm1heC55XTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gY3JlYXRlUmVjdEJ5Vmlld3BvcnRUcmFuc2Zvcm0ocmVuZGVyQ3R4LCBjdXJyZW50VHJhbnNmb3JtLCB2aWV3cG9ydCwgdGVtcFJlY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ3MucHVzaCh0ZW1wT2JqZWN0LnN0cik7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ0JveGVzLnB1c2gocmVjdFswXSwgcmVjdFsxXSwgcmVjdFsyXSwgcmVjdFszXSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ0FuZ2xlcy5wdXNoKHN0ckFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nUG9zaXRpb25zLnB1c2goW3JlY3RbMF0sIHJlY3RbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nSGVpZ2h0cy5wdXNoKHRleHRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdXaWR0aHMucHVzaCh0ZXh0V2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge3N0cmluZ3MsIHN0cmluZ0JveGVzLCBzdHJpbmdBbmdsZXMsIHN0cmluZ0NoYXJXaWR0aHMsIHN0cmluZ1Bvc2l0aW9ucywgc3RyaW5nSGVpZ2h0cywgc3RyaW5nV2lkdGhzfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdmlld3BvcnRzIGZyb20gdGhlIFBERlxuICAgICAqIEBwYXJhbSB7UERGUGFnZVByb3h5fSBwYWdlXG4gICAgICogQHBhcmFtIHtMbXZDYW52YXNDb250ZXh0fSByZW5kZXJDb250ZXh0XG4gICAgICogQHJldHVybnMge09iamVjdFtdfSBUaGUgZXh0cmFjdGVkIHZpZXdwb3J0c1xuICAgICAqL1xuICAgIFBERkxvYWRlci5wcm90b3R5cGUuYnVpbGRWaWV3cG9ydHMgPSBmdW5jdGlvbihwYWdlLCByZW5kZXJDb250ZXh0KSB7XG4gICAgICAgIGxldCB2aWV3cG9ydHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3BlcmF0b3JMaXN0KHBhZ2UpLnRoZW4oKG9wcykgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHMuZm5BcnJheS5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wcy5mbkFycmF5W2ldID09IFBERkpTLk9QUy5iZWdpbk1hcmtlZENvbnRlbnQgfHwgb3BzLmZuQXJyYXlbaV0gPT0gUERGSlMuT1BTLmJlZ2luTWFya2VkQ29udGVudFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHMuYXJnc0FycmF5W2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvcGVydGllcyA9IG9wcy5mbkFycmF5W2ldID09IFBERkpTLk9QUy5iZWdpbk1hcmtlZENvbnRlbnQgPyBvcHMuYXJnc0FycmF5W2ldWzBdIDogb3BzLmFyZ3NBcnJheVtpXVsxXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSByZW5kZXJDb250ZXh0Ll9wcm9jZXNzUHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHByb3BlcnRpZXMuVlApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdnAgPSByZW5kZXJDb250ZXh0Ll9nZXRNb2RlbFRvVmlld3BvcnRNYXRyaXgocHJvcGVydGllcy5WUCwgISFwcm9wZXJ0aWVzLlVOSVRTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRzLnB1c2gocmVuZGVyQ29udGV4dC5jcmVhdGVWaWV3UG9ydERhdGEodnAsIHByb3BlcnRpZXMuVU5JVFMsIHByb3BlcnRpZXMuUFJFQ0lTSU9OKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZpZXdwb3J0cztcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkTGF5ZXJzKHBhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlLmdldE9wZXJhdG9yTGlzdChwYWdlKS50aGVuKChvcHMpID0+IHtcbiAgICAgICAgICAgIGxldCBmbkFycmF5ID0gb3BzLmZuQXJyYXk7XG4gICAgICAgICAgICBsZXQgYXJnc0FycmF5ID0gb3BzLmFyZ3NBcnJheTtcbiAgICAgICAgICAgIGxldCBsYXllcnMgPSB7fTtcbiAgICAgICAgICAgIGxldCBsYXllclN0YXJ0SW5kZXggPSAxO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgZm5BcnJheSAmJiBpIDwgZm5BcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBmbiA9IGZuQXJyYXlbaV07XG4gICAgICAgICAgICAgICAgaWYgKGZuID09PSBQREZKUy5PUFMuYmVnaW5NYXJrZWRDb250ZW50UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3NBcnJheVtpXSAmJiBhcmdzQXJyYXlbaV1bMF0gPT0gXCJPQ1wiICYmIGFyZ3NBcnJheVtpXVsxXSE9PW51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IExtdkNhbnZhc0NvbnRleHQuZ2V0TGF5ZXJLZXkoYXJnc0FycmF5W2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkhPT11bmRlZmluZWQgJiYgbGF5ZXJzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyc1trZXldID0gbGF5ZXJTdGFydEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGF5ZXJzO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLy8gSXQgc2hvdWxkIG5vdCBoYXZlIGVycm9yLCBidXQgd2UgZG9uJ3QgdGVzdCBlbm91Z2ggZm9yIFBERlxuICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBwb3RlbnRpYWwgZXJyb3IgaGFwcGVuZWQsIHdlIHN0aWxsIHdhbnQgdG8gc2hvdyB0aGUgY29udGVudHNcbiAgICAgICAgICAgIC5jYXRjaChhdnAubG9nZ2VyLmxvZylcbiAgICAgICAgICAgIC50aGVuKChsYXllcnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUucGRmLmdldFBhZ2VPQ0dOYW1lcyhwYWdlLnJlZilcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGF2cC5sb2dnZXIubG9nKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihsYXllck5hbWVNYXAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJOYW1lTWFwID0gbGF5ZXJOYW1lTWFwIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVyc1Jvb3QgPSB7IG5hbWU6ICdyb290JywgaWQ6ICdyb290JywgY2hpbGRyZW46IFtdLCBpc0xheWVyOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVyc01hcCA9IHsgXCIwXCI6IDAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXllckNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGxheWVyS2V5IGluIGxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gbGF5ZXJOYW1lTWFwW2xheWVyS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHR5cGVvZiBsID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobCwgJ25hbWUnKSA/IGwubmFtZSA6IGxheWVyS2V5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2dyb3VwLScgKyBsYXllcnNbbGF5ZXJLZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xheWVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogbGF5ZXJzW2xheWVyS2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogbD8udmlzaWJsZSA/PyB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBsYXllcnMsIHRoZSBmaXJzdCBkcmF3aW5nIGxheWVyIHNob3VsZCBiZSBhdCB0aGUgYm90dG9tIG9mIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzUm9vdC5jaGlsZHJlbi51bnNoaWZ0KGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzTWFwW2xheWVyc1tsYXllcktleV1dID0gbGF5ZXJzW2xheWVyS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllckNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyc1Jvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdHJpbmdzKHBhZ2UpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRTdHJpbmdzID0gW107XG4gICAgICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gcGFnZS5zdHJlYW1UZXh0Q29udGVudCh7IG5vcm1hbGl6ZVdoaXRlc3BhY2U6IHRydWUsIGNvbWJpbmVUZXh0SXRlbXM6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgcHVtcCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4oKHsgdmFsdWUsIGRvbmUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkb2N1bWVudFN0cmluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50U3RyaW5ncy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcHVtcCgpO1xuICAgICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBwdW1wKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlclBhZ2UocGFnZU51bWJlcikge1xuICAgICAgICB2YXIgcGRmID0gc2NvcGUucGRmO1xuICAgICAgICBQREZXb3JraW5nUmVmZXJlbmNlTWFwW3BkZi5maW5nZXJwcmludF0gPSAxO1xuXG4gICAgICAgIGlmIChwYWdlTnVtYmVyIDw9IDAgfHwgcGFnZU51bWJlciA+IHBkZi5udW1QYWdlcykge1xuICAgICAgICAgICAgcGFnZU51bWJlciA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NvcGUubW9kZWwpIHtcbiAgICAgICAgICAgIHNjb3BlLnZpZXdlcjNESW1wbC51bmxvYWRNb2RlbChzY29wZS5tb2RlbCk7XG4gICAgICAgICAgICBzY29wZS5tb2RlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICBsZXQgZG9jdW1lbnRTdHJpbmdzID0gW107XG4gICAgICAgIHJldHVybiBwZGYuZ2V0UGFnZShwYWdlTnVtYmVyKS50aGVuKHBhZ2UgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmNyZWF0ZUZvbnRBdGxhcyhwYWdlLCBwZGYuZmluZ2VycHJpbnQpLnRoZW4oKGZvbnRBdGxhcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZm9udEF0bGFzID0gZm9udEF0bGFzO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbnRlcm5hbExpbmtzKHBkZiwgcGFnZSkudGhlbigoaW50ZXJuYWxMaW5rcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmludGVybmFsTGlua3MgPSBpbnRlcm5hbExpbmtzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IFBERiBzdHJpbmdzIGZyb20gcGFnZVxuICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMgRmVhdHVyZSBGbGFnIGRpc2FibGVzIGJ5IGRlZmF1bHQgUERGLmpzIHN0cmluZ3MgZmV0Y2hcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5leHRlbmRTdHJpbmdzRmV0Y2hpbmcgPyBnZXRTdHJpbmdzKHBhZ2UpIDogW107XG4gICAgICAgICAgICB9KS50aGVuKChzdHJpbmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRTdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGV0ZWN0Q2lyY2xlKHBhZ2UpO1xuICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTG9hZCBhbnkgbGFyZ2UgZm9udCBmaWxlcyB0aGF0IG5lZWQgdG8gYmUgdXNlZCBieSB0aGUgY3VycmVudCBQREYuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmxvYWRPbkRlbWFuZEZvbnRzKHBhZ2UsIGZlKTtcbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5sb2FkTWFya2VkQ29udGVudFByb3BlcnRpZXNSZWZlcmVuY2VzKHBkZiwgcGFnZSkudGhlbigobWFwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGRmUmVmT2JqTWFwID0gbWFwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmV2YWx1YXRlUGFnZUxpbmVTdHlsZXMocGFnZSk7XG4gICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGV0ZWN0U21hbGxJbWFnZVNlcXVlbmNlcyhwYWdlKTtcbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5maXhUaWxpbmdQYXR0ZXJuc1dpdGhIdWdlR2FwcyhwYWdlKTtcbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpbnRlcm5hbExpbmtzID0gY29udGV4dC5pbnRlcm5hbExpbmtzO1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gcGFnZS52aWV3O1xuICAgICAgICAgICAgICAgIHZpZXcgPSB2aWV3LnNsaWNlKDApO1xuXG4gICAgICAgICAgICAgICAgLy8gTE1WLTUxNDk6IEFwcGx5IHRoZSBwYWdlIHJvdGF0aW9uIHRvIHRoZSBwYWdlX3dpZHRoIGFuZCBwYWdlX2hlaWdodFxuICAgICAgICAgICAgICAgIHZhciByb3RhdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVJvdGF0aW9uWigocGFnZS5yb3RhdGUgLyAxODApICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0ZWRWaWV3VmVjMSA9IG5ldyBUSFJFRS5WZWN0b3IzKHZpZXdbMF0sIHZpZXdbMV0sIDApLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0ZWRWaWV3VmVjMiA9IG5ldyBUSFJFRS5WZWN0b3IzKHZpZXdbMl0sIHZpZXdbM10sIDApLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG5cblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSByb3RhdGlvbiB2ZWN0b3IgdG8gdGhlIHZpZXdcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSB2YWx1ZXMgYXJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBwYWdlX3dpZHRoIGFuZCB0aGUgcGFnZV9oZWlnaHRcbiAgICAgICAgICAgICAgICB2aWV3WzBdID0gTWF0aC5taW4ocm90YXRlZFZpZXdWZWMxLngsIHJvdGF0ZWRWaWV3VmVjMi54KTtcbiAgICAgICAgICAgICAgICB2aWV3WzFdID0gTWF0aC5taW4ocm90YXRlZFZpZXdWZWMxLnksIHJvdGF0ZWRWaWV3VmVjMi55KTtcbiAgICAgICAgICAgICAgICB2aWV3WzJdID0gTWF0aC5tYXgocm90YXRlZFZpZXdWZWMxLngsIHJvdGF0ZWRWaWV3VmVjMi54KTtcbiAgICAgICAgICAgICAgICB2aWV3WzNdID0gTWF0aC5tYXgocm90YXRlZFZpZXdWZWMxLnksIHJvdGF0ZWRWaWV3VmVjMi55KTtcblxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gcHV0IGEgY2FwIG9uIDEgZGltZW50aW9uIDogODE5MiBmb3IgZGVza3RvcCAvIDQwOTYgZm9yIGZpcmVmb3ggLyAyMDQ4IGZvciBtb2JpbGVcbiAgICAgICAgICAgICAgICAvLyBMTVYtNDczMTogSWYgd2Ugc2V0IHRoZSB2aWV3cG9ydCB0b28gbGFyZ2UsIGl0IHdpbGwgZmFpbCB0byBsb2FkIGluIEZpcmVmb3hcbiAgICAgICAgICAgICAgICB2YXIgbWF4RGltID0gTWF0aC5tYXgodmlld1syXSAtIHZpZXdbMF0sIHZpZXdbM10gLSB2aWV3WzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXBEaW0gPSBhdi5pc01vYmlsZURldmljZSgpID8gTU9CSUxFX0RJTV9DQVAgOiBhdi5pc0ZpcmVmb3goKSA/IEZJUkVGT1hfRElNX0NBUCA6IERFRkFVTFRfRElNX0NBUDtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZUJ5RGltID0gY2FwRGltIC8gbWF4RGltO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgRFBJID0gMzAwO1xuICAgICAgICAgICAgICAgIC8vUmVuZGVyIHRoZSBQREYgYXQgMzAwIHBpeGVscy9pbmNoIGluc3RlYWQgb2YgNzIgcG9pbnRzL2luY2guXG4gICAgICAgICAgICAgICAgLy9UaGlzIHNlZW1zIHRvIG1hdGNoIHdoYXQgQWRvYmUgUmVhZGVyIGRvZXMgYXQgbWF4IHpvb20uXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVCeURQSSA9IERQSSAvIDcyO1xuXG4gICAgICAgICAgICAgICAgLy8gc2NhbGUgYXMgbXVjaCBhcyBwb3NzaWJsZSB3aXRob3V0IGV4Y2VlZGluZyBjYXBEaW1cbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlVG9DYW52YXNTY2FsZSA9IE1hdGgubWluKHNjYWxlQnlEUEksIHNjYWxlQnlEaW0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSW1wb3J0YW50OiB0aGUgbWVhc3VyZSB0b29sIGV4cGVjdHMgaW5jaGVzXG4gICAgICAgICAgICAgICAgLy8gdGFrZSB1c2VyVW5pdCBpbnRvIGFjY291bnQ6IFBERiBzcGVjcyBkZWZpbmUgdXNlclVuaXQgYXMgYSBmYWN0b3Igb24gdGhlIHNpemUgb2YgYSBwdCwgc28gdGhlIGNvbnZlcnNpb24gdG8gaW5jaGVzIGlzIG5vdCAxLzcyLCBidXQgdXNlclVuaXQvNzJcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyVW5pdCA9IHBhZ2UudXNlclVuaXQgfHwgMTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXNUb0luY2hlc1NjYWxlID0gKHVzZXJVbml0IC8gNzIgLyBwYWdlVG9DYW52YXNTY2FsZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHNvdXJjZSBmaWxlIHVuaXQncyBpZiBzdXBwbGllZCBpbiB0aGUgYnViYmxlLlxuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRVbml0cyA9IHNjb3BlLm9wdGlvbnMuYnViYmxlTm9kZT8uZ2V0U291cmNlRmlsZVVuaXRzKCkgfHwgYXZwLk1vZGVsVW5pdHMuSU5DSDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGluY2hlc1RvVGFyZ2V0VW5pdHNTY2FsZSA9IEF1dG9kZXNrLlZpZXdpbmcuUHJpdmF0ZS5jb252ZXJ0VW5pdHMoYXZwLk1vZGVsVW5pdHMuSU5DSCwgdGFyZ2V0VW5pdHMsIDEsIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhc1RvVGFyZ2V0VW5pdFNjYWxlID0gY2FudmFzVG9JbmNoZXNTY2FsZSAqIGluY2hlc1RvVGFyZ2V0VW5pdHNTY2FsZTtcblxuICAgICAgICAgICAgICAgIC8vTmVnYXRpdmUgcm90YXRpb24gYmVjYXVzZSB3ZSBza2lwIHRoZSB5LWZsaXAuXG4gICAgICAgICAgICAgICAgLy9UT0RPOiBuZWVkIHRvIGNoZWNrIGlmIHRoaXMgaXMgcmlnaHQgZm9yIGFsbCByb3RhdGlvbnMsIGlmIG5vdCBqdXN0IGxldCBpdCBmbGlwIHkgYW5kIG5lZ2F0ZSB0aGF0IGluIHRoZSBjYW52YXMgY29udGV4dC5cbiAgICAgICAgICAgICAgICAvLyB2aWV3cG9ydCB3aWxsIHVzZSBjYW52YXMgdW5pdHNcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IHBhZ2VUb0NhbnZhc1NjYWxlLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogLXBhZ2Uucm90YXRlLFxuICAgICAgICAgICAgICAgICAgICBkb250RmxpcDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0ID0gcGFnZS5nZXRWaWV3cG9ydChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydC5jbGlwVG9WaWV3cG9ydCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5yZW5kZXJDb250ZXh0ID0gbmV3IExtdkNhbnZhc0NvbnRleHQodmlld3BvcnQsIGNhbnZhc1RvVGFyZ2V0VW5pdFNjYWxlLCBzY29wZS5wcm9jZXNzUmVjZWl2ZWRNZXNoMkQuYmluZChzY29wZSksIGZlLCBQREZMb2FkZXIudXNlVGV4dExheWVyLCBjb250ZXh0LmZvbnRBdGxhcywgY29udGV4dC5wZGZSZWZPYmpNYXApO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGxpbmVTdHlsZXNcbiAgICAgICAgICAgICAgICBzY29wZS5yZW5kZXJDb250ZXh0LnNldExpbmVTdHlsZVBhcmFtKHNjb3BlLnBhZ2VMaW5lU3R5bGVQYXJhbXMpO1xuICAgICAgICAgICAgICAgIHNjb3BlLnZpZXdlcjNESW1wbC5tYXRtYW4oKS5zZXRMaW5lU3R5bGVUZXh0dXJlKHNjb3BlLnJlbmRlckNvbnRleHQubGluZVN0eWxlVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgc2NvcGUucmVuZGVyQ29udGV4dC5zZXRTbWFsbEltYWdlU2VxdWVuY2VzKHNjb3BlLnNtYWxsSW1hZ2VTZXF1ZW5jZXMpO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUucmVuZGVyQ29udGV4dC5zZXRDaXJjbGVJbmZvKHNjb3BlLmNpcmNsZUluZm8pO1xuXG4gICAgICAgICAgICAgICAgLy8gQXNzaWduIGNvbnNlY3V0aXZlIGRiSWRzLiBUaGUgb25seSBwdXJwb3NlIG9mIHRoZXNlIElEcyBpcyB0byBzcGxpdCB0aGUgcGFnZSBkb3duIGludG8gc21hbGxlciBzaGFwZXMsIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gdXNlIHRoZSBJRCBidWZmZXIgdG8gcXVpY2tseSBmaW5kIHNoYXBlcyBmb3Igc25hcHBpbmcuXG4gICAgICAgICAgICAgICAgc2NvcGUucmVuZGVyQ29udGV4dC5jb25zZWN1dGl2ZUlkcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBib3VuZHMgPSBzY29wZS5yZW5kZXJDb250ZXh0LmJvdW5kcztcblxuICAgICAgICAgICAgICAgIHNjb3BlLnN2ZiA9IHtcbiAgICAgICAgICAgICAgICAgICAgaXMyZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNQZGY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0czogW10sXG4gICAgICAgICAgICAgICAgICAgIGxheWVyc01hcDogeyBcIjBcIjogMCB9LFxuICAgICAgICAgICAgICAgICAgICBsYXllckNvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICBiYm94OiBuZXcgVEhSRUUuQm94MyhuZXcgVEhSRUUuVmVjdG9yMyhib3VuZHMueCwgYm91bmRzLnksIDApLCBuZXcgVEhSRUUuVmVjdG9yMyhib3VuZHMueiwgYm91bmRzLncsIDApKSxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VfZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2Vfd2lkdGg6ICh2aWV3WzJdIC0gdmlld1swXSkgKiBpbmNoZXNUb1RhcmdldFVuaXRzU2NhbGUgKiB1c2VyVW5pdCAvIDcyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VfaGVpZ2h0OiAodmlld1szXSAtIHZpZXdbMV0pICogaW5jaGVzVG9UYXJnZXRVbml0c1NjYWxlICogdXNlclVuaXQgLyA3MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dpY2FsX3dpZHRoOiB2aWV3cG9ydC53aWR0aCAqIGluY2hlc1RvVGFyZ2V0VW5pdHNTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dpY2FsX2hlaWdodDogdmlld3BvcnQuaGVpZ2h0ICogaW5jaGVzVG9UYXJnZXRVbml0c1NjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2ljYWxfb2Zmc2V0X3g6IHZpZXdwb3J0Lm9mZnNldFggKiBpbmNoZXNUb1RhcmdldFVuaXRzU2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9naWNhbF9vZmZzZXRfeTogdmlld3BvcnQub2Zmc2V0WSAqIGluY2hlc1RvVGFyZ2V0VW5pdHNTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlX3VuaXRzOiB0YXJnZXRVbml0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogdmlld3BvcnQucm90YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZTogcGFnZU51bWJlclxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRUcmFuc2Zvcm06IHNjb3BlLm9wdGlvbnMucGxhY2VtZW50VHJhbnNmb3JtPy5jbG9uZSgpLFxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRXaXRoT2Zmc2V0OiBzY29wZS5vcHRpb25zLnBsYWNlbWVudFRyYW5zZm9ybT8uY2xvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nczogW10sXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ0RiSWRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UERGOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUucGRmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAgICAgICAgICAgLy8gbGF5ZXJzIGluZm9ybWF0aW9uIGlzIHJlcXVpcmVkIGJlZm9yZSB3ZSBjYWxsIG9uU3VjY2Vzc1xuICAgICAgICAgICAgICAgIGJ1aWxkTGF5ZXJzKHBhZ2UpLnRoZW4oKGxheWVyc0luZm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3ZmLmxheWVyc1Jvb3QgPSBsYXllcnNJbmZvLmxheWVyc1Jvb3Q7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnN2Zi5sYXllckNvdW50ID0gbGF5ZXJzSW5mby5sYXllckNvdW50O1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5zdmYubGF5ZXJzTWFwID0gbGF5ZXJzSW5mby5sYXllcnNNYXA7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnJlbmRlckNvbnRleHQubGF5ZXJzID0gbGF5ZXJzSW5mby5sYXllcnM7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGFueSBwb3RlbnRpYWwgZXJyb3IgYW5kIGxldCB0aGUgcmVuZGVyaW5nIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChhdnAubG9nZ2VyLmxvZylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gc2NvcGUuYnVpbGRWaWV3cG9ydHMocGFnZSwgc2NvcGUucmVuZGVyQ29udGV4dCkpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh2aWV3cG9ydHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHZpZXdwb3J0c1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3ZmLnZpZXdwb3J0cyA9IHNjb3BlLnJlbmRlckNvbnRleHQudmlld3BvcnRzID0gc2NvcGUucmVuZGVyQ29udGV4dC52aWV3cG9ydHMuY29uY2F0KHZpZXdwb3J0cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5jdXJyZW50TG9hZFBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9IFwiUERGIGxvYWRlciB3YXMgZGVzdHJveWVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzICYmIG9uU3VjY2VzcyhlcnJvck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUub25Nb2RlbFJvb3RMb2FkRG9uZShzY29wZS5zdmYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyhudWxsLCBzY29wZS5tb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS52aWV3ZXIzREltcGwuYXBpLmZpcmVFdmVudCh7IHR5cGU6IGF2Lk1PREVMX1JPT1RfTE9BREVEX0VWRU5ULCBzdmY6IHNjb3BlLnN2ZiwgbW9kZWw6IHNjb3BlLm1vZGVsIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgUERGIHBhZ2UgaW50byBjYW52YXMgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRGb250c0FzeW5jLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW5kZXJUYXNrID0gc2NvcGUuX3JlbmRlclRhc2sgPSBwYWdlLnJlbmRlcihzY29wZS5yZW5kZXJDb250ZXh0LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXNrLnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbExpbmtzICYmIGludGVybmFsTGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIGhvdCBhcmVhIGluIHRoZSBjYW52YXMgdG8gZW5hYmxlIGludGVybmFsIGxpbmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHJlbmRlciB0aGUgaG90QXJlYSBhZnRlciBtYWluIHBhZ2Ugd2FzIHJlbmRlcmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBleHRyYSBkYklEIHdpbGwgYmUgYXNzaWduZWQgdG8gaG90QXJlYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFBERkxvYWRlci5lbmFibGVIeXBlcmxpbmtzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlTGlua0JvdW5kcyhzY29wZS5yZW5kZXJDb250ZXh0LCB2aWV3cG9ydCwgaW50ZXJuYWxMaW5rcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3ZmLm1ldGFkYXRhLmh5cGVyTGlua3MgPSBzY29wZS5kYklkTGlua3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUudmlld2VyM0RJbXBsLmFwaS5sb2FkRXh0ZW5zaW9uKFwiQXV0b2Rlc2suSHlwZXJsaW5rXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9ybWF0IFBERiBkb2N1bWVudCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudFN0cmluZ3M/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBkZk9iamVjdHMgPSBwYWdlPy5jb21tb25PYmpzPy5fb2JqcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZEdseXBocyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGRmT2JqZWN0cyBjb250YWluIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBmb250cyBhbmQgdGhlaXIgcHJvcGVydGllcyBhcyBzaXplLCB3aWR0aCwgc3R5bGUgZXRjLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnkgaXRlcmF0aW5nIHRoaXMgb2JqZWN0LCB3ZSBjYW4gb2J0YWluIGNvbXBhY3Qgb2JqZWN0IHdpdGggcmVsZXZhbnQgY2hhcmFjdGVycyBmb3IgZnVydGhlciBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsIHN0cnVjdHVyZSBvZiBmb3JtYXR0ZWRHbHlwaHMgb2JqZWN0OiBGYW1pbHkgTmFtZS0+IENoYXJhY3RlciAtPiBjaGFyYWN0ZXIgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHBkZk9iamVjdCBpbiBwZGZPYmplY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBkZk9iamVjdHNbcGRmT2JqZWN0XS5kYXRhPy5nbHlwaENhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoQ2FjaGUgPSAgcGRmT2JqZWN0c1twZGZPYmplY3RdLmRhdGEuZ2x5cGhDYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9udE5hbWUgPSBwZGZPYmplY3RzW3BkZk9iamVjdF0uZGF0YS5sb2FkZWROYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wR2x5cGhzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNoYXIgaW4gZ2x5cGhDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pY29kZUNoYXIgPSBnbHlwaENhY2hlW2NoYXJdLnVuaWNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wR2x5cGhzW3VuaWNvZGVDaGFyXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZ2x5cGhDYWNoZVtjaGFyXS53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkR2x5cGhzW2ZvbnROYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBHbHlwaHMsIGZvcm1hdHRlZEdseXBoc1tmb250TmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkU3RyaW5ncyA9IGZvcm1hdFZlY3RvclBkZlN0cmluZ3Moc2NvcGUucmVuZGVyQ29udGV4dCwgcGFnZS5fcGFnZUluZm8sIHZpZXdwb3J0LCBkb2N1bWVudFN0cmluZ3MsIGZvcm1hdHRlZEdseXBocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5zdmYuc3RyaW5ncyA9IGZvcm1hdHRlZFN0cmluZ3Muc3RyaW5ncztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnN2Zi5zdHJpbmdCb3hlcyA9IGZvcm1hdHRlZFN0cmluZ3Muc3RyaW5nQm94ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5zdmYuc3RyaW5nQW5nbGVzID0gZm9ybWF0dGVkU3RyaW5ncy5zdHJpbmdBbmdsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5zdmYuc3RyaW5nQ2hhcldpZHRocyA9IGZvcm1hdHRlZFN0cmluZ3Muc3RyaW5nQ2hhcldpZHRocztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnN2Zi5zdHJpbmdQb3NpdGlvbnMgPSBmb3JtYXR0ZWRTdHJpbmdzLnN0cmluZ1Bvc2l0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnN2Zi5zdHJpbmdIZWlnaHRzID0gZm9ybWF0dGVkU3RyaW5ncy5zdHJpbmdIZWlnaHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3ZmLnN0cmluZ1dpZHRocyA9IGZvcm1hdHRlZFN0cmluZ3Muc3RyaW5nV2lkdGhzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucmVuZGVyQ29udGV4dC5maW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3ZmLm1pbkxpbmVXaWR0aCA9IHNjb3BlLnJlbmRlckNvbnRleHQuY3VycmVudFZiYi5taW5MaW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnN2Zi5tYXhPYmplY3ROdW1iZXIgPSBzY29wZS5yZW5kZXJDb250ZXh0Lm1heERiSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLm9uR2VvbUxvYWREb25lKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBkZkxvYWRUaW1lID0gdDEgLSB0MDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJQREYgbG9hZCB0aW1lXCIsIHBkZkxvYWRUaW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBpeGVsVGltZSA9IHNjb3BlLnQxX2ZpcnN0UGl4ZWwgLSB0MDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGaXJzdCBQaXhlbCBUaW1lXCIsIGZpcnN0UGl4ZWxUaW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IHNjb3BlLm1vZGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW9tTGlzdCA9IG1vZGVsLmdldEdlb21ldHJ5TGlzdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFUb1RyYWNrID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZF90aW1lOiBzY29wZS5sb2FkVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkZl9sb2FkX3RpbWU6IHBkZkxvYWRUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbnM6IGdlb21MaXN0Lmdlb21Qb2x5Q291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudHM6IG1vZGVsLmdldEZyYWdtZW50TGlzdCgpLmdldENvdW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW1fdXNhZ2U6IGdlb21MaXN0LmdwdU1lc2hNZW1vcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lX3RvX2ZpcnN0X3BpeGVsOiBmaXJzdFBpeGVsVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsX3Jhc3Rlcl9waXhlbHM6IG1vZGVsLmdldERvY3VtZW50Tm9kZSgpPy5kYXRhPy50b3RhbFJhc3RlclBpeGVscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdhYmxlX3R5cGU6ICcyZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHNjb3BlLmN1cnJlbnRMb2FkUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybjogc2NvcGUuc3ZmVXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdnAuYW5hbHl0aWNzLnRyYWNrKCd2aWV3ZXIubW9kZWwubG9hZGVkJywgZGF0YVRvVHJhY2spO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhlc2UgYXJlIG5lZWRlZCBpbiBvcmRlciB0byBmcmVlIHRoZSBQREYgbG9hZGVyIGNvbnRleHQgKGl0IGNhY2hlcyBhbGwgUERGIG9wY29kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pbiBhIGdpYW50IGFycmF5KS4gSWRlYWxseSB3ZSB3aWxsIG1vZGlmeSB0aGUgcGRmLmpzIGxpYnJhcnkgdG8gbm90IGFjY3VtdWxhdGUgb3Bjb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoYXQgYXJlIGFscmVhZHkgcHJvY2Vzc2VkLCBzbyB3ZSBkb24ndCBzcGlrZSBtZW1vcnkgYXQgbG9hZCB0aW1lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXNrLl9jYW52YXMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzdWFsbHkgaGFwcGVucyB3aGVuIHRoZSBzd2l0Y2hpbmcgdG8gYW5vdGhlciBQREYgcGFnZSB3aGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBvbmUgaXMgc3RpbGwgZ2V0dGluZyByZW5kZXJlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZwLmxvZ2dlci5sb2coZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLl9yZW5kZXJUYXNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS5jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJ1YmJsZU5vZGUgJiYgdHlwZW9mIChvcHRpb25zLmJ1YmJsZU5vZGUuZ2V0Um9vdE5vZGUoKS5kYXRhLmdldFBERikgPT0gXCJmdW5jdGlvblwiICYmIG9wdGlvbnMuYnViYmxlTm9kZS5nZXRSb290Tm9kZSgpLmRhdGEuZ2V0UERGKCkpIHtcbiAgICAgICAgICAgICAgICBzY29wZS5wZGYgPSBvcHRpb25zLmJ1YmJsZU5vZGUuZ2V0Um9vdE5vZGUoKS5kYXRhLmdldFBERigpO1xuICAgICAgICAgICAgICAgIHNjb3BlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZW5kZXJQYWdlKG9wdGlvbnMuYnViYmxlTm9kZS5kYXRhLnBhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcGRmVGFzayA9IFBERkpTLmdldERvY3VtZW50KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgcGRmVGFzay5vblByb2dyZXNzID0gKHsgbG9hZGVkLCB0b3RhbCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRMb2FkZWQgPSBNYXRoLnJvdW5kKChsb2FkZWQgKiAxMDApIC8gdG90YWwpO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS52aWV3ZXIzREltcGwuc2lnbmFsUHJvZ3Jlc3MocGVyY2VudExvYWRlZCwgYXYuUHJvZ3Jlc3NTdGF0ZS5MT0FESU5HKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgcGRmVGFzayByZWZlcmVuY2UgZm9yIGNsZWFudXAgbGF0ZXJcbiAgICAgICAgICAgICAgICBzY29wZS5wZGZUYXNrID0gcGRmVGFzaztcblxuICAgICAgICAgICAgICAgIHJldHVybiBwZGZUYXNrLnByb21pc2UudGhlbihwZGYgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5wZGYgPSBwZGY7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZ2VOdW1iZXIgPSBvcHRpb25zLnBhZ2UgfHwgcGFyc2VJbnQoYXZwLmdldFBhcmFtZXRlckJ5TmFtZShcInBhZ2VcIikpIHx8IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLm9wdGlvbnMgJiYgIXNjb3BlLm9wdGlvbnMuYnViYmxlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBkZk1haW4gPSBzY29wZS5jcmVhdGVQREZEb2N1bWVudChwZGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUub3B0aW9ucy5idWJibGVOb2RlID0gcGRmTWFpbi5nZXRSb290KCkuY2hpbGRyZW5bcGFnZU51bWJlciAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlclBhZ2UocGFnZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyAmJiBvblN1Y2Nlc3MoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5QREZMb2FkZXIucHJvdG90eXBlLmxvYWRPbkRlbWFuZEZvbnRzID0gZnVuY3Rpb24gKHBhZ2UsIGZlKSB7XG4gICAgY29uc3QgY29tbW9uT2JqcyA9IHBhZ2UuY29tbW9uT2Jqcy5fb2JqcztcbiAgICBjb25zdCBsb2FkZWRGb250cyA9IHt9O1xuICAgIGNvbnN0IGxvYWRQcm9taXNlcyA9IFtdO1xuICAgIGZvciAobGV0IG5hbWUgaW4gY29tbW9uT2Jqcykge1xuICAgICAgICBjb25zdCBmb250ID0gY29tbW9uT2Jqc1tuYW1lXTtcbiAgICAgICAgaWYgKGZvbnQ/LmRhdGE/Lm1pc3NpbmdGaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBmb250TmFtZSA9IGZvbnQ/LmRhdGE/Lm5hbWU7XG4gICAgICAgICAgICBpZiAoZm9udE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb250RGVzY3JpcHRvciA9IGZlLmdldE9uRGVtYW5kRm9udChmb250TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvbnREZXNjcmlwdG9yICYmICFsb2FkZWRGb250c1tmb250RGVzY3JpcHRvci5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkUHJvbWlzZXMucHVzaChmZS5sb2FkRm9udChmb250RGVzY3JpcHRvcikpO1xuICAgICAgICAgICAgICAgICAgICBsb2FkZWRGb250c1tmb250RGVzY3JpcHRvci5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxvYWRQcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkUHJvbWlzZXMpO1xufTtcblxuXG4vKipcbiAqIExvb3AgYWxsIHRoZSBvcGVyYXRvciBjb21tYW5kIHRvIGRldGVjdCB3aGV0aGVyIGl0IGlzIGEgY2lyY2xlLlxuICovXG5QREZMb2FkZXIucHJvdG90eXBlLmRldGVjdENpcmNsZSA9IGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gMC4wMDE7XG4gICAgY29uc3QgbWFnaWMgPSAoNCAvIDMpICogTWF0aC50YW4oTWF0aC5QSSAvIDgpO1xuICAgIGNvbnN0IG1hZ2ljMiA9IG1hZ2ljICogbWFnaWM7XG4gICAgbGV0IHAxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICBsZXQgcDIgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIGxldCBwMyA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgbGV0IHA0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgIGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSB0aHJlc2hvbGQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVseUVxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPiAwICYmIGIgPiAwICYmIGVxdWFsKE1hdGguYWJzKGEtYikvYSwgdGhyZXNob2xkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgaWYgaXQgaXMgYSBwcmltaXRpdmUgY2lyY2xlXG4gICAgICogIGl0IHdpbGwgaGF2ZSBhIDEzLCAxNSwgMTUsIDE1LCAxNSwgWzE4XVxuICAgICAqICBSZWZlcmVuY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3MzQ3NDUvaG93LXRvLWNyZWF0ZS1jaXJjbGUtd2l0aC1iJUMzJUE5emllci1jdXJ2ZXNcbiAgICAgKiBAcGFyYW0geyp9IGZuQXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IGFyZ3NBcnJheVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrUGF0dGVybihmbkFycmF5LCBhcmdzQXJyYXkpIHtcbiAgICAgICAgaWYgKChmbkFycmF5Lmxlbmd0aCA9PSA1IHx8IGZuQXJyYXkubGVuZ3RoID09IDYpICYmIGFyZ3NBcnJheS5sZW5ndGggPT0gMjYpIHtcbiAgICAgICAgICAgIGlmIChmbkFycmF5WzBdID09IDEzICYmIGZuQXJyYXlbMV0gPT0gMTUgJiYgZm5BcnJheVsyXSA9PSAxNSAmJiBmbkFycmF5WzNdID09IDE1ICYmIGZuQXJyYXlbNF0gPT0gMTUgJiYgKGZuQXJyYXlbNV0gPT0gMTggfHwgZm5BcnJheVs1XSA9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gdGhlIG1hdGggdG8gZmlndXJlIG91dCB3aGV0aGVyIGl0IGlzIGEgY2lyY2xlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzQXJyYXkubGVuZ3RoIC0gNjsgaSArPSA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHAxLnNldChhcmdzQXJyYXlbaV0sIGFyZ3NBcnJheVtpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICBwMi5zZXQoYXJnc0FycmF5W2kgKyAyXSwgYXJnc0FycmF5W2kgKyAzXSk7XG4gICAgICAgICAgICAgICAgICAgIHAzLnNldChhcmdzQXJyYXlbaSArIDRdLCBhcmdzQXJyYXlbaSArIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgcDQuc2V0KGFyZ3NBcnJheVtpICsgNl0sIGFyZ3NBcnJheVtpICsgN10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrUXVhdGVyQ2lyY2xlKHAxLCBwMiwgcDMsIHA0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrUXVhdGVyQ2lyY2xlKHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgIGxldCBwMTIgPSBwMi5jbG9uZSgpLnN1YihwMSk7XG4gICAgICAgIGxldCBwNDMgPSBwMy5jbG9uZSgpLnN1YihwNCk7XG4gICAgICAgIGxldCBsMTIgPSBwMTIubGVuZ3RoU3EoKTtcbiAgICAgICAgbGV0IGw0MyA9IHA0My5sZW5ndGhTcSgpO1xuICAgICAgICBsZXQgcmFkaXVzID0gcDQuZGlzdGFuY2VUb1NxdWFyZWQocDEpIC8gMjtcblxuICAgICAgICBsZXQgcmVzdWx0ID0gbDEyID4gMCAmJiBsNDMgPiAwICYmIHJlbGF0aXZlbHlFcXVhbChsMTIsIGw0MylcbiAgICAgICAgICAgICYmIGVxdWFsKHAxMi5ub3JtYWxpemUoKS5kb3QocDQzLm5vcm1hbGl6ZSgpKSwgMClcbiAgICAgICAgICAgICYmIGVxdWFsKGwxMiAvIHJhZGl1cywgbWFnaWMyKVxuICAgICAgICAgICAgJiYgZXF1YWwobDQzIC8gcmFkaXVzLCBtYWdpYzIpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0T3BlcmF0b3JMaXN0KHBhZ2UpLnRoZW4oKG9wcykgPT4ge1xuICAgICAgICBsZXQgY2lyY2xlSW5mbyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wcy5mbkFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAob3BzLmZuQXJyYXlbaV0gPT0gUERGSlMuT1BTLmNvbnN0cnVjdFBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRyeSB0byBkZXRlY3Qgd2hldGhlciB0aGVyZSBpcyBjaXJjbGUgaW4gdGhpcyBjb21tYW5kXG4gICAgICAgICAgICAgICAgbGV0IGZuMSA9IG9wcy5hcmdzQXJyYXlbaV1bMF07XG4gICAgICAgICAgICAgICAgbGV0IGFyZ3MxID0gb3BzLmFyZ3NBcnJheVtpXVsxXTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGVja1BhdHRlcm4oZm4xLCBhcmdzMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcDEuc2V0KGFyZ3MxWzBdLCBhcmdzMVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHAyLnNldChhcmdzMVs2XSwgYXJnczFbN10pO1xuICAgICAgICAgICAgICAgICAgICBwMy5zZXQoYXJnczFbMTJdLCBhcmdzMVsxM10pO1xuICAgICAgICAgICAgICAgICAgICBwNC5zZXQoYXJnczFbMThdLCBhcmdzMVsxOV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwMTIgPSBwMi5jbG9uZSgpLnN1YihwMSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwMjMgPSBwMy5jbG9uZSgpLnN1YihwMik7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGwxMiA9IHAxMi5sZW5ndGhTcSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbDIzID0gcDIzLmxlbmd0aFNxKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsMzQgPSBwMy5kaXN0YW5jZVRvU3F1YXJlZChwNCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsNDEgPSBwNC5kaXN0YW5jZVRvU3F1YXJlZChwMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIDQgcG9pbnRzIGlzIGEgc3F1YXJlXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlbGF0aXZlbHlFcXVhbChsMTIsIGwyMykgJiYgcmVsYXRpdmVseUVxdWFsKGwzNCwgbDQxKSAmJiByZWxhdGl2ZWx5RXF1YWwobDEyLCBsNDEpICYmIGVxdWFsKHAxMi5ub3JtYWxpemUoKS5kb3QocDIzLm5vcm1hbGl6ZSgpKSwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB4ID0gMCwgeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFyZ3MxLmxlbmd0aCAtIDY7IGsgKz0gNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gYXJnczFba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBhcmdzMVtrICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZUluZm9baV0gPSBbeCAvIDQsIHkgLyA0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2lyY2xlSW5mbyA9IGNpcmNsZUluZm87XG4gICAgfSk7XG59O1xuXG5cblBERkxvYWRlci5wcm90b3R5cGUucHJvY2Vzc1JlY2VpdmVkTWVzaCA9IGZ1bmN0aW9uIChtZGF0YSkge1xuXG4gICAgLy9GaW5kIGFsbCBmcmFnbWVudHMgdGhhdCBpbnN0YW5jZSB0aGlzIG1lc2hcbiAgICB2YXIgbWVzaGlkID0gbWRhdGEucGFja0lkICsgXCI6XCIgKyBtZGF0YS5tZXNoSW5kZXg7XG5cbiAgICB2YXIgc3ZmID0gdGhpcy5zdmY7XG4gICAgdmFyIGZyYWdtZW50cyA9IHN2Zi5mcmFnbWVudHM7XG5cbiAgICB2YXIgZnJhZ0luZGV4ZXMgPSBmcmFnbWVudHMubWVzaDJmcmFnW21lc2hpZF07XG4gICAgaWYgKGZyYWdJbmRleGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXZwLmxvZ2dlci53YXJuKFwiTWVzaCBcIiArIG1lc2hpZCArIFwiIHdhcyBub3QgcmVmZXJlbmNlZCBieSBhbnkgZnJhZ21lbnRzLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJhZ0luZGV4ZXMpKVxuICAgICAgICBmcmFnSW5kZXhlcyA9IFtmcmFnSW5kZXhlc107XG5cbiAgICB2YXIgcm0gPSB0aGlzLm1vZGVsO1xuXG4gICAgLy8gQmFja2dyb3VuZCBkYmlkIGlzIC0xLiBIaWRlIGl0IHdoZW4gaGlkZUJhY2tncm91bmQgaXMgc2V0LlxuICAgIC8vIFRoaXMgbGluZSBoYXMgdG8gYmUgYmVmb3JlIGNhbGxpbmcgbWVzaFRvR2VvbWV0cnksIGJlY2F1c2UgbWRhdGEubWVzaCBpcyBzZXQgdG8gbnVsbCBpbnNpZGUgb2YgaXQuXG4gICAgaWYgKG1kYXRhLm1lc2guZGJJZHNbLTFdICYmIHRoaXMub3B0aW9ucy5oaWRlQmFja2dyb3VuZCkge1xuICAgICAgICBybS5jaGFuZ2VQYXBlclZpc2liaWxpdHkoZmFsc2UpO1xuICAgIH1cblxuICAgIC8vQ29udmVydCB0aGUgcmVjZWl2ZWQgbWVzaCB0byBUSFJFRSBidWZmZXIgZ2VvbWV0cnlcbiAgICBjb25zdCBnZW9tZXRyeSA9IGF2cC5CdWZmZXJHZW9tZXRyeVV0aWxzLm1lc2hUb0dlb21ldHJ5KG1kYXRhKTtcblxuXG4gICAgLy8gQWRkIGdlb21ldHJ5IHRvIGVuc3VyZSBQREYgZGF0YSBpcyB0YWtlbiBpbnRvIGFjY291bnQgZm9yIGdwdSBtZW1vcnkgbGltaXRzXG4gICAgY29uc3QgZ2VvbUlkID0gcm0uZ2V0R2VvbWV0cnlMaXN0KCkuYWRkR2VvbWV0cnkoZ2VvbWV0cnksIGZyYWdJbmRleGVzLmxlbmd0aCwgbWRhdGEubWVzaEluZGV4ICsgMSk7XG5cbiAgICBjb25zdCBwb2x5Q291bnQgPSBhdnAuZ2V0UG9seWdvbkNvdW50KGdlb21ldHJ5KTtcblxuICAgIC8vRm9yIGVhY2ggZnJhZ21lbnQsIGFkZCBhIG1lc2ggaW5zdGFuY2UgdG8gdGhlIHJlbmRlcmVyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFnSW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZnJhZ0lkID0gMCB8IGZyYWdJbmRleGVzW2ldO1xuXG4gICAgICAgIC8vV2UgZ2V0IHRoZSBtYXRyaXggZnJvbSB0aGUgZnJhZ21lbnRzIGFuZCB3ZSBzZXQgaXQgYmFjayB0aGVyZVxuICAgICAgICAvL3dpdGggdGhlIGFjdGl2YXRlRnJhZ21lbnQgY2FsbCwgYnV0IHRoaXMgaXMgdG8gbWFpbnRhaW4gdGhlXG4gICAgICAgIC8vYWJpbGl0eSB0byBhZGQgYSBwbGFpbiBUSFJFRS5NZXNoIC0tIG90aGVyd2lzZSBpdCBjb3VsZCBiZSBzaW1wbGVyXG4gICAgICAgIHJtLmdldEZyYWdtZW50TGlzdCgpLmdldE9yaWdpbmFsV29ybGRNYXRyaXgoZnJhZ0lkLCB0aGlzLnRtcE1hdHJpeCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wbGFjZW1lbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRoaXMudG1wTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5tdWx0aXBseU1hdHJpY2VzKHRoaXMub3B0aW9ucy5wbGFjZW1lbnRUcmFuc2Zvcm0sIHRoaXMudG1wTWF0cml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXRlcmlhbElkID0gZnJhZ21lbnRzLm1hdGVyaWFsc1tmcmFnSWRdLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKGZyYWdtZW50cy5wb2x5Z29uQ291bnRzKVxuICAgICAgICAgICAgZnJhZ21lbnRzLnBvbHlnb25Db3VudHNbZnJhZ0lkXSA9IHBvbHlDb3VudDtcblxuICAgICAgICB2YXIgbSA9IHRoaXMudmlld2VyM0RJbXBsLnNldHVwTWVzaCh0aGlzLm1vZGVsLCBnZW9tZXRyeSwgbWF0ZXJpYWxJZCwgdGhpcy50bXBNYXRyaXgpO1xuICAgICAgICBybS5hY3RpdmF0ZUZyYWdtZW50KGZyYWdJZCwgbSk7XG4gICAgfVxuXG4gICAgLy9kb24ndCBuZWVkIHRoaXMgbWFwcGluZyBhbnltb3JlLlxuICAgIGZyYWdtZW50cy5tZXNoMmZyYWdbbWVzaGlkXSA9IG51bGw7XG5cbiAgICAvL1JlcGFpbnQgYW5kIHByb2dyZXNzIHJlcG9ydGluZ1xuICAgIGZyYWdtZW50cy5udW1Mb2FkZWQgKz0gZnJhZ0luZGV4ZXMubGVuZ3RoO1xuXG4gICAgdGhpcy52aWV3ZXIzREltcGwuc2lnbmFsTmV3R2VvbWV0cnlBZGRlZChnZW9tSWQsIHRoaXMubW9kZWwpO1xuXG4gICAgaWYgKCF0aGlzLnQxX2ZpcnN0UGl4ZWwpIHtcbiAgICAgICAgdGhpcy50MV9maXJzdFBpeGVsID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuXG4gICAgLy9yZXBhaW50IGV2ZXJ5IG9uY2UgaW4gYSB3aGlsZSAtLSBtb3JlIGluaXRpYWxseSwgbGVzcyBhcyB0aGUgbG9hZCBkcmFncyBvbi5cbiAgICBpZiAoZnJhZ21lbnRzLm51bUxvYWRlZCA+IGZyYWdtZW50cy5uZXh0UmVwYWludCkge1xuICAgICAgICAvL2F2cC5sb2dnZXIubG9nKFwibnVtIGxvYWRlZCBcIiArIGZyYWdtZW50cy5udW1Mb2FkZWQpO1xuICAgICAgICBzdmYubnVtUmVwYWludHMrKztcbiAgICAgICAgZnJhZ21lbnRzLm5leHRSZXBhaW50ICs9IDYgKiBNYXRoLnBvdygxLjc1LCBzdmYubnVtUmVwYWludHMpO1xuICAgICAgICB0aGlzLnZpZXdlcjNESW1wbC5hcGkuZGlzcGF0Y2hFdmVudCh7dHlwZTogYXYuTE9BREVSX1JFUEFJTlRfUkVRVUVTVF9FVkVOVCwgbG9hZGVyOiB0aGlzLCBtb2RlbDogdGhpcy5tb2RlbH0pO1xuICAgIH1cbn07XG5cblBERkxvYWRlci5wcm90b3R5cGUucHJvY2Vzc1JlY2VpdmVkTWVzaDJEID0gZnVuY3Rpb24gKG1lc2gsIG1pbmRleCkge1xuXG4gICAgdmFyIG1kYXRhID0geyBtZXNoOiBtZXNoLCBpczJkOiB0cnVlLCBwYWNrSWQ6IFwiMFwiLCBtZXNoSW5kZXg6IG1pbmRleCB9O1xuXG4gICAgdmFyIG1lc2hJZCA9IFwiMDpcIiArIG1pbmRleDtcblxuICAgIHZhciBmcmFncyA9IHRoaXMuc3ZmLmZyYWdtZW50cztcblxuICAgIC8vUmVtZW1iZXIgdGhlIGxpc3Qgb2YgYWxsIGRiSWRzIHJlZmVyZW5jZWQgYnkgdGhpcyBtZXNoLlxuICAgIC8vSW4gdGhlIDJEIGNhc2UgdGhpcyBpcyAxLT5tYW55ICgxIGZyYWcgPSBtYW55IGRiSWRzKSBtYXBwaW5nIGluc3RlYWQgb2ZcbiAgICAvLyAxIGRiSWQgLT4gbWFueSBmcmFnbWVudHMgbGlrZSBpbiB0aGUgU1ZGIDNEIGNhc2UuXG4gICAgdmFyIGRiSWRzID0gT2JqZWN0LmtleXMobWRhdGEubWVzaC5kYklkcykubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBwYXJzZUludChpdGVtKTsgfSk7XG4gICAgZnJhZ3MuZnJhZ0lkMmRiSWRbbWluZGV4XSA9IGRiSWRzO1xuXG4gICAgLy9UT0RPOiBkYklkMmZyYWdJZCBpcyBub3QgcmVhbGx5IG5lY2Vzc2FyeSBpZiB3ZSBoYXZlIGEgZ29vZCBpbnN0YW5jZSB0cmVlIGZvciB0aGUgMkQgZHJhd2luZyAoZS5nLiBSZXZpdCwgQXV0b0NBRClcbiAgICAvL3NvIHdlIGNhbiBnZXQgcmlkIG9mIHRoaXMgbWFwcGluZyBpZiB3ZSBjYW4gY29udmVydCBWaWV3ZXIzREltcGwuaGlnaGxpZ2h0RnJhZ21lbnQgdG8gdXNlIHRoZSBzYW1lIGxvZ2ljIGZvciAyRCBhcyBmb3IgM0QuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYklkcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZGJJZCA9IGRiSWRzW2pdO1xuICAgICAgICB2YXIgZnJhZ0lkcyA9IGZyYWdzLmRiSWQyZnJhZ0lkW2RiSWRdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmcmFnSWRzKSlcbiAgICAgICAgICAgIGZyYWdJZHMucHVzaChtaW5kZXgpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZnJhZ0lkcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZnJhZ3MuZGJJZDJmcmFnSWRbZGJJZF0gPSBbZnJhZ0lkcywgbWluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyYWdzLmRiSWQyZnJhZ0lkW2RiSWRdID0gbWluZGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbW9kZWxGcmFncyA9IHRoaXMubW9kZWwuZ2V0RnJhZ21lbnRMaXN0KCk7XG5cbiAgICBmcmFncy5tZXNoMmZyYWdbbWVzaElkXSA9IG1pbmRleDtcbiAgICBtZXNoLm1hdGVyaWFsLm1vZGVsU2NhbGUgPSB0aGlzLm1vZGVsU2NhbGU7XG4gICAgbWVzaC5tYXRlcmlhbC5kb05vdEN1dCA9IHRoaXMub3B0aW9ucy5kb05vdEN1dCB8fCBtb2RlbEZyYWdzPy5nZXREb05vdEN1dCgpO1xuICAgIGlmIChtb2RlbEZyYWdzPy52aWV3Qm91bmRzKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IG1vZGVsRnJhZ3Mudmlld0JvdW5kcztcbiAgICAgICAgbWVzaC5tYXRlcmlhbC52aWV3cG9ydEJvdW5kcyA9IG5ldyBUSFJFRS5WZWN0b3I0KGJvdW5kcy5taW4ueCwgYm91bmRzLm1pbi55LCBib3VuZHMubWF4LngsIGJvdW5kcy5tYXgueSk7XG4gICAgfVxuXG4gICAgZnJhZ3MubWF0ZXJpYWxzW21pbmRleF0gPSB0aGlzLnZpZXdlcjNESW1wbC5tYXRtYW4oKS5jcmVhdGUyRE1hdGVyaWFsKHRoaXMubW9kZWwsIG1lc2gubWF0ZXJpYWwpO1xuXG4gICAgZnJhZ3MubGVuZ3RoKys7XG5cbiAgICB0aGlzLnByb2Nlc3NSZWNlaXZlZE1lc2gobWRhdGEpO1xuXG59O1xuXG5QREZMb2FkZXIucHJvdG90eXBlLm9uTW9kZWxSb290TG9hZERvbmUgPSBmdW5jdGlvbiAoc3ZmKSB7XG5cbiAgICAvL0luIHRoZSAyZCBjYXNlIHdlIGNyZWF0ZSBhbmQgYnVpbGQgdXAgdGhlIGZyYWdtZW50cyBtYXBwaW5nXG4gICAgLy9vbiB0aGUgcmVjZWl2aW5nIGVuZC5cbiAgICBzdmYuZnJhZ21lbnRzID0ge307XG4gICAgc3ZmLmZyYWdtZW50cy5tZXNoMmZyYWcgPSB7fTtcbiAgICBzdmYuZnJhZ21lbnRzLm1hdGVyaWFscyA9IFtdO1xuICAgIHN2Zi5mcmFnbWVudHMuZnJhZ0lkMmRiSWQgPSBbXTtcbiAgICBzdmYuZnJhZ21lbnRzLmRiSWQyZnJhZ0lkID0gW107XG4gICAgc3ZmLmZyYWdtZW50cy5sZW5ndGggPSAwO1xuICAgIHN2Zi5mcmFnbWVudHMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG5cbiAgICBzdmYuZ2VvbVBvbHlDb3VudCA9IDA7XG4gICAgc3ZmLmluc3RhbmNlUG9seUNvdW50ID0gMDtcbiAgICBzdmYuZnJhZ21lbnRzLm51bUxvYWRlZCA9IDA7XG4gICAgc3ZmLmZyYWdtZW50cy5uZXh0UmVwYWludCA9IDU7XG4gICAgc3ZmLm1lc2hDb3VudCA9IDA7XG5cbiAgICBzdmYubmV4dFJlcGFpbnRQb2x5cyA9IDEwMDAwO1xuICAgIHN2Zi5udW1SZXBhaW50cyA9IDA7XG5cbiAgICBzdmYudXJuID0gdGhpcy5zdmZVcm47XG4gICAgc3ZmLmFjbVNlc3Npb25JZCA9IHRoaXMuYWNtU2Vzc2lvbklkO1xuXG4gICAgc3ZmLmJhc2VQYXRoID0gXCJcIjtcbiAgICB2YXIgbGFzdFNsYXNoID0gdGhpcy5jdXJyZW50TG9hZFBhdGgubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChsYXN0U2xhc2ggIT09IC0xKVxuICAgICAgICBzdmYuYmFzZVBhdGggPSB0aGlzLmN1cnJlbnRMb2FkUGF0aC5zdWJzdHIoMCwgbGFzdFNsYXNoICsgMSk7XG5cbiAgICBzdmYubG9hZE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB2YXIgdDEgPSBEYXRlLm5vdygpO1xuICAgIGF2cC5sb2dnZXIubG9nKFwiUERGIHJvb3QgbG9hZDogXCIgKyAodDEgLSB0aGlzLnQwKSk7XG5cbiAgICB0aGlzLnQxID0gdDE7XG5cbiAgICAvL1RoZSBCQm94IG9iamVjdCBsb3NlcyBrbm93bGVkZ2Ugb2YgaXRzXG4gICAgLy90eXBlIHdoZW4gZ29pbmcgYWNyb3NzIHRoZSB3b3JrZXIgdGhyZWFkIGJvdW5kYXJ5Li4uXG4gICAgc3ZmLmJib3ggPSBuZXcgVEhSRUUuQm94MygpLmNvcHkoc3ZmLmJib3gpO1xuICAgIHN2Zi5tb2RlbFNwYWNlQkJveCA9IHN2Zi5iYm94LmNsb25lKCk7XG5cbiAgICBpZiAoc3ZmLnBsYWNlbWVudFRyYW5zZm9ybSkge1xuICAgICAgICBzdmYuYmJveC5hcHBseU1hdHJpeDQoc3ZmLnBsYWNlbWVudFRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLy9DcmVhdGUgdGhlIEFQSSBNb2RlbCBvYmplY3QgYW5kIGl0cyByZW5kZXIgcHJveHlcbiAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsID0gbmV3IGF2Lk1vZGVsKHN2Zik7XG4gICAgbW9kZWwubG9hZGVyID0gdGhpcztcblxuICAgIG1vZGVsLmluaXRpYWxpemUoKTtcblxuICAgIC8vIFVwZGF0ZSB2aWV3cG9ydCBib3VuZHMgYWNjb3JkaW5nIHRvIG1vZGVsIGNsaXBwZWQgYm91bmRzLiAoU2VlIExtdkNhbnZhc0NvbnRleHQpXG4gICAgbW9kZWwuc2V0Vmlld3BvcnRCb3VuZHModGhpcy52aWV3ZXIzREltcGwubWF0bWFuKCksIHN2Zi5tb2RlbFNwYWNlQkJveCk7XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5za2lwUHJvcGVydHlEYikge1xuICAgICAgICB0aGlzLnN2Zi5wcm9wRGJMb2FkZXIgPSBuZXcgYXZwLlByb3BEYkxvYWRlcih0aGlzLnNoYXJlZERiUGF0aCwgdGhpcy5tb2RlbCwgdGhpcy52aWV3ZXIzREltcGwuYXBpKTtcbiAgICB9XG5cbiAgICBhdnAubG9nZ2VyLmxvZyhcInNjZW5lIGJvdW5kczogXCIgKyBKU09OLnN0cmluZ2lmeShzdmYuYmJveCkpO1xuXG4gICAgdmFyIG1ldGFkYXRhU3RhdHMgPSB7XG4gICAgICAgIGNhdGVnb3J5OiBcIm1ldGFkYXRhX2xvYWRfc3RhdHNcIixcbiAgICAgICAgdXJuOiBzdmYudXJuLFxuICAgICAgICBsYXllcnM6IHN2Zi5sYXllckNvdW50XG4gICAgfTtcbiAgICBhdnAubG9nZ2VyLnRyYWNrKG1ldGFkYXRhU3RhdHMpO1xuXG4gICAgdGhpcy52aWV3ZXIzREltcGwuc2V0RG9Ob3RDdXQobW9kZWwsICEhdGhpcy5vcHRpb25zLmRvTm90Q3V0KTtcblxuICAgIHRoaXMudmlld2VyM0RJbXBsLnNpZ25hbFByb2dyZXNzKDUsIGF2LlByb2dyZXNzU3RhdGUuUk9PVF9MT0FERUQsIG1vZGVsKTtcbn07XG5cblxuUERGTG9hZGVyLnByb3RvdHlwZS5vbkdlb21Mb2FkRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN2Zi5sb2FkRG9uZSA9IHRydWU7XG5cbiAgICAvLyBEb24ndCBuZWVkIHRoZXNlIGFueW1vcmVcbiAgICB0aGlzLnN2Zi5mcmFnbWVudHMuZW50aXR5SW5kZXhlcyA9IG51bGw7XG4gICAgdGhpcy5zdmYuZnJhZ21lbnRzLm1lc2gyZnJhZyA9IG51bGw7XG5cbiAgICB2YXIgdDIgPSBEYXRlLm5vdygpO1xuICAgIHZhciBtc2cgPSBcIkZyYWdtZW50cyBsb2FkIHRpbWU6IFwiICsgKHQyIC0gdGhpcy50MSk7XG4gICAgdGhpcy5sb2FkVGltZSA9IHQyIC0gdGhpcy50MDtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLnNraXBQcm9wZXJ0eURiKSB7XG4gICAgICAgIHRoaXMubG9hZFByb3BlcnR5RGIoKTtcbiAgICB9XG5cbiAgICBhdnAubG9nZ2VyLmxvZyhtc2cpO1xuXG4gICAgdmFyIG1vZGVsU3RhdHMgPSB7XG4gICAgICAgIGNhdGVnb3J5OiBcIm1vZGVsX2xvYWRfc3RhdHNcIixcbiAgICAgICAgaXNfZjJkOiB0cnVlLFxuICAgICAgICBoYXNfcHJpc206IHRoaXMudmlld2VyM0RJbXBsLm1hdG1hbigpLmhhc1ByaXNtLFxuICAgICAgICBsb2FkX3RpbWU6IHRoaXMubG9hZFRpbWUsXG4gICAgICAgIGdlb21ldHJ5X3NpemU6IHRoaXMubW9kZWwuZ2V0R2VvbWV0cnlMaXN0KCkuZ2VvbU1lbW9yeSxcbiAgICAgICAgbWVzaGVzX2NvdW50OiB0aGlzLm1vZGVsLmdldEdlb21ldHJ5TGlzdCgpLmdldENvdW50KCksXG4gICAgICAgIHVybjogdGhpcy5zdmZVcm5cbiAgICB9O1xuICAgIGF2cC5sb2dnZXIudHJhY2sobW9kZWxTdGF0cywgdHJ1ZSk7XG5cbiAgICB0aGlzLnZpZXdlcjNESW1wbC5vbkxvYWRDb21wbGV0ZSh0aGlzLm1vZGVsKTtcbn07XG5cblBERkxvYWRlci5wcm90b3R5cGUubG9hZFByb3BlcnR5RGIgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmICh0aGlzLnN2Zi5wcm9wRGJMb2FkZXIpIHtcbiAgICAgICAgdGhpcy5zdmYucHJvcERiTG9hZGVyLmxvYWQoKTtcbiAgICB9XG59O1xuXG5QREZMb2FkZXIucHJvdG90eXBlLmlzM2QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUERGTG9hZGVyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyQ29udGV4dCkge1xuICAgICAgICB0aGlzLnJlbmRlckNvbnRleHQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnJlbmRlckNvbnRleHQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmKHRoaXMucGRmKSB7XG4gICAgICAgIHRoaXMucGRmLmNsZWFudXAoKTtcbiAgICB9XG59O1xuXG5QREZMb2FkZXIucHJvdG90eXBlLmdldE9wZXJhdG9yTGlzdCA9IGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgLy8gVXNlIHRoZSBzYW1lICdkaXNwbGF5JyBpbnRlbnQgZm9yIGV2ZXJ5dGhpbmcsIGluIG9yZGVyIHRvIHNhdmUgbWVtb3J5LlxuICAgIHJldHVybiBwYWdlLmdldE9wZXJhdG9yTGlzdCgnZGlzcGxheScpO1xufTtcbiJdLCJuYW1lcyI6WyJQREZKUyIsInRoZUZvbnRFbmdpbmUiLCJMbXZDYW52YXNDb250ZXh0IiwiaXNSZWYiLCJyZWZLZXkiLCJNT0JJTEVfRElNX0NBUCIsIkZJUkVGT1hfRElNX0NBUCIsIkRFRkFVTFRfRElNX0NBUCIsImluaXRDb21wR2VvbSIsIkF1dG9kZXNrIiwiRXh0ZW5zaW9ucyIsIkNvbXBHZW9tIiwiUERGV29ya2luZ1JlZmVyZW5jZU1hcCIsIkRlZmZlcmVkRGVzdHJveVRpbWUiLCJhdiIsIlZpZXdpbmciLCJhdnAiLCJQcml2YXRlIiwiUERGTG9hZGVyIiwicGFyZW50IiwiaXNQZGZMb2FkZXIiLCJ2aWV3ZXIzREltcGwiLCJzZXRHbG9iYWxNYW5hZ2VyIiwiZ2xvYmFsTWFuYWdlciIsImxvYWRpbmciLCJ0bXBNYXRyaXgiLCJUSFJFRSIsIk1hdHJpeDQiLCJsb2dnZXIiLCJsb2FkVGltZSIsIm5vdGlmaWVzRmlyc3RQaXhlbCIsInQxX2ZpcnN0UGl4ZWwiLCJ1bmRlZmluZWQiLCJkdG9yIiwiYmluZCIsImFwaSIsImFkZEV2ZW50TGlzdGVuZXIiLCJWSUVXRVJfVU5JTklUSUFMSVpFRCIsIm9uY2UiLCJHbG9iYWxNYW5hZ2VyTWl4aW4iLCJjYWxsIiwicHJvdG90eXBlIiwiY3JlYXRlUERGRG9jdW1lbnQiLCJwZGYiLCJudW1QYWdlcyIsImd1aWQiLCJmaW5nZXJwcmludCIsIm1lIiwidHlwZSIsInRvdGFsUmFzdGVyUGl4ZWxzIiwiZ2V0UERGIiwiX3RyYW5zcG9ydCIsImRlc3Ryb3llZCIsImNoaWxkcmVuIiwiaSIsInB1c2giLCJyb2xlIiwic3RhdHVzIiwicHJvZ3Jlc3MiLCJ2aWV3YWJsZUlEIiwibmFtZSIsImkxOG4iLCJ0cmFuc2xhdGUiLCJwYWdlIiwiQnViYmxlTm9kZSIsIlBERl9QQUdFX05PREUiLCJ1cm4iLCJzdmZVcm4iLCJEb2N1bWVudCIsInN2ZiIsInByb3BEYkxvYWRlciIsImN1cnJlbnRMb2FkUGF0aCIsImlzZjJkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNldFRpbWVvdXQiLCJkZXN0cm95IiwiX3JlbmRlclRhc2siLCJjYW5jZWwiLCJvcHRpb25zIiwibG9nIiwibG9hZEZpbGUiLCJwYXRoIiwib25TdWNjZXNzIiwib25Xb3JrZXJTdGFydCIsInVybklkeCIsImluZGV4T2YiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzdWJzdHIiLCJfaW5kZXgiLCJsYXN0SW5kZXhPZiIsInFJZHgiLCJzbGljZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInNoYXJlZERiUGF0aCIsInNoYXJlZFByb3BlcnR5RGJQYXRoIiwiYWNtU2Vzc2lvbklkIiwicXVlcnlQYXJhbXMiLCJlbmRwb2ludCIsImdldFF1ZXJ5UGFyYW1zIiwiZmlsdGVyIiwicCIsImpvaW4iLCJwbGFjZW1lbnRUcmFuc2Zvcm0iLCJtb2RlbFNjYWxlIiwiZ2V0TWF4U2NhbGVPbkF4aXMiLCJzY29wZSIsImxvYWRGeWRvQ0IiLCJnZXREb2N1bWVudCIsImJ1YmJsZU5vZGUiLCJnZXRSb290Tm9kZSIsImRhdGEiLCJnZXRGb250R2VuZXJhdG9yIiwibG9hZEV4dGVuc2lvbiIsInRoZW4iLCJnZW5lcmF0b3IiLCJNU0RGIiwiR2VuZXJhdG9yIiwiY3JlYXRlRm9udEF0bGFzIiwiY2FjaGVLZXkiLCJlbmFibGVNU0RGVGV4dCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZ2V0T3BlcmF0b3JMaXN0IiwiY3JlYXRlRm9udEF0bGFzRm9yUERGIiwiZm9udEF0bGFzIiwiZXZhbHVhdGVQYWdlTGluZVN0eWxlcyIsInciLCJjYWNoZVNldCIsIlNldCIsImZuQXJyYXkiLCJsZW5ndGgiLCJPUFMiLCJzZXREYXNoIiwiTWF0aCIsIm1heCIsImFyZ3NBcnJheSIsImtleSIsImFkZCIsImgiLCJzaXplIiwicGFnZUxpbmVTdHlsZVBhcmFtcyIsIndpZHRoIiwiaGVpZ2h0IiwiZGV0ZWN0U21hbGxJbWFnZVNlcXVlbmNlcyIsIk1BWF9PUF9ESVNUQU5DRSIsIk1JTl9PUFMiLCJNQVhfUEFHRV9VTklUX0RJU1RBTkNFIiwiaXNTbWFsbEltYWdlIiwiaW5kZXgiLCJvcCIsInBhaW50SnBlZ1hPYmplY3QiLCJwYWludEltYWdlWE9iamVjdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdCIsInBhaW50SW5saW5lSW1hZ2VYT2JqZWN0IiwiZmluZFNlcXVlbmNlU3RhcnQiLCJlbmQiLCJxIiwicUNvdW50Iiwic2F2ZSIsInNob3dUZXh0Iiwic2hvd1NwYWNlZFRleHQiLCJuZXh0TGluZVNob3dUZXh0IiwibmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQiLCJyZXN0b3JlIiwiZmluZFNlcXVlbmNlRW5kIiwibWluIiwiYWRkUG9pbnRCQm94IiwiYmJveCIsIngiLCJ5IiwiYWRkSW1hZ2VCQm94IiwieGZvcm0iLCJwcm9jZXNzIiwic2VxdWVuY2VTdGFydCIsImxhc3RTbWFsbEltYWdlIiwic21hbGxJbWFnZVNlcXVlbmNlcyIsImN1cnJYZm9ybSIsInhmb3JtU3RhY2siLCJiZWdpblNlcXVlbmNlIiwiZW5kU2VxdWVuY2UiLCJzdGFydCIsInRyYW5zZm9ybSIsIm0iLCJhIiwicG9wIiwiYmJveEltZyIsImNhdGNoIiwiZml4VGlsaW5nUGF0dGVybnNXaXRoSHVnZUdhcHMiLCJNQVhfR0FQX0ZBQ1RPUiIsIkJVRkZFUl9GQUNUT1IiLCJzZXRGaWxsQ29sb3JOIiwiYXJncyIsInhzdGVwIiwieXN0ZXAiLCJiYm94V2lkdGgiLCJiYm94SGVpZ2h0IiwibG9hZE1hcmtlZENvbnRlbnRQcm9wZXJ0aWVzUmVmZXJlbmNlcyIsInJlZmVyZW5jZU9iak1hcCIsImdldFJlZk9iaiIsInJlZiIsImdldE9iamVjdCIsInZhbHVlIiwiY2hpbGRQcm9taXNlcyIsImlzRGljdGlvbmFyeSIsIml0ZW1LZXkiLCJkYXRhMSIsImFsbCIsIm9wcyIsInByb21pc2VzIiwiYmVnaW5NYXJrZWRDb250ZW50IiwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHMiLCJhcmdzMSIsImoiLCJwcm9taXNlIiwidDAiLCJEYXRlIiwibm93Iiwic3ZmUGF0aCIsInBhdGhUb1VSTCIsImNNYXBVcmwiLCJjTWFwUGFja2VkIiwiZ2V0UmVzb3VyY2VVcmwiLCJwYXJhbXMiLCJ1cmwiLCJkaXNhYmxlRm9udEZhY2UiLCJzdG9wQXRFcnJvcnMiLCJpc0V2YWxTdXBwb3J0ZWQiLCJnZXRVc2VDb29raWUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJodHRwSGVhZGVycyIsIkhUVFBfUkVRVUVTVF9IRUFERVJTIiwiX3NpZ25hbE5vTWVzaGVzIiwiZmUiLCJsb2FkRm9udHNBc3luYyIsImxvYWRGb250cyIsImdldEludGVybmFsTGlua3MiLCJnZXRBbm5vdGF0aW9ucyIsImFubm90YXRpb25zIiwibWFwIiwiYW5ub3RhdGlvbiIsInN1YnR5cGUiLCJwYWdlSW5kZXhQcm9taXNlIiwiZGVzdCIsImdldERlc3RpbmF0aW9uIiwiZGVzdEluZm8iLCJnZXRQYWdlSW5kZXgiLCJBcnJheSIsInBhZ2VJbmRleCIsImludGVybmFsTGlua3MiLCJpdGVtIiwiZXJyb3IiLCJ1cGRhdGVMaW5rQm91bmRzIiwicmVuZGVyQ29udGV4dCIsInZpZXdwb3J0IiwiZGJJZExpbmtzIiwiZGJJZCIsImdldEN1cnJlbnRUcmFuc2Zvcm0iLCJyZWN0IiwiY3JlYXRlUmVjdEJ5Vmlld3BvcnRUcmFuc2Zvcm0iLCJsaW5rTm9kZSIsImxvYWRPcHRpb25zIiwicHJvcGVydGllcyIsImRpc3BsYXlWYWx1ZSIsImJveCIsInRlbXBSZWN0IiwiY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUiLCJ0eCIsInR5Iiwicm90YXRlQXJvdW5kIiwiY2VudGVyIiwiYW5nbGUiLCJjIiwiY29zIiwicyIsInNpbiIsImZvcm1hdFZlY3RvclBkZlN0cmluZ3MiLCJyZW5kZXJDdHgiLCJwYWdlSW5mbyIsInZlY3RvclN0cmluZ3MiLCJmb3JtYXR0ZWRHbHlwaHMiLCJzdHJpbmdzIiwic3RyaW5nQm94ZXMiLCJzdHJpbmdBbmdsZXMiLCJzdHJpbmdDaGFyV2lkdGhzIiwic3RyaW5nUG9zaXRpb25zIiwic3RyaW5nSGVpZ2h0cyIsInN0cmluZ1dpZHRocyIsInJlbmRlckN0eFRyYW5zZm9ybSIsImN1cnJlbnRUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1GdW5jIiwibTEiLCJtMiIsIml0ZW1zIiwidGVtcE9iamVjdCIsInRlbXBDaGFyV2lkdGgiLCJrIiwic3RyIiwidGVtcEZvbnROYW1lIiwiZm9udE5hbWUiLCJ0ZW1wU3RyaW5nIiwiY29uc29sZSIsIndhcm4iLCJ0ZXh0V2lkdGgiLCJ0ZXh0SGVpZ2h0Iiwic3RyVHgiLCJzdHJBbmdsZSIsImF0YW4yIiwibWluWCIsIm1heFgiLCJtaW5ZIiwibWF4WSIsIkJveDIiLCJzZXRGcm9tUG9pbnRzIiwiVmVjdG9yMiIsImRlZ1RvUmFkIiwicm90YXRlIiwiYnVpbGRWaWV3cG9ydHMiLCJ2aWV3cG9ydHMiLCJfcHJvY2Vzc1Byb3BlcnRpZXMiLCJWUCIsInZwIiwiX2dldE1vZGVsVG9WaWV3cG9ydE1hdHJpeCIsIlVOSVRTIiwiY3JlYXRlVmlld1BvcnREYXRhIiwiUFJFQ0lTSU9OIiwiYnVpbGRMYXllcnMiLCJsYXllcnMiLCJsYXllclN0YXJ0SW5kZXgiLCJmbiIsImdldExheWVyS2V5IiwiZ2V0UGFnZU9DR05hbWVzIiwibGF5ZXJOYW1lTWFwIiwibGF5ZXJzUm9vdCIsImlkIiwiaXNMYXllciIsImxheWVyc01hcCIsImxheWVyQ291bnQiLCJsYXllcktleSIsIl9sIiwibCIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwibGF5ZXIiLCJ2aXNpYmxlIiwidW5zaGlmdCIsImdldFN0cmluZ3MiLCJkb2N1bWVudFN0cmluZ3MiLCJyZWFkYWJsZVN0cmVhbSIsInN0cmVhbVRleHRDb250ZW50Iiwibm9ybWFsaXplV2hpdGVzcGFjZSIsImNvbWJpbmVUZXh0SXRlbXMiLCJwdW1wIiwicmVhZGVyIiwicmVhZCIsIl9yZWYiLCJkb25lIiwiZ2V0UmVhZGVyIiwicmVuZGVyUGFnZSIsInBhZ2VOdW1iZXIiLCJtb2RlbCIsInVubG9hZE1vZGVsIiwiY29udGV4dCIsImdldFBhZ2UiLCJleHRlbmRTdHJpbmdzRmV0Y2hpbmciLCJkZXRlY3RDaXJjbGUiLCJsb2FkT25EZW1hbmRGb250cyIsInBkZlJlZk9iak1hcCIsIl9zY29wZSRvcHRpb25zJGJ1YmJsZSIsIl9zY29wZSRvcHRpb25zJHBsYWNlbSIsIl9zY29wZSRvcHRpb25zJHBsYWNlbTIiLCJ2aWV3Iiwicm90YXRpb25NYXRyaXgiLCJtYWtlUm90YXRpb25aIiwiUEkiLCJyb3RhdGVkVmlld1ZlYzEiLCJWZWN0b3IzIiwiYXBwbHlNYXRyaXg0Iiwicm90YXRlZFZpZXdWZWMyIiwibWF4RGltIiwiY2FwRGltIiwiaXNNb2JpbGVEZXZpY2UiLCJpc0ZpcmVmb3giLCJzY2FsZUJ5RGltIiwiRFBJIiwic2NhbGVCeURQSSIsInBhZ2VUb0NhbnZhc1NjYWxlIiwidXNlclVuaXQiLCJjYW52YXNUb0luY2hlc1NjYWxlIiwidGFyZ2V0VW5pdHMiLCJnZXRTb3VyY2VGaWxlVW5pdHMiLCJNb2RlbFVuaXRzIiwiSU5DSCIsImluY2hlc1RvVGFyZ2V0VW5pdHNTY2FsZSIsImNvbnZlcnRVbml0cyIsImNhbnZhc1RvVGFyZ2V0VW5pdFNjYWxlIiwic2NhbGUiLCJyb3RhdGlvbiIsImRvbnRGbGlwIiwiZ2V0Vmlld3BvcnQiLCJjbGlwVG9WaWV3cG9ydCIsInByb2Nlc3NSZWNlaXZlZE1lc2gyRCIsInVzZVRleHRMYXllciIsInNldExpbmVTdHlsZVBhcmFtIiwibWF0bWFuIiwic2V0TGluZVN0eWxlVGV4dHVyZSIsImxpbmVTdHlsZVRleHR1cmUiLCJzZXRTbWFsbEltYWdlU2VxdWVuY2VzIiwic2V0Q2lyY2xlSW5mbyIsImNpcmNsZUluZm8iLCJjb25zZWN1dGl2ZUlkcyIsImJvdW5kcyIsImlzMmQiLCJpc1BkZiIsIkJveDMiLCJ6IiwibWV0YWRhdGEiLCJwYWdlX2RpbWVuc2lvbnMiLCJwYWdlX3dpZHRoIiwicGFnZV9oZWlnaHQiLCJsb2dpY2FsX3dpZHRoIiwibG9naWNhbF9oZWlnaHQiLCJsb2dpY2FsX29mZnNldF94Iiwib2Zmc2V0WCIsImxvZ2ljYWxfb2Zmc2V0X3kiLCJvZmZzZXRZIiwicGFnZV91bml0cyIsImN1cnJlbnRQYWdlIiwiY2xvbmUiLCJwbGFjZW1lbnRXaXRoT2Zmc2V0Iiwic3RyaW5nRGJJZHMiLCJwZXJmb3JtYW5jZSIsImxheWVyc0luZm8iLCJjb25jYXQiLCJlcnJvck1zZyIsIm9uTW9kZWxSb290TG9hZERvbmUiLCJmaXJlRXZlbnQiLCJNT0RFTF9ST09UX0xPQURFRF9FVkVOVCIsInJlbmRlclRhc2siLCJyZW5kZXIiLCJfZG9jdW1lbnRTdHJpbmdzIiwiX21vZGVsJGdldERvY3VtZW50Tm9kIiwiZW5hYmxlSHlwZXJsaW5rcyIsImh5cGVyTGlua3MiLCJfcGFnZSRjb21tb25PYmpzIiwicGRmT2JqZWN0cyIsImNvbW1vbk9ianMiLCJfb2JqcyIsInBkZk9iamVjdCIsIl9wZGZPYmplY3RzJHBkZk9iamVjdCIsImdseXBoQ2FjaGUiLCJsb2FkZWROYW1lIiwidGVtcEdseXBocyIsImNoYXIiLCJ1bmljb2RlQ2hhciIsInVuaWNvZGUiLCJhc3NpZ24iLCJmb3JtYXR0ZWRTdHJpbmdzIiwiX3BhZ2VJbmZvIiwiZmluaXNoIiwibWluTGluZVdpZHRoIiwiY3VycmVudFZiYiIsIm1heE9iamVjdE51bWJlciIsIm1heERiSWQiLCJvbkdlb21Mb2FkRG9uZSIsInQxIiwicGRmTG9hZFRpbWUiLCJmaXJzdFBpeGVsVGltZSIsImdlb21MaXN0IiwiZ2V0R2VvbWV0cnlMaXN0IiwiZGF0YVRvVHJhY2siLCJsb2FkX3RpbWUiLCJwZGZfbG9hZF90aW1lIiwicG9seWdvbnMiLCJnZW9tUG9seUNvdW50IiwiZnJhZ21lbnRzIiwiZ2V0RnJhZ21lbnRMaXN0IiwiZ2V0Q291bnQiLCJtZW1fdXNhZ2UiLCJncHVNZXNoTWVtb3J5IiwidGltZV90b19maXJzdF9waXhlbCIsInRvdGFsX3Jhc3Rlcl9waXhlbHMiLCJnZXREb2N1bWVudE5vZGUiLCJ2aWV3YWJsZV90eXBlIiwiYW5hbHl0aWNzIiwidHJhY2siLCJfY2FudmFzIiwiZXJyIiwiZmluYWxseSIsImNsZWFudXAiLCJwZGZUYXNrIiwib25Qcm9ncmVzcyIsIl9yZWYyIiwibG9hZGVkIiwidG90YWwiLCJwZXJjZW50TG9hZGVkIiwicm91bmQiLCJzaWduYWxQcm9ncmVzcyIsIlByb2dyZXNzU3RhdGUiLCJMT0FESU5HIiwicGFyc2VJbnQiLCJnZXRQYXJhbWV0ZXJCeU5hbWUiLCJwZGZNYWluIiwiZ2V0Um9vdCIsImxvYWRlZEZvbnRzIiwibG9hZFByb21pc2VzIiwiX2ZvbnQkZGF0YSIsImZvbnQiLCJtaXNzaW5nRmlsZSIsIl9mb250JGRhdGEyIiwiZm9udERlc2NyaXB0b3IiLCJnZXRPbkRlbWFuZEZvbnQiLCJsb2FkRm9udCIsInRocmVzaG9sZCIsIm1hZ2ljIiwidGFuIiwibWFnaWMyIiwicDEiLCJwMiIsInAzIiwicDQiLCJlcXVhbCIsImIiLCJhYnMiLCJyZWxhdGl2ZWx5RXF1YWwiLCJjaGVja1BhdHRlcm4iLCJzZXQiLCJjaGVja1F1YXRlckNpcmNsZSIsInAxMiIsInN1YiIsInA0MyIsImwxMiIsImxlbmd0aFNxIiwibDQzIiwicmFkaXVzIiwiZGlzdGFuY2VUb1NxdWFyZWQiLCJyZXN1bHQiLCJub3JtYWxpemUiLCJkb3QiLCJjb25zdHJ1Y3RQYXRoIiwiZm4xIiwicDIzIiwibDIzIiwibDM0IiwibDQxIiwicHJvY2Vzc1JlY2VpdmVkTWVzaCIsIm1kYXRhIiwibWVzaGlkIiwicGFja0lkIiwibWVzaEluZGV4IiwiZnJhZ0luZGV4ZXMiLCJtZXNoMmZyYWciLCJpc0FycmF5Iiwicm0iLCJtZXNoIiwiZGJJZHMiLCJoaWRlQmFja2dyb3VuZCIsImNoYW5nZVBhcGVyVmlzaWJpbGl0eSIsImdlb21ldHJ5IiwiQnVmZmVyR2VvbWV0cnlVdGlscyIsIm1lc2hUb0dlb21ldHJ5IiwiZ2VvbUlkIiwiYWRkR2VvbWV0cnkiLCJwb2x5Q291bnQiLCJnZXRQb2x5Z29uQ291bnQiLCJmcmFnSWQiLCJnZXRPcmlnaW5hbFdvcmxkTWF0cml4IiwibXVsdGlwbHlNYXRyaWNlcyIsIm1hdGVyaWFsSWQiLCJtYXRlcmlhbHMiLCJ0b1N0cmluZyIsInBvbHlnb25Db3VudHMiLCJzZXR1cE1lc2giLCJhY3RpdmF0ZUZyYWdtZW50IiwibnVtTG9hZGVkIiwic2lnbmFsTmV3R2VvbWV0cnlBZGRlZCIsIm5leHRSZXBhaW50IiwibnVtUmVwYWludHMiLCJwb3ciLCJkaXNwYXRjaEV2ZW50IiwiTE9BREVSX1JFUEFJTlRfUkVRVUVTVF9FVkVOVCIsImxvYWRlciIsIm1pbmRleCIsIm1lc2hJZCIsImZyYWdzIiwia2V5cyIsImZyYWdJZDJkYklkIiwiZnJhZ0lkcyIsImRiSWQyZnJhZ0lkIiwibW9kZWxGcmFncyIsIm1hdGVyaWFsIiwiZG9Ob3RDdXQiLCJnZXREb05vdEN1dCIsInZpZXdCb3VuZHMiLCJ2aWV3cG9ydEJvdW5kcyIsIlZlY3RvcjQiLCJjcmVhdGUyRE1hdGVyaWFsIiwiaW5pdGlhbGl6ZWQiLCJpbnN0YW5jZVBvbHlDb3VudCIsIm1lc2hDb3VudCIsIm5leHRSZXBhaW50UG9seXMiLCJiYXNlUGF0aCIsImxhc3RTbGFzaCIsImNvcHkiLCJtb2RlbFNwYWNlQkJveCIsIk1vZGVsIiwiaW5pdGlhbGl6ZSIsInNldFZpZXdwb3J0Qm91bmRzIiwic2tpcFByb3BlcnR5RGIiLCJQcm9wRGJMb2FkZXIiLCJKU09OIiwic3RyaW5naWZ5IiwibWV0YWRhdGFTdGF0cyIsImNhdGVnb3J5Iiwic2V0RG9Ob3RDdXQiLCJST09UX0xPQURFRCIsImxvYWREb25lIiwiZW50aXR5SW5kZXhlcyIsInQyIiwibXNnIiwibG9hZFByb3BlcnR5RGIiLCJtb2RlbFN0YXRzIiwiaXNfZjJkIiwiaGFzX3ByaXNtIiwiaGFzUHJpc20iLCJnZW9tZXRyeV9zaXplIiwiZ2VvbU1lbW9yeSIsIm1lc2hlc19jb3VudCIsIm9uTG9hZENvbXBsZXRlIiwibG9hZCIsImlzM2QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./extensions/PDF/PDFLoader.js\n");

/***/ }),

/***/ "./extensions/PDF/PDFTextLayer.js":
/*!****************************************!*\
  !*** ./extensions/PDF/PDFTextLayer.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PDFTextLayer: () => (/* binding */ PDFTextLayer)\n/* harmony export */ });\n/* harmony import */ var _textlayer_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./textlayer.css */ \"./extensions/PDF/textlayer.css\");\n/* harmony import */ var _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @adsk/pdfjs-dist */ \"./node_modules/@adsk/pdfjs-dist/legacy/build/pdf.js\");\n/* harmony import */ var _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _PDFFontExtractor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PDFFontExtractor */ \"./extensions/PDF/PDFFontExtractor.js\");\n/**\n * PDF Text Layer is hiden on top of our drawings\n * And it will provide the possible user experience to select/hightlight/copy/search\n * From Vector PDF Document\n */\n\n\n\n\n\nvar av = Autodesk.Viewing;\nvar avu = Autodesk.Viewing.UI;\n\nfunction PDFTextLayer(viewer, usingTextLayer) {\n  this.viewer = viewer;\n  this.setGlobalManager(viewer.globalManager);\n\n  this.onModelLoaded = this.onModelLoaded.bind(this);\n  this.onRenderFinished = this.onRenderFinished.bind(this);\n  this.onModelUnload = this.onModelUnload.bind(this);\n\n  viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.onModelLoaded);\n  viewer.addEventListener(av.PROGRESS_UPDATE_EVENT, this.onRenderFinished);\n  viewer.addEventListener(av.MODEL_UNLOADED_EVENT, this.onModelUnload);\n\n  this.usingTextLayer = usingTextLayer;\n  this.textSelectionEnabled = false;\n}\n\nav.GlobalManagerMixin.call(PDFTextLayer.prototype);\n\nPDFTextLayer.prototype.addToolbarButton = function () {\n  if (this.toolButtonAdded) return;\n  this.toolButtonAdded = true;\n\n  if (!this.viewer.getToolbar) return;\n  var toolbar = this.viewer.getToolbar();\n  if (!toolbar) return;\n  var modelTools = toolbar.getControl(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);\n  if (!modelTools) return;\n\n  var button = new avu.Button('toolbar-pdf-text-selection');\n  // Need CSS for the ICON and the actual icon\n  button.setIcon(\"adsk-icon-pdf-textselection\");\n  button.setToolTip(\"Select Text\");\n  modelTools.addControl(button);\n  this.toolbarButton = button;\n\n\n  button.onClick = () => {\n    this.textSelectionEnabled = !this.textSelectionEnabled;\n    if (this.textLayerDiv) {\n      if (this.textSelectionEnabled) {\n        this.textLayerDiv.classList.add(\"enabled\");\n        this.viewer.toolController.enableMouseButtons(false);\n      } else {\n        this.textLayerDiv.classList.remove(\"enabled\");\n        this.viewer.toolController.enableMouseButtons(true);\n        this.clearSelection();\n      }\n      this.toolbarButton.setState(this.textSelectionEnabled ? avu.Button.State.ACTIVE : avu.Button.State.INACTIVE);\n    }\n  };\n};\n\nPDFTextLayer.prototype.clearSelection = function () {\n  const _document = this.getDocument();\n  const _window = this.getWindow();\n  if (_window.getSelection) {\n    if (_window.getSelection().empty) {// Chrome\n      _window.getSelection().empty();\n    } else if (_window.getSelection().removeAllRanges) {// Firefox\n      _window.getSelection().removeAllRanges();\n    }\n  } else if (_document.selection) {// IE?\n    _document.selection.empty();\n  }\n};\n\nPDFTextLayer.prototype.destroy = function () {\n  this.onModelUnload();\n\n  this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.onModelLoaded);\n  this.viewer.removeEventListener(av.PROGRESS_UPDATE_EVENT, this.onRenderFinished);\n  this.viewer.removeEventListener(av.MODEL_UNLOADED_EVENT, this.onModelUnload);\n\n  this.removeToolbarButton();\n};\n\nPDFTextLayer.prototype.removeToolbarButton = function () {\n  if (this.toolbarButton) {\n    this.toolbarButton.removeFromParent();\n    this.toolbarButton = null;\n  }\n};\n\nPDFTextLayer.prototype.onRenderFinished = function (event) {\n  if (event.percent == 100 && event.state === av.ProgressState.RENDERING && this.centerTextlayer) {\n    this.centerTextlayer();\n  }\n};\n\nPDFTextLayer.prototype.onModelUnload = function () {\n  this.centerTextlayer = null;\n  if (this.textLayerDiv) {\n    this.textLayerDiv.remove();\n    this.textLayerDiv = null;\n  }\n};\n\nPDFTextLayer.prototype.onModelLoaded = function (event) {\n  if (this.viewer.model && this.viewer.model.isPdf() && typeof this.viewer.model.getData().getPDF === \"function\") {\n    const pageNumber = this.viewer.model.getData().metadata.currentPage;\n    const pdf = this.viewer.model.getData().getPDF();\n    const model = this.viewer.model;\n    pdf.getPage(pageNumber).then((page) => {\n\n      // Note that the model might be unloaded or replaced by a (maybe non-pdf) one meanwhile.\n      if (this.viewer.model !== model) {\n        return;\n      }\n\n      this.renderTextLayer(page);\n    });\n  }\n};\n\nPDFTextLayer.prototype.renderTextLayer = function renderTextlayer(page) {\n  const _document = this.getDocument();\n  const readableStream = page.streamTextContent({ normalizeWhitespace: true, combineTextItems: true });\n  const textLayerDiv = _document.createElement('div');\n  var options = {\n    scale: 1,\n    rotation: page.rotate,\n    dontFlip: false\n  };\n  const viewport = page.getViewport(options);\n  textLayerDiv.style.height = `${viewport.height}px`;\n  textLayerDiv.style.width = `${viewport.width}px`;\n  textLayerDiv.classList.add(\"pdf-textlayer\");\n\n  var scope = this;\n\n  this.viewer.canvasWrap.append(textLayerDiv);\n  this.textLayerDiv = textLayerDiv;\n\n  // loop the style to check whether this text was loaded\n  function getLoadedFonts() {\n    const _document = scope.getDocument();\n    let nodes = _document.getElementsByTagName(\"style\");\n    let names = {};\n    for (let i = 0; i < nodes.length; i++) {\n      if (nodes[i].getAttribute(\"datatype\") === \"fonts\") {\n        names[nodes[i].getAttribute(\"id\")] = 1;\n      }\n    }\n    return names;\n  }\n\n  // need to make the html overlay the same position as canvas\n  function mapModelBoundsToScreen() {\n    let bounds = scope.viewer.model.getBoundingBox();\n    let min = scope.viewer.worldToClient(bounds.min);\n    let max = scope.viewer.worldToClient(bounds.max);\n\n    return {\n      min: {\n        x: Math.min(min.x, max.x),\n        y: Math.min(min.y, max.y),\n        z: Math.min(min.z, max.z)\n      },\n      max: {\n        x: Math.max(min.x, max.x),\n        y: Math.max(min.y, max.y),\n        z: Math.max(min.z, max.z)\n      }\n    };\n  }\n\n  function centerTextlayer() {\n\n    // PDF model might have been removed meanwhile\n    if (!scope.viewer.model) {\n      return;\n    }\n\n    // get transform matrix for the textLayer\n    // scale\n    let screenBounds = mapModelBoundsToScreen();\n    let width = screenBounds.max.x - screenBounds.min.x;\n    let height = screenBounds.max.y - screenBounds.min.y;\n    let scale1 = Math.min(width / viewport.width, height / viewport.height);\n\n    let matrix = new THREE.Matrix4().makeTranslation(viewport.width / 2, viewport.height / 2, 0);\n    matrix = new THREE.Matrix4().makeScale(scale1, scale1, 1).multiply(matrix);\n    matrix = new THREE.Matrix4().makeTranslation(-viewport.width / 2, -viewport.height / 2, 0).multiply(matrix);\n    let left = screenBounds.min.x;\n    let top = screenBounds.min.y;\n\n    matrix = new THREE.Matrix4().makeTranslation(left, top, 0).multiply(matrix);\n    let el = matrix.elements;\n    let transform1 = `matrix(${[el[0], el[1], el[4], el[5], el[12], el[13]].join(\",\")})`;\n    textLayerDiv.style.transform = transform1;\n  }\n\n  function render() {\n    let textDivs = [];\n    return _adsk_pdfjs_dist__WEBPACK_IMPORTED_MODULE_1__.renderTextLayer({\n      pageIndex: page.pageNumber,\n      textDivs: textDivs,\n      viewport,\n      enhanceTextSelection: true,\n      textContentStream: readableStream,\n      container: textLayerDiv\n    }).promise.then(() => {\n      if (scope.usingTextLayer) {\n        textLayerDiv.classList.add(\"visible\");\n      }\n      if (textDivs.length > 0) {\n        scope.addToolbarButton();\n      }\n      centerTextlayer();\n    });\n  }\n\n  var promise = Promise.resolve();\n  if (this.usingTextLayer) {\n    // for now only extract the font library when we show the text layer\n    // because it will increase the loading time, will not use it for selection\n    // But, if we decide to use it for selection, the selection/highlight will be more accurate\n    promise = (0,_PDFFontExtractor__WEBPACK_IMPORTED_MODULE_2__.cssFontExtractor)(page, getLoadedFonts()).then((data) => {\n      var fonts = [];\n      const _document = this.getDocument();\n      for (var i = 0; i < data.length; i++) {\n        let fontStyle = _document.createElement(\"style\");\n        _document.getElementsByTagName(\"head\")[0].append(fontStyle);\n        fontStyle.innerHTML = data[i].css;\n        fontStyle.setAttribute(\"id\", data[i].name);\n        fontStyle.setAttribute(\"datatype\", \"fonts\");\n        fonts.push(data[i].name);\n      }\n\n      return fonts;\n    }).then((names) => {\n      // preload the fonts\n      const _document = this.getDocument();\n      var promises = names.map((name) => {\n        return _document.fonts.load(`10pt ${name}`);\n      });\n      return Promise.all(promises);\n    }).catch();\n  }\n\n  promise.then(render);\n\n  this.centerTextlayer = centerTextlayer;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQ00sSUFBSSxDQUFDUCxJQUFJLENBQUNyQyxDQUFDLENBQUMsQ0FBQzJDLElBQUksQ0FBQztNQUM1Qjs7TUFFQSxPQUFPTCxLQUFLO0lBQ2hCLENBQUMsQ0FBQyxDQUFDaEUsSUFBSSxDQUFDLENBQUN5QixLQUFLLEtBQUs7TUFDZjtNQUNBLE1BQU1wRCxTQUFTLEdBQUcsSUFBSSxDQUFDQyxXQUFXLENBQUMsQ0FBQztNQUNwQyxJQUFJaUcsUUFBUSxHQUFHOUMsS0FBSyxDQUFDK0MsR0FBRyxDQUFDLENBQUNILElBQUksS0FBSztRQUMvQixPQUFPaEcsU0FBUyxDQUFDMkYsS0FBSyxDQUFDUyxJQUFJLENBQUUsUUFBT0osSUFBSyxFQUFDLENBQUM7TUFDL0MsQ0FBQyxDQUFDO01BQ0YsT0FBT1IsT0FBTyxDQUFDYSxHQUFHLENBQUNILFFBQVEsQ0FBQztJQUNoQyxDQUFDLENBQUMsQ0FBQ0ksS0FBSyxDQUFDLENBQUM7RUFDZDs7RUFFQWYsT0FBTyxDQUFDNUQsSUFBSSxDQUFDc0QsTUFBTSxDQUFDOztFQUVwQixJQUFJLENBQUNoRSxlQUFlLEdBQUdBLGVBQWU7QUFDMUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0F1dG9kZXNrLkV4dGVuc2lvbnMvLi9leHRlbnNpb25zL1BERi9QREZUZXh0TGF5ZXIuanM/YjdkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBERiBUZXh0IExheWVyIGlzIGhpZGVuIG9uIHRvcCBvZiBvdXIgZHJhd2luZ3NcbiAqIEFuZCBpdCB3aWxsIHByb3ZpZGUgdGhlIHBvc3NpYmxlIHVzZXIgZXhwZXJpZW5jZSB0byBzZWxlY3QvaGlnaHRsaWdodC9jb3B5L3NlYXJjaFxuICogRnJvbSBWZWN0b3IgUERGIERvY3VtZW50XG4gKi9cblxuaW1wb3J0IFwiLi90ZXh0bGF5ZXIuY3NzXCI7XG5pbXBvcnQgKiBhcyBQREZKUyBmcm9tIFwiQGFkc2svcGRmanMtZGlzdFwiO1xuaW1wb3J0IHsgY3NzRm9udEV4dHJhY3RvciB9IGZyb20gXCIuL1BERkZvbnRFeHRyYWN0b3JcIjtcblxudmFyIGF2ID0gQXV0b2Rlc2suVmlld2luZztcbnZhciBhdnUgPSBBdXRvZGVzay5WaWV3aW5nLlVJO1xuXG5leHBvcnQgZnVuY3Rpb24gUERGVGV4dExheWVyKHZpZXdlciwgdXNpbmdUZXh0TGF5ZXIpIHtcbiAgICB0aGlzLnZpZXdlciA9IHZpZXdlcjtcbiAgICB0aGlzLnNldEdsb2JhbE1hbmFnZXIodmlld2VyLmdsb2JhbE1hbmFnZXIpO1xuXG4gICAgdGhpcy5vbk1vZGVsTG9hZGVkID0gdGhpcy5vbk1vZGVsTG9hZGVkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblJlbmRlckZpbmlzaGVkID0gdGhpcy5vblJlbmRlckZpbmlzaGVkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbk1vZGVsVW5sb2FkID0gdGhpcy5vbk1vZGVsVW5sb2FkLmJpbmQodGhpcyk7XG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihhdi5HRU9NRVRSWV9MT0FERURfRVZFTlQsIHRoaXMub25Nb2RlbExvYWRlZCk7XG4gICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoYXYuUFJPR1JFU1NfVVBEQVRFX0VWRU5ULCB0aGlzLm9uUmVuZGVyRmluaXNoZWQpO1xuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKGF2Lk1PREVMX1VOTE9BREVEX0VWRU5ULCB0aGlzLm9uTW9kZWxVbmxvYWQpO1xuXG4gICAgdGhpcy51c2luZ1RleHRMYXllciA9IHVzaW5nVGV4dExheWVyO1xuICAgIHRoaXMudGV4dFNlbGVjdGlvbkVuYWJsZWQgPSBmYWxzZTtcbn1cblxuYXYuR2xvYmFsTWFuYWdlck1peGluLmNhbGwoUERGVGV4dExheWVyLnByb3RvdHlwZSk7XG5cblBERlRleHRMYXllci5wcm90b3R5cGUuYWRkVG9vbGJhckJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50b29sQnV0dG9uQWRkZWQpIHJldHVybjtcbiAgICB0aGlzLnRvb2xCdXR0b25BZGRlZCA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMudmlld2VyLmdldFRvb2xiYXIpIHJldHVybjtcbiAgICB2YXIgdG9vbGJhciA9IHRoaXMudmlld2VyLmdldFRvb2xiYXIoKTtcbiAgICBpZiAoIXRvb2xiYXIpIHJldHVybjtcbiAgICB2YXIgbW9kZWxUb29scyA9IHRvb2xiYXIuZ2V0Q29udHJvbChBdXRvZGVzay5WaWV3aW5nLlRPT0xCQVIuTU9ERUxUT09MU0lEKTtcbiAgICBpZiAoIW1vZGVsVG9vbHMpIHJldHVybjtcblxuICAgIHZhciBidXR0b24gPSBuZXcgYXZ1LkJ1dHRvbigndG9vbGJhci1wZGYtdGV4dC1zZWxlY3Rpb24nKTtcbiAgICAvLyBOZWVkIENTUyBmb3IgdGhlIElDT04gYW5kIHRoZSBhY3R1YWwgaWNvblxuICAgIGJ1dHRvbi5zZXRJY29uKFwiYWRzay1pY29uLXBkZi10ZXh0c2VsZWN0aW9uXCIpO1xuICAgIGJ1dHRvbi5zZXRUb29sVGlwKFwiU2VsZWN0IFRleHRcIik7XG4gICAgbW9kZWxUb29scy5hZGRDb250cm9sKGJ1dHRvbik7XG4gICAgdGhpcy50b29sYmFyQnV0dG9uID0gYnV0dG9uO1xuXG5cbiAgICBidXR0b24ub25DbGljayA9ICgpID0+IHtcbiAgICAgICAgdGhpcy50ZXh0U2VsZWN0aW9uRW5hYmxlZCA9ICF0aGlzLnRleHRTZWxlY3Rpb25FbmFibGVkO1xuICAgICAgICBpZiAodGhpcy50ZXh0TGF5ZXJEaXYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRTZWxlY3Rpb25FbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0TGF5ZXJEaXYuY2xhc3NMaXN0LmFkZChcImVuYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3ZXIudG9vbENvbnRyb2xsZXIuZW5hYmxlTW91c2VCdXR0b25zKGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0TGF5ZXJEaXYuY2xhc3NMaXN0LnJlbW92ZShcImVuYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3ZXIudG9vbENvbnRyb2xsZXIuZW5hYmxlTW91c2VCdXR0b25zKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudG9vbGJhckJ1dHRvbi5zZXRTdGF0ZSh0aGlzLnRleHRTZWxlY3Rpb25FbmFibGVkID8gYXZ1LkJ1dHRvbi5TdGF0ZS5BQ1RJVkUgOiBhdnUuQnV0dG9uLlN0YXRlLklOQUNUSVZFKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5QREZUZXh0TGF5ZXIucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IF9kb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoKTtcbiAgICBjb25zdCBfd2luZG93ID0gdGhpcy5nZXRXaW5kb3coKTtcbiAgICBpZiAoX3dpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKF93aW5kb3cuZ2V0U2VsZWN0aW9uKCkuZW1wdHkpIHsgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lXG4gICAgICAgICAgICBfd2luZG93LmdldFNlbGVjdGlvbigpLmVtcHR5KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX3dpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMpIHsgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgIF93aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9kb2N1bWVudC5zZWxlY3Rpb24pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU/XG4gICAgICAgIF9kb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgICB9XG59O1xuXG5QREZUZXh0TGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vbk1vZGVsVW5sb2FkKCk7XG5cbiAgICB0aGlzLnZpZXdlci5yZW1vdmVFdmVudExpc3RlbmVyKGF2LkdFT01FVFJZX0xPQURFRF9FVkVOVCwgdGhpcy5vbk1vZGVsTG9hZGVkKTtcbiAgICB0aGlzLnZpZXdlci5yZW1vdmVFdmVudExpc3RlbmVyKGF2LlBST0dSRVNTX1VQREFURV9FVkVOVCwgdGhpcy5vblJlbmRlckZpbmlzaGVkKTtcbiAgICB0aGlzLnZpZXdlci5yZW1vdmVFdmVudExpc3RlbmVyKGF2Lk1PREVMX1VOTE9BREVEX0VWRU5ULCB0aGlzLm9uTW9kZWxVbmxvYWQpO1xuXG4gICAgdGhpcy5yZW1vdmVUb29sYmFyQnV0dG9uKCk7XG59O1xuXG5QREZUZXh0TGF5ZXIucHJvdG90eXBlLnJlbW92ZVRvb2xiYXJCdXR0b24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy50b29sYmFyQnV0dG9uKSB7XG4gICAgICAgIHRoaXMudG9vbGJhckJ1dHRvbi5yZW1vdmVGcm9tUGFyZW50KCk7XG4gICAgICAgIHRoaXMudG9vbGJhckJ1dHRvbiA9IG51bGw7XG4gICAgfVxufTtcblxuUERGVGV4dExheWVyLnByb3RvdHlwZS5vblJlbmRlckZpbmlzaGVkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnBlcmNlbnQgPT0gMTAwICYmIGV2ZW50LnN0YXRlID09PSBhdi5Qcm9ncmVzc1N0YXRlLlJFTkRFUklORyAmJiB0aGlzLmNlbnRlclRleHRsYXllcikge1xuICAgICAgICB0aGlzLmNlbnRlclRleHRsYXllcigpO1xuICAgIH1cbn07XG5cblBERlRleHRMYXllci5wcm90b3R5cGUub25Nb2RlbFVubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNlbnRlclRleHRsYXllciA9IG51bGw7XG4gICAgaWYgKHRoaXMudGV4dExheWVyRGl2KSB7XG4gICAgICAgIHRoaXMudGV4dExheWVyRGl2LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnRleHRMYXllckRpdiA9IG51bGw7XG4gICAgfVxufTtcblxuUERGVGV4dExheWVyLnByb3RvdHlwZS5vbk1vZGVsTG9hZGVkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMudmlld2VyLm1vZGVsICYmIHRoaXMudmlld2VyLm1vZGVsLmlzUGRmKCkgJiYgdHlwZW9mKHRoaXMudmlld2VyLm1vZGVsLmdldERhdGEoKS5nZXRQREYpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgcGFnZU51bWJlciA9IHRoaXMudmlld2VyLm1vZGVsLmdldERhdGEoKS5tZXRhZGF0YS5jdXJyZW50UGFnZTtcbiAgICAgICAgY29uc3QgcGRmID0gdGhpcy52aWV3ZXIubW9kZWwuZ2V0RGF0YSgpLmdldFBERigpO1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMudmlld2VyLm1vZGVsO1xuICAgICAgICBwZGYuZ2V0UGFnZShwYWdlTnVtYmVyKS50aGVuKChwYWdlKSA9PiB7XG5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgbW9kZWwgbWlnaHQgYmUgdW5sb2FkZWQgb3IgcmVwbGFjZWQgYnkgYSAobWF5YmUgbm9uLXBkZikgb25lIG1lYW53aGlsZS5cbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXdlci5tb2RlbCAhPT0gbW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGV4dExheWVyKHBhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5QREZUZXh0TGF5ZXIucHJvdG90eXBlLnJlbmRlclRleHRMYXllciA9IGZ1bmN0aW9uIHJlbmRlclRleHRsYXllcihwYWdlKSB7XG4gICAgY29uc3QgX2RvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudCgpO1xuICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gcGFnZS5zdHJlYW1UZXh0Q29udGVudCh7IG5vcm1hbGl6ZVdoaXRlc3BhY2U6IHRydWUsIGNvbWJpbmVUZXh0SXRlbXM6IHRydWUgfSk7XG4gICAgY29uc3QgdGV4dExheWVyRGl2ID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgcm90YXRpb246IHBhZ2Uucm90YXRlLFxuICAgICAgICBkb250RmxpcDogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gcGFnZS5nZXRWaWV3cG9ydChvcHRpb25zKTtcbiAgICB0ZXh0TGF5ZXJEaXYuc3R5bGUuaGVpZ2h0ID0gYCR7dmlld3BvcnQuaGVpZ2h0fXB4YDtcbiAgICB0ZXh0TGF5ZXJEaXYuc3R5bGUud2lkdGggPSBgJHt2aWV3cG9ydC53aWR0aH1weGA7XG4gICAgdGV4dExheWVyRGl2LmNsYXNzTGlzdC5hZGQoXCJwZGYtdGV4dGxheWVyXCIpO1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHRoaXMudmlld2VyLmNhbnZhc1dyYXAuYXBwZW5kKHRleHRMYXllckRpdik7XG4gICAgdGhpcy50ZXh0TGF5ZXJEaXYgPSB0ZXh0TGF5ZXJEaXY7XG5cbiAgICAvLyBsb29wIHRoZSBzdHlsZSB0byBjaGVjayB3aGV0aGVyIHRoaXMgdGV4dCB3YXMgbG9hZGVkXG4gICAgZnVuY3Rpb24gZ2V0TG9hZGVkRm9udHMoKSB7XG4gICAgICAgIGNvbnN0IF9kb2N1bWVudCA9IHNjb3BlLmdldERvY3VtZW50KCk7XG4gICAgICAgIGxldCBub2RlcyA9IF9kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN0eWxlXCIpO1xuICAgICAgICBsZXQgbmFtZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5vZGVzW2ldLmdldEF0dHJpYnV0ZShcImRhdGF0eXBlXCIpID09PSBcImZvbnRzXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lc1tub2Rlc1tpXS5nZXRBdHRyaWJ1dGUoXCJpZFwiKV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG5cbiAgICAvLyBuZWVkIHRvIG1ha2UgdGhlIGh0bWwgb3ZlcmxheSB0aGUgc2FtZSBwb3NpdGlvbiBhcyBjYW52YXNcbiAgICBmdW5jdGlvbiBtYXBNb2RlbEJvdW5kc1RvU2NyZWVuKCkge1xuICAgICAgICBsZXQgYm91bmRzID0gc2NvcGUudmlld2VyLm1vZGVsLmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgIGxldCBtaW4gPSBzY29wZS52aWV3ZXIud29ybGRUb0NsaWVudChib3VuZHMubWluKTtcbiAgICAgICAgbGV0IG1heCA9IHNjb3BlLnZpZXdlci53b3JsZFRvQ2xpZW50KGJvdW5kcy5tYXgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IHtcbiAgICAgICAgICAgICAgICB4OiBNYXRoLm1pbihtaW4ueCwgbWF4LngpLFxuICAgICAgICAgICAgICAgIHk6IE1hdGgubWluKG1pbi55LCBtYXgueSksXG4gICAgICAgICAgICAgICAgejogTWF0aC5taW4obWluLnosIG1heC56KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heDoge1xuICAgICAgICAgICAgICAgIHg6IE1hdGgubWF4KG1pbi54LCBtYXgueCksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5tYXgobWluLnksIG1heC55KSxcbiAgICAgICAgICAgICAgICB6OiBNYXRoLm1heChtaW4ueiwgbWF4LnopXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNlbnRlclRleHRsYXllcigpIHtcblxuICAgICAgICAvLyBQREYgbW9kZWwgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWQgbWVhbndoaWxlXG4gICAgICAgIGlmICghc2NvcGUudmlld2VyLm1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdHJhbnNmb3JtIG1hdHJpeCBmb3IgdGhlIHRleHRMYXllclxuICAgICAgICAvLyBzY2FsZVxuICAgICAgICBsZXQgc2NyZWVuQm91bmRzID0gbWFwTW9kZWxCb3VuZHNUb1NjcmVlbigpO1xuICAgICAgICBsZXQgd2lkdGggPSBzY3JlZW5Cb3VuZHMubWF4LnggLSBzY3JlZW5Cb3VuZHMubWluLng7XG4gICAgICAgIGxldCBoZWlnaHQgPSBzY3JlZW5Cb3VuZHMubWF4LnkgLSBzY3JlZW5Cb3VuZHMubWluLnk7XG4gICAgICAgIGxldCBzY2FsZTEgPSBNYXRoLm1pbih3aWR0aCAvIHZpZXdwb3J0LndpZHRoLCBoZWlnaHQgLyB2aWV3cG9ydC5oZWlnaHQpO1xuXG4gICAgICAgIGxldCBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbih2aWV3cG9ydC53aWR0aCAvIDIsIHZpZXdwb3J0LmhlaWdodCAvIDIsIDApO1xuICAgICAgICBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VTY2FsZShzY2FsZTEsIHNjYWxlMSwgMSkubXVsdGlwbHkobWF0cml4KTtcbiAgICAgICAgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oLXZpZXdwb3J0LndpZHRoIC8gMiwgLXZpZXdwb3J0LmhlaWdodCAvIDIsIDApLm11bHRpcGx5KG1hdHJpeCk7XG4gICAgICAgIGxldCBsZWZ0ID0gc2NyZWVuQm91bmRzLm1pbi54O1xuICAgICAgICBsZXQgdG9wID0gc2NyZWVuQm91bmRzLm1pbi55O1xuXG4gICAgICAgIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKGxlZnQsIHRvcCwgMCkubXVsdGlwbHkobWF0cml4KTtcbiAgICAgICAgbGV0IGVsID0gbWF0cml4LmVsZW1lbnRzO1xuICAgICAgICBsZXQgdHJhbnNmb3JtMSA9IGBtYXRyaXgoJHtbZWxbMF0sIGVsWzFdLCBlbFs0XSwgZWxbNV0sIGVsWzEyXSwgZWxbMTNdXS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgdGV4dExheWVyRGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICBsZXQgdGV4dERpdnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFBERkpTLnJlbmRlclRleHRMYXllcih7XG4gICAgICAgICAgICBwYWdlSW5kZXg6IHBhZ2UucGFnZU51bWJlcixcbiAgICAgICAgICAgIHRleHREaXZzOiB0ZXh0RGl2cyxcbiAgICAgICAgICAgIHZpZXdwb3J0LFxuICAgICAgICAgICAgZW5oYW5jZVRleHRTZWxlY3Rpb246IHRydWUsXG4gICAgICAgICAgICB0ZXh0Q29udGVudFN0cmVhbTogcmVhZGFibGVTdHJlYW0sXG4gICAgICAgICAgICBjb250YWluZXI6IHRleHRMYXllckRpdlxuICAgICAgICB9KS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjb3BlLnVzaW5nVGV4dExheWVyKSB7XG4gICAgICAgICAgICAgICAgdGV4dExheWVyRGl2LmNsYXNzTGlzdC5hZGQoXCJ2aXNpYmxlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGV4dERpdnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNjb3BlLmFkZFRvb2xiYXJCdXR0b24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbnRlclRleHRsYXllcigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGlmICh0aGlzLnVzaW5nVGV4dExheWVyKSB7XG4gICAgICAgIC8vIGZvciBub3cgb25seSBleHRyYWN0IHRoZSBmb250IGxpYnJhcnkgd2hlbiB3ZSBzaG93IHRoZSB0ZXh0IGxheWVyXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgd2lsbCBpbmNyZWFzZSB0aGUgbG9hZGluZyB0aW1lLCB3aWxsIG5vdCB1c2UgaXQgZm9yIHNlbGVjdGlvblxuICAgICAgICAvLyBCdXQsIGlmIHdlIGRlY2lkZSB0byB1c2UgaXQgZm9yIHNlbGVjdGlvbiwgdGhlIHNlbGVjdGlvbi9oaWdobGlnaHQgd2lsbCBiZSBtb3JlIGFjY3VyYXRlXG4gICAgICAgIHByb21pc2UgPSBjc3NGb250RXh0cmFjdG9yKHBhZ2UsIGdldExvYWRlZEZvbnRzKCkpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHZhciBmb250cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgX2RvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvbnRTdHlsZSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgICAgICAgICAgX2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmQoZm9udFN0eWxlKTtcbiAgICAgICAgICAgICAgICBmb250U3R5bGUuaW5uZXJIVE1MID0gZGF0YVtpXS5jc3M7XG4gICAgICAgICAgICAgICAgZm9udFN0eWxlLnNldEF0dHJpYnV0ZShcImlkXCIsIGRhdGFbaV0ubmFtZSk7XG4gICAgICAgICAgICAgICAgZm9udFN0eWxlLnNldEF0dHJpYnV0ZShcImRhdGF0eXBlXCIsIFwiZm9udHNcIik7XG4gICAgICAgICAgICAgICAgZm9udHMucHVzaChkYXRhW2ldLm5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm9udHM7XG4gICAgICAgIH0pLnRoZW4oKG5hbWVzKSA9PiB7XG4gICAgICAgICAgICAvLyBwcmVsb2FkIHRoZSBmb250c1xuICAgICAgICAgICAgY29uc3QgX2RvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudCgpO1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gbmFtZXMubWFwKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9kb2N1bWVudC5mb250cy5sb2FkKGAxMHB0ICR7bmFtZX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfSkuY2F0Y2goKTtcbiAgICB9XG5cbiAgICBwcm9taXNlLnRoZW4ocmVuZGVyKTtcblxuICAgIHRoaXMuY2VudGVyVGV4dGxheWVyID0gY2VudGVyVGV4dGxheWVyO1xufTtcbiJdLCJuYW1lcyI6WyJQREZKUyIsImNzc0ZvbnRFeHRyYWN0b3IiLCJhdiIsIkF1dG9kZXNrIiwiVmlld2luZyIsImF2dSIsIlVJIiwiUERGVGV4dExheWVyIiwidmlld2VyIiwidXNpbmdUZXh0TGF5ZXIiLCJzZXRHbG9iYWxNYW5hZ2VyIiwiZ2xvYmFsTWFuYWdlciIsIm9uTW9kZWxMb2FkZWQiLCJiaW5kIiwib25SZW5kZXJGaW5pc2hlZCIsIm9uTW9kZWxVbmxvYWQiLCJhZGRFdmVudExpc3RlbmVyIiwiR0VPTUVUUllfTE9BREVEX0VWRU5UIiwiUFJPR1JFU1NfVVBEQVRFX0VWRU5UIiwiTU9ERUxfVU5MT0FERURfRVZFTlQiLCJ0ZXh0U2VsZWN0aW9uRW5hYmxlZCIsIkdsb2JhbE1hbmFnZXJNaXhpbiIsImNhbGwiLCJwcm90b3R5cGUiLCJhZGRUb29sYmFyQnV0dG9uIiwidG9vbEJ1dHRvbkFkZGVkIiwiZ2V0VG9vbGJhciIsInRvb2xiYXIiLCJtb2RlbFRvb2xzIiwiZ2V0Q29udHJvbCIsIlRPT0xCQVIiLCJNT0RFTFRPT0xTSUQiLCJidXR0b24iLCJCdXR0b24iLCJzZXRJY29uIiwic2V0VG9vbFRpcCIsImFkZENvbnRyb2wiLCJ0b29sYmFyQnV0dG9uIiwib25DbGljayIsInRleHRMYXllckRpdiIsImNsYXNzTGlzdCIsImFkZCIsInRvb2xDb250cm9sbGVyIiwiZW5hYmxlTW91c2VCdXR0b25zIiwicmVtb3ZlIiwiY2xlYXJTZWxlY3Rpb24iLCJzZXRTdGF0ZSIsIlN0YXRlIiwiQUNUSVZFIiwiSU5BQ1RJVkUiLCJfZG9jdW1lbnQiLCJnZXREb2N1bWVudCIsIl93aW5kb3ciLCJnZXRXaW5kb3ciLCJnZXRTZWxlY3Rpb24iLCJlbXB0eSIsInJlbW92ZUFsbFJhbmdlcyIsInNlbGVjdGlvbiIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlVG9vbGJhckJ1dHRvbiIsInJlbW92ZUZyb21QYXJlbnQiLCJldmVudCIsInBlcmNlbnQiLCJzdGF0ZSIsIlByb2dyZXNzU3RhdGUiLCJSRU5ERVJJTkciLCJjZW50ZXJUZXh0bGF5ZXIiLCJtb2RlbCIsImlzUGRmIiwiZ2V0RGF0YSIsImdldFBERiIsInBhZ2VOdW1iZXIiLCJtZXRhZGF0YSIsImN1cnJlbnRQYWdlIiwicGRmIiwiZ2V0UGFnZSIsInRoZW4iLCJwYWdlIiwicmVuZGVyVGV4dExheWVyIiwicmVuZGVyVGV4dGxheWVyIiwicmVhZGFibGVTdHJlYW0iLCJzdHJlYW1UZXh0Q29udGVudCIsIm5vcm1hbGl6ZVdoaXRlc3BhY2UiLCJjb21iaW5lVGV4dEl0ZW1zIiwiY3JlYXRlRWxlbWVudCIsIm9wdGlvbnMiLCJzY2FsZSIsInJvdGF0aW9uIiwicm90YXRlIiwiZG9udEZsaXAiLCJ2aWV3cG9ydCIsImdldFZpZXdwb3J0Iiwic3R5bGUiLCJoZWlnaHQiLCJ3aWR0aCIsInNjb3BlIiwiY2FudmFzV3JhcCIsImFwcGVuZCIsImdldExvYWRlZEZvbnRzIiwibm9kZXMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIm5hbWVzIiwiaSIsImxlbmd0aCIsImdldEF0dHJpYnV0ZSIsIm1hcE1vZGVsQm91bmRzVG9TY3JlZW4iLCJib3VuZHMiLCJnZXRCb3VuZGluZ0JveCIsIm1pbiIsIndvcmxkVG9DbGllbnQiLCJtYXgiLCJ4IiwiTWF0aCIsInkiLCJ6Iiwic2NyZWVuQm91bmRzIiwic2NhbGUxIiwibWF0cml4IiwiVEhSRUUiLCJNYXRyaXg0IiwibWFrZVRyYW5zbGF0aW9uIiwibWFrZVNjYWxlIiwibXVsdGlwbHkiLCJsZWZ0IiwidG9wIiwiZWwiLCJlbGVtZW50cyIsInRyYW5zZm9ybTEiLCJqb2luIiwidHJhbnNmb3JtIiwicmVuZGVyIiwidGV4dERpdnMiLCJwYWdlSW5kZXgiLCJlbmhhbmNlVGV4dFNlbGVjdGlvbiIsInRleHRDb250ZW50U3RyZWFtIiwiY29udGFpbmVyIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiZGF0YSIsImZvbnRzIiwiZm9udFN0eWxlIiwiaW5uZXJIVE1MIiwiY3NzIiwic2V0QXR0cmlidXRlIiwibmFtZSIsInB1c2giLCJwcm9taXNlcyIsIm1hcCIsImxvYWQiLCJhbGwiLCJjYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./extensions/PDF/PDFTextLayer.js\n");

/***/ }),

/***/ "./extensions/PDF/font-engine.js":
/*!***************************************!*\
  !*** ./extensions/PDF/font-engine.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   theFontEngine: () => (/* binding */ theFontEngine)\n/* harmony export */ });\n/* harmony import */ var opentype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! opentype.js */ \"./node_modules/opentype.js/dist/opentype.js\");\n/* harmony import */ var opentype_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(opentype_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _res_fonts_font_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../res/fonts/font-list */ \"./res/fonts/font-list.js\");\n\n\n\n\nconst getResourceUrl = Autodesk.Viewing.Private.getResourceUrl;\n\n\n\nlet FONTS_LOADER;\nconst avp = Autodesk.Viewing.Private;\n\nclass FontEngine {\n\n  constructor() {\n    this.fontCache = {};\n  }\n\n  loadFont(f) {\n    return new Promise((resolve) => {\n      opentype_js__WEBPACK_IMPORTED_MODULE_0__.load(getResourceUrl(f.url), (err, font) => {\n        if (!font) {\n          const warning = `Failed to load font ${f.name}`;\n          avp.logger.warn(warning);\n\n          // As we output a warning and not throw an error, we still want to resolve.\n          resolve(warning);\n          return;\n        }\n\n        font.pathCache = {};\n\n        this.fontCache[f.name] = font;\n\n        f.subs.forEach((s) => {\n          this.fontCache[s] = font;\n        });\n\n        resolve();\n      });\n    });\n  }\n\n  loadFonts() {\n\n    if (FONTS_LOADER)\n    return FONTS_LOADER;\n\n    let loaders = _res_fonts_font_list__WEBPACK_IMPORTED_MODULE_1__.FONT_LIST.map((f) => {\n      if (f.url) {\n        return this.loadFont(f);\n      }\n    });\n\n    FONTS_LOADER = Promise.all(loaders);\n    return FONTS_LOADER;\n  }\n\n  mapFont(font) {\n    let cachedFont = this.fontCache[font.name.toLowerCase()];\n    if (!cachedFont)\n    cachedFont = this.fontCache[font.loadedName.toLowerCase()];\n    if (!cachedFont)\n    cachedFont = this.fontCache[font.fallbackName.toLowerCase()];\n\n    if (!cachedFont) {\n      avp.logger.warn(\"Failed to map font\", font.name);\n    }\n\n    return cachedFont;\n  }\n\n  drawText(ctx, text, x, y, font, fontSize) {\n\n    let cachedFont = this.mapFont(font);\n\n    if (!cachedFont)\n    return;\n\n    if (text.length === 1) {\n\n      let perSizeCache = cachedFont.pathCache[fontSize];\n\n      let path = perSizeCache && perSizeCache[text];\n\n      if (!path) {\n        path = cachedFont.getPath(text, 0, 0, fontSize);\n        path.fill = null;\n        path.stroke = null;\n\n        if (!perSizeCache) {\n          perSizeCache = cachedFont.pathCache[fontSize] = {};\n        }\n        perSizeCache[text] = path;\n      }\n\n      ctx.beginPath(text, x, y, font, fontSize);\n      for (let i = 0; i < path.commands.length; i += 1) {\n        const cmd = path.commands[i];\n        if (cmd.type === 'M') {\n          ctx.moveTo(cmd.x + x, cmd.y + y);\n        } else if (cmd.type === 'L') {\n          ctx.lineTo(cmd.x + x, cmd.y + y);\n        } else if (cmd.type === 'C') {\n          ctx.bezierCurveTo(cmd.x1 + x, cmd.y1 + y, cmd.x2 + x, cmd.y2 + y, cmd.x + x, cmd.y + y);\n        } else if (cmd.type === 'Q') {\n          ctx.quadraticCurveTo(cmd.x1 + x, cmd.y1 + y, cmd.x + x, cmd.y + y);\n        } else if (cmd.type === 'Z') {\n          ctx.closePath();\n        }\n      }\n\n    } else {\n      //TODO: No caching is attempted here. This code path should not be\n      //called during normal PDF loading. If it every is, it needs to be optimized as above.\n      avp.logger.warn(\"Multi-character text rendering not fully implemented\");\n      cachedFont.draw(ctx, text, x, y, fontSize);\n    }\n\n\n\n  }\n\n  getOnDemandFont(name) {\n    for (let i = 0; i < _res_fonts_font_list__WEBPACK_IMPORTED_MODULE_1__.ONDEMAND_FONT_LIST.length; i++) {\n      const entry = _res_fonts_font_list__WEBPACK_IMPORTED_MODULE_1__.ONDEMAND_FONT_LIST[i];\n      if (entry.name === name || entry.subs.includes(name.toLowerCase())) {\n        return entry;\n      }\n    }\n  }\n}\n\n\nconst theFontEngine = new FontEngine();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUlKOztFQUVBc0IsZUFBZUEsQ0FBQzNDLElBQUksRUFBRTtJQUNsQixLQUFLLElBQUk2QixDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUc1QyxvRUFBa0IsQ0FBQ3FDLE1BQU0sRUFBRU8sQ0FBQyxFQUFFLEVBQUU7TUFDaEQsTUFBTWUsS0FBSyxHQUFHM0Qsb0VBQWtCLENBQUM0QyxDQUFDLENBQUM7TUFDbkMsSUFBSWUsS0FBSyxDQUFDNUMsSUFBSSxLQUFLQSxJQUFJLElBQUk0QyxLQUFLLENBQUN4QyxJQUFJLENBQUN5QyxRQUFRLENBQUM3QyxJQUFJLENBQUNhLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUNoRSxPQUFPK0IsS0FBSztNQUNoQjtJQUNKO0VBQ0o7QUFDSjs7O0FBR08sTUFBTUUsYUFBYSxHQUFHLElBQUkxRCxVQUFVLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0F1dG9kZXNrLkV4dGVuc2lvbnMvLi9leHRlbnNpb25zL1BERi9mb250LWVuZ2luZS5qcz8wODkxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuXG5pbXBvcnQgKiBhcyBvcGVudHlwZSBmcm9tIFwib3BlbnR5cGUuanNcIjtcblxuY29uc3QgZ2V0UmVzb3VyY2VVcmwgPSBBdXRvZGVzay5WaWV3aW5nLlByaXZhdGUuZ2V0UmVzb3VyY2VVcmw7XG5cbmltcG9ydCB7IEZPTlRfTElTVCwgT05ERU1BTkRfRk9OVF9MSVNUIH0gZnJvbSBcIi4uLy4uL3Jlcy9mb250cy9mb250LWxpc3RcIjtcblxubGV0IEZPTlRTX0xPQURFUjtcbmNvbnN0IGF2cCA9IEF1dG9kZXNrLlZpZXdpbmcuUHJpdmF0ZTtcblxuY2xhc3MgRm9udEVuZ2luZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mb250Q2FjaGUgPSB7fTtcbiAgICB9XG5cbiAgICBsb2FkRm9udChmKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgb3BlbnR5cGUubG9hZChnZXRSZXNvdXJjZVVybChmLnVybCksIChlcnIsIGZvbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FybmluZyA9IGBGYWlsZWQgdG8gbG9hZCBmb250ICR7Zi5uYW1lfWA7XG4gICAgICAgICAgICAgICAgICAgIGF2cC5sb2dnZXIud2Fybih3YXJuaW5nKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBcyB3ZSBvdXRwdXQgYSB3YXJuaW5nIGFuZCBub3QgdGhyb3cgYW4gZXJyb3IsIHdlIHN0aWxsIHdhbnQgdG8gcmVzb2x2ZS5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh3YXJuaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvbnQucGF0aENhY2hlID0ge307XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZvbnRDYWNoZVtmLm5hbWVdID0gZm9udDtcblxuICAgICAgICAgICAgICAgIGYuc3Vicy5mb3JFYWNoKHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbnRDYWNoZVtzXSA9IGZvbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbG9hZEZvbnRzKCkge1xuXG4gICAgICAgIGlmIChGT05UU19MT0FERVIpXG4gICAgICAgICAgICByZXR1cm4gRk9OVFNfTE9BREVSO1xuXG4gICAgICAgIGxldCBsb2FkZXJzID0gRk9OVF9MSVNULm1hcChmID0+IHtcbiAgICAgICAgICAgIGlmIChmLnVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRGb250KGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBGT05UU19MT0FERVIgPSBQcm9taXNlLmFsbChsb2FkZXJzKTtcbiAgICAgICAgcmV0dXJuIEZPTlRTX0xPQURFUjtcbiAgICB9XG5cbiAgICBtYXBGb250KGZvbnQpIHtcbiAgICAgICAgbGV0IGNhY2hlZEZvbnQgPSB0aGlzLmZvbnRDYWNoZVtmb250Lm5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmICghY2FjaGVkRm9udClcbiAgICAgICAgICAgIGNhY2hlZEZvbnQgPSB0aGlzLmZvbnRDYWNoZVtmb250LmxvYWRlZE5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmICghY2FjaGVkRm9udClcbiAgICAgICAgICAgIGNhY2hlZEZvbnQgPSB0aGlzLmZvbnRDYWNoZVtmb250LmZhbGxiYWNrTmFtZS50b0xvd2VyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoIWNhY2hlZEZvbnQpIHtcbiAgICAgICAgICAgIGF2cC5sb2dnZXIud2FybihcIkZhaWxlZCB0byBtYXAgZm9udFwiLCBmb250Lm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlZEZvbnQ7XG4gICAgfVxuXG4gICAgZHJhd1RleHQoY3R4LCB0ZXh0LCB4LCB5LCBmb250LCBmb250U2l6ZSkge1xuXG4gICAgICAgIGxldCBjYWNoZWRGb250ID0gdGhpcy5tYXBGb250KGZvbnQpO1xuXG4gICAgICAgIGlmICghY2FjaGVkRm9udClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT09IDEpIHtcblxuICAgICAgICAgICAgbGV0IHBlclNpemVDYWNoZSA9IGNhY2hlZEZvbnQucGF0aENhY2hlW2ZvbnRTaXplXTtcblxuICAgICAgICAgICAgbGV0IHBhdGggPSBwZXJTaXplQ2FjaGUgJiYgcGVyU2l6ZUNhY2hlW3RleHRdO1xuXG4gICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gY2FjaGVkRm9udC5nZXRQYXRoKHRleHQsIDAsIDAsIGZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICBwYXRoLmZpbGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBhdGguc3Ryb2tlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmICghcGVyU2l6ZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlclNpemVDYWNoZSA9IGNhY2hlZEZvbnQucGF0aENhY2hlW2ZvbnRTaXplXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwZXJTaXplQ2FjaGVbdGV4dF0gPSBwYXRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKHRleHQsIHgsIHksIGZvbnQsIGZvbnRTaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNtZCA9IHBhdGguY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhjbWQueCArIHgsIGNtZC55ICsgeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oY21kLnggKyB4LCBjbWQueSArIHkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjbWQueDEgKyB4LCBjbWQueTEgKyB5LCBjbWQueDIgKyB4LCBjbWQueTIgKyB5LCBjbWQueCArIHgsIGNtZC55ICsgeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNtZC54MSArIHgsIGNtZC55MSArIHksIGNtZC54ICsgeCwgY21kLnkgKyB5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9UT0RPOiBObyBjYWNoaW5nIGlzIGF0dGVtcHRlZCBoZXJlLiBUaGlzIGNvZGUgcGF0aCBzaG91bGQgbm90IGJlXG4gICAgICAgICAgICAvL2NhbGxlZCBkdXJpbmcgbm9ybWFsIFBERiBsb2FkaW5nLiBJZiBpdCBldmVyeSBpcywgaXQgbmVlZHMgdG8gYmUgb3B0aW1pemVkIGFzIGFib3ZlLlxuICAgICAgICAgICAgYXZwLmxvZ2dlci53YXJuKFwiTXVsdGktY2hhcmFjdGVyIHRleHQgcmVuZGVyaW5nIG5vdCBmdWxseSBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgIGNhY2hlZEZvbnQuZHJhdyhjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplKTtcbiAgICAgICAgfVxuXG5cblxuICAgIH1cblxuICAgIGdldE9uRGVtYW5kRm9udChuYW1lKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgT05ERU1BTkRfRk9OVF9MSVNULmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IE9OREVNQU5EX0ZPTlRfTElTVFtpXTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5uYW1lID09PSBuYW1lIHx8IGVudHJ5LnN1YnMuaW5jbHVkZXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgY29uc3QgdGhlRm9udEVuZ2luZSA9IG5ldyBGb250RW5naW5lKCk7XG5cbiJdLCJuYW1lcyI6WyJvcGVudHlwZSIsImdldFJlc291cmNlVXJsIiwiQXV0b2Rlc2siLCJWaWV3aW5nIiwiUHJpdmF0ZSIsIkZPTlRfTElTVCIsIk9OREVNQU5EX0ZPTlRfTElTVCIsIkZPTlRTX0xPQURFUiIsImF2cCIsIkZvbnRFbmdpbmUiLCJjb25zdHJ1Y3RvciIsImZvbnRDYWNoZSIsImxvYWRGb250IiwiZiIsIlByb21pc2UiLCJyZXNvbHZlIiwibG9hZCIsInVybCIsImVyciIsImZvbnQiLCJ3YXJuaW5nIiwibmFtZSIsImxvZ2dlciIsIndhcm4iLCJwYXRoQ2FjaGUiLCJzdWJzIiwiZm9yRWFjaCIsInMiLCJsb2FkRm9udHMiLCJsb2FkZXJzIiwibWFwIiwiYWxsIiwibWFwRm9udCIsImNhY2hlZEZvbnQiLCJ0b0xvd2VyQ2FzZSIsImxvYWRlZE5hbWUiLCJmYWxsYmFja05hbWUiLCJkcmF3VGV4dCIsImN0eCIsInRleHQiLCJ4IiwieSIsImZvbnRTaXplIiwibGVuZ3RoIiwicGVyU2l6ZUNhY2hlIiwicGF0aCIsImdldFBhdGgiLCJmaWxsIiwic3Ryb2tlIiwiYmVnaW5QYXRoIiwiaSIsImNvbW1hbmRzIiwiY21kIiwidHlwZSIsIm1vdmVUbyIsImxpbmVUbyIsImJlemllckN1cnZlVG8iLCJ4MSIsInkxIiwieDIiLCJ5MiIsInF1YWRyYXRpY0N1cnZlVG8iLCJjbG9zZVBhdGgiLCJkcmF3IiwiZ2V0T25EZW1hbmRGb250IiwiZW50cnkiLCJpbmNsdWRlcyIsInRoZUZvbnRFbmdpbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./extensions/PDF/font-engine.js\n");

/***/ }),

/***/ "./extensions/PDF/index.js":
/*!*********************************!*\
  !*** ./extensions/PDF/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PDFExtension: () => (/* binding */ PDFExtension),\n/* harmony export */   PDFLoader: () => (/* reexport safe */ _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader)\n/* harmony export */ });\n/* harmony import */ var _PDFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PDFLoader */ \"./extensions/PDF/PDFLoader.js\");\n/* harmony import */ var _PDFTextLayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PDFTextLayer */ \"./extensions/PDF/PDFTextLayer.js\");\n\n\n\n\n\nvar av = Autodesk.Viewing;\nvar aveh = AutodeskNamespace('Autodesk.Viewing.Extensions.PDF');\n\n\n/**\n * Registers a FileLoader to enhance `viewer.loadModel()` to allow loading of PDF files.\n * The viewer will render a single page at a time.\n *\n * The extension id is: `Autodesk.PDF`\n *\n * @example\n * // Create Viewer instance and load PDF file on page 1\n * Autodesk.Viewing.Initializer(options, function() {\n *     var viewer = new Autodesk.Viewing.Viewer3D(div,config3d);\n *     viewer.start();\n *     viewer.loadExtension('Autodesk.PDF').then(function() {\n *         // URL parameter `page` will override value passed to loadModel\n *         viewer.loadModel('path/to/file.pdf', { page: 1 });\n *     });\n * });\n *\n *\n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.PDFExtension\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @class\n */\nclass PDFExtension extends av.Extension {\n\n  constructor(viewer, options) {\n    super(viewer, options);\n    this.onModelLoaded = this.onModelLoaded.bind(this);\n    this.onPopState = this.onPopState.bind(this);\n    // each time pdf change a page, tear down will happen, we need to use PDFLoader.useTextLayer to save the options\n    this.showTextLayer = options ? options.useTextLayer : _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.useTextLayer;\n    _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.useTextLayer = this.showTextLayer || false;\n    _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableHyperlinks = options && options.enableHyperlinks != undefined ? options.enableHyperlinks : _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableHyperlinks != null ? _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableHyperlinks : true;\n    _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableTextSearch = options && options.enableTextSearch != undefined ? options.enableTextSearch : _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableTextSearch != null ? _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableTextSearch : true;\n\n    PDFExtension.enableBrowserNavigation = options && options.enableBrowserNavigation != undefined ? options.enableBrowserNavigation : PDFExtension.enableBrowserNavigation != null ? PDFExtension.enableBrowserNavigation : true;\n    this.enableTextSearch = _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableTextSearch;\n    _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableMSDFText = options && options.enableMSDFText != undefined ? options.enableMSDFText : _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableMSDFText != null ? _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableMSDFText : false;\n\n    // Turn on SSAA if it is not an weak device and using MSDFText\n    if (_PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader.enableMSDFText && !viewer.impl.renderer().isWeakDevice() && viewer.impl.glrenderer().getPixelRatio() <= 1) {\n      viewer.impl.renderer().settings.useSSAA = true;\n    }\n  }\n\n  async load() {\n\n    await this.viewer.loadExtension('Autodesk.CompGeom');\n\n    av.FileLoaderManager.registerFileLoader(\"pdf\", [\"pdf\"], _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader);\n    if (!av.isNodeJS()) {\n      if (PDFExtension.enableBrowserNavigation) {\n        this.viewer.addEventListener(av.GEOMETRY_LOADED_EVENT, this.onModelLoaded);\n        this.addWindowEventListener(\"popstate\", this.onPopState);\n      }\n\n      if (this.enableTextSearch) {\n        this.textLayer = new _PDFTextLayer__WEBPACK_IMPORTED_MODULE_1__.PDFTextLayer(this.viewer, this.showTextLayer);\n        this.textLayer.onModelLoaded();\n      }\n    }\n    return true;\n  }\n\n  unload() {\n    av.FileLoaderManager.unregisterFileLoader(\"pdf\");\n    if (!av.isNodeJS()) {\n      this.viewer.removeEventListener(av.GEOMETRY_LOADED_EVENT, this.onModelLoaded);\n      this.removeWindowEventListener(\"popstate\", this.onPopState);\n\n      if (this.textLayer) {\n        this.textLayer.destroy();\n        this.textLayer = null;\n      }\n    }\n    return true;\n  }\n\n  onModelLoaded(event) {\n    if (event && event.model && event.model.getDocumentNode() && event.model.isPdf(true)) {\n      var url = new URL(window.location.href);\n      var bubbleNode = event.model.getDocumentNode();\n      var pageIndex = bubbleNode.data.page;\n      if (url.searchParams.get(\"page\") != pageIndex) {\n        url.searchParams.set(\"page\", pageIndex);\n        const _window = this.getWindow();\n        _window.history.pushState(undefined, \"Page:\" + pageIndex, url.href);\n      }\n    }\n  }\n\n  onPopState(event) {\n    var model = this.viewer.model;\n    if (event && model && model.getDocumentNode() && model.isPdf(true)) {\n      const _window = this.getWindow();\n      var url = new URL(_window.location.href);\n      var pageIndex = parseInt(url.searchParams.get(\"page\")) || 1;\n      var rootNode = model.getDocumentNode().getRootNode();\n\n      var bubbleNode = rootNode.children[pageIndex - 1];\n      this.viewer.dispatchEvent({ type: av.HYPERLINK_EVENT, data: { bubbleNode: bubbleNode } });\n      this.viewer.loadDocumentNode(rootNode.getDocument(), bubbleNode);\n    }\n  }\n\n  activate() {return true;}\n  deactivate() {return false;}\n}\n\naveh.PDFExtension = PDFExtension;\naveh.PDFLoader = _PDFLoader__WEBPACK_IMPORTED_MODULE_0__.PDFLoader;\n\nav.theExtensionManager.registerExtension('Autodesk.PDF', PDFExtension);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSUMsR0FBRyxDQUFDVyxPQUFPLENBQUNULFFBQVEsQ0FBQ0MsSUFBSSxDQUFDO01BQ3hDLElBQUlFLFNBQVMsR0FBR1UsUUFBUSxDQUFDaEIsR0FBRyxDQUFDUyxZQUFZLENBQUNDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUM7TUFDM0QsSUFBSU8sUUFBUSxHQUFHcEIsS0FBSyxDQUFDQyxlQUFlLENBQUMsQ0FBQyxDQUFDb0IsV0FBVyxDQUFDLENBQUM7O01BRXBELElBQUliLFVBQVUsR0FBR1ksUUFBUSxDQUFDRSxRQUFRLENBQUNiLFNBQVMsR0FBRyxDQUFDLENBQUM7TUFDakQsSUFBSSxDQUFDM0MsTUFBTSxDQUFDeUQsYUFBYSxDQUFDLEVBQUVDLElBQUksRUFBRWxFLEVBQUUsQ0FBQ21FLGVBQWUsRUFBRWYsSUFBSSxFQUFFLEVBQUVGLFVBQVUsRUFBRUEsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7TUFDekYsSUFBSSxDQUFDMUMsTUFBTSxDQUFDNEQsZ0JBQWdCLENBQUNOLFFBQVEsQ0FBQ08sV0FBVyxDQUFDLENBQUMsRUFBRW5CLFVBQVUsQ0FBQztJQUNwRTtFQUNKOztFQUVBb0IsUUFBUUEsQ0FBQSxFQUFHLENBQUUsT0FBTyxJQUFJLENBQUU7RUFDMUJDLFVBQVVBLENBQUEsRUFBRyxDQUFFLE9BQU8sS0FBSyxDQUFFO0FBQ2pDOztBQUVBcEUsSUFBSSxDQUFDRSxZQUFZLEdBQUdBLFlBQVk7QUFDaENGLElBQUksQ0FBQ0wsU0FBUyxHQUFHQSxpREFBUzs7QUFFMUJFLEVBQUUsQ0FBQ3dFLG1CQUFtQixDQUFDQyxpQkFBaUIsQ0FBQyxjQUFjLEVBQUVwRSxZQUFZLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9QREYvaW5kZXguanM/ZDU4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcblxuaW1wb3J0IHsgUERGTG9hZGVyIH0gZnJvbSBcIi4vUERGTG9hZGVyXCI7XG5pbXBvcnQge1BERlRleHRMYXllcn0gZnJvbSBcIi4vUERGVGV4dExheWVyXCI7XG5cbnZhciBhdiA9IEF1dG9kZXNrLlZpZXdpbmc7XG52YXIgYXZlaCA9IEF1dG9kZXNrTmFtZXNwYWNlKCdBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuUERGJyk7XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBGaWxlTG9hZGVyIHRvIGVuaGFuY2UgYHZpZXdlci5sb2FkTW9kZWwoKWAgdG8gYWxsb3cgbG9hZGluZyBvZiBQREYgZmlsZXMuXG4gKiBUaGUgdmlld2VyIHdpbGwgcmVuZGVyIGEgc2luZ2xlIHBhZ2UgYXQgYSB0aW1lLlxuICpcbiAqIFRoZSBleHRlbnNpb24gaWQgaXM6IGBBdXRvZGVzay5QREZgXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENyZWF0ZSBWaWV3ZXIgaW5zdGFuY2UgYW5kIGxvYWQgUERGIGZpbGUgb24gcGFnZSAxXG4gKiBBdXRvZGVzay5WaWV3aW5nLkluaXRpYWxpemVyKG9wdGlvbnMsIGZ1bmN0aW9uKCkge1xuICogICAgIHZhciB2aWV3ZXIgPSBuZXcgQXV0b2Rlc2suVmlld2luZy5WaWV3ZXIzRChkaXYsY29uZmlnM2QpO1xuICogICAgIHZpZXdlci5zdGFydCgpO1xuICogICAgIHZpZXdlci5sb2FkRXh0ZW5zaW9uKCdBdXRvZGVzay5QREYnKS50aGVuKGZ1bmN0aW9uKCkge1xuICogICAgICAgICAvLyBVUkwgcGFyYW1ldGVyIGBwYWdlYCB3aWxsIG92ZXJyaWRlIHZhbHVlIHBhc3NlZCB0byBsb2FkTW9kZWxcbiAqICAgICAgICAgdmlld2VyLmxvYWRNb2RlbCgncGF0aC90by9maWxlLnBkZicsIHsgcGFnZTogMSB9KTtcbiAqICAgICB9KTtcbiAqIH0pO1xuICpcbiAqXG4gKiBAbWVtYmVyb2YgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zXG4gKiBAYWxpYXMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLlBERkV4dGVuc2lvblxuICogQHNlZSB7QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb259IGZvciBjb21tb24gaW5oZXJpdGVkIG1ldGhvZHMuXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgUERGRXh0ZW5zaW9uIGV4dGVuZHMgYXYuRXh0ZW5zaW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKHZpZXdlciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcih2aWV3ZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9uTW9kZWxMb2FkZWQgPSB0aGlzLm9uTW9kZWxMb2FkZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblBvcFN0YXRlID0gdGhpcy5vblBvcFN0YXRlLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIGVhY2ggdGltZSBwZGYgY2hhbmdlIGEgcGFnZSwgdGVhciBkb3duIHdpbGwgaGFwcGVuLCB3ZSBuZWVkIHRvIHVzZSBQREZMb2FkZXIudXNlVGV4dExheWVyIHRvIHNhdmUgdGhlIG9wdGlvbnNcbiAgICAgICAgdGhpcy5zaG93VGV4dExheWVyID0gb3B0aW9ucyA/IG9wdGlvbnMudXNlVGV4dExheWVyIDogUERGTG9hZGVyLnVzZVRleHRMYXllcjtcbiAgICAgICAgUERGTG9hZGVyLnVzZVRleHRMYXllciA9IHRoaXMuc2hvd1RleHRMYXllciB8fCBmYWxzZTtcbiAgICAgICAgUERGTG9hZGVyLmVuYWJsZUh5cGVybGlua3MgPSBvcHRpb25zICYmIG9wdGlvbnMuZW5hYmxlSHlwZXJsaW5rcyAhPSB1bmRlZmluZWQgPyBvcHRpb25zLmVuYWJsZUh5cGVybGlua3MgOiAoUERGTG9hZGVyLmVuYWJsZUh5cGVybGlua3MgIT0gbnVsbCA/IFBERkxvYWRlci5lbmFibGVIeXBlcmxpbmtzIDogdHJ1ZSk7XG4gICAgICAgIFBERkxvYWRlci5lbmFibGVUZXh0U2VhcmNoID0gb3B0aW9ucyAmJiBvcHRpb25zLmVuYWJsZVRleHRTZWFyY2ggIT0gdW5kZWZpbmVkID8gb3B0aW9ucy5lbmFibGVUZXh0U2VhcmNoIDogKFBERkxvYWRlci5lbmFibGVUZXh0U2VhcmNoICE9IG51bGwgPyBQREZMb2FkZXIuZW5hYmxlVGV4dFNlYXJjaCA6IHRydWUpO1xuXG4gICAgICAgIFBERkV4dGVuc2lvbi5lbmFibGVCcm93c2VyTmF2aWdhdGlvbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5lbmFibGVCcm93c2VyTmF2aWdhdGlvbiAhPSB1bmRlZmluZWQgPyBvcHRpb25zLmVuYWJsZUJyb3dzZXJOYXZpZ2F0aW9uIDogKFBERkV4dGVuc2lvbi5lbmFibGVCcm93c2VyTmF2aWdhdGlvbiAhPW51bGwgPyBQREZFeHRlbnNpb24uZW5hYmxlQnJvd3Nlck5hdmlnYXRpb246IHRydWUpO1xuICAgICAgICB0aGlzLmVuYWJsZVRleHRTZWFyY2ggPSBQREZMb2FkZXIuZW5hYmxlVGV4dFNlYXJjaDtcbiAgICAgICAgUERGTG9hZGVyLmVuYWJsZU1TREZUZXh0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmVuYWJsZU1TREZUZXh0ICE9IHVuZGVmaW5lZCA/IG9wdGlvbnMuZW5hYmxlTVNERlRleHQgOiAoUERGTG9hZGVyLmVuYWJsZU1TREZUZXh0ICE9IG51bGwgPyBQREZMb2FkZXIuZW5hYmxlTVNERlRleHQgOiBmYWxzZSk7XG5cbiAgICAgICAgLy8gVHVybiBvbiBTU0FBIGlmIGl0IGlzIG5vdCBhbiB3ZWFrIGRldmljZSBhbmQgdXNpbmcgTVNERlRleHRcbiAgICAgICAgaWYoUERGTG9hZGVyLmVuYWJsZU1TREZUZXh0ICYmICF2aWV3ZXIuaW1wbC5yZW5kZXJlcigpLmlzV2Vha0RldmljZSgpICYmIHZpZXdlci5pbXBsLmdscmVuZGVyZXIoKS5nZXRQaXhlbFJhdGlvKCkgPD0gMSkge1xuICAgICAgICAgICAgdmlld2VyLmltcGwucmVuZGVyZXIoKS5zZXR0aW5ncy51c2VTU0FBID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGxvYWQoKSB7XG5cbiAgICAgICAgYXdhaXQgdGhpcy52aWV3ZXIubG9hZEV4dGVuc2lvbignQXV0b2Rlc2suQ29tcEdlb20nKTtcblxuICAgICAgICBhdi5GaWxlTG9hZGVyTWFuYWdlci5yZWdpc3RlckZpbGVMb2FkZXIoXCJwZGZcIiwgW1wicGRmXCJdLCBQREZMb2FkZXIpO1xuICAgICAgICBpZighYXYuaXNOb2RlSlMoKSkge1xuICAgICAgICAgICAgaWYoUERGRXh0ZW5zaW9uLmVuYWJsZUJyb3dzZXJOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihhdi5HRU9NRVRSWV9MT0FERURfRVZFTlQsIHRoaXMub25Nb2RlbExvYWRlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRXaW5kb3dFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5vblBvcFN0YXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5lbmFibGVUZXh0U2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0TGF5ZXIgPSBuZXcgUERGVGV4dExheWVyKHRoaXMudmlld2VyLCB0aGlzLnNob3dUZXh0TGF5ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dExheWVyLm9uTW9kZWxMb2FkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB1bmxvYWQoKSB7XG4gICAgICAgIGF2LkZpbGVMb2FkZXJNYW5hZ2VyLnVucmVnaXN0ZXJGaWxlTG9hZGVyKFwicGRmXCIpO1xuICAgICAgICBpZighYXYuaXNOb2RlSlMoKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihhdi5HRU9NRVRSWV9MT0FERURfRVZFTlQsIHRoaXMub25Nb2RlbExvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVdpbmRvd0V2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLm9uUG9wU3RhdGUpO1xuXG4gICAgICAgICAgICBpZih0aGlzLnRleHRMYXllcikge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dExheWVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRMYXllciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb25Nb2RlbExvYWRlZChldmVudCkge1xuICAgICAgICBpZihldmVudCAmJiBldmVudC5tb2RlbCAmJiBldmVudC5tb2RlbC5nZXREb2N1bWVudE5vZGUoKSAmJiBldmVudC5tb2RlbC5pc1BkZih0cnVlKSkge1xuICAgICAgICAgICAgdmFyIHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgdmFyIGJ1YmJsZU5vZGUgPSBldmVudC5tb2RlbC5nZXREb2N1bWVudE5vZGUoKTtcbiAgICAgICAgICAgIHZhciBwYWdlSW5kZXggPSBidWJibGVOb2RlLmRhdGEucGFnZTtcbiAgICAgICAgICAgIGlmKHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwicGFnZVwiKSAhPSBwYWdlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInBhZ2VcIiwgcGFnZUluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBfd2luZG93ID0gdGhpcy5nZXRXaW5kb3coKTtcbiAgICAgICAgICAgICAgICBfd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHVuZGVmaW5lZCwgXCJQYWdlOlwiICsgcGFnZUluZGV4LCB1cmwuaHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblBvcFN0YXRlKGV2ZW50KSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMudmlld2VyLm1vZGVsO1xuICAgICAgICBpZihldmVudCAmJiBtb2RlbCAmJiBtb2RlbC5nZXREb2N1bWVudE5vZGUoKSAmJiBtb2RlbC5pc1BkZih0cnVlKSkge1xuICAgICAgICAgICAgY29uc3QgX3dpbmRvdyA9IHRoaXMuZ2V0V2luZG93KCk7XG4gICAgICAgICAgICB2YXIgdXJsID0gbmV3IFVSTChfd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgdmFyIHBhZ2VJbmRleCA9IHBhcnNlSW50KHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwicGFnZVwiKSkgfHwgMTtcbiAgICAgICAgICAgIHZhciByb290Tm9kZSA9IG1vZGVsLmdldERvY3VtZW50Tm9kZSgpLmdldFJvb3ROb2RlKCk7XG5cbiAgICAgICAgICAgIHZhciBidWJibGVOb2RlID0gcm9vdE5vZGUuY2hpbGRyZW5bcGFnZUluZGV4IC0gMV07XG4gICAgICAgICAgICB0aGlzLnZpZXdlci5kaXNwYXRjaEV2ZW50KHsgdHlwZTogYXYuSFlQRVJMSU5LX0VWRU5ULCBkYXRhOiB7IGJ1YmJsZU5vZGU6IGJ1YmJsZU5vZGUgfSB9KTtcbiAgICAgICAgICAgIHRoaXMudmlld2VyLmxvYWREb2N1bWVudE5vZGUocm9vdE5vZGUuZ2V0RG9jdW1lbnQoKSwgYnViYmxlTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBkZWFjdGl2YXRlKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuYXZlaC5QREZFeHRlbnNpb24gPSBQREZFeHRlbnNpb247XG5hdmVoLlBERkxvYWRlciA9IFBERkxvYWRlcjtcblxuYXYudGhlRXh0ZW5zaW9uTWFuYWdlci5yZWdpc3RlckV4dGVuc2lvbignQXV0b2Rlc2suUERGJywgUERGRXh0ZW5zaW9uKTtcblxuZXhwb3J0IHsgUERGTG9hZGVyLCBQREZFeHRlbnNpb24gfTsiXSwibmFtZXMiOlsiUERGTG9hZGVyIiwiUERGVGV4dExheWVyIiwiYXYiLCJBdXRvZGVzayIsIlZpZXdpbmciLCJhdmVoIiwiQXV0b2Rlc2tOYW1lc3BhY2UiLCJQREZFeHRlbnNpb24iLCJFeHRlbnNpb24iLCJjb25zdHJ1Y3RvciIsInZpZXdlciIsIm9wdGlvbnMiLCJvbk1vZGVsTG9hZGVkIiwiYmluZCIsIm9uUG9wU3RhdGUiLCJzaG93VGV4dExheWVyIiwidXNlVGV4dExheWVyIiwiZW5hYmxlSHlwZXJsaW5rcyIsInVuZGVmaW5lZCIsImVuYWJsZVRleHRTZWFyY2giLCJlbmFibGVCcm93c2VyTmF2aWdhdGlvbiIsImVuYWJsZU1TREZUZXh0IiwiaW1wbCIsInJlbmRlcmVyIiwiaXNXZWFrRGV2aWNlIiwiZ2xyZW5kZXJlciIsImdldFBpeGVsUmF0aW8iLCJzZXR0aW5ncyIsInVzZVNTQUEiLCJsb2FkIiwibG9hZEV4dGVuc2lvbiIsIkZpbGVMb2FkZXJNYW5hZ2VyIiwicmVnaXN0ZXJGaWxlTG9hZGVyIiwiaXNOb2RlSlMiLCJhZGRFdmVudExpc3RlbmVyIiwiR0VPTUVUUllfTE9BREVEX0VWRU5UIiwiYWRkV2luZG93RXZlbnRMaXN0ZW5lciIsInRleHRMYXllciIsInVubG9hZCIsInVucmVnaXN0ZXJGaWxlTG9hZGVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZVdpbmRvd0V2ZW50TGlzdGVuZXIiLCJkZXN0cm95IiwiZXZlbnQiLCJtb2RlbCIsImdldERvY3VtZW50Tm9kZSIsImlzUGRmIiwidXJsIiwiVVJMIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiYnViYmxlTm9kZSIsInBhZ2VJbmRleCIsImRhdGEiLCJwYWdlIiwic2VhcmNoUGFyYW1zIiwiZ2V0Iiwic2V0IiwiX3dpbmRvdyIsImdldFdpbmRvdyIsImhpc3RvcnkiLCJwdXNoU3RhdGUiLCJwYXJzZUludCIsInJvb3ROb2RlIiwiZ2V0Um9vdE5vZGUiLCJjaGlsZHJlbiIsImRpc3BhdGNoRXZlbnQiLCJ0eXBlIiwiSFlQRVJMSU5LX0VWRU5UIiwibG9hZERvY3VtZW50Tm9kZSIsImdldERvY3VtZW50IiwiYWN0aXZhdGUiLCJkZWFjdGl2YXRlIiwidGhlRXh0ZW5zaW9uTWFuYWdlciIsInJlZ2lzdGVyRXh0ZW5zaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./extensions/PDF/index.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[6].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[6].use[2]!./node_modules/css-unicode-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/PDF/textlayer.css":
/*!****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[6].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[6].use[2]!./node_modules/css-unicode-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/PDF/textlayer.css ***!
  \****************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ \"./node_modules/css-loader/dist/runtime/sourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.pdf-textlayer {\n  position: absolute;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n  /* opacity: 0.45; */\n  /* line-height: 1.0; */\n  -webkit-font-smoothing: subpixel-antialiased;\n  display: none;\n}\n\n.pdf-textlayer > div {\n  color: transparent;\n  /* color: black; */\n  position: absolute;\n  white-space: pre;\n  -webkit-transform-origin: 0% 0%;\n  transform-origin: 0% 0%;\n  user-select: text;\n  -webkit-user-select: text;\n  -webkit-text-size-adjust: none;\n  text-size-adjust: none;\n  display: inline;\n}\n\n.pdf-textlayer.enabled {\n  display: block;\n}\n\n.pdf-textlayer.visible {\n  display: block;\n}\n\n.pdf-textlayer.visible > div {\n  display: block;\n  color: black; /*default color for text in case not defined in pdf*/\n}\n\n.pdf-textlayer.enabled > div {\n  cursor: text;\n}\n\n.pdf-textlayer .highlight {\n  margin: -1px;\n  padding: 1px;\n  background-color: rgb(180, 0, 170);\n  border-radius: 4px;\n}\n\n.pdf-textlayer .highlight.begin {\n  border-radius: 4px 0px 0px 4px;\n}\n\n.pdf-textlayer .highlight.end {\n  border-radius: 0px 4px 4px 0px;\n}\n\n.pdf-textlayer .highlight.middle {\n  border-radius: 0px;\n}\n\n.pdf-textlayer .highlight.selected {\n  background-color: rgb(0, 100, 0);\n}\n\n.pdf-textlayer ::-moz-selection {\n  background: rgba(0, 0, 255, 0.45);\n  color: transparent;\n}\n\n.pdf-textlayer ::selection {\n  background: rgba(0, 0, 255, 0.45);\n  color: transparent;\n}\n\n.pdf-textlayer.visible ::-moz-selection {\n  background: rgba(0, 0, 255, 0.45);\n  color: unset;\n}\n\n.pdf-textlayer.visible ::selection {\n  background: rgba(0, 0, 255, 0.45);\n  color: unset;\n}\n\n.pdf-textlayer .endOfContent {\n  display: block;\n  position: absolute;\n  left: 0px;\n  top: 100%;\n  right: 0px;\n  bottom: 0px;\n  z-index: -1;\n  cursor: default;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.pdf-textlayer .endOfContent.active {\n  top: 0px;\n}\n\n.active .adsk-icon-pdf-textselection {\n  background: url(\"data:image/svg+xml,%3C%3Fxml version%3D%221.0%22 encoding%3D%22UTF-8%22 standalone%3D%22no%22%3F%3E%3Csvg width%3D%2216px%22 height%3D%2216px%22 viewBox%3D%220 0 14 16%22 version%3D%221.1%22 xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E    %3C!-- Generator%3A Sketch 3.7.1 (28215) - http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch --%3E    %3Ctitle%3Eicon-text%3C%2Ftitle%3E    %3Cdesc%3ECreated with Sketch.%3C%2Fdesc%3E    %3Cdefs%3E%3C%2Fdefs%3E    %3Cg id%3D%22Page-1%22 stroke%3D%22none%22 stroke-width%3D%221%22 fill%3D%22none%22 fill-rule%3D%22evenodd%22%3E        %3Cg id%3D%22tools%22 transform%3D%22translate(-508.000000%2C -27.000000)%22 fill%3D%22%2300BFFF%22%3E            %3Cg id%3D%22text%22 transform%3D%22translate(500.000000%2C 20.000000)%22%3E                %3Cg id%3D%22icon-text%22 transform%3D%22translate(8.000000%2C 7.000000)%22%3E                    %3Cpath d%3D%22M13.6924546%2C0.948 C13.5289104%2C0.387 13.0022776%2C0 12.4036441%2C0 L8.02806554%2C0 L6.99948571%2C0 L1.59532731%2C0 C0.996693851%2C0 0.47006098%2C0.387 0.306516788%2C0.948 C0.306516788%2C0.948 0%2C2.844 0%2C3.375 C0%2C3.906 0.402174712%2C4 0.402174712%2C4 L1.02857983%2C4 L1.68687091%2C2.72 C1.91315847%2C2.279 2.37704798%2C2 2.88516641%2C2 L5.97090588%2C2 L5.97090588%2C13 L4.94232606%2C14 L2.88516641%2C14 L2.88516641%2C16 L11.113805%2C16 L11.113805%2C14 L9.05664536%2C14 L8.02806554%2C13 L8.02806554%2C2 L11.113805%2C2 C11.6219234%2C2 12.0858129%2C2.279 12.3131291%2C2.72 L12.9714202%2C4 L13.5978253%2C4 C13.5978253%2C4 14%2C3.906 14%2C3.375 C13.9989714%2C2.844 13.6924546%2C0.948 13.6924546%2C0.948 L13.6924546%2C0.948 Z%22 id%3D%22Shape%22%3E%3C%2Fpath%3E                %3C%2Fg%3E            %3C%2Fg%3E        %3C%2Fg%3E    %3C%2Fg%3E%3C%2Fsvg%3E\");\n  background-repeat: no-repeat;\n  background-position: center;\n}\n\n.inactive .adsk-icon-pdf-textselection {\n  background: url(\"data:image/svg+xml,%3C%3Fxml version%3D%221.0%22 encoding%3D%22UTF-8%22 standalone%3D%22no%22%3F%3E%3Csvg width%3D%2214px%22 height%3D%2216px%22 viewBox%3D%220 0 14 16%22 version%3D%221.1%22 xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E    %3C!-- Generator%3A Sketch 3.7.1 (28215) - http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch --%3E    %3Ctitle%3Eicon-text%3C%2Ftitle%3E    %3Cdesc%3ECreated with Sketch.%3C%2Fdesc%3E    %3Cdefs%3E%3C%2Fdefs%3E    %3Cg id%3D%22Page-1%22 stroke%3D%22none%22 stroke-width%3D%221%22 fill%3D%22none%22 fill-rule%3D%22evenodd%22%3E        %3Cg id%3D%22tools%22 transform%3D%22translate(-508.000000%2C -27.000000)%22 fill%3D%22%23F4F4F4%22%3E            %3Cg id%3D%22text%22 transform%3D%22translate(500.000000%2C 20.000000)%22%3E                %3Cg id%3D%22icon-text%22 transform%3D%22translate(8.000000%2C 7.000000)%22%3E                    %3Cpath d%3D%22M13.6924546%2C0.948 C13.5289104%2C0.387 13.0022776%2C0 12.4036441%2C0 L8.02806554%2C0 L6.99948571%2C0 L1.59532731%2C0 C0.996693851%2C0 0.47006098%2C0.387 0.306516788%2C0.948 C0.306516788%2C0.948 0%2C2.844 0%2C3.375 C0%2C3.906 0.402174712%2C4 0.402174712%2C4 L1.02857983%2C4 L1.68687091%2C2.72 C1.91315847%2C2.279 2.37704798%2C2 2.88516641%2C2 L5.97090588%2C2 L5.97090588%2C13 L4.94232606%2C14 L2.88516641%2C14 L2.88516641%2C16 L11.113805%2C16 L11.113805%2C14 L9.05664536%2C14 L8.02806554%2C13 L8.02806554%2C2 L11.113805%2C2 C11.6219234%2C2 12.0858129%2C2.279 12.3131291%2C2.72 L12.9714202%2C4 L13.5978253%2C4 C13.5978253%2C4 14%2C3.906 14%2C3.375 C13.9989714%2C2.844 13.6924546%2C0.948 13.6924546%2C0.948 L13.6924546%2C0.948 Z%22 id%3D%22Shape%22%3E%3C%2Fpath%3E                %3C%2Fg%3E            %3C%2Fg%3E        %3C%2Fg%3E    %3C%2Fg%3E%3C%2Fsvg%3E\");\n  background-repeat: no-repeat;\n  background-position: center;\n}\n\n.adsk-viewing-viewer.light-theme .inactive .adsk-icon-pdf-textselection {\n  background: url(\"data:image/svg+xml,%3C%3Fxml version%3D%221.0%22 encoding%3D%22UTF-8%22 standalone%3D%22no%22%3F%3E%3Csvg width%3D%2216px%22 height%3D%2216px%22 viewBox%3D%220 0 14 16%22 version%3D%221.1%22 xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22 xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E    %3C!-- Generator%3A Sketch 3.7.1 (28215) - http%3A%2F%2Fwww.bohemiancoding.com%2Fsketch --%3E    %3Ctitle%3Eicon-text%3C%2Ftitle%3E    %3Cdesc%3ECreated with Sketch.%3C%2Fdesc%3E    %3Cdefs%3E%3C%2Fdefs%3E    %3Cg id%3D%22Page-1%22 stroke%3D%22none%22 stroke-width%3D%221%22 fill%3D%22none%22 fill-rule%3D%22evenodd%22%3E        %3Cg id%3D%22tools%22 transform%3D%22translate(-508.000000%2C -27.000000)%22 fill%3D%22%230A131C%22%3E            %3Cg id%3D%22text%22 transform%3D%22translate(500.000000%2C 20.000000)%22%3E                %3Cg id%3D%22icon-text%22 transform%3D%22translate(8.000000%2C 7.000000)%22%3E                    %3Cpath d%3D%22M13.6924546%2C0.948 C13.5289104%2C0.387 13.0022776%2C0 12.4036441%2C0 L8.02806554%2C0 L6.99948571%2C0 L1.59532731%2C0 C0.996693851%2C0 0.47006098%2C0.387 0.306516788%2C0.948 C0.306516788%2C0.948 0%2C2.844 0%2C3.375 C0%2C3.906 0.402174712%2C4 0.402174712%2C4 L1.02857983%2C4 L1.68687091%2C2.72 C1.91315847%2C2.279 2.37704798%2C2 2.88516641%2C2 L5.97090588%2C2 L5.97090588%2C13 L4.94232606%2C14 L2.88516641%2C14 L2.88516641%2C16 L11.113805%2C16 L11.113805%2C14 L9.05664536%2C14 L8.02806554%2C13 L8.02806554%2C2 L11.113805%2C2 C11.6219234%2C2 12.0858129%2C2.279 12.3131291%2C2.72 L12.9714202%2C4 L13.5978253%2C4 C13.5978253%2C4 14%2C3.906 14%2C3.375 C13.9989714%2C2.844 13.6924546%2C0.948 13.6924546%2C0.948 L13.6924546%2C0.948 Z%22 id%3D%22Shape%22%3E%3C%2Fpath%3E                %3C%2Fg%3E            %3C%2Fg%3E        %3C%2Fg%3E    %3C%2Fg%3E%3C%2Fsvg%3E\");\n  background-repeat: no-repeat;\n  background-position: center;\n}`, \"\",{\"version\":3,\"sources\":[\"webpack://./extensions/PDF/textlayer.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,kBAAkB;EAClB,OAAO;EACP,MAAM;EACN,QAAQ;EACR,SAAS;EACT,gBAAgB;EAChB,mBAAmB;EACnB,sBAAsB;EACtB,4CAA4C;EAC5C,aAAa;AACf;;AAEA;EACE,kBAAkB;EAClB,kBAAkB;EAClB,kBAAkB;EAClB,gBAAgB;EAChB,+BAA+B;EAC/B,uBAAuB;EACvB,iBAAiB;EACjB,yBAAyB;EACzB,8BAA8B;EAC9B,sBAAsB;EACtB,eAAe;AACjB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,cAAc;EACd,YAAY,EAAE,oDAAoD;AACpE;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,YAAY;EACZ,YAAY;EACZ,kCAAkC;EAClC,kBAAkB;AACpB;;AAEA;EACE,8BAA8B;AAChC;;AAEA;EACE,8BAA8B;AAChC;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,gCAAgC;AAClC;;AAEA;EACE,iCAAiC;EACjC,kBAAkB;AACpB;;AAEA;EACE,iCAAiC;EACjC,kBAAkB;AACpB;;AAEA;EACE,iCAAiC;EACjC,YAAY;AACd;;AAEA;EACE,iCAAiC;EACjC,YAAY;AACd;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,SAAS;EACT,SAAS;EACT,UAAU;EACV,WAAW;EACX,WAAW;EACX,eAAe;EACf,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;EACrB,iBAAiB;AACnB;;AAEA;EACE,QAAQ;AACV;;AAEA;EACE,syDAAsC;EACtC,4BAA4B;EAC5B,2BAA2B;AAC7B;;AAEA;EACE,syDAAwC;EACxC,4BAA4B;EAC5B,2BAA2B;AAC7B;;AAEA;EACE,syDAAqC;EACrC,4BAA4B;EAC5B,2BAA2B;AAC7B\",\"sourcesContent\":[\".pdf-textlayer {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  right: 0;\\n  bottom: 0;\\n  overflow: hidden;\\n  /* opacity: 0.45; */\\n  /* line-height: 1.0; */\\n  -webkit-font-smoothing: subpixel-antialiased;\\n  display: none;\\n}\\n\\n.pdf-textlayer > div {\\n  color: transparent;\\n  /* color: black; */\\n  position: absolute;\\n  white-space: pre;\\n  -webkit-transform-origin: 0% 0%;\\n  transform-origin: 0% 0%;\\n  user-select: text;\\n  -webkit-user-select: text;\\n  -webkit-text-size-adjust: none;\\n  text-size-adjust: none;\\n  display: inline;\\n}\\n\\n.pdf-textlayer.enabled {\\n  display: block;\\n}\\n\\n.pdf-textlayer.visible {\\n  display: block;\\n}\\n\\n.pdf-textlayer.visible > div {\\n  display: block;\\n  color: black; /*default color for text in case not defined in pdf*/\\n}\\n\\n.pdf-textlayer.enabled > div {\\n  cursor: text;\\n}\\n\\n.pdf-textlayer .highlight {\\n  margin: -1px;\\n  padding: 1px;\\n  background-color: rgb(180, 0, 170);\\n  border-radius: 4px;\\n}\\n\\n.pdf-textlayer .highlight.begin {\\n  border-radius: 4px 0px 0px 4px;\\n}\\n\\n.pdf-textlayer .highlight.end {\\n  border-radius: 0px 4px 4px 0px;\\n}\\n\\n.pdf-textlayer .highlight.middle {\\n  border-radius: 0px;\\n}\\n\\n.pdf-textlayer .highlight.selected {\\n  background-color: rgb(0, 100, 0);\\n}\\n\\n.pdf-textlayer ::-moz-selection {\\n  background: rgba(0, 0, 255, 0.45);\\n  color: transparent;\\n}\\n\\n.pdf-textlayer ::selection {\\n  background: rgba(0, 0, 255, 0.45);\\n  color: transparent;\\n}\\n\\n.pdf-textlayer.visible ::-moz-selection {\\n  background: rgba(0, 0, 255, 0.45);\\n  color: unset;\\n}\\n\\n.pdf-textlayer.visible ::selection {\\n  background: rgba(0, 0, 255, 0.45);\\n  color: unset;\\n}\\n\\n.pdf-textlayer .endOfContent {\\n  display: block;\\n  position: absolute;\\n  left: 0px;\\n  top: 100%;\\n  right: 0px;\\n  bottom: 0px;\\n  z-index: -1;\\n  cursor: default;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n}\\n\\n.pdf-textlayer .endOfContent.active {\\n  top: 0px;\\n}\\n\\n.active .adsk-icon-pdf-textselection {\\n  background: url(./res/text.active.svg);\\n  background-repeat: no-repeat;\\n  background-position: center;\\n}\\n\\n.inactive .adsk-icon-pdf-textselection {\\n  background: url(./res/text.inactive.svg);\\n  background-repeat: no-repeat;\\n  background-position: center;\\n}\\n\\n.adsk-viewing-viewer.light-theme .inactive .adsk-icon-pdf-textselection {\\n  background: url(./res/text.light.svg);\\n  background-repeat: no-repeat;\\n  background-position: center;\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL2Nzcy11bmljb2RlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2V4dGVuc2lvbnMvUERGL3RleHRsYXllci5jc3MiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUM2RztBQUNqQjtBQUM1Riw4QkFBOEIsbUZBQTJCLENBQUMsNEZBQXFDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLE9BQU8sK0ZBQStGLFlBQVksV0FBVyxVQUFVLFVBQVUsVUFBVSxZQUFZLGFBQWEsYUFBYSxhQUFhLFdBQVcsTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsV0FBVyxPQUFPLEtBQUssVUFBVSxPQUFPLEtBQUssVUFBVSxPQUFPLEtBQUssVUFBVSxzQkFBc0IsT0FBTyxLQUFLLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsTUFBTSxLQUFLLFlBQVksV0FBVyxNQUFNLEtBQUssVUFBVSxZQUFZLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsT0FBTyxLQUFLLFVBQVUsTUFBTSxLQUFLLGFBQWEsYUFBYSxhQUFhLE9BQU8sS0FBSyxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssYUFBYSxhQUFhLGFBQWEsMENBQTBDLHVCQUF1QixZQUFZLFdBQVcsYUFBYSxjQUFjLHFCQUFxQixzQkFBc0IsMkJBQTJCLG1EQUFtRCxrQkFBa0IsR0FBRywwQkFBMEIsdUJBQXVCLHFCQUFxQix5QkFBeUIscUJBQXFCLG9DQUFvQyw0QkFBNEIsc0JBQXNCLDhCQUE4QixtQ0FBbUMsMkJBQTJCLG9CQUFvQixHQUFHLDRCQUE0QixtQkFBbUIsR0FBRyw0QkFBNEIsbUJBQW1CLEdBQUcsa0NBQWtDLG1CQUFtQixrQkFBa0Isd0RBQXdELGtDQUFrQyxpQkFBaUIsR0FBRywrQkFBK0IsaUJBQWlCLGlCQUFpQix1Q0FBdUMsdUJBQXVCLEdBQUcscUNBQXFDLG1DQUFtQyxHQUFHLG1DQUFtQyxtQ0FBbUMsR0FBRyxzQ0FBc0MsdUJBQXVCLEdBQUcsd0NBQXdDLHFDQUFxQyxHQUFHLHFDQUFxQyxzQ0FBc0MsdUJBQXVCLEdBQUcsZ0NBQWdDLHNDQUFzQyx1QkFBdUIsR0FBRyw2Q0FBNkMsc0NBQXNDLGlCQUFpQixHQUFHLHdDQUF3QyxzQ0FBc0MsaUJBQWlCLEdBQUcsa0NBQWtDLG1CQUFtQix1QkFBdUIsY0FBYyxjQUFjLGVBQWUsZ0JBQWdCLGdCQUFnQixvQkFBb0IsOEJBQThCLDJCQUEyQiwwQkFBMEIsc0JBQXNCLEdBQUcseUNBQXlDLGFBQWEsR0FBRywwQ0FBMEMsMkNBQTJDLGlDQUFpQyxnQ0FBZ0MsR0FBRyw0Q0FBNEMsNkNBQTZDLGlDQUFpQyxnQ0FBZ0MsR0FBRyw2RUFBNkUsMENBQTBDLGlDQUFpQyxnQ0FBZ0MsR0FBRyxtQkFBbUI7QUFDcGlIO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9QREYvdGV4dGxheWVyLmNzcz9kMTU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAucGRmLXRleHRsYXllciB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogMDtcbiAgdG9wOiAwO1xuICByaWdodDogMDtcbiAgYm90dG9tOiAwO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICAvKiBvcGFjaXR5OiAwLjQ1OyAqL1xuICAvKiBsaW5lLWhlaWdodDogMS4wOyAqL1xuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBzdWJwaXhlbC1hbnRpYWxpYXNlZDtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuLnBkZi10ZXh0bGF5ZXIgPiBkaXYge1xuICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gIC8qIGNvbG9yOiBibGFjazsgKi9cbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB3aGl0ZS1zcGFjZTogcHJlO1xuICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDAlIDAlO1xuICB0cmFuc2Zvcm0tb3JpZ2luOiAwJSAwJTtcbiAgdXNlci1zZWxlY3Q6IHRleHQ7XG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IHRleHQ7XG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogbm9uZTtcbiAgdGV4dC1zaXplLWFkanVzdDogbm9uZTtcbiAgZGlzcGxheTogaW5saW5lO1xufVxuXG4ucGRmLXRleHRsYXllci5lbmFibGVkIHtcbiAgZGlzcGxheTogYmxvY2s7XG59XG5cbi5wZGYtdGV4dGxheWVyLnZpc2libGUge1xuICBkaXNwbGF5OiBibG9jaztcbn1cblxuLnBkZi10ZXh0bGF5ZXIudmlzaWJsZSA+IGRpdiB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBjb2xvcjogYmxhY2s7IC8qZGVmYXVsdCBjb2xvciBmb3IgdGV4dCBpbiBjYXNlIG5vdCBkZWZpbmVkIGluIHBkZiovXG59XG5cbi5wZGYtdGV4dGxheWVyLmVuYWJsZWQgPiBkaXYge1xuICBjdXJzb3I6IHRleHQ7XG59XG5cbi5wZGYtdGV4dGxheWVyIC5oaWdobGlnaHQge1xuICBtYXJnaW46IC0xcHg7XG4gIHBhZGRpbmc6IDFweDtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDE4MCwgMCwgMTcwKTtcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xufVxuXG4ucGRmLXRleHRsYXllciAuaGlnaGxpZ2h0LmJlZ2luIHtcbiAgYm9yZGVyLXJhZGl1czogNHB4IDBweCAwcHggNHB4O1xufVxuXG4ucGRmLXRleHRsYXllciAuaGlnaGxpZ2h0LmVuZCB7XG4gIGJvcmRlci1yYWRpdXM6IDBweCA0cHggNHB4IDBweDtcbn1cblxuLnBkZi10ZXh0bGF5ZXIgLmhpZ2hsaWdodC5taWRkbGUge1xuICBib3JkZXItcmFkaXVzOiAwcHg7XG59XG5cbi5wZGYtdGV4dGxheWVyIC5oaWdobGlnaHQuc2VsZWN0ZWQge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCwgMTAwLCAwKTtcbn1cblxuLnBkZi10ZXh0bGF5ZXIgOjotbW96LXNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMjU1LCAwLjQ1KTtcbiAgY29sb3I6IHRyYW5zcGFyZW50O1xufVxuXG4ucGRmLXRleHRsYXllciA6OnNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMjU1LCAwLjQ1KTtcbiAgY29sb3I6IHRyYW5zcGFyZW50O1xufVxuXG4ucGRmLXRleHRsYXllci52aXNpYmxlIDo6LW1vei1zZWxlY3Rpb24ge1xuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDI1NSwgMC40NSk7XG4gIGNvbG9yOiB1bnNldDtcbn1cblxuLnBkZi10ZXh0bGF5ZXIudmlzaWJsZSA6OnNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMjU1LCAwLjQ1KTtcbiAgY29sb3I6IHVuc2V0O1xufVxuXG4ucGRmLXRleHRsYXllciAuZW5kT2ZDb250ZW50IHtcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogMHB4O1xuICB0b3A6IDEwMCU7XG4gIHJpZ2h0OiAwcHg7XG4gIGJvdHRvbTogMHB4O1xuICB6LWluZGV4OiAtMTtcbiAgY3Vyc29yOiBkZWZhdWx0O1xuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gIHVzZXItc2VsZWN0OiBub25lO1xufVxuXG4ucGRmLXRleHRsYXllciAuZW5kT2ZDb250ZW50LmFjdGl2ZSB7XG4gIHRvcDogMHB4O1xufVxuXG4uYWN0aXZlIC5hZHNrLWljb24tcGRmLXRleHRzZWxlY3Rpb24ge1xuICBiYWNrZ3JvdW5kOiB1cmwoXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sIHZlcnNpb24lM0QlMjIxLjAlMjIgZW5jb2RpbmclM0QlMjJVVEYtOCUyMiBzdGFuZGFsb25lJTNEJTIybm8lMjIlM0YlM0UlM0Nzdmcgd2lkdGglM0QlMjIxNnB4JTIyIGhlaWdodCUzRCUyMjE2cHglMjIgdmlld0JveCUzRCUyMjAgMCAxNCAxNiUyMiB2ZXJzaW9uJTNEJTIyMS4xJTIyIHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyIHhtbG5zJTNBeGxpbmslM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjE5OTklMkZ4bGluayUyMiUzRSAgICAlM0MhLS0gR2VuZXJhdG9yJTNBIFNrZXRjaCAzLjcuMSAoMjgyMTUpIC0gaHR0cCUzQSUyRiUyRnd3dy5ib2hlbWlhbmNvZGluZy5jb20lMkZza2V0Y2ggLS0lM0UgICAgJTNDdGl0bGUlM0VpY29uLXRleHQlM0MlMkZ0aXRsZSUzRSAgICAlM0NkZXNjJTNFQ3JlYXRlZCB3aXRoIFNrZXRjaC4lM0MlMkZkZXNjJTNFICAgICUzQ2RlZnMlM0UlM0MlMkZkZWZzJTNFICAgICUzQ2cgaWQlM0QlMjJQYWdlLTElMjIgc3Ryb2tlJTNEJTIybm9uZSUyMiBzdHJva2Utd2lkdGglM0QlMjIxJTIyIGZpbGwlM0QlMjJub25lJTIyIGZpbGwtcnVsZSUzRCUyMmV2ZW5vZGQlMjIlM0UgICAgICAgICUzQ2cgaWQlM0QlMjJ0b29scyUyMiB0cmFuc2Zvcm0lM0QlMjJ0cmFuc2xhdGUoLTUwOC4wMDAwMDAlMkMgLTI3LjAwMDAwMCklMjIgZmlsbCUzRCUyMiUyMzAwQkZGRiUyMiUzRSAgICAgICAgICAgICUzQ2cgaWQlM0QlMjJ0ZXh0JTIyIHRyYW5zZm9ybSUzRCUyMnRyYW5zbGF0ZSg1MDAuMDAwMDAwJTJDIDIwLjAwMDAwMCklMjIlM0UgICAgICAgICAgICAgICAgJTNDZyBpZCUzRCUyMmljb24tdGV4dCUyMiB0cmFuc2Zvcm0lM0QlMjJ0cmFuc2xhdGUoOC4wMDAwMDAlMkMgNy4wMDAwMDApJTIyJTNFICAgICAgICAgICAgICAgICAgICAlM0NwYXRoIGQlM0QlMjJNMTMuNjkyNDU0NiUyQzAuOTQ4IEMxMy41Mjg5MTA0JTJDMC4zODcgMTMuMDAyMjc3NiUyQzAgMTIuNDAzNjQ0MSUyQzAgTDguMDI4MDY1NTQlMkMwIEw2Ljk5OTQ4NTcxJTJDMCBMMS41OTUzMjczMSUyQzAgQzAuOTk2NjkzODUxJTJDMCAwLjQ3MDA2MDk4JTJDMC4zODcgMC4zMDY1MTY3ODglMkMwLjk0OCBDMC4zMDY1MTY3ODglMkMwLjk0OCAwJTJDMi44NDQgMCUyQzMuMzc1IEMwJTJDMy45MDYgMC40MDIxNzQ3MTIlMkM0IDAuNDAyMTc0NzEyJTJDNCBMMS4wMjg1Nzk4MyUyQzQgTDEuNjg2ODcwOTElMkMyLjcyIEMxLjkxMzE1ODQ3JTJDMi4yNzkgMi4zNzcwNDc5OCUyQzIgMi44ODUxNjY0MSUyQzIgTDUuOTcwOTA1ODglMkMyIEw1Ljk3MDkwNTg4JTJDMTMgTDQuOTQyMzI2MDYlMkMxNCBMMi44ODUxNjY0MSUyQzE0IEwyLjg4NTE2NjQxJTJDMTYgTDExLjExMzgwNSUyQzE2IEwxMS4xMTM4MDUlMkMxNCBMOS4wNTY2NDUzNiUyQzE0IEw4LjAyODA2NTU0JTJDMTMgTDguMDI4MDY1NTQlMkMyIEwxMS4xMTM4MDUlMkMyIEMxMS42MjE5MjM0JTJDMiAxMi4wODU4MTI5JTJDMi4yNzkgMTIuMzEzMTI5MSUyQzIuNzIgTDEyLjk3MTQyMDIlMkM0IEwxMy41OTc4MjUzJTJDNCBDMTMuNTk3ODI1MyUyQzQgMTQlMkMzLjkwNiAxNCUyQzMuMzc1IEMxMy45OTg5NzE0JTJDMi44NDQgMTMuNjkyNDU0NiUyQzAuOTQ4IDEzLjY5MjQ1NDYlMkMwLjk0OCBMMTMuNjkyNDU0NiUyQzAuOTQ4IFolMjIgaWQlM0QlMjJTaGFwZSUyMiUzRSUzQyUyRnBhdGglM0UgICAgICAgICAgICAgICAgJTNDJTJGZyUzRSAgICAgICAgICAgICUzQyUyRmclM0UgICAgICAgICUzQyUyRmclM0UgICAgJTNDJTJGZyUzRSUzQyUyRnN2ZyUzRVwiKTtcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xufVxuXG4uaW5hY3RpdmUgLmFkc2staWNvbi1wZGYtdGV4dHNlbGVjdGlvbiB7XG4gIGJhY2tncm91bmQ6IHVybChcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0MlM0Z4bWwgdmVyc2lvbiUzRCUyMjEuMCUyMiBlbmNvZGluZyUzRCUyMlVURi04JTIyIHN0YW5kYWxvbmUlM0QlMjJubyUyMiUzRiUzRSUzQ3N2ZyB3aWR0aCUzRCUyMjE0cHglMjIgaGVpZ2h0JTNEJTIyMTZweCUyMiB2aWV3Qm94JTNEJTIyMCAwIDE0IDE2JTIyIHZlcnNpb24lM0QlMjIxLjElMjIgeG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIgeG1sbnMlM0F4bGluayUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMTk5OSUyRnhsaW5rJTIyJTNFICAgICUzQyEtLSBHZW5lcmF0b3IlM0EgU2tldGNoIDMuNy4xICgyODIxNSkgLSBodHRwJTNBJTJGJTJGd3d3LmJvaGVtaWFuY29kaW5nLmNvbSUyRnNrZXRjaCAtLSUzRSAgICAlM0N0aXRsZSUzRWljb24tdGV4dCUzQyUyRnRpdGxlJTNFICAgICUzQ2Rlc2MlM0VDcmVhdGVkIHdpdGggU2tldGNoLiUzQyUyRmRlc2MlM0UgICAgJTNDZGVmcyUzRSUzQyUyRmRlZnMlM0UgICAgJTNDZyBpZCUzRCUyMlBhZ2UtMSUyMiBzdHJva2UlM0QlMjJub25lJTIyIHN0cm9rZS13aWR0aCUzRCUyMjElMjIgZmlsbCUzRCUyMm5vbmUlMjIgZmlsbC1ydWxlJTNEJTIyZXZlbm9kZCUyMiUzRSAgICAgICAgJTNDZyBpZCUzRCUyMnRvb2xzJTIyIHRyYW5zZm9ybSUzRCUyMnRyYW5zbGF0ZSgtNTA4LjAwMDAwMCUyQyAtMjcuMDAwMDAwKSUyMiBmaWxsJTNEJTIyJTIzRjRGNEY0JTIyJTNFICAgICAgICAgICAgJTNDZyBpZCUzRCUyMnRleHQlMjIgdHJhbnNmb3JtJTNEJTIydHJhbnNsYXRlKDUwMC4wMDAwMDAlMkMgMjAuMDAwMDAwKSUyMiUzRSAgICAgICAgICAgICAgICAlM0NnIGlkJTNEJTIyaWNvbi10ZXh0JTIyIHRyYW5zZm9ybSUzRCUyMnRyYW5zbGF0ZSg4LjAwMDAwMCUyQyA3LjAwMDAwMCklMjIlM0UgICAgICAgICAgICAgICAgICAgICUzQ3BhdGggZCUzRCUyMk0xMy42OTI0NTQ2JTJDMC45NDggQzEzLjUyODkxMDQlMkMwLjM4NyAxMy4wMDIyNzc2JTJDMCAxMi40MDM2NDQxJTJDMCBMOC4wMjgwNjU1NCUyQzAgTDYuOTk5NDg1NzElMkMwIEwxLjU5NTMyNzMxJTJDMCBDMC45OTY2OTM4NTElMkMwIDAuNDcwMDYwOTglMkMwLjM4NyAwLjMwNjUxNjc4OCUyQzAuOTQ4IEMwLjMwNjUxNjc4OCUyQzAuOTQ4IDAlMkMyLjg0NCAwJTJDMy4zNzUgQzAlMkMzLjkwNiAwLjQwMjE3NDcxMiUyQzQgMC40MDIxNzQ3MTIlMkM0IEwxLjAyODU3OTgzJTJDNCBMMS42ODY4NzA5MSUyQzIuNzIgQzEuOTEzMTU4NDclMkMyLjI3OSAyLjM3NzA0Nzk4JTJDMiAyLjg4NTE2NjQxJTJDMiBMNS45NzA5MDU4OCUyQzIgTDUuOTcwOTA1ODglMkMxMyBMNC45NDIzMjYwNiUyQzE0IEwyLjg4NTE2NjQxJTJDMTQgTDIuODg1MTY2NDElMkMxNiBMMTEuMTEzODA1JTJDMTYgTDExLjExMzgwNSUyQzE0IEw5LjA1NjY0NTM2JTJDMTQgTDguMDI4MDY1NTQlMkMxMyBMOC4wMjgwNjU1NCUyQzIgTDExLjExMzgwNSUyQzIgQzExLjYyMTkyMzQlMkMyIDEyLjA4NTgxMjklMkMyLjI3OSAxMi4zMTMxMjkxJTJDMi43MiBMMTIuOTcxNDIwMiUyQzQgTDEzLjU5NzgyNTMlMkM0IEMxMy41OTc4MjUzJTJDNCAxNCUyQzMuOTA2IDE0JTJDMy4zNzUgQzEzLjk5ODk3MTQlMkMyLjg0NCAxMy42OTI0NTQ2JTJDMC45NDggMTMuNjkyNDU0NiUyQzAuOTQ4IEwxMy42OTI0NTQ2JTJDMC45NDggWiUyMiBpZCUzRCUyMlNoYXBlJTIyJTNFJTNDJTJGcGF0aCUzRSAgICAgICAgICAgICAgICAlM0MlMkZnJTNFICAgICAgICAgICAgJTNDJTJGZyUzRSAgICAgICAgJTNDJTJGZyUzRSAgICAlM0MlMkZnJTNFJTNDJTJGc3ZnJTNFXCIpO1xuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XG59XG5cbi5hZHNrLXZpZXdpbmctdmlld2VyLmxpZ2h0LXRoZW1lIC5pbmFjdGl2ZSAuYWRzay1pY29uLXBkZi10ZXh0c2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdXJsKFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCB2ZXJzaW9uJTNEJTIyMS4wJTIyIGVuY29kaW5nJTNEJTIyVVRGLTglMjIgc3RhbmRhbG9uZSUzRCUyMm5vJTIyJTNGJTNFJTNDc3ZnIHdpZHRoJTNEJTIyMTZweCUyMiBoZWlnaHQlM0QlMjIxNnB4JTIyIHZpZXdCb3glM0QlMjIwIDAgMTQgMTYlMjIgdmVyc2lvbiUzRCUyMjEuMSUyMiB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiB4bWxucyUzQXhsaW5rJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYxOTk5JTJGeGxpbmslMjIlM0UgICAgJTNDIS0tIEdlbmVyYXRvciUzQSBTa2V0Y2ggMy43LjEgKDI4MjE1KSAtIGh0dHAlM0ElMkYlMkZ3d3cuYm9oZW1pYW5jb2RpbmcuY29tJTJGc2tldGNoIC0tJTNFICAgICUzQ3RpdGxlJTNFaWNvbi10ZXh0JTNDJTJGdGl0bGUlM0UgICAgJTNDZGVzYyUzRUNyZWF0ZWQgd2l0aCBTa2V0Y2guJTNDJTJGZGVzYyUzRSAgICAlM0NkZWZzJTNFJTNDJTJGZGVmcyUzRSAgICAlM0NnIGlkJTNEJTIyUGFnZS0xJTIyIHN0cm9rZSUzRCUyMm5vbmUlMjIgc3Ryb2tlLXdpZHRoJTNEJTIyMSUyMiBmaWxsJTNEJTIybm9uZSUyMiBmaWxsLXJ1bGUlM0QlMjJldmVub2RkJTIyJTNFICAgICAgICAlM0NnIGlkJTNEJTIydG9vbHMlMjIgdHJhbnNmb3JtJTNEJTIydHJhbnNsYXRlKC01MDguMDAwMDAwJTJDIC0yNy4wMDAwMDApJTIyIGZpbGwlM0QlMjIlMjMwQTEzMUMlMjIlM0UgICAgICAgICAgICAlM0NnIGlkJTNEJTIydGV4dCUyMiB0cmFuc2Zvcm0lM0QlMjJ0cmFuc2xhdGUoNTAwLjAwMDAwMCUyQyAyMC4wMDAwMDApJTIyJTNFICAgICAgICAgICAgICAgICUzQ2cgaWQlM0QlMjJpY29uLXRleHQlMjIgdHJhbnNmb3JtJTNEJTIydHJhbnNsYXRlKDguMDAwMDAwJTJDIDcuMDAwMDAwKSUyMiUzRSAgICAgICAgICAgICAgICAgICAgJTNDcGF0aCBkJTNEJTIyTTEzLjY5MjQ1NDYlMkMwLjk0OCBDMTMuNTI4OTEwNCUyQzAuMzg3IDEzLjAwMjI3NzYlMkMwIDEyLjQwMzY0NDElMkMwIEw4LjAyODA2NTU0JTJDMCBMNi45OTk0ODU3MSUyQzAgTDEuNTk1MzI3MzElMkMwIEMwLjk5NjY5Mzg1MSUyQzAgMC40NzAwNjA5OCUyQzAuMzg3IDAuMzA2NTE2Nzg4JTJDMC45NDggQzAuMzA2NTE2Nzg4JTJDMC45NDggMCUyQzIuODQ0IDAlMkMzLjM3NSBDMCUyQzMuOTA2IDAuNDAyMTc0NzEyJTJDNCAwLjQwMjE3NDcxMiUyQzQgTDEuMDI4NTc5ODMlMkM0IEwxLjY4Njg3MDkxJTJDMi43MiBDMS45MTMxNTg0NyUyQzIuMjc5IDIuMzc3MDQ3OTglMkMyIDIuODg1MTY2NDElMkMyIEw1Ljk3MDkwNTg4JTJDMiBMNS45NzA5MDU4OCUyQzEzIEw0Ljk0MjMyNjA2JTJDMTQgTDIuODg1MTY2NDElMkMxNCBMMi44ODUxNjY0MSUyQzE2IEwxMS4xMTM4MDUlMkMxNiBMMTEuMTEzODA1JTJDMTQgTDkuMDU2NjQ1MzYlMkMxNCBMOC4wMjgwNjU1NCUyQzEzIEw4LjAyODA2NTU0JTJDMiBMMTEuMTEzODA1JTJDMiBDMTEuNjIxOTIzNCUyQzIgMTIuMDg1ODEyOSUyQzIuMjc5IDEyLjMxMzEyOTElMkMyLjcyIEwxMi45NzE0MjAyJTJDNCBMMTMuNTk3ODI1MyUyQzQgQzEzLjU5NzgyNTMlMkM0IDE0JTJDMy45MDYgMTQlMkMzLjM3NSBDMTMuOTk4OTcxNCUyQzIuODQ0IDEzLjY5MjQ1NDYlMkMwLjk0OCAxMy42OTI0NTQ2JTJDMC45NDggTDEzLjY5MjQ1NDYlMkMwLjk0OCBaJTIyIGlkJTNEJTIyU2hhcGUlMjIlM0UlM0MlMkZwYXRoJTNFICAgICAgICAgICAgICAgICUzQyUyRmclM0UgICAgICAgICAgICAlM0MlMkZnJTNFICAgICAgICAlM0MlMkZnJTNFICAgICUzQyUyRmclM0UlM0MlMkZzdmclM0VcIik7XG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG4gIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlcjtcbn1gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL2V4dGVuc2lvbnMvUERGL3RleHRsYXllci5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxrQkFBa0I7RUFDbEIsT0FBTztFQUNQLE1BQU07RUFDTixRQUFRO0VBQ1IsU0FBUztFQUNULGdCQUFnQjtFQUNoQixtQkFBbUI7RUFDbkIsc0JBQXNCO0VBQ3RCLDRDQUE0QztFQUM1QyxhQUFhO0FBQ2Y7O0FBRUE7RUFDRSxrQkFBa0I7RUFDbEIsa0JBQWtCO0VBQ2xCLGtCQUFrQjtFQUNsQixnQkFBZ0I7RUFDaEIsK0JBQStCO0VBQy9CLHVCQUF1QjtFQUN2QixpQkFBaUI7RUFDakIseUJBQXlCO0VBQ3pCLDhCQUE4QjtFQUM5QixzQkFBc0I7RUFDdEIsZUFBZTtBQUNqQjs7QUFFQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7RUFDRSxjQUFjO0FBQ2hCOztBQUVBO0VBQ0UsY0FBYztFQUNkLFlBQVksRUFBRSxvREFBb0Q7QUFDcEU7O0FBRUE7RUFDRSxZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxZQUFZO0VBQ1osWUFBWTtFQUNaLGtDQUFrQztFQUNsQyxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSw4QkFBOEI7QUFDaEM7O0FBRUE7RUFDRSw4QkFBOEI7QUFDaEM7O0FBRUE7RUFDRSxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxnQ0FBZ0M7QUFDbEM7O0FBRUE7RUFDRSxpQ0FBaUM7RUFDakMsa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsaUNBQWlDO0VBQ2pDLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLGlDQUFpQztFQUNqQyxZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxpQ0FBaUM7RUFDakMsWUFBWTtBQUNkOztBQUVBO0VBQ0UsY0FBYztFQUNkLGtCQUFrQjtFQUNsQixTQUFTO0VBQ1QsU0FBUztFQUNULFVBQVU7RUFDVixXQUFXO0VBQ1gsV0FBVztFQUNYLGVBQWU7RUFDZix5QkFBeUI7RUFDekIsc0JBQXNCO0VBQ3RCLHFCQUFxQjtFQUNyQixpQkFBaUI7QUFDbkI7O0FBRUE7RUFDRSxRQUFRO0FBQ1Y7O0FBRUE7RUFDRSxzeURBQXNDO0VBQ3RDLDRCQUE0QjtFQUM1QiwyQkFBMkI7QUFDN0I7O0FBRUE7RUFDRSxzeURBQXdDO0VBQ3hDLDRCQUE0QjtFQUM1QiwyQkFBMkI7QUFDN0I7O0FBRUE7RUFDRSxzeURBQXFDO0VBQ3JDLDRCQUE0QjtFQUM1QiwyQkFBMkI7QUFDN0JcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnBkZi10ZXh0bGF5ZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbGVmdDogMDtcXG4gIHRvcDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIC8qIG9wYWNpdHk6IDAuNDU7ICovXFxuICAvKiBsaW5lLWhlaWdodDogMS4wOyAqL1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogc3VicGl4ZWwtYW50aWFsaWFzZWQ7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4ucGRmLXRleHRsYXllciA+IGRpdiB7XFxuICBjb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAvKiBjb2xvcjogYmxhY2s7ICovXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aGl0ZS1zcGFjZTogcHJlO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiAwJSAwJTtcXG4gIHRyYW5zZm9ybS1vcmlnaW46IDAlIDAlO1xcbiAgdXNlci1zZWxlY3Q6IHRleHQ7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiB0ZXh0O1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiBub25lO1xcbiAgdGV4dC1zaXplLWFkanVzdDogbm9uZTtcXG4gIGRpc3BsYXk6IGlubGluZTtcXG59XFxuXFxuLnBkZi10ZXh0bGF5ZXIuZW5hYmxlZCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLnBkZi10ZXh0bGF5ZXIudmlzaWJsZSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLnBkZi10ZXh0bGF5ZXIudmlzaWJsZSA+IGRpdiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGNvbG9yOiBibGFjazsgLypkZWZhdWx0IGNvbG9yIGZvciB0ZXh0IGluIGNhc2Ugbm90IGRlZmluZWQgaW4gcGRmKi9cXG59XFxuXFxuLnBkZi10ZXh0bGF5ZXIuZW5hYmxlZCA+IGRpdiB7XFxuICBjdXJzb3I6IHRleHQ7XFxufVxcblxcbi5wZGYtdGV4dGxheWVyIC5oaWdobGlnaHQge1xcbiAgbWFyZ2luOiAtMXB4O1xcbiAgcGFkZGluZzogMXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDE4MCwgMCwgMTcwKTtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG59XFxuXFxuLnBkZi10ZXh0bGF5ZXIgLmhpZ2hsaWdodC5iZWdpbiB7XFxuICBib3JkZXItcmFkaXVzOiA0cHggMHB4IDBweCA0cHg7XFxufVxcblxcbi5wZGYtdGV4dGxheWVyIC5oaWdobGlnaHQuZW5kIHtcXG4gIGJvcmRlci1yYWRpdXM6IDBweCA0cHggNHB4IDBweDtcXG59XFxuXFxuLnBkZi10ZXh0bGF5ZXIgLmhpZ2hsaWdodC5taWRkbGUge1xcbiAgYm9yZGVyLXJhZGl1czogMHB4O1xcbn1cXG5cXG4ucGRmLXRleHRsYXllciAuaGlnaGxpZ2h0LnNlbGVjdGVkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigwLCAxMDAsIDApO1xcbn1cXG5cXG4ucGRmLXRleHRsYXllciA6Oi1tb3otc2VsZWN0aW9uIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMjU1LCAwLjQ1KTtcXG4gIGNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuLnBkZi10ZXh0bGF5ZXIgOjpzZWxlY3Rpb24ge1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAyNTUsIDAuNDUpO1xcbiAgY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4ucGRmLXRleHRsYXllci52aXNpYmxlIDo6LW1vei1zZWxlY3Rpb24ge1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAyNTUsIDAuNDUpO1xcbiAgY29sb3I6IHVuc2V0O1xcbn1cXG5cXG4ucGRmLXRleHRsYXllci52aXNpYmxlIDo6c2VsZWN0aW9uIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMjU1LCAwLjQ1KTtcXG4gIGNvbG9yOiB1bnNldDtcXG59XFxuXFxuLnBkZi10ZXh0bGF5ZXIgLmVuZE9mQ29udGVudCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDBweDtcXG4gIHRvcDogMTAwJTtcXG4gIHJpZ2h0OiAwcHg7XFxuICBib3R0b206IDBweDtcXG4gIHotaW5kZXg6IC0xO1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG59XFxuXFxuLnBkZi10ZXh0bGF5ZXIgLmVuZE9mQ29udGVudC5hY3RpdmUge1xcbiAgdG9wOiAwcHg7XFxufVxcblxcbi5hY3RpdmUgLmFkc2staWNvbi1wZGYtdGV4dHNlbGVjdGlvbiB7XFxuICBiYWNrZ3JvdW5kOiB1cmwoLi9yZXMvdGV4dC5hY3RpdmUuc3ZnKTtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XFxufVxcblxcbi5pbmFjdGl2ZSAuYWRzay1pY29uLXBkZi10ZXh0c2VsZWN0aW9uIHtcXG4gIGJhY2tncm91bmQ6IHVybCguL3Jlcy90ZXh0LmluYWN0aXZlLnN2Zyk7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcbn1cXG5cXG4uYWRzay12aWV3aW5nLXZpZXdlci5saWdodC10aGVtZSAuaW5hY3RpdmUgLmFkc2staWNvbi1wZGYtdGV4dHNlbGVjdGlvbiB7XFxuICBiYWNrZ3JvdW5kOiB1cmwoLi9yZXMvdGV4dC5saWdodC5zdmcpO1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlcjtcXG59XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[6].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[6].use[2]!./node_modules/css-unicode-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/PDF/textlayer.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzRkFBc0YscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz8yNGZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbGlzdDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    return [content].concat([sourceMapping]).join(\"\\n\");\n  }\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0F1dG9kZXNrLkV4dGVuc2lvbnMvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcz9hZjEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/sourceMaps.js\n");

/***/ }),

/***/ "./node_modules/opentype.js/dist/opentype.js":
/*!***************************************************!*\
  !*** ./node_modules/opentype.js/dist/opentype.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/**\n * https://opentype.js.org v0.9.0 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett and string.prototype.codepointat polyfill by Mathias Bynens\n */\n\n(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { 'use strict';\n\n\t/*! https://mths.be/codepointat v0.2.0 by @mathias */\n\tif (!String.prototype.codePointAt) {\n\t\t(function() {\n\t\t\tvar defineProperty = (function() {\n\t\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\t\ttry {\n\t\t\t\t\tvar object = {};\n\t\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t\t} catch(error) {}\n\t\t\t\treturn result;\n\t\t\t}());\n\t\t\tvar codePointAt = function(position) {\n\t\t\t\tif (this == null) {\n\t\t\t\t\tthrow TypeError();\n\t\t\t\t}\n\t\t\t\tvar string = String(this);\n\t\t\t\tvar size = string.length;\n\t\t\t\t// `ToInteger`\n\t\t\t\tvar index = position ? Number(position) : 0;\n\t\t\t\tif (index != index) { // better `isNaN`\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t\t// Account for out-of-bounds indices:\n\t\t\t\tif (index < 0 || index >= size) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\t// Get the first code unit\n\t\t\t\tvar first = string.charCodeAt(index);\n\t\t\t\tvar second;\n\t\t\t\tif ( // check if its the start of a surrogate pair\n\t\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t\t) {\n\t\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn first;\n\t\t\t};\n\t\t\tif (defineProperty) {\n\t\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t\t'value': codePointAt,\n\t\t\t\t\t'configurable': true,\n\t\t\t\t\t'writable': true\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t\t}\n\t\t}());\n\t}\n\n\tvar TINF_OK = 0;\n\tvar TINF_DATA_ERROR = -3;\n\n\tfunction Tree() {\n\t  this.table = new Uint16Array(16);   /* table of code length counts */\n\t  this.trans = new Uint16Array(288);  /* code -> symbol translation table */\n\t}\n\n\tfunction Data(source, dest) {\n\t  this.source = source;\n\t  this.sourceIndex = 0;\n\t  this.tag = 0;\n\t  this.bitcount = 0;\n\t  \n\t  this.dest = dest;\n\t  this.destLen = 0;\n\t  \n\t  this.ltree = new Tree();  /* dynamic length/symbol tree */\n\t  this.dtree = new Tree();  /* dynamic distance tree */\n\t}\n\n\t/* --------------------------------------------------- *\n\t * -- uninitialized global data (static structures) -- *\n\t * --------------------------------------------------- */\n\n\tvar sltree = new Tree();\n\tvar sdtree = new Tree();\n\n\t/* extra bits and base tables for length codes */\n\tvar length_bits = new Uint8Array(30);\n\tvar length_base = new Uint16Array(30);\n\n\t/* extra bits and base tables for distance codes */\n\tvar dist_bits = new Uint8Array(30);\n\tvar dist_base = new Uint16Array(30);\n\n\t/* special ordering of code length codes */\n\tvar clcidx = new Uint8Array([\n\t  16, 17, 18, 0, 8, 7, 9, 6,\n\t  10, 5, 11, 4, 12, 3, 13, 2,\n\t  14, 1, 15\n\t]);\n\n\t/* used by tinf_decode_trees, avoids allocations every call */\n\tvar code_tree = new Tree();\n\tvar lengths = new Uint8Array(288 + 32);\n\n\t/* ----------------------- *\n\t * -- utility functions -- *\n\t * ----------------------- */\n\n\t/* build extra bits and base tables */\n\tfunction tinf_build_bits_base(bits, base, delta, first) {\n\t  var i, sum;\n\n\t  /* build bits table */\n\t  for (i = 0; i < delta; ++i) { bits[i] = 0; }\n\t  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }\n\n\t  /* build base table */\n\t  for (sum = first, i = 0; i < 30; ++i) {\n\t    base[i] = sum;\n\t    sum += 1 << bits[i];\n\t  }\n\t}\n\n\t/* build the fixed huffman trees */\n\tfunction tinf_build_fixed_trees(lt, dt) {\n\t  var i;\n\n\t  /* build fixed length tree */\n\t  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }\n\n\t  lt.table[7] = 24;\n\t  lt.table[8] = 152;\n\t  lt.table[9] = 112;\n\n\t  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }\n\t  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }\n\t  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }\n\t  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }\n\n\t  /* build fixed distance tree */\n\t  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }\n\n\t  dt.table[5] = 32;\n\n\t  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }\n\t}\n\n\t/* given an array of code lengths, build a tree */\n\tvar offs = new Uint16Array(16);\n\n\tfunction tinf_build_tree(t, lengths, off, num) {\n\t  var i, sum;\n\n\t  /* clear code length count table */\n\t  for (i = 0; i < 16; ++i) { t.table[i] = 0; }\n\n\t  /* scan symbol lengths, and sum code length counts */\n\t  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }\n\n\t  t.table[0] = 0;\n\n\t  /* compute offset table for distribution sort */\n\t  for (sum = 0, i = 0; i < 16; ++i) {\n\t    offs[i] = sum;\n\t    sum += t.table[i];\n\t  }\n\n\t  /* create code->symbol translation table (symbols sorted by code) */\n\t  for (i = 0; i < num; ++i) {\n\t    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }\n\t  }\n\t}\n\n\t/* ---------------------- *\n\t * -- decode functions -- *\n\t * ---------------------- */\n\n\t/* get one bit from source stream */\n\tfunction tinf_getbit(d) {\n\t  /* check if tag is empty */\n\t  if (!d.bitcount--) {\n\t    /* load next tag */\n\t    d.tag = d.source[d.sourceIndex++];\n\t    d.bitcount = 7;\n\t  }\n\n\t  /* shift bit out of tag */\n\t  var bit = d.tag & 1;\n\t  d.tag >>>= 1;\n\n\t  return bit;\n\t}\n\n\t/* read a num bit value from a stream and add base */\n\tfunction tinf_read_bits(d, num, base) {\n\t  if (!num)\n\t    { return base; }\n\n\t  while (d.bitcount < 24) {\n\t    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n\t    d.bitcount += 8;\n\t  }\n\n\t  var val = d.tag & (0xffff >>> (16 - num));\n\t  d.tag >>>= num;\n\t  d.bitcount -= num;\n\t  return val + base;\n\t}\n\n\t/* given a data stream and a tree, decode a symbol */\n\tfunction tinf_decode_symbol(d, t) {\n\t  while (d.bitcount < 24) {\n\t    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n\t    d.bitcount += 8;\n\t  }\n\t  \n\t  var sum = 0, cur = 0, len = 0;\n\t  var tag = d.tag;\n\n\t  /* get more bits while code value is above sum */\n\t  do {\n\t    cur = 2 * cur + (tag & 1);\n\t    tag >>>= 1;\n\t    ++len;\n\n\t    sum += t.table[len];\n\t    cur -= t.table[len];\n\t  } while (cur >= 0);\n\t  \n\t  d.tag = tag;\n\t  d.bitcount -= len;\n\n\t  return t.trans[sum + cur];\n\t}\n\n\t/* given a data stream, decode dynamic trees from it */\n\tfunction tinf_decode_trees(d, lt, dt) {\n\t  var hlit, hdist, hclen;\n\t  var i, num, length;\n\n\t  /* get 5 bits HLIT (257-286) */\n\t  hlit = tinf_read_bits(d, 5, 257);\n\n\t  /* get 5 bits HDIST (1-32) */\n\t  hdist = tinf_read_bits(d, 5, 1);\n\n\t  /* get 4 bits HCLEN (4-19) */\n\t  hclen = tinf_read_bits(d, 4, 4);\n\n\t  for (i = 0; i < 19; ++i) { lengths[i] = 0; }\n\n\t  /* read code lengths for code length alphabet */\n\t  for (i = 0; i < hclen; ++i) {\n\t    /* get 3 bits code length (0-7) */\n\t    var clen = tinf_read_bits(d, 3, 0);\n\t    lengths[clcidx[i]] = clen;\n\t  }\n\n\t  /* build code length tree */\n\t  tinf_build_tree(code_tree, lengths, 0, 19);\n\n\t  /* decode code lengths for the dynamic trees */\n\t  for (num = 0; num < hlit + hdist;) {\n\t    var sym = tinf_decode_symbol(d, code_tree);\n\n\t    switch (sym) {\n\t      case 16:\n\t        /* copy previous code length 3-6 times (read 2 bits) */\n\t        var prev = lengths[num - 1];\n\t        for (length = tinf_read_bits(d, 2, 3); length; --length) {\n\t          lengths[num++] = prev;\n\t        }\n\t        break;\n\t      case 17:\n\t        /* repeat code length 0 for 3-10 times (read 3 bits) */\n\t        for (length = tinf_read_bits(d, 3, 3); length; --length) {\n\t          lengths[num++] = 0;\n\t        }\n\t        break;\n\t      case 18:\n\t        /* repeat code length 0 for 11-138 times (read 7 bits) */\n\t        for (length = tinf_read_bits(d, 7, 11); length; --length) {\n\t          lengths[num++] = 0;\n\t        }\n\t        break;\n\t      default:\n\t        /* values 0-15 represent the actual code lengths */\n\t        lengths[num++] = sym;\n\t        break;\n\t    }\n\t  }\n\n\t  /* build dynamic trees */\n\t  tinf_build_tree(lt, lengths, 0, hlit);\n\t  tinf_build_tree(dt, lengths, hlit, hdist);\n\t}\n\n\t/* ----------------------------- *\n\t * -- block inflate functions -- *\n\t * ----------------------------- */\n\n\t/* given a stream and two trees, inflate a block of data */\n\tfunction tinf_inflate_block_data(d, lt, dt) {\n\t  while (1) {\n\t    var sym = tinf_decode_symbol(d, lt);\n\n\t    /* check for end of block */\n\t    if (sym === 256) {\n\t      return TINF_OK;\n\t    }\n\n\t    if (sym < 256) {\n\t      d.dest[d.destLen++] = sym;\n\t    } else {\n\t      var length, dist, offs;\n\t      var i;\n\n\t      sym -= 257;\n\n\t      /* possibly get more bits from length code */\n\t      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);\n\n\t      dist = tinf_decode_symbol(d, dt);\n\n\t      /* possibly get more bits from distance code */\n\t      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);\n\n\t      /* copy match */\n\t      for (i = offs; i < offs + length; ++i) {\n\t        d.dest[d.destLen++] = d.dest[i];\n\t      }\n\t    }\n\t  }\n\t}\n\n\t/* inflate an uncompressed block of data */\n\tfunction tinf_inflate_uncompressed_block(d) {\n\t  var length, invlength;\n\t  var i;\n\t  \n\t  /* unread from bitbuffer */\n\t  while (d.bitcount > 8) {\n\t    d.sourceIndex--;\n\t    d.bitcount -= 8;\n\t  }\n\n\t  /* get length */\n\t  length = d.source[d.sourceIndex + 1];\n\t  length = 256 * length + d.source[d.sourceIndex];\n\n\t  /* get one's complement of length */\n\t  invlength = d.source[d.sourceIndex + 3];\n\t  invlength = 256 * invlength + d.source[d.sourceIndex + 2];\n\n\t  /* check length */\n\t  if (length !== (~invlength & 0x0000ffff))\n\t    { return TINF_DATA_ERROR; }\n\n\t  d.sourceIndex += 4;\n\n\t  /* copy block */\n\t  for (i = length; i; --i)\n\t    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }\n\n\t  /* make sure we start next block on a byte boundary */\n\t  d.bitcount = 0;\n\n\t  return TINF_OK;\n\t}\n\n\t/* inflate stream from source to dest */\n\tfunction tinf_uncompress(source, dest) {\n\t  var d = new Data(source, dest);\n\t  var bfinal, btype, res;\n\n\t  do {\n\t    /* read final block flag */\n\t    bfinal = tinf_getbit(d);\n\n\t    /* read block type (2 bits) */\n\t    btype = tinf_read_bits(d, 2, 0);\n\n\t    /* decompress block */\n\t    switch (btype) {\n\t      case 0:\n\t        /* decompress uncompressed block */\n\t        res = tinf_inflate_uncompressed_block(d);\n\t        break;\n\t      case 1:\n\t        /* decompress block with fixed huffman trees */\n\t        res = tinf_inflate_block_data(d, sltree, sdtree);\n\t        break;\n\t      case 2:\n\t        /* decompress block with dynamic huffman trees */\n\t        tinf_decode_trees(d, d.ltree, d.dtree);\n\t        res = tinf_inflate_block_data(d, d.ltree, d.dtree);\n\t        break;\n\t      default:\n\t        res = TINF_DATA_ERROR;\n\t    }\n\n\t    if (res !== TINF_OK)\n\t      { throw new Error('Data error'); }\n\n\t  } while (!bfinal);\n\n\t  if (d.destLen < d.dest.length) {\n\t    if (typeof d.dest.slice === 'function')\n\t      { return d.dest.slice(0, d.destLen); }\n\t    else\n\t      { return d.dest.subarray(0, d.destLen); }\n\t  }\n\t  \n\t  return d.dest;\n\t}\n\n\t/* -------------------- *\n\t * -- initialization -- *\n\t * -------------------- */\n\n\t/* build fixed huffman trees */\n\ttinf_build_fixed_trees(sltree, sdtree);\n\n\t/* build extra bits and base tables */\n\ttinf_build_bits_base(length_bits, length_base, 4, 3);\n\ttinf_build_bits_base(dist_bits, dist_base, 2, 1);\n\n\t/* fix a special case */\n\tlength_bits[28] = 0;\n\tlength_base[28] = 258;\n\n\tvar tinyInflate = tinf_uncompress;\n\n\t// The Bounding Box object\n\n\tfunction derive(v0, v1, v2, v3, t) {\n\t    return Math.pow(1 - t, 3) * v0 +\n\t        3 * Math.pow(1 - t, 2) * t * v1 +\n\t        3 * (1 - t) * Math.pow(t, 2) * v2 +\n\t        Math.pow(t, 3) * v3;\n\t}\n\t/**\n\t * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.\n\t * It is used to calculate the bounding box of a glyph or text path.\n\t *\n\t * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.\n\t *\n\t * @exports opentype.BoundingBox\n\t * @class\n\t * @constructor\n\t */\n\tfunction BoundingBox() {\n\t    this.x1 = Number.NaN;\n\t    this.y1 = Number.NaN;\n\t    this.x2 = Number.NaN;\n\t    this.y2 = Number.NaN;\n\t}\n\n\t/**\n\t * Returns true if the bounding box is empty, that is, no points have been added to the box yet.\n\t */\n\tBoundingBox.prototype.isEmpty = function() {\n\t    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);\n\t};\n\n\t/**\n\t * Add the point to the bounding box.\n\t * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.\n\t * @param {number} x - The X coordinate of the point.\n\t * @param {number} y - The Y coordinate of the point.\n\t */\n\tBoundingBox.prototype.addPoint = function(x, y) {\n\t    if (typeof x === 'number') {\n\t        if (isNaN(this.x1) || isNaN(this.x2)) {\n\t            this.x1 = x;\n\t            this.x2 = x;\n\t        }\n\t        if (x < this.x1) {\n\t            this.x1 = x;\n\t        }\n\t        if (x > this.x2) {\n\t            this.x2 = x;\n\t        }\n\t    }\n\t    if (typeof y === 'number') {\n\t        if (isNaN(this.y1) || isNaN(this.y2)) {\n\t            this.y1 = y;\n\t            this.y2 = y;\n\t        }\n\t        if (y < this.y1) {\n\t            this.y1 = y;\n\t        }\n\t        if (y > this.y2) {\n\t            this.y2 = y;\n\t        }\n\t    }\n\t};\n\n\t/**\n\t * Add a X coordinate to the bounding box.\n\t * This extends the bounding box to include the X coordinate.\n\t * This function is used internally inside of addBezier.\n\t * @param {number} x - The X coordinate of the point.\n\t */\n\tBoundingBox.prototype.addX = function(x) {\n\t    this.addPoint(x, null);\n\t};\n\n\t/**\n\t * Add a Y coordinate to the bounding box.\n\t * This extends the bounding box to include the Y coordinate.\n\t * This function is used internally inside of addBezier.\n\t * @param {number} y - The Y coordinate of the point.\n\t */\n\tBoundingBox.prototype.addY = function(y) {\n\t    this.addPoint(null, y);\n\t};\n\n\t/**\n\t * Add a Bzier curve to the bounding box.\n\t * This extends the bounding box to include the entire Bzier.\n\t * @param {number} x0 - The starting X coordinate.\n\t * @param {number} y0 - The starting Y coordinate.\n\t * @param {number} x1 - The X coordinate of the first control point.\n\t * @param {number} y1 - The Y coordinate of the first control point.\n\t * @param {number} x2 - The X coordinate of the second control point.\n\t * @param {number} y2 - The Y coordinate of the second control point.\n\t * @param {number} x - The ending X coordinate.\n\t * @param {number} y - The ending Y coordinate.\n\t */\n\tBoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {\n\t    var this$1 = this;\n\n\t    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html\n\t    // and https://github.com/icons8/svg-path-bounding-box\n\n\t    var p0 = [x0, y0];\n\t    var p1 = [x1, y1];\n\t    var p2 = [x2, y2];\n\t    var p3 = [x, y];\n\n\t    this.addPoint(x0, y0);\n\t    this.addPoint(x, y);\n\n\t    for (var i = 0; i <= 1; i++) {\n\t        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n\t        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n\t        var c = 3 * p1[i] - 3 * p0[i];\n\n\t        if (a === 0) {\n\t            if (b === 0) { continue; }\n\t            var t = -c / b;\n\t            if (0 < t && t < 1) {\n\t                if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }\n\t                if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }\n\t            }\n\t            continue;\n\t        }\n\n\t        var b2ac = Math.pow(b, 2) - 4 * c * a;\n\t        if (b2ac < 0) { continue; }\n\t        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n\t        if (0 < t1 && t1 < 1) {\n\t            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }\n\t            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }\n\t        }\n\t        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n\t        if (0 < t2 && t2 < 1) {\n\t            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }\n\t            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }\n\t        }\n\t    }\n\t};\n\n\t/**\n\t * Add a quadratic curve to the bounding box.\n\t * This extends the bounding box to include the entire quadratic curve.\n\t * @param {number} x0 - The starting X coordinate.\n\t * @param {number} y0 - The starting Y coordinate.\n\t * @param {number} x1 - The X coordinate of the control point.\n\t * @param {number} y1 - The Y coordinate of the control point.\n\t * @param {number} x - The ending X coordinate.\n\t * @param {number} y - The ending Y coordinate.\n\t */\n\tBoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {\n\t    var cp1x = x0 + 2 / 3 * (x1 - x0);\n\t    var cp1y = y0 + 2 / 3 * (y1 - y0);\n\t    var cp2x = cp1x + 1 / 3 * (x - x0);\n\t    var cp2y = cp1y + 1 / 3 * (y - y0);\n\t    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);\n\t};\n\n\t// Geometric objects\n\n\t/**\n\t * A bzier path containing a set of path commands similar to a SVG path.\n\t * Paths can be drawn on a context using `draw`.\n\t * @exports opentype.Path\n\t * @class\n\t * @constructor\n\t */\n\tfunction Path() {\n\t    this.commands = [];\n\t    this.fill = 'black';\n\t    this.stroke = null;\n\t    this.strokeWidth = 1;\n\t}\n\n\t/**\n\t * @param  {number} x\n\t * @param  {number} y\n\t */\n\tPath.prototype.moveTo = function(x, y) {\n\t    this.commands.push({\n\t        type: 'M',\n\t        x: x,\n\t        y: y\n\t    });\n\t};\n\n\t/**\n\t * @param  {number} x\n\t * @param  {number} y\n\t */\n\tPath.prototype.lineTo = function(x, y) {\n\t    this.commands.push({\n\t        type: 'L',\n\t        x: x,\n\t        y: y\n\t    });\n\t};\n\n\t/**\n\t * Draws cubic curve\n\t * @function\n\t * curveTo\n\t * @memberof opentype.Path.prototype\n\t * @param  {number} x1 - x of control 1\n\t * @param  {number} y1 - y of control 1\n\t * @param  {number} x2 - x of control 2\n\t * @param  {number} y2 - y of control 2\n\t * @param  {number} x - x of path point\n\t * @param  {number} y - y of path point\n\t */\n\n\t/**\n\t * Draws cubic curve\n\t * @function\n\t * bezierCurveTo\n\t * @memberof opentype.Path.prototype\n\t * @param  {number} x1 - x of control 1\n\t * @param  {number} y1 - y of control 1\n\t * @param  {number} x2 - x of control 2\n\t * @param  {number} y2 - y of control 2\n\t * @param  {number} x - x of path point\n\t * @param  {number} y - y of path point\n\t * @see curveTo\n\t */\n\tPath.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {\n\t    this.commands.push({\n\t        type: 'C',\n\t        x1: x1,\n\t        y1: y1,\n\t        x2: x2,\n\t        y2: y2,\n\t        x: x,\n\t        y: y\n\t    });\n\t};\n\n\t/**\n\t * Draws quadratic curve\n\t * @function\n\t * quadraticCurveTo\n\t * @memberof opentype.Path.prototype\n\t * @param  {number} x1 - x of control\n\t * @param  {number} y1 - y of control\n\t * @param  {number} x - x of path point\n\t * @param  {number} y - y of path point\n\t */\n\n\t/**\n\t * Draws quadratic curve\n\t * @function\n\t * quadTo\n\t * @memberof opentype.Path.prototype\n\t * @param  {number} x1 - x of control\n\t * @param  {number} y1 - y of control\n\t * @param  {number} x - x of path point\n\t * @param  {number} y - y of path point\n\t */\n\tPath.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {\n\t    this.commands.push({\n\t        type: 'Q',\n\t        x1: x1,\n\t        y1: y1,\n\t        x: x,\n\t        y: y\n\t    });\n\t};\n\n\t/**\n\t * Closes the path\n\t * @function closePath\n\t * @memberof opentype.Path.prototype\n\t */\n\n\t/**\n\t * Close the path\n\t * @function close\n\t * @memberof opentype.Path.prototype\n\t */\n\tPath.prototype.close = Path.prototype.closePath = function() {\n\t    this.commands.push({\n\t        type: 'Z'\n\t    });\n\t};\n\n\t/**\n\t * Add the given path or list of commands to the commands of this path.\n\t * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n\t */\n\tPath.prototype.extend = function(pathOrCommands) {\n\t    if (pathOrCommands.commands) {\n\t        pathOrCommands = pathOrCommands.commands;\n\t    } else if (pathOrCommands instanceof BoundingBox) {\n\t        var box = pathOrCommands;\n\t        this.moveTo(box.x1, box.y1);\n\t        this.lineTo(box.x2, box.y1);\n\t        this.lineTo(box.x2, box.y2);\n\t        this.lineTo(box.x1, box.y2);\n\t        this.close();\n\t        return;\n\t    }\n\n\t    Array.prototype.push.apply(this.commands, pathOrCommands);\n\t};\n\n\t/**\n\t * Calculate the bounding box of the path.\n\t * @returns {opentype.BoundingBox}\n\t */\n\tPath.prototype.getBoundingBox = function() {\n\t    var this$1 = this;\n\n\t    var box = new BoundingBox();\n\n\t    var startX = 0;\n\t    var startY = 0;\n\t    var prevX = 0;\n\t    var prevY = 0;\n\t    for (var i = 0; i < this.commands.length; i++) {\n\t        var cmd = this$1.commands[i];\n\t        switch (cmd.type) {\n\t            case 'M':\n\t                box.addPoint(cmd.x, cmd.y);\n\t                startX = prevX = cmd.x;\n\t                startY = prevY = cmd.y;\n\t                break;\n\t            case 'L':\n\t                box.addPoint(cmd.x, cmd.y);\n\t                prevX = cmd.x;\n\t                prevY = cmd.y;\n\t                break;\n\t            case 'Q':\n\t                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);\n\t                prevX = cmd.x;\n\t                prevY = cmd.y;\n\t                break;\n\t            case 'C':\n\t                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n\t                prevX = cmd.x;\n\t                prevY = cmd.y;\n\t                break;\n\t            case 'Z':\n\t                prevX = startX;\n\t                prevY = startY;\n\t                break;\n\t            default:\n\t                throw new Error('Unexpected path command ' + cmd.type);\n\t        }\n\t    }\n\t    if (box.isEmpty()) {\n\t        box.addPoint(0, 0);\n\t    }\n\t    return box;\n\t};\n\n\t/**\n\t * Draw the path to a 2D context.\n\t * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.\n\t */\n\tPath.prototype.draw = function(ctx) {\n\t    var this$1 = this;\n\n\t    ctx.beginPath();\n\t    for (var i = 0; i < this.commands.length; i += 1) {\n\t        var cmd = this$1.commands[i];\n\t        if (cmd.type === 'M') {\n\t            ctx.moveTo(cmd.x, cmd.y);\n\t        } else if (cmd.type === 'L') {\n\t            ctx.lineTo(cmd.x, cmd.y);\n\t        } else if (cmd.type === 'C') {\n\t            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n\t        } else if (cmd.type === 'Q') {\n\t            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);\n\t        } else if (cmd.type === 'Z') {\n\t            ctx.closePath();\n\t        }\n\t    }\n\n\t    if (this.fill) {\n\t        ctx.fillStyle = this.fill;\n\t        ctx.fill();\n\t    }\n\n\t    if (this.stroke) {\n\t        ctx.strokeStyle = this.stroke;\n\t        ctx.lineWidth = this.strokeWidth;\n\t        ctx.stroke();\n\t    }\n\t};\n\n\t/**\n\t * Convert the Path to a string of path data instructions\n\t * See http://www.w3.org/TR/SVG/paths.html#PathData\n\t * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n\t * @return {string}\n\t */\n\tPath.prototype.toPathData = function(decimalPlaces) {\n\t    var this$1 = this;\n\n\t    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n\t    function floatToString(v) {\n\t        if (Math.round(v) === v) {\n\t            return '' + Math.round(v);\n\t        } else {\n\t            return v.toFixed(decimalPlaces);\n\t        }\n\t    }\n\n\t    function packValues() {\n\t        var arguments$1 = arguments;\n\n\t        var s = '';\n\t        for (var i = 0; i < arguments.length; i += 1) {\n\t            var v = arguments$1[i];\n\t            if (v >= 0 && i > 0) {\n\t                s += ' ';\n\t            }\n\n\t            s += floatToString(v);\n\t        }\n\n\t        return s;\n\t    }\n\n\t    var d = '';\n\t    for (var i = 0; i < this.commands.length; i += 1) {\n\t        var cmd = this$1.commands[i];\n\t        if (cmd.type === 'M') {\n\t            d += 'M' + packValues(cmd.x, cmd.y);\n\t        } else if (cmd.type === 'L') {\n\t            d += 'L' + packValues(cmd.x, cmd.y);\n\t        } else if (cmd.type === 'C') {\n\t            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n\t        } else if (cmd.type === 'Q') {\n\t            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n\t        } else if (cmd.type === 'Z') {\n\t            d += 'Z';\n\t        }\n\t    }\n\n\t    return d;\n\t};\n\n\t/**\n\t * Convert the path to an SVG <path> element, as a string.\n\t * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n\t * @return {string}\n\t */\n\tPath.prototype.toSVG = function(decimalPlaces) {\n\t    var svg = '<path d=\"';\n\t    svg += this.toPathData(decimalPlaces);\n\t    svg += '\"';\n\t    if (this.fill && this.fill !== 'black') {\n\t        if (this.fill === null) {\n\t            svg += ' fill=\"none\"';\n\t        } else {\n\t            svg += ' fill=\"' + this.fill + '\"';\n\t        }\n\t    }\n\n\t    if (this.stroke) {\n\t        svg += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"';\n\t    }\n\n\t    svg += '/>';\n\t    return svg;\n\t};\n\n\t/**\n\t * Convert the path to a DOM element.\n\t * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n\t * @return {SVGPathElement}\n\t */\n\tPath.prototype.toDOMElement = function(decimalPlaces) {\n\t    var temporaryPath = this.toPathData(decimalPlaces);\n\t    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n\t    newPath.setAttribute('d', temporaryPath);\n\n\t    return newPath;\n\t};\n\n\t// Run-time checking of preconditions.\n\n\tfunction fail(message) {\n\t    throw new Error(message);\n\t}\n\n\t// Precondition function that checks if the given predicate is true.\n\t// If not, it will throw an error.\n\tfunction argument(predicate, message) {\n\t    if (!predicate) {\n\t        fail(message);\n\t    }\n\t}\n\tvar check = { fail: fail, argument: argument, assert: argument };\n\n\t// Data types used in the OpenType font file.\n\n\tvar LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15\n\tvar LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31\n\n\t/**\n\t * @exports opentype.decode\n\t * @class\n\t */\n\tvar decode = {};\n\t/**\n\t * @exports opentype.encode\n\t * @class\n\t */\n\tvar encode = {};\n\t/**\n\t * @exports opentype.sizeOf\n\t * @class\n\t */\n\tvar sizeOf = {};\n\n\t// Return a function that always returns the same value.\n\tfunction constant(v) {\n\t    return function() {\n\t        return v;\n\t    };\n\t}\n\n\t// OpenType data types //////////////////////////////////////////////////////\n\n\t/**\n\t * Convert an 8-bit unsigned integer to a list of 1 byte.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.BYTE = function(v) {\n\t    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');\n\t    return [v];\n\t};\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.BYTE = constant(1);\n\n\t/**\n\t * Convert a 8-bit signed integer to a list of 1 byte.\n\t * @param {string}\n\t * @returns {Array}\n\t */\n\tencode.CHAR = function(v) {\n\t    return [v.charCodeAt(0)];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.CHAR = constant(1);\n\n\t/**\n\t * Convert an ASCII string to a list of bytes.\n\t * @param {string}\n\t * @returns {Array}\n\t */\n\tencode.CHARARRAY = function(v) {\n\t    var b = [];\n\t    for (var i = 0; i < v.length; i += 1) {\n\t        b[i] = v.charCodeAt(i);\n\t    }\n\n\t    return b;\n\t};\n\n\t/**\n\t * @param {Array}\n\t * @returns {number}\n\t */\n\tsizeOf.CHARARRAY = function(v) {\n\t    return v.length;\n\t};\n\n\t/**\n\t * Convert a 16-bit unsigned integer to a list of 2 bytes.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.USHORT = function(v) {\n\t    return [(v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.USHORT = constant(2);\n\n\t/**\n\t * Convert a 16-bit signed integer to a list of 2 bytes.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.SHORT = function(v) {\n\t    // Two's complement\n\t    if (v >= LIMIT16) {\n\t        v = -(2 * LIMIT16 - v);\n\t    }\n\n\t    return [(v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.SHORT = constant(2);\n\n\t/**\n\t * Convert a 24-bit unsigned integer to a list of 3 bytes.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.UINT24 = function(v) {\n\t    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.UINT24 = constant(3);\n\n\t/**\n\t * Convert a 32-bit unsigned integer to a list of 4 bytes.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.ULONG = function(v) {\n\t    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.ULONG = constant(4);\n\n\t/**\n\t * Convert a 32-bit unsigned integer to a list of 4 bytes.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.LONG = function(v) {\n\t    // Two's complement\n\t    if (v >= LIMIT32) {\n\t        v = -(2 * LIMIT32 - v);\n\t    }\n\n\t    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.LONG = constant(4);\n\n\tencode.FIXED = encode.ULONG;\n\tsizeOf.FIXED = sizeOf.ULONG;\n\n\tencode.FWORD = encode.SHORT;\n\tsizeOf.FWORD = sizeOf.SHORT;\n\n\tencode.UFWORD = encode.USHORT;\n\tsizeOf.UFWORD = sizeOf.USHORT;\n\n\t/**\n\t * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.LONGDATETIME = function(v) {\n\t    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.LONGDATETIME = constant(8);\n\n\t/**\n\t * Convert a 4-char tag to a list of 4 bytes.\n\t * @param {string}\n\t * @returns {Array}\n\t */\n\tencode.TAG = function(v) {\n\t    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');\n\t    return [v.charCodeAt(0),\n\t            v.charCodeAt(1),\n\t            v.charCodeAt(2),\n\t            v.charCodeAt(3)];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.TAG = constant(4);\n\n\t// CFF data types ///////////////////////////////////////////////////////////\n\n\tencode.Card8 = encode.BYTE;\n\tsizeOf.Card8 = sizeOf.BYTE;\n\n\tencode.Card16 = encode.USHORT;\n\tsizeOf.Card16 = sizeOf.USHORT;\n\n\tencode.OffSize = encode.BYTE;\n\tsizeOf.OffSize = sizeOf.BYTE;\n\n\tencode.SID = encode.USHORT;\n\tsizeOf.SID = sizeOf.USHORT;\n\n\t// Convert a numeric operand or charstring number to a variable-size list of bytes.\n\t/**\n\t * Convert a numeric operand or charstring number to a variable-size list of bytes.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.NUMBER = function(v) {\n\t    if (v >= -107 && v <= 107) {\n\t        return [v + 139];\n\t    } else if (v >= 108 && v <= 1131) {\n\t        v = v - 108;\n\t        return [(v >> 8) + 247, v & 0xFF];\n\t    } else if (v >= -1131 && v <= -108) {\n\t        v = -v - 108;\n\t        return [(v >> 8) + 251, v & 0xFF];\n\t    } else if (v >= -32768 && v <= 32767) {\n\t        return encode.NUMBER16(v);\n\t    } else {\n\t        return encode.NUMBER32(v);\n\t    }\n\t};\n\n\t/**\n\t * @param {number}\n\t * @returns {number}\n\t */\n\tsizeOf.NUMBER = function(v) {\n\t    return encode.NUMBER(v).length;\n\t};\n\n\t/**\n\t * Convert a signed number between -32768 and +32767 to a three-byte value.\n\t * This ensures we always use three bytes, but is not the most compact format.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.NUMBER16 = function(v) {\n\t    return [28, (v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.NUMBER16 = constant(3);\n\n\t/**\n\t * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n\t * This is useful if you want to be sure you always use four bytes,\n\t * at the expense of wasting a few bytes for smaller numbers.\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.NUMBER32 = function(v) {\n\t    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n\t};\n\n\t/**\n\t * @constant\n\t * @type {number}\n\t */\n\tsizeOf.NUMBER32 = constant(5);\n\n\t/**\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.REAL = function(v) {\n\t    var value = v.toString();\n\n\t    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n\t    // This code converts it back to a number without the epsilon.\n\t    var m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value);\n\t    if (m) {\n\t        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));\n\t        value = (Math.round(v * epsilon) / epsilon).toString();\n\t    }\n\n\t    var nibbles = '';\n\t    for (var i = 0, ii = value.length; i < ii; i += 1) {\n\t        var c = value[i];\n\t        if (c === 'e') {\n\t            nibbles += value[++i] === '-' ? 'c' : 'b';\n\t        } else if (c === '.') {\n\t            nibbles += 'a';\n\t        } else if (c === '-') {\n\t            nibbles += 'e';\n\t        } else {\n\t            nibbles += c;\n\t        }\n\t    }\n\n\t    nibbles += (nibbles.length & 1) ? 'f' : 'ff';\n\t    var out = [30];\n\t    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {\n\t        out.push(parseInt(nibbles.substr(i$1, 2), 16));\n\t    }\n\n\t    return out;\n\t};\n\n\t/**\n\t * @param {number}\n\t * @returns {number}\n\t */\n\tsizeOf.REAL = function(v) {\n\t    return encode.REAL(v).length;\n\t};\n\n\tencode.NAME = encode.CHARARRAY;\n\tsizeOf.NAME = sizeOf.CHARARRAY;\n\n\tencode.STRING = encode.CHARARRAY;\n\tsizeOf.STRING = sizeOf.CHARARRAY;\n\n\t/**\n\t * @param {DataView} data\n\t * @param {number} offset\n\t * @param {number} numBytes\n\t * @returns {string}\n\t */\n\tdecode.UTF8 = function(data, offset, numBytes) {\n\t    var codePoints = [];\n\t    var numChars = numBytes;\n\t    for (var j = 0; j < numChars; j++, offset += 1) {\n\t        codePoints[j] = data.getUint8(offset);\n\t    }\n\n\t    return String.fromCharCode.apply(null, codePoints);\n\t};\n\n\t/**\n\t * @param {DataView} data\n\t * @param {number} offset\n\t * @param {number} numBytes\n\t * @returns {string}\n\t */\n\tdecode.UTF16 = function(data, offset, numBytes) {\n\t    var codePoints = [];\n\t    var numChars = numBytes / 2;\n\t    for (var j = 0; j < numChars; j++, offset += 2) {\n\t        codePoints[j] = data.getUint16(offset);\n\t    }\n\n\t    return String.fromCharCode.apply(null, codePoints);\n\t};\n\n\t/**\n\t * Convert a JavaScript string to UTF16-BE.\n\t * @param {string}\n\t * @returns {Array}\n\t */\n\tencode.UTF16 = function(v) {\n\t    var b = [];\n\t    for (var i = 0; i < v.length; i += 1) {\n\t        var codepoint = v.charCodeAt(i);\n\t        b[b.length] = (codepoint >> 8) & 0xFF;\n\t        b[b.length] = codepoint & 0xFF;\n\t    }\n\n\t    return b;\n\t};\n\n\t/**\n\t * @param {string}\n\t * @returns {number}\n\t */\n\tsizeOf.UTF16 = function(v) {\n\t    return v.length * 2;\n\t};\n\n\t// Data for converting old eight-bit Macintosh encodings to Unicode.\n\t// This representation is optimized for decoding; encoding is slower\n\t// and needs more memory. The assumption is that all opentype.js users\n\t// want to open fonts, but saving a font will be comparatively rare\n\t// so it can be more expensive. Keyed by IANA character set name.\n\t//\n\t// Python script for generating these strings:\n\t//\n\t//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n\t//     print(s.encode('utf-8'))\n\t/**\n\t * @private\n\t */\n\tvar eightBitMacEncodings = {\n\t    'x-mac-croatian':  // Python: 'mac_croatian'\n\t    '' +\n\t    '',\n\t    'x-mac-cyrillic':  // Python: 'mac_cyrillic'\n\t    '' +\n\t    '',\n\t    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n\t    '' +\n\t    '',\n\t    'x-mac-greek':  // Python: 'mac_greek'\n\t    '' +\n\t    '\\u00AD',\n\t    'x-mac-icelandic':  // Python: 'mac_iceland'\n\t    '' +\n\t    '',\n\t    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n\t    '' +\n\t    '',\n\t    'x-mac-ce':  // Python: 'mac_latin2'\n\t    '' +\n\t    '',\n\t    macintosh:  // Python: 'mac_roman'\n\t    '' +\n\t    '',\n\t    'x-mac-romanian':  // Python: 'mac_romanian'\n\t    '' +\n\t    '',\n\t    'x-mac-turkish':  // Python: 'mac_turkish'\n\t    '' +\n\t    ''\n\t};\n\n\t/**\n\t * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n\t * string, or 'undefined' if the encoding is unsupported. For example, we do\n\t * not support Chinese, Japanese or Korean because these would need large\n\t * mapping tables.\n\t * @param {DataView} dataView\n\t * @param {number} offset\n\t * @param {number} dataLength\n\t * @param {string} encoding\n\t * @returns {string}\n\t */\n\tdecode.MACSTRING = function(dataView, offset, dataLength, encoding) {\n\t    var table = eightBitMacEncodings[encoding];\n\t    if (table === undefined) {\n\t        return undefined;\n\t    }\n\n\t    var result = '';\n\t    for (var i = 0; i < dataLength; i++) {\n\t        var c = dataView.getUint8(offset + i);\n\t        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n\t        // mapped to U+0000..U+007F; we only need to look up the others.\n\t        if (c <= 0x7F) {\n\t            result += String.fromCharCode(c);\n\t        } else {\n\t            result += table[c & 0x7F];\n\t        }\n\t    }\n\n\t    return result;\n\t};\n\n\t// Helper function for encode.MACSTRING. Returns a dictionary for mapping\n\t// Unicode character codes to their 8-bit MacOS equivalent. This table\n\t// is not exactly a super cheap data structure, but we do not care because\n\t// encoding Macintosh strings is only rarely needed in typical applications.\n\tvar macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();\n\tvar macEncodingCacheKeys;\n\tvar getMacEncodingTable = function (encoding) {\n\t    // Since we use encoding as a cache key for WeakMap, it has to be\n\t    // a String object and not a literal. And at least on NodeJS 2.10.1,\n\t    // WeakMap requires that the same String instance is passed for cache hits.\n\t    if (!macEncodingCacheKeys) {\n\t        macEncodingCacheKeys = {};\n\t        for (var e in eightBitMacEncodings) {\n\t            /*jshint -W053 */  // Suppress \"Do not use String as a constructor.\"\n\t            macEncodingCacheKeys[e] = new String(e);\n\t        }\n\t    }\n\n\t    var cacheKey = macEncodingCacheKeys[encoding];\n\t    if (cacheKey === undefined) {\n\t        return undefined;\n\t    }\n\n\t    // We can't do \"if (cache.has(key)) {return cache.get(key)}\" here:\n\t    // since garbage collection may run at any time, it could also kick in\n\t    // between the calls to cache.has() and cache.get(). In that case,\n\t    // we would return 'undefined' even though we do support the encoding.\n\t    if (macEncodingTableCache) {\n\t        var cachedTable = macEncodingTableCache.get(cacheKey);\n\t        if (cachedTable !== undefined) {\n\t            return cachedTable;\n\t        }\n\t    }\n\n\t    var decodingTable = eightBitMacEncodings[encoding];\n\t    if (decodingTable === undefined) {\n\t        return undefined;\n\t    }\n\n\t    var encodingTable = {};\n\t    for (var i = 0; i < decodingTable.length; i++) {\n\t        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;\n\t    }\n\n\t    if (macEncodingTableCache) {\n\t        macEncodingTableCache.set(cacheKey, encodingTable);\n\t    }\n\n\t    return encodingTable;\n\t};\n\n\t/**\n\t * Encodes an old-style Macintosh string. Returns a byte array upon success.\n\t * If the requested encoding is unsupported, or if the input string contains\n\t * a character that cannot be expressed in the encoding, the function returns\n\t * 'undefined'.\n\t * @param {string} str\n\t * @param {string} encoding\n\t * @returns {Array}\n\t */\n\tencode.MACSTRING = function(str, encoding) {\n\t    var table = getMacEncodingTable(encoding);\n\t    if (table === undefined) {\n\t        return undefined;\n\t    }\n\n\t    var result = [];\n\t    for (var i = 0; i < str.length; i++) {\n\t        var c = str.charCodeAt(i);\n\n\t        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n\t        // mapped to U+0000..U+007F; we only need to look up the others.\n\t        if (c >= 0x80) {\n\t            c = table[c];\n\t            if (c === undefined) {\n\t                // str contains a Unicode character that cannot be encoded\n\t                // in the requested encoding.\n\t                return undefined;\n\t            }\n\t        }\n\t        result[i] = c;\n\t        // result.push(c);\n\t    }\n\n\t    return result;\n\t};\n\n\t/**\n\t * @param {string} str\n\t * @param {string} encoding\n\t * @returns {number}\n\t */\n\tsizeOf.MACSTRING = function(str, encoding) {\n\t    var b = encode.MACSTRING(str, encoding);\n\t    if (b !== undefined) {\n\t        return b.length;\n\t    } else {\n\t        return 0;\n\t    }\n\t};\n\n\t// Helper for encode.VARDELTAS\n\tfunction isByteEncodable(value) {\n\t    return value >= -128 && value <= 127;\n\t}\n\n\t// Helper for encode.VARDELTAS\n\tfunction encodeVarDeltaRunAsZeroes(deltas, pos, result) {\n\t    var runLength = 0;\n\t    var numDeltas = deltas.length;\n\t    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {\n\t        ++pos;\n\t        ++runLength;\n\t    }\n\t    result.push(0x80 | (runLength - 1));\n\t    return pos;\n\t}\n\n\t// Helper for encode.VARDELTAS\n\tfunction encodeVarDeltaRunAsBytes(deltas, offset, result) {\n\t    var runLength = 0;\n\t    var numDeltas = deltas.length;\n\t    var pos = offset;\n\t    while (pos < numDeltas && runLength < 64) {\n\t        var value = deltas[pos];\n\t        if (!isByteEncodable(value)) {\n\t            break;\n\t        }\n\n\t        // Within a byte-encoded run of deltas, a single zero is best\n\t        // stored literally as 0x00 value. However, if we have two or\n\t        // more zeroes in a sequence, it is better to start a new run.\n\t        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]\n\t        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero\n\t        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)\n\t        // when starting a new run.\n\t        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {\n\t            break;\n\t        }\n\n\t        ++pos;\n\t        ++runLength;\n\t    }\n\t    result.push(runLength - 1);\n\t    for (var i = offset; i < pos; ++i) {\n\t        result.push((deltas[i] + 256) & 0xff);\n\t    }\n\t    return pos;\n\t}\n\n\t// Helper for encode.VARDELTAS\n\tfunction encodeVarDeltaRunAsWords(deltas, offset, result) {\n\t    var runLength = 0;\n\t    var numDeltas = deltas.length;\n\t    var pos = offset;\n\t    while (pos < numDeltas && runLength < 64) {\n\t        var value = deltas[pos];\n\n\t        // Within a word-encoded run of deltas, it is easiest to start\n\t        // a new run (with a different encoding) whenever we encounter\n\t        // a zero value. For example, the sequence [0x6666, 0, 0x7777]\n\t        // needs 7 bytes when storing the zero inside the current run\n\t        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a\n\t        // new run (40 66 66 80 40 77 77).\n\t        if (value === 0) {\n\t            break;\n\t        }\n\n\t        // Within a word-encoded run of deltas, a single value in the\n\t        // range (-128..127) should be encoded within the current run\n\t        // because it is more compact. For example, the sequence\n\t        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value\n\t        // literally (42 66 66 00 02 77 77), but 8 bytes when starting\n\t        // a new run (40 66 66 00 02 40 77 77).\n\t        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {\n\t            break;\n\t        }\n\n\t        ++pos;\n\t        ++runLength;\n\t    }\n\t    result.push(0x40 | (runLength - 1));\n\t    for (var i = offset; i < pos; ++i) {\n\t        var val = deltas[i];\n\t        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);\n\t    }\n\t    return pos;\n\t}\n\n\t/**\n\t * Encode a list of variation adjustment deltas.\n\t *\n\t * Variation adjustment deltas are used in gvar and cvar tables.\n\t * They indicate how points (in gvar) or values (in cvar) get adjusted\n\t * when generating instances of variation fonts.\n\t *\n\t * @see https://www.microsoft.com/typography/otspec/gvar.htm\n\t * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html\n\t * @param {Array}\n\t * @return {Array}\n\t */\n\tencode.VARDELTAS = function(deltas) {\n\t    var pos = 0;\n\t    var result = [];\n\t    while (pos < deltas.length) {\n\t        var value = deltas[pos];\n\t        if (value === 0) {\n\t            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);\n\t        } else if (value >= -128 && value <= 127) {\n\t            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);\n\t        } else {\n\t            pos = encodeVarDeltaRunAsWords(deltas, pos, result);\n\t        }\n\t    }\n\t    return result;\n\t};\n\n\t// Convert a list of values to a CFF INDEX structure.\n\t// The values should be objects containing name / type / value.\n\t/**\n\t * @param {Array} l\n\t * @returns {Array}\n\t */\n\tencode.INDEX = function(l) {\n\t    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n\t    //    i, v;\n\t    // Because we have to know which data type to use to encode the offsets,\n\t    // we have to go through the values twice: once to encode the data and\n\t    // calculate the offsets, then again to encode the offsets using the fitting data type.\n\t    var offset = 1; // First offset is always 1.\n\t    var offsets = [offset];\n\t    var data = [];\n\t    for (var i = 0; i < l.length; i += 1) {\n\t        var v = encode.OBJECT(l[i]);\n\t        Array.prototype.push.apply(data, v);\n\t        offset += v.length;\n\t        offsets.push(offset);\n\t    }\n\n\t    if (data.length === 0) {\n\t        return [0, 0];\n\t    }\n\n\t    var encodedOffsets = [];\n\t    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;\n\t    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];\n\t    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {\n\t        var encodedOffset = offsetEncoder(offsets[i$1]);\n\t        Array.prototype.push.apply(encodedOffsets, encodedOffset);\n\t    }\n\n\t    return Array.prototype.concat(encode.Card16(l.length),\n\t                           encode.OffSize(offSize),\n\t                           encodedOffsets,\n\t                           data);\n\t};\n\n\t/**\n\t * @param {Array}\n\t * @returns {number}\n\t */\n\tsizeOf.INDEX = function(v) {\n\t    return encode.INDEX(v).length;\n\t};\n\n\t/**\n\t * Convert an object to a CFF DICT structure.\n\t * The keys should be numeric.\n\t * The values should be objects containing name / type / value.\n\t * @param {Object} m\n\t * @returns {Array}\n\t */\n\tencode.DICT = function(m) {\n\t    var d = [];\n\t    var keys = Object.keys(m);\n\t    var length = keys.length;\n\n\t    for (var i = 0; i < length; i += 1) {\n\t        // Object.keys() return string keys, but our keys are always numeric.\n\t        var k = parseInt(keys[i], 0);\n\t        var v = m[k];\n\t        // Value comes before the key.\n\t        d = d.concat(encode.OPERAND(v.value, v.type));\n\t        d = d.concat(encode.OPERATOR(k));\n\t    }\n\n\t    return d;\n\t};\n\n\t/**\n\t * @param {Object}\n\t * @returns {number}\n\t */\n\tsizeOf.DICT = function(m) {\n\t    return encode.DICT(m).length;\n\t};\n\n\t/**\n\t * @param {number}\n\t * @returns {Array}\n\t */\n\tencode.OPERATOR = function(v) {\n\t    if (v < 1200) {\n\t        return [v];\n\t    } else {\n\t        return [12, v - 1200];\n\t    }\n\t};\n\n\t/**\n\t * @param {Array} v\n\t * @param {string}\n\t * @returns {Array}\n\t */\n\tencode.OPERAND = function(v, type) {\n\t    var d = [];\n\t    if (Array.isArray(type)) {\n\t        for (var i = 0; i < type.length; i += 1) {\n\t            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);\n\t            d = d.concat(encode.OPERAND(v[i], type[i]));\n\t        }\n\t    } else {\n\t        if (type === 'SID') {\n\t            d = d.concat(encode.NUMBER(v));\n\t        } else if (type === 'offset') {\n\t            // We make it easy for ourselves and always encode offsets as\n\t            // 4 bytes. This makes offset calculation for the top dict easier.\n\t            d = d.concat(encode.NUMBER32(v));\n\t        } else if (type === 'number') {\n\t            d = d.concat(encode.NUMBER(v));\n\t        } else if (type === 'real') {\n\t            d = d.concat(encode.REAL(v));\n\t        } else {\n\t            throw new Error('Unknown operand type ' + type);\n\t            // FIXME Add support for booleans\n\t        }\n\t    }\n\n\t    return d;\n\t};\n\n\tencode.OP = encode.BYTE;\n\tsizeOf.OP = sizeOf.BYTE;\n\n\t// memoize charstring encoding using WeakMap if available\n\tvar wmm = typeof WeakMap === 'function' && new WeakMap();\n\n\t/**\n\t * Convert a list of CharString operations to bytes.\n\t * @param {Array}\n\t * @returns {Array}\n\t */\n\tencode.CHARSTRING = function(ops) {\n\t    // See encode.MACSTRING for why we don't do \"if (wmm && wmm.has(ops))\".\n\t    if (wmm) {\n\t        var cachedValue = wmm.get(ops);\n\t        if (cachedValue !== undefined) {\n\t            return cachedValue;\n\t        }\n\t    }\n\n\t    var d = [];\n\t    var length = ops.length;\n\n\t    for (var i = 0; i < length; i += 1) {\n\t        var op = ops[i];\n\t        d = d.concat(encode[op.type](op.value));\n\t    }\n\n\t    if (wmm) {\n\t        wmm.set(ops, d);\n\t    }\n\n\t    return d;\n\t};\n\n\t/**\n\t * @param {Array}\n\t * @returns {number}\n\t */\n\tsizeOf.CHARSTRING = function(ops) {\n\t    return encode.CHARSTRING(ops).length;\n\t};\n\n\t// Utility functions ////////////////////////////////////////////////////////\n\n\t/**\n\t * Convert an object containing name / type / value to bytes.\n\t * @param {Object}\n\t * @returns {Array}\n\t */\n\tencode.OBJECT = function(v) {\n\t    var encodingFunction = encode[v.type];\n\t    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);\n\t    return encodingFunction(v.value);\n\t};\n\n\t/**\n\t * @param {Object}\n\t * @returns {number}\n\t */\n\tsizeOf.OBJECT = function(v) {\n\t    var sizeOfFunction = sizeOf[v.type];\n\t    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);\n\t    return sizeOfFunction(v.value);\n\t};\n\n\t/**\n\t * Convert a table object to bytes.\n\t * A table contains a list of fields containing the metadata (name, type and default value).\n\t * The table itself has the field values set as attributes.\n\t * @param {opentype.Table}\n\t * @returns {Array}\n\t */\n\tencode.TABLE = function(table) {\n\t    var d = [];\n\t    var length = table.fields.length;\n\t    var subtables = [];\n\t    var subtableOffsets = [];\n\n\t    for (var i = 0; i < length; i += 1) {\n\t        var field = table.fields[i];\n\t        var encodingFunction = encode[field.type];\n\t        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');\n\t        var value = table[field.name];\n\t        if (value === undefined) {\n\t            value = field.value;\n\t        }\n\n\t        var bytes = encodingFunction(value);\n\n\t        if (field.type === 'TABLE') {\n\t            subtableOffsets.push(d.length);\n\t            d = d.concat([0, 0]);\n\t            subtables.push(bytes);\n\t        } else {\n\t            d = d.concat(bytes);\n\t        }\n\t    }\n\n\t    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {\n\t        var o = subtableOffsets[i$1];\n\t        var offset = d.length;\n\t        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');\n\t        d[o] = offset >> 8;\n\t        d[o + 1] = offset & 0xff;\n\t        d = d.concat(subtables[i$1]);\n\t    }\n\n\t    return d;\n\t};\n\n\t/**\n\t * @param {opentype.Table}\n\t * @returns {number}\n\t */\n\tsizeOf.TABLE = function(table) {\n\t    var numBytes = 0;\n\t    var length = table.fields.length;\n\n\t    for (var i = 0; i < length; i += 1) {\n\t        var field = table.fields[i];\n\t        var sizeOfFunction = sizeOf[field.type];\n\t        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');\n\t        var value = table[field.name];\n\t        if (value === undefined) {\n\t            value = field.value;\n\t        }\n\n\t        numBytes += sizeOfFunction(value);\n\n\t        // Subtables take 2 more bytes for offsets.\n\t        if (field.type === 'TABLE') {\n\t            numBytes += 2;\n\t        }\n\t    }\n\n\t    return numBytes;\n\t};\n\n\tencode.RECORD = encode.TABLE;\n\tsizeOf.RECORD = sizeOf.TABLE;\n\n\t// Merge in a list of bytes.\n\tencode.LITERAL = function(v) {\n\t    return v;\n\t};\n\n\tsizeOf.LITERAL = function(v) {\n\t    return v.length;\n\t};\n\n\t// Table metadata\n\n\t/**\n\t * @exports opentype.Table\n\t * @class\n\t * @param {string} tableName\n\t * @param {Array} fields\n\t * @param {Object} options\n\t * @constructor\n\t */\n\tfunction Table(tableName, fields, options) {\n\t    var this$1 = this;\n\n\t    for (var i = 0; i < fields.length; i += 1) {\n\t        var field = fields[i];\n\t        this$1[field.name] = field.value;\n\t    }\n\n\t    this.tableName = tableName;\n\t    this.fields = fields;\n\t    if (options) {\n\t        var optionKeys = Object.keys(options);\n\t        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {\n\t            var k = optionKeys[i$1];\n\t            var v = options[k];\n\t            if (this$1[k] !== undefined) {\n\t                this$1[k] = v;\n\t            }\n\t        }\n\t    }\n\t}\n\n\t/**\n\t * Encodes the table and returns an array of bytes\n\t * @return {Array}\n\t */\n\tTable.prototype.encode = function() {\n\t    return encode.TABLE(this);\n\t};\n\n\t/**\n\t * Get the size of the table.\n\t * @return {number}\n\t */\n\tTable.prototype.sizeOf = function() {\n\t    return sizeOf.TABLE(this);\n\t};\n\n\t/**\n\t * @private\n\t */\n\tfunction ushortList(itemName, list, count) {\n\t    if (count === undefined) {\n\t        count = list.length;\n\t    }\n\t    var fields = new Array(list.length + 1);\n\t    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n\t    for (var i = 0; i < list.length; i++) {\n\t        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};\n\t    }\n\t    return fields;\n\t}\n\n\t/**\n\t * @private\n\t */\n\tfunction tableList(itemName, records, itemCallback) {\n\t    var count = records.length;\n\t    var fields = new Array(count + 1);\n\t    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n\t    for (var i = 0; i < count; i++) {\n\t        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};\n\t    }\n\t    return fields;\n\t}\n\n\t/**\n\t * @private\n\t */\n\tfunction recordList(itemName, records, itemCallback) {\n\t    var count = records.length;\n\t    var fields = [];\n\t    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n\t    for (var i = 0; i < count; i++) {\n\t        fields = fields.concat(itemCallback(records[i], i));\n\t    }\n\t    return fields;\n\t}\n\n\t// Common Layout Tables\n\n\t/**\n\t * @exports opentype.Coverage\n\t * @class\n\t * @param {opentype.Table}\n\t * @constructor\n\t * @extends opentype.Table\n\t */\n\tfunction Coverage(coverageTable) {\n\t    if (coverageTable.format === 1) {\n\t        Table.call(this, 'coverageTable',\n\t            [{name: 'coverageFormat', type: 'USHORT', value: 1}]\n\t            .concat(ushortList('glyph', coverageTable.glyphs))\n\t        );\n\t    } else {\n\t        check.assert(false, 'Can\\'t create coverage table format 2 yet.');\n\t    }\n\t}\n\tCoverage.prototype = Object.create(Table.prototype);\n\tCoverage.prototype.constructor = Coverage;\n\n\tfunction ScriptList(scriptListTable) {\n\t    Table.call(this, 'scriptListTable',\n\t        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {\n\t            var script = scriptRecord.script;\n\t            var defaultLangSys = script.defaultLangSys;\n\t            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');\n\t            return [\n\t                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},\n\t                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [\n\t                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [\n\t                        {name: 'lookupOrder', type: 'USHORT', value: 0},\n\t                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]\n\t                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}\n\t                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {\n\t                        var langSys = langSysRecord.langSys;\n\t                        return [\n\t                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},\n\t                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [\n\t                                {name: 'lookupOrder', type: 'USHORT', value: 0},\n\t                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}\n\t                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}\n\t                        ];\n\t                    })))}\n\t            ];\n\t        })\n\t    );\n\t}\n\tScriptList.prototype = Object.create(Table.prototype);\n\tScriptList.prototype.constructor = ScriptList;\n\n\t/**\n\t * @exports opentype.FeatureList\n\t * @class\n\t * @param {opentype.Table}\n\t * @constructor\n\t * @extends opentype.Table\n\t */\n\tfunction FeatureList(featureListTable) {\n\t    Table.call(this, 'featureListTable',\n\t        recordList('featureRecord', featureListTable, function(featureRecord, i) {\n\t            var feature = featureRecord.feature;\n\t            return [\n\t                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},\n\t                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [\n\t                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}\n\t            ];\n\t        })\n\t    );\n\t}\n\tFeatureList.prototype = Object.create(Table.prototype);\n\tFeatureList.prototype.constructor = FeatureList;\n\n\t/**\n\t * @exports opentype.LookupList\n\t * @class\n\t * @param {opentype.Table}\n\t * @param {Object}\n\t * @constructor\n\t * @extends opentype.Table\n\t */\n\tfunction LookupList(lookupListTable, subtableMakers) {\n\t    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {\n\t        var subtableCallback = subtableMakers[lookupTable.lookupType];\n\t        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');\n\t        return new Table('lookupTable', [\n\t            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},\n\t            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}\n\t        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));\n\t    }));\n\t}\n\tLookupList.prototype = Object.create(Table.prototype);\n\tLookupList.prototype.constructor = LookupList;\n\n\t// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)\n\t// Don't use offsets inside Records (probable bug), only in Tables.\n\tvar table = {\n\t    Table: Table,\n\t    Record: Table,\n\t    Coverage: Coverage,\n\t    ScriptList: ScriptList,\n\t    FeatureList: FeatureList,\n\t    LookupList: LookupList,\n\t    ushortList: ushortList,\n\t    tableList: tableList,\n\t    recordList: recordList,\n\t};\n\n\t// Parsing utility functions\n\n\t// Retrieve an unsigned byte from the DataView.\n\tfunction getByte(dataView, offset) {\n\t    return dataView.getUint8(offset);\n\t}\n\n\t// Retrieve an unsigned 16-bit short from the DataView.\n\t// The value is stored in big endian.\n\tfunction getUShort(dataView, offset) {\n\t    return dataView.getUint16(offset, false);\n\t}\n\n\t// Retrieve a signed 16-bit short from the DataView.\n\t// The value is stored in big endian.\n\tfunction getShort(dataView, offset) {\n\t    return dataView.getInt16(offset, false);\n\t}\n\n\t// Retrieve an unsigned 32-bit long from the DataView.\n\t// The value is stored in big endian.\n\tfunction getULong(dataView, offset) {\n\t    return dataView.getUint32(offset, false);\n\t}\n\n\t// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n\t// The value is stored in big endian.\n\tfunction getFixed(dataView, offset) {\n\t    var decimal = dataView.getInt16(offset, false);\n\t    var fraction = dataView.getUint16(offset + 2, false);\n\t    return decimal + fraction / 65535;\n\t}\n\n\t// Retrieve a 4-character tag from the DataView.\n\t// Tags are used to identify tables.\n\tfunction getTag(dataView, offset) {\n\t    var tag = '';\n\t    for (var i = offset; i < offset + 4; i += 1) {\n\t        tag += String.fromCharCode(dataView.getInt8(i));\n\t    }\n\n\t    return tag;\n\t}\n\n\t// Retrieve an offset from the DataView.\n\t// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\n\tfunction getOffset(dataView, offset, offSize) {\n\t    var v = 0;\n\t    for (var i = 0; i < offSize; i += 1) {\n\t        v <<= 8;\n\t        v += dataView.getUint8(offset + i);\n\t    }\n\n\t    return v;\n\t}\n\n\t// Retrieve a number of bytes from start offset to the end offset from the DataView.\n\tfunction getBytes(dataView, startOffset, endOffset) {\n\t    var bytes = [];\n\t    for (var i = startOffset; i < endOffset; i += 1) {\n\t        bytes.push(dataView.getUint8(i));\n\t    }\n\n\t    return bytes;\n\t}\n\n\t// Convert the list of bytes to a string.\n\tfunction bytesToString(bytes) {\n\t    var s = '';\n\t    for (var i = 0; i < bytes.length; i += 1) {\n\t        s += String.fromCharCode(bytes[i]);\n\t    }\n\n\t    return s;\n\t}\n\n\tvar typeOffsets = {\n\t    byte: 1,\n\t    uShort: 2,\n\t    short: 2,\n\t    uLong: 4,\n\t    fixed: 4,\n\t    longDateTime: 8,\n\t    tag: 4\n\t};\n\n\t// A stateful parser that changes the offset whenever a value is retrieved.\n\t// The data is a DataView.\n\tfunction Parser(data, offset) {\n\t    this.data = data;\n\t    this.offset = offset;\n\t    this.relativeOffset = 0;\n\t}\n\n\tParser.prototype.parseByte = function() {\n\t    var v = this.data.getUint8(this.offset + this.relativeOffset);\n\t    this.relativeOffset += 1;\n\t    return v;\n\t};\n\n\tParser.prototype.parseChar = function() {\n\t    var v = this.data.getInt8(this.offset + this.relativeOffset);\n\t    this.relativeOffset += 1;\n\t    return v;\n\t};\n\n\tParser.prototype.parseCard8 = Parser.prototype.parseByte;\n\n\tParser.prototype.parseUShort = function() {\n\t    var v = this.data.getUint16(this.offset + this.relativeOffset);\n\t    this.relativeOffset += 2;\n\t    return v;\n\t};\n\n\tParser.prototype.parseCard16 = Parser.prototype.parseUShort;\n\tParser.prototype.parseSID = Parser.prototype.parseUShort;\n\tParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\n\tParser.prototype.parseShort = function() {\n\t    var v = this.data.getInt16(this.offset + this.relativeOffset);\n\t    this.relativeOffset += 2;\n\t    return v;\n\t};\n\n\tParser.prototype.parseF2Dot14 = function() {\n\t    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n\t    this.relativeOffset += 2;\n\t    return v;\n\t};\n\n\tParser.prototype.parseULong = function() {\n\t    var v = getULong(this.data, this.offset + this.relativeOffset);\n\t    this.relativeOffset += 4;\n\t    return v;\n\t};\n\n\tParser.prototype.parseOffset32 = Parser.prototype.parseULong;\n\n\tParser.prototype.parseFixed = function() {\n\t    var v = getFixed(this.data, this.offset + this.relativeOffset);\n\t    this.relativeOffset += 4;\n\t    return v;\n\t};\n\n\tParser.prototype.parseString = function(length) {\n\t    var dataView = this.data;\n\t    var offset = this.offset + this.relativeOffset;\n\t    var string = '';\n\t    this.relativeOffset += length;\n\t    for (var i = 0; i < length; i++) {\n\t        string += String.fromCharCode(dataView.getUint8(offset + i));\n\t    }\n\n\t    return string;\n\t};\n\n\tParser.prototype.parseTag = function() {\n\t    return this.parseString(4);\n\t};\n\n\t// LONGDATETIME is a 64-bit integer.\n\t// JavaScript and unix timestamps traditionally use 32 bits, so we\n\t// only take the last 32 bits.\n\t// + Since until 2038 those bits will be filled by zeros we can ignore them.\n\tParser.prototype.parseLongDateTime = function() {\n\t    var v = getULong(this.data, this.offset + this.relativeOffset + 4);\n\t    // Subtract seconds between 01/01/1904 and 01/01/1970\n\t    // to convert Apple Mac timestamp to Standard Unix timestamp\n\t    v -= 2082844800;\n\t    this.relativeOffset += 8;\n\t    return v;\n\t};\n\n\tParser.prototype.parseVersion = function(minorBase) {\n\t    var major = getUShort(this.data, this.offset + this.relativeOffset);\n\n\t    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n\t    // Default returns the correct number if minor = 0xN000 where N is 0-9\n\t    // Set minorBase to 1 for tables that use minor = N where N is 0-9\n\t    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n\t    this.relativeOffset += 4;\n\t    if (minorBase === undefined) { minorBase = 0x1000; }\n\t    return major + minor / minorBase / 10;\n\t};\n\n\tParser.prototype.skip = function(type, amount) {\n\t    if (amount === undefined) {\n\t        amount = 1;\n\t    }\n\n\t    this.relativeOffset += typeOffsets[type] * amount;\n\t};\n\n\t///// Parsing lists and records ///////////////////////////////\n\n\t// Parse a list of 32 bit unsigned integers.\n\tParser.prototype.parseULongList = function(count) {\n\t    if (count === undefined) { count = this.parseULong(); }\n\t    var offsets = new Array(count);\n\t    var dataView = this.data;\n\t    var offset = this.offset + this.relativeOffset;\n\t    for (var i = 0; i < count; i++) {\n\t        offsets[i] = dataView.getUint32(offset);\n\t        offset += 4;\n\t    }\n\n\t    this.relativeOffset += count * 4;\n\t    return offsets;\n\t};\n\n\t// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n\t// or provided as an argument.\n\tParser.prototype.parseOffset16List =\n\tParser.prototype.parseUShortList = function(count) {\n\t    if (count === undefined) { count = this.parseUShort(); }\n\t    var offsets = new Array(count);\n\t    var dataView = this.data;\n\t    var offset = this.offset + this.relativeOffset;\n\t    for (var i = 0; i < count; i++) {\n\t        offsets[i] = dataView.getUint16(offset);\n\t        offset += 2;\n\t    }\n\n\t    this.relativeOffset += count * 2;\n\t    return offsets;\n\t};\n\n\t// Parses a list of 16 bit signed integers.\n\tParser.prototype.parseShortList = function(count) {\n\t    var list = new Array(count);\n\t    var dataView = this.data;\n\t    var offset = this.offset + this.relativeOffset;\n\t    for (var i = 0; i < count; i++) {\n\t        list[i] = dataView.getInt16(offset);\n\t        offset += 2;\n\t    }\n\n\t    this.relativeOffset += count * 2;\n\t    return list;\n\t};\n\n\t// Parses a list of bytes.\n\tParser.prototype.parseByteList = function(count) {\n\t    var list = new Array(count);\n\t    var dataView = this.data;\n\t    var offset = this.offset + this.relativeOffset;\n\t    for (var i = 0; i < count; i++) {\n\t        list[i] = dataView.getUint8(offset++);\n\t    }\n\n\t    this.relativeOffset += count;\n\t    return list;\n\t};\n\n\t/**\n\t * Parse a list of items.\n\t * Record count is optional, if omitted it is read from the stream.\n\t * itemCallback is one of the Parser methods.\n\t */\n\tParser.prototype.parseList = function(count, itemCallback) {\n\t    var this$1 = this;\n\n\t    if (!itemCallback) {\n\t        itemCallback = count;\n\t        count = this.parseUShort();\n\t    }\n\t    var list = new Array(count);\n\t    for (var i = 0; i < count; i++) {\n\t        list[i] = itemCallback.call(this$1);\n\t    }\n\t    return list;\n\t};\n\n\tParser.prototype.parseList32 = function(count, itemCallback) {\n\t    var this$1 = this;\n\n\t    if (!itemCallback) {\n\t        itemCallback = count;\n\t        count = this.parseULong();\n\t    }\n\t    var list = new Array(count);\n\t    for (var i = 0; i < count; i++) {\n\t        list[i] = itemCallback.call(this$1);\n\t    }\n\t    return list;\n\t};\n\n\t/**\n\t * Parse a list of records.\n\t * Record count is optional, if omitted it is read from the stream.\n\t * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n\t */\n\tParser.prototype.parseRecordList = function(count, recordDescription) {\n\t    var this$1 = this;\n\n\t    // If the count argument is absent, read it in the stream.\n\t    if (!recordDescription) {\n\t        recordDescription = count;\n\t        count = this.parseUShort();\n\t    }\n\t    var records = new Array(count);\n\t    var fields = Object.keys(recordDescription);\n\t    for (var i = 0; i < count; i++) {\n\t        var rec = {};\n\t        for (var j = 0; j < fields.length; j++) {\n\t            var fieldName = fields[j];\n\t            var fieldType = recordDescription[fieldName];\n\t            rec[fieldName] = fieldType.call(this$1);\n\t        }\n\t        records[i] = rec;\n\t    }\n\t    return records;\n\t};\n\n\tParser.prototype.parseRecordList32 = function(count, recordDescription) {\n\t    var this$1 = this;\n\n\t    // If the count argument is absent, read it in the stream.\n\t    if (!recordDescription) {\n\t        recordDescription = count;\n\t        count = this.parseULong();\n\t    }\n\t    var records = new Array(count);\n\t    var fields = Object.keys(recordDescription);\n\t    for (var i = 0; i < count; i++) {\n\t        var rec = {};\n\t        for (var j = 0; j < fields.length; j++) {\n\t            var fieldName = fields[j];\n\t            var fieldType = recordDescription[fieldName];\n\t            rec[fieldName] = fieldType.call(this$1);\n\t        }\n\t        records[i] = rec;\n\t    }\n\t    return records;\n\t};\n\n\t// Parse a data structure into an object\n\t// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n\tParser.prototype.parseStruct = function(description) {\n\t    var this$1 = this;\n\n\t    if (typeof description === 'function') {\n\t        return description.call(this);\n\t    } else {\n\t        var fields = Object.keys(description);\n\t        var struct = {};\n\t        for (var j = 0; j < fields.length; j++) {\n\t            var fieldName = fields[j];\n\t            var fieldType = description[fieldName];\n\t            struct[fieldName] = fieldType.call(this$1);\n\t        }\n\t        return struct;\n\t    }\n\t};\n\n\t/**\n\t * Parse a GPOS valueRecord\n\t * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n\t * valueFormat is optional, if omitted it is read from the stream.\n\t */\n\tParser.prototype.parseValueRecord = function(valueFormat) {\n\t    if (valueFormat === undefined) {\n\t        valueFormat = this.parseUShort();\n\t    }\n\t    if (valueFormat === 0) {\n\t        // valueFormat2 in kerning pairs is most often 0\n\t        // in this case return undefined instead of an empty object, to save space\n\t        return;\n\t    }\n\t    var valueRecord = {};\n\n\t    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }\n\t    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }\n\t    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }\n\t    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }\n\n\t    // Device table (non-variable font) / VariationIndex table (variable font) not supported\n\t    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls\n\t    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }\n\t    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }\n\t    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }\n\t    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }\n\n\t    return valueRecord;\n\t};\n\n\t/**\n\t * Parse a list of GPOS valueRecords\n\t * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record\n\t * valueFormat and valueCount are read from the stream.\n\t */\n\tParser.prototype.parseValueRecordList = function() {\n\t    var this$1 = this;\n\n\t    var valueFormat = this.parseUShort();\n\t    var valueCount = this.parseUShort();\n\t    var values = new Array(valueCount);\n\t    for (var i = 0; i < valueCount; i++) {\n\t        values[i] = this$1.parseValueRecord(valueFormat);\n\t    }\n\t    return values;\n\t};\n\n\tParser.prototype.parsePointer = function(description) {\n\t    var structOffset = this.parseOffset16();\n\t    if (structOffset > 0) {\n\t        // NULL offset => return undefined\n\t        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n\t    }\n\t    return undefined;\n\t};\n\n\tParser.prototype.parsePointer32 = function(description) {\n\t    var structOffset = this.parseOffset32();\n\t    if (structOffset > 0) {\n\t        // NULL offset => return undefined\n\t        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n\t    }\n\t    return undefined;\n\t};\n\n\t/**\n\t * Parse a list of offsets to lists of 16-bit integers,\n\t * or a list of offsets to lists of offsets to any kind of items.\n\t * If itemCallback is not provided, a list of list of UShort is assumed.\n\t * If provided, itemCallback is called on each item and must parse the item.\n\t * See examples in tables/gsub.js\n\t */\n\tParser.prototype.parseListOfLists = function(itemCallback) {\n\t    var this$1 = this;\n\n\t    var offsets = this.parseOffset16List();\n\t    var count = offsets.length;\n\t    var relativeOffset = this.relativeOffset;\n\t    var list = new Array(count);\n\t    for (var i = 0; i < count; i++) {\n\t        var start = offsets[i];\n\t        if (start === 0) {\n\t            // NULL offset\n\t            // Add i as owned property to list. Convenient with assert.\n\t            list[i] = undefined;\n\t            continue;\n\t        }\n\t        this$1.relativeOffset = start;\n\t        if (itemCallback) {\n\t            var subOffsets = this$1.parseOffset16List();\n\t            var subList = new Array(subOffsets.length);\n\t            for (var j = 0; j < subOffsets.length; j++) {\n\t                this$1.relativeOffset = start + subOffsets[j];\n\t                subList[j] = itemCallback.call(this$1);\n\t            }\n\t            list[i] = subList;\n\t        } else {\n\t            list[i] = this$1.parseUShortList();\n\t        }\n\t    }\n\t    this.relativeOffset = relativeOffset;\n\t    return list;\n\t};\n\n\t///// Complex tables parsing //////////////////////////////////\n\n\t// Parse a coverage table in a GSUB, GPOS or GDEF table.\n\t// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\t// parser.offset must point to the start of the table containing the coverage.\n\tParser.prototype.parseCoverage = function() {\n\t    var this$1 = this;\n\n\t    var startOffset = this.offset + this.relativeOffset;\n\t    var format = this.parseUShort();\n\t    var count = this.parseUShort();\n\t    if (format === 1) {\n\t        return {\n\t            format: 1,\n\t            glyphs: this.parseUShortList(count)\n\t        };\n\t    } else if (format === 2) {\n\t        var ranges = new Array(count);\n\t        for (var i = 0; i < count; i++) {\n\t            ranges[i] = {\n\t                start: this$1.parseUShort(),\n\t                end: this$1.parseUShort(),\n\t                index: this$1.parseUShort()\n\t            };\n\t        }\n\t        return {\n\t            format: 2,\n\t            ranges: ranges\n\t        };\n\t    }\n\t    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n\t};\n\n\t// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n\t// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\tParser.prototype.parseClassDef = function() {\n\t    var startOffset = this.offset + this.relativeOffset;\n\t    var format = this.parseUShort();\n\t    if (format === 1) {\n\t        return {\n\t            format: 1,\n\t            startGlyph: this.parseUShort(),\n\t            classes: this.parseUShortList()\n\t        };\n\t    } else if (format === 2) {\n\t        return {\n\t            format: 2,\n\t            ranges: this.parseRecordList({\n\t                start: Parser.uShort,\n\t                end: Parser.uShort,\n\t                classId: Parser.uShort\n\t            })\n\t        };\n\t    }\n\t    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n\t};\n\n\t///// Static methods ///////////////////////////////////\n\t// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\n\tParser.list = function(count, itemCallback) {\n\t    return function() {\n\t        return this.parseList(count, itemCallback);\n\t    };\n\t};\n\n\tParser.list32 = function(count, itemCallback) {\n\t    return function() {\n\t        return this.parseList32(count, itemCallback);\n\t    };\n\t};\n\n\tParser.recordList = function(count, recordDescription) {\n\t    return function() {\n\t        return this.parseRecordList(count, recordDescription);\n\t    };\n\t};\n\n\tParser.recordList32 = function(count, recordDescription) {\n\t    return function() {\n\t        return this.parseRecordList32(count, recordDescription);\n\t    };\n\t};\n\n\tParser.pointer = function(description) {\n\t    return function() {\n\t        return this.parsePointer(description);\n\t    };\n\t};\n\n\tParser.pointer32 = function(description) {\n\t    return function() {\n\t        return this.parsePointer32(description);\n\t    };\n\t};\n\n\tParser.tag = Parser.prototype.parseTag;\n\tParser.byte = Parser.prototype.parseByte;\n\tParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\n\tParser.uShortList = Parser.prototype.parseUShortList;\n\tParser.uLong = Parser.offset32 = Parser.prototype.parseULong;\n\tParser.uLongList = Parser.prototype.parseULongList;\n\tParser.struct = Parser.prototype.parseStruct;\n\tParser.coverage = Parser.prototype.parseCoverage;\n\tParser.classDef = Parser.prototype.parseClassDef;\n\n\t///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n\t// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\n\tvar langSysTable = {\n\t    reserved: Parser.uShort,\n\t    reqFeatureIndex: Parser.uShort,\n\t    featureIndexes: Parser.uShortList\n\t};\n\n\tParser.prototype.parseScriptList = function() {\n\t    return this.parsePointer(Parser.recordList({\n\t        tag: Parser.tag,\n\t        script: Parser.pointer({\n\t            defaultLangSys: Parser.pointer(langSysTable),\n\t            langSysRecords: Parser.recordList({\n\t                tag: Parser.tag,\n\t                langSys: Parser.pointer(langSysTable)\n\t            })\n\t        })\n\t    })) || [];\n\t};\n\n\tParser.prototype.parseFeatureList = function() {\n\t    return this.parsePointer(Parser.recordList({\n\t        tag: Parser.tag,\n\t        feature: Parser.pointer({\n\t            featureParams: Parser.offset16,\n\t            lookupListIndexes: Parser.uShortList\n\t        })\n\t    })) || [];\n\t};\n\n\tParser.prototype.parseLookupList = function(lookupTableParsers) {\n\t    return this.parsePointer(Parser.list(Parser.pointer(function() {\n\t        var lookupType = this.parseUShort();\n\t        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');\n\t        var lookupFlag = this.parseUShort();\n\t        var useMarkFilteringSet = lookupFlag & 0x10;\n\t        return {\n\t            lookupType: lookupType,\n\t            lookupFlag: lookupFlag,\n\t            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n\t            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n\t        };\n\t    }))) || [];\n\t};\n\n\tParser.prototype.parseFeatureVariationsList = function() {\n\t    return this.parsePointer32(function() {\n\t        var majorVersion = this.parseUShort();\n\t        var minorVersion = this.parseUShort();\n\t        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');\n\t        var featureVariations = this.parseRecordList32({\n\t            conditionSetOffset: Parser.offset32,\n\t            featureTableSubstitutionOffset: Parser.offset32\n\t        });\n\t        return featureVariations;\n\t    }) || [];\n\t};\n\n\tvar parse = {\n\t    getByte: getByte,\n\t    getCard8: getByte,\n\t    getUShort: getUShort,\n\t    getCard16: getUShort,\n\t    getShort: getShort,\n\t    getULong: getULong,\n\t    getFixed: getFixed,\n\t    getTag: getTag,\n\t    getOffset: getOffset,\n\t    getBytes: getBytes,\n\t    bytesToString: bytesToString,\n\t    Parser: Parser,\n\t};\n\n\t// The `cmap` table stores the mappings from characters to glyphs.\n\n\tfunction parseCmapTableFormat12(cmap, p) {\n\t    //Skip reserved.\n\t    p.parseUShort();\n\n\t    // Length in bytes of the sub-tables.\n\t    cmap.length = p.parseULong();\n\t    cmap.language = p.parseULong();\n\n\t    var groupCount;\n\t    cmap.groupCount = groupCount = p.parseULong();\n\t    cmap.glyphIndexMap = {};\n\n\t    for (var i = 0; i < groupCount; i += 1) {\n\t        var startCharCode = p.parseULong();\n\t        var endCharCode = p.parseULong();\n\t        var startGlyphId = p.parseULong();\n\n\t        for (var c = startCharCode; c <= endCharCode; c += 1) {\n\t            cmap.glyphIndexMap[c] = startGlyphId;\n\t            startGlyphId++;\n\t        }\n\t    }\n\t}\n\n\tfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n\t    // Length in bytes of the sub-tables.\n\t    cmap.length = p.parseUShort();\n\t    cmap.language = p.parseUShort();\n\n\t    // segCount is stored x 2.\n\t    var segCount;\n\t    cmap.segCount = segCount = p.parseUShort() >> 1;\n\n\t    // Skip searchRange, entrySelector, rangeShift.\n\t    p.skip('uShort', 3);\n\n\t    // The \"unrolled\" mapping from character codes to glyph indices.\n\t    cmap.glyphIndexMap = {};\n\t    var endCountParser = new parse.Parser(data, start + offset + 14);\n\t    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);\n\t    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);\n\t    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);\n\t    var glyphIndexOffset = start + offset + 16 + segCount * 8;\n\t    for (var i = 0; i < segCount - 1; i += 1) {\n\t        var glyphIndex = (void 0);\n\t        var endCount = endCountParser.parseUShort();\n\t        var startCount = startCountParser.parseUShort();\n\t        var idDelta = idDeltaParser.parseShort();\n\t        var idRangeOffset = idRangeOffsetParser.parseUShort();\n\t        for (var c = startCount; c <= endCount; c += 1) {\n\t            if (idRangeOffset !== 0) {\n\t                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n\t                // Take the current offset in the idRangeOffset array.\n\t                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);\n\n\t                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n\t                glyphIndexOffset += idRangeOffset;\n\n\t                // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n\t                glyphIndexOffset += (c - startCount) * 2;\n\t                glyphIndex = parse.getUShort(data, glyphIndexOffset);\n\t                if (glyphIndex !== 0) {\n\t                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;\n\t                }\n\t            } else {\n\t                glyphIndex = (c + idDelta) & 0xFFFF;\n\t            }\n\n\t            cmap.glyphIndexMap[c] = glyphIndex;\n\t        }\n\t    }\n\t}\n\n\t// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n\t// There are many available formats, but we only support the Windows format 4 and 12.\n\t// This function returns a `CmapEncoding` object or null if no supported format could be found.\n\tfunction parseCmapTable(data, start) {\n\t    var cmap = {};\n\t    cmap.version = parse.getUShort(data, start);\n\t    check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n\t    // The cmap table can contain many sub-tables, each with their own format.\n\t    // We're only interested in a \"platform 0\" (Unicode format) and \"platform 3\" (Windows format) table.\n\t    cmap.numTables = parse.getUShort(data, start + 2);\n\t    var offset = -1;\n\t    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {\n\t        var platformId = parse.getUShort(data, start + 4 + (i * 8));\n\t        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);\n\t        if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||\n\t            (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {\n\t            offset = parse.getULong(data, start + 4 + (i * 8) + 4);\n\t            break;\n\t        }\n\t    }\n\n\t    if (offset === -1) {\n\t        // There is no cmap table in the font that we support.\n\t        throw new Error('No valid cmap sub-tables found.');\n\t    }\n\n\t    var p = new parse.Parser(data, start + offset);\n\t    cmap.format = p.parseUShort();\n\n\t    if (cmap.format === 12) {\n\t        parseCmapTableFormat12(cmap, p);\n\t    } else if (cmap.format === 4) {\n\t        parseCmapTableFormat4(cmap, p, data, start, offset);\n\t    } else {\n\t        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');\n\t    }\n\n\t    return cmap;\n\t}\n\n\tfunction addSegment(t, code, glyphIndex) {\n\t    t.segments.push({\n\t        end: code,\n\t        start: code,\n\t        delta: -(code - glyphIndex),\n\t        offset: 0,\n\t        glyphIndex: glyphIndex\n\t    });\n\t}\n\n\tfunction addTerminatorSegment(t) {\n\t    t.segments.push({\n\t        end: 0xFFFF,\n\t        start: 0xFFFF,\n\t        delta: 1,\n\t        offset: 0\n\t    });\n\t}\n\n\t// Make cmap table, format 4 by default, 12 if needed only\n\tfunction makeCmapTable(glyphs) {\n\t    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)\n\t    var isPlan0Only = true;\n\t    var i;\n\n\t    // Check if we need to add cmap format 12 or if format 4 only is fine\n\t    for (i = glyphs.length - 1; i > 0; i -= 1) {\n\t        var g = glyphs.get(i);\n\t        if (g.unicode > 65535) {\n\t            console.log('Adding CMAP format 12 (needed!)');\n\t            isPlan0Only = false;\n\t            break;\n\t        }\n\t    }\n\n\t    var cmapTable = [\n\t        {name: 'version', type: 'USHORT', value: 0},\n\t        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},\n\n\t        // CMAP 4 header\n\t        {name: 'platformID', type: 'USHORT', value: 3},\n\t        {name: 'encodingID', type: 'USHORT', value: 1},\n\t        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}\n\t    ];\n\n\t    if (!isPlan0Only)\n\t        { cmapTable = cmapTable.concat([\n\t            // CMAP 12 header\n\t            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere\n\t            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},\n\t            {name: 'cmap12Offset', type: 'ULONG', value: 0}\n\t        ]); }\n\n\t    cmapTable = cmapTable.concat([\n\t        // CMAP 4 Subtable\n\t        {name: 'format', type: 'USHORT', value: 4},\n\t        {name: 'cmap4Length', type: 'USHORT', value: 0},\n\t        {name: 'language', type: 'USHORT', value: 0},\n\t        {name: 'segCountX2', type: 'USHORT', value: 0},\n\t        {name: 'searchRange', type: 'USHORT', value: 0},\n\t        {name: 'entrySelector', type: 'USHORT', value: 0},\n\t        {name: 'rangeShift', type: 'USHORT', value: 0}\n\t    ]);\n\n\t    var t = new table.Table('cmap', cmapTable);\n\n\t    t.segments = [];\n\t    for (i = 0; i < glyphs.length; i += 1) {\n\t        var glyph = glyphs.get(i);\n\t        for (var j = 0; j < glyph.unicodes.length; j += 1) {\n\t            addSegment(t, glyph.unicodes[j], i);\n\t        }\n\n\t        t.segments = t.segments.sort(function (a, b) {\n\t            return a.start - b.start;\n\t        });\n\t    }\n\n\t    addTerminatorSegment(t);\n\n\t    var segCount = t.segments.length;\n\t    var segCountToRemove = 0;\n\n\t    // CMAP 4\n\t    // Set up parallel segment arrays.\n\t    var endCounts = [];\n\t    var startCounts = [];\n\t    var idDeltas = [];\n\t    var idRangeOffsets = [];\n\t    var glyphIds = [];\n\n\t    // CMAP 12\n\t    var cmap12Groups = [];\n\n\t    // Reminder this loop is not following the specification at 100%\n\t    // The specification -> find suites of characters and make a group\n\t    // Here we're doing one group for each letter\n\t    // Doing as the spec can save 8 times (or more) space\n\t    for (i = 0; i < segCount; i += 1) {\n\t        var segment = t.segments[i];\n\n\t        // CMAP 4\n\t        if (segment.end <= 65535 && segment.start <= 65535) {\n\t            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});\n\t            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});\n\t            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});\n\t            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});\n\t            if (segment.glyphId !== undefined) {\n\t                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});\n\t            }\n\t        } else {\n\t            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12\n\t            segCountToRemove += 1;\n\t        }\n\n\t        // CMAP 12\n\t        // Skip Terminator Segment\n\t        if (!isPlan0Only && segment.glyphIndex !== undefined) {\n\t            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});\n\t            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});\n\t            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});\n\t        }\n\t    }\n\n\t    // CMAP 4 Subtable\n\t    t.segCountX2 = (segCount - segCountToRemove) * 2;\n\t    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;\n\t    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);\n\t    t.rangeShift = t.segCountX2 - t.searchRange;\n\n\t    t.fields = t.fields.concat(endCounts);\n\t    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});\n\t    t.fields = t.fields.concat(startCounts);\n\t    t.fields = t.fields.concat(idDeltas);\n\t    t.fields = t.fields.concat(idRangeOffsets);\n\t    t.fields = t.fields.concat(glyphIds);\n\n\t    t.cmap4Length = 14 + // Subtable header\n\t        endCounts.length * 2 +\n\t        2 + // reservedPad\n\t        startCounts.length * 2 +\n\t        idDeltas.length * 2 +\n\t        idRangeOffsets.length * 2 +\n\t        glyphIds.length * 2;\n\n\t    if (!isPlan0Only) {\n\t        // CMAP 12 Subtable\n\t        var cmap12Length = 16 + // Subtable header\n\t            cmap12Groups.length * 4;\n\n\t        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;\n\t        t.fields = t.fields.concat([\n\t            {name: 'cmap12Format', type: 'USHORT', value: 12},\n\t            {name: 'cmap12Reserved', type: 'USHORT', value: 0},\n\t            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},\n\t            {name: 'cmap12Language', type: 'ULONG', value: 0},\n\t            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}\n\t        ]);\n\n\t        t.fields = t.fields.concat(cmap12Groups);\n\t    }\n\n\t    return t;\n\t}\n\n\tvar cmap = { parse: parseCmapTable, make: makeCmapTable };\n\n\t// Glyph encoding\n\n\tvar cffStandardStrings = [\n\t    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n\t    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n\t    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n\t    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n\t    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n\t    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',\n\t    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',\n\t    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',\n\t    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',\n\t    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',\n\t    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',\n\t    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',\n\t    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',\n\t    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',\n\t    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',\n\t    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',\n\t    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',\n\t    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',\n\t    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',\n\t    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',\n\t    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',\n\t    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',\n\t    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',\n\t    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',\n\t    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\n\t    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',\n\t    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n\t    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n\t    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n\t    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',\n\t    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',\n\t    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',\n\t    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',\n\t    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\n\t    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',\n\t    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',\n\t    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',\n\t    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',\n\t    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',\n\t    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',\n\t    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',\n\t    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];\n\n\tvar cffStandardEncoding = [\n\t    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n\t    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n\t    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n\t    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n\t    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n\t    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n\t    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',\n\t    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n\t    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',\n\t    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',\n\t    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',\n\t    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',\n\t    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',\n\t    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',\n\t    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',\n\t    'lslash', 'oslash', 'oe', 'germandbls'];\n\n\tvar cffExpertEncoding = [\n\t    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n\t    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',\n\t    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',\n\t    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\n\t    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',\n\t    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',\n\t    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',\n\t    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',\n\t    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n\t    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n\t    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n\t    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',\n\t    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n\t    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\n\t    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',\n\t    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',\n\t    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',\n\t    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n\t    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',\n\t    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',\n\t    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',\n\t    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',\n\t    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\n\t    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',\n\t    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\n\t    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\n\n\tvar standardNames = [\n\t    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',\n\t    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',\n\t    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',\n\t    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n\t    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',\n\t    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n\t    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',\n\t    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',\n\t    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',\n\t    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',\n\t    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',\n\t    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',\n\t    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',\n\t    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',\n\t    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',\n\t    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',\n\t    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',\n\t    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',\n\t    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',\n\t    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',\n\t    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',\n\t    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',\n\t    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',\n\t    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',\n\t    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];\n\n\t/**\n\t * This is the encoding used for fonts created from scratch.\n\t * It loops through all glyphs and finds the appropriate unicode value.\n\t * Since it's linear time, other encodings will be faster.\n\t * @exports opentype.DefaultEncoding\n\t * @class\n\t * @constructor\n\t * @param {opentype.Font}\n\t */\n\tfunction DefaultEncoding(font) {\n\t    this.font = font;\n\t}\n\n\tDefaultEncoding.prototype.charToGlyphIndex = function(c) {\n\t    var code = c.codePointAt(0);\n\t    var glyphs = this.font.glyphs;\n\t    if (glyphs) {\n\t        for (var i = 0; i < glyphs.length; i += 1) {\n\t            var glyph = glyphs.get(i);\n\t            for (var j = 0; j < glyph.unicodes.length; j += 1) {\n\t                if (glyph.unicodes[j] === code) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t};\n\n\t/**\n\t * @exports opentype.CmapEncoding\n\t * @class\n\t * @constructor\n\t * @param {Object} cmap - a object with the cmap encoded data\n\t */\n\tfunction CmapEncoding(cmap) {\n\t    this.cmap = cmap;\n\t}\n\n\t/**\n\t * @param  {string} c - the character\n\t * @return {number} The glyph index.\n\t */\n\tCmapEncoding.prototype.charToGlyphIndex = function(c) {\n\t    return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;\n\t};\n\n\t/**\n\t * @exports opentype.CffEncoding\n\t * @class\n\t * @constructor\n\t * @param {string} encoding - The encoding\n\t * @param {Array} charset - The character set.\n\t */\n\tfunction CffEncoding(encoding, charset) {\n\t    this.encoding = encoding;\n\t    this.charset = charset;\n\t}\n\n\t/**\n\t * @param  {string} s - The character\n\t * @return {number} The index.\n\t */\n\tCffEncoding.prototype.charToGlyphIndex = function(s) {\n\t    var code = s.codePointAt(0);\n\t    var charName = this.encoding[code];\n\t    return this.charset.indexOf(charName);\n\t};\n\n\t/**\n\t * @exports opentype.GlyphNames\n\t * @class\n\t * @constructor\n\t * @param {Object} post\n\t */\n\tfunction GlyphNames(post) {\n\t    var this$1 = this;\n\n\t    switch (post.version) {\n\t        case 1:\n\t            this.names = standardNames.slice();\n\t            break;\n\t        case 2:\n\t            this.names = new Array(post.numberOfGlyphs);\n\t            for (var i = 0; i < post.numberOfGlyphs; i++) {\n\t                if (post.glyphNameIndex[i] < standardNames.length) {\n\t                    this$1.names[i] = standardNames[post.glyphNameIndex[i]];\n\t                } else {\n\t                    this$1.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];\n\t                }\n\t            }\n\n\t            break;\n\t        case 2.5:\n\t            this.names = new Array(post.numberOfGlyphs);\n\t            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n\t                this$1.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];\n\t            }\n\n\t            break;\n\t        case 3:\n\t            this.names = [];\n\t            break;\n\t        default:\n\t            this.names = [];\n\t            break;\n\t    }\n\t}\n\n\t/**\n\t * Gets the index of a glyph by name.\n\t * @param  {string} name - The glyph name\n\t * @return {number} The index\n\t */\n\tGlyphNames.prototype.nameToGlyphIndex = function(name) {\n\t    return this.names.indexOf(name);\n\t};\n\n\t/**\n\t * @param  {number} gid\n\t * @return {string}\n\t */\n\tGlyphNames.prototype.glyphIndexToName = function(gid) {\n\t    return this.names[gid];\n\t};\n\n\t/**\n\t * @alias opentype.addGlyphNames\n\t * @param {opentype.Font}\n\t */\n\tfunction addGlyphNames(font) {\n\t    var glyph;\n\t    var glyphIndexMap = font.tables.cmap.glyphIndexMap;\n\t    var charCodes = Object.keys(glyphIndexMap);\n\n\t    for (var i = 0; i < charCodes.length; i += 1) {\n\t        var c = charCodes[i];\n\t        var glyphIndex = glyphIndexMap[c];\n\t        glyph = font.glyphs.get(glyphIndex);\n\t        glyph.addUnicode(parseInt(c));\n\t    }\n\n\t    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {\n\t        glyph = font.glyphs.get(i$1);\n\t        if (font.cffEncoding) {\n\t            if (font.isCIDFont) {\n\t                glyph.name = 'gid' + i$1;\n\t            } else {\n\t                glyph.name = font.cffEncoding.charset[i$1];\n\t            }\n\t        } else if (font.glyphNames.names) {\n\t            glyph.name = font.glyphNames.glyphIndexToName(i$1);\n\t        }\n\t    }\n\t}\n\n\t// Drawing utility functions.\n\n\t// Draw a line on the given context from point `x1,y1` to point `x2,y2`.\n\tfunction line(ctx, x1, y1, x2, y2) {\n\t    ctx.beginPath();\n\t    ctx.moveTo(x1, y1);\n\t    ctx.lineTo(x2, y2);\n\t    ctx.stroke();\n\t}\n\n\tvar draw = { line: line };\n\n\t// The Glyph object\n\t// import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency\n\n\tfunction getPathDefinition(glyph, path) {\n\t    var _path = path || new Path();\n\t    return {\n\t        configurable: true,\n\n\t        get: function() {\n\t            if (typeof _path === 'function') {\n\t                _path = _path();\n\t            }\n\n\t            return _path;\n\t        },\n\n\t        set: function(p) {\n\t            _path = p;\n\t        }\n\t    };\n\t}\n\t/**\n\t * @typedef GlyphOptions\n\t * @type Object\n\t * @property {string} [name] - The glyph name\n\t * @property {number} [unicode]\n\t * @property {Array} [unicodes]\n\t * @property {number} [xMin]\n\t * @property {number} [yMin]\n\t * @property {number} [xMax]\n\t * @property {number} [yMax]\n\t * @property {number} [advanceWidth]\n\t */\n\n\t// A Glyph is an individual mark that often corresponds to a character.\n\t// Some glyphs, such as ligatures, are a combination of many characters.\n\t// Glyphs are the basic building blocks of a font.\n\t//\n\t// The `Glyph` class contains utility methods for drawing the path and its points.\n\t/**\n\t * @exports opentype.Glyph\n\t * @class\n\t * @param {GlyphOptions}\n\t * @constructor\n\t */\n\tfunction Glyph(options) {\n\t    // By putting all the code on a prototype function (which is only declared once)\n\t    // we reduce the memory requirements for larger fonts by some 2%\n\t    this.bindConstructorValues(options);\n\t}\n\n\t/**\n\t * @param  {GlyphOptions}\n\t */\n\tGlyph.prototype.bindConstructorValues = function(options) {\n\t    this.index = options.index || 0;\n\n\t    // These three values cannot be deferred for memory optimization:\n\t    this.name = options.name || null;\n\t    this.unicode = options.unicode || undefined;\n\t    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];\n\n\t    // But by binding these values only when necessary, we reduce can\n\t    // the memory requirements by almost 3% for larger fonts.\n\t    if (options.xMin) {\n\t        this.xMin = options.xMin;\n\t    }\n\n\t    if (options.yMin) {\n\t        this.yMin = options.yMin;\n\t    }\n\n\t    if (options.xMax) {\n\t        this.xMax = options.xMax;\n\t    }\n\n\t    if (options.yMax) {\n\t        this.yMax = options.yMax;\n\t    }\n\n\t    if (options.advanceWidth) {\n\t        this.advanceWidth = options.advanceWidth;\n\t    }\n\n\t    // The path for a glyph is the most memory intensive, and is bound as a value\n\t    // with a getter/setter to ensure we actually do path parsing only once the\n\t    // path is actually needed by anything.\n\t    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n\t};\n\n\t/**\n\t * @param {number}\n\t */\n\tGlyph.prototype.addUnicode = function(unicode) {\n\t    if (this.unicodes.length === 0) {\n\t        this.unicode = unicode;\n\t    }\n\n\t    this.unicodes.push(unicode);\n\t};\n\n\t/**\n\t * Calculate the minimum bounding box for this glyph.\n\t * @return {opentype.BoundingBox}\n\t */\n\tGlyph.prototype.getBoundingBox = function() {\n\t    return this.path.getBoundingBox();\n\t};\n\n\t/**\n\t * Convert the glyph to a Path we can draw on a drawing context.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {Object=} options - xScale, yScale to stretch the glyph.\n\t * @param  {opentype.Font} if hinting is to be used, the font\n\t * @return {opentype.Path}\n\t */\n\tGlyph.prototype.getPath = function(x, y, fontSize, options, font) {\n\t    x = x !== undefined ? x : 0;\n\t    y = y !== undefined ? y : 0;\n\t    fontSize = fontSize !== undefined ? fontSize : 72;\n\t    var commands;\n\t    var hPoints;\n\t    if (!options) { options = { }; }\n\t    var xScale = options.xScale;\n\t    var yScale = options.yScale;\n\n\t    if (options.hinting && font && font.hinting) {\n\t        // in case of hinting, the hinting engine takes care\n\t        // of scaling the points (not the path) before hinting.\n\t        hPoints = this.path && font.hinting.exec(this, fontSize);\n\t        // in case the hinting engine failed hPoints is undefined\n\t        // and thus reverts to plain rending\n\t    }\n\n\t    if (hPoints) {\n\t        // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency\n\t        commands = font.hinting.getCommands(hPoints);\n\t        x = Math.round(x);\n\t        y = Math.round(y);\n\t        // TODO in case of hinting xyScaling is not yet supported\n\t        xScale = yScale = 1;\n\t    } else {\n\t        commands = this.path.commands;\n\t        var scale = 1 / this.path.unitsPerEm * fontSize;\n\t        if (xScale === undefined) { xScale = scale; }\n\t        if (yScale === undefined) { yScale = scale; }\n\t    }\n\n\t    var p = new Path();\n\t    for (var i = 0; i < commands.length; i += 1) {\n\t        var cmd = commands[i];\n\t        if (cmd.type === 'M') {\n\t            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n\t        } else if (cmd.type === 'L') {\n\t            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n\t        } else if (cmd.type === 'Q') {\n\t            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n\t                               x + (cmd.x * xScale), y + (-cmd.y * yScale));\n\t        } else if (cmd.type === 'C') {\n\t            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n\t                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),\n\t                      x + (cmd.x * xScale), y + (-cmd.y * yScale));\n\t        } else if (cmd.type === 'Z') {\n\t            p.closePath();\n\t        }\n\t    }\n\n\t    return p;\n\t};\n\n\t/**\n\t * Split the glyph into contours.\n\t * This function is here for backwards compatibility, and to\n\t * provide raw access to the TrueType glyph outlines.\n\t * @return {Array}\n\t */\n\tGlyph.prototype.getContours = function() {\n\t    var this$1 = this;\n\n\t    if (this.points === undefined) {\n\t        return [];\n\t    }\n\n\t    var contours = [];\n\t    var currentContour = [];\n\t    for (var i = 0; i < this.points.length; i += 1) {\n\t        var pt = this$1.points[i];\n\t        currentContour.push(pt);\n\t        if (pt.lastPointOfContour) {\n\t            contours.push(currentContour);\n\t            currentContour = [];\n\t        }\n\t    }\n\n\t    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n\t    return contours;\n\t};\n\n\t/**\n\t * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n\t * @return {Object}\n\t */\n\tGlyph.prototype.getMetrics = function() {\n\t    var commands = this.path.commands;\n\t    var xCoords = [];\n\t    var yCoords = [];\n\t    for (var i = 0; i < commands.length; i += 1) {\n\t        var cmd = commands[i];\n\t        if (cmd.type !== 'Z') {\n\t            xCoords.push(cmd.x);\n\t            yCoords.push(cmd.y);\n\t        }\n\n\t        if (cmd.type === 'Q' || cmd.type === 'C') {\n\t            xCoords.push(cmd.x1);\n\t            yCoords.push(cmd.y1);\n\t        }\n\n\t        if (cmd.type === 'C') {\n\t            xCoords.push(cmd.x2);\n\t            yCoords.push(cmd.y2);\n\t        }\n\t    }\n\n\t    var metrics = {\n\t        xMin: Math.min.apply(null, xCoords),\n\t        yMin: Math.min.apply(null, yCoords),\n\t        xMax: Math.max.apply(null, xCoords),\n\t        yMax: Math.max.apply(null, yCoords),\n\t        leftSideBearing: this.leftSideBearing\n\t    };\n\n\t    if (!isFinite(metrics.xMin)) {\n\t        metrics.xMin = 0;\n\t    }\n\n\t    if (!isFinite(metrics.xMax)) {\n\t        metrics.xMax = this.advanceWidth;\n\t    }\n\n\t    if (!isFinite(metrics.yMin)) {\n\t        metrics.yMin = 0;\n\t    }\n\n\t    if (!isFinite(metrics.yMax)) {\n\t        metrics.yMax = 0;\n\t    }\n\n\t    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);\n\t    return metrics;\n\t};\n\n\t/**\n\t * Draw the glyph on the given context.\n\t * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {Object=} options - xScale, yScale to stretch the glyph.\n\t */\n\tGlyph.prototype.draw = function(ctx, x, y, fontSize, options) {\n\t    this.getPath(x, y, fontSize, options).draw(ctx);\n\t};\n\n\t/**\n\t * Draw the points of the glyph.\n\t * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n\t * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t */\n\tGlyph.prototype.drawPoints = function(ctx, x, y, fontSize) {\n\t    function drawCircles(l, x, y, scale) {\n\t        var PI_SQ = Math.PI * 2;\n\t        ctx.beginPath();\n\t        for (var j = 0; j < l.length; j += 1) {\n\t            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));\n\t            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);\n\t        }\n\n\t        ctx.closePath();\n\t        ctx.fill();\n\t    }\n\n\t    x = x !== undefined ? x : 0;\n\t    y = y !== undefined ? y : 0;\n\t    fontSize = fontSize !== undefined ? fontSize : 24;\n\t    var scale = 1 / this.path.unitsPerEm * fontSize;\n\n\t    var blueCircles = [];\n\t    var redCircles = [];\n\t    var path = this.path;\n\t    for (var i = 0; i < path.commands.length; i += 1) {\n\t        var cmd = path.commands[i];\n\t        if (cmd.x !== undefined) {\n\t            blueCircles.push({x: cmd.x, y: -cmd.y});\n\t        }\n\n\t        if (cmd.x1 !== undefined) {\n\t            redCircles.push({x: cmd.x1, y: -cmd.y1});\n\t        }\n\n\t        if (cmd.x2 !== undefined) {\n\t            redCircles.push({x: cmd.x2, y: -cmd.y2});\n\t        }\n\t    }\n\n\t    ctx.fillStyle = 'blue';\n\t    drawCircles(blueCircles, x, y, scale);\n\t    ctx.fillStyle = 'red';\n\t    drawCircles(redCircles, x, y, scale);\n\t};\n\n\t/**\n\t * Draw lines indicating important font measurements.\n\t * Black lines indicate the origin of the coordinate system (point 0,0).\n\t * Blue lines indicate the glyph bounding box.\n\t * Green line indicates the advance width of the glyph.\n\t * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t */\n\tGlyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {\n\t    var scale;\n\t    x = x !== undefined ? x : 0;\n\t    y = y !== undefined ? y : 0;\n\t    fontSize = fontSize !== undefined ? fontSize : 24;\n\t    scale = 1 / this.path.unitsPerEm * fontSize;\n\t    ctx.lineWidth = 1;\n\n\t    // Draw the origin\n\t    ctx.strokeStyle = 'black';\n\t    draw.line(ctx, x, -10000, x, 10000);\n\t    draw.line(ctx, -10000, y, 10000, y);\n\n\t    // This code is here due to memory optimization: by not using\n\t    // defaults in the constructor, we save a notable amount of memory.\n\t    var xMin = this.xMin || 0;\n\t    var yMin = this.yMin || 0;\n\t    var xMax = this.xMax || 0;\n\t    var yMax = this.yMax || 0;\n\t    var advanceWidth = this.advanceWidth || 0;\n\n\t    // Draw the glyph box\n\t    ctx.strokeStyle = 'blue';\n\t    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);\n\t    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);\n\t    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));\n\t    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));\n\n\t    // Draw the advance width\n\t    ctx.strokeStyle = 'green';\n\t    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);\n\t};\n\n\t// The GlyphSet object\n\n\t// Define a property on the glyph that depends on the path being loaded.\n\tfunction defineDependentProperty(glyph, externalName, internalName) {\n\t    Object.defineProperty(glyph, externalName, {\n\t        get: function() {\n\t            // Request the path property to make sure the path is loaded.\n\t            glyph.path; // jshint ignore:line\n\t            return glyph[internalName];\n\t        },\n\t        set: function(newValue) {\n\t            glyph[internalName] = newValue;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t}\n\n\t/**\n\t * A GlyphSet represents all glyphs available in the font, but modelled using\n\t * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n\t * necessary, to keep the memory footprint down.\n\t * @exports opentype.GlyphSet\n\t * @class\n\t * @param {opentype.Font}\n\t * @param {Array}\n\t */\n\tfunction GlyphSet(font, glyphs) {\n\t    var this$1 = this;\n\n\t    this.font = font;\n\t    this.glyphs = {};\n\t    if (Array.isArray(glyphs)) {\n\t        for (var i = 0; i < glyphs.length; i++) {\n\t            this$1.glyphs[i] = glyphs[i];\n\t        }\n\t    }\n\n\t    this.length = (glyphs && glyphs.length) || 0;\n\t}\n\n\t/**\n\t * @param  {number} index\n\t * @return {opentype.Glyph}\n\t */\n\tGlyphSet.prototype.get = function(index) {\n\t    if (typeof this.glyphs[index] === 'function') {\n\t        this.glyphs[index] = this.glyphs[index]();\n\t    }\n\n\t    return this.glyphs[index];\n\t};\n\n\t/**\n\t * @param  {number} index\n\t * @param  {Object}\n\t */\n\tGlyphSet.prototype.push = function(index, loader) {\n\t    this.glyphs[index] = loader;\n\t    this.length++;\n\t};\n\n\t/**\n\t * @alias opentype.glyphLoader\n\t * @param  {opentype.Font} font\n\t * @param  {number} index\n\t * @return {opentype.Glyph}\n\t */\n\tfunction glyphLoader(font, index) {\n\t    return new Glyph({index: index, font: font});\n\t}\n\n\t/**\n\t * Generate a stub glyph that can be filled with all metadata *except*\n\t * the \"points\" and \"path\" properties, which must be loaded only once\n\t * the glyph's path is actually requested for text shaping.\n\t * @alias opentype.ttfGlyphLoader\n\t * @param  {opentype.Font} font\n\t * @param  {number} index\n\t * @param  {Function} parseGlyph\n\t * @param  {Object} data\n\t * @param  {number} position\n\t * @param  {Function} buildPath\n\t * @return {opentype.Glyph}\n\t */\n\tfunction ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n\t    return function() {\n\t        var glyph = new Glyph({index: index, font: font});\n\n\t        glyph.path = function() {\n\t            parseGlyph(glyph, data, position);\n\t            var path = buildPath(font.glyphs, glyph);\n\t            path.unitsPerEm = font.unitsPerEm;\n\t            return path;\n\t        };\n\n\t        defineDependentProperty(glyph, 'xMin', '_xMin');\n\t        defineDependentProperty(glyph, 'xMax', '_xMax');\n\t        defineDependentProperty(glyph, 'yMin', '_yMin');\n\t        defineDependentProperty(glyph, 'yMax', '_yMax');\n\n\t        return glyph;\n\t    };\n\t}\n\t/**\n\t * @alias opentype.cffGlyphLoader\n\t * @param  {opentype.Font} font\n\t * @param  {number} index\n\t * @param  {Function} parseCFFCharstring\n\t * @param  {string} charstring\n\t * @return {opentype.Glyph}\n\t */\n\tfunction cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n\t    return function() {\n\t        var glyph = new Glyph({index: index, font: font});\n\n\t        glyph.path = function() {\n\t            var path = parseCFFCharstring(font, glyph, charstring);\n\t            path.unitsPerEm = font.unitsPerEm;\n\t            return path;\n\t        };\n\n\t        return glyph;\n\t    };\n\t}\n\n\tvar glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };\n\n\t// The `CFF` table contains the glyph outlines in PostScript format.\n\n\t// Custom equals function that can also check lists.\n\tfunction equals(a, b) {\n\t    if (a === b) {\n\t        return true;\n\t    } else if (Array.isArray(a) && Array.isArray(b)) {\n\t        if (a.length !== b.length) {\n\t            return false;\n\t        }\n\n\t        for (var i = 0; i < a.length; i += 1) {\n\t            if (!equals(a[i], b[i])) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    } else {\n\t        return false;\n\t    }\n\t}\n\n\t// Subroutines are encoded using the negative half of the number space.\n\t// See type 2 chapter 4.7 \"Subroutine operators\".\n\tfunction calcCFFSubroutineBias(subrs) {\n\t    var bias;\n\t    if (subrs.length < 1240) {\n\t        bias = 107;\n\t    } else if (subrs.length < 33900) {\n\t        bias = 1131;\n\t    } else {\n\t        bias = 32768;\n\t    }\n\n\t    return bias;\n\t}\n\n\t// Parse a `CFF` INDEX array.\n\t// An index array consists of a list of offsets, then a list of objects at those offsets.\n\tfunction parseCFFIndex(data, start, conversionFn) {\n\t    var offsets = [];\n\t    var objects = [];\n\t    var count = parse.getCard16(data, start);\n\t    var objectOffset;\n\t    var endOffset;\n\t    if (count !== 0) {\n\t        var offsetSize = parse.getByte(data, start + 2);\n\t        objectOffset = start + ((count + 1) * offsetSize) + 2;\n\t        var pos = start + 3;\n\t        for (var i = 0; i < count + 1; i += 1) {\n\t            offsets.push(parse.getOffset(data, pos, offsetSize));\n\t            pos += offsetSize;\n\t        }\n\n\t        // The total size of the index array is 4 header bytes + the value of the last offset.\n\t        endOffset = objectOffset + offsets[count];\n\t    } else {\n\t        endOffset = start + 2;\n\t    }\n\n\t    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {\n\t        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);\n\t        if (conversionFn) {\n\t            value = conversionFn(value);\n\t        }\n\n\t        objects.push(value);\n\t    }\n\n\t    return {objects: objects, startOffset: start, endOffset: endOffset};\n\t}\n\n\t// Parse a `CFF` DICT real value.\n\tfunction parseFloatOperand(parser) {\n\t    var s = '';\n\t    var eof = 15;\n\t    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\n\t    while (true) {\n\t        var b = parser.parseByte();\n\t        var n1 = b >> 4;\n\t        var n2 = b & 15;\n\n\t        if (n1 === eof) {\n\t            break;\n\t        }\n\n\t        s += lookup[n1];\n\n\t        if (n2 === eof) {\n\t            break;\n\t        }\n\n\t        s += lookup[n2];\n\t    }\n\n\t    return parseFloat(s);\n\t}\n\n\t// Parse a `CFF` DICT operand.\n\tfunction parseOperand(parser, b0) {\n\t    var b1;\n\t    var b2;\n\t    var b3;\n\t    var b4;\n\t    if (b0 === 28) {\n\t        b1 = parser.parseByte();\n\t        b2 = parser.parseByte();\n\t        return b1 << 8 | b2;\n\t    }\n\n\t    if (b0 === 29) {\n\t        b1 = parser.parseByte();\n\t        b2 = parser.parseByte();\n\t        b3 = parser.parseByte();\n\t        b4 = parser.parseByte();\n\t        return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n\t    }\n\n\t    if (b0 === 30) {\n\t        return parseFloatOperand(parser);\n\t    }\n\n\t    if (b0 >= 32 && b0 <= 246) {\n\t        return b0 - 139;\n\t    }\n\n\t    if (b0 >= 247 && b0 <= 250) {\n\t        b1 = parser.parseByte();\n\t        return (b0 - 247) * 256 + b1 + 108;\n\t    }\n\n\t    if (b0 >= 251 && b0 <= 254) {\n\t        b1 = parser.parseByte();\n\t        return -(b0 - 251) * 256 - b1 - 108;\n\t    }\n\n\t    throw new Error('Invalid b0 ' + b0);\n\t}\n\n\t// Convert the entries returned by `parseDict` to a proper dictionary.\n\t// If a value is a list of one, it is unpacked.\n\tfunction entriesToObject(entries) {\n\t    var o = {};\n\t    for (var i = 0; i < entries.length; i += 1) {\n\t        var key = entries[i][0];\n\t        var values = entries[i][1];\n\t        var value = (void 0);\n\t        if (values.length === 1) {\n\t            value = values[0];\n\t        } else {\n\t            value = values;\n\t        }\n\n\t        if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n\t            throw new Error('Object ' + o + ' already has key ' + key);\n\t        }\n\n\t        o[key] = value;\n\t    }\n\n\t    return o;\n\t}\n\n\t// Parse a `CFF` DICT object.\n\t// A dictionary contains key-value pairs in a compact tokenized format.\n\tfunction parseCFFDict(data, start, size) {\n\t    start = start !== undefined ? start : 0;\n\t    var parser = new parse.Parser(data, start);\n\t    var entries = [];\n\t    var operands = [];\n\t    size = size !== undefined ? size : data.length;\n\n\t    while (parser.relativeOffset < size) {\n\t        var op = parser.parseByte();\n\n\t        // The first byte for each dict item distinguishes between operator (key) and operand (value).\n\t        // Values <= 21 are operators.\n\t        if (op <= 21) {\n\t            // Two-byte operators have an initial escape byte of 12.\n\t            if (op === 12) {\n\t                op = 1200 + parser.parseByte();\n\t            }\n\n\t            entries.push([op, operands]);\n\t            operands = [];\n\t        } else {\n\t            // Since the operands (values) come before the operators (keys), we store all operands in a list\n\t            // until we encounter an operator.\n\t            operands.push(parseOperand(parser, op));\n\t        }\n\t    }\n\n\t    return entriesToObject(entries);\n\t}\n\n\t// Given a String Index (SID), return the value of the string.\n\t// Strings below index 392 are standard CFF strings and are not encoded in the font.\n\tfunction getCFFString(strings, index) {\n\t    if (index <= 390) {\n\t        index = cffStandardStrings[index];\n\t    } else {\n\t        index = strings[index - 391];\n\t    }\n\n\t    return index;\n\t}\n\n\t// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n\t// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\n\tfunction interpretDict(dict, meta, strings) {\n\t    var newDict = {};\n\t    var value;\n\n\t    // Because we also want to include missing values, we start out from the meta list\n\t    // and lookup values in the dict.\n\t    for (var i = 0; i < meta.length; i += 1) {\n\t        var m = meta[i];\n\n\t        if (Array.isArray(m.type)) {\n\t            var values = [];\n\t            values.length = m.type.length;\n\t            for (var j = 0; j < m.type.length; j++) {\n\t                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n\t                if (value === undefined) {\n\t                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;\n\t                }\n\t                if (m.type[j] === 'SID') {\n\t                    value = getCFFString(strings, value);\n\t                }\n\t                values[j] = value;\n\t            }\n\t            newDict[m.name] = values;\n\t        } else {\n\t            value = dict[m.op];\n\t            if (value === undefined) {\n\t                value = m.value !== undefined ? m.value : null;\n\t            }\n\n\t            if (m.type === 'SID') {\n\t                value = getCFFString(strings, value);\n\t            }\n\t            newDict[m.name] = value;\n\t        }\n\t    }\n\n\t    return newDict;\n\t}\n\n\t// Parse the CFF header.\n\tfunction parseCFFHeader(data, start) {\n\t    var header = {};\n\t    header.formatMajor = parse.getCard8(data, start);\n\t    header.formatMinor = parse.getCard8(data, start + 1);\n\t    header.size = parse.getCard8(data, start + 2);\n\t    header.offsetSize = parse.getCard8(data, start + 3);\n\t    header.startOffset = start;\n\t    header.endOffset = start + 4;\n\t    return header;\n\t}\n\n\tvar TOP_DICT_META = [\n\t    {name: 'version', op: 0, type: 'SID'},\n\t    {name: 'notice', op: 1, type: 'SID'},\n\t    {name: 'copyright', op: 1200, type: 'SID'},\n\t    {name: 'fullName', op: 2, type: 'SID'},\n\t    {name: 'familyName', op: 3, type: 'SID'},\n\t    {name: 'weight', op: 4, type: 'SID'},\n\t    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},\n\t    {name: 'italicAngle', op: 1202, type: 'number', value: 0},\n\t    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},\n\t    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},\n\t    {name: 'paintType', op: 1205, type: 'number', value: 0},\n\t    {name: 'charstringType', op: 1206, type: 'number', value: 2},\n\t    {\n\t        name: 'fontMatrix',\n\t        op: 1207,\n\t        type: ['real', 'real', 'real', 'real', 'real', 'real'],\n\t        value: [0.001, 0, 0, 0.001, 0, 0]\n\t    },\n\t    {name: 'uniqueId', op: 13, type: 'number'},\n\t    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},\n\t    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},\n\t    {name: 'xuid', op: 14, type: [], value: null},\n\t    {name: 'charset', op: 15, type: 'offset', value: 0},\n\t    {name: 'encoding', op: 16, type: 'offset', value: 0},\n\t    {name: 'charStrings', op: 17, type: 'offset', value: 0},\n\t    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},\n\t    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},\n\t    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},\n\t    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},\n\t    {name: 'cidFontType', op: 1233, type: 'number', value: 0},\n\t    {name: 'cidCount', op: 1234, type: 'number', value: 8720},\n\t    {name: 'uidBase', op: 1235, type: 'number'},\n\t    {name: 'fdArray', op: 1236, type: 'offset'},\n\t    {name: 'fdSelect', op: 1237, type: 'offset'},\n\t    {name: 'fontName', op: 1238, type: 'SID'}\n\t];\n\n\tvar PRIVATE_DICT_META = [\n\t    {name: 'subrs', op: 19, type: 'offset', value: 0},\n\t    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},\n\t    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}\n\t];\n\n\t// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n\t// The top dictionary contains the essential metadata for the font, together with the private dictionary.\n\tfunction parseCFFTopDict(data, strings) {\n\t    var dict = parseCFFDict(data, 0, data.byteLength);\n\t    return interpretDict(dict, TOP_DICT_META, strings);\n\t}\n\n\t// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\n\tfunction parseCFFPrivateDict(data, start, size, strings) {\n\t    var dict = parseCFFDict(data, start, size);\n\t    return interpretDict(dict, PRIVATE_DICT_META, strings);\n\t}\n\n\t// Returns a list of \"Top DICT\"s found using an INDEX list.\n\t// Used to read both the usual high-level Top DICTs and also the FDArray\n\t// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n\t// a Private DICT that is read and saved into the Top DICT.\n\t//\n\t// In addition to the expected/optional values as outlined in TOP_DICT_META\n\t// the following values might be saved into the Top DICT.\n\t//\n\t//    _subrs []        array of local CFF subroutines from Private DICT\n\t//    _subrsBias       bias value computed from number of subroutines\n\t//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n\t//    _defaultWidthX   default widths for CFF characters\n\t//    _nominalWidthX   bias added to width embedded within glyph description\n\t//\n\t//    _privateDict     saved copy of parsed Private DICT from Top DICT\n\tfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n\t    var topDictArray = [];\n\t    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n\t        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);\n\t        var topDict = parseCFFTopDict(topDictData, strings);\n\t        topDict._subrs = [];\n\t        topDict._subrsBias = 0;\n\t        var privateSize = topDict.private[0];\n\t        var privateOffset = topDict.private[1];\n\t        if (privateSize !== 0 && privateOffset !== 0) {\n\t            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);\n\t            topDict._defaultWidthX = privateDict.defaultWidthX;\n\t            topDict._nominalWidthX = privateDict.nominalWidthX;\n\t            if (privateDict.subrs !== 0) {\n\t                var subrOffset = privateOffset + privateDict.subrs;\n\t                var subrIndex = parseCFFIndex(data, subrOffset + start);\n\t                topDict._subrs = subrIndex.objects;\n\t                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n\t            }\n\t            topDict._privateDict = privateDict;\n\t        }\n\t        topDictArray.push(topDict);\n\t    }\n\t    return topDictArray;\n\t}\n\n\t// Parse the CFF charset table, which contains internal names for all the glyphs.\n\t// This function will return a list of glyph names.\n\t// See Adobe TN #5176 chapter 13, \"Charsets\".\n\tfunction parseCFFCharset(data, start, nGlyphs, strings) {\n\t    var sid;\n\t    var count;\n\t    var parser = new parse.Parser(data, start);\n\n\t    // The .notdef glyph is not included, so subtract 1.\n\t    nGlyphs -= 1;\n\t    var charset = ['.notdef'];\n\n\t    var format = parser.parseCard8();\n\t    if (format === 0) {\n\t        for (var i = 0; i < nGlyphs; i += 1) {\n\t            sid = parser.parseSID();\n\t            charset.push(getCFFString(strings, sid));\n\t        }\n\t    } else if (format === 1) {\n\t        while (charset.length <= nGlyphs) {\n\t            sid = parser.parseSID();\n\t            count = parser.parseCard8();\n\t            for (var i$1 = 0; i$1 <= count; i$1 += 1) {\n\t                charset.push(getCFFString(strings, sid));\n\t                sid += 1;\n\t            }\n\t        }\n\t    } else if (format === 2) {\n\t        while (charset.length <= nGlyphs) {\n\t            sid = parser.parseSID();\n\t            count = parser.parseCard16();\n\t            for (var i$2 = 0; i$2 <= count; i$2 += 1) {\n\t                charset.push(getCFFString(strings, sid));\n\t                sid += 1;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Unknown charset format ' + format);\n\t    }\n\n\t    return charset;\n\t}\n\n\t// Parse the CFF encoding data. Only one encoding can be specified per font.\n\t// See Adobe TN #5176 chapter 12, \"Encodings\".\n\tfunction parseCFFEncoding(data, start, charset) {\n\t    var code;\n\t    var enc = {};\n\t    var parser = new parse.Parser(data, start);\n\t    var format = parser.parseCard8();\n\t    if (format === 0) {\n\t        var nCodes = parser.parseCard8();\n\t        for (var i = 0; i < nCodes; i += 1) {\n\t            code = parser.parseCard8();\n\t            enc[code] = i;\n\t        }\n\t    } else if (format === 1) {\n\t        var nRanges = parser.parseCard8();\n\t        code = 1;\n\t        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {\n\t            var first = parser.parseCard8();\n\t            var nLeft = parser.parseCard8();\n\t            for (var j = first; j <= first + nLeft; j += 1) {\n\t                enc[j] = code;\n\t                code += 1;\n\t            }\n\t        }\n\t    } else {\n\t        throw new Error('Unknown encoding format ' + format);\n\t    }\n\n\t    return new CffEncoding(enc, charset);\n\t}\n\n\t// Take in charstring code and return a Glyph object.\n\t// The encoding is described in the Type 2 Charstring Format\n\t// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\n\tfunction parseCFFCharstring(font, glyph, code) {\n\t    var c1x;\n\t    var c1y;\n\t    var c2x;\n\t    var c2y;\n\t    var p = new Path();\n\t    var stack = [];\n\t    var nStems = 0;\n\t    var haveWidth = false;\n\t    var open = false;\n\t    var x = 0;\n\t    var y = 0;\n\t    var subrs;\n\t    var subrsBias;\n\t    var defaultWidthX;\n\t    var nominalWidthX;\n\t    if (font.isCIDFont) {\n\t        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n\t        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n\t        subrs = fdDict._subrs;\n\t        subrsBias = fdDict._subrsBias;\n\t        defaultWidthX = fdDict._defaultWidthX;\n\t        nominalWidthX = fdDict._nominalWidthX;\n\t    } else {\n\t        subrs = font.tables.cff.topDict._subrs;\n\t        subrsBias = font.tables.cff.topDict._subrsBias;\n\t        defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n\t        nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n\t    }\n\t    var width = defaultWidthX;\n\n\t    function newContour(x, y) {\n\t        if (open) {\n\t            p.closePath();\n\t        }\n\n\t        p.moveTo(x, y);\n\t        open = true;\n\t    }\n\n\t    function parseStems() {\n\t        var hasWidthArg;\n\n\t        // The number of stem operators on the stack is always even.\n\t        // If the value is uneven, that means a width is specified.\n\t        hasWidthArg = stack.length % 2 !== 0;\n\t        if (hasWidthArg && !haveWidth) {\n\t            width = stack.shift() + nominalWidthX;\n\t        }\n\n\t        nStems += stack.length >> 1;\n\t        stack.length = 0;\n\t        haveWidth = true;\n\t    }\n\n\t    function parse$$1(code) {\n\t        var b1;\n\t        var b2;\n\t        var b3;\n\t        var b4;\n\t        var codeIndex;\n\t        var subrCode;\n\t        var jpx;\n\t        var jpy;\n\t        var c3x;\n\t        var c3y;\n\t        var c4x;\n\t        var c4y;\n\n\t        var i = 0;\n\t        while (i < code.length) {\n\t            var v = code[i];\n\t            i += 1;\n\t            switch (v) {\n\t                case 1: // hstem\n\t                    parseStems();\n\t                    break;\n\t                case 3: // vstem\n\t                    parseStems();\n\t                    break;\n\t                case 4: // vmoveto\n\t                    if (stack.length > 1 && !haveWidth) {\n\t                        width = stack.shift() + nominalWidthX;\n\t                        haveWidth = true;\n\t                    }\n\n\t                    y += stack.pop();\n\t                    newContour(x, y);\n\t                    break;\n\t                case 5: // rlineto\n\t                    while (stack.length > 0) {\n\t                        x += stack.shift();\n\t                        y += stack.shift();\n\t                        p.lineTo(x, y);\n\t                    }\n\n\t                    break;\n\t                case 6: // hlineto\n\t                    while (stack.length > 0) {\n\t                        x += stack.shift();\n\t                        p.lineTo(x, y);\n\t                        if (stack.length === 0) {\n\t                            break;\n\t                        }\n\n\t                        y += stack.shift();\n\t                        p.lineTo(x, y);\n\t                    }\n\n\t                    break;\n\t                case 7: // vlineto\n\t                    while (stack.length > 0) {\n\t                        y += stack.shift();\n\t                        p.lineTo(x, y);\n\t                        if (stack.length === 0) {\n\t                            break;\n\t                        }\n\n\t                        x += stack.shift();\n\t                        p.lineTo(x, y);\n\t                    }\n\n\t                    break;\n\t                case 8: // rrcurveto\n\t                    while (stack.length > 0) {\n\t                        c1x = x + stack.shift();\n\t                        c1y = y + stack.shift();\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        x = c2x + stack.shift();\n\t                        y = c2y + stack.shift();\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    }\n\n\t                    break;\n\t                case 10: // callsubr\n\t                    codeIndex = stack.pop() + subrsBias;\n\t                    subrCode = subrs[codeIndex];\n\t                    if (subrCode) {\n\t                        parse$$1(subrCode);\n\t                    }\n\n\t                    break;\n\t                case 11: // return\n\t                    return;\n\t                case 12: // flex operators\n\t                    v = code[i];\n\t                    i += 1;\n\t                    switch (v) {\n\t                        case 35: // flex\n\t                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n\t                            c1x = x   + stack.shift();    // dx1\n\t                            c1y = y   + stack.shift();    // dy1\n\t                            c2x = c1x + stack.shift();    // dx2\n\t                            c2y = c1y + stack.shift();    // dy2\n\t                            jpx = c2x + stack.shift();    // dx3\n\t                            jpy = c2y + stack.shift();    // dy3\n\t                            c3x = jpx + stack.shift();    // dx4\n\t                            c3y = jpy + stack.shift();    // dy4\n\t                            c4x = c3x + stack.shift();    // dx5\n\t                            c4y = c3y + stack.shift();    // dy5\n\t                            x = c4x   + stack.shift();    // dx6\n\t                            y = c4y   + stack.shift();    // dy6\n\t                            stack.shift();                // flex depth\n\t                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n\t                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n\t                            break;\n\t                        case 34: // hflex\n\t                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n\t                            c1x = x   + stack.shift();    // dx1\n\t                            c1y = y;                      // dy1\n\t                            c2x = c1x + stack.shift();    // dx2\n\t                            c2y = c1y + stack.shift();    // dy2\n\t                            jpx = c2x + stack.shift();    // dx3\n\t                            jpy = c2y;                    // dy3\n\t                            c3x = jpx + stack.shift();    // dx4\n\t                            c3y = c2y;                    // dy4\n\t                            c4x = c3x + stack.shift();    // dx5\n\t                            c4y = y;                      // dy5\n\t                            x = c4x + stack.shift();      // dx6\n\t                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n\t                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n\t                            break;\n\t                        case 36: // hflex1\n\t                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n\t                            c1x = x   + stack.shift();    // dx1\n\t                            c1y = y   + stack.shift();    // dy1\n\t                            c2x = c1x + stack.shift();    // dx2\n\t                            c2y = c1y + stack.shift();    // dy2\n\t                            jpx = c2x + stack.shift();    // dx3\n\t                            jpy = c2y;                    // dy3\n\t                            c3x = jpx + stack.shift();    // dx4\n\t                            c3y = c2y;                    // dy4\n\t                            c4x = c3x + stack.shift();    // dx5\n\t                            c4y = c3y + stack.shift();    // dy5\n\t                            x = c4x + stack.shift();      // dx6\n\t                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n\t                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n\t                            break;\n\t                        case 37: // flex1\n\t                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n\t                            c1x = x   + stack.shift();    // dx1\n\t                            c1y = y   + stack.shift();    // dy1\n\t                            c2x = c1x + stack.shift();    // dx2\n\t                            c2y = c1y + stack.shift();    // dy2\n\t                            jpx = c2x + stack.shift();    // dx3\n\t                            jpy = c2y + stack.shift();    // dy3\n\t                            c3x = jpx + stack.shift();    // dx4\n\t                            c3y = jpy + stack.shift();    // dy4\n\t                            c4x = c3x + stack.shift();    // dx5\n\t                            c4y = c3y + stack.shift();    // dy5\n\t                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n\t                                x = c4x + stack.shift();\n\t                            } else {\n\t                                y = c4y + stack.shift();\n\t                            }\n\n\t                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n\t                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n\t                            break;\n\t                        default:\n\t                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);\n\t                            stack.length = 0;\n\t                    }\n\t                    break;\n\t                case 14: // endchar\n\t                    if (stack.length > 0 && !haveWidth) {\n\t                        width = stack.shift() + nominalWidthX;\n\t                        haveWidth = true;\n\t                    }\n\n\t                    if (open) {\n\t                        p.closePath();\n\t                        open = false;\n\t                    }\n\n\t                    break;\n\t                case 18: // hstemhm\n\t                    parseStems();\n\t                    break;\n\t                case 19: // hintmask\n\t                case 20: // cntrmask\n\t                    parseStems();\n\t                    i += (nStems + 7) >> 3;\n\t                    break;\n\t                case 21: // rmoveto\n\t                    if (stack.length > 2 && !haveWidth) {\n\t                        width = stack.shift() + nominalWidthX;\n\t                        haveWidth = true;\n\t                    }\n\n\t                    y += stack.pop();\n\t                    x += stack.pop();\n\t                    newContour(x, y);\n\t                    break;\n\t                case 22: // hmoveto\n\t                    if (stack.length > 1 && !haveWidth) {\n\t                        width = stack.shift() + nominalWidthX;\n\t                        haveWidth = true;\n\t                    }\n\n\t                    x += stack.pop();\n\t                    newContour(x, y);\n\t                    break;\n\t                case 23: // vstemhm\n\t                    parseStems();\n\t                    break;\n\t                case 24: // rcurveline\n\t                    while (stack.length > 2) {\n\t                        c1x = x + stack.shift();\n\t                        c1y = y + stack.shift();\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        x = c2x + stack.shift();\n\t                        y = c2y + stack.shift();\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    }\n\n\t                    x += stack.shift();\n\t                    y += stack.shift();\n\t                    p.lineTo(x, y);\n\t                    break;\n\t                case 25: // rlinecurve\n\t                    while (stack.length > 6) {\n\t                        x += stack.shift();\n\t                        y += stack.shift();\n\t                        p.lineTo(x, y);\n\t                    }\n\n\t                    c1x = x + stack.shift();\n\t                    c1y = y + stack.shift();\n\t                    c2x = c1x + stack.shift();\n\t                    c2y = c1y + stack.shift();\n\t                    x = c2x + stack.shift();\n\t                    y = c2y + stack.shift();\n\t                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    break;\n\t                case 26: // vvcurveto\n\t                    if (stack.length % 2) {\n\t                        x += stack.shift();\n\t                    }\n\n\t                    while (stack.length > 0) {\n\t                        c1x = x;\n\t                        c1y = y + stack.shift();\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        x = c2x;\n\t                        y = c2y + stack.shift();\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    }\n\n\t                    break;\n\t                case 27: // hhcurveto\n\t                    if (stack.length % 2) {\n\t                        y += stack.shift();\n\t                    }\n\n\t                    while (stack.length > 0) {\n\t                        c1x = x + stack.shift();\n\t                        c1y = y;\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        x = c2x + stack.shift();\n\t                        y = c2y;\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    }\n\n\t                    break;\n\t                case 28: // shortint\n\t                    b1 = code[i];\n\t                    b2 = code[i + 1];\n\t                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);\n\t                    i += 2;\n\t                    break;\n\t                case 29: // callgsubr\n\t                    codeIndex = stack.pop() + font.gsubrsBias;\n\t                    subrCode = font.gsubrs[codeIndex];\n\t                    if (subrCode) {\n\t                        parse$$1(subrCode);\n\t                    }\n\n\t                    break;\n\t                case 30: // vhcurveto\n\t                    while (stack.length > 0) {\n\t                        c1x = x;\n\t                        c1y = y + stack.shift();\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        x = c2x + stack.shift();\n\t                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                        if (stack.length === 0) {\n\t                            break;\n\t                        }\n\n\t                        c1x = x + stack.shift();\n\t                        c1y = y;\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        y = c2y + stack.shift();\n\t                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    }\n\n\t                    break;\n\t                case 31: // hvcurveto\n\t                    while (stack.length > 0) {\n\t                        c1x = x + stack.shift();\n\t                        c1y = y;\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        y = c2y + stack.shift();\n\t                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                        if (stack.length === 0) {\n\t                            break;\n\t                        }\n\n\t                        c1x = x;\n\t                        c1y = y + stack.shift();\n\t                        c2x = c1x + stack.shift();\n\t                        c2y = c1y + stack.shift();\n\t                        x = c2x + stack.shift();\n\t                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n\t                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n\t                    }\n\n\t                    break;\n\t                default:\n\t                    if (v < 32) {\n\t                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);\n\t                    } else if (v < 247) {\n\t                        stack.push(v - 139);\n\t                    } else if (v < 251) {\n\t                        b1 = code[i];\n\t                        i += 1;\n\t                        stack.push((v - 247) * 256 + b1 + 108);\n\t                    } else if (v < 255) {\n\t                        b1 = code[i];\n\t                        i += 1;\n\t                        stack.push(-(v - 251) * 256 - b1 - 108);\n\t                    } else {\n\t                        b1 = code[i];\n\t                        b2 = code[i + 1];\n\t                        b3 = code[i + 2];\n\t                        b4 = code[i + 3];\n\t                        i += 4;\n\t                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);\n\t                    }\n\t            }\n\t        }\n\t    }\n\n\t    parse$$1(code);\n\n\t    glyph.advanceWidth = width;\n\t    return p;\n\t}\n\n\tfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n\t    var fdSelect = [];\n\t    var fdIndex;\n\t    var parser = new parse.Parser(data, start);\n\t    var format = parser.parseCard8();\n\t    if (format === 0) {\n\t        // Simple list of nGlyphs elements\n\t        for (var iGid = 0; iGid < nGlyphs; iGid++) {\n\t            fdIndex = parser.parseCard8();\n\t            if (fdIndex >= fdArrayCount) {\n\t                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n\t            }\n\t            fdSelect.push(fdIndex);\n\t        }\n\t    } else if (format === 3) {\n\t        // Ranges\n\t        var nRanges = parser.parseCard16();\n\t        var first = parser.parseCard16();\n\t        if (first !== 0) {\n\t            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);\n\t        }\n\t        var next;\n\t        for (var iRange = 0; iRange < nRanges; iRange++) {\n\t            fdIndex = parser.parseCard8();\n\t            next = parser.parseCard16();\n\t            if (fdIndex >= fdArrayCount) {\n\t                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n\t            }\n\t            if (next > nGlyphs) {\n\t                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);\n\t            }\n\t            for (; first < next; first++) {\n\t                fdSelect.push(fdIndex);\n\t            }\n\t            first = next;\n\t        }\n\t        if (next !== nGlyphs) {\n\t            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);\n\t        }\n\t    } else {\n\t        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);\n\t    }\n\t    return fdSelect;\n\t}\n\n\t// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\n\tfunction parseCFFTable(data, start, font) {\n\t    font.tables.cff = {};\n\t    var header = parseCFFHeader(data, start);\n\t    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);\n\t    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n\t    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);\n\t    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n\t    font.gsubrs = globalSubrIndex.objects;\n\t    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n\n\t    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);\n\t    if (topDictArray.length !== 1) {\n\t        throw new Error('CFF table has too many fonts in \\'FontSet\\' - count of fonts NameIndex.length = ' + topDictArray.length);\n\t    }\n\n\t    var topDict = topDictArray[0];\n\t    font.tables.cff.topDict = topDict;\n\n\t    if (topDict._privateDict) {\n\t        font.defaultWidthX = topDict._privateDict.defaultWidthX;\n\t        font.nominalWidthX = topDict._privateDict.nominalWidthX;\n\t    }\n\n\t    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n\t        font.isCIDFont = true;\n\t    }\n\n\t    if (font.isCIDFont) {\n\t        var fdArrayOffset = topDict.fdArray;\n\t        var fdSelectOffset = topDict.fdSelect;\n\t        if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n\t            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');\n\t        }\n\t        fdArrayOffset += start;\n\t        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n\t        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);\n\t        topDict._fdArray = fdArray;\n\t        fdSelectOffset += start;\n\t        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);\n\t    }\n\n\t    var privateDictOffset = start + topDict.private[1];\n\t    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);\n\t    font.defaultWidthX = privateDict.defaultWidthX;\n\t    font.nominalWidthX = privateDict.nominalWidthX;\n\n\t    if (privateDict.subrs !== 0) {\n\t        var subrOffset = privateDictOffset + privateDict.subrs;\n\t        var subrIndex = parseCFFIndex(data, subrOffset);\n\t        font.subrs = subrIndex.objects;\n\t        font.subrsBias = calcCFFSubroutineBias(font.subrs);\n\t    } else {\n\t        font.subrs = [];\n\t        font.subrsBias = 0;\n\t    }\n\n\t    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n\t    var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n\t    font.nGlyphs = charStringsIndex.objects.length;\n\n\t    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n\t    if (topDict.encoding === 0) {\n\t        // Standard encoding\n\t        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n\t    } else if (topDict.encoding === 1) {\n\t        // Expert encoding\n\t        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n\t    } else {\n\t        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n\t    }\n\n\t    // Prefer the CMAP encoding to the CFF encoding.\n\t    font.encoding = font.encoding || font.cffEncoding;\n\n\t    font.glyphs = new glyphset.GlyphSet(font);\n\t    for (var i = 0; i < font.nGlyphs; i += 1) {\n\t        var charString = charStringsIndex.objects[i];\n\t        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));\n\t    }\n\t}\n\n\t// Convert a string to a String ID (SID).\n\t// The list of strings is modified in place.\n\tfunction encodeString(s, strings) {\n\t    var sid;\n\n\t    // Is the string in the CFF standard strings?\n\t    var i = cffStandardStrings.indexOf(s);\n\t    if (i >= 0) {\n\t        sid = i;\n\t    }\n\n\t    // Is the string already in the string index?\n\t    i = strings.indexOf(s);\n\t    if (i >= 0) {\n\t        sid = i + cffStandardStrings.length;\n\t    } else {\n\t        sid = cffStandardStrings.length + strings.length;\n\t        strings.push(s);\n\t    }\n\n\t    return sid;\n\t}\n\n\tfunction makeHeader() {\n\t    return new table.Record('Header', [\n\t        {name: 'major', type: 'Card8', value: 1},\n\t        {name: 'minor', type: 'Card8', value: 0},\n\t        {name: 'hdrSize', type: 'Card8', value: 4},\n\t        {name: 'major', type: 'Card8', value: 1}\n\t    ]);\n\t}\n\n\tfunction makeNameIndex(fontNames) {\n\t    var t = new table.Record('Name INDEX', [\n\t        {name: 'names', type: 'INDEX', value: []}\n\t    ]);\n\t    t.names = [];\n\t    for (var i = 0; i < fontNames.length; i += 1) {\n\t        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});\n\t    }\n\n\t    return t;\n\t}\n\n\t// Given a dictionary's metadata, create a DICT structure.\n\tfunction makeDict(meta, attrs, strings) {\n\t    var m = {};\n\t    for (var i = 0; i < meta.length; i += 1) {\n\t        var entry = meta[i];\n\t        var value = attrs[entry.name];\n\t        if (value !== undefined && !equals(value, entry.value)) {\n\t            if (entry.type === 'SID') {\n\t                value = encodeString(value, strings);\n\t            }\n\n\t            m[entry.op] = {name: entry.name, type: entry.type, value: value};\n\t        }\n\t    }\n\n\t    return m;\n\t}\n\n\t// The Top DICT houses the global font attributes.\n\tfunction makeTopDict(attrs, strings) {\n\t    var t = new table.Record('Top DICT', [\n\t        {name: 'dict', type: 'DICT', value: {}}\n\t    ]);\n\t    t.dict = makeDict(TOP_DICT_META, attrs, strings);\n\t    return t;\n\t}\n\n\tfunction makeTopDictIndex(topDict) {\n\t    var t = new table.Record('Top DICT INDEX', [\n\t        {name: 'topDicts', type: 'INDEX', value: []}\n\t    ]);\n\t    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];\n\t    return t;\n\t}\n\n\tfunction makeStringIndex(strings) {\n\t    var t = new table.Record('String INDEX', [\n\t        {name: 'strings', type: 'INDEX', value: []}\n\t    ]);\n\t    t.strings = [];\n\t    for (var i = 0; i < strings.length; i += 1) {\n\t        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});\n\t    }\n\n\t    return t;\n\t}\n\n\tfunction makeGlobalSubrIndex() {\n\t    // Currently we don't use subroutines.\n\t    return new table.Record('Global Subr INDEX', [\n\t        {name: 'subrs', type: 'INDEX', value: []}\n\t    ]);\n\t}\n\n\tfunction makeCharsets(glyphNames, strings) {\n\t    var t = new table.Record('Charsets', [\n\t        {name: 'format', type: 'Card8', value: 0}\n\t    ]);\n\t    for (var i = 0; i < glyphNames.length; i += 1) {\n\t        var glyphName = glyphNames[i];\n\t        var glyphSID = encodeString(glyphName, strings);\n\t        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});\n\t    }\n\n\t    return t;\n\t}\n\n\tfunction glyphToOps(glyph) {\n\t    var ops = [];\n\t    var path = glyph.path;\n\t    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});\n\t    var x = 0;\n\t    var y = 0;\n\t    for (var i = 0; i < path.commands.length; i += 1) {\n\t        var dx = (void 0);\n\t        var dy = (void 0);\n\t        var cmd = path.commands[i];\n\t        if (cmd.type === 'Q') {\n\t            // CFF only supports bzier curves, so convert the quad to a bzier.\n\t            var _13 = 1 / 3;\n\t            var _23 = 2 / 3;\n\n\t            // We're going to create a new command so we don't change the original path.\n\t            cmd = {\n\t                type: 'C',\n\t                x: cmd.x,\n\t                y: cmd.y,\n\t                x1: _13 * x + _23 * cmd.x1,\n\t                y1: _13 * y + _23 * cmd.y1,\n\t                x2: _13 * cmd.x + _23 * cmd.x1,\n\t                y2: _13 * cmd.y + _23 * cmd.y1\n\t            };\n\t        }\n\n\t        if (cmd.type === 'M') {\n\t            dx = Math.round(cmd.x - x);\n\t            dy = Math.round(cmd.y - y);\n\t            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n\t            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n\t            ops.push({name: 'rmoveto', type: 'OP', value: 21});\n\t            x = Math.round(cmd.x);\n\t            y = Math.round(cmd.y);\n\t        } else if (cmd.type === 'L') {\n\t            dx = Math.round(cmd.x - x);\n\t            dy = Math.round(cmd.y - y);\n\t            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n\t            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n\t            ops.push({name: 'rlineto', type: 'OP', value: 5});\n\t            x = Math.round(cmd.x);\n\t            y = Math.round(cmd.y);\n\t        } else if (cmd.type === 'C') {\n\t            var dx1 = Math.round(cmd.x1 - x);\n\t            var dy1 = Math.round(cmd.y1 - y);\n\t            var dx2 = Math.round(cmd.x2 - cmd.x1);\n\t            var dy2 = Math.round(cmd.y2 - cmd.y1);\n\t            dx = Math.round(cmd.x - cmd.x2);\n\t            dy = Math.round(cmd.y - cmd.y2);\n\t            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});\n\t            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});\n\t            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});\n\t            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});\n\t            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n\t            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n\t            ops.push({name: 'rrcurveto', type: 'OP', value: 8});\n\t            x = Math.round(cmd.x);\n\t            y = Math.round(cmd.y);\n\t        }\n\n\t        // Contours are closed automatically.\n\t    }\n\n\t    ops.push({name: 'endchar', type: 'OP', value: 14});\n\t    return ops;\n\t}\n\n\tfunction makeCharStringsIndex(glyphs) {\n\t    var t = new table.Record('CharStrings INDEX', [\n\t        {name: 'charStrings', type: 'INDEX', value: []}\n\t    ]);\n\n\t    for (var i = 0; i < glyphs.length; i += 1) {\n\t        var glyph = glyphs.get(i);\n\t        var ops = glyphToOps(glyph);\n\t        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});\n\t    }\n\n\t    return t;\n\t}\n\n\tfunction makePrivateDict(attrs, strings) {\n\t    var t = new table.Record('Private DICT', [\n\t        {name: 'dict', type: 'DICT', value: {}}\n\t    ]);\n\t    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);\n\t    return t;\n\t}\n\n\tfunction makeCFFTable(glyphs, options) {\n\t    var t = new table.Table('CFF ', [\n\t        {name: 'header', type: 'RECORD'},\n\t        {name: 'nameIndex', type: 'RECORD'},\n\t        {name: 'topDictIndex', type: 'RECORD'},\n\t        {name: 'stringIndex', type: 'RECORD'},\n\t        {name: 'globalSubrIndex', type: 'RECORD'},\n\t        {name: 'charsets', type: 'RECORD'},\n\t        {name: 'charStringsIndex', type: 'RECORD'},\n\t        {name: 'privateDict', type: 'RECORD'}\n\t    ]);\n\n\t    var fontScale = 1 / options.unitsPerEm;\n\t    // We use non-zero values for the offsets so that the DICT encodes them.\n\t    // This is important because the size of the Top DICT plays a role in offset calculation,\n\t    // and the size shouldn't change after we've written correct offsets.\n\t    var attrs = {\n\t        version: options.version,\n\t        fullName: options.fullName,\n\t        familyName: options.familyName,\n\t        weight: options.weightName,\n\t        fontBBox: options.fontBBox || [0, 0, 0, 0],\n\t        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n\t        charset: 999,\n\t        encoding: 0,\n\t        charStrings: 999,\n\t        private: [0, 999]\n\t    };\n\n\t    var privateAttrs = {};\n\n\t    var glyphNames = [];\n\t    var glyph;\n\n\t    // Skip first glyph (.notdef)\n\t    for (var i = 1; i < glyphs.length; i += 1) {\n\t        glyph = glyphs.get(i);\n\t        glyphNames.push(glyph.name);\n\t    }\n\n\t    var strings = [];\n\n\t    t.header = makeHeader();\n\t    t.nameIndex = makeNameIndex([options.postScriptName]);\n\t    var topDict = makeTopDict(attrs, strings);\n\t    t.topDictIndex = makeTopDictIndex(topDict);\n\t    t.globalSubrIndex = makeGlobalSubrIndex();\n\t    t.charsets = makeCharsets(glyphNames, strings);\n\t    t.charStringsIndex = makeCharStringsIndex(glyphs);\n\t    t.privateDict = makePrivateDict(privateAttrs, strings);\n\n\t    // Needs to come at the end, to encode all custom strings used in the font.\n\t    t.stringIndex = makeStringIndex(strings);\n\n\t    var startOffset = t.header.sizeOf() +\n\t        t.nameIndex.sizeOf() +\n\t        t.topDictIndex.sizeOf() +\n\t        t.stringIndex.sizeOf() +\n\t        t.globalSubrIndex.sizeOf();\n\t    attrs.charset = startOffset;\n\n\t    // We use the CFF standard encoding; proper encoding will be handled in cmap.\n\t    attrs.encoding = 0;\n\t    attrs.charStrings = attrs.charset + t.charsets.sizeOf();\n\t    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();\n\n\t    // Recreate the Top DICT INDEX with the correct offsets.\n\t    topDict = makeTopDict(attrs, strings);\n\t    t.topDictIndex = makeTopDictIndex(topDict);\n\n\t    return t;\n\t}\n\n\tvar cff = { parse: parseCFFTable, make: makeCFFTable };\n\n\t// The `head` table contains global information about the font.\n\n\t// Parse the header `head` table\n\tfunction parseHeadTable(data, start) {\n\t    var head = {};\n\t    var p = new parse.Parser(data, start);\n\t    head.version = p.parseVersion();\n\t    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n\t    head.checkSumAdjustment = p.parseULong();\n\t    head.magicNumber = p.parseULong();\n\t    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');\n\t    head.flags = p.parseUShort();\n\t    head.unitsPerEm = p.parseUShort();\n\t    head.created = p.parseLongDateTime();\n\t    head.modified = p.parseLongDateTime();\n\t    head.xMin = p.parseShort();\n\t    head.yMin = p.parseShort();\n\t    head.xMax = p.parseShort();\n\t    head.yMax = p.parseShort();\n\t    head.macStyle = p.parseUShort();\n\t    head.lowestRecPPEM = p.parseUShort();\n\t    head.fontDirectionHint = p.parseShort();\n\t    head.indexToLocFormat = p.parseShort();\n\t    head.glyphDataFormat = p.parseShort();\n\t    return head;\n\t}\n\n\tfunction makeHeadTable(options) {\n\t    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970\n\t    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;\n\t    var createdTimestamp = timestamp;\n\n\t    if (options.createdTimestamp) {\n\t        createdTimestamp = options.createdTimestamp + 2082844800;\n\t    }\n\n\t    return new table.Table('head', [\n\t        {name: 'version', type: 'FIXED', value: 0x00010000},\n\t        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},\n\t        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},\n\t        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},\n\t        {name: 'flags', type: 'USHORT', value: 0},\n\t        {name: 'unitsPerEm', type: 'USHORT', value: 1000},\n\t        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},\n\t        {name: 'modified', type: 'LONGDATETIME', value: timestamp},\n\t        {name: 'xMin', type: 'SHORT', value: 0},\n\t        {name: 'yMin', type: 'SHORT', value: 0},\n\t        {name: 'xMax', type: 'SHORT', value: 0},\n\t        {name: 'yMax', type: 'SHORT', value: 0},\n\t        {name: 'macStyle', type: 'USHORT', value: 0},\n\t        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},\n\t        {name: 'fontDirectionHint', type: 'SHORT', value: 2},\n\t        {name: 'indexToLocFormat', type: 'SHORT', value: 0},\n\t        {name: 'glyphDataFormat', type: 'SHORT', value: 0}\n\t    ], options);\n\t}\n\n\tvar head = { parse: parseHeadTable, make: makeHeadTable };\n\n\t// The `hhea` table contains information for horizontal layout.\n\n\t// Parse the horizontal header `hhea` table\n\tfunction parseHheaTable(data, start) {\n\t    var hhea = {};\n\t    var p = new parse.Parser(data, start);\n\t    hhea.version = p.parseVersion();\n\t    hhea.ascender = p.parseShort();\n\t    hhea.descender = p.parseShort();\n\t    hhea.lineGap = p.parseShort();\n\t    hhea.advanceWidthMax = p.parseUShort();\n\t    hhea.minLeftSideBearing = p.parseShort();\n\t    hhea.minRightSideBearing = p.parseShort();\n\t    hhea.xMaxExtent = p.parseShort();\n\t    hhea.caretSlopeRise = p.parseShort();\n\t    hhea.caretSlopeRun = p.parseShort();\n\t    hhea.caretOffset = p.parseShort();\n\t    p.relativeOffset += 8;\n\t    hhea.metricDataFormat = p.parseShort();\n\t    hhea.numberOfHMetrics = p.parseUShort();\n\t    return hhea;\n\t}\n\n\tfunction makeHheaTable(options) {\n\t    return new table.Table('hhea', [\n\t        {name: 'version', type: 'FIXED', value: 0x00010000},\n\t        {name: 'ascender', type: 'FWORD', value: 0},\n\t        {name: 'descender', type: 'FWORD', value: 0},\n\t        {name: 'lineGap', type: 'FWORD', value: 0},\n\t        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},\n\t        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},\n\t        {name: 'minRightSideBearing', type: 'FWORD', value: 0},\n\t        {name: 'xMaxExtent', type: 'FWORD', value: 0},\n\t        {name: 'caretSlopeRise', type: 'SHORT', value: 1},\n\t        {name: 'caretSlopeRun', type: 'SHORT', value: 0},\n\t        {name: 'caretOffset', type: 'SHORT', value: 0},\n\t        {name: 'reserved1', type: 'SHORT', value: 0},\n\t        {name: 'reserved2', type: 'SHORT', value: 0},\n\t        {name: 'reserved3', type: 'SHORT', value: 0},\n\t        {name: 'reserved4', type: 'SHORT', value: 0},\n\t        {name: 'metricDataFormat', type: 'SHORT', value: 0},\n\t        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}\n\t    ], options);\n\t}\n\n\tvar hhea = { parse: parseHheaTable, make: makeHheaTable };\n\n\t// The `hmtx` table contains the horizontal metrics for all glyphs.\n\n\t// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n\t// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\n\tfunction parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {\n\t    var advanceWidth;\n\t    var leftSideBearing;\n\t    var p = new parse.Parser(data, start);\n\t    for (var i = 0; i < numGlyphs; i += 1) {\n\t        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n\t        if (i < numMetrics) {\n\t            advanceWidth = p.parseUShort();\n\t            leftSideBearing = p.parseShort();\n\t        }\n\n\t        var glyph = glyphs.get(i);\n\t        glyph.advanceWidth = advanceWidth;\n\t        glyph.leftSideBearing = leftSideBearing;\n\t    }\n\t}\n\n\tfunction makeHmtxTable(glyphs) {\n\t    var t = new table.Table('hmtx', []);\n\t    for (var i = 0; i < glyphs.length; i += 1) {\n\t        var glyph = glyphs.get(i);\n\t        var advanceWidth = glyph.advanceWidth || 0;\n\t        var leftSideBearing = glyph.leftSideBearing || 0;\n\t        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});\n\t        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});\n\t    }\n\n\t    return t;\n\t}\n\n\tvar hmtx = { parse: parseHmtxTable, make: makeHmtxTable };\n\n\t// The `ltag` table stores IETF BCP-47 language tags. It allows supporting\n\n\tfunction makeLtagTable(tags) {\n\t    var result = new table.Table('ltag', [\n\t        {name: 'version', type: 'ULONG', value: 1},\n\t        {name: 'flags', type: 'ULONG', value: 0},\n\t        {name: 'numTags', type: 'ULONG', value: tags.length}\n\t    ]);\n\n\t    var stringPool = '';\n\t    var stringPoolOffset = 12 + tags.length * 4;\n\t    for (var i = 0; i < tags.length; ++i) {\n\t        var pos = stringPool.indexOf(tags[i]);\n\t        if (pos < 0) {\n\t            pos = stringPool.length;\n\t            stringPool += tags[i];\n\t        }\n\n\t        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});\n\t        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});\n\t    }\n\n\t    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n\t    return result;\n\t}\n\n\tfunction parseLtagTable(data, start) {\n\t    var p = new parse.Parser(data, start);\n\t    var tableVersion = p.parseULong();\n\t    check.argument(tableVersion === 1, 'Unsupported ltag table version.');\n\t    // The 'ltag' specification does not define any flags; skip the field.\n\t    p.skip('uLong', 1);\n\t    var numTags = p.parseULong();\n\n\t    var tags = [];\n\t    for (var i = 0; i < numTags; i++) {\n\t        var tag = '';\n\t        var offset = start + p.parseUShort();\n\t        var length = p.parseUShort();\n\t        for (var j = offset; j < offset + length; ++j) {\n\t            tag += String.fromCharCode(data.getInt8(j));\n\t        }\n\n\t        tags.push(tag);\n\t    }\n\n\t    return tags;\n\t}\n\n\tvar ltag = { make: makeLtagTable, parse: parseLtagTable };\n\n\t// The `maxp` table establishes the memory requirements for the font.\n\n\t// Parse the maximum profile `maxp` table.\n\tfunction parseMaxpTable(data, start) {\n\t    var maxp = {};\n\t    var p = new parse.Parser(data, start);\n\t    maxp.version = p.parseVersion();\n\t    maxp.numGlyphs = p.parseUShort();\n\t    if (maxp.version === 1.0) {\n\t        maxp.maxPoints = p.parseUShort();\n\t        maxp.maxContours = p.parseUShort();\n\t        maxp.maxCompositePoints = p.parseUShort();\n\t        maxp.maxCompositeContours = p.parseUShort();\n\t        maxp.maxZones = p.parseUShort();\n\t        maxp.maxTwilightPoints = p.parseUShort();\n\t        maxp.maxStorage = p.parseUShort();\n\t        maxp.maxFunctionDefs = p.parseUShort();\n\t        maxp.maxInstructionDefs = p.parseUShort();\n\t        maxp.maxStackElements = p.parseUShort();\n\t        maxp.maxSizeOfInstructions = p.parseUShort();\n\t        maxp.maxComponentElements = p.parseUShort();\n\t        maxp.maxComponentDepth = p.parseUShort();\n\t    }\n\n\t    return maxp;\n\t}\n\n\tfunction makeMaxpTable(numGlyphs) {\n\t    return new table.Table('maxp', [\n\t        {name: 'version', type: 'FIXED', value: 0x00005000},\n\t        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}\n\t    ]);\n\t}\n\n\tvar maxp = { parse: parseMaxpTable, make: makeMaxpTable };\n\n\t// The `name` naming table.\n\n\t// NameIDs for the name table.\n\tvar nameTableNames = [\n\t    'copyright',              // 0\n\t    'fontFamily',             // 1\n\t    'fontSubfamily',          // 2\n\t    'uniqueID',               // 3\n\t    'fullName',               // 4\n\t    'version',                // 5\n\t    'postScriptName',         // 6\n\t    'trademark',              // 7\n\t    'manufacturer',           // 8\n\t    'designer',               // 9\n\t    'description',            // 10\n\t    'manufacturerURL',        // 11\n\t    'designerURL',            // 12\n\t    'license',                // 13\n\t    'licenseURL',             // 14\n\t    'reserved',               // 15\n\t    'preferredFamily',        // 16\n\t    'preferredSubfamily',     // 17\n\t    'compatibleFullName',     // 18\n\t    'sampleText',             // 19\n\t    'postScriptFindFontName', // 20\n\t    'wwsFamily',              // 21\n\t    'wwsSubfamily'            // 22\n\t];\n\n\tvar macLanguages = {\n\t    0: 'en',\n\t    1: 'fr',\n\t    2: 'de',\n\t    3: 'it',\n\t    4: 'nl',\n\t    5: 'sv',\n\t    6: 'es',\n\t    7: 'da',\n\t    8: 'pt',\n\t    9: 'no',\n\t    10: 'he',\n\t    11: 'ja',\n\t    12: 'ar',\n\t    13: 'fi',\n\t    14: 'el',\n\t    15: 'is',\n\t    16: 'mt',\n\t    17: 'tr',\n\t    18: 'hr',\n\t    19: 'zh-Hant',\n\t    20: 'ur',\n\t    21: 'hi',\n\t    22: 'th',\n\t    23: 'ko',\n\t    24: 'lt',\n\t    25: 'pl',\n\t    26: 'hu',\n\t    27: 'es',\n\t    28: 'lv',\n\t    29: 'se',\n\t    30: 'fo',\n\t    31: 'fa',\n\t    32: 'ru',\n\t    33: 'zh',\n\t    34: 'nl-BE',\n\t    35: 'ga',\n\t    36: 'sq',\n\t    37: 'ro',\n\t    38: 'cz',\n\t    39: 'sk',\n\t    40: 'si',\n\t    41: 'yi',\n\t    42: 'sr',\n\t    43: 'mk',\n\t    44: 'bg',\n\t    45: 'uk',\n\t    46: 'be',\n\t    47: 'uz',\n\t    48: 'kk',\n\t    49: 'az-Cyrl',\n\t    50: 'az-Arab',\n\t    51: 'hy',\n\t    52: 'ka',\n\t    53: 'mo',\n\t    54: 'ky',\n\t    55: 'tg',\n\t    56: 'tk',\n\t    57: 'mn-CN',\n\t    58: 'mn',\n\t    59: 'ps',\n\t    60: 'ks',\n\t    61: 'ku',\n\t    62: 'sd',\n\t    63: 'bo',\n\t    64: 'ne',\n\t    65: 'sa',\n\t    66: 'mr',\n\t    67: 'bn',\n\t    68: 'as',\n\t    69: 'gu',\n\t    70: 'pa',\n\t    71: 'or',\n\t    72: 'ml',\n\t    73: 'kn',\n\t    74: 'ta',\n\t    75: 'te',\n\t    76: 'si',\n\t    77: 'my',\n\t    78: 'km',\n\t    79: 'lo',\n\t    80: 'vi',\n\t    81: 'id',\n\t    82: 'tl',\n\t    83: 'ms',\n\t    84: 'ms-Arab',\n\t    85: 'am',\n\t    86: 'ti',\n\t    87: 'om',\n\t    88: 'so',\n\t    89: 'sw',\n\t    90: 'rw',\n\t    91: 'rn',\n\t    92: 'ny',\n\t    93: 'mg',\n\t    94: 'eo',\n\t    128: 'cy',\n\t    129: 'eu',\n\t    130: 'ca',\n\t    131: 'la',\n\t    132: 'qu',\n\t    133: 'gn',\n\t    134: 'ay',\n\t    135: 'tt',\n\t    136: 'ug',\n\t    137: 'dz',\n\t    138: 'jv',\n\t    139: 'su',\n\t    140: 'gl',\n\t    141: 'af',\n\t    142: 'br',\n\t    143: 'iu',\n\t    144: 'gd',\n\t    145: 'gv',\n\t    146: 'ga',\n\t    147: 'to',\n\t    148: 'el-polyton',\n\t    149: 'kl',\n\t    150: 'az',\n\t    151: 'nn'\n\t};\n\n\t// MacOS language ID  MacOS script ID\n\t//\n\t// Note that the script ID is not sufficient to determine what encoding\n\t// to use in TrueType files. For some languages, MacOS used a modification\n\t// of a mainstream script. For example, an Icelandic name would be stored\n\t// with smRoman in the TrueType naming table, but the actual encoding\n\t// is a special Icelandic version of the normal Macintosh Roman encoding.\n\t// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal\n\t// Syllables but MacOS had run out of available script codes, so this was\n\t// done as a (pretty radical) \"modification\" of Ethiopic.\n\t//\n\t// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n\tvar macLanguageToScript = {\n\t    0: 0,  // langEnglish  smRoman\n\t    1: 0,  // langFrench  smRoman\n\t    2: 0,  // langGerman  smRoman\n\t    3: 0,  // langItalian  smRoman\n\t    4: 0,  // langDutch  smRoman\n\t    5: 0,  // langSwedish  smRoman\n\t    6: 0,  // langSpanish  smRoman\n\t    7: 0,  // langDanish  smRoman\n\t    8: 0,  // langPortuguese  smRoman\n\t    9: 0,  // langNorwegian  smRoman\n\t    10: 5,  // langHebrew  smHebrew\n\t    11: 1,  // langJapanese  smJapanese\n\t    12: 4,  // langArabic  smArabic\n\t    13: 0,  // langFinnish  smRoman\n\t    14: 6,  // langGreek  smGreek\n\t    15: 0,  // langIcelandic  smRoman (modified)\n\t    16: 0,  // langMaltese  smRoman\n\t    17: 0,  // langTurkish  smRoman (modified)\n\t    18: 0,  // langCroatian  smRoman (modified)\n\t    19: 2,  // langTradChinese  smTradChinese\n\t    20: 4,  // langUrdu  smArabic\n\t    21: 9,  // langHindi  smDevanagari\n\t    22: 21,  // langThai  smThai\n\t    23: 3,  // langKorean  smKorean\n\t    24: 29,  // langLithuanian  smCentralEuroRoman\n\t    25: 29,  // langPolish  smCentralEuroRoman\n\t    26: 29,  // langHungarian  smCentralEuroRoman\n\t    27: 29,  // langEstonian  smCentralEuroRoman\n\t    28: 29,  // langLatvian  smCentralEuroRoman\n\t    29: 0,  // langSami  smRoman\n\t    30: 0,  // langFaroese  smRoman (modified)\n\t    31: 4,  // langFarsi  smArabic (modified)\n\t    32: 7,  // langRussian  smCyrillic\n\t    33: 25,  // langSimpChinese  smSimpChinese\n\t    34: 0,  // langFlemish  smRoman\n\t    35: 0,  // langIrishGaelic  smRoman (modified)\n\t    36: 0,  // langAlbanian  smRoman\n\t    37: 0,  // langRomanian  smRoman (modified)\n\t    38: 29,  // langCzech  smCentralEuroRoman\n\t    39: 29,  // langSlovak  smCentralEuroRoman\n\t    40: 0,  // langSlovenian  smRoman (modified)\n\t    41: 5,  // langYiddish  smHebrew\n\t    42: 7,  // langSerbian  smCyrillic\n\t    43: 7,  // langMacedonian  smCyrillic\n\t    44: 7,  // langBulgarian  smCyrillic\n\t    45: 7,  // langUkrainian  smCyrillic (modified)\n\t    46: 7,  // langByelorussian  smCyrillic\n\t    47: 7,  // langUzbek  smCyrillic\n\t    48: 7,  // langKazakh  smCyrillic\n\t    49: 7,  // langAzerbaijani  smCyrillic\n\t    50: 4,  // langAzerbaijanAr  smArabic\n\t    51: 24,  // langArmenian  smArmenian\n\t    52: 23,  // langGeorgian  smGeorgian\n\t    53: 7,  // langMoldavian  smCyrillic\n\t    54: 7,  // langKirghiz  smCyrillic\n\t    55: 7,  // langTajiki  smCyrillic\n\t    56: 7,  // langTurkmen  smCyrillic\n\t    57: 27,  // langMongolian  smMongolian\n\t    58: 7,  // langMongolianCyr  smCyrillic\n\t    59: 4,  // langPashto  smArabic\n\t    60: 4,  // langKurdish  smArabic\n\t    61: 4,  // langKashmiri  smArabic\n\t    62: 4,  // langSindhi  smArabic\n\t    63: 26,  // langTibetan  smTibetan\n\t    64: 9,  // langNepali  smDevanagari\n\t    65: 9,  // langSanskrit  smDevanagari\n\t    66: 9,  // langMarathi  smDevanagari\n\t    67: 13,  // langBengali  smBengali\n\t    68: 13,  // langAssamese  smBengali\n\t    69: 11,  // langGujarati  smGujarati\n\t    70: 10,  // langPunjabi  smGurmukhi\n\t    71: 12,  // langOriya  smOriya\n\t    72: 17,  // langMalayalam  smMalayalam\n\t    73: 16,  // langKannada  smKannada\n\t    74: 14,  // langTamil  smTamil\n\t    75: 15,  // langTelugu  smTelugu\n\t    76: 18,  // langSinhalese  smSinhalese\n\t    77: 19,  // langBurmese  smBurmese\n\t    78: 20,  // langKhmer  smKhmer\n\t    79: 22,  // langLao  smLao\n\t    80: 30,  // langVietnamese  smVietnamese\n\t    81: 0,  // langIndonesian  smRoman\n\t    82: 0,  // langTagalog  smRoman\n\t    83: 0,  // langMalayRoman  smRoman\n\t    84: 4,  // langMalayArabic  smArabic\n\t    85: 28,  // langAmharic  smEthiopic\n\t    86: 28,  // langTigrinya  smEthiopic\n\t    87: 28,  // langOromo  smEthiopic\n\t    88: 0,  // langSomali  smRoman\n\t    89: 0,  // langSwahili  smRoman\n\t    90: 0,  // langKinyarwanda  smRoman\n\t    91: 0,  // langRundi  smRoman\n\t    92: 0,  // langNyanja  smRoman\n\t    93: 0,  // langMalagasy  smRoman\n\t    94: 0,  // langEsperanto  smRoman\n\t    128: 0,  // langWelsh  smRoman (modified)\n\t    129: 0,  // langBasque  smRoman\n\t    130: 0,  // langCatalan  smRoman\n\t    131: 0,  // langLatin  smRoman\n\t    132: 0,  // langQuechua  smRoman\n\t    133: 0,  // langGuarani  smRoman\n\t    134: 0,  // langAymara  smRoman\n\t    135: 7,  // langTatar  smCyrillic\n\t    136: 4,  // langUighur  smArabic\n\t    137: 26,  // langDzongkha  smTibetan\n\t    138: 0,  // langJavaneseRom  smRoman\n\t    139: 0,  // langSundaneseRom  smRoman\n\t    140: 0,  // langGalician  smRoman\n\t    141: 0,  // langAfrikaans  smRoman\n\t    142: 0,  // langBreton  smRoman (modified)\n\t    143: 28,  // langInuktitut  smEthiopic (modified)\n\t    144: 0,  // langScottishGaelic  smRoman (modified)\n\t    145: 0,  // langManxGaelic  smRoman (modified)\n\t    146: 0,  // langIrishGaelicScript  smRoman (modified)\n\t    147: 0,  // langTongan  smRoman\n\t    148: 6,  // langGreekAncient  smRoman\n\t    149: 0,  // langGreenlandic  smRoman\n\t    150: 0,  // langAzerbaijanRoman  smRoman\n\t    151: 0   // langNynorsk  smRoman\n\t};\n\n\t// While Microsoft indicates a region/country for all its language\n\t// IDs, we omit the region code if it's equal to the \"most likely\n\t// region subtag\" according to Unicode CLDR. For scripts, we omit\n\t// the subtag if it is equal to the Suppress-Script entry in the\n\t// IANA language subtag registry for IETF BCP 47.\n\t//\n\t// For example, Microsoft states that its language code 0x041A is\n\t// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'\n\t// and not 'hr-HR' because Croatia is the default country for Croatian,\n\t// according to Unicode CLDR. As another example, Microsoft states\n\t// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform\n\t// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script\n\t// for the Croatian language, according to IANA.\n\t//\n\t// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html\n\t// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\n\tvar windowsLanguages = {\n\t    0x0436: 'af',\n\t    0x041C: 'sq',\n\t    0x0484: 'gsw',\n\t    0x045E: 'am',\n\t    0x1401: 'ar-DZ',\n\t    0x3C01: 'ar-BH',\n\t    0x0C01: 'ar',\n\t    0x0801: 'ar-IQ',\n\t    0x2C01: 'ar-JO',\n\t    0x3401: 'ar-KW',\n\t    0x3001: 'ar-LB',\n\t    0x1001: 'ar-LY',\n\t    0x1801: 'ary',\n\t    0x2001: 'ar-OM',\n\t    0x4001: 'ar-QA',\n\t    0x0401: 'ar-SA',\n\t    0x2801: 'ar-SY',\n\t    0x1C01: 'aeb',\n\t    0x3801: 'ar-AE',\n\t    0x2401: 'ar-YE',\n\t    0x042B: 'hy',\n\t    0x044D: 'as',\n\t    0x082C: 'az-Cyrl',\n\t    0x042C: 'az',\n\t    0x046D: 'ba',\n\t    0x042D: 'eu',\n\t    0x0423: 'be',\n\t    0x0845: 'bn',\n\t    0x0445: 'bn-IN',\n\t    0x201A: 'bs-Cyrl',\n\t    0x141A: 'bs',\n\t    0x047E: 'br',\n\t    0x0402: 'bg',\n\t    0x0403: 'ca',\n\t    0x0C04: 'zh-HK',\n\t    0x1404: 'zh-MO',\n\t    0x0804: 'zh',\n\t    0x1004: 'zh-SG',\n\t    0x0404: 'zh-TW',\n\t    0x0483: 'co',\n\t    0x041A: 'hr',\n\t    0x101A: 'hr-BA',\n\t    0x0405: 'cs',\n\t    0x0406: 'da',\n\t    0x048C: 'prs',\n\t    0x0465: 'dv',\n\t    0x0813: 'nl-BE',\n\t    0x0413: 'nl',\n\t    0x0C09: 'en-AU',\n\t    0x2809: 'en-BZ',\n\t    0x1009: 'en-CA',\n\t    0x2409: 'en-029',\n\t    0x4009: 'en-IN',\n\t    0x1809: 'en-IE',\n\t    0x2009: 'en-JM',\n\t    0x4409: 'en-MY',\n\t    0x1409: 'en-NZ',\n\t    0x3409: 'en-PH',\n\t    0x4809: 'en-SG',\n\t    0x1C09: 'en-ZA',\n\t    0x2C09: 'en-TT',\n\t    0x0809: 'en-GB',\n\t    0x0409: 'en',\n\t    0x3009: 'en-ZW',\n\t    0x0425: 'et',\n\t    0x0438: 'fo',\n\t    0x0464: 'fil',\n\t    0x040B: 'fi',\n\t    0x080C: 'fr-BE',\n\t    0x0C0C: 'fr-CA',\n\t    0x040C: 'fr',\n\t    0x140C: 'fr-LU',\n\t    0x180C: 'fr-MC',\n\t    0x100C: 'fr-CH',\n\t    0x0462: 'fy',\n\t    0x0456: 'gl',\n\t    0x0437: 'ka',\n\t    0x0C07: 'de-AT',\n\t    0x0407: 'de',\n\t    0x1407: 'de-LI',\n\t    0x1007: 'de-LU',\n\t    0x0807: 'de-CH',\n\t    0x0408: 'el',\n\t    0x046F: 'kl',\n\t    0x0447: 'gu',\n\t    0x0468: 'ha',\n\t    0x040D: 'he',\n\t    0x0439: 'hi',\n\t    0x040E: 'hu',\n\t    0x040F: 'is',\n\t    0x0470: 'ig',\n\t    0x0421: 'id',\n\t    0x045D: 'iu',\n\t    0x085D: 'iu-Latn',\n\t    0x083C: 'ga',\n\t    0x0434: 'xh',\n\t    0x0435: 'zu',\n\t    0x0410: 'it',\n\t    0x0810: 'it-CH',\n\t    0x0411: 'ja',\n\t    0x044B: 'kn',\n\t    0x043F: 'kk',\n\t    0x0453: 'km',\n\t    0x0486: 'quc',\n\t    0x0487: 'rw',\n\t    0x0441: 'sw',\n\t    0x0457: 'kok',\n\t    0x0412: 'ko',\n\t    0x0440: 'ky',\n\t    0x0454: 'lo',\n\t    0x0426: 'lv',\n\t    0x0427: 'lt',\n\t    0x082E: 'dsb',\n\t    0x046E: 'lb',\n\t    0x042F: 'mk',\n\t    0x083E: 'ms-BN',\n\t    0x043E: 'ms',\n\t    0x044C: 'ml',\n\t    0x043A: 'mt',\n\t    0x0481: 'mi',\n\t    0x047A: 'arn',\n\t    0x044E: 'mr',\n\t    0x047C: 'moh',\n\t    0x0450: 'mn',\n\t    0x0850: 'mn-CN',\n\t    0x0461: 'ne',\n\t    0x0414: 'nb',\n\t    0x0814: 'nn',\n\t    0x0482: 'oc',\n\t    0x0448: 'or',\n\t    0x0463: 'ps',\n\t    0x0415: 'pl',\n\t    0x0416: 'pt',\n\t    0x0816: 'pt-PT',\n\t    0x0446: 'pa',\n\t    0x046B: 'qu-BO',\n\t    0x086B: 'qu-EC',\n\t    0x0C6B: 'qu',\n\t    0x0418: 'ro',\n\t    0x0417: 'rm',\n\t    0x0419: 'ru',\n\t    0x243B: 'smn',\n\t    0x103B: 'smj-NO',\n\t    0x143B: 'smj',\n\t    0x0C3B: 'se-FI',\n\t    0x043B: 'se',\n\t    0x083B: 'se-SE',\n\t    0x203B: 'sms',\n\t    0x183B: 'sma-NO',\n\t    0x1C3B: 'sms',\n\t    0x044F: 'sa',\n\t    0x1C1A: 'sr-Cyrl-BA',\n\t    0x0C1A: 'sr',\n\t    0x181A: 'sr-Latn-BA',\n\t    0x081A: 'sr-Latn',\n\t    0x046C: 'nso',\n\t    0x0432: 'tn',\n\t    0x045B: 'si',\n\t    0x041B: 'sk',\n\t    0x0424: 'sl',\n\t    0x2C0A: 'es-AR',\n\t    0x400A: 'es-BO',\n\t    0x340A: 'es-CL',\n\t    0x240A: 'es-CO',\n\t    0x140A: 'es-CR',\n\t    0x1C0A: 'es-DO',\n\t    0x300A: 'es-EC',\n\t    0x440A: 'es-SV',\n\t    0x100A: 'es-GT',\n\t    0x480A: 'es-HN',\n\t    0x080A: 'es-MX',\n\t    0x4C0A: 'es-NI',\n\t    0x180A: 'es-PA',\n\t    0x3C0A: 'es-PY',\n\t    0x280A: 'es-PE',\n\t    0x500A: 'es-PR',\n\n\t    // Microsoft has defined two different language codes for\n\t    // Spanish with modern sorting and Spanish with traditional\n\t    // sorting. This makes sense for collation APIs, and it would be\n\t    // possible to express this in BCP 47 language tags via Unicode\n\t    // extensions (eg., es-u-co-trad is Spanish with traditional\n\t    // sorting). However, for storing names in fonts, the distinction\n\t    // does not make sense, so we give es in both cases.\n\t    0x0C0A: 'es',\n\t    0x040A: 'es',\n\n\t    0x540A: 'es-US',\n\t    0x380A: 'es-UY',\n\t    0x200A: 'es-VE',\n\t    0x081D: 'sv-FI',\n\t    0x041D: 'sv',\n\t    0x045A: 'syr',\n\t    0x0428: 'tg',\n\t    0x085F: 'tzm',\n\t    0x0449: 'ta',\n\t    0x0444: 'tt',\n\t    0x044A: 'te',\n\t    0x041E: 'th',\n\t    0x0451: 'bo',\n\t    0x041F: 'tr',\n\t    0x0442: 'tk',\n\t    0x0480: 'ug',\n\t    0x0422: 'uk',\n\t    0x042E: 'hsb',\n\t    0x0420: 'ur',\n\t    0x0843: 'uz-Cyrl',\n\t    0x0443: 'uz',\n\t    0x042A: 'vi',\n\t    0x0452: 'cy',\n\t    0x0488: 'wo',\n\t    0x0485: 'sah',\n\t    0x0478: 'ii',\n\t    0x046A: 'yo'\n\t};\n\n\t// Returns a IETF BCP 47 language code, for example 'zh-Hant'\n\t// for 'Chinese in the traditional script'.\n\tfunction getLanguageCode(platformID, languageID, ltag) {\n\t    switch (platformID) {\n\t        case 0:  // Unicode\n\t            if (languageID === 0xFFFF) {\n\t                return 'und';\n\t            } else if (ltag) {\n\t                return ltag[languageID];\n\t            }\n\n\t            break;\n\n\t        case 1:  // Macintosh\n\t            return macLanguages[languageID];\n\n\t        case 3:  // Windows\n\t            return windowsLanguages[languageID];\n\t    }\n\n\t    return undefined;\n\t}\n\n\tvar utf16 = 'utf-16';\n\n\t// MacOS script ID  encoding. This table stores the default case,\n\t// which can be overridden by macLanguageEncodings.\n\tvar macScriptEncodings = {\n\t    0: 'macintosh',           // smRoman\n\t    1: 'x-mac-japanese',      // smJapanese\n\t    2: 'x-mac-chinesetrad',   // smTradChinese\n\t    3: 'x-mac-korean',        // smKorean\n\t    6: 'x-mac-greek',         // smGreek\n\t    7: 'x-mac-cyrillic',      // smCyrillic\n\t    9: 'x-mac-devanagai',     // smDevanagari\n\t    10: 'x-mac-gurmukhi',     // smGurmukhi\n\t    11: 'x-mac-gujarati',     // smGujarati\n\t    12: 'x-mac-oriya',        // smOriya\n\t    13: 'x-mac-bengali',      // smBengali\n\t    14: 'x-mac-tamil',        // smTamil\n\t    15: 'x-mac-telugu',       // smTelugu\n\t    16: 'x-mac-kannada',      // smKannada\n\t    17: 'x-mac-malayalam',    // smMalayalam\n\t    18: 'x-mac-sinhalese',    // smSinhalese\n\t    19: 'x-mac-burmese',      // smBurmese\n\t    20: 'x-mac-khmer',        // smKhmer\n\t    21: 'x-mac-thai',         // smThai\n\t    22: 'x-mac-lao',          // smLao\n\t    23: 'x-mac-georgian',     // smGeorgian\n\t    24: 'x-mac-armenian',     // smArmenian\n\t    25: 'x-mac-chinesesimp',  // smSimpChinese\n\t    26: 'x-mac-tibetan',      // smTibetan\n\t    27: 'x-mac-mongolian',    // smMongolian\n\t    28: 'x-mac-ethiopic',     // smEthiopic\n\t    29: 'x-mac-ce',           // smCentralEuroRoman\n\t    30: 'x-mac-vietnamese',   // smVietnamese\n\t    31: 'x-mac-extarabic'     // smExtArabic\n\t};\n\n\t// MacOS language ID  encoding. This table stores the exceptional\n\t// cases, which override macScriptEncodings. For writing MacOS naming\n\t// tables, we need to emit a MacOS script ID. Therefore, we cannot\n\t// merge macScriptEncodings into macLanguageEncodings.\n\t//\n\t// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n\tvar macLanguageEncodings = {\n\t    15: 'x-mac-icelandic',    // langIcelandic\n\t    17: 'x-mac-turkish',      // langTurkish\n\t    18: 'x-mac-croatian',     // langCroatian\n\t    24: 'x-mac-ce',           // langLithuanian\n\t    25: 'x-mac-ce',           // langPolish\n\t    26: 'x-mac-ce',           // langHungarian\n\t    27: 'x-mac-ce',           // langEstonian\n\t    28: 'x-mac-ce',           // langLatvian\n\t    30: 'x-mac-icelandic',    // langFaroese\n\t    37: 'x-mac-romanian',     // langRomanian\n\t    38: 'x-mac-ce',           // langCzech\n\t    39: 'x-mac-ce',           // langSlovak\n\t    40: 'x-mac-ce',           // langSlovenian\n\t    143: 'x-mac-inuit',       // langInuktitut\n\t    146: 'x-mac-gaelic'       // langIrishGaelicScript\n\t};\n\n\tfunction getEncoding(platformID, encodingID, languageID) {\n\t    switch (platformID) {\n\t        case 0:  // Unicode\n\t            return utf16;\n\n\t        case 1:  // Apple Macintosh\n\t            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];\n\n\t        case 3:  // Microsoft Windows\n\t            if (encodingID === 1 || encodingID === 10) {\n\t                return utf16;\n\t            }\n\n\t            break;\n\t    }\n\n\t    return undefined;\n\t}\n\n\t// Parse the naming `name` table.\n\t// FIXME: Format 1 additional fields are not supported yet.\n\t// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].\n\tfunction parseNameTable(data, start, ltag) {\n\t    var name = {};\n\t    var p = new parse.Parser(data, start);\n\t    var format = p.parseUShort();\n\t    var count = p.parseUShort();\n\t    var stringOffset = p.offset + p.parseUShort();\n\t    for (var i = 0; i < count; i++) {\n\t        var platformID = p.parseUShort();\n\t        var encodingID = p.parseUShort();\n\t        var languageID = p.parseUShort();\n\t        var nameID = p.parseUShort();\n\t        var property = nameTableNames[nameID] || nameID;\n\t        var byteLength = p.parseUShort();\n\t        var offset = p.parseUShort();\n\t        var language = getLanguageCode(platformID, languageID, ltag);\n\t        var encoding = getEncoding(platformID, encodingID, languageID);\n\t        if (encoding !== undefined && language !== undefined) {\n\t            var text = (void 0);\n\t            if (encoding === utf16) {\n\t                text = decode.UTF16(data, stringOffset + offset, byteLength);\n\t            } else {\n\t                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);\n\t            }\n\n\t            if (text) {\n\t                var translations = name[property];\n\t                if (translations === undefined) {\n\t                    translations = name[property] = {};\n\t                }\n\n\t                translations[language] = text;\n\t            }\n\t        }\n\t    }\n\n\t    var langTagCount = 0;\n\t    if (format === 1) {\n\t        // FIXME: Also handle Microsoft's 'name' table 1.\n\t        langTagCount = p.parseUShort();\n\t    }\n\n\t    return name;\n\t}\n\n\t// {23: 'foo'}  {'foo': 23}\n\t// ['bar', 'baz']  {'bar': 0, 'baz': 1}\n\tfunction reverseDict(dict) {\n\t    var result = {};\n\t    for (var key in dict) {\n\t        result[dict[key]] = parseInt(key);\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {\n\t    return new table.Record('NameRecord', [\n\t        {name: 'platformID', type: 'USHORT', value: platformID},\n\t        {name: 'encodingID', type: 'USHORT', value: encodingID},\n\t        {name: 'languageID', type: 'USHORT', value: languageID},\n\t        {name: 'nameID', type: 'USHORT', value: nameID},\n\t        {name: 'length', type: 'USHORT', value: length},\n\t        {name: 'offset', type: 'USHORT', value: offset}\n\t    ]);\n\t}\n\n\t// Finds the position of needle in haystack, or -1 if not there.\n\t// Like String.indexOf(), but for arrays.\n\tfunction findSubArray(needle, haystack) {\n\t    var needleLength = needle.length;\n\t    var limit = haystack.length - needleLength + 1;\n\n\t    loop:\n\t    for (var pos = 0; pos < limit; pos++) {\n\t        for (; pos < limit; pos++) {\n\t            for (var k = 0; k < needleLength; k++) {\n\t                if (haystack[pos + k] !== needle[k]) {\n\t                    continue loop;\n\t                }\n\t            }\n\n\t            return pos;\n\t        }\n\t    }\n\n\t    return -1;\n\t}\n\n\tfunction addStringToPool(s, pool) {\n\t    var offset = findSubArray(s, pool);\n\t    if (offset < 0) {\n\t        offset = pool.length;\n\t        var i = 0;\n\t        var len = s.length;\n\t        for (; i < len; ++i) {\n\t            pool.push(s[i]);\n\t        }\n\n\t    }\n\n\t    return offset;\n\t}\n\n\tfunction makeNameTable(names, ltag) {\n\t    var nameID;\n\t    var nameIDs = [];\n\n\t    var namesWithNumericKeys = {};\n\t    var nameTableIds = reverseDict(nameTableNames);\n\t    for (var key in names) {\n\t        var id = nameTableIds[key];\n\t        if (id === undefined) {\n\t            id = key;\n\t        }\n\n\t        nameID = parseInt(id);\n\n\t        if (isNaN(nameID)) {\n\t            throw new Error('Name table entry \"' + key + '\" does not exist, see nameTableNames for complete list.');\n\t        }\n\n\t        namesWithNumericKeys[nameID] = names[key];\n\t        nameIDs.push(nameID);\n\t    }\n\n\t    var macLanguageIds = reverseDict(macLanguages);\n\t    var windowsLanguageIds = reverseDict(windowsLanguages);\n\n\t    var nameRecords = [];\n\t    var stringPool = [];\n\n\t    for (var i = 0; i < nameIDs.length; i++) {\n\t        nameID = nameIDs[i];\n\t        var translations = namesWithNumericKeys[nameID];\n\t        for (var lang in translations) {\n\t            var text = translations[lang];\n\n\t            // For MacOS, we try to emit the name in the form that was introduced\n\t            // in the initial version of the TrueType spec (in the late 1980s).\n\t            // However, this can fail for various reasons: the requested BCP 47\n\t            // language code might not have an old-style Mac equivalent;\n\t            // we might not have a codec for the needed character encoding;\n\t            // or the name might contain characters that cannot be expressed\n\t            // in the old-style Macintosh encoding. In case of failure, we emit\n\t            // the name in a more modern fashion (Unicode encoding with BCP 47\n\t            // language tags) that is recognized by MacOS 10.5, released in 2009.\n\t            // If fonts were only read by operating systems, we could simply\n\t            // emit all names in the modern form; this would be much easier.\n\t            // However, there are many applications and libraries that read\n\t            // 'name' tables directly, and these will usually only recognize\n\t            // the ancient form (silently skipping the unrecognized names).\n\t            var macPlatform = 1;  // Macintosh\n\t            var macLanguage = macLanguageIds[lang];\n\t            var macScript = macLanguageToScript[macLanguage];\n\t            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);\n\t            var macName = encode.MACSTRING(text, macEncoding);\n\t            if (macName === undefined) {\n\t                macPlatform = 0;  // Unicode\n\t                macLanguage = ltag.indexOf(lang);\n\t                if (macLanguage < 0) {\n\t                    macLanguage = ltag.length;\n\t                    ltag.push(lang);\n\t                }\n\n\t                macScript = 4;  // Unicode 2.0 and later\n\t                macName = encode.UTF16(text);\n\t            }\n\n\t            var macNameOffset = addStringToPool(macName, stringPool);\n\t            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,\n\t                                            nameID, macName.length, macNameOffset));\n\n\t            var winLanguage = windowsLanguageIds[lang];\n\t            if (winLanguage !== undefined) {\n\t                var winName = encode.UTF16(text);\n\t                var winNameOffset = addStringToPool(winName, stringPool);\n\t                nameRecords.push(makeNameRecord(3, 1, winLanguage,\n\t                                                nameID, winName.length, winNameOffset));\n\t            }\n\t        }\n\t    }\n\n\t    nameRecords.sort(function(a, b) {\n\t        return ((a.platformID - b.platformID) ||\n\t                (a.encodingID - b.encodingID) ||\n\t                (a.languageID - b.languageID) ||\n\t                (a.nameID - b.nameID));\n\t    });\n\n\t    var t = new table.Table('name', [\n\t        {name: 'format', type: 'USHORT', value: 0},\n\t        {name: 'count', type: 'USHORT', value: nameRecords.length},\n\t        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}\n\t    ]);\n\n\t    for (var r = 0; r < nameRecords.length; r++) {\n\t        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});\n\t    }\n\n\t    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});\n\t    return t;\n\t}\n\n\tvar _name = { parse: parseNameTable, make: makeNameTable };\n\n\t// The `OS/2` table contains metrics required in OpenType fonts.\n\n\tvar unicodeRanges = [\n\t    {begin: 0x0000, end: 0x007F}, // Basic Latin\n\t    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement\n\t    {begin: 0x0100, end: 0x017F}, // Latin Extended-A\n\t    {begin: 0x0180, end: 0x024F}, // Latin Extended-B\n\t    {begin: 0x0250, end: 0x02AF}, // IPA Extensions\n\t    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters\n\t    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks\n\t    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic\n\t    {begin: 0x2C80, end: 0x2CFF}, // Coptic\n\t    {begin: 0x0400, end: 0x04FF}, // Cyrillic\n\t    {begin: 0x0530, end: 0x058F}, // Armenian\n\t    {begin: 0x0590, end: 0x05FF}, // Hebrew\n\t    {begin: 0xA500, end: 0xA63F}, // Vai\n\t    {begin: 0x0600, end: 0x06FF}, // Arabic\n\t    {begin: 0x07C0, end: 0x07FF}, // NKo\n\t    {begin: 0x0900, end: 0x097F}, // Devanagari\n\t    {begin: 0x0980, end: 0x09FF}, // Bengali\n\t    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi\n\t    {begin: 0x0A80, end: 0x0AFF}, // Gujarati\n\t    {begin: 0x0B00, end: 0x0B7F}, // Oriya\n\t    {begin: 0x0B80, end: 0x0BFF}, // Tamil\n\t    {begin: 0x0C00, end: 0x0C7F}, // Telugu\n\t    {begin: 0x0C80, end: 0x0CFF}, // Kannada\n\t    {begin: 0x0D00, end: 0x0D7F}, // Malayalam\n\t    {begin: 0x0E00, end: 0x0E7F}, // Thai\n\t    {begin: 0x0E80, end: 0x0EFF}, // Lao\n\t    {begin: 0x10A0, end: 0x10FF}, // Georgian\n\t    {begin: 0x1B00, end: 0x1B7F}, // Balinese\n\t    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo\n\t    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional\n\t    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended\n\t    {begin: 0x2000, end: 0x206F}, // General Punctuation\n\t    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts\n\t    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol\n\t    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols\n\t    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols\n\t    {begin: 0x2150, end: 0x218F}, // Number Forms\n\t    {begin: 0x2190, end: 0x21FF}, // Arrows\n\t    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators\n\t    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical\n\t    {begin: 0x2400, end: 0x243F}, // Control Pictures\n\t    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition\n\t    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics\n\t    {begin: 0x2500, end: 0x257F}, // Box Drawing\n\t    {begin: 0x2580, end: 0x259F}, // Block Elements\n\t    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes\n\t    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols\n\t    {begin: 0x2700, end: 0x27BF}, // Dingbats\n\t    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation\n\t    {begin: 0x3040, end: 0x309F}, // Hiragana\n\t    {begin: 0x30A0, end: 0x30FF}, // Katakana\n\t    {begin: 0x3100, end: 0x312F}, // Bopomofo\n\t    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo\n\t    {begin: 0xA840, end: 0xA87F}, // Phags-pa\n\t    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months\n\t    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility\n\t    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables\n\t    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *\n\t    {begin: 0x10900, end: 0x1091F}, // Phoenicia\n\t    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs\n\t    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)\n\t    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes\n\t    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms\n\t    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A\n\t    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks\n\t    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms\n\t    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants\n\t    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B\n\t    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms\n\t    {begin: 0xFFF0, end: 0xFFFF}, // Specials\n\t    {begin: 0x0F00, end: 0x0FFF}, // Tibetan\n\t    {begin: 0x0700, end: 0x074F}, // Syriac\n\t    {begin: 0x0780, end: 0x07BF}, // Thaana\n\t    {begin: 0x0D80, end: 0x0DFF}, // Sinhala\n\t    {begin: 0x1000, end: 0x109F}, // Myanmar\n\t    {begin: 0x1200, end: 0x137F}, // Ethiopic\n\t    {begin: 0x13A0, end: 0x13FF}, // Cherokee\n\t    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics\n\t    {begin: 0x1680, end: 0x169F}, // Ogham\n\t    {begin: 0x16A0, end: 0x16FF}, // Runic\n\t    {begin: 0x1780, end: 0x17FF}, // Khmer\n\t    {begin: 0x1800, end: 0x18AF}, // Mongolian\n\t    {begin: 0x2800, end: 0x28FF}, // Braille Patterns\n\t    {begin: 0xA000, end: 0xA48F}, // Yi Syllables\n\t    {begin: 0x1700, end: 0x171F}, // Tagalog\n\t    {begin: 0x10300, end: 0x1032F}, // Old Italic\n\t    {begin: 0x10330, end: 0x1034F}, // Gothic\n\t    {begin: 0x10400, end: 0x1044F}, // Deseret\n\t    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols\n\t    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols\n\t    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)\n\t    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors\n\t    {begin: 0xE0000, end: 0xE007F}, // Tags\n\t    {begin: 0x1900, end: 0x194F}, // Limbu\n\t    {begin: 0x1950, end: 0x197F}, // Tai Le\n\t    {begin: 0x1980, end: 0x19DF}, // New Tai Lue\n\t    {begin: 0x1A00, end: 0x1A1F}, // Buginese\n\t    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic\n\t    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh\n\t    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols\n\t    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri\n\t    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary\n\t    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers\n\t    {begin: 0x10380, end: 0x1039F}, // Ugaritic\n\t    {begin: 0x103A0, end: 0x103DF}, // Old Persian\n\t    {begin: 0x10450, end: 0x1047F}, // Shavian\n\t    {begin: 0x10480, end: 0x104AF}, // Osmanya\n\t    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary\n\t    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi\n\t    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols\n\t    {begin: 0x12000, end: 0x123FF}, // Cuneiform\n\t    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals\n\t    {begin: 0x1B80, end: 0x1BBF}, // Sundanese\n\t    {begin: 0x1C00, end: 0x1C4F}, // Lepcha\n\t    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki\n\t    {begin: 0xA880, end: 0xA8DF}, // Saurashtra\n\t    {begin: 0xA900, end: 0xA92F}, // Kayah Li\n\t    {begin: 0xA930, end: 0xA95F}, // Rejang\n\t    {begin: 0xAA00, end: 0xAA5F}, // Cham\n\t    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols\n\t    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc\n\t    {begin: 0x102A0, end: 0x102DF}, // Carian\n\t    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles\n\t];\n\n\tfunction getUnicodeRange(unicode) {\n\t    for (var i = 0; i < unicodeRanges.length; i += 1) {\n\t        var range = unicodeRanges[i];\n\t        if (unicode >= range.begin && unicode < range.end) {\n\t            return i;\n\t        }\n\t    }\n\n\t    return -1;\n\t}\n\n\t// Parse the OS/2 and Windows metrics `OS/2` table\n\tfunction parseOS2Table(data, start) {\n\t    var os2 = {};\n\t    var p = new parse.Parser(data, start);\n\t    os2.version = p.parseUShort();\n\t    os2.xAvgCharWidth = p.parseShort();\n\t    os2.usWeightClass = p.parseUShort();\n\t    os2.usWidthClass = p.parseUShort();\n\t    os2.fsType = p.parseUShort();\n\t    os2.ySubscriptXSize = p.parseShort();\n\t    os2.ySubscriptYSize = p.parseShort();\n\t    os2.ySubscriptXOffset = p.parseShort();\n\t    os2.ySubscriptYOffset = p.parseShort();\n\t    os2.ySuperscriptXSize = p.parseShort();\n\t    os2.ySuperscriptYSize = p.parseShort();\n\t    os2.ySuperscriptXOffset = p.parseShort();\n\t    os2.ySuperscriptYOffset = p.parseShort();\n\t    os2.yStrikeoutSize = p.parseShort();\n\t    os2.yStrikeoutPosition = p.parseShort();\n\t    os2.sFamilyClass = p.parseShort();\n\t    os2.panose = [];\n\t    for (var i = 0; i < 10; i++) {\n\t        os2.panose[i] = p.parseByte();\n\t    }\n\n\t    os2.ulUnicodeRange1 = p.parseULong();\n\t    os2.ulUnicodeRange2 = p.parseULong();\n\t    os2.ulUnicodeRange3 = p.parseULong();\n\t    os2.ulUnicodeRange4 = p.parseULong();\n\t    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());\n\t    os2.fsSelection = p.parseUShort();\n\t    os2.usFirstCharIndex = p.parseUShort();\n\t    os2.usLastCharIndex = p.parseUShort();\n\t    os2.sTypoAscender = p.parseShort();\n\t    os2.sTypoDescender = p.parseShort();\n\t    os2.sTypoLineGap = p.parseShort();\n\t    os2.usWinAscent = p.parseUShort();\n\t    os2.usWinDescent = p.parseUShort();\n\t    if (os2.version >= 1) {\n\t        os2.ulCodePageRange1 = p.parseULong();\n\t        os2.ulCodePageRange2 = p.parseULong();\n\t    }\n\n\t    if (os2.version >= 2) {\n\t        os2.sxHeight = p.parseShort();\n\t        os2.sCapHeight = p.parseShort();\n\t        os2.usDefaultChar = p.parseUShort();\n\t        os2.usBreakChar = p.parseUShort();\n\t        os2.usMaxContent = p.parseUShort();\n\t    }\n\n\t    return os2;\n\t}\n\n\tfunction makeOS2Table(options) {\n\t    return new table.Table('OS/2', [\n\t        {name: 'version', type: 'USHORT', value: 0x0003},\n\t        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},\n\t        {name: 'usWeightClass', type: 'USHORT', value: 0},\n\t        {name: 'usWidthClass', type: 'USHORT', value: 0},\n\t        {name: 'fsType', type: 'USHORT', value: 0},\n\t        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},\n\t        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},\n\t        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},\n\t        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},\n\t        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},\n\t        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},\n\t        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},\n\t        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},\n\t        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},\n\t        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},\n\t        {name: 'sFamilyClass', type: 'SHORT', value: 0},\n\t        {name: 'bFamilyType', type: 'BYTE', value: 0},\n\t        {name: 'bSerifStyle', type: 'BYTE', value: 0},\n\t        {name: 'bWeight', type: 'BYTE', value: 0},\n\t        {name: 'bProportion', type: 'BYTE', value: 0},\n\t        {name: 'bContrast', type: 'BYTE', value: 0},\n\t        {name: 'bStrokeVariation', type: 'BYTE', value: 0},\n\t        {name: 'bArmStyle', type: 'BYTE', value: 0},\n\t        {name: 'bLetterform', type: 'BYTE', value: 0},\n\t        {name: 'bMidline', type: 'BYTE', value: 0},\n\t        {name: 'bXHeight', type: 'BYTE', value: 0},\n\t        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},\n\t        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},\n\t        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},\n\t        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},\n\t        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},\n\t        {name: 'fsSelection', type: 'USHORT', value: 0},\n\t        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},\n\t        {name: 'usLastCharIndex', type: 'USHORT', value: 0},\n\t        {name: 'sTypoAscender', type: 'SHORT', value: 0},\n\t        {name: 'sTypoDescender', type: 'SHORT', value: 0},\n\t        {name: 'sTypoLineGap', type: 'SHORT', value: 0},\n\t        {name: 'usWinAscent', type: 'USHORT', value: 0},\n\t        {name: 'usWinDescent', type: 'USHORT', value: 0},\n\t        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},\n\t        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},\n\t        {name: 'sxHeight', type: 'SHORT', value: 0},\n\t        {name: 'sCapHeight', type: 'SHORT', value: 0},\n\t        {name: 'usDefaultChar', type: 'USHORT', value: 0},\n\t        {name: 'usBreakChar', type: 'USHORT', value: 0},\n\t        {name: 'usMaxContext', type: 'USHORT', value: 0}\n\t    ], options);\n\t}\n\n\tvar os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };\n\n\t// The `post` table stores additional PostScript information, such as glyph names.\n\n\t// Parse the PostScript `post` table\n\tfunction parsePostTable(data, start) {\n\t    var post = {};\n\t    var p = new parse.Parser(data, start);\n\t    post.version = p.parseVersion();\n\t    post.italicAngle = p.parseFixed();\n\t    post.underlinePosition = p.parseShort();\n\t    post.underlineThickness = p.parseShort();\n\t    post.isFixedPitch = p.parseULong();\n\t    post.minMemType42 = p.parseULong();\n\t    post.maxMemType42 = p.parseULong();\n\t    post.minMemType1 = p.parseULong();\n\t    post.maxMemType1 = p.parseULong();\n\t    switch (post.version) {\n\t        case 1:\n\t            post.names = standardNames.slice();\n\t            break;\n\t        case 2:\n\t            post.numberOfGlyphs = p.parseUShort();\n\t            post.glyphNameIndex = new Array(post.numberOfGlyphs);\n\t            for (var i = 0; i < post.numberOfGlyphs; i++) {\n\t                post.glyphNameIndex[i] = p.parseUShort();\n\t            }\n\n\t            post.names = [];\n\t            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {\n\t                if (post.glyphNameIndex[i$1] >= standardNames.length) {\n\t                    var nameLength = p.parseChar();\n\t                    post.names.push(p.parseString(nameLength));\n\t                }\n\t            }\n\n\t            break;\n\t        case 2.5:\n\t            post.numberOfGlyphs = p.parseUShort();\n\t            post.offset = new Array(post.numberOfGlyphs);\n\t            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {\n\t                post.offset[i$2] = p.parseChar();\n\t            }\n\n\t            break;\n\t    }\n\t    return post;\n\t}\n\n\tfunction makePostTable() {\n\t    return new table.Table('post', [\n\t        {name: 'version', type: 'FIXED', value: 0x00030000},\n\t        {name: 'italicAngle', type: 'FIXED', value: 0},\n\t        {name: 'underlinePosition', type: 'FWORD', value: 0},\n\t        {name: 'underlineThickness', type: 'FWORD', value: 0},\n\t        {name: 'isFixedPitch', type: 'ULONG', value: 0},\n\t        {name: 'minMemType42', type: 'ULONG', value: 0},\n\t        {name: 'maxMemType42', type: 'ULONG', value: 0},\n\t        {name: 'minMemType1', type: 'ULONG', value: 0},\n\t        {name: 'maxMemType1', type: 'ULONG', value: 0}\n\t    ]);\n\t}\n\n\tvar post = { parse: parsePostTable, make: makePostTable };\n\n\t// The `GSUB` table contains ligatures, among other things.\n\n\tvar subtableParsers = new Array(9);         // subtableParsers[0] is unused\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS\n\tsubtableParsers[1] = function parseLookup1() {\n\t    var start = this.offset + this.relativeOffset;\n\t    var substFormat = this.parseUShort();\n\t    if (substFormat === 1) {\n\t        return {\n\t            substFormat: 1,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            deltaGlyphId: this.parseUShort()\n\t        };\n\t    } else if (substFormat === 2) {\n\t        return {\n\t            substFormat: 2,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            substitute: this.parseOffset16List()\n\t        };\n\t    }\n\t    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS\n\tsubtableParsers[2] = function parseLookup2() {\n\t    var substFormat = this.parseUShort();\n\t    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');\n\t    return {\n\t        substFormat: substFormat,\n\t        coverage: this.parsePointer(Parser.coverage),\n\t        sequences: this.parseListOfLists()\n\t    };\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS\n\tsubtableParsers[3] = function parseLookup3() {\n\t    var substFormat = this.parseUShort();\n\t    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');\n\t    return {\n\t        substFormat: substFormat,\n\t        coverage: this.parsePointer(Parser.coverage),\n\t        alternateSets: this.parseListOfLists()\n\t    };\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS\n\tsubtableParsers[4] = function parseLookup4() {\n\t    var substFormat = this.parseUShort();\n\t    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');\n\t    return {\n\t        substFormat: substFormat,\n\t        coverage: this.parsePointer(Parser.coverage),\n\t        ligatureSets: this.parseListOfLists(function() {\n\t            return {\n\t                ligGlyph: this.parseUShort(),\n\t                components: this.parseUShortList(this.parseUShort() - 1)\n\t            };\n\t        })\n\t    };\n\t};\n\n\tvar lookupRecordDesc = {\n\t    sequenceIndex: Parser.uShort,\n\t    lookupListIndex: Parser.uShort\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF\n\tsubtableParsers[5] = function parseLookup5() {\n\t    var start = this.offset + this.relativeOffset;\n\t    var substFormat = this.parseUShort();\n\n\t    if (substFormat === 1) {\n\t        return {\n\t            substFormat: substFormat,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            ruleSets: this.parseListOfLists(function() {\n\t                var glyphCount = this.parseUShort();\n\t                var substCount = this.parseUShort();\n\t                return {\n\t                    input: this.parseUShortList(glyphCount - 1),\n\t                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n\t                };\n\t            })\n\t        };\n\t    } else if (substFormat === 2) {\n\t        return {\n\t            substFormat: substFormat,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            classDef: this.parsePointer(Parser.classDef),\n\t            classSets: this.parseListOfLists(function() {\n\t                var glyphCount = this.parseUShort();\n\t                var substCount = this.parseUShort();\n\t                return {\n\t                    classes: this.parseUShortList(glyphCount - 1),\n\t                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n\t                };\n\t            })\n\t        };\n\t    } else if (substFormat === 3) {\n\t        var glyphCount = this.parseUShort();\n\t        var substCount = this.parseUShort();\n\t        return {\n\t            substFormat: substFormat,\n\t            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),\n\t            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n\t        };\n\t    }\n\t    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC\n\tsubtableParsers[6] = function parseLookup6() {\n\t    var start = this.offset + this.relativeOffset;\n\t    var substFormat = this.parseUShort();\n\t    if (substFormat === 1) {\n\t        return {\n\t            substFormat: 1,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            chainRuleSets: this.parseListOfLists(function() {\n\t                return {\n\t                    backtrack: this.parseUShortList(),\n\t                    input: this.parseUShortList(this.parseShort() - 1),\n\t                    lookahead: this.parseUShortList(),\n\t                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n\t                };\n\t            })\n\t        };\n\t    } else if (substFormat === 2) {\n\t        return {\n\t            substFormat: 2,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            backtrackClassDef: this.parsePointer(Parser.classDef),\n\t            inputClassDef: this.parsePointer(Parser.classDef),\n\t            lookaheadClassDef: this.parsePointer(Parser.classDef),\n\t            chainClassSet: this.parseListOfLists(function() {\n\t                return {\n\t                    backtrack: this.parseUShortList(),\n\t                    input: this.parseUShortList(this.parseShort() - 1),\n\t                    lookahead: this.parseUShortList(),\n\t                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n\t                };\n\t            })\n\t        };\n\t    } else if (substFormat === 3) {\n\t        return {\n\t            substFormat: 3,\n\t            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n\t            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n\t            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n\t            lookupRecords: this.parseRecordList(lookupRecordDesc)\n\t        };\n\t    }\n\t    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES\n\tsubtableParsers[7] = function parseLookup7() {\n\t    // Extension Substitution subtable\n\t    var substFormat = this.parseUShort();\n\t    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');\n\t    var extensionLookupType = this.parseUShort();\n\t    var extensionParser = new Parser(this.data, this.offset + this.parseULong());\n\t    return {\n\t        substFormat: 1,\n\t        lookupType: extensionLookupType,\n\t        extension: subtableParsers[extensionLookupType].call(extensionParser)\n\t    };\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS\n\tsubtableParsers[8] = function parseLookup8() {\n\t    var substFormat = this.parseUShort();\n\t    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');\n\t    return {\n\t        substFormat: substFormat,\n\t        coverage: this.parsePointer(Parser.coverage),\n\t        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n\t        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n\t        substitutes: this.parseUShortList()\n\t    };\n\t};\n\n\t// https://www.microsoft.com/typography/OTSPEC/gsub.htm\n\tfunction parseGsubTable(data, start) {\n\t    start = start || 0;\n\t    var p = new Parser(data, start);\n\t    var tableVersion = p.parseVersion(1);\n\t    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');\n\t    if (tableVersion === 1) {\n\t        return {\n\t            version: tableVersion,\n\t            scripts: p.parseScriptList(),\n\t            features: p.parseFeatureList(),\n\t            lookups: p.parseLookupList(subtableParsers)\n\t        };\n\t    } else {\n\t        return {\n\t            version: tableVersion,\n\t            scripts: p.parseScriptList(),\n\t            features: p.parseFeatureList(),\n\t            lookups: p.parseLookupList(subtableParsers),\n\t            variations: p.parseFeatureVariationsList()\n\t        };\n\t    }\n\n\t}\n\n\t// GSUB Writing //////////////////////////////////////////////\n\tvar subtableMakers = new Array(9);\n\n\tsubtableMakers[1] = function makeLookup1(subtable) {\n\t    if (subtable.substFormat === 1) {\n\t        return new table.Table('substitutionTable', [\n\t            {name: 'substFormat', type: 'USHORT', value: 1},\n\t            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},\n\t            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}\n\t        ]);\n\t    } else {\n\t        return new table.Table('substitutionTable', [\n\t            {name: 'substFormat', type: 'USHORT', value: 2},\n\t            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n\t        ].concat(table.ushortList('substitute', subtable.substitute)));\n\t    }\n\t    check.fail('Lookup type 1 substFormat must be 1 or 2.');\n\t};\n\n\tsubtableMakers[3] = function makeLookup3(subtable) {\n\t    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');\n\t    return new table.Table('substitutionTable', [\n\t        {name: 'substFormat', type: 'USHORT', value: 1},\n\t        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n\t    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {\n\t        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));\n\t    })));\n\t};\n\n\tsubtableMakers[4] = function makeLookup4(subtable) {\n\t    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');\n\t    return new table.Table('substitutionTable', [\n\t        {name: 'substFormat', type: 'USHORT', value: 1},\n\t        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}\n\t    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {\n\t        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {\n\t            return new table.Table('ligatureTable',\n\t                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]\n\t                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))\n\t            );\n\t        }));\n\t    })));\n\t};\n\n\tfunction makeGsubTable(gsub) {\n\t    return new table.Table('GSUB', [\n\t        {name: 'version', type: 'ULONG', value: 0x10000},\n\t        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},\n\t        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},\n\t        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}\n\t    ]);\n\t}\n\n\tvar gsub = { parse: parseGsubTable, make: makeGsubTable };\n\n\t// The `GPOS` table contains kerning pairs, among other things.\n\n\t// Parse the metadata `meta` table.\n\t// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html\n\tfunction parseMetaTable(data, start) {\n\t    var p = new parse.Parser(data, start);\n\t    var tableVersion = p.parseULong();\n\t    check.argument(tableVersion === 1, 'Unsupported META table version.');\n\t    p.parseULong(); // flags - currently unused and set to 0\n\t    p.parseULong(); // tableOffset\n\t    var numDataMaps = p.parseULong();\n\n\t    var tags = {};\n\t    for (var i = 0; i < numDataMaps; i++) {\n\t        var tag = p.parseTag();\n\t        var dataOffset = p.parseULong();\n\t        var dataLength = p.parseULong();\n\t        var text = decode.UTF8(data, start + dataOffset, dataLength);\n\n\t        tags[tag] = text;\n\t    }\n\t    return tags;\n\t}\n\n\tfunction makeMetaTable(tags) {\n\t    var numTags = Object.keys(tags).length;\n\t    var stringPool = '';\n\t    var stringPoolOffset = 16 + numTags * 12;\n\n\t    var result = new table.Table('meta', [\n\t        {name: 'version', type: 'ULONG', value: 1},\n\t        {name: 'flags', type: 'ULONG', value: 0},\n\t        {name: 'offset', type: 'ULONG', value: stringPoolOffset},\n\t        {name: 'numTags', type: 'ULONG', value: numTags}\n\t    ]);\n\n\t    for (var tag in tags) {\n\t        var pos = stringPool.length;\n\t        stringPool += tags[tag];\n\n\t        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});\n\t        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});\n\t        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});\n\t    }\n\n\t    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n\n\t    return result;\n\t}\n\n\tvar meta = { parse: parseMetaTable, make: makeMetaTable };\n\n\t// The `sfnt` wrapper provides organization for the tables in the font.\n\n\tfunction log2(v) {\n\t    return Math.log(v) / Math.log(2) | 0;\n\t}\n\n\tfunction computeCheckSum(bytes) {\n\t    while (bytes.length % 4 !== 0) {\n\t        bytes.push(0);\n\t    }\n\n\t    var sum = 0;\n\t    for (var i = 0; i < bytes.length; i += 4) {\n\t        sum += (bytes[i] << 24) +\n\t            (bytes[i + 1] << 16) +\n\t            (bytes[i + 2] << 8) +\n\t            (bytes[i + 3]);\n\t    }\n\n\t    sum %= Math.pow(2, 32);\n\t    return sum;\n\t}\n\n\tfunction makeTableRecord(tag, checkSum, offset, length) {\n\t    return new table.Record('Table Record', [\n\t        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},\n\t        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},\n\t        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},\n\t        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}\n\t    ]);\n\t}\n\n\tfunction makeSfntTable(tables) {\n\t    var sfnt = new table.Table('sfnt', [\n\t        {name: 'version', type: 'TAG', value: 'OTTO'},\n\t        {name: 'numTables', type: 'USHORT', value: 0},\n\t        {name: 'searchRange', type: 'USHORT', value: 0},\n\t        {name: 'entrySelector', type: 'USHORT', value: 0},\n\t        {name: 'rangeShift', type: 'USHORT', value: 0}\n\t    ]);\n\t    sfnt.tables = tables;\n\t    sfnt.numTables = tables.length;\n\t    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));\n\t    sfnt.searchRange = 16 * highestPowerOf2;\n\t    sfnt.entrySelector = log2(highestPowerOf2);\n\t    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;\n\n\t    var recordFields = [];\n\t    var tableFields = [];\n\n\t    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);\n\t    while (offset % 4 !== 0) {\n\t        offset += 1;\n\t        tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n\t    }\n\n\t    for (var i = 0; i < tables.length; i += 1) {\n\t        var t = tables[i];\n\t        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');\n\t        var tableLength = t.sizeOf();\n\t        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);\n\t        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});\n\t        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});\n\t        offset += tableLength;\n\t        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');\n\t        while (offset % 4 !== 0) {\n\t            offset += 1;\n\t            tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n\t        }\n\t    }\n\n\t    // Table records need to be sorted alphabetically.\n\t    recordFields.sort(function(r1, r2) {\n\t        if (r1.value.tag > r2.value.tag) {\n\t            return 1;\n\t        } else {\n\t            return -1;\n\t        }\n\t    });\n\n\t    sfnt.fields = sfnt.fields.concat(recordFields);\n\t    sfnt.fields = sfnt.fields.concat(tableFields);\n\t    return sfnt;\n\t}\n\n\t// Get the metrics for a character. If the string has more than one character\n\t// this function returns metrics for the first available character.\n\t// You can provide optional fallback metrics if no characters are available.\n\tfunction metricsForChar(font, chars, notFoundMetrics) {\n\t    for (var i = 0; i < chars.length; i += 1) {\n\t        var glyphIndex = font.charToGlyphIndex(chars[i]);\n\t        if (glyphIndex > 0) {\n\t            var glyph = font.glyphs.get(glyphIndex);\n\t            return glyph.getMetrics();\n\t        }\n\t    }\n\n\t    return notFoundMetrics;\n\t}\n\n\tfunction average(vs) {\n\t    var sum = 0;\n\t    for (var i = 0; i < vs.length; i += 1) {\n\t        sum += vs[i];\n\t    }\n\n\t    return sum / vs.length;\n\t}\n\n\t// Convert the font object to a SFNT data structure.\n\t// This structure contains all the necessary tables and metadata to create a binary OTF file.\n\tfunction fontToSfntTable(font) {\n\t    var xMins = [];\n\t    var yMins = [];\n\t    var xMaxs = [];\n\t    var yMaxs = [];\n\t    var advanceWidths = [];\n\t    var leftSideBearings = [];\n\t    var rightSideBearings = [];\n\t    var firstCharIndex;\n\t    var lastCharIndex = 0;\n\t    var ulUnicodeRange1 = 0;\n\t    var ulUnicodeRange2 = 0;\n\t    var ulUnicodeRange3 = 0;\n\t    var ulUnicodeRange4 = 0;\n\n\t    for (var i = 0; i < font.glyphs.length; i += 1) {\n\t        var glyph = font.glyphs.get(i);\n\t        var unicode = glyph.unicode | 0;\n\n\t        if (isNaN(glyph.advanceWidth)) {\n\t            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');\n\t        }\n\n\t        if (firstCharIndex > unicode || firstCharIndex === undefined) {\n\t            // ignore .notdef char\n\t            if (unicode > 0) {\n\t                firstCharIndex = unicode;\n\t            }\n\t        }\n\n\t        if (lastCharIndex < unicode) {\n\t            lastCharIndex = unicode;\n\t        }\n\n\t        var position = os2.getUnicodeRange(unicode);\n\t        if (position < 32) {\n\t            ulUnicodeRange1 |= 1 << position;\n\t        } else if (position < 64) {\n\t            ulUnicodeRange2 |= 1 << position - 32;\n\t        } else if (position < 96) {\n\t            ulUnicodeRange3 |= 1 << position - 64;\n\t        } else if (position < 123) {\n\t            ulUnicodeRange4 |= 1 << position - 96;\n\t        } else {\n\t            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');\n\t        }\n\t        // Skip non-important characters.\n\t        if (glyph.name === '.notdef') { continue; }\n\t        var metrics = glyph.getMetrics();\n\t        xMins.push(metrics.xMin);\n\t        yMins.push(metrics.yMin);\n\t        xMaxs.push(metrics.xMax);\n\t        yMaxs.push(metrics.yMax);\n\t        leftSideBearings.push(metrics.leftSideBearing);\n\t        rightSideBearings.push(metrics.rightSideBearing);\n\t        advanceWidths.push(glyph.advanceWidth);\n\t    }\n\n\t    var globals = {\n\t        xMin: Math.min.apply(null, xMins),\n\t        yMin: Math.min.apply(null, yMins),\n\t        xMax: Math.max.apply(null, xMaxs),\n\t        yMax: Math.max.apply(null, yMaxs),\n\t        advanceWidthMax: Math.max.apply(null, advanceWidths),\n\t        advanceWidthAvg: average(advanceWidths),\n\t        minLeftSideBearing: Math.min.apply(null, leftSideBearings),\n\t        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),\n\t        minRightSideBearing: Math.min.apply(null, rightSideBearings)\n\t    };\n\t    globals.ascender = font.ascender;\n\t    globals.descender = font.descender;\n\n\t    var headTable = head.make({\n\t        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)\n\t        unitsPerEm: font.unitsPerEm,\n\t        xMin: globals.xMin,\n\t        yMin: globals.yMin,\n\t        xMax: globals.xMax,\n\t        yMax: globals.yMax,\n\t        lowestRecPPEM: 3,\n\t        createdTimestamp: font.createdTimestamp\n\t    });\n\n\t    var hheaTable = hhea.make({\n\t        ascender: globals.ascender,\n\t        descender: globals.descender,\n\t        advanceWidthMax: globals.advanceWidthMax,\n\t        minLeftSideBearing: globals.minLeftSideBearing,\n\t        minRightSideBearing: globals.minRightSideBearing,\n\t        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),\n\t        numberOfHMetrics: font.glyphs.length\n\t    });\n\n\t    var maxpTable = maxp.make(font.glyphs.length);\n\n\t    var os2Table = os2.make({\n\t        xAvgCharWidth: Math.round(globals.advanceWidthAvg),\n\t        usWeightClass: font.tables.os2.usWeightClass,\n\t        usWidthClass: font.tables.os2.usWidthClass,\n\t        usFirstCharIndex: firstCharIndex,\n\t        usLastCharIndex: lastCharIndex,\n\t        ulUnicodeRange1: ulUnicodeRange1,\n\t        ulUnicodeRange2: ulUnicodeRange2,\n\t        ulUnicodeRange3: ulUnicodeRange3,\n\t        ulUnicodeRange4: ulUnicodeRange4,\n\t        fsSelection: font.tables.os2.fsSelection, // REGULAR\n\t        // See http://typophile.com/node/13081 for more info on vertical metrics.\n\t        // We get metrics for typical characters (such as \"x\" for xHeight).\n\t        // We provide some fallback characters if characters are unavailable: their\n\t        // ordering was chosen experimentally.\n\t        sTypoAscender: globals.ascender,\n\t        sTypoDescender: globals.descender,\n\t        sTypoLineGap: 0,\n\t        usWinAscent: globals.yMax,\n\t        usWinDescent: Math.abs(globals.yMin),\n\t        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now\n\t        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,\n\t        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,\n\t        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.\n\t        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.\n\t    });\n\n\t    var hmtxTable = hmtx.make(font.glyphs);\n\t    var cmapTable = cmap.make(font.glyphs);\n\n\t    var englishFamilyName = font.getEnglishName('fontFamily');\n\t    var englishStyleName = font.getEnglishName('fontSubfamily');\n\t    var englishFullName = englishFamilyName + ' ' + englishStyleName;\n\t    var postScriptName = font.getEnglishName('postScriptName');\n\t    if (!postScriptName) {\n\t        postScriptName = englishFamilyName.replace(/\\s/g, '') + '-' + englishStyleName;\n\t    }\n\n\t    var names = {};\n\t    for (var n in font.names) {\n\t        names[n] = font.names[n];\n\t    }\n\n\t    if (!names.uniqueID) {\n\t        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};\n\t    }\n\n\t    if (!names.postScriptName) {\n\t        names.postScriptName = {en: postScriptName};\n\t    }\n\n\t    if (!names.preferredFamily) {\n\t        names.preferredFamily = font.names.fontFamily;\n\t    }\n\n\t    if (!names.preferredSubfamily) {\n\t        names.preferredSubfamily = font.names.fontSubfamily;\n\t    }\n\n\t    var languageTags = [];\n\t    var nameTable = _name.make(names, languageTags);\n\t    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);\n\n\t    var postTable = post.make();\n\t    var cffTable = cff.make(font.glyphs, {\n\t        version: font.getEnglishName('version'),\n\t        fullName: englishFullName,\n\t        familyName: englishFamilyName,\n\t        weightName: englishStyleName,\n\t        postScriptName: postScriptName,\n\t        unitsPerEm: font.unitsPerEm,\n\t        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]\n\t    });\n\n\t    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;\n\n\t    // The order does not matter because makeSfntTable() will sort them.\n\t    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];\n\t    if (ltagTable) {\n\t        tables.push(ltagTable);\n\t    }\n\t    // Optional tables\n\t    if (font.tables.gsub) {\n\t        tables.push(gsub.make(font.tables.gsub));\n\t    }\n\t    if (metaTable) {\n\t        tables.push(metaTable);\n\t    }\n\n\t    var sfntTable = makeSfntTable(tables);\n\n\t    // Compute the font's checkSum and store it in head.checkSumAdjustment.\n\t    var bytes = sfntTable.encode();\n\t    var checkSum = computeCheckSum(bytes);\n\t    var tableFields = sfntTable.fields;\n\t    var checkSumAdjusted = false;\n\t    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {\n\t        if (tableFields[i$1].name === 'head table') {\n\t            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;\n\t            checkSumAdjusted = true;\n\t            break;\n\t        }\n\t    }\n\n\t    if (!checkSumAdjusted) {\n\t        throw new Error('Could not find head table with checkSum to adjust.');\n\t    }\n\n\t    return sfntTable;\n\t}\n\n\tvar sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };\n\n\t// The Layout object is the prototype of Substitution objects, and provides\n\n\tfunction searchTag(arr, tag) {\n\t    /* jshint bitwise: false */\n\t    var imin = 0;\n\t    var imax = arr.length - 1;\n\t    while (imin <= imax) {\n\t        var imid = (imin + imax) >>> 1;\n\t        var val = arr[imid].tag;\n\t        if (val === tag) {\n\t            return imid;\n\t        } else if (val < tag) {\n\t            imin = imid + 1;\n\t        } else { imax = imid - 1; }\n\t    }\n\t    // Not found: return -1-insertion point\n\t    return -imin - 1;\n\t}\n\n\tfunction binSearch(arr, value) {\n\t    /* jshint bitwise: false */\n\t    var imin = 0;\n\t    var imax = arr.length - 1;\n\t    while (imin <= imax) {\n\t        var imid = (imin + imax) >>> 1;\n\t        var val = arr[imid];\n\t        if (val === value) {\n\t            return imid;\n\t        } else if (val < value) {\n\t            imin = imid + 1;\n\t        } else { imax = imid - 1; }\n\t    }\n\t    // Not found: return -1-insertion point\n\t    return -imin - 1;\n\t}\n\n\t// binary search in a list of ranges (coverage, class definition)\n\tfunction searchRange(ranges, value) {\n\t    // jshint bitwise: false\n\t    var range;\n\t    var imin = 0;\n\t    var imax = ranges.length - 1;\n\t    while (imin <= imax) {\n\t        var imid = (imin + imax) >>> 1;\n\t        range = ranges[imid];\n\t        var start = range.start;\n\t        if (start === value) {\n\t            return range;\n\t        } else if (start < value) {\n\t            imin = imid + 1;\n\t        } else { imax = imid - 1; }\n\t    }\n\t    if (imin > 0) {\n\t        range = ranges[imin - 1];\n\t        if (value > range.end) { return 0; }\n\t        return range;\n\t    }\n\t}\n\n\t/**\n\t * @exports opentype.Layout\n\t * @class\n\t */\n\tfunction Layout(font, tableName) {\n\t    this.font = font;\n\t    this.tableName = tableName;\n\t}\n\n\tLayout.prototype = {\n\n\t    /**\n\t     * Binary search an object by \"tag\" property\n\t     * @instance\n\t     * @function searchTag\n\t     * @memberof opentype.Layout\n\t     * @param  {Array} arr\n\t     * @param  {string} tag\n\t     * @return {number}\n\t     */\n\t    searchTag: searchTag,\n\n\t    /**\n\t     * Binary search in a list of numbers\n\t     * @instance\n\t     * @function binSearch\n\t     * @memberof opentype.Layout\n\t     * @param  {Array} arr\n\t     * @param  {number} value\n\t     * @return {number}\n\t     */\n\t    binSearch: binSearch,\n\n\t    /**\n\t     * Get or create the Layout table (GSUB, GPOS etc).\n\t     * @param  {boolean} create - Whether to create a new one.\n\t     * @return {Object} The GSUB or GPOS table.\n\t     */\n\t    getTable: function(create) {\n\t        var layout = this.font.tables[this.tableName];\n\t        if (!layout && create) {\n\t            layout = this.font.tables[this.tableName] = this.createDefaultTable();\n\t        }\n\t        return layout;\n\t    },\n\n\t    /**\n\t     * Returns all scripts in the substitution table.\n\t     * @instance\n\t     * @return {Array}\n\t     */\n\t    getScriptNames: function() {\n\t        var layout = this.getTable();\n\t        if (!layout) { return []; }\n\t        return layout.scripts.map(function(script) {\n\t            return script.tag;\n\t        });\n\t    },\n\n\t    /**\n\t     * Returns the best bet for a script name.\n\t     * Returns 'DFLT' if it exists.\n\t     * If not, returns 'latn' if it exists.\n\t     * If neither exist, returns undefined.\n\t     */\n\t    getDefaultScriptName: function() {\n\t        var layout = this.getTable();\n\t        if (!layout) { return; }\n\t        var hasLatn = false;\n\t        for (var i = 0; i < layout.scripts.length; i++) {\n\t            var name = layout.scripts[i].tag;\n\t            if (name === 'DFLT') { return name; }\n\t            if (name === 'latn') { hasLatn = true; }\n\t        }\n\t        if (hasLatn) { return 'latn'; }\n\t    },\n\n\t    /**\n\t     * Returns all LangSysRecords in the given script.\n\t     * @instance\n\t     * @param {string} [script='DFLT']\n\t     * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n\t     * @return {Object} An object with tag and script properties.\n\t     */\n\t    getScriptTable: function(script, create) {\n\t        var layout = this.getTable(create);\n\t        if (layout) {\n\t            script = script || 'DFLT';\n\t            var scripts = layout.scripts;\n\t            var pos = searchTag(layout.scripts, script);\n\t            if (pos >= 0) {\n\t                return scripts[pos].script;\n\t            } else if (create) {\n\t                var scr = {\n\t                    tag: script,\n\t                    script: {\n\t                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},\n\t                        langSysRecords: []\n\t                    }\n\t                };\n\t                scripts.splice(-1 - pos, 0, scr);\n\t                return scr.script;\n\t            }\n\t        }\n\t    },\n\n\t    /**\n\t     * Returns a language system table\n\t     * @instance\n\t     * @param {string} [script='DFLT']\n\t     * @param {string} [language='dlft']\n\t     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n\t     * @return {Object}\n\t     */\n\t    getLangSysTable: function(script, language, create) {\n\t        var scriptTable = this.getScriptTable(script, create);\n\t        if (scriptTable) {\n\t            if (!language || language === 'dflt' || language === 'DFLT') {\n\t                return scriptTable.defaultLangSys;\n\t            }\n\t            var pos = searchTag(scriptTable.langSysRecords, language);\n\t            if (pos >= 0) {\n\t                return scriptTable.langSysRecords[pos].langSys;\n\t            } else if (create) {\n\t                var langSysRecord = {\n\t                    tag: language,\n\t                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}\n\t                };\n\t                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n\t                return langSysRecord.langSys;\n\t            }\n\t        }\n\t    },\n\n\t    /**\n\t     * Get a specific feature table.\n\t     * @instance\n\t     * @param {string} [script='DFLT']\n\t     * @param {string} [language='dlft']\n\t     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n\t     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n\t     * @return {Object}\n\t     */\n\t    getFeatureTable: function(script, language, feature, create) {\n\t        var langSysTable = this.getLangSysTable(script, language, create);\n\t        if (langSysTable) {\n\t            var featureRecord;\n\t            var featIndexes = langSysTable.featureIndexes;\n\t            var allFeatures = this.font.tables[this.tableName].features;\n\t            // The FeatureIndex array of indices is in arbitrary order,\n\t            // even if allFeatures is sorted alphabetically by feature tag.\n\t            for (var i = 0; i < featIndexes.length; i++) {\n\t                featureRecord = allFeatures[featIndexes[i]];\n\t                if (featureRecord.tag === feature) {\n\t                    return featureRecord.feature;\n\t                }\n\t            }\n\t            if (create) {\n\t                var index = allFeatures.length;\n\t                // Automatic ordering of features would require to shift feature indexes in the script list.\n\t                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');\n\t                featureRecord = {\n\t                    tag: feature,\n\t                    feature: { params: 0, lookupListIndexes: [] }\n\t                };\n\t                allFeatures.push(featureRecord);\n\t                featIndexes.push(index);\n\t                return featureRecord.feature;\n\t            }\n\t        }\n\t    },\n\n\t    /**\n\t     * Get the lookup tables of a given type for a script/language/feature.\n\t     * @instance\n\t     * @param {string} [script='DFLT']\n\t     * @param {string} [language='dlft']\n\t     * @param {string} feature - 4-letter feature code\n\t     * @param {number} lookupType - 1 to 9\n\t     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n\t     * @return {Object[]}\n\t     */\n\t    getLookupTables: function(script, language, feature, lookupType, create) {\n\t        var featureTable = this.getFeatureTable(script, language, feature, create);\n\t        var tables = [];\n\t        if (featureTable) {\n\t            var lookupTable;\n\t            var lookupListIndexes = featureTable.lookupListIndexes;\n\t            var allLookups = this.font.tables[this.tableName].lookups;\n\t            // lookupListIndexes are in no particular order, so use naive search.\n\t            for (var i = 0; i < lookupListIndexes.length; i++) {\n\t                lookupTable = allLookups[lookupListIndexes[i]];\n\t                if (lookupTable.lookupType === lookupType) {\n\t                    tables.push(lookupTable);\n\t                }\n\t            }\n\t            if (tables.length === 0 && create) {\n\t                lookupTable = {\n\t                    lookupType: lookupType,\n\t                    lookupFlag: 0,\n\t                    subtables: [],\n\t                    markFilteringSet: undefined\n\t                };\n\t                var index = allLookups.length;\n\t                allLookups.push(lookupTable);\n\t                lookupListIndexes.push(index);\n\t                return [lookupTable];\n\t            }\n\t        }\n\t        return tables;\n\t    },\n\n\t    /**\n\t     * Find a glyph in a class definition table\n\t     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table\n\t     * @param {object} classDefTable - an OpenType Layout class definition table\n\t     * @param {number} glyphIndex - the index of the glyph to find\n\t     * @returns {number} -1 if not found\n\t     */\n\t    getGlyphClass: function(classDefTable, glyphIndex) {\n\t        switch (classDefTable.format) {\n\t            case 1:\n\t                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {\n\t                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];\n\t                }\n\t                return 0;\n\t            case 2:\n\t                var range = searchRange(classDefTable.ranges, glyphIndex);\n\t                return range ? range.classId : 0;\n\t        }\n\t    },\n\n\t    /**\n\t     * Find a glyph in a coverage table\n\t     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table\n\t     * @param {object} coverageTable - an OpenType Layout coverage table\n\t     * @param {number} glyphIndex - the index of the glyph to find\n\t     * @returns {number} -1 if not found\n\t     */\n\t    getCoverageIndex: function(coverageTable, glyphIndex) {\n\t        switch (coverageTable.format) {\n\t            case 1:\n\t                var index = binSearch(coverageTable.glyphs, glyphIndex);\n\t                return index >= 0 ? index : -1;\n\t            case 2:\n\t                var range = searchRange(coverageTable.ranges, glyphIndex);\n\t                return range ? range.index + glyphIndex - range.start : -1;\n\t        }\n\t    },\n\n\t    /**\n\t     * Returns the list of glyph indexes of a coverage table.\n\t     * Format 1: the list is stored raw\n\t     * Format 2: compact list as range records.\n\t     * @instance\n\t     * @param  {Object} coverageTable\n\t     * @return {Array}\n\t     */\n\t    expandCoverage: function(coverageTable) {\n\t        if (coverageTable.format === 1) {\n\t            return coverageTable.glyphs;\n\t        } else {\n\t            var glyphs = [];\n\t            var ranges = coverageTable.ranges;\n\t            for (var i = 0; i < ranges.length; i++) {\n\t                var range = ranges[i];\n\t                var start = range.start;\n\t                var end = range.end;\n\t                for (var j = start; j <= end; j++) {\n\t                    glyphs.push(j);\n\t                }\n\t            }\n\t            return glyphs;\n\t        }\n\t    }\n\n\t};\n\n\t// The Position object provides utility methods to manipulate\n\n\t/**\n\t * @exports opentype.Position\n\t * @class\n\t * @extends opentype.Layout\n\t * @param {opentype.Font}\n\t * @constructor\n\t */\n\tfunction Position(font) {\n\t    Layout.call(this, font, 'gpos');\n\t}\n\n\tPosition.prototype = Layout.prototype;\n\n\t/**\n\t * Init some data for faster and easier access later.\n\t */\n\tPosition.prototype.init = function() {\n\t    var script = this.getDefaultScriptName();\n\t    this.defaultKerningTables = this.getKerningTables(script);\n\t};\n\n\t/**\n\t * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.\n\t *\n\t * @param {integer} leftIndex - left glyph index\n\t * @param {integer} rightIndex - right glyph index\n\t * @returns {integer}\n\t */\n\tPosition.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {\n\t    var this$1 = this;\n\n\t    for (var i = 0; i < kerningLookups.length; i++) {\n\t        var subtables = kerningLookups[i].subtables;\n\t        for (var j = 0; j < subtables.length; j++) {\n\t            var subtable = subtables[j];\n\t            var covIndex = this$1.getCoverageIndex(subtable.coverage, leftIndex);\n\t            if (covIndex < 0) { continue; }\n\t            switch (subtable.posFormat) {\n\t                case 1:\n\t                    // Search Pair Adjustment Positioning Format 1\n\t                    var pairSet = subtable.pairSets[covIndex];\n\t                    for (var k = 0; k < pairSet.length; k++) {\n\t                        var pair = pairSet[k];\n\t                        if (pair.secondGlyph === rightIndex) {\n\t                            return pair.value1 && pair.value1.xAdvance || 0;\n\t                        }\n\t                    }\n\t                    break;      // left glyph found, not right glyph - try next subtable\n\t                case 2:\n\t                    // Search Pair Adjustment Positioning Format 2\n\t                    var class1 = this$1.getGlyphClass(subtable.classDef1, leftIndex);\n\t                    var class2 = this$1.getGlyphClass(subtable.classDef2, rightIndex);\n\t                    var pair$1 = subtable.classRecords[class1][class2];\n\t                    return pair$1.value1 && pair$1.value1.xAdvance || 0;\n\t            }\n\t        }\n\t    }\n\t    return 0;\n\t};\n\n\t/**\n\t * List all kerning lookup tables.\n\t *\n\t * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value\n\t * @param {string} [language='dflt']\n\t * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)\n\t */\n\tPosition.prototype.getKerningTables = function(script, language) {\n\t    if (this.font.tables.gpos) {\n\t        return this.getLookupTables(script, language, 'kern', 2);\n\t    }\n\t};\n\n\t// The Substitution object provides utility methods to manipulate\n\n\t/**\n\t * @exports opentype.Substitution\n\t * @class\n\t * @extends opentype.Layout\n\t * @param {opentype.Font}\n\t * @constructor\n\t */\n\tfunction Substitution(font) {\n\t    Layout.call(this, font, 'gsub');\n\t}\n\n\t// Check if 2 arrays of primitives are equal.\n\tfunction arraysEqual(ar1, ar2) {\n\t    var n = ar1.length;\n\t    if (n !== ar2.length) { return false; }\n\t    for (var i = 0; i < n; i++) {\n\t        if (ar1[i] !== ar2[i]) { return false; }\n\t    }\n\t    return true;\n\t}\n\n\t// Find the first subtable of a lookup table in a particular format.\n\tfunction getSubstFormat(lookupTable, format, defaultSubtable) {\n\t    var subtables = lookupTable.subtables;\n\t    for (var i = 0; i < subtables.length; i++) {\n\t        var subtable = subtables[i];\n\t        if (subtable.substFormat === format) {\n\t            return subtable;\n\t        }\n\t    }\n\t    if (defaultSubtable) {\n\t        subtables.push(defaultSubtable);\n\t        return defaultSubtable;\n\t    }\n\t    return undefined;\n\t}\n\n\tSubstitution.prototype = Layout.prototype;\n\n\t/**\n\t * Create a default GSUB table.\n\t * @return {Object} gsub - The GSUB table.\n\t */\n\tSubstitution.prototype.createDefaultTable = function() {\n\t    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.\n\t    return {\n\t        version: 1,\n\t        scripts: [{\n\t            tag: 'DFLT',\n\t            script: {\n\t                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },\n\t                langSysRecords: []\n\t            }\n\t        }],\n\t        features: [],\n\t        lookups: []\n\t    };\n\t};\n\n\t/**\n\t * List all single substitutions (lookup type 1) for a given script, language, and feature.\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)\n\t * @return {Array} substitutions - The list of substitutions.\n\t */\n\tSubstitution.prototype.getSingle = function(feature, script, language) {\n\t    var this$1 = this;\n\n\t    var substitutions = [];\n\t    var lookupTables = this.getLookupTables(script, language, feature, 1);\n\t    for (var idx = 0; idx < lookupTables.length; idx++) {\n\t        var subtables = lookupTables[idx].subtables;\n\t        for (var i = 0; i < subtables.length; i++) {\n\t            var subtable = subtables[i];\n\t            var glyphs = this$1.expandCoverage(subtable.coverage);\n\t            var j = (void 0);\n\t            if (subtable.substFormat === 1) {\n\t                var delta = subtable.deltaGlyphId;\n\t                for (j = 0; j < glyphs.length; j++) {\n\t                    var glyph = glyphs[j];\n\t                    substitutions.push({ sub: glyph, by: glyph + delta });\n\t                }\n\t            } else {\n\t                var substitute = subtable.substitute;\n\t                for (j = 0; j < glyphs.length; j++) {\n\t                    substitutions.push({ sub: glyphs[j], by: substitute[j] });\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return substitutions;\n\t};\n\n\t/**\n\t * List all alternates (lookup type 3) for a given script, language, and feature.\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t * @param {string} feature - 4-character feature name ('aalt', 'salt'...)\n\t * @return {Array} alternates - The list of alternates\n\t */\n\tSubstitution.prototype.getAlternates = function(feature, script, language) {\n\t    var this$1 = this;\n\n\t    var alternates = [];\n\t    var lookupTables = this.getLookupTables(script, language, feature, 3);\n\t    for (var idx = 0; idx < lookupTables.length; idx++) {\n\t        var subtables = lookupTables[idx].subtables;\n\t        for (var i = 0; i < subtables.length; i++) {\n\t            var subtable = subtables[i];\n\t            var glyphs = this$1.expandCoverage(subtable.coverage);\n\t            var alternateSets = subtable.alternateSets;\n\t            for (var j = 0; j < glyphs.length; j++) {\n\t                alternates.push({ sub: glyphs[j], by: alternateSets[j] });\n\t            }\n\t        }\n\t    }\n\t    return alternates;\n\t};\n\n\t/**\n\t * List all ligatures (lookup type 4) for a given script, language, and feature.\n\t * The result is an array of ligature objects like { sub: [ids], by: id }\n\t * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t * @return {Array} ligatures - The list of ligatures.\n\t */\n\tSubstitution.prototype.getLigatures = function(feature, script, language) {\n\t    var this$1 = this;\n\n\t    var ligatures = [];\n\t    var lookupTables = this.getLookupTables(script, language, feature, 4);\n\t    for (var idx = 0; idx < lookupTables.length; idx++) {\n\t        var subtables = lookupTables[idx].subtables;\n\t        for (var i = 0; i < subtables.length; i++) {\n\t            var subtable = subtables[i];\n\t            var glyphs = this$1.expandCoverage(subtable.coverage);\n\t            var ligatureSets = subtable.ligatureSets;\n\t            for (var j = 0; j < glyphs.length; j++) {\n\t                var startGlyph = glyphs[j];\n\t                var ligSet = ligatureSets[j];\n\t                for (var k = 0; k < ligSet.length; k++) {\n\t                    var lig = ligSet[k];\n\t                    ligatures.push({\n\t                        sub: [startGlyph].concat(lig.components),\n\t                        by: lig.ligGlyph\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    }\n\t    return ligatures;\n\t};\n\n\t/**\n\t * Add or modify a single substitution (lookup type 1)\n\t * Format 2, more flexible, is always used.\n\t * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n\t * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t */\n\tSubstitution.prototype.addSingle = function(feature, substitution, script, language) {\n\t    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];\n\t    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1\n\t        substFormat: 2,\n\t        coverage: {format: 1, glyphs: []},\n\t        substitute: []\n\t    });\n\t    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);\n\t    var coverageGlyph = substitution.sub;\n\t    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n\t    if (pos < 0) {\n\t        pos = -1 - pos;\n\t        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n\t        subtable.substitute.splice(pos, 0, 0);\n\t    }\n\t    subtable.substitute[pos] = substitution.by;\n\t};\n\n\t/**\n\t * Add or modify an alternate substitution (lookup type 1)\n\t * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n\t * @param {Object} substitution - { sub: id, by: [ids] }\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t */\n\tSubstitution.prototype.addAlternate = function(feature, substitution, script, language) {\n\t    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];\n\t    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1\n\t        substFormat: 1,\n\t        coverage: {format: 1, glyphs: []},\n\t        alternateSets: []\n\t    });\n\t    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);\n\t    var coverageGlyph = substitution.sub;\n\t    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n\t    if (pos < 0) {\n\t        pos = -1 - pos;\n\t        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n\t        subtable.alternateSets.splice(pos, 0, 0);\n\t    }\n\t    subtable.alternateSets[pos] = substitution.by;\n\t};\n\n\t/**\n\t * Add a ligature (lookup type 4)\n\t * Ligatures with more components must be stored ahead of those with fewer components in order to be found\n\t * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n\t * @param {Object} ligature - { sub: [ids], by: id }\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t */\n\tSubstitution.prototype.addLigature = function(feature, ligature, script, language) {\n\t    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];\n\t    var subtable = lookupTable.subtables[0];\n\t    if (!subtable) {\n\t        subtable = {                // lookup type 4 subtable, format 1, coverage format 1\n\t            substFormat: 1,\n\t            coverage: { format: 1, glyphs: [] },\n\t            ligatureSets: []\n\t        };\n\t        lookupTable.subtables[0] = subtable;\n\t    }\n\t    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);\n\t    var coverageGlyph = ligature.sub[0];\n\t    var ligComponents = ligature.sub.slice(1);\n\t    var ligatureTable = {\n\t        ligGlyph: ligature.by,\n\t        components: ligComponents\n\t    };\n\t    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n\t    if (pos >= 0) {\n\t        // ligatureSet already exists\n\t        var ligatureSet = subtable.ligatureSets[pos];\n\t        for (var i = 0; i < ligatureSet.length; i++) {\n\t            // If ligature already exists, return.\n\t            if (arraysEqual(ligatureSet[i].components, ligComponents)) {\n\t                return;\n\t            }\n\t        }\n\t        // ligature does not exist: add it.\n\t        ligatureSet.push(ligatureTable);\n\t    } else {\n\t        // Create a new ligatureSet and add coverage for the first glyph.\n\t        pos = -1 - pos;\n\t        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n\t        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);\n\t    }\n\t};\n\n\t/**\n\t * List all feature data for a given script and language.\n\t * @param {string} feature - 4-letter feature name\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t * @return {Array} substitutions - The list of substitutions.\n\t */\n\tSubstitution.prototype.getFeature = function(feature, script, language) {\n\t    if (/ss\\d\\d/.test(feature)) {\n\t        // ss01 - ss20\n\t        return this.getSingle(feature, script, language);\n\t    }\n\t    switch (feature) {\n\t        case 'aalt':\n\t        case 'salt':\n\t            return this.getSingle(feature, script, language)\n\t                    .concat(this.getAlternates(feature, script, language));\n\t        case 'dlig':\n\t        case 'liga':\n\t        case 'rlig': return this.getLigatures(feature, script, language);\n\t    }\n\t    return undefined;\n\t};\n\n\t/**\n\t * Add a substitution to a feature for a given script and language.\n\t * @param {string} feature - 4-letter feature name\n\t * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })\n\t * @param {string} [script='DFLT']\n\t * @param {string} [language='dflt']\n\t */\n\tSubstitution.prototype.add = function(feature, sub, script, language) {\n\t    if (/ss\\d\\d/.test(feature)) {\n\t        // ss01 - ss20\n\t        return this.addSingle(feature, sub, script, language);\n\t    }\n\t    switch (feature) {\n\t        case 'aalt':\n\t        case 'salt':\n\t            if (typeof sub.by === 'number') {\n\t                return this.addSingle(feature, sub, script, language);\n\t            }\n\t            return this.addAlternate(feature, sub, script, language);\n\t        case 'dlig':\n\t        case 'liga':\n\t        case 'rlig':\n\t            return this.addLigature(feature, sub, script, language);\n\t    }\n\t    return undefined;\n\t};\n\n\tfunction isBrowser() {\n\t    return typeof window !== 'undefined';\n\t}\n\n\tfunction nodeBufferToArrayBuffer(buffer) {\n\t    var ab = new ArrayBuffer(buffer.length);\n\t    var view = new Uint8Array(ab);\n\t    for (var i = 0; i < buffer.length; ++i) {\n\t        view[i] = buffer[i];\n\t    }\n\n\t    return ab;\n\t}\n\n\tfunction arrayBufferToNodeBuffer(ab) {\n\t    var buffer = new Buffer(ab.byteLength);\n\t    var view = new Uint8Array(ab);\n\t    for (var i = 0; i < buffer.length; ++i) {\n\t        buffer[i] = view[i];\n\t    }\n\n\t    return buffer;\n\t}\n\n\tfunction checkArgument(expression, message) {\n\t    if (!expression) {\n\t        throw message;\n\t    }\n\t}\n\n\t// The `glyf` table describes the glyphs in TrueType outline format.\n\n\t// Parse the coordinate data for a glyph.\n\tfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n\t    var v;\n\t    if ((flag & shortVectorBitMask) > 0) {\n\t        // The coordinate is 1 byte long.\n\t        v = p.parseByte();\n\t        // The `same` bit is re-used for short values to signify the sign of the value.\n\t        if ((flag & sameBitMask) === 0) {\n\t            v = -v;\n\t        }\n\n\t        v = previousValue + v;\n\t    } else {\n\t        //  The coordinate is 2 bytes long.\n\t        // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n\t        if ((flag & sameBitMask) > 0) {\n\t            v = previousValue;\n\t        } else {\n\t            // Parse the coordinate as a signed 16-bit delta value.\n\t            v = previousValue + p.parseShort();\n\t        }\n\t    }\n\n\t    return v;\n\t}\n\n\t// Parse a TrueType glyph.\n\tfunction parseGlyph(glyph, data, start) {\n\t    var p = new parse.Parser(data, start);\n\t    glyph.numberOfContours = p.parseShort();\n\t    glyph._xMin = p.parseShort();\n\t    glyph._yMin = p.parseShort();\n\t    glyph._xMax = p.parseShort();\n\t    glyph._yMax = p.parseShort();\n\t    var flags;\n\t    var flag;\n\n\t    if (glyph.numberOfContours > 0) {\n\t        // This glyph is not a composite.\n\t        var endPointIndices = glyph.endPointIndices = [];\n\t        for (var i = 0; i < glyph.numberOfContours; i += 1) {\n\t            endPointIndices.push(p.parseUShort());\n\t        }\n\n\t        glyph.instructionLength = p.parseUShort();\n\t        glyph.instructions = [];\n\t        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {\n\t            glyph.instructions.push(p.parseByte());\n\t        }\n\n\t        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n\t        flags = [];\n\t        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {\n\t            flag = p.parseByte();\n\t            flags.push(flag);\n\t            // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n\t            if ((flag & 8) > 0) {\n\t                var repeatCount = p.parseByte();\n\t                for (var j = 0; j < repeatCount; j += 1) {\n\t                    flags.push(flag);\n\t                    i$2 += 1;\n\t                }\n\t            }\n\t        }\n\n\t        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n\t        if (endPointIndices.length > 0) {\n\t            var points = [];\n\t            var point;\n\t            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n\t            if (numberOfCoordinates > 0) {\n\t                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {\n\t                    flag = flags[i$3];\n\t                    point = {};\n\t                    point.onCurve = !!(flag & 1);\n\t                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;\n\t                    points.push(point);\n\t                }\n\n\t                var px = 0;\n\t                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {\n\t                    flag = flags[i$4];\n\t                    point = points[i$4];\n\t                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n\t                    px = point.x;\n\t                }\n\n\t                var py = 0;\n\t                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {\n\t                    flag = flags[i$5];\n\t                    point = points[i$5];\n\t                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n\t                    py = point.y;\n\t                }\n\t            }\n\n\t            glyph.points = points;\n\t        } else {\n\t            glyph.points = [];\n\t        }\n\t    } else if (glyph.numberOfContours === 0) {\n\t        glyph.points = [];\n\t    } else {\n\t        glyph.isComposite = true;\n\t        glyph.points = [];\n\t        glyph.components = [];\n\t        var moreComponents = true;\n\t        while (moreComponents) {\n\t            flags = p.parseUShort();\n\t            var component = {\n\t                glyphIndex: p.parseUShort(),\n\t                xScale: 1,\n\t                scale01: 0,\n\t                scale10: 0,\n\t                yScale: 1,\n\t                dx: 0,\n\t                dy: 0\n\t            };\n\t            if ((flags & 1) > 0) {\n\t                // The arguments are words\n\t                if ((flags & 2) > 0) {\n\t                    // values are offset\n\t                    component.dx = p.parseShort();\n\t                    component.dy = p.parseShort();\n\t                } else {\n\t                    // values are matched points\n\t                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n\t                }\n\n\t            } else {\n\t                // The arguments are bytes\n\t                if ((flags & 2) > 0) {\n\t                    // values are offset\n\t                    component.dx = p.parseChar();\n\t                    component.dy = p.parseChar();\n\t                } else {\n\t                    // values are matched points\n\t                    component.matchedPoints = [p.parseByte(), p.parseByte()];\n\t                }\n\t            }\n\n\t            if ((flags & 8) > 0) {\n\t                // We have a scale\n\t                component.xScale = component.yScale = p.parseF2Dot14();\n\t            } else if ((flags & 64) > 0) {\n\t                // We have an X / Y scale\n\t                component.xScale = p.parseF2Dot14();\n\t                component.yScale = p.parseF2Dot14();\n\t            } else if ((flags & 128) > 0) {\n\t                // We have a 2x2 transformation\n\t                component.xScale = p.parseF2Dot14();\n\t                component.scale01 = p.parseF2Dot14();\n\t                component.scale10 = p.parseF2Dot14();\n\t                component.yScale = p.parseF2Dot14();\n\t            }\n\n\t            glyph.components.push(component);\n\t            moreComponents = !!(flags & 32);\n\t        }\n\t        if (flags & 0x100) {\n\t            // We have instructions\n\t            glyph.instructionLength = p.parseUShort();\n\t            glyph.instructions = [];\n\t            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {\n\t                glyph.instructions.push(p.parseByte());\n\t            }\n\t        }\n\t    }\n\t}\n\n\t// Transform an array of points and return a new array.\n\tfunction transformPoints(points, transform) {\n\t    var newPoints = [];\n\t    for (var i = 0; i < points.length; i += 1) {\n\t        var pt = points[i];\n\t        var newPt = {\n\t            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n\t            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n\t            onCurve: pt.onCurve,\n\t            lastPointOfContour: pt.lastPointOfContour\n\t        };\n\t        newPoints.push(newPt);\n\t    }\n\n\t    return newPoints;\n\t}\n\n\tfunction getContours(points) {\n\t    var contours = [];\n\t    var currentContour = [];\n\t    for (var i = 0; i < points.length; i += 1) {\n\t        var pt = points[i];\n\t        currentContour.push(pt);\n\t        if (pt.lastPointOfContour) {\n\t            contours.push(currentContour);\n\t            currentContour = [];\n\t        }\n\t    }\n\n\t    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n\t    return contours;\n\t}\n\n\t// Convert the TrueType glyph outline to a Path.\n\tfunction getPath(points) {\n\t    var p = new Path();\n\t    if (!points) {\n\t        return p;\n\t    }\n\n\t    var contours = getContours(points);\n\n\t    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n\t        var contour = contours[contourIndex];\n\n\t        var prev = null;\n\t        var curr = contour[contour.length - 1];\n\t        var next = contour[0];\n\n\t        if (curr.onCurve) {\n\t            p.moveTo(curr.x, curr.y);\n\t        } else {\n\t            if (next.onCurve) {\n\t                p.moveTo(next.x, next.y);\n\t            } else {\n\t                // If both first and last points are off-curve, start at their middle.\n\t                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};\n\t                p.moveTo(start.x, start.y);\n\t            }\n\t        }\n\n\t        for (var i = 0; i < contour.length; ++i) {\n\t            prev = curr;\n\t            curr = next;\n\t            next = contour[(i + 1) % contour.length];\n\n\t            if (curr.onCurve) {\n\t                // This is a straight line.\n\t                p.lineTo(curr.x, curr.y);\n\t            } else {\n\t                var prev2 = prev;\n\t                var next2 = next;\n\n\t                if (!prev.onCurve) {\n\t                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };\n\t                }\n\n\t                if (!next.onCurve) {\n\t                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };\n\t                }\n\n\t                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n\t            }\n\t        }\n\n\t        p.closePath();\n\t    }\n\t    return p;\n\t}\n\n\tfunction buildPath(glyphs, glyph) {\n\t    if (glyph.isComposite) {\n\t        for (var j = 0; j < glyph.components.length; j += 1) {\n\t            var component = glyph.components[j];\n\t            var componentGlyph = glyphs.get(component.glyphIndex);\n\t            // Force the ttfGlyphLoader to parse the glyph.\n\t            componentGlyph.getPath();\n\t            if (componentGlyph.points) {\n\t                var transformedPoints = (void 0);\n\t                if (component.matchedPoints === undefined) {\n\t                    // component positioned by offset\n\t                    transformedPoints = transformPoints(componentGlyph.points, component);\n\t                } else {\n\t                    // component positioned by matched points\n\t                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||\n\t                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {\n\t                        throw Error('Matched points out of range in ' + glyph.name);\n\t                    }\n\t                    var firstPt = glyph.points[component.matchedPoints[0]];\n\t                    var secondPt = componentGlyph.points[component.matchedPoints[1]];\n\t                    var transform = {\n\t                        xScale: component.xScale, scale01: component.scale01,\n\t                        scale10: component.scale10, yScale: component.yScale,\n\t                        dx: 0, dy: 0\n\t                    };\n\t                    secondPt = transformPoints([secondPt], transform)[0];\n\t                    transform.dx = firstPt.x - secondPt.x;\n\t                    transform.dy = firstPt.y - secondPt.y;\n\t                    transformedPoints = transformPoints(componentGlyph.points, transform);\n\t                }\n\t                glyph.points = glyph.points.concat(transformedPoints);\n\t            }\n\t        }\n\t    }\n\n\t    return getPath(glyph.points);\n\t}\n\n\t// Parse all the glyphs according to the offsets from the `loca` table.\n\tfunction parseGlyfTable(data, start, loca, font) {\n\t    var glyphs = new glyphset.GlyphSet(font);\n\n\t    // The last element of the loca table is invalid.\n\t    for (var i = 0; i < loca.length - 1; i += 1) {\n\t        var offset = loca[i];\n\t        var nextOffset = loca[i + 1];\n\t        if (offset !== nextOffset) {\n\t            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));\n\t        } else {\n\t            glyphs.push(i, glyphset.glyphLoader(font, i));\n\t        }\n\t    }\n\n\t    return glyphs;\n\t}\n\n\tvar glyf = { getPath: getPath, parse: parseGlyfTable };\n\n\t/* A TrueType font hinting interpreter.\n\t*\n\t* (c) 2017 Axel Kittenberger\n\t*\n\t* This interpreter has been implemented according to this documentation:\n\t* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n\t*\n\t* According to the documentation F24DOT6 values are used for pixels.\n\t* That means calculation is 1/64 pixel accurate and uses integer operations.\n\t* However, Javascript has floating point operations by default and only\n\t* those are available. One could make a case to simulate the 1/64 accuracy\n\t* exactly by truncating after every division operation\n\t* (for example with << 0) to get pixel exactly results as other TrueType\n\t* implementations. It may make sense since some fonts are pixel optimized\n\t* by hand using DELTAP instructions. The current implementation doesn't\n\t* and rather uses full floating point precision.\n\t*\n\t* xScale, yScale and rotation is currently ignored.\n\t*\n\t* A few non-trivial instructions are missing as I didn't encounter yet\n\t* a font that used them to test a possible implementation.\n\t*\n\t* Some fonts seem to use undocumented features regarding the twilight zone.\n\t* Only some of them are implemented as they were encountered.\n\t*\n\t* The exports.DEBUG statements are removed on the minified distribution file.\n\t*/\n\n\tvar instructionTable;\n\tvar exec;\n\tvar execGlyph;\n\tvar execComponent;\n\n\t/*\n\t* Creates a hinting object.\n\t*\n\t* There ought to be exactly one\n\t* for each truetype font that is used for hinting.\n\t*/\n\tfunction Hinting(font) {\n\t    // the font this hinting object is for\n\t    this.font = font;\n\n\t    this.getCommands = function (hPoints) {\n\t        return glyf.getPath(hPoints).commands;\n\t    };\n\n\t    // cached states\n\t    this._fpgmState  =\n\t    this._prepState  =\n\t        undefined;\n\n\t    // errorState\n\t    // 0 ... all okay\n\t    // 1 ... had an error in a glyf,\n\t    //       continue working but stop spamming\n\t    //       the console\n\t    // 2 ... error at prep, stop hinting at this ppem\n\t    // 3 ... error at fpeg, stop hinting for this font at all\n\t    this._errorState = 0;\n\t}\n\n\t/*\n\t* Not rounding.\n\t*/\n\tfunction roundOff(v) {\n\t    return v;\n\t}\n\n\t/*\n\t* Rounding to grid.\n\t*/\n\tfunction roundToGrid(v) {\n\t    //Rounding in TT is supposed to \"symmetrical around zero\"\n\t    return Math.sign(v) * Math.round(Math.abs(v));\n\t}\n\n\t/*\n\t* Rounding to double grid.\n\t*/\n\tfunction roundToDoubleGrid(v) {\n\t    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n\t}\n\n\t/*\n\t* Rounding to half grid.\n\t*/\n\tfunction roundToHalfGrid(v) {\n\t    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n\t}\n\n\t/*\n\t* Rounding to up to grid.\n\t*/\n\tfunction roundUpToGrid(v) {\n\t    return Math.sign(v) * Math.ceil(Math.abs(v));\n\t}\n\n\t/*\n\t* Rounding to down to grid.\n\t*/\n\tfunction roundDownToGrid(v) {\n\t    return Math.sign(v) * Math.floor(Math.abs(v));\n\t}\n\n\t/*\n\t* Super rounding.\n\t*/\n\tvar roundSuper = function (v) {\n\t    var period = this.srPeriod;\n\t    var phase = this.srPhase;\n\t    var threshold = this.srThreshold;\n\t    var sign = 1;\n\n\t    if (v < 0) {\n\t        v = -v;\n\t        sign = -1;\n\t    }\n\n\t    v += threshold - phase;\n\n\t    v = Math.trunc(v / period) * period;\n\n\t    v += phase;\n\n\t    // according to http://xgridfit.sourceforge.net/round.html\n\t    if (v < 0) { return phase * sign; }\n\n\t    return v * sign;\n\t};\n\n\t/*\n\t* Unit vector of x-axis.\n\t*/\n\tvar xUnitVector = {\n\t    x: 1,\n\n\t    y: 0,\n\n\t    axis: 'x',\n\n\t    // Gets the projected distance between two points.\n\t    // o1/o2 ... if true, respective original position is used.\n\t    distance: function (p1, p2, o1, o2) {\n\t        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n\t    },\n\n\t    // Moves point p so the moved position has the same relative\n\t    // position to the moved positions of rp1 and rp2 than the\n\t    // original positions had.\n\t    //\n\t    // See APPENDIX on INTERPOLATE at the bottom of this file.\n\t    interpolate: function (p, rp1, rp2, pv) {\n\t        var do1;\n\t        var do2;\n\t        var doa1;\n\t        var doa2;\n\t        var dm1;\n\t        var dm2;\n\t        var dt;\n\n\t        if (!pv || pv === this) {\n\t            do1 = p.xo - rp1.xo;\n\t            do2 = p.xo - rp2.xo;\n\t            dm1 = rp1.x - rp1.xo;\n\t            dm2 = rp2.x - rp2.xo;\n\t            doa1 = Math.abs(do1);\n\t            doa2 = Math.abs(do2);\n\t            dt = doa1 + doa2;\n\n\t            if (dt === 0) {\n\t                p.x = p.xo + (dm1 + dm2) / 2;\n\t                return;\n\t            }\n\n\t            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n\t            return;\n\t        }\n\n\t        do1 = pv.distance(p, rp1, true, true);\n\t        do2 = pv.distance(p, rp2, true, true);\n\t        dm1 = pv.distance(rp1, rp1, false, true);\n\t        dm2 = pv.distance(rp2, rp2, false, true);\n\t        doa1 = Math.abs(do1);\n\t        doa2 = Math.abs(do2);\n\t        dt = doa1 + doa2;\n\n\t        if (dt === 0) {\n\t            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n\t            return;\n\t        }\n\n\t        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n\t    },\n\n\t    // Slope of line normal to this\n\t    normalSlope: Number.NEGATIVE_INFINITY,\n\n\t    // Sets the point 'p' relative to point 'rp'\n\t    // by the distance 'd'.\n\t    //\n\t    // See APPENDIX on SETRELATIVE at the bottom of this file.\n\t    //\n\t    // p   ... point to set\n\t    // rp  ... reference point\n\t    // d   ... distance on projection vector\n\t    // pv  ... projection vector (undefined = this)\n\t    // org ... if true, uses the original position of rp as reference.\n\t    setRelative: function (p, rp, d, pv, org) {\n\t        if (!pv || pv === this) {\n\t            p.x = (org ? rp.xo : rp.x) + d;\n\t            return;\n\t        }\n\n\t        var rpx = org ? rp.xo : rp.x;\n\t        var rpy = org ? rp.yo : rp.y;\n\t        var rpdx = rpx + d * pv.x;\n\t        var rpdy = rpy + d * pv.y;\n\n\t        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n\t    },\n\n\t    // Slope of vector line.\n\t    slope: 0,\n\n\t    // Touches the point p.\n\t    touch: function (p) {\n\t        p.xTouched = true;\n\t    },\n\n\t    // Tests if a point p is touched.\n\t    touched: function (p) {\n\t        return p.xTouched;\n\t    },\n\n\t    // Untouches the point p.\n\t    untouch: function (p) {\n\t        p.xTouched = false;\n\t    }\n\t};\n\n\t/*\n\t* Unit vector of y-axis.\n\t*/\n\tvar yUnitVector = {\n\t    x: 0,\n\n\t    y: 1,\n\n\t    axis: 'y',\n\n\t    // Gets the projected distance between two points.\n\t    // o1/o2 ... if true, respective original position is used.\n\t    distance: function (p1, p2, o1, o2) {\n\t        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n\t    },\n\n\t    // Moves point p so the moved position has the same relative\n\t    // position to the moved positions of rp1 and rp2 than the\n\t    // original positions had.\n\t    //\n\t    // See APPENDIX on INTERPOLATE at the bottom of this file.\n\t    interpolate: function (p, rp1, rp2, pv) {\n\t        var do1;\n\t        var do2;\n\t        var doa1;\n\t        var doa2;\n\t        var dm1;\n\t        var dm2;\n\t        var dt;\n\n\t        if (!pv || pv === this) {\n\t            do1 = p.yo - rp1.yo;\n\t            do2 = p.yo - rp2.yo;\n\t            dm1 = rp1.y - rp1.yo;\n\t            dm2 = rp2.y - rp2.yo;\n\t            doa1 = Math.abs(do1);\n\t            doa2 = Math.abs(do2);\n\t            dt = doa1 + doa2;\n\n\t            if (dt === 0) {\n\t                p.y = p.yo + (dm1 + dm2) / 2;\n\t                return;\n\t            }\n\n\t            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n\t            return;\n\t        }\n\n\t        do1 = pv.distance(p, rp1, true, true);\n\t        do2 = pv.distance(p, rp2, true, true);\n\t        dm1 = pv.distance(rp1, rp1, false, true);\n\t        dm2 = pv.distance(rp2, rp2, false, true);\n\t        doa1 = Math.abs(do1);\n\t        doa2 = Math.abs(do2);\n\t        dt = doa1 + doa2;\n\n\t        if (dt === 0) {\n\t            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n\t            return;\n\t        }\n\n\t        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n\t    },\n\n\t    // Slope of line normal to this.\n\t    normalSlope: 0,\n\n\t    // Sets the point 'p' relative to point 'rp'\n\t    // by the distance 'd'\n\t    //\n\t    // See APPENDIX on SETRELATIVE at the bottom of this file.\n\t    //\n\t    // p   ... point to set\n\t    // rp  ... reference point\n\t    // d   ... distance on projection vector\n\t    // pv  ... projection vector (undefined = this)\n\t    // org ... if true, uses the original position of rp as reference.\n\t    setRelative: function (p, rp, d, pv, org) {\n\t        if (!pv || pv === this) {\n\t            p.y = (org ? rp.yo : rp.y) + d;\n\t            return;\n\t        }\n\n\t        var rpx = org ? rp.xo : rp.x;\n\t        var rpy = org ? rp.yo : rp.y;\n\t        var rpdx = rpx + d * pv.x;\n\t        var rpdy = rpy + d * pv.y;\n\n\t        p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n\t    },\n\n\t    // Slope of vector line.\n\t    slope: Number.POSITIVE_INFINITY,\n\n\t    // Touches the point p.\n\t    touch: function (p) {\n\t        p.yTouched = true;\n\t    },\n\n\t    // Tests if a point p is touched.\n\t    touched: function (p) {\n\t        return p.yTouched;\n\t    },\n\n\t    // Untouches the point p.\n\t    untouch: function (p) {\n\t        p.yTouched = false;\n\t    }\n\t};\n\n\tObject.freeze(xUnitVector);\n\tObject.freeze(yUnitVector);\n\n\t/*\n\t* Creates a unit vector that is not x- or y-axis.\n\t*/\n\tfunction UnitVector(x, y) {\n\t    this.x = x;\n\t    this.y = y;\n\t    this.axis = undefined;\n\t    this.slope = y / x;\n\t    this.normalSlope = -x / y;\n\t    Object.freeze(this);\n\t}\n\n\t/*\n\t* Gets the projected distance between two points.\n\t* o1/o2 ... if true, respective original position is used.\n\t*/\n\tUnitVector.prototype.distance = function(p1, p2, o1, o2) {\n\t    return (\n\t        this.x * xUnitVector.distance(p1, p2, o1, o2) +\n\t        this.y * yUnitVector.distance(p1, p2, o1, o2)\n\t    );\n\t};\n\n\t/*\n\t* Moves point p so the moved position has the same relative\n\t* position to the moved positions of rp1 and rp2 than the\n\t* original positions had.\n\t*\n\t* See APPENDIX on INTERPOLATE at the bottom of this file.\n\t*/\n\tUnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {\n\t    var dm1;\n\t    var dm2;\n\t    var do1;\n\t    var do2;\n\t    var doa1;\n\t    var doa2;\n\t    var dt;\n\n\t    do1 = pv.distance(p, rp1, true, true);\n\t    do2 = pv.distance(p, rp2, true, true);\n\t    dm1 = pv.distance(rp1, rp1, false, true);\n\t    dm2 = pv.distance(rp2, rp2, false, true);\n\t    doa1 = Math.abs(do1);\n\t    doa2 = Math.abs(do2);\n\t    dt = doa1 + doa2;\n\n\t    if (dt === 0) {\n\t        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n\t        return;\n\t    }\n\n\t    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n\t};\n\n\t/*\n\t* Sets the point 'p' relative to point 'rp'\n\t* by the distance 'd'\n\t*\n\t* See APPENDIX on SETRELATIVE at the bottom of this file.\n\t*\n\t* p   ...  point to set\n\t* rp  ... reference point\n\t* d   ... distance on projection vector\n\t* pv  ... projection vector (undefined = this)\n\t* org ... if true, uses the original position of rp as reference.\n\t*/\n\tUnitVector.prototype.setRelative = function(p, rp, d, pv, org) {\n\t    pv = pv || this;\n\n\t    var rpx = org ? rp.xo : rp.x;\n\t    var rpy = org ? rp.yo : rp.y;\n\t    var rpdx = rpx + d * pv.x;\n\t    var rpdy = rpy + d * pv.y;\n\n\t    var pvns = pv.normalSlope;\n\t    var fvs = this.slope;\n\n\t    var px = p.x;\n\t    var py = p.y;\n\n\t    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n\t    p.y = fvs * (p.x - px) + py;\n\t};\n\n\t/*\n\t* Touches the point p.\n\t*/\n\tUnitVector.prototype.touch = function(p) {\n\t    p.xTouched = true;\n\t    p.yTouched = true;\n\t};\n\n\t/*\n\t* Returns a unit vector with x/y coordinates.\n\t*/\n\tfunction getUnitVector(x, y) {\n\t    var d = Math.sqrt(x * x + y * y);\n\n\t    x /= d;\n\t    y /= d;\n\n\t    if (x === 1 && y === 0) { return xUnitVector; }\n\t    else if (x === 0 && y === 1) { return yUnitVector; }\n\t    else { return new UnitVector(x, y); }\n\t}\n\n\t/*\n\t* Creates a point in the hinting engine.\n\t*/\n\tfunction HPoint(\n\t    x,\n\t    y,\n\t    lastPointOfContour,\n\t    onCurve\n\t) {\n\t    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n\t    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n\t    this.lastPointOfContour = lastPointOfContour;\n\t    this.onCurve = onCurve;\n\t    this.prevPointOnContour = undefined;\n\t    this.nextPointOnContour = undefined;\n\t    this.xTouched = false;\n\t    this.yTouched = false;\n\n\t    Object.preventExtensions(this);\n\t}\n\n\t/*\n\t* Returns the next touched point on the contour.\n\t*\n\t* v  ... unit vector to test touch axis.\n\t*/\n\tHPoint.prototype.nextTouched = function(v) {\n\t    var p = this.nextPointOnContour;\n\n\t    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }\n\n\t    return p;\n\t};\n\n\t/*\n\t* Returns the previous touched point on the contour\n\t*\n\t* v  ... unit vector to test touch axis.\n\t*/\n\tHPoint.prototype.prevTouched = function(v) {\n\t    var p = this.prevPointOnContour;\n\n\t    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }\n\n\t    return p;\n\t};\n\n\t/*\n\t* The zero point.\n\t*/\n\tvar HPZero = Object.freeze(new HPoint(0, 0));\n\n\t/*\n\t* The default state of the interpreter.\n\t*\n\t* Note: Freezing the defaultState and then deriving from it\n\t* makes the V8 Javascript engine going awkward,\n\t* so this is avoided, albeit the defaultState shouldn't\n\t* ever change.\n\t*/\n\tvar defaultState = {\n\t    cvCutIn: 17 / 16,    // control value cut in\n\t    deltaBase: 9,\n\t    deltaShift: 0.125,\n\t    loop: 1,             // loops some instructions\n\t    minDis: 1,           // minimum distance\n\t    autoFlip: true\n\t};\n\n\t/*\n\t* The current state of the interpreter.\n\t*\n\t* env  ... 'fpgm' or 'prep' or 'glyf'\n\t* prog ... the program\n\t*/\n\tfunction State(env, prog) {\n\t    this.env = env;\n\t    this.stack = [];\n\t    this.prog = prog;\n\n\t    switch (env) {\n\t        case 'glyf' :\n\t            this.zp0 = this.zp1 = this.zp2 = 1;\n\t            this.rp0 = this.rp1 = this.rp2 = 0;\n\t            /* fall through */\n\t        case 'prep' :\n\t            this.fv = this.pv = this.dpv = xUnitVector;\n\t            this.round = roundToGrid;\n\t    }\n\t}\n\n\t/*\n\t* Executes a glyph program.\n\t*\n\t* This does the hinting for each glyph.\n\t*\n\t* Returns an array of moved points.\n\t*\n\t* glyph: the glyph to hint\n\t* ppem: the size the glyph is rendered for\n\t*/\n\tHinting.prototype.exec = function(glyph, ppem) {\n\t    if (typeof ppem !== 'number') {\n\t        throw new Error('Point size is not a number!');\n\t    }\n\n\t    // Received a fatal error, don't do any hinting anymore.\n\t    if (this._errorState > 2) { return; }\n\n\t    var font = this.font;\n\t    var prepState = this._prepState;\n\n\t    if (!prepState || prepState.ppem !== ppem) {\n\t        var fpgmState = this._fpgmState;\n\n\t        if (!fpgmState) {\n\t            // Executes the fpgm state.\n\t            // This is used by fonts to define functions.\n\t            State.prototype = defaultState;\n\n\t            fpgmState =\n\t            this._fpgmState =\n\t                new State('fpgm', font.tables.fpgm);\n\n\t            fpgmState.funcs = [ ];\n\t            fpgmState.font = font;\n\n\t            if (exports.DEBUG) {\n\t                console.log('---EXEC FPGM---');\n\t                fpgmState.step = -1;\n\t            }\n\n\t            try {\n\t                exec(fpgmState);\n\t            } catch (e) {\n\t                console.log('Hinting error in FPGM:' + e);\n\t                this._errorState = 3;\n\t                return;\n\t            }\n\t        }\n\n\t        // Executes the prep program for this ppem setting.\n\t        // This is used by fonts to set cvt values\n\t        // depending on to be rendered font size.\n\n\t        State.prototype = fpgmState;\n\t        prepState =\n\t        this._prepState =\n\t            new State('prep', font.tables.prep);\n\n\t        prepState.ppem = ppem;\n\n\t        // Creates a copy of the cvt table\n\t        // and scales it to the current ppem setting.\n\t        var oCvt = font.tables.cvt;\n\t        if (oCvt) {\n\t            var cvt = prepState.cvt = new Array(oCvt.length);\n\t            var scale = ppem / font.unitsPerEm;\n\t            for (var c = 0; c < oCvt.length; c++) {\n\t                cvt[c] = oCvt[c] * scale;\n\t            }\n\t        } else {\n\t            prepState.cvt = [];\n\t        }\n\n\t        if (exports.DEBUG) {\n\t            console.log('---EXEC PREP---');\n\t            prepState.step = -1;\n\t        }\n\n\t        try {\n\t            exec(prepState);\n\t        } catch (e) {\n\t            if (this._errorState < 2) {\n\t                console.log('Hinting error in PREP:' + e);\n\t            }\n\t            this._errorState = 2;\n\t        }\n\t    }\n\n\t    if (this._errorState > 1) { return; }\n\n\t    try {\n\t        return execGlyph(glyph, prepState);\n\t    } catch (e) {\n\t        if (this._errorState < 1) {\n\t            console.log('Hinting error:' + e);\n\t            console.log('Note: further hinting errors are silenced');\n\t        }\n\t        this._errorState = 1;\n\t        return undefined;\n\t    }\n\t};\n\n\t/*\n\t* Executes the hinting program for a glyph.\n\t*/\n\texecGlyph = function(glyph, prepState) {\n\t    // original point positions\n\t    var xScale = prepState.ppem / prepState.font.unitsPerEm;\n\t    var yScale = xScale;\n\t    var components = glyph.components;\n\t    var contours;\n\t    var gZone;\n\t    var state;\n\n\t    State.prototype = prepState;\n\t    if (!components) {\n\t        state = new State('glyf', glyph.instructions);\n\t        if (exports.DEBUG) {\n\t            console.log('---EXEC GLYPH---');\n\t            state.step = -1;\n\t        }\n\t        execComponent(glyph, state, xScale, yScale);\n\t        gZone = state.gZone;\n\t    } else {\n\t        var font = prepState.font;\n\t        gZone = [];\n\t        contours = [];\n\t        for (var i = 0; i < components.length; i++) {\n\t            var c = components[i];\n\t            var cg = font.glyphs.get(c.glyphIndex);\n\n\t            state = new State('glyf', cg.instructions);\n\n\t            if (exports.DEBUG) {\n\t                console.log('---EXEC COMP ' + i + '---');\n\t                state.step = -1;\n\t            }\n\n\t            execComponent(cg, state, xScale, yScale);\n\t            // appends the computed points to the result array\n\t            // post processes the component points\n\t            var dx = Math.round(c.dx * xScale);\n\t            var dy = Math.round(c.dy * yScale);\n\t            var gz = state.gZone;\n\t            var cc = state.contours;\n\t            for (var pi = 0; pi < gz.length; pi++) {\n\t                var p = gz[pi];\n\t                p.xTouched = p.yTouched = false;\n\t                p.xo = p.x = p.x + dx;\n\t                p.yo = p.y = p.y + dy;\n\t            }\n\n\t            var gLen = gZone.length;\n\t            gZone.push.apply(gZone, gz);\n\t            for (var j = 0; j < cc.length; j++) {\n\t                contours.push(cc[j] + gLen);\n\t            }\n\t        }\n\n\t        if (glyph.instructions && !state.inhibitGridFit) {\n\t            // the composite has instructions on its own\n\t            state = new State('glyf', glyph.instructions);\n\n\t            state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n\n\t            state.contours = contours;\n\n\t            // note: HPZero cannot be used here, since\n\t            //       the point might be modified\n\t            gZone.push(\n\t                new HPoint(0, 0),\n\t                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n\t            );\n\n\t            if (exports.DEBUG) {\n\t                console.log('---EXEC COMPOSITE---');\n\t                state.step = -1;\n\t            }\n\n\t            exec(state);\n\n\t            gZone.length -= 2;\n\t        }\n\t    }\n\n\t    return gZone;\n\t};\n\n\t/*\n\t* Executes the hinting program for a component of a multi-component glyph\n\t* or of the glyph itself for a non-component glyph.\n\t*/\n\texecComponent = function(glyph, state, xScale, yScale)\n\t{\n\t    var points = glyph.points || [];\n\t    var pLen = points.length;\n\t    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n\t    var contours = state.contours = [];\n\n\t    // Scales the original points and\n\t    // makes copies for the hinted points.\n\t    var cp; // current point\n\t    for (var i = 0; i < pLen; i++) {\n\t        cp = points[i];\n\n\t        gZone[i] = new HPoint(\n\t            cp.x * xScale,\n\t            cp.y * yScale,\n\t            cp.lastPointOfContour,\n\t            cp.onCurve\n\t        );\n\t    }\n\n\t    // Chain links the contours.\n\t    var sp; // start point\n\t    var np; // next point\n\n\t    for (var i$1 = 0; i$1 < pLen; i$1++) {\n\t        cp = gZone[i$1];\n\n\t        if (!sp) {\n\t            sp = cp;\n\t            contours.push(i$1);\n\t        }\n\n\t        if (cp.lastPointOfContour) {\n\t            cp.nextPointOnContour = sp;\n\t            sp.prevPointOnContour = cp;\n\t            sp = undefined;\n\t        } else {\n\t            np = gZone[i$1 + 1];\n\t            cp.nextPointOnContour = np;\n\t            np.prevPointOnContour = cp;\n\t        }\n\t    }\n\n\t    if (state.inhibitGridFit) { return; }\n\n\t    if (exports.DEBUG) {\n\t        console.log('PROCESSING GLYPH', state.stack);\n\t        for (var i$2 = 0; i$2 < pLen; i$2++) {\n\t            console.log(i$2, gZone[i$2].x, gZone[i$2].y);\n\t        }\n\t    }\n\n\t    gZone.push(\n\t        new HPoint(0, 0),\n\t        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n\t    );\n\n\t    exec(state);\n\n\t    // Removes the extra points.\n\t    gZone.length -= 2;\n\n\t    if (exports.DEBUG) {\n\t        console.log('FINISHED GLYPH', state.stack);\n\t        for (var i$3 = 0; i$3 < pLen; i$3++) {\n\t            console.log(i$3, gZone[i$3].x, gZone[i$3].y);\n\t        }\n\t    }\n\t};\n\n\t/*\n\t* Executes the program loaded in state.\n\t*/\n\texec = function(state) {\n\t    var prog = state.prog;\n\n\t    if (!prog) { return; }\n\n\t    var pLen = prog.length;\n\t    var ins;\n\n\t    for (state.ip = 0; state.ip < pLen; state.ip++) {\n\t        if (exports.DEBUG) { state.step++; }\n\t        ins = instructionTable[prog[state.ip]];\n\n\t        if (!ins) {\n\t            throw new Error(\n\t                'unknown instruction: 0x' +\n\t                Number(prog[state.ip]).toString(16)\n\t            );\n\t        }\n\n\t        ins(state);\n\n\t        // very extensive debugging for each step\n\t        /*\n\t        if (exports.DEBUG) {\n\t            var da;\n\t            if (state.gZone) {\n\t                da = [];\n\t                for (let i = 0; i < state.gZone.length; i++)\n\t                {\n\t                    da.push(i + ' ' +\n\t                        state.gZone[i].x * 64 + ' ' +\n\t                        state.gZone[i].y * 64 + ' ' +\n\t                        (state.gZone[i].xTouched ? 'x' : '') +\n\t                        (state.gZone[i].yTouched ? 'y' : '')\n\t                    );\n\t                }\n\t                console.log('GZ', da);\n\t            }\n\n\t            if (state.tZone) {\n\t                da = [];\n\t                for (let i = 0; i < state.tZone.length; i++) {\n\t                    da.push(i + ' ' +\n\t                        state.tZone[i].x * 64 + ' ' +\n\t                        state.tZone[i].y * 64 + ' ' +\n\t                        (state.tZone[i].xTouched ? 'x' : '') +\n\t                        (state.tZone[i].yTouched ? 'y' : '')\n\t                    );\n\t                }\n\t                console.log('TZ', da);\n\t            }\n\n\t            if (state.stack.length > 10) {\n\t                console.log(\n\t                    state.stack.length,\n\t                    '...', state.stack.slice(state.stack.length - 10)\n\t                );\n\t            } else {\n\t                console.log(state.stack.length, state.stack);\n\t            }\n\t        }\n\t        */\n\t    }\n\t};\n\n\t/*\n\t* Initializes the twilight zone.\n\t*\n\t* This is only done if a SZPx instruction\n\t* refers to the twilight zone.\n\t*/\n\tfunction initTZone(state)\n\t{\n\t    var tZone = state.tZone = new Array(state.gZone.length);\n\n\t    // no idea if this is actually correct...\n\t    for (var i = 0; i < tZone.length; i++)\n\t    {\n\t        tZone[i] = new HPoint(0, 0);\n\t    }\n\t}\n\n\t/*\n\t* Skips the instruction pointer ahead over an IF/ELSE block.\n\t* handleElse .. if true breaks on matching ELSE\n\t*/\n\tfunction skip(state, handleElse)\n\t{\n\t    var prog = state.prog;\n\t    var ip = state.ip;\n\t    var nesting = 1;\n\t    var ins;\n\n\t    do {\n\t        ins = prog[++ip];\n\t        if (ins === 0x58) // IF\n\t            { nesting++; }\n\t        else if (ins === 0x59) // EIF\n\t            { nesting--; }\n\t        else if (ins === 0x40) // NPUSHB\n\t            { ip += prog[ip + 1] + 1; }\n\t        else if (ins === 0x41) // NPUSHW\n\t            { ip += 2 * prog[ip + 1] + 1; }\n\t        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB\n\t            { ip += ins - 0xB0 + 1; }\n\t        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW\n\t            { ip += (ins - 0xB8 + 1) * 2; }\n\t        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE\n\t            { break; }\n\t    } while (nesting > 0);\n\n\t    state.ip = ip;\n\t}\n\n\t/*----------------------------------------------------------*\n\t*          And then a lot of instructions...                *\n\t*----------------------------------------------------------*/\n\n\t// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n\t// 0x00-0x01\n\tfunction SVTCA(v, state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }\n\n\t    state.fv = state.pv = state.dpv = v;\n\t}\n\n\t// SPVTCA[a] Set Projection Vector to Coordinate Axis\n\t// 0x02-0x03\n\tfunction SPVTCA(v, state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }\n\n\t    state.pv = state.dpv = v;\n\t}\n\n\t// SFVTCA[a] Set Freedom Vector to Coordinate Axis\n\t// 0x04-0x05\n\tfunction SFVTCA(v, state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }\n\n\t    state.fv = v;\n\t}\n\n\t// SPVTL[a] Set Projection Vector To Line\n\t// 0x06-0x07\n\tfunction SPVTL(a, state) {\n\t    var stack = state.stack;\n\t    var p2i = stack.pop();\n\t    var p1i = stack.pop();\n\t    var p2 = state.z2[p2i];\n\t    var p1 = state.z1[p1i];\n\n\t    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }\n\n\t    var dx;\n\t    var dy;\n\n\t    if (!a) {\n\t        dx = p1.x - p2.x;\n\t        dy = p1.y - p2.y;\n\t    } else {\n\t        dx = p2.y - p1.y;\n\t        dy = p1.x - p2.x;\n\t    }\n\n\t    state.pv = state.dpv = getUnitVector(dx, dy);\n\t}\n\n\t// SFVTL[a] Set Freedom Vector To Line\n\t// 0x08-0x09\n\tfunction SFVTL(a, state) {\n\t    var stack = state.stack;\n\t    var p2i = stack.pop();\n\t    var p1i = stack.pop();\n\t    var p2 = state.z2[p2i];\n\t    var p1 = state.z1[p1i];\n\n\t    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }\n\n\t    var dx;\n\t    var dy;\n\n\t    if (!a) {\n\t        dx = p1.x - p2.x;\n\t        dy = p1.y - p2.y;\n\t    } else {\n\t        dx = p2.y - p1.y;\n\t        dy = p1.x - p2.x;\n\t    }\n\n\t    state.fv = getUnitVector(dx, dy);\n\t}\n\n\t// SPVFS[] Set Projection Vector From Stack\n\t// 0x0A\n\tfunction SPVFS(state) {\n\t    var stack = state.stack;\n\t    var y = stack.pop();\n\t    var x = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n\t    state.pv = state.dpv = getUnitVector(x, y);\n\t}\n\n\t// SFVFS[] Set Freedom Vector From Stack\n\t// 0x0B\n\tfunction SFVFS(state) {\n\t    var stack = state.stack;\n\t    var y = stack.pop();\n\t    var x = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }\n\n\t    state.fv = getUnitVector(x, y);\n\t}\n\n\t// GPV[] Get Projection Vector\n\t// 0x0C\n\tfunction GPV(state) {\n\t    var stack = state.stack;\n\t    var pv = state.pv;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }\n\n\t    stack.push(pv.x * 0x4000);\n\t    stack.push(pv.y * 0x4000);\n\t}\n\n\t// GFV[] Get Freedom Vector\n\t// 0x0C\n\tfunction GFV(state) {\n\t    var stack = state.stack;\n\t    var fv = state.fv;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }\n\n\t    stack.push(fv.x * 0x4000);\n\t    stack.push(fv.y * 0x4000);\n\t}\n\n\t// SFVTPV[] Set Freedom Vector To Projection Vector\n\t// 0x0E\n\tfunction SFVTPV(state) {\n\t    state.fv = state.pv;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }\n\t}\n\n\t// ISECT[] moves point p to the InterSECTion of two lines\n\t// 0x0F\n\tfunction ISECT(state)\n\t{\n\t    var stack = state.stack;\n\t    var pa0i = stack.pop();\n\t    var pa1i = stack.pop();\n\t    var pb0i = stack.pop();\n\t    var pb1i = stack.pop();\n\t    var pi = stack.pop();\n\t    var z0 = state.z0;\n\t    var z1 = state.z1;\n\t    var pa0 = z0[pa0i];\n\t    var pa1 = z0[pa1i];\n\t    var pb0 = z1[pb0i];\n\t    var pb1 = z1[pb1i];\n\t    var p = state.z2[pi];\n\n\t    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }\n\n\t    // math from\n\t    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n\t    var x1 = pa0.x;\n\t    var y1 = pa0.y;\n\t    var x2 = pa1.x;\n\t    var y2 = pa1.y;\n\t    var x3 = pb0.x;\n\t    var y3 = pb0.y;\n\t    var x4 = pb1.x;\n\t    var y4 = pb1.y;\n\n\t    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\t    var f1 = x1 * y2 - y1 * x2;\n\t    var f2 = x3 * y4 - y3 * x4;\n\n\t    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n\t    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n\t}\n\n\t// SRP0[] Set Reference Point 0\n\t// 0x10\n\tfunction SRP0(state) {\n\t    state.rp0 = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }\n\t}\n\n\t// SRP1[] Set Reference Point 1\n\t// 0x11\n\tfunction SRP1(state) {\n\t    state.rp1 = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }\n\t}\n\n\t// SRP1[] Set Reference Point 2\n\t// 0x12\n\tfunction SRP2(state) {\n\t    state.rp2 = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }\n\t}\n\n\t// SZP0[] Set Zone Pointer 0\n\t// 0x13\n\tfunction SZP0(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }\n\n\t    state.zp0 = n;\n\n\t    switch (n) {\n\t        case 0:\n\t            if (!state.tZone) { initTZone(state); }\n\t            state.z0 = state.tZone;\n\t            break;\n\t        case 1 :\n\t            state.z0 = state.gZone;\n\t            break;\n\t        default :\n\t            throw new Error('Invalid zone pointer');\n\t    }\n\t}\n\n\t// SZP1[] Set Zone Pointer 1\n\t// 0x14\n\tfunction SZP1(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }\n\n\t    state.zp1 = n;\n\n\t    switch (n) {\n\t        case 0:\n\t            if (!state.tZone) { initTZone(state); }\n\t            state.z1 = state.tZone;\n\t            break;\n\t        case 1 :\n\t            state.z1 = state.gZone;\n\t            break;\n\t        default :\n\t            throw new Error('Invalid zone pointer');\n\t    }\n\t}\n\n\t// SZP2[] Set Zone Pointer 2\n\t// 0x15\n\tfunction SZP2(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }\n\n\t    state.zp2 = n;\n\n\t    switch (n) {\n\t        case 0:\n\t            if (!state.tZone) { initTZone(state); }\n\t            state.z2 = state.tZone;\n\t            break;\n\t        case 1 :\n\t            state.z2 = state.gZone;\n\t            break;\n\t        default :\n\t            throw new Error('Invalid zone pointer');\n\t    }\n\t}\n\n\t// SZPS[] Set Zone PointerS\n\t// 0x16\n\tfunction SZPS(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }\n\n\t    state.zp0 = state.zp1 = state.zp2 = n;\n\n\t    switch (n) {\n\t        case 0:\n\t            if (!state.tZone) { initTZone(state); }\n\t            state.z0 = state.z1 = state.z2 = state.tZone;\n\t            break;\n\t        case 1 :\n\t            state.z0 = state.z1 = state.z2 = state.gZone;\n\t            break;\n\t        default :\n\t            throw new Error('Invalid zone pointer');\n\t    }\n\t}\n\n\t// SLOOP[] Set LOOP variable\n\t// 0x17\n\tfunction SLOOP(state) {\n\t    state.loop = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }\n\t}\n\n\t// RTG[] Round To Grid\n\t// 0x18\n\tfunction RTG(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }\n\n\t    state.round = roundToGrid;\n\t}\n\n\t// RTHG[] Round To Half Grid\n\t// 0x19\n\tfunction RTHG(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }\n\n\t    state.round = roundToHalfGrid;\n\t}\n\n\t// SMD[] Set Minimum Distance\n\t// 0x1A\n\tfunction SMD(state) {\n\t    var d = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }\n\n\t    state.minDis = d / 0x40;\n\t}\n\n\t// ELSE[] ELSE clause\n\t// 0x1B\n\tfunction ELSE(state) {\n\t    // This instruction has been reached by executing a then branch\n\t    // so it just skips ahead until matching EIF.\n\t    //\n\t    // In case the IF was negative the IF[] instruction already\n\t    // skipped forward over the ELSE[]\n\n\t    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }\n\n\t    skip(state, false);\n\t}\n\n\t// JMPR[] JuMP Relative\n\t// 0x1C\n\tfunction JMPR(state) {\n\t    var o = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }\n\n\t    // A jump by 1 would do nothing.\n\t    state.ip += o - 1;\n\t}\n\n\t// SCVTCI[] Set Control Value Table Cut-In\n\t// 0x1D\n\tfunction SCVTCI(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }\n\n\t    state.cvCutIn = n / 0x40;\n\t}\n\n\t// DUP[] DUPlicate top stack element\n\t// 0x20\n\tfunction DUP(state) {\n\t    var stack = state.stack;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }\n\n\t    stack.push(stack[stack.length - 1]);\n\t}\n\n\t// POP[] POP top stack element\n\t// 0x21\n\tfunction POP(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }\n\n\t    state.stack.pop();\n\t}\n\n\t// CLEAR[] CLEAR the stack\n\t// 0x22\n\tfunction CLEAR(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }\n\n\t    state.stack.length = 0;\n\t}\n\n\t// SWAP[] SWAP the top two elements on the stack\n\t// 0x23\n\tfunction SWAP(state) {\n\t    var stack = state.stack;\n\n\t    var a = stack.pop();\n\t    var b = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }\n\n\t    stack.push(a);\n\t    stack.push(b);\n\t}\n\n\t// DEPTH[] DEPTH of the stack\n\t// 0x24\n\tfunction DEPTH(state) {\n\t    var stack = state.stack;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }\n\n\t    stack.push(stack.length);\n\t}\n\n\t// LOOPCALL[] LOOPCALL function\n\t// 0x2A\n\tfunction LOOPCALL(state) {\n\t    var stack = state.stack;\n\t    var fn = stack.pop();\n\t    var c = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }\n\n\t    // saves callers program\n\t    var cip = state.ip;\n\t    var cprog = state.prog;\n\n\t    state.prog = state.funcs[fn];\n\n\t    // executes the function\n\t    for (var i = 0; i < c; i++) {\n\t        exec(state);\n\n\t        if (exports.DEBUG) { console.log(\n\t            ++state.step,\n\t            i + 1 < c ? 'next loopcall' : 'done loopcall',\n\t            i\n\t        ); }\n\t    }\n\n\t    // restores the callers program\n\t    state.ip = cip;\n\t    state.prog = cprog;\n\t}\n\n\t// CALL[] CALL function\n\t// 0x2B\n\tfunction CALL(state) {\n\t    var fn = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }\n\n\t    // saves callers program\n\t    var cip = state.ip;\n\t    var cprog = state.prog;\n\n\t    state.prog = state.funcs[fn];\n\n\t    // executes the function\n\t    exec(state);\n\n\t    // restores the callers program\n\t    state.ip = cip;\n\t    state.prog = cprog;\n\n\t    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }\n\t}\n\n\t// CINDEX[] Copy the INDEXed element to the top of the stack\n\t// 0x25\n\tfunction CINDEX(state) {\n\t    var stack = state.stack;\n\t    var k = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }\n\n\t    // In case of k == 1, it copies the last element after popping\n\t    // thus stack.length - k.\n\t    stack.push(stack[stack.length - k]);\n\t}\n\n\t// MINDEX[] Move the INDEXed element to the top of the stack\n\t// 0x26\n\tfunction MINDEX(state) {\n\t    var stack = state.stack;\n\t    var k = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }\n\n\t    stack.push(stack.splice(stack.length - k, 1)[0]);\n\t}\n\n\t// FDEF[] Function DEFinition\n\t// 0x2C\n\tfunction FDEF(state) {\n\t    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }\n\t    var stack = state.stack;\n\t    var prog = state.prog;\n\t    var ip = state.ip;\n\n\t    var fn = stack.pop();\n\t    var ipBegin = ip;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }\n\n\t    while (prog[++ip] !== 0x2D){ }\n\n\t    state.ip = ip;\n\t    state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n\t}\n\n\t// MDAP[a] Move Direct Absolute Point\n\t// 0x2E-0x2F\n\tfunction MDAP(round, state) {\n\t    var pi = state.stack.pop();\n\t    var p = state.z0[pi];\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }\n\n\t    var d = pv.distance(p, HPZero);\n\n\t    if (round) { d = state.round(d); }\n\n\t    fv.setRelative(p, HPZero, d, pv);\n\t    fv.touch(p);\n\n\t    state.rp0 = state.rp1 = pi;\n\t}\n\n\t// IUP[a] Interpolate Untouched Points through the outline\n\t// 0x30\n\tfunction IUP(v, state) {\n\t    var z2 = state.z2;\n\t    var pLen = z2.length - 2;\n\t    var cp;\n\t    var pp;\n\t    var np;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }\n\n\t    for (var i = 0; i < pLen; i++) {\n\t        cp = z2[i]; // current point\n\n\t        // if this point has been touched go on\n\t        if (v.touched(cp)) { continue; }\n\n\t        pp = cp.prevTouched(v);\n\n\t        // no point on the contour has been touched?\n\t        if (pp === cp) { continue; }\n\n\t        np = cp.nextTouched(v);\n\n\t        if (pp === np) {\n\t            // only one point on the contour has been touched\n\t            // so simply moves the point like that\n\n\t            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n\t        }\n\n\t        v.interpolate(cp, pp, np, v);\n\t    }\n\t}\n\n\t// SHP[] SHift Point using reference point\n\t// 0x32-0x33\n\tfunction SHP(a, state) {\n\t    var stack = state.stack;\n\t    var rpi = a ? state.rp1 : state.rp2;\n\t    var rp = (a ? state.z0 : state.z1)[rpi];\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\t    var loop = state.loop;\n\t    var z2 = state.z2;\n\n\t    while (loop--)\n\t    {\n\t        var pi = stack.pop();\n\t        var p = z2[pi];\n\n\t        var d = pv.distance(rp, rp, false, true);\n\t        fv.setRelative(p, p, d, pv);\n\t        fv.touch(p);\n\n\t        if (exports.DEBUG) {\n\t            console.log(\n\t                state.step,\n\t                (state.loop > 1 ?\n\t                   'loop ' + (state.loop - loop) + ': ' :\n\t                   ''\n\t                ) +\n\t                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi\n\t            );\n\t        }\n\t    }\n\n\t    state.loop = 1;\n\t}\n\n\t// SHC[] SHift Contour using reference point\n\t// 0x36-0x37\n\tfunction SHC(a, state) {\n\t    var stack = state.stack;\n\t    var rpi = a ? state.rp1 : state.rp2;\n\t    var rp = (a ? state.z0 : state.z1)[rpi];\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\t    var ci = stack.pop();\n\t    var sp = state.z2[state.contours[ci]];\n\t    var p = sp;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }\n\n\t    var d = pv.distance(rp, rp, false, true);\n\n\t    do {\n\t        if (p !== rp) { fv.setRelative(p, p, d, pv); }\n\t        p = p.nextPointOnContour;\n\t    } while (p !== sp);\n\t}\n\n\t// SHZ[] SHift Zone using reference point\n\t// 0x36-0x37\n\tfunction SHZ(a, state) {\n\t    var stack = state.stack;\n\t    var rpi = a ? state.rp1 : state.rp2;\n\t    var rp = (a ? state.z0 : state.z1)[rpi];\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\n\t    var e = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }\n\n\t    var z;\n\t    switch (e) {\n\t        case 0 : z = state.tZone; break;\n\t        case 1 : z = state.gZone; break;\n\t        default : throw new Error('Invalid zone');\n\t    }\n\n\t    var p;\n\t    var d = pv.distance(rp, rp, false, true);\n\t    var pLen = z.length - 2;\n\t    for (var i = 0; i < pLen; i++)\n\t    {\n\t        p = z[i];\n\t        fv.setRelative(p, p, d, pv);\n\t        //if (p !== rp) fv.setRelative(p, p, d, pv);\n\t    }\n\t}\n\n\t// SHPIX[] SHift point by a PIXel amount\n\t// 0x38\n\tfunction SHPIX(state) {\n\t    var stack = state.stack;\n\t    var loop = state.loop;\n\t    var fv = state.fv;\n\t    var d = stack.pop() / 0x40;\n\t    var z2 = state.z2;\n\n\t    while (loop--) {\n\t        var pi = stack.pop();\n\t        var p = z2[pi];\n\n\t        if (exports.DEBUG) {\n\t            console.log(\n\t                state.step,\n\t                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n\t                'SHPIX[]', pi, d\n\t            );\n\t        }\n\n\t        fv.setRelative(p, p, d);\n\t        fv.touch(p);\n\t    }\n\n\t    state.loop = 1;\n\t}\n\n\t// IP[] Interpolate Point\n\t// 0x39\n\tfunction IP(state) {\n\t    var stack = state.stack;\n\t    var rp1i = state.rp1;\n\t    var rp2i = state.rp2;\n\t    var loop = state.loop;\n\t    var rp1 = state.z0[rp1i];\n\t    var rp2 = state.z1[rp2i];\n\t    var fv = state.fv;\n\t    var pv = state.dpv;\n\t    var z2 = state.z2;\n\n\t    while (loop--) {\n\t        var pi = stack.pop();\n\t        var p = z2[pi];\n\n\t        if (exports.DEBUG) {\n\t            console.log(\n\t                state.step,\n\t                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n\t                'IP[]', pi, rp1i, '<->', rp2i\n\t            );\n\t        }\n\n\t        fv.interpolate(p, rp1, rp2, pv);\n\n\t        fv.touch(p);\n\t    }\n\n\t    state.loop = 1;\n\t}\n\n\t// MSIRP[a] Move Stack Indirect Relative Point\n\t// 0x3A-0x3B\n\tfunction MSIRP(a, state) {\n\t    var stack = state.stack;\n\t    var d = stack.pop() / 64;\n\t    var pi = stack.pop();\n\t    var p = state.z1[pi];\n\t    var rp0 = state.z0[state.rp0];\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\n\t    fv.setRelative(p, rp0, d, pv);\n\t    fv.touch(p);\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }\n\n\t    state.rp1 = state.rp0;\n\t    state.rp2 = pi;\n\t    if (a) { state.rp0 = pi; }\n\t}\n\n\t// ALIGNRP[] Align to reference point.\n\t// 0x3C\n\tfunction ALIGNRP(state) {\n\t    var stack = state.stack;\n\t    var rp0i = state.rp0;\n\t    var rp0 = state.z0[rp0i];\n\t    var loop = state.loop;\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\t    var z1 = state.z1;\n\n\t    while (loop--) {\n\t        var pi = stack.pop();\n\t        var p = z1[pi];\n\n\t        if (exports.DEBUG) {\n\t            console.log(\n\t                state.step,\n\t                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n\t                'ALIGNRP[]', pi\n\t            );\n\t        }\n\n\t        fv.setRelative(p, rp0, 0, pv);\n\t        fv.touch(p);\n\t    }\n\n\t    state.loop = 1;\n\t}\n\n\t// RTG[] Round To Double Grid\n\t// 0x3D\n\tfunction RTDG(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }\n\n\t    state.round = roundToDoubleGrid;\n\t}\n\n\t// MIAP[a] Move Indirect Absolute Point\n\t// 0x3E-0x3F\n\tfunction MIAP(round, state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\t    var pi = stack.pop();\n\t    var p = state.z0[pi];\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\t    var cv = state.cvt[n];\n\n\t    if (exports.DEBUG) {\n\t        console.log(\n\t            state.step,\n\t            'MIAP[' + round + ']',\n\t            n, '(', cv, ')', pi\n\t        );\n\t    }\n\n\t    var d = pv.distance(p, HPZero);\n\n\t    if (round) {\n\t        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n\n\t        d = state.round(d);\n\t    }\n\n\t    fv.setRelative(p, HPZero, d, pv);\n\n\t    if (state.zp0 === 0) {\n\t        p.xo = p.x;\n\t        p.yo = p.y;\n\t    }\n\n\t    fv.touch(p);\n\n\t    state.rp0 = state.rp1 = pi;\n\t}\n\n\t// NPUSB[] PUSH N Bytes\n\t// 0x40\n\tfunction NPUSHB(state) {\n\t    var prog = state.prog;\n\t    var ip = state.ip;\n\t    var stack = state.stack;\n\n\t    var n = prog[++ip];\n\n\t    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }\n\n\t    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n\t    state.ip = ip;\n\t}\n\n\t// NPUSHW[] PUSH N Words\n\t// 0x41\n\tfunction NPUSHW(state) {\n\t    var ip = state.ip;\n\t    var prog = state.prog;\n\t    var stack = state.stack;\n\t    var n = prog[++ip];\n\n\t    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }\n\n\t    for (var i = 0; i < n; i++) {\n\t        var w = (prog[++ip] << 8) | prog[++ip];\n\t        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n\t        stack.push(w);\n\t    }\n\n\t    state.ip = ip;\n\t}\n\n\t// WS[] Write Store\n\t// 0x42\n\tfunction WS(state) {\n\t    var stack = state.stack;\n\t    var store = state.store;\n\n\t    if (!store) { store = state.store = []; }\n\n\t    var v = stack.pop();\n\t    var l = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }\n\n\t    store[l] = v;\n\t}\n\n\t// RS[] Read Store\n\t// 0x43\n\tfunction RS(state) {\n\t    var stack = state.stack;\n\t    var store = state.store;\n\n\t    var l = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'RS', l); }\n\n\t    var v = (store && store[l]) || 0;\n\n\t    stack.push(v);\n\t}\n\n\t// WCVTP[] Write Control Value Table in Pixel units\n\t// 0x44\n\tfunction WCVTP(state) {\n\t    var stack = state.stack;\n\n\t    var v = stack.pop();\n\t    var l = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }\n\n\t    state.cvt[l] = v / 0x40;\n\t}\n\n\t// RCVT[] Read Control Value Table entry\n\t// 0x45\n\tfunction RCVT(state) {\n\t    var stack = state.stack;\n\t    var cvte = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }\n\n\t    stack.push(state.cvt[cvte] * 0x40);\n\t}\n\n\t// GC[] Get Coordinate projected onto the projection vector\n\t// 0x46-0x47\n\tfunction GC(a, state) {\n\t    var stack = state.stack;\n\t    var pi = stack.pop();\n\t    var p = state.z2[pi];\n\n\t    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }\n\n\t    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n\t}\n\n\t// MD[a] Measure Distance\n\t// 0x49-0x4A\n\tfunction MD(a, state) {\n\t    var stack = state.stack;\n\t    var pi2 = stack.pop();\n\t    var pi1 = stack.pop();\n\t    var p2 = state.z1[pi2];\n\t    var p1 = state.z0[pi1];\n\t    var d = state.dpv.distance(p1, p2, a, a);\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }\n\n\t    state.stack.push(Math.round(d * 64));\n\t}\n\n\t// MPPEM[] Measure Pixels Per EM\n\t// 0x4B\n\tfunction MPPEM(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }\n\t    state.stack.push(state.ppem);\n\t}\n\n\t// FLIPON[] set the auto FLIP Boolean to ON\n\t// 0x4D\n\tfunction FLIPON(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }\n\t    state.autoFlip = true;\n\t}\n\n\t// LT[] Less Than\n\t// 0x50\n\tfunction LT(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }\n\n\t    stack.push(e1 < e2 ? 1 : 0);\n\t}\n\n\t// LTEQ[] Less Than or EQual\n\t// 0x53\n\tfunction LTEQ(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }\n\n\t    stack.push(e1 <= e2 ? 1 : 0);\n\t}\n\n\t// GTEQ[] Greater Than\n\t// 0x52\n\tfunction GT(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }\n\n\t    stack.push(e1 > e2 ? 1 : 0);\n\t}\n\n\t// GTEQ[] Greater Than or EQual\n\t// 0x53\n\tfunction GTEQ(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }\n\n\t    stack.push(e1 >= e2 ? 1 : 0);\n\t}\n\n\t// EQ[] EQual\n\t// 0x54\n\tfunction EQ(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }\n\n\t    stack.push(e2 === e1 ? 1 : 0);\n\t}\n\n\t// NEQ[] Not EQual\n\t// 0x55\n\tfunction NEQ(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }\n\n\t    stack.push(e2 !== e1 ? 1 : 0);\n\t}\n\n\t// ODD[] ODD\n\t// 0x56\n\tfunction ODD(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }\n\n\t    stack.push(Math.trunc(n) % 2 ? 1 : 0);\n\t}\n\n\t// EVEN[] EVEN\n\t// 0x57\n\tfunction EVEN(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }\n\n\t    stack.push(Math.trunc(n) % 2 ? 0 : 1);\n\t}\n\n\t// IF[] IF test\n\t// 0x58\n\tfunction IF(state) {\n\t    var test = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }\n\n\t    // if test is true it just continues\n\t    // if not the ip is skipped until matching ELSE or EIF\n\t    if (!test) {\n\t        skip(state, true);\n\n\t        if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }\n\t    }\n\t}\n\n\t// EIF[] End IF\n\t// 0x59\n\tfunction EIF(state) {\n\t    // this can be reached normally when\n\t    // executing an else branch.\n\t    // -> just ignore it\n\n\t    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }\n\t}\n\n\t// AND[] logical AND\n\t// 0x5A\n\tfunction AND(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }\n\n\t    stack.push(e2 && e1 ? 1 : 0);\n\t}\n\n\t// OR[] logical OR\n\t// 0x5B\n\tfunction OR(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }\n\n\t    stack.push(e2 || e1 ? 1 : 0);\n\t}\n\n\t// NOT[] logical NOT\n\t// 0x5C\n\tfunction NOT(state) {\n\t    var stack = state.stack;\n\t    var e = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }\n\n\t    stack.push(e ? 0 : 1);\n\t}\n\n\t// DELTAP1[] DELTA exception P1\n\t// DELTAP2[] DELTA exception P2\n\t// DELTAP3[] DELTA exception P3\n\t// 0x5D, 0x71, 0x72\n\tfunction DELTAP123(b, state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\t    var fv = state.fv;\n\t    var pv = state.pv;\n\t    var ppem = state.ppem;\n\t    var base = state.deltaBase + (b - 1) * 16;\n\t    var ds = state.deltaShift;\n\t    var z0 = state.z0;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }\n\n\t    for (var i = 0; i < n; i++) {\n\t        var pi = stack.pop();\n\t        var arg = stack.pop();\n\t        var appem = base + ((arg & 0xF0) >> 4);\n\t        if (appem !== ppem) { continue; }\n\n\t        var mag = (arg & 0x0F) - 8;\n\t        if (mag >= 0) { mag++; }\n\t        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }\n\n\t        var p = z0[pi];\n\t        fv.setRelative(p, p, mag * ds, pv);\n\t    }\n\t}\n\n\t// SDB[] Set Delta Base in the graphics state\n\t// 0x5E\n\tfunction SDB(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }\n\n\t    state.deltaBase = n;\n\t}\n\n\t// SDS[] Set Delta Shift in the graphics state\n\t// 0x5F\n\tfunction SDS(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }\n\n\t    state.deltaShift = Math.pow(0.5, n);\n\t}\n\n\t// ADD[] ADD\n\t// 0x60\n\tfunction ADD(state) {\n\t    var stack = state.stack;\n\t    var n2 = stack.pop();\n\t    var n1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }\n\n\t    stack.push(n1 + n2);\n\t}\n\n\t// SUB[] SUB\n\t// 0x61\n\tfunction SUB(state) {\n\t    var stack = state.stack;\n\t    var n2 = stack.pop();\n\t    var n1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }\n\n\t    stack.push(n1 - n2);\n\t}\n\n\t// DIV[] DIV\n\t// 0x62\n\tfunction DIV(state) {\n\t    var stack = state.stack;\n\t    var n2 = stack.pop();\n\t    var n1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }\n\n\t    stack.push(n1 * 64 / n2);\n\t}\n\n\t// MUL[] MUL\n\t// 0x63\n\tfunction MUL(state) {\n\t    var stack = state.stack;\n\t    var n2 = stack.pop();\n\t    var n1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }\n\n\t    stack.push(n1 * n2 / 64);\n\t}\n\n\t// ABS[] ABSolute value\n\t// 0x64\n\tfunction ABS(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }\n\n\t    stack.push(Math.abs(n));\n\t}\n\n\t// NEG[] NEGate\n\t// 0x65\n\tfunction NEG(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }\n\n\t    stack.push(-n);\n\t}\n\n\t// FLOOR[] FLOOR\n\t// 0x66\n\tfunction FLOOR(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }\n\n\t    stack.push(Math.floor(n / 0x40) * 0x40);\n\t}\n\n\t// CEILING[] CEILING\n\t// 0x67\n\tfunction CEILING(state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }\n\n\t    stack.push(Math.ceil(n / 0x40) * 0x40);\n\t}\n\n\t// ROUND[ab] ROUND value\n\t// 0x68-0x6B\n\tfunction ROUND(dt, state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }\n\n\t    stack.push(state.round(n / 0x40) * 0x40);\n\t}\n\n\t// WCVTF[] Write Control Value Table in Funits\n\t// 0x70\n\tfunction WCVTF(state) {\n\t    var stack = state.stack;\n\t    var v = stack.pop();\n\t    var l = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }\n\n\t    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n\t}\n\n\t// DELTAC1[] DELTA exception C1\n\t// DELTAC2[] DELTA exception C2\n\t// DELTAC3[] DELTA exception C3\n\t// 0x73, 0x74, 0x75\n\tfunction DELTAC123(b, state) {\n\t    var stack = state.stack;\n\t    var n = stack.pop();\n\t    var ppem = state.ppem;\n\t    var base = state.deltaBase + (b - 1) * 16;\n\t    var ds = state.deltaShift;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }\n\n\t    for (var i = 0; i < n; i++) {\n\t        var c = stack.pop();\n\t        var arg = stack.pop();\n\t        var appem = base + ((arg & 0xF0) >> 4);\n\t        if (appem !== ppem) { continue; }\n\n\t        var mag = (arg & 0x0F) - 8;\n\t        if (mag >= 0) { mag++; }\n\n\t        var delta = mag * ds;\n\n\t        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }\n\n\t        state.cvt[c] += delta;\n\t    }\n\t}\n\n\t// SROUND[] Super ROUND\n\t// 0x76\n\tfunction SROUND(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }\n\n\t    state.round = roundSuper;\n\n\t    var period;\n\n\t    switch (n & 0xC0) {\n\t        case 0x00:\n\t            period = 0.5;\n\t            break;\n\t        case 0x40:\n\t            period = 1;\n\t            break;\n\t        case 0x80:\n\t            period = 2;\n\t            break;\n\t        default:\n\t            throw new Error('invalid SROUND value');\n\t    }\n\n\t    state.srPeriod = period;\n\n\t    switch (n & 0x30) {\n\t        case 0x00:\n\t            state.srPhase = 0;\n\t            break;\n\t        case 0x10:\n\t            state.srPhase = 0.25 * period;\n\t            break;\n\t        case 0x20:\n\t            state.srPhase = 0.5  * period;\n\t            break;\n\t        case 0x30:\n\t            state.srPhase = 0.75 * period;\n\t            break;\n\t        default: throw new Error('invalid SROUND value');\n\t    }\n\n\t    n &= 0x0F;\n\n\t    if (n === 0) { state.srThreshold = 0; }\n\t    else { state.srThreshold = (n / 8 - 0.5) * period; }\n\t}\n\n\t// S45ROUND[] Super ROUND 45 degrees\n\t// 0x77\n\tfunction S45ROUND(state) {\n\t    var n = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }\n\n\t    state.round = roundSuper;\n\n\t    var period;\n\n\t    switch (n & 0xC0) {\n\t        case 0x00:\n\t            period = Math.sqrt(2) / 2;\n\t            break;\n\t        case 0x40:\n\t            period = Math.sqrt(2);\n\t            break;\n\t        case 0x80:\n\t            period = 2 * Math.sqrt(2);\n\t            break;\n\t        default:\n\t            throw new Error('invalid S45ROUND value');\n\t    }\n\n\t    state.srPeriod = period;\n\n\t    switch (n & 0x30) {\n\t        case 0x00:\n\t            state.srPhase = 0;\n\t            break;\n\t        case 0x10:\n\t            state.srPhase = 0.25 * period;\n\t            break;\n\t        case 0x20:\n\t            state.srPhase = 0.5  * period;\n\t            break;\n\t        case 0x30:\n\t            state.srPhase = 0.75 * period;\n\t            break;\n\t        default:\n\t            throw new Error('invalid S45ROUND value');\n\t    }\n\n\t    n &= 0x0F;\n\n\t    if (n === 0) { state.srThreshold = 0; }\n\t    else { state.srThreshold = (n / 8 - 0.5) * period; }\n\t}\n\n\t// ROFF[] Round Off\n\t// 0x7A\n\tfunction ROFF(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }\n\n\t    state.round = roundOff;\n\t}\n\n\t// RUTG[] Round Up To Grid\n\t// 0x7C\n\tfunction RUTG(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }\n\n\t    state.round = roundUpToGrid;\n\t}\n\n\t// RDTG[] Round Down To Grid\n\t// 0x7D\n\tfunction RDTG(state) {\n\t    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }\n\n\t    state.round = roundDownToGrid;\n\t}\n\n\t// SCANCTRL[] SCAN conversion ConTRoL\n\t// 0x85\n\tfunction SCANCTRL(state) {\n\t    var n = state.stack.pop();\n\n\t    // ignored by opentype.js\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }\n\t}\n\n\t// SDPVTL[a] Set Dual Projection Vector To Line\n\t// 0x86-0x87\n\tfunction SDPVTL(a, state) {\n\t    var stack = state.stack;\n\t    var p2i = stack.pop();\n\t    var p1i = stack.pop();\n\t    var p2 = state.z2[p2i];\n\t    var p1 = state.z1[p1i];\n\n\t    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }\n\n\t    var dx;\n\t    var dy;\n\n\t    if (!a) {\n\t        dx = p1.x - p2.x;\n\t        dy = p1.y - p2.y;\n\t    } else {\n\t        dx = p2.y - p1.y;\n\t        dy = p1.x - p2.x;\n\t    }\n\n\t    state.dpv = getUnitVector(dx, dy);\n\t}\n\n\t// GETINFO[] GET INFOrmation\n\t// 0x88\n\tfunction GETINFO(state) {\n\t    var stack = state.stack;\n\t    var sel = stack.pop();\n\t    var r = 0;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }\n\n\t    // v35 as in no subpixel hinting\n\t    if (sel & 0x01) { r = 35; }\n\n\t    // TODO rotation and stretch currently not supported\n\t    // and thus those GETINFO are always 0.\n\n\t    // opentype.js is always gray scaling\n\t    if (sel & 0x20) { r |= 0x1000; }\n\n\t    stack.push(r);\n\t}\n\n\t// ROLL[] ROLL the top three stack elements\n\t// 0x8A\n\tfunction ROLL(state) {\n\t    var stack = state.stack;\n\t    var a = stack.pop();\n\t    var b = stack.pop();\n\t    var c = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }\n\n\t    stack.push(b);\n\t    stack.push(a);\n\t    stack.push(c);\n\t}\n\n\t// MAX[] MAXimum of top two stack elements\n\t// 0x8B\n\tfunction MAX(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }\n\n\t    stack.push(Math.max(e1, e2));\n\t}\n\n\t// MIN[] MINimum of top two stack elements\n\t// 0x8C\n\tfunction MIN(state) {\n\t    var stack = state.stack;\n\t    var e2 = stack.pop();\n\t    var e1 = stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }\n\n\t    stack.push(Math.min(e1, e2));\n\t}\n\n\t// SCANTYPE[] SCANTYPE\n\t// 0x8D\n\tfunction SCANTYPE(state) {\n\t    var n = state.stack.pop();\n\t    // ignored by opentype.js\n\t    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }\n\t}\n\n\t// INSTCTRL[] INSTCTRL\n\t// 0x8D\n\tfunction INSTCTRL(state) {\n\t    var s = state.stack.pop();\n\t    var v = state.stack.pop();\n\n\t    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }\n\n\t    switch (s) {\n\t        case 1 : state.inhibitGridFit = !!v; return;\n\t        case 2 : state.ignoreCvt = !!v; return;\n\t        default: throw new Error('invalid INSTCTRL[] selector');\n\t    }\n\t}\n\n\t// PUSHB[abc] PUSH Bytes\n\t// 0xB0-0xB7\n\tfunction PUSHB(n, state) {\n\t    var stack = state.stack;\n\t    var prog = state.prog;\n\t    var ip = state.ip;\n\n\t    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }\n\n\t    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }\n\n\t    state.ip = ip;\n\t}\n\n\t// PUSHW[abc] PUSH Words\n\t// 0xB8-0xBF\n\tfunction PUSHW(n, state) {\n\t    var ip = state.ip;\n\t    var prog = state.prog;\n\t    var stack = state.stack;\n\n\t    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }\n\n\t    for (var i = 0; i < n; i++) {\n\t        var w = (prog[++ip] << 8) | prog[++ip];\n\t        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }\n\t        stack.push(w);\n\t    }\n\n\t    state.ip = ip;\n\t}\n\n\t// MDRP[abcde] Move Direct Relative Point\n\t// 0xD0-0xEF\n\t// (if indirect is 0)\n\t//\n\t// and\n\t//\n\t// MIRP[abcde] Move Indirect Relative Point\n\t// 0xE0-0xFF\n\t// (if indirect is 1)\n\n\tfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n\t    var stack = state.stack;\n\t    var cvte = indirect && stack.pop();\n\t    var pi = stack.pop();\n\t    var rp0i = state.rp0;\n\t    var rp = state.z0[rp0i];\n\t    var p = state.z1[pi];\n\n\t    var md = state.minDis;\n\t    var fv = state.fv;\n\t    var pv = state.dpv;\n\t    var od; // original distance\n\t    var d; // moving distance\n\t    var sign; // sign of distance\n\t    var cv;\n\n\t    d = od = pv.distance(p, rp, true, true);\n\t    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n\n\t    // TODO consider autoFlip\n\t    d = Math.abs(d);\n\n\t    if (indirect) {\n\t        cv = state.cvt[cvte];\n\n\t        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }\n\t    }\n\n\t    if (keepD && d < md) { d = md; }\n\n\t    if (ro) { d = state.round(d); }\n\n\t    fv.setRelative(p, rp, sign * d, pv);\n\t    fv.touch(p);\n\n\t    if (exports.DEBUG) {\n\t        console.log(\n\t            state.step,\n\t            (indirect ? 'MIRP[' : 'MDRP[') +\n\t            (setRp0 ? 'M' : 'm') +\n\t            (keepD ? '>' : '_') +\n\t            (ro ? 'R' : '_') +\n\t            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +\n\t            ']',\n\t            indirect ?\n\t                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :\n\t                '',\n\t            pi,\n\t            '(d =', od, '->', sign * d, ')'\n\t        );\n\t    }\n\n\t    state.rp1 = state.rp0;\n\t    state.rp2 = pi;\n\t    if (setRp0) { state.rp0 = pi; }\n\t}\n\n\t/*\n\t* The instruction table.\n\t*/\n\tinstructionTable = [\n\t    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n\t    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n\t    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n\t    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n\t    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n\t    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n\t    /* 0x06 */ SPVTL.bind(undefined, 0),\n\t    /* 0x07 */ SPVTL.bind(undefined, 1),\n\t    /* 0x08 */ SFVTL.bind(undefined, 0),\n\t    /* 0x09 */ SFVTL.bind(undefined, 1),\n\t    /* 0x0A */ SPVFS,\n\t    /* 0x0B */ SFVFS,\n\t    /* 0x0C */ GPV,\n\t    /* 0x0D */ GFV,\n\t    /* 0x0E */ SFVTPV,\n\t    /* 0x0F */ ISECT,\n\t    /* 0x10 */ SRP0,\n\t    /* 0x11 */ SRP1,\n\t    /* 0x12 */ SRP2,\n\t    /* 0x13 */ SZP0,\n\t    /* 0x14 */ SZP1,\n\t    /* 0x15 */ SZP2,\n\t    /* 0x16 */ SZPS,\n\t    /* 0x17 */ SLOOP,\n\t    /* 0x18 */ RTG,\n\t    /* 0x19 */ RTHG,\n\t    /* 0x1A */ SMD,\n\t    /* 0x1B */ ELSE,\n\t    /* 0x1C */ JMPR,\n\t    /* 0x1D */ SCVTCI,\n\t    /* 0x1E */ undefined,   // TODO SSWCI\n\t    /* 0x1F */ undefined,   // TODO SSW\n\t    /* 0x20 */ DUP,\n\t    /* 0x21 */ POP,\n\t    /* 0x22 */ CLEAR,\n\t    /* 0x23 */ SWAP,\n\t    /* 0x24 */ DEPTH,\n\t    /* 0x25 */ CINDEX,\n\t    /* 0x26 */ MINDEX,\n\t    /* 0x27 */ undefined,   // TODO ALIGNPTS\n\t    /* 0x28 */ undefined,\n\t    /* 0x29 */ undefined,   // TODO UTP\n\t    /* 0x2A */ LOOPCALL,\n\t    /* 0x2B */ CALL,\n\t    /* 0x2C */ FDEF,\n\t    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)\n\t    /* 0x2E */ MDAP.bind(undefined, 0),\n\t    /* 0x2F */ MDAP.bind(undefined, 1),\n\t    /* 0x30 */ IUP.bind(undefined, yUnitVector),\n\t    /* 0x31 */ IUP.bind(undefined, xUnitVector),\n\t    /* 0x32 */ SHP.bind(undefined, 0),\n\t    /* 0x33 */ SHP.bind(undefined, 1),\n\t    /* 0x34 */ SHC.bind(undefined, 0),\n\t    /* 0x35 */ SHC.bind(undefined, 1),\n\t    /* 0x36 */ SHZ.bind(undefined, 0),\n\t    /* 0x37 */ SHZ.bind(undefined, 1),\n\t    /* 0x38 */ SHPIX,\n\t    /* 0x39 */ IP,\n\t    /* 0x3A */ MSIRP.bind(undefined, 0),\n\t    /* 0x3B */ MSIRP.bind(undefined, 1),\n\t    /* 0x3C */ ALIGNRP,\n\t    /* 0x3D */ RTDG,\n\t    /* 0x3E */ MIAP.bind(undefined, 0),\n\t    /* 0x3F */ MIAP.bind(undefined, 1),\n\t    /* 0x40 */ NPUSHB,\n\t    /* 0x41 */ NPUSHW,\n\t    /* 0x42 */ WS,\n\t    /* 0x43 */ RS,\n\t    /* 0x44 */ WCVTP,\n\t    /* 0x45 */ RCVT,\n\t    /* 0x46 */ GC.bind(undefined, 0),\n\t    /* 0x47 */ GC.bind(undefined, 1),\n\t    /* 0x48 */ undefined,   // TODO SCFS\n\t    /* 0x49 */ MD.bind(undefined, 0),\n\t    /* 0x4A */ MD.bind(undefined, 1),\n\t    /* 0x4B */ MPPEM,\n\t    /* 0x4C */ undefined,   // TODO MPS\n\t    /* 0x4D */ FLIPON,\n\t    /* 0x4E */ undefined,   // TODO FLIPOFF\n\t    /* 0x4F */ undefined,   // TODO DEBUG\n\t    /* 0x50 */ LT,\n\t    /* 0x51 */ LTEQ,\n\t    /* 0x52 */ GT,\n\t    /* 0x53 */ GTEQ,\n\t    /* 0x54 */ EQ,\n\t    /* 0x55 */ NEQ,\n\t    /* 0x56 */ ODD,\n\t    /* 0x57 */ EVEN,\n\t    /* 0x58 */ IF,\n\t    /* 0x59 */ EIF,\n\t    /* 0x5A */ AND,\n\t    /* 0x5B */ OR,\n\t    /* 0x5C */ NOT,\n\t    /* 0x5D */ DELTAP123.bind(undefined, 1),\n\t    /* 0x5E */ SDB,\n\t    /* 0x5F */ SDS,\n\t    /* 0x60 */ ADD,\n\t    /* 0x61 */ SUB,\n\t    /* 0x62 */ DIV,\n\t    /* 0x63 */ MUL,\n\t    /* 0x64 */ ABS,\n\t    /* 0x65 */ NEG,\n\t    /* 0x66 */ FLOOR,\n\t    /* 0x67 */ CEILING,\n\t    /* 0x68 */ ROUND.bind(undefined, 0),\n\t    /* 0x69 */ ROUND.bind(undefined, 1),\n\t    /* 0x6A */ ROUND.bind(undefined, 2),\n\t    /* 0x6B */ ROUND.bind(undefined, 3),\n\t    /* 0x6C */ undefined,   // TODO NROUND[ab]\n\t    /* 0x6D */ undefined,   // TODO NROUND[ab]\n\t    /* 0x6E */ undefined,   // TODO NROUND[ab]\n\t    /* 0x6F */ undefined,   // TODO NROUND[ab]\n\t    /* 0x70 */ WCVTF,\n\t    /* 0x71 */ DELTAP123.bind(undefined, 2),\n\t    /* 0x72 */ DELTAP123.bind(undefined, 3),\n\t    /* 0x73 */ DELTAC123.bind(undefined, 1),\n\t    /* 0x74 */ DELTAC123.bind(undefined, 2),\n\t    /* 0x75 */ DELTAC123.bind(undefined, 3),\n\t    /* 0x76 */ SROUND,\n\t    /* 0x77 */ S45ROUND,\n\t    /* 0x78 */ undefined,   // TODO JROT[]\n\t    /* 0x79 */ undefined,   // TODO JROF[]\n\t    /* 0x7A */ ROFF,\n\t    /* 0x7B */ undefined,\n\t    /* 0x7C */ RUTG,\n\t    /* 0x7D */ RDTG,\n\t    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though\n\t    /* 0x7F */ POP, // actually AA, supposed to do only a pop though\n\t    /* 0x80 */ undefined,   // TODO FLIPPT\n\t    /* 0x81 */ undefined,   // TODO FLIPRGON\n\t    /* 0x82 */ undefined,   // TODO FLIPRGOFF\n\t    /* 0x83 */ undefined,\n\t    /* 0x84 */ undefined,\n\t    /* 0x85 */ SCANCTRL,\n\t    /* 0x86 */ SDPVTL.bind(undefined, 0),\n\t    /* 0x87 */ SDPVTL.bind(undefined, 1),\n\t    /* 0x88 */ GETINFO,\n\t    /* 0x89 */ undefined,   // TODO IDEF\n\t    /* 0x8A */ ROLL,\n\t    /* 0x8B */ MAX,\n\t    /* 0x8C */ MIN,\n\t    /* 0x8D */ SCANTYPE,\n\t    /* 0x8E */ INSTCTRL,\n\t    /* 0x8F */ undefined,\n\t    /* 0x90 */ undefined,\n\t    /* 0x91 */ undefined,\n\t    /* 0x92 */ undefined,\n\t    /* 0x93 */ undefined,\n\t    /* 0x94 */ undefined,\n\t    /* 0x95 */ undefined,\n\t    /* 0x96 */ undefined,\n\t    /* 0x97 */ undefined,\n\t    /* 0x98 */ undefined,\n\t    /* 0x99 */ undefined,\n\t    /* 0x9A */ undefined,\n\t    /* 0x9B */ undefined,\n\t    /* 0x9C */ undefined,\n\t    /* 0x9D */ undefined,\n\t    /* 0x9E */ undefined,\n\t    /* 0x9F */ undefined,\n\t    /* 0xA0 */ undefined,\n\t    /* 0xA1 */ undefined,\n\t    /* 0xA2 */ undefined,\n\t    /* 0xA3 */ undefined,\n\t    /* 0xA4 */ undefined,\n\t    /* 0xA5 */ undefined,\n\t    /* 0xA6 */ undefined,\n\t    /* 0xA7 */ undefined,\n\t    /* 0xA8 */ undefined,\n\t    /* 0xA9 */ undefined,\n\t    /* 0xAA */ undefined,\n\t    /* 0xAB */ undefined,\n\t    /* 0xAC */ undefined,\n\t    /* 0xAD */ undefined,\n\t    /* 0xAE */ undefined,\n\t    /* 0xAF */ undefined,\n\t    /* 0xB0 */ PUSHB.bind(undefined, 1),\n\t    /* 0xB1 */ PUSHB.bind(undefined, 2),\n\t    /* 0xB2 */ PUSHB.bind(undefined, 3),\n\t    /* 0xB3 */ PUSHB.bind(undefined, 4),\n\t    /* 0xB4 */ PUSHB.bind(undefined, 5),\n\t    /* 0xB5 */ PUSHB.bind(undefined, 6),\n\t    /* 0xB6 */ PUSHB.bind(undefined, 7),\n\t    /* 0xB7 */ PUSHB.bind(undefined, 8),\n\t    /* 0xB8 */ PUSHW.bind(undefined, 1),\n\t    /* 0xB9 */ PUSHW.bind(undefined, 2),\n\t    /* 0xBA */ PUSHW.bind(undefined, 3),\n\t    /* 0xBB */ PUSHW.bind(undefined, 4),\n\t    /* 0xBC */ PUSHW.bind(undefined, 5),\n\t    /* 0xBD */ PUSHW.bind(undefined, 6),\n\t    /* 0xBE */ PUSHW.bind(undefined, 7),\n\t    /* 0xBF */ PUSHW.bind(undefined, 8),\n\t    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n\t    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n\t    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n\t    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n\t    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n\t    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n\t    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n\t    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n\t    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n\t    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n\t    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n\t    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n\t    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n\t    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n\t    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n\t    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n\t    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n\t    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n\t    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n\t    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n\t    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n\t    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n\t    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n\t    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n\t    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n\t    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n\t    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n\t    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n\t    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n\t    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n\t    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n\t    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n\t    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n\t    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n\t    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n\t    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n\t    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n\t    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n\t    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n\t    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n\t    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n\t    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n\t    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n\t    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n\t    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n\t    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n\t    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n\t    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n\t    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n\t    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n\t    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n\t    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n\t    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n\t    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n\t    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n\t    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n\t    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n\t    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n\t    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n\t    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n\t    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n\t    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n\t    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n\t    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)\n\t];\n\n\t/*****************************\n\t  Mathematical Considerations\n\t******************************\n\n\tfv ... refers to freedom vector\n\tpv ... refers to projection vector\n\trp ... refers to reference point\n\tp  ... refers to to point being operated on\n\td  ... refers to distance\n\n\tSETRELATIVE:\n\t============\n\n\tcase freedom vector == x-axis:\n\t------------------------------\n\n\t                        (pv)\n\t                     .-'\n\t              rpd .-'\n\t               .-*\n\t          d .-'90'\n\t         .-'       '\n\t      .-'           '\n\t   *-'               ' b\n\t  rp                  '\n\t                       '\n\t                        '\n\t            p *----------*-------------- (fv)\n\t                          pm\n\n\t  rpdx = rpx + d * pv.x\n\t  rpdy = rpy + d * pv.y\n\n\t  equation of line b\n\n\t   y - rpdy = pvns * (x- rpdx)\n\n\t   y = p.y\n\n\t   x = rpdx + ( p.y - rpdy ) / pvns\n\n\n\tcase freedom vector == y-axis:\n\t------------------------------\n\n\t    * pm\n\t    |\\\n\t    | \\\n\t    |  \\\n\t    |   \\\n\t    |    \\\n\t    |     \\\n\t    |      \\\n\t    |       \\\n\t    |        \\\n\t    |         \\ b\n\t    |          \\\n\t    |           \\\n\t    |            \\    .-' (pv)\n\t    |         90 \\.-'\n\t    |           .-'* rpd\n\t    |        .-'\n\t    *     *-'  d\n\t    p     rp\n\n\t  rpdx = rpx + d * pv.x\n\t  rpdy = rpy + d * pv.y\n\n\t  equation of line b:\n\t           pvns ... normal slope to pv\n\n\t   y - rpdy = pvns * (x - rpdx)\n\n\t   x = p.x\n\n\t   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\n\tgeneric case:\n\t-------------\n\n\n\t                              .'(fv)\n\t                            .'\n\t                          .* pm\n\t                        .' !\n\t                      .'    .\n\t                    .'      !\n\t                  .'         . b\n\t                .'           !\n\t               *              .\n\t              p               !\n\t                         90   .    ... (pv)\n\t                           ...-*-'''\n\t                  ...---'''    rpd\n\t         ...---'''   d\n\t   *--'''\n\t  rp\n\n\t    rpdx = rpx + d * pv.x\n\t    rpdy = rpy + d * pv.y\n\n\t equation of line b:\n\t    pvns... normal slope to pv\n\n\t    y - rpdy = pvns * (x - rpdx)\n\n\t equation of freedom vector line:\n\t    fvs ... slope of freedom vector (=fy/fx)\n\n\t    y - py = fvs * (x - px)\n\n\n\t  on pm both equations are true for same x/y\n\n\t    y - rpdy = pvns * (x - rpdx)\n\n\t    y - py = fvs * (x - px)\n\n\t  form to y and set equal:\n\n\t    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n\t  expand:\n\n\t    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n\t  switch:\n\n\t    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n\t  solve for x:\n\n\t    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n\t          fvs * px - pvns * rpdx + rpdy - py\n\t    x =  -----------------------------------\n\t                 fvs - pvns\n\n\t  and:\n\n\t    y = fvs * (x - px) + py\n\n\n\n\tINTERPOLATE:\n\t============\n\n\tExamples of point interpolation.\n\n\tThe weight of the movement of the reference point gets bigger\n\tthe further the other reference point is away, thus the safest\n\toption (that is avoiding 0/0 divisions) is to weight the\n\toriginal distance of the other point by the sum of both distances.\n\n\tIf the sum of both distances is 0, then move the point by the\n\tarithmetic average of the movement of both reference points.\n\n\n\n\n\t           (+6)\n\t    rp1o *---->*rp1\n\t         .     .                          (+12)\n\t         .     .                  rp2o *---------->* rp2\n\t         .     .                       .           .\n\t         .     .                       .           .\n\t         .    10          20           .           .\n\t         |.........|...................|           .\n\t               .   .                               .\n\t               .   . (+8)                          .\n\t                po *------>*p                      .\n\t               .           .                       .\n\t               .    12     .          24           .\n\t               |...........|.......................|\n\t                                  36\n\n\n\t-------\n\n\n\n\t           (+10)\n\t    rp1o *-------->*rp1\n\t         .         .                      (-10)\n\t         .         .              rp2 *<---------* rpo2\n\t         .         .                   .         .\n\t         .         .                   .         .\n\t         .    10   .          30       .         .\n\t         |.........|.............................|\n\t                   .                   .\n\t                   . (+5)              .\n\t                po *--->* p            .\n\t                   .    .              .\n\t                   .    .   20         .\n\t                   |....|..............|\n\t                     5        15\n\n\n\t-------\n\n\n\t           (+10)\n\t    rp1o *-------->*rp1\n\t         .         .\n\t         .         .\n\t    rp2o *-------->*rp2\n\n\n\t                               (+10)\n\t                          po *-------->* p\n\n\t-------\n\n\n\t           (+10)\n\t    rp1o *-------->*rp1\n\t         .         .\n\t         .         .(+30)\n\t    rp2o *---------------------------->*rp2\n\n\n\t                                        (+25)\n\t                          po *----------------------->* p\n\n\n\n\tvim: set ts=4 sw=4 expandtab:\n\t*****/\n\n\t// The Font object\n\n\t// This code is based on Array.from implementation for strings in https://github.com/mathiasbynens/Array.from\n\tvar arrayFromString = Array.from || (function (s) { return s.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?|[^\\uD800-\\uDFFF]|./g) || []; });\n\n\t/**\n\t * @typedef FontOptions\n\t * @type Object\n\t * @property {Boolean} empty - whether to create a new empty font\n\t * @property {string} familyName\n\t * @property {string} styleName\n\t * @property {string=} fullName\n\t * @property {string=} postScriptName\n\t * @property {string=} designer\n\t * @property {string=} designerURL\n\t * @property {string=} manufacturer\n\t * @property {string=} manufacturerURL\n\t * @property {string=} license\n\t * @property {string=} licenseURL\n\t * @property {string=} version\n\t * @property {string=} description\n\t * @property {string=} copyright\n\t * @property {string=} trademark\n\t * @property {Number} unitsPerEm\n\t * @property {Number} ascender\n\t * @property {Number} descender\n\t * @property {Number} createdTimestamp\n\t * @property {string=} weightClass\n\t * @property {string=} widthClass\n\t * @property {string=} fsSelection\n\t */\n\n\t/**\n\t * A Font represents a loaded OpenType font file.\n\t * It contains a set of glyphs and methods to draw text on a drawing context,\n\t * or to get a path representing the text.\n\t * @exports opentype.Font\n\t * @class\n\t * @param {FontOptions}\n\t * @constructor\n\t */\n\tfunction Font(options) {\n\t    options = options || {};\n\n\t    if (!options.empty) {\n\t        // Check that we've provided the minimum set of names.\n\t        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');\n\t        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');\n\t        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');\n\t        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');\n\t        checkArgument(options.descender, 'When creating a new Font object, descender is required.');\n\t        checkArgument(options.descender < 0, 'Descender should be negative (e.g. -512).');\n\n\t        // OS X will complain if the names are empty, so we put a single space everywhere by default.\n\t        this.names = {\n\t            fontFamily: {en: options.familyName || ' '},\n\t            fontSubfamily: {en: options.styleName || ' '},\n\t            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},\n\t            // postScriptName may not contain any whitespace\n\t            postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\\s/g, '')},\n\t            designer: {en: options.designer || ' '},\n\t            designerURL: {en: options.designerURL || ' '},\n\t            manufacturer: {en: options.manufacturer || ' '},\n\t            manufacturerURL: {en: options.manufacturerURL || ' '},\n\t            license: {en: options.license || ' '},\n\t            licenseURL: {en: options.licenseURL || ' '},\n\t            version: {en: options.version || 'Version 0.1'},\n\t            description: {en: options.description || ' '},\n\t            copyright: {en: options.copyright || ' '},\n\t            trademark: {en: options.trademark || ' '}\n\t        };\n\t        this.unitsPerEm = options.unitsPerEm || 1000;\n\t        this.ascender = options.ascender;\n\t        this.descender = options.descender;\n\t        this.createdTimestamp = options.createdTimestamp;\n\t        this.tables = { os2: {\n\t            usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,\n\t            usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,\n\t            fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR\n\t        } };\n\t    }\n\n\t    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n\t    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n\t    this.encoding = new DefaultEncoding(this);\n\t    this.position = new Position(this);\n\t    this.substitution = new Substitution(this);\n\t    this.tables = this.tables || {};\n\n\t    Object.defineProperty(this, 'hinting', {\n\t        get: function() {\n\t            if (this._hinting) { return this._hinting; }\n\t            if (this.outlinesFormat === 'truetype') {\n\t                return (this._hinting = new Hinting(this));\n\t            }\n\t        }\n\t    });\n\t}\n\n\t/**\n\t * Check if the font has a glyph for the given character.\n\t * @param  {string}\n\t * @return {Boolean}\n\t */\n\tFont.prototype.hasChar = function(c) {\n\t    return this.encoding.charToGlyphIndex(c) !== null;\n\t};\n\n\t/**\n\t * Convert the given character to a single glyph index.\n\t * Note that this function assumes that there is a one-to-one mapping between\n\t * the given character and a glyph; for complex scripts this might not be the case.\n\t * @param  {string}\n\t * @return {Number}\n\t */\n\tFont.prototype.charToGlyphIndex = function(s) {\n\t    return this.encoding.charToGlyphIndex(s);\n\t};\n\n\t/**\n\t * Convert the given character to a single Glyph object.\n\t * Note that this function assumes that there is a one-to-one mapping between\n\t * the given character and a glyph; for complex scripts this might not be the case.\n\t * @param  {string}\n\t * @return {opentype.Glyph}\n\t */\n\tFont.prototype.charToGlyph = function(c) {\n\t    var glyphIndex = this.charToGlyphIndex(c);\n\t    var glyph = this.glyphs.get(glyphIndex);\n\t    if (!glyph) {\n\t        // .notdef\n\t        glyph = this.glyphs.get(0);\n\t    }\n\n\t    return glyph;\n\t};\n\n\t/**\n\t * Convert the given text to a list of Glyph objects.\n\t * Note that there is no strict one-to-one mapping between characters and\n\t * glyphs, so the list of returned glyphs can be larger or smaller than the\n\t * length of the given string.\n\t * @param  {string}\n\t * @param  {GlyphRenderOptions} [options]\n\t * @return {opentype.Glyph[]}\n\t */\n\tFont.prototype.stringToGlyphs = function(s, options) {\n\t    var this$1 = this;\n\n\t    options = options || this.defaultRenderOptions;\n\t    // Get glyph indexes\n\t    var chars = arrayFromString(s);\n\t    var indexes = [];\n\t    for (var i = 0; i < chars.length; i += 1) {\n\t        var c = chars[i];\n\t        indexes.push(this$1.charToGlyphIndex(c));\n\t    }\n\t    var length = indexes.length;\n\n\t    // Apply substitutions on glyph indexes\n\t    if (options.features) {\n\t        var script = options.script || this.substitution.getDefaultScriptName();\n\t        var manyToOne = [];\n\t        if (options.features.liga) { manyToOne = manyToOne.concat(this.substitution.getFeature('liga', script, options.language)); }\n\t        if (options.features.rlig) { manyToOne = manyToOne.concat(this.substitution.getFeature('rlig', script, options.language)); }\n\t        for (var i$1 = 0; i$1 < length; i$1 += 1) {\n\t            for (var j = 0; j < manyToOne.length; j++) {\n\t                var ligature = manyToOne[j];\n\t                var components = ligature.sub;\n\t                var compCount = components.length;\n\t                var k = 0;\n\t                while (k < compCount && components[k] === indexes[i$1 + k]) { k++; }\n\t                if (k === compCount) {\n\t                    indexes.splice(i$1, compCount, ligature.by);\n\t                    length = length - compCount + 1;\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    // convert glyph indexes to glyph objects\n\t    var glyphs = new Array(length);\n\t    var notdef = this.glyphs.get(0);\n\t    for (var i$2 = 0; i$2 < length; i$2 += 1) {\n\t        glyphs[i$2] = this$1.glyphs.get(indexes[i$2]) || notdef;\n\t    }\n\t    return glyphs;\n\t};\n\n\t/**\n\t * @param  {string}\n\t * @return {Number}\n\t */\n\tFont.prototype.nameToGlyphIndex = function(name) {\n\t    return this.glyphNames.nameToGlyphIndex(name);\n\t};\n\n\t/**\n\t * @param  {string}\n\t * @return {opentype.Glyph}\n\t */\n\tFont.prototype.nameToGlyph = function(name) {\n\t    var glyphIndex = this.nameToGlyphIndex(name);\n\t    var glyph = this.glyphs.get(glyphIndex);\n\t    if (!glyph) {\n\t        // .notdef\n\t        glyph = this.glyphs.get(0);\n\t    }\n\n\t    return glyph;\n\t};\n\n\t/**\n\t * @param  {Number}\n\t * @return {String}\n\t */\n\tFont.prototype.glyphIndexToName = function(gid) {\n\t    if (!this.glyphNames.glyphIndexToName) {\n\t        return '';\n\t    }\n\n\t    return this.glyphNames.glyphIndexToName(gid);\n\t};\n\n\t/**\n\t * Retrieve the value of the kerning pair between the left glyph (or its index)\n\t * and the right glyph (or its index). If no kerning pair is found, return 0.\n\t * The kerning value gets added to the advance width when calculating the spacing\n\t * between glyphs.\n\t * For GPOS kerning, this method uses the default script and language, which covers\n\t * most use cases. To have greater control, use font.position.getKerningValue .\n\t * @param  {opentype.Glyph} leftGlyph\n\t * @param  {opentype.Glyph} rightGlyph\n\t * @return {Number}\n\t */\n\tFont.prototype.getKerningValue = function(leftGlyph, rightGlyph) {\n\t    leftGlyph = leftGlyph.index || leftGlyph;\n\t    rightGlyph = rightGlyph.index || rightGlyph;\n\t    var gposKerning = this.position.defaultKerningTables;\n\t    if (gposKerning) {\n\t        return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);\n\t    }\n\t    // \"kern\" table\n\t    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;\n\t};\n\n\t/**\n\t * @typedef GlyphRenderOptions\n\t * @type Object\n\t * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n\t *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n\t * @property {string} [language='dflt'] - language system used to determine which features to apply.\n\t *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n\t * @property {boolean} [kerning=true] - whether to include kerning values\n\t * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n\t *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n\t */\n\tFont.prototype.defaultRenderOptions = {\n\t    kerning: true,\n\t    features: {\n\t        liga: true,\n\t        rlig: true\n\t    }\n\t};\n\n\t/**\n\t * Helper function that invokes the given callback for each glyph in the given text.\n\t * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n\t * @param {string} text - The text to apply.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {GlyphRenderOptions=} options\n\t * @param  {Function} callback\n\t */\n\tFont.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {\n\t    var this$1 = this;\n\n\t    x = x !== undefined ? x : 0;\n\t    y = y !== undefined ? y : 0;\n\t    fontSize = fontSize !== undefined ? fontSize : 72;\n\t    options = options || this.defaultRenderOptions;\n\t    var fontScale = 1 / this.unitsPerEm * fontSize;\n\t    var glyphs = this.stringToGlyphs(text, options);\n\t    var kerningLookups;\n\t    if (options.kerning) {\n\t        var script = options.script || this.position.getDefaultScriptName();\n\t        kerningLookups = this.position.getKerningTables(script, options.language);\n\t    }\n\t    for (var i = 0; i < glyphs.length; i += 1) {\n\t        var glyph = glyphs[i];\n\t        callback.call(this$1, glyph, x, y, fontSize, options);\n\t        if (glyph.advanceWidth) {\n\t            x += glyph.advanceWidth * fontScale;\n\t        }\n\n\t        if (options.kerning && i < glyphs.length - 1) {\n\t            // We should apply position adjustment lookups in a more generic way.\n\t            // Here we only use the xAdvance value.\n\t            var kerningValue = kerningLookups ?\n\t                  this$1.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :\n\t                  this$1.getKerningValue(glyph, glyphs[i + 1]);\n\t            x += kerningValue * fontScale;\n\t        }\n\n\t        if (options.letterSpacing) {\n\t            x += options.letterSpacing * fontSize;\n\t        } else if (options.tracking) {\n\t            x += (options.tracking / 1000) * fontSize;\n\t        }\n\t    }\n\t    return x;\n\t};\n\n\t/**\n\t * Create a Path object that represents the given text.\n\t * @param  {string} text - The text to create.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {GlyphRenderOptions=} options\n\t * @return {opentype.Path}\n\t */\n\tFont.prototype.getPath = function(text, x, y, fontSize, options) {\n\t    var fullPath = new Path();\n\t    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n\t        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n\t        fullPath.extend(glyphPath);\n\t    });\n\t    return fullPath;\n\t};\n\n\t/**\n\t * Create an array of Path objects that represent the glyphs of a given text.\n\t * @param  {string} text - The text to create.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {GlyphRenderOptions=} options\n\t * @return {opentype.Path[]}\n\t */\n\tFont.prototype.getPaths = function(text, x, y, fontSize, options) {\n\t    var glyphPaths = [];\n\t    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n\t        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n\t        glyphPaths.push(glyphPath);\n\t    });\n\n\t    return glyphPaths;\n\t};\n\n\t/**\n\t * Returns the advance width of a text.\n\t *\n\t * This is something different than Path.getBoundingBox() as for example a\n\t * suffixed whitespace increases the advanceWidth but not the bounding box\n\t * or an overhanging letter like a calligraphic 'f' might have a quite larger\n\t * bounding box than its advance width.\n\t *\n\t * This corresponds to canvas2dContext.measureText(text).width\n\t *\n\t * @param  {string} text - The text to create.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {GlyphRenderOptions=} options\n\t * @return advance width\n\t */\n\tFont.prototype.getAdvanceWidth = function(text, fontSize, options) {\n\t    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});\n\t};\n\n\t/**\n\t * Draw the text on the given drawing context.\n\t * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n\t * @param  {string} text - The text to create.\n\t * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param  {GlyphRenderOptions=} options\n\t */\n\tFont.prototype.draw = function(ctx, text, x, y, fontSize, options) {\n\t    this.getPath(text, x, y, fontSize, options).draw(ctx);\n\t};\n\n\t/**\n\t * Draw the points of all glyphs in the text.\n\t * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n\t * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n\t * @param {string} text - The text to create.\n\t * @param {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param {GlyphRenderOptions=} options\n\t */\n\tFont.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {\n\t    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n\t        glyph.drawPoints(ctx, gX, gY, gFontSize);\n\t    });\n\t};\n\n\t/**\n\t * Draw lines indicating important font measurements for all glyphs in the text.\n\t * Black lines indicate the origin of the coordinate system (point 0,0).\n\t * Blue lines indicate the glyph bounding box.\n\t * Green line indicates the advance width of the glyph.\n\t * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n\t * @param {string} text - The text to create.\n\t * @param {number} [x=0] - Horizontal position of the beginning of the text.\n\t * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n\t * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n\t * @param {GlyphRenderOptions=} options\n\t */\n\tFont.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {\n\t    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n\t        glyph.drawMetrics(ctx, gX, gY, gFontSize);\n\t    });\n\t};\n\n\t/**\n\t * @param  {string}\n\t * @return {string}\n\t */\n\tFont.prototype.getEnglishName = function(name) {\n\t    var translations = this.names[name];\n\t    if (translations) {\n\t        return translations.en;\n\t    }\n\t};\n\n\t/**\n\t * Validate\n\t */\n\tFont.prototype.validate = function() {\n\t    var _this = this;\n\n\t    function assert(predicate, message) {\n\t    }\n\n\t    function assertNamePresent(name) {\n\t        var englishName = _this.getEnglishName(name);\n\t        assert(englishName && englishName.trim().length > 0,\n\t               'No English ' + name + ' specified.');\n\t    }\n\n\t    // Identification information\n\t    assertNamePresent('fontFamily');\n\t    assertNamePresent('weightName');\n\t    assertNamePresent('manufacturer');\n\t    assertNamePresent('copyright');\n\t    assertNamePresent('version');\n\n\t    // Dimension information\n\t    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');\n\t};\n\n\t/**\n\t * Convert the font object to a SFNT data structure.\n\t * This structure contains all the necessary tables and metadata to create a binary OTF file.\n\t * @return {opentype.Table}\n\t */\n\tFont.prototype.toTables = function() {\n\t    return sfnt.fontToTable(this);\n\t};\n\t/**\n\t * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.\n\t */\n\tFont.prototype.toBuffer = function() {\n\t    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');\n\t    return this.toArrayBuffer();\n\t};\n\t/**\n\t * Converts a `opentype.Font` into an `ArrayBuffer`\n\t * @return {ArrayBuffer}\n\t */\n\tFont.prototype.toArrayBuffer = function() {\n\t    var sfntTable = this.toTables();\n\t    var bytes = sfntTable.encode();\n\t    var buffer = new ArrayBuffer(bytes.length);\n\t    var intArray = new Uint8Array(buffer);\n\t    for (var i = 0; i < bytes.length; i++) {\n\t        intArray[i] = bytes[i];\n\t    }\n\n\t    return buffer;\n\t};\n\n\t/**\n\t * Initiate a download of the OpenType font.\n\t */\n\tFont.prototype.download = function(fileName) {\n\t    var familyName = this.getEnglishName('fontFamily');\n\t    var styleName = this.getEnglishName('fontSubfamily');\n\t    fileName = fileName || familyName.replace(/\\s/g, '') + '-' + styleName + '.otf';\n\t    var arrayBuffer = this.toArrayBuffer();\n\n\t    if (isBrowser()) {\n\t        window.URL = window.URL || window.webkitURL;\n\n\t        if (window.URL) {\n\t            var dataView = new DataView(arrayBuffer);\n\t            var blob = new Blob([dataView], {type: 'font/opentype'});\n\n\t            var link = document.createElement('a');\n\t            link.href = window.URL.createObjectURL(blob);\n\t            link.download = fileName;\n\n\t            var event = document.createEvent('MouseEvents');\n\t            event.initEvent('click', true, false);\n\t            link.dispatchEvent(event);\n\t        } else {\n\t            console.warn('Font file could not be downloaded. Try using a different browser.');\n\t        }\n\t    } else {\n\t        var fs = __webpack_require__(/*! fs */ \"?4db5\");\n\t        var buffer = arrayBufferToNodeBuffer(arrayBuffer);\n\t        fs.writeFileSync(fileName, buffer);\n\t    }\n\t};\n\t/**\n\t * @private\n\t */\n\tFont.prototype.fsSelectionValues = {\n\t    ITALIC:              0x001, //1\n\t    UNDERSCORE:          0x002, //2\n\t    NEGATIVE:            0x004, //4\n\t    OUTLINED:            0x008, //8\n\t    STRIKEOUT:           0x010, //16\n\t    BOLD:                0x020, //32\n\t    REGULAR:             0x040, //64\n\t    USER_TYPO_METRICS:   0x080, //128\n\t    WWS:                 0x100, //256\n\t    OBLIQUE:             0x200  //512\n\t};\n\n\t/**\n\t * @private\n\t */\n\tFont.prototype.usWidthClasses = {\n\t    ULTRA_CONDENSED: 1,\n\t    EXTRA_CONDENSED: 2,\n\t    CONDENSED: 3,\n\t    SEMI_CONDENSED: 4,\n\t    MEDIUM: 5,\n\t    SEMI_EXPANDED: 6,\n\t    EXPANDED: 7,\n\t    EXTRA_EXPANDED: 8,\n\t    ULTRA_EXPANDED: 9\n\t};\n\n\t/**\n\t * @private\n\t */\n\tFont.prototype.usWeightClasses = {\n\t    THIN: 100,\n\t    EXTRA_LIGHT: 200,\n\t    LIGHT: 300,\n\t    NORMAL: 400,\n\t    MEDIUM: 500,\n\t    SEMI_BOLD: 600,\n\t    BOLD: 700,\n\t    EXTRA_BOLD: 800,\n\t    BLACK:    900\n\t};\n\n\t// The `fvar` table stores font variation axes and instances.\n\n\tfunction addName(name, names) {\n\t    var nameString = JSON.stringify(name);\n\t    var nameID = 256;\n\t    for (var nameKey in names) {\n\t        var n = parseInt(nameKey);\n\t        if (!n || n < 256) {\n\t            continue;\n\t        }\n\n\t        if (JSON.stringify(names[nameKey]) === nameString) {\n\t            return n;\n\t        }\n\n\t        if (nameID <= n) {\n\t            nameID = n + 1;\n\t        }\n\t    }\n\n\t    names[nameID] = name;\n\t    return nameID;\n\t}\n\n\tfunction makeFvarAxis(n, axis, names) {\n\t    var nameID = addName(axis.name, names);\n\t    return [\n\t        {name: 'tag_' + n, type: 'TAG', value: axis.tag},\n\t        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},\n\t        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},\n\t        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},\n\t        {name: 'flags_' + n, type: 'USHORT', value: 0},\n\t        {name: 'nameID_' + n, type: 'USHORT', value: nameID}\n\t    ];\n\t}\n\n\tfunction parseFvarAxis(data, start, names) {\n\t    var axis = {};\n\t    var p = new parse.Parser(data, start);\n\t    axis.tag = p.parseTag();\n\t    axis.minValue = p.parseFixed();\n\t    axis.defaultValue = p.parseFixed();\n\t    axis.maxValue = p.parseFixed();\n\t    p.skip('uShort', 1);  // reserved for flags; no values defined\n\t    axis.name = names[p.parseUShort()] || {};\n\t    return axis;\n\t}\n\n\tfunction makeFvarInstance(n, inst, axes, names) {\n\t    var nameID = addName(inst.name, names);\n\t    var fields = [\n\t        {name: 'nameID_' + n, type: 'USHORT', value: nameID},\n\t        {name: 'flags_' + n, type: 'USHORT', value: 0}\n\t    ];\n\n\t    for (var i = 0; i < axes.length; ++i) {\n\t        var axisTag = axes[i].tag;\n\t        fields.push({\n\t            name: 'axis_' + n + ' ' + axisTag,\n\t            type: 'FIXED',\n\t            value: inst.coordinates[axisTag] << 16\n\t        });\n\t    }\n\n\t    return fields;\n\t}\n\n\tfunction parseFvarInstance(data, start, axes, names) {\n\t    var inst = {};\n\t    var p = new parse.Parser(data, start);\n\t    inst.name = names[p.parseUShort()] || {};\n\t    p.skip('uShort', 1);  // reserved for flags; no values defined\n\n\t    inst.coordinates = {};\n\t    for (var i = 0; i < axes.length; ++i) {\n\t        inst.coordinates[axes[i].tag] = p.parseFixed();\n\t    }\n\n\t    return inst;\n\t}\n\n\tfunction makeFvarTable(fvar, names) {\n\t    var result = new table.Table('fvar', [\n\t        {name: 'version', type: 'ULONG', value: 0x10000},\n\t        {name: 'offsetToData', type: 'USHORT', value: 0},\n\t        {name: 'countSizePairs', type: 'USHORT', value: 2},\n\t        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},\n\t        {name: 'axisSize', type: 'USHORT', value: 20},\n\t        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},\n\t        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}\n\t    ]);\n\t    result.offsetToData = result.sizeOf();\n\n\t    for (var i = 0; i < fvar.axes.length; i++) {\n\t        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));\n\t    }\n\n\t    for (var j = 0; j < fvar.instances.length; j++) {\n\t        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));\n\t    }\n\n\t    return result;\n\t}\n\n\tfunction parseFvarTable(data, start, names) {\n\t    var p = new parse.Parser(data, start);\n\t    var tableVersion = p.parseULong();\n\t    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');\n\t    var offsetToData = p.parseOffset16();\n\t    // Skip countSizePairs.\n\t    p.skip('uShort', 1);\n\t    var axisCount = p.parseUShort();\n\t    var axisSize = p.parseUShort();\n\t    var instanceCount = p.parseUShort();\n\t    var instanceSize = p.parseUShort();\n\n\t    var axes = [];\n\t    for (var i = 0; i < axisCount; i++) {\n\t        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));\n\t    }\n\n\t    var instances = [];\n\t    var instanceStart = start + offsetToData + axisCount * axisSize;\n\t    for (var j = 0; j < instanceCount; j++) {\n\t        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));\n\t    }\n\n\t    return {axes: axes, instances: instances};\n\t}\n\n\tvar fvar = { make: makeFvarTable, parse: parseFvarTable };\n\n\t// The `GPOS` table contains kerning pairs, among other things.\n\n\tvar subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused\n\n\t// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable\n\t// this = Parser instance\n\tsubtableParsers$1[1] = function parseLookup1() {\n\t    var start = this.offset + this.relativeOffset;\n\t    var posformat = this.parseUShort();\n\t    if (posformat === 1) {\n\t        return {\n\t            posFormat: 1,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            value: this.parseValueRecord()\n\t        };\n\t    } else if (posformat === 2) {\n\t        return {\n\t            posFormat: 2,\n\t            coverage: this.parsePointer(Parser.coverage),\n\t            values: this.parseValueRecordList()\n\t        };\n\t    }\n\t    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');\n\t};\n\n\t// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable\n\tsubtableParsers$1[2] = function parseLookup2() {\n\t    var start = this.offset + this.relativeOffset;\n\t    var posFormat = this.parseUShort();\n\t    check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');\n\t    var coverage = this.parsePointer(Parser.coverage);\n\t    var valueFormat1 = this.parseUShort();\n\t    var valueFormat2 = this.parseUShort();\n\t    if (posFormat === 1) {\n\t        // Adjustments for Glyph Pairs\n\t        return {\n\t            posFormat: posFormat,\n\t            coverage: coverage,\n\t            valueFormat1: valueFormat1,\n\t            valueFormat2: valueFormat2,\n\t            pairSets: this.parseList(Parser.pointer(Parser.list(function() {\n\t                return {        // pairValueRecord\n\t                    secondGlyph: this.parseUShort(),\n\t                    value1: this.parseValueRecord(valueFormat1),\n\t                    value2: this.parseValueRecord(valueFormat2)\n\t                };\n\t            })))\n\t        };\n\t    } else if (posFormat === 2) {\n\t        var classDef1 = this.parsePointer(Parser.classDef);\n\t        var classDef2 = this.parsePointer(Parser.classDef);\n\t        var class1Count = this.parseUShort();\n\t        var class2Count = this.parseUShort();\n\t        return {\n\t            // Class Pair Adjustment\n\t            posFormat: posFormat,\n\t            coverage: coverage,\n\t            valueFormat1: valueFormat1,\n\t            valueFormat2: valueFormat2,\n\t            classDef1: classDef1,\n\t            classDef2: classDef2,\n\t            class1Count: class1Count,\n\t            class2Count: class2Count,\n\t            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {\n\t                return {\n\t                    value1: this.parseValueRecord(valueFormat1),\n\t                    value2: this.parseValueRecord(valueFormat2)\n\t                };\n\t            }))\n\t        };\n\t    }\n\t};\n\n\tsubtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };\n\tsubtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };\n\tsubtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };\n\tsubtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };\n\tsubtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };\n\tsubtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };\n\tsubtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };\n\n\t// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos\n\tfunction parseGposTable(data, start) {\n\t    start = start || 0;\n\t    var p = new Parser(data, start);\n\t    var tableVersion = p.parseVersion(1);\n\t    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);\n\n\t    if (tableVersion === 1) {\n\t        return {\n\t            version: tableVersion,\n\t            scripts: p.parseScriptList(),\n\t            features: p.parseFeatureList(),\n\t            lookups: p.parseLookupList(subtableParsers$1)\n\t        };\n\t    } else {\n\t        return {\n\t            version: tableVersion,\n\t            scripts: p.parseScriptList(),\n\t            features: p.parseFeatureList(),\n\t            lookups: p.parseLookupList(subtableParsers$1),\n\t            variations: p.parseFeatureVariationsList()\n\t        };\n\t    }\n\n\t}\n\n\t// GPOS Writing //////////////////////////////////////////////\n\t// NOT SUPPORTED\n\tvar subtableMakers$1 = new Array(10);\n\n\tfunction makeGposTable(gpos) {\n\t    return new table.Table('GPOS', [\n\t        {name: 'version', type: 'ULONG', value: 0x10000},\n\t        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},\n\t        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},\n\t        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}\n\t    ]);\n\t}\n\n\tvar gpos = { parse: parseGposTable, make: makeGposTable };\n\n\t// The `kern` table contains kerning pairs.\n\n\tfunction parseWindowsKernTable(p) {\n\t    var pairs = {};\n\t    // Skip nTables.\n\t    p.skip('uShort');\n\t    var subtableVersion = p.parseUShort();\n\t    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');\n\t    // Skip subtableLength, subtableCoverage\n\t    p.skip('uShort', 2);\n\t    var nPairs = p.parseUShort();\n\t    // Skip searchRange, entrySelector, rangeShift.\n\t    p.skip('uShort', 3);\n\t    for (var i = 0; i < nPairs; i += 1) {\n\t        var leftIndex = p.parseUShort();\n\t        var rightIndex = p.parseUShort();\n\t        var value = p.parseShort();\n\t        pairs[leftIndex + ',' + rightIndex] = value;\n\t    }\n\t    return pairs;\n\t}\n\n\tfunction parseMacKernTable(p) {\n\t    var pairs = {};\n\t    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.\n\t    // Skip the rest.\n\t    p.skip('uShort');\n\t    var nTables = p.parseULong();\n\t    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');\n\t    if (nTables > 1) {\n\t        console.warn('Only the first kern subtable is supported.');\n\t    }\n\t    p.skip('uLong');\n\t    var coverage = p.parseUShort();\n\t    var subtableVersion = coverage & 0xFF;\n\t    p.skip('uShort');\n\t    if (subtableVersion === 0) {\n\t        var nPairs = p.parseUShort();\n\t        // Skip searchRange, entrySelector, rangeShift.\n\t        p.skip('uShort', 3);\n\t        for (var i = 0; i < nPairs; i += 1) {\n\t            var leftIndex = p.parseUShort();\n\t            var rightIndex = p.parseUShort();\n\t            var value = p.parseShort();\n\t            pairs[leftIndex + ',' + rightIndex] = value;\n\t        }\n\t    }\n\t    return pairs;\n\t}\n\n\t// Parse the `kern` table which contains kerning pairs.\n\tfunction parseKernTable(data, start) {\n\t    var p = new parse.Parser(data, start);\n\t    var tableVersion = p.parseUShort();\n\t    if (tableVersion === 0) {\n\t        return parseWindowsKernTable(p);\n\t    } else if (tableVersion === 1) {\n\t        return parseMacKernTable(p);\n\t    } else {\n\t        throw new Error('Unsupported kern table version (' + tableVersion + ').');\n\t    }\n\t}\n\n\tvar kern = { parse: parseKernTable };\n\n\t// The `loca` table stores the offsets to the locations of the glyphs in the font.\n\n\t// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n\t// relative to the beginning of the glyphData table.\n\t// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n\t// The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n\t// version where offsets are stored as uLongs. The `head` table specifies which version to use\n\t// (under indexToLocFormat).\n\tfunction parseLocaTable(data, start, numGlyphs, shortVersion) {\n\t    var p = new parse.Parser(data, start);\n\t    var parseFn = shortVersion ? p.parseUShort : p.parseULong;\n\t    // There is an extra entry after the last index element to compute the length of the last glyph.\n\t    // That's why we use numGlyphs + 1.\n\t    var glyphOffsets = [];\n\t    for (var i = 0; i < numGlyphs + 1; i += 1) {\n\t        var glyphOffset = parseFn.call(p);\n\t        if (shortVersion) {\n\t            // The short table version stores the actual offset divided by 2.\n\t            glyphOffset *= 2;\n\t        }\n\n\t        glyphOffsets.push(glyphOffset);\n\t    }\n\n\t    return glyphOffsets;\n\t}\n\n\tvar loca = { parse: parseLocaTable };\n\n\t// opentype.js\n\n\t/**\n\t * The opentype library.\n\t * @namespace opentype\n\t */\n\n\t// File loaders /////////////////////////////////////////////////////////\n\t/**\n\t * Loads a font from a file. The callback throws an error message as the first parameter if it fails\n\t * and the font as an ArrayBuffer in the second parameter if it succeeds.\n\t * @param  {string} path - The path of the file\n\t * @param  {Function} callback - The function to call when the font load completes\n\t */\n\tfunction loadFromFile(path, callback) {\n\t    var fs = __webpack_require__(/*! fs */ \"?4db5\");\n\t    fs.readFile(path, function(err, buffer) {\n\t        if (err) {\n\t            return callback(err.message);\n\t        }\n\n\t        callback(null, nodeBufferToArrayBuffer(buffer));\n\t    });\n\t}\n\t/**\n\t * Loads a font from a URL. The callback throws an error message as the first parameter if it fails\n\t * and the font as an ArrayBuffer in the second parameter if it succeeds.\n\t * @param  {string} url - The URL of the font file.\n\t * @param  {Function} callback - The function to call when the font load completes\n\t */\n\tfunction loadFromUrl(url, callback) {\n\t    var request = new XMLHttpRequest();\n\t    request.open('get', url, true);\n\t    request.responseType = 'arraybuffer';\n\t    request.onload = function() {\n\t        if (request.response) {\n\t            return callback(null, request.response);\n\t        } else {\n\t            return callback('Font could not be loaded: ' + request.statusText);\n\t        }\n\t    };\n\n\t    request.onerror = function () {\n\t        callback('Font could not be loaded');\n\t    };\n\n\t    request.send();\n\t}\n\n\t// Table Directory Entries //////////////////////////////////////////////\n\t/**\n\t * Parses OpenType table entries.\n\t * @param  {DataView}\n\t * @param  {Number}\n\t * @return {Object[]}\n\t */\n\tfunction parseOpenTypeTableEntries(data, numTables) {\n\t    var tableEntries = [];\n\t    var p = 12;\n\t    for (var i = 0; i < numTables; i += 1) {\n\t        var tag = parse.getTag(data, p);\n\t        var checksum = parse.getULong(data, p + 4);\n\t        var offset = parse.getULong(data, p + 8);\n\t        var length = parse.getULong(data, p + 12);\n\t        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});\n\t        p += 16;\n\t    }\n\n\t    return tableEntries;\n\t}\n\n\t/**\n\t * Parses WOFF table entries.\n\t * @param  {DataView}\n\t * @param  {Number}\n\t * @return {Object[]}\n\t */\n\tfunction parseWOFFTableEntries(data, numTables) {\n\t    var tableEntries = [];\n\t    var p = 44; // offset to the first table directory entry.\n\t    for (var i = 0; i < numTables; i += 1) {\n\t        var tag = parse.getTag(data, p);\n\t        var offset = parse.getULong(data, p + 4);\n\t        var compLength = parse.getULong(data, p + 8);\n\t        var origLength = parse.getULong(data, p + 12);\n\t        var compression = (void 0);\n\t        if (compLength < origLength) {\n\t            compression = 'WOFF';\n\t        } else {\n\t            compression = false;\n\t        }\n\n\t        tableEntries.push({tag: tag, offset: offset, compression: compression,\n\t            compressedLength: compLength, length: origLength});\n\t        p += 20;\n\t    }\n\n\t    return tableEntries;\n\t}\n\n\t/**\n\t * @typedef TableData\n\t * @type Object\n\t * @property {DataView} data - The DataView\n\t * @property {number} offset - The data offset.\n\t */\n\n\t/**\n\t * @param  {DataView}\n\t * @param  {Object}\n\t * @return {TableData}\n\t */\n\tfunction uncompressTable(data, tableEntry) {\n\t    if (tableEntry.compression === 'WOFF') {\n\t        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);\n\t        var outBuffer = new Uint8Array(tableEntry.length);\n\t        tinyInflate(inBuffer, outBuffer);\n\t        if (outBuffer.byteLength !== tableEntry.length) {\n\t            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\\'t match recorded length');\n\t        }\n\n\t        var view = new DataView(outBuffer.buffer, 0);\n\t        return {data: view, offset: 0};\n\t    } else {\n\t        return {data: data, offset: tableEntry.offset};\n\t    }\n\t}\n\n\t// Public API ///////////////////////////////////////////////////////////\n\n\t/**\n\t * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n\t * Throws an error if the font could not be parsed.\n\t * @param  {ArrayBuffer}\n\t * @return {opentype.Font}\n\t */\n\tfunction parseBuffer(buffer) {\n\t    var indexToLocFormat;\n\t    var ltagTable;\n\n\t    // Since the constructor can also be called to create new fonts from scratch, we indicate this\n\t    // should be an empty font that we'll fill with our own data.\n\t    var font = new Font({empty: true});\n\n\t    // OpenType fonts use big endian byte ordering.\n\t    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n\t    // Instead we use DataViews where we can specify endianness.\n\t    var data = new DataView(buffer, 0);\n\t    var numTables;\n\t    var tableEntries = [];\n\t    var signature = parse.getTag(data, 0);\n\t    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {\n\t        font.outlinesFormat = 'truetype';\n\t        numTables = parse.getUShort(data, 4);\n\t        tableEntries = parseOpenTypeTableEntries(data, numTables);\n\t    } else if (signature === 'OTTO') {\n\t        font.outlinesFormat = 'cff';\n\t        numTables = parse.getUShort(data, 4);\n\t        tableEntries = parseOpenTypeTableEntries(data, numTables);\n\t    } else if (signature === 'wOFF') {\n\t        var flavor = parse.getTag(data, 4);\n\t        if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n\t            font.outlinesFormat = 'truetype';\n\t        } else if (flavor === 'OTTO') {\n\t            font.outlinesFormat = 'cff';\n\t        } else {\n\t            throw new Error('Unsupported OpenType flavor ' + signature);\n\t        }\n\n\t        numTables = parse.getUShort(data, 12);\n\t        tableEntries = parseWOFFTableEntries(data, numTables);\n\t    } else {\n\t        throw new Error('Unsupported OpenType signature ' + signature);\n\t    }\n\n\t    var cffTableEntry;\n\t    var fvarTableEntry;\n\t    var glyfTableEntry;\n\t    var gposTableEntry;\n\t    var gsubTableEntry;\n\t    var hmtxTableEntry;\n\t    var kernTableEntry;\n\t    var locaTableEntry;\n\t    var nameTableEntry;\n\t    var metaTableEntry;\n\t    var p;\n\n\t    for (var i = 0; i < numTables; i += 1) {\n\t        var tableEntry = tableEntries[i];\n\t        var table = (void 0);\n\t        switch (tableEntry.tag) {\n\t            case 'cmap':\n\t                table = uncompressTable(data, tableEntry);\n\t                font.tables.cmap = cmap.parse(table.data, table.offset);\n\t                font.encoding = new CmapEncoding(font.tables.cmap);\n\t                break;\n\t            case 'cvt ' :\n\t                table = uncompressTable(data, tableEntry);\n\t                p = new parse.Parser(table.data, table.offset);\n\t                font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n\t                break;\n\t            case 'fvar':\n\t                fvarTableEntry = tableEntry;\n\t                break;\n\t            case 'fpgm' :\n\t                table = uncompressTable(data, tableEntry);\n\t                p = new parse.Parser(table.data, table.offset);\n\t                font.tables.fpgm = p.parseByteList(tableEntry.length);\n\t                break;\n\t            case 'head':\n\t                table = uncompressTable(data, tableEntry);\n\t                font.tables.head = head.parse(table.data, table.offset);\n\t                font.unitsPerEm = font.tables.head.unitsPerEm;\n\t                indexToLocFormat = font.tables.head.indexToLocFormat;\n\t                break;\n\t            case 'hhea':\n\t                table = uncompressTable(data, tableEntry);\n\t                font.tables.hhea = hhea.parse(table.data, table.offset);\n\t                font.ascender = font.tables.hhea.ascender;\n\t                font.descender = font.tables.hhea.descender;\n\t                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n\t                break;\n\t            case 'hmtx':\n\t                hmtxTableEntry = tableEntry;\n\t                break;\n\t            case 'ltag':\n\t                table = uncompressTable(data, tableEntry);\n\t                ltagTable = ltag.parse(table.data, table.offset);\n\t                break;\n\t            case 'maxp':\n\t                table = uncompressTable(data, tableEntry);\n\t                font.tables.maxp = maxp.parse(table.data, table.offset);\n\t                font.numGlyphs = font.tables.maxp.numGlyphs;\n\t                break;\n\t            case 'name':\n\t                nameTableEntry = tableEntry;\n\t                break;\n\t            case 'OS/2':\n\t                table = uncompressTable(data, tableEntry);\n\t                font.tables.os2 = os2.parse(table.data, table.offset);\n\t                break;\n\t            case 'post':\n\t                table = uncompressTable(data, tableEntry);\n\t                font.tables.post = post.parse(table.data, table.offset);\n\t                font.glyphNames = new GlyphNames(font.tables.post);\n\t                break;\n\t            case 'prep' :\n\t                table = uncompressTable(data, tableEntry);\n\t                p = new parse.Parser(table.data, table.offset);\n\t                font.tables.prep = p.parseByteList(tableEntry.length);\n\t                break;\n\t            case 'glyf':\n\t                glyfTableEntry = tableEntry;\n\t                break;\n\t            case 'loca':\n\t                locaTableEntry = tableEntry;\n\t                break;\n\t            case 'CFF ':\n\t                cffTableEntry = tableEntry;\n\t                break;\n\t            case 'kern':\n\t                kernTableEntry = tableEntry;\n\t                break;\n\t            case 'GPOS':\n\t                gposTableEntry = tableEntry;\n\t                break;\n\t            case 'GSUB':\n\t                gsubTableEntry = tableEntry;\n\t                break;\n\t            case 'meta':\n\t                metaTableEntry = tableEntry;\n\t                break;\n\t        }\n\t    }\n\n\t    var nameTable = uncompressTable(data, nameTableEntry);\n\t    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);\n\t    font.names = font.tables.name;\n\n\t    if (glyfTableEntry && locaTableEntry) {\n\t        var shortVersion = indexToLocFormat === 0;\n\t        var locaTable = uncompressTable(data, locaTableEntry);\n\t        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);\n\t        var glyfTable = uncompressTable(data, glyfTableEntry);\n\t        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);\n\t    } else if (cffTableEntry) {\n\t        var cffTable = uncompressTable(data, cffTableEntry);\n\t        cff.parse(cffTable.data, cffTable.offset, font);\n\t    } else {\n\t        throw new Error('Font doesn\\'t contain TrueType or CFF outlines.');\n\t    }\n\n\t    var hmtxTable = uncompressTable(data, hmtxTableEntry);\n\t    hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);\n\t    addGlyphNames(font);\n\n\t    if (kernTableEntry) {\n\t        var kernTable = uncompressTable(data, kernTableEntry);\n\t        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n\t    } else {\n\t        font.kerningPairs = {};\n\t    }\n\n\t    if (gposTableEntry) {\n\t        var gposTable = uncompressTable(data, gposTableEntry);\n\t        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);\n\t        font.position.init();\n\t    }\n\n\t    if (gsubTableEntry) {\n\t        var gsubTable = uncompressTable(data, gsubTableEntry);\n\t        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);\n\t    }\n\n\t    if (fvarTableEntry) {\n\t        var fvarTable = uncompressTable(data, fvarTableEntry);\n\t        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);\n\t    }\n\n\t    if (metaTableEntry) {\n\t        var metaTable = uncompressTable(data, metaTableEntry);\n\t        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n\t        font.metas = font.tables.meta;\n\t    }\n\n\t    return font;\n\t}\n\n\t/**\n\t * Asynchronously load the font from a URL or a filesystem. When done, call the callback\n\t * with two arguments `(err, font)`. The `err` will be null on success,\n\t * the `font` is a Font object.\n\t * We use the node.js callback convention so that\n\t * opentype.js can integrate with frameworks like async.js.\n\t * @alias opentype.load\n\t * @param  {string} url - The URL of the font to load.\n\t * @param  {Function} callback - The callback.\n\t */\n\tfunction load(url, callback) {\n\t    var isNode$$1 = typeof window === 'undefined';\n\t    var loadFn = isNode$$1 ? loadFromFile : loadFromUrl;\n\t    loadFn(url, function(err, arrayBuffer) {\n\t        if (err) {\n\t            return callback(err);\n\t        }\n\t        var font;\n\t        try {\n\t            font = parseBuffer(arrayBuffer);\n\t        } catch (e) {\n\t            return callback(e, null);\n\t        }\n\t        return callback(null, font);\n\t    });\n\t}\n\n\t/**\n\t * Synchronously load the font from a URL or file.\n\t * When done, returns the font object or throws an error.\n\t * @alias opentype.loadSync\n\t * @param  {string} url - The URL of the font to load.\n\t * @return {opentype.Font}\n\t */\n\tfunction loadSync(url) {\n\t    var fs = __webpack_require__(/*! fs */ \"?4db5\");\n\t    var buffer = fs.readFileSync(url);\n\t    return parseBuffer(nodeBufferToArrayBuffer(buffer));\n\t}\n\n\texports.Font = Font;\n\texports.Glyph = Glyph;\n\texports.Path = Path;\n\texports.BoundingBox = BoundingBox;\n\texports._parse = parse;\n\texports.parse = parseBuffer;\n\texports.load = load;\n\texports.loadSync = loadSync;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=opentype.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLEtBQTREO0FBQzdELENBQUMsQ0FDaUM7QUFDbEMsQ0FBQyw2QkFBNkI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxXQUFXLE9BQU87QUFDakMsZUFBZSxnQkFBZ0IsT0FBTzs7QUFFdEM7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU8sT0FBTzs7QUFFN0I7QUFDQTtBQUNBOztBQUVBLGVBQWUsUUFBUSxPQUFPO0FBQzlC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QU07QUFDTjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047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QUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQSxpQ0FBaUMsb0JBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNB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TUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSwyQkFBMkI7QUFDakMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSw2QkFBNkI7QUFDbkMsTUFBTSwrQkFBK0I7QUFDckM7O0FBRUE7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSwrQ0FBK0M7QUFDekQsVUFBVSwrQ0FBK0M7QUFDekQsVUFBVSxnREFBZ0Q7QUFDMUQsVUFBVSwrQ0FBK0M7QUFDekQsVUFBVSx5Q0FBeUM7QUFDbkQsVUFBVSxtREFBbUQ7QUFDN0QsVUFBVSxtREFBbUQ7QUFDN0QsVUFBVSxtREFBbUQ7QUFDN0QsVUFBVSxxREFBcUQ7QUFDL0QsVUFBVSxxREFBcUQ7QUFDL0QsVUFBVSxxREFBcUQ7QUFDL0QsVUFBVSxxREFBcUQ7QUFDL0QsVUFBVSx1REFBdUQ7QUFDakUsVUFBVSxpREFBaUQ7QUFDM0QsVUFBVSxzREFBc0Q7QUFDaEUsVUFBVSw4Q0FBOEM7QUFDeEQsVUFBVSw0Q0FBNEM7QUFDdEQsVUFBVSw0Q0FBNEM7QUFDdEQsVUFBVSx3Q0FBd0M7QUFDbEQsVUFBVSw0Q0FBNEM7QUFDdEQsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVSxpREFBaUQ7QUFDM0QsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVSw0Q0FBNEM7QUFDdEQsVUFBVSx5Q0FBeUM7QUFDbkQsVUFBVSx5Q0FBeUM7QUFDbkQsVUFBVSxpREFBaUQ7QUFDM0QsVUFBVSxpREFBaUQ7QUFDM0QsVUFBVSxpREFBaUQ7QUFDM0QsVUFBVSxpREFBaUQ7QUFDM0QsVUFBVSxvREFBb0Q7QUFDOUQsVUFBVSw4Q0FBOEM7QUFDeEQsVUFBVSxtREFBbUQ7QUFDN0QsVUFBVSxrREFBa0Q7QUFDNUQsVUFBVSwrQ0FBK0M7QUFDekQsVUFBVSxnREFBZ0Q7QUFDMUQsVUFBVSw4Q0FBOEM7QUFDeEQsVUFBVSw4Q0FBOEM7QUFDeEQsVUFBVSwrQ0FBK0M7QUFDekQsVUFBVSxrREFBa0Q7QUFDNUQsVUFBVSxrREFBa0Q7QUFDNUQsVUFBVSwwQ0FBMEM7QUFDcEQsVUFBVSw0Q0FBNEM7QUFDdEQsVUFBVSxnREFBZ0Q7QUFDMUQsVUFBVSw4Q0FBOEM7QUFDeEQsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlCQUF5QjtBQUN0RDtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGtEQUFrRDtBQUM1RCxVQUFVLDZDQUE2QztBQUN2RCxVQUFVLG1EQUFtRDtBQUM3RCxVQUFVLG9EQUFvRDtBQUM5RCxVQUFVLDhDQUE4QztBQUN4RCxVQUFVLDhDQUE4QztBQUN4RCxVQUFVLDhDQUE4QztBQUN4RCxVQUFVLDZDQUE2QztBQUN2RCxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxjQUFjOztBQUVkOztBQUVBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBOEM7QUFDNUQsY0FBYyw4RUFBOEU7QUFDNUYsY0FBYztBQUNkO0FBQ0EsT0FBTztBQUNQO0FBQ0EsY0FBYyw4Q0FBOEM7QUFDNUQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOENBQThDO0FBQ3hELFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOENBQThDO0FBQ3hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkRBQTJEO0FBQzlFO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsTUFBTTtBQUNOOztBQUVBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CLG9DQUFvQztBQUNwQyxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2YsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjs7QUFFQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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MEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUIscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBLHlCQUF5QjtBQUN6Qiw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCLHFCQUFxQixPQUFPO0FBQzVC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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7O0FB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QUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxpQkFBSTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsYUFBYTs7QUFFN0QsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQXV0b2Rlc2suRXh0ZW5zaW9ucy8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9kaXN0L29wZW50eXBlLmpzP2Y0NjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwczovL29wZW50eXBlLmpzLm9yZyB2MC45LjAgfCAoYykgRnJlZGVyaWsgRGUgQmxlc2VyIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBNSVQgTGljZW5zZSB8IFVzZXMgdGlueS1pbmZsYXRlIGJ5IERldm9uIEdvdmV0dCBhbmQgc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdCBwb2x5ZmlsbCBieSBNYXRoaWFzIEJ5bmVuc1xuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5vcGVudHlwZSA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdC8qISBodHRwczovL210aHMuYmUvY29kZXBvaW50YXQgdjAuMi4wIGJ5IEBtYXRoaWFzICovXG5cdGlmICghU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdCkge1xuXHRcdChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gSUUgOCBvbmx5IHN1cHBvcnRzIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG9uIERPTSBlbGVtZW50c1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdFx0XHR2YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHRcdFx0XHRcdHZhciByZXN1bHQgPSAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCBvYmplY3QsIG9iamVjdCkgJiYgJGRlZmluZVByb3BlcnR5O1xuXHRcdFx0XHR9IGNhdGNoKGVycm9yKSB7fVxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fSgpKTtcblx0XHRcdHZhciBjb2RlUG9pbnRBdCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0XHRcdGlmICh0aGlzID09IG51bGwpIHtcblx0XHRcdFx0XHR0aHJvdyBUeXBlRXJyb3IoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuXHRcdFx0XHR2YXIgc2l6ZSA9IHN0cmluZy5sZW5ndGg7XG5cdFx0XHRcdC8vIGBUb0ludGVnZXJgXG5cdFx0XHRcdHZhciBpbmRleCA9IHBvc2l0aW9uID8gTnVtYmVyKHBvc2l0aW9uKSA6IDA7XG5cdFx0XHRcdGlmIChpbmRleCAhPSBpbmRleCkgeyAvLyBiZXR0ZXIgYGlzTmFOYFxuXHRcdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBBY2NvdW50IGZvciBvdXQtb2YtYm91bmRzIGluZGljZXM6XG5cdFx0XHRcdGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2l6ZSkge1xuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gR2V0IHRoZSBmaXJzdCBjb2RlIHVuaXRcblx0XHRcdFx0dmFyIGZpcnN0ID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuXHRcdFx0XHR2YXIgc2Vjb25kO1xuXHRcdFx0XHRpZiAoIC8vIGNoZWNrIGlmIGl04oCZcyB0aGUgc3RhcnQgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYgJiYgLy8gaGlnaCBzdXJyb2dhdGVcblx0XHRcdFx0XHRzaXplID4gaW5kZXggKyAxIC8vIHRoZXJlIGlzIGEgbmV4dCBjb2RlIHVuaXRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0c2Vjb25kID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblx0XHRcdFx0XHRpZiAoc2Vjb25kID49IDB4REMwMCAmJiBzZWNvbmQgPD0gMHhERkZGKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuXHRcdFx0XHRcdFx0cmV0dXJuIChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmaXJzdDtcblx0XHRcdH07XG5cdFx0XHRpZiAoZGVmaW5lUHJvcGVydHkpIHtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgJ2NvZGVQb2ludEF0Jywge1xuXHRcdFx0XHRcdCd2YWx1ZSc6IGNvZGVQb2ludEF0LFxuXHRcdFx0XHRcdCdjb25maWd1cmFibGUnOiB0cnVlLFxuXHRcdFx0XHRcdCd3cml0YWJsZSc6IHRydWVcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0ID0gY29kZVBvaW50QXQ7XG5cdFx0XHR9XG5cdFx0fSgpKTtcblx0fVxuXG5cdHZhciBUSU5GX09LID0gMDtcblx0dmFyIFRJTkZfREFUQV9FUlJPUiA9IC0zO1xuXG5cdGZ1bmN0aW9uIFRyZWUoKSB7XG5cdCAgdGhpcy50YWJsZSA9IG5ldyBVaW50MTZBcnJheSgxNik7ICAgLyogdGFibGUgb2YgY29kZSBsZW5ndGggY291bnRzICovXG5cdCAgdGhpcy50cmFucyA9IG5ldyBVaW50MTZBcnJheSgyODgpOyAgLyogY29kZSAtPiBzeW1ib2wgdHJhbnNsYXRpb24gdGFibGUgKi9cblx0fVxuXG5cdGZ1bmN0aW9uIERhdGEoc291cmNlLCBkZXN0KSB7XG5cdCAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cdCAgdGhpcy5zb3VyY2VJbmRleCA9IDA7XG5cdCAgdGhpcy50YWcgPSAwO1xuXHQgIHRoaXMuYml0Y291bnQgPSAwO1xuXHQgIFxuXHQgIHRoaXMuZGVzdCA9IGRlc3Q7XG5cdCAgdGhpcy5kZXN0TGVuID0gMDtcblx0ICBcblx0ICB0aGlzLmx0cmVlID0gbmV3IFRyZWUoKTsgIC8qIGR5bmFtaWMgbGVuZ3RoL3N5bWJvbCB0cmVlICovXG5cdCAgdGhpcy5kdHJlZSA9IG5ldyBUcmVlKCk7ICAvKiBkeW5hbWljIGRpc3RhbmNlIHRyZWUgKi9cblx0fVxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdCAqIC0tIHVuaW5pdGlhbGl6ZWQgZ2xvYmFsIGRhdGEgKHN0YXRpYyBzdHJ1Y3R1cmVzKSAtLSAqXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdHZhciBzbHRyZWUgPSBuZXcgVHJlZSgpO1xuXHR2YXIgc2R0cmVlID0gbmV3IFRyZWUoKTtcblxuXHQvKiBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyBmb3IgbGVuZ3RoIGNvZGVzICovXG5cdHZhciBsZW5ndGhfYml0cyA9IG5ldyBVaW50OEFycmF5KDMwKTtcblx0dmFyIGxlbmd0aF9iYXNlID0gbmV3IFVpbnQxNkFycmF5KDMwKTtcblxuXHQvKiBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyBmb3IgZGlzdGFuY2UgY29kZXMgKi9cblx0dmFyIGRpc3RfYml0cyA9IG5ldyBVaW50OEFycmF5KDMwKTtcblx0dmFyIGRpc3RfYmFzZSA9IG5ldyBVaW50MTZBcnJheSgzMCk7XG5cblx0Lyogc3BlY2lhbCBvcmRlcmluZyBvZiBjb2RlIGxlbmd0aCBjb2RlcyAqL1xuXHR2YXIgY2xjaWR4ID0gbmV3IFVpbnQ4QXJyYXkoW1xuXHQgIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsXG5cdCAgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsXG5cdCAgMTQsIDEsIDE1XG5cdF0pO1xuXG5cdC8qIHVzZWQgYnkgdGluZl9kZWNvZGVfdHJlZXMsIGF2b2lkcyBhbGxvY2F0aW9ucyBldmVyeSBjYWxsICovXG5cdHZhciBjb2RlX3RyZWUgPSBuZXcgVHJlZSgpO1xuXHR2YXIgbGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDI4OCArIDMyKTtcblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG5cdCAqIC0tIHV0aWxpdHkgZnVuY3Rpb25zIC0tICpcblx0ICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiBidWlsZCBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyAqL1xuXHRmdW5jdGlvbiB0aW5mX2J1aWxkX2JpdHNfYmFzZShiaXRzLCBiYXNlLCBkZWx0YSwgZmlyc3QpIHtcblx0ICB2YXIgaSwgc3VtO1xuXG5cdCAgLyogYnVpbGQgYml0cyB0YWJsZSAqL1xuXHQgIGZvciAoaSA9IDA7IGkgPCBkZWx0YTsgKytpKSB7IGJpdHNbaV0gPSAwOyB9XG5cdCAgZm9yIChpID0gMDsgaSA8IDMwIC0gZGVsdGE7ICsraSkgeyBiaXRzW2kgKyBkZWx0YV0gPSBpIC8gZGVsdGEgfCAwOyB9XG5cblx0ICAvKiBidWlsZCBiYXNlIHRhYmxlICovXG5cdCAgZm9yIChzdW0gPSBmaXJzdCwgaSA9IDA7IGkgPCAzMDsgKytpKSB7XG5cdCAgICBiYXNlW2ldID0gc3VtO1xuXHQgICAgc3VtICs9IDEgPDwgYml0c1tpXTtcblx0ICB9XG5cdH1cblxuXHQvKiBidWlsZCB0aGUgZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xuXHRmdW5jdGlvbiB0aW5mX2J1aWxkX2ZpeGVkX3RyZWVzKGx0LCBkdCkge1xuXHQgIHZhciBpO1xuXG5cdCAgLyogYnVpbGQgZml4ZWQgbGVuZ3RoIHRyZWUgKi9cblx0ICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7IGx0LnRhYmxlW2ldID0gMDsgfVxuXG5cdCAgbHQudGFibGVbN10gPSAyNDtcblx0ICBsdC50YWJsZVs4XSA9IDE1Mjtcblx0ICBsdC50YWJsZVs5XSA9IDExMjtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCAyNDsgKytpKSB7IGx0LnRyYW5zW2ldID0gMjU2ICsgaTsgfVxuXHQgIGZvciAoaSA9IDA7IGkgPCAxNDQ7ICsraSkgeyBsdC50cmFuc1syNCArIGldID0gaTsgfVxuXHQgIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHsgbHQudHJhbnNbMjQgKyAxNDQgKyBpXSA9IDI4MCArIGk7IH1cblx0ICBmb3IgKGkgPSAwOyBpIDwgMTEyOyArK2kpIHsgbHQudHJhbnNbMjQgKyAxNDQgKyA4ICsgaV0gPSAxNDQgKyBpOyB9XG5cblx0ICAvKiBidWlsZCBmaXhlZCBkaXN0YW5jZSB0cmVlICovXG5cdCAgZm9yIChpID0gMDsgaSA8IDU7ICsraSkgeyBkdC50YWJsZVtpXSA9IDA7IH1cblxuXHQgIGR0LnRhYmxlWzVdID0gMzI7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgMzI7ICsraSkgeyBkdC50cmFuc1tpXSA9IGk7IH1cblx0fVxuXG5cdC8qIGdpdmVuIGFuIGFycmF5IG9mIGNvZGUgbGVuZ3RocywgYnVpbGQgYSB0cmVlICovXG5cdHZhciBvZmZzID0gbmV3IFVpbnQxNkFycmF5KDE2KTtcblxuXHRmdW5jdGlvbiB0aW5mX2J1aWxkX3RyZWUodCwgbGVuZ3Rocywgb2ZmLCBudW0pIHtcblx0ICB2YXIgaSwgc3VtO1xuXG5cdCAgLyogY2xlYXIgY29kZSBsZW5ndGggY291bnQgdGFibGUgKi9cblx0ICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkgeyB0LnRhYmxlW2ldID0gMDsgfVxuXG5cdCAgLyogc2NhbiBzeW1ib2wgbGVuZ3RocywgYW5kIHN1bSBjb2RlIGxlbmd0aCBjb3VudHMgKi9cblx0ICBmb3IgKGkgPSAwOyBpIDwgbnVtOyArK2kpIHsgdC50YWJsZVtsZW5ndGhzW29mZiArIGldXSsrOyB9XG5cblx0ICB0LnRhYmxlWzBdID0gMDtcblxuXHQgIC8qIGNvbXB1dGUgb2Zmc2V0IHRhYmxlIGZvciBkaXN0cmlidXRpb24gc29ydCAqL1xuXHQgIGZvciAoc3VtID0gMCwgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG5cdCAgICBvZmZzW2ldID0gc3VtO1xuXHQgICAgc3VtICs9IHQudGFibGVbaV07XG5cdCAgfVxuXG5cdCAgLyogY3JlYXRlIGNvZGUtPnN5bWJvbCB0cmFuc2xhdGlvbiB0YWJsZSAoc3ltYm9scyBzb3J0ZWQgYnkgY29kZSkgKi9cblx0ICBmb3IgKGkgPSAwOyBpIDwgbnVtOyArK2kpIHtcblx0ICAgIGlmIChsZW5ndGhzW29mZiArIGldKSB7IHQudHJhbnNbb2Zmc1tsZW5ndGhzW29mZiArIGldXSsrXSA9IGk7IH1cblx0ICB9XG5cdH1cblxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcblx0ICogLS0gZGVjb2RlIGZ1bmN0aW9ucyAtLSAqXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvKiBnZXQgb25lIGJpdCBmcm9tIHNvdXJjZSBzdHJlYW0gKi9cblx0ZnVuY3Rpb24gdGluZl9nZXRiaXQoZCkge1xuXHQgIC8qIGNoZWNrIGlmIHRhZyBpcyBlbXB0eSAqL1xuXHQgIGlmICghZC5iaXRjb3VudC0tKSB7XG5cdCAgICAvKiBsb2FkIG5leHQgdGFnICovXG5cdCAgICBkLnRhZyA9IGQuc291cmNlW2Quc291cmNlSW5kZXgrK107XG5cdCAgICBkLmJpdGNvdW50ID0gNztcblx0ICB9XG5cblx0ICAvKiBzaGlmdCBiaXQgb3V0IG9mIHRhZyAqL1xuXHQgIHZhciBiaXQgPSBkLnRhZyAmIDE7XG5cdCAgZC50YWcgPj4+PSAxO1xuXG5cdCAgcmV0dXJuIGJpdDtcblx0fVxuXG5cdC8qIHJlYWQgYSBudW0gYml0IHZhbHVlIGZyb20gYSBzdHJlYW0gYW5kIGFkZCBiYXNlICovXG5cdGZ1bmN0aW9uIHRpbmZfcmVhZF9iaXRzKGQsIG51bSwgYmFzZSkge1xuXHQgIGlmICghbnVtKVxuXHQgICAgeyByZXR1cm4gYmFzZTsgfVxuXG5cdCAgd2hpbGUgKGQuYml0Y291bnQgPCAyNCkge1xuXHQgICAgZC50YWcgfD0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXSA8PCBkLmJpdGNvdW50O1xuXHQgICAgZC5iaXRjb3VudCArPSA4O1xuXHQgIH1cblxuXHQgIHZhciB2YWwgPSBkLnRhZyAmICgweGZmZmYgPj4+ICgxNiAtIG51bSkpO1xuXHQgIGQudGFnID4+Pj0gbnVtO1xuXHQgIGQuYml0Y291bnQgLT0gbnVtO1xuXHQgIHJldHVybiB2YWwgKyBiYXNlO1xuXHR9XG5cblx0LyogZ2l2ZW4gYSBkYXRhIHN0cmVhbSBhbmQgYSB0cmVlLCBkZWNvZGUgYSBzeW1ib2wgKi9cblx0ZnVuY3Rpb24gdGluZl9kZWNvZGVfc3ltYm9sKGQsIHQpIHtcblx0ICB3aGlsZSAoZC5iaXRjb3VudCA8IDI0KSB7XG5cdCAgICBkLnRhZyB8PSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4KytdIDw8IGQuYml0Y291bnQ7XG5cdCAgICBkLmJpdGNvdW50ICs9IDg7XG5cdCAgfVxuXHQgIFxuXHQgIHZhciBzdW0gPSAwLCBjdXIgPSAwLCBsZW4gPSAwO1xuXHQgIHZhciB0YWcgPSBkLnRhZztcblxuXHQgIC8qIGdldCBtb3JlIGJpdHMgd2hpbGUgY29kZSB2YWx1ZSBpcyBhYm92ZSBzdW0gKi9cblx0ICBkbyB7XG5cdCAgICBjdXIgPSAyICogY3VyICsgKHRhZyAmIDEpO1xuXHQgICAgdGFnID4+Pj0gMTtcblx0ICAgICsrbGVuO1xuXG5cdCAgICBzdW0gKz0gdC50YWJsZVtsZW5dO1xuXHQgICAgY3VyIC09IHQudGFibGVbbGVuXTtcblx0ICB9IHdoaWxlIChjdXIgPj0gMCk7XG5cdCAgXG5cdCAgZC50YWcgPSB0YWc7XG5cdCAgZC5iaXRjb3VudCAtPSBsZW47XG5cblx0ICByZXR1cm4gdC50cmFuc1tzdW0gKyBjdXJdO1xuXHR9XG5cblx0LyogZ2l2ZW4gYSBkYXRhIHN0cmVhbSwgZGVjb2RlIGR5bmFtaWMgdHJlZXMgZnJvbSBpdCAqL1xuXHRmdW5jdGlvbiB0aW5mX2RlY29kZV90cmVlcyhkLCBsdCwgZHQpIHtcblx0ICB2YXIgaGxpdCwgaGRpc3QsIGhjbGVuO1xuXHQgIHZhciBpLCBudW0sIGxlbmd0aDtcblxuXHQgIC8qIGdldCA1IGJpdHMgSExJVCAoMjU3LTI4NikgKi9cblx0ICBobGl0ID0gdGluZl9yZWFkX2JpdHMoZCwgNSwgMjU3KTtcblxuXHQgIC8qIGdldCA1IGJpdHMgSERJU1QgKDEtMzIpICovXG5cdCAgaGRpc3QgPSB0aW5mX3JlYWRfYml0cyhkLCA1LCAxKTtcblxuXHQgIC8qIGdldCA0IGJpdHMgSENMRU4gKDQtMTkpICovXG5cdCAgaGNsZW4gPSB0aW5mX3JlYWRfYml0cyhkLCA0LCA0KTtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCAxOTsgKytpKSB7IGxlbmd0aHNbaV0gPSAwOyB9XG5cblx0ICAvKiByZWFkIGNvZGUgbGVuZ3RocyBmb3IgY29kZSBsZW5ndGggYWxwaGFiZXQgKi9cblx0ICBmb3IgKGkgPSAwOyBpIDwgaGNsZW47ICsraSkge1xuXHQgICAgLyogZ2V0IDMgYml0cyBjb2RlIGxlbmd0aCAoMC03KSAqL1xuXHQgICAgdmFyIGNsZW4gPSB0aW5mX3JlYWRfYml0cyhkLCAzLCAwKTtcblx0ICAgIGxlbmd0aHNbY2xjaWR4W2ldXSA9IGNsZW47XG5cdCAgfVxuXG5cdCAgLyogYnVpbGQgY29kZSBsZW5ndGggdHJlZSAqL1xuXHQgIHRpbmZfYnVpbGRfdHJlZShjb2RlX3RyZWUsIGxlbmd0aHMsIDAsIDE5KTtcblxuXHQgIC8qIGRlY29kZSBjb2RlIGxlbmd0aHMgZm9yIHRoZSBkeW5hbWljIHRyZWVzICovXG5cdCAgZm9yIChudW0gPSAwOyBudW0gPCBobGl0ICsgaGRpc3Q7KSB7XG5cdCAgICB2YXIgc3ltID0gdGluZl9kZWNvZGVfc3ltYm9sKGQsIGNvZGVfdHJlZSk7XG5cblx0ICAgIHN3aXRjaCAoc3ltKSB7XG5cdCAgICAgIGNhc2UgMTY6XG5cdCAgICAgICAgLyogY29weSBwcmV2aW91cyBjb2RlIGxlbmd0aCAzLTYgdGltZXMgKHJlYWQgMiBiaXRzKSAqL1xuXHQgICAgICAgIHZhciBwcmV2ID0gbGVuZ3Roc1tudW0gLSAxXTtcblx0ICAgICAgICBmb3IgKGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIDIsIDMpOyBsZW5ndGg7IC0tbGVuZ3RoKSB7XG5cdCAgICAgICAgICBsZW5ndGhzW251bSsrXSA9IHByZXY7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlIDE3OlxuXHQgICAgICAgIC8qIHJlcGVhdCBjb2RlIGxlbmd0aCAwIGZvciAzLTEwIHRpbWVzIChyZWFkIDMgYml0cykgKi9cblx0ICAgICAgICBmb3IgKGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIDMsIDMpOyBsZW5ndGg7IC0tbGVuZ3RoKSB7XG5cdCAgICAgICAgICBsZW5ndGhzW251bSsrXSA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlIDE4OlxuXHQgICAgICAgIC8qIHJlcGVhdCBjb2RlIGxlbmd0aCAwIGZvciAxMS0xMzggdGltZXMgKHJlYWQgNyBiaXRzKSAqL1xuXHQgICAgICAgIGZvciAobGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgNywgMTEpOyBsZW5ndGg7IC0tbGVuZ3RoKSB7XG5cdCAgICAgICAgICBsZW5ndGhzW251bSsrXSA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIC8qIHZhbHVlcyAwLTE1IHJlcHJlc2VudCB0aGUgYWN0dWFsIGNvZGUgbGVuZ3RocyAqL1xuXHQgICAgICAgIGxlbmd0aHNbbnVtKytdID0gc3ltO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qIGJ1aWxkIGR5bmFtaWMgdHJlZXMgKi9cblx0ICB0aW5mX2J1aWxkX3RyZWUobHQsIGxlbmd0aHMsIDAsIGhsaXQpO1xuXHQgIHRpbmZfYnVpbGRfdHJlZShkdCwgbGVuZ3RocywgaGxpdCwgaGRpc3QpO1xuXHR9XG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQgKiAtLSBibG9jayBpbmZsYXRlIGZ1bmN0aW9ucyAtLSAqXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyogZ2l2ZW4gYSBzdHJlYW0gYW5kIHR3byB0cmVlcywgaW5mbGF0ZSBhIGJsb2NrIG9mIGRhdGEgKi9cblx0ZnVuY3Rpb24gdGluZl9pbmZsYXRlX2Jsb2NrX2RhdGEoZCwgbHQsIGR0KSB7XG5cdCAgd2hpbGUgKDEpIHtcblx0ICAgIHZhciBzeW0gPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgbHQpO1xuXG5cdCAgICAvKiBjaGVjayBmb3IgZW5kIG9mIGJsb2NrICovXG5cdCAgICBpZiAoc3ltID09PSAyNTYpIHtcblx0ICAgICAgcmV0dXJuIFRJTkZfT0s7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzeW0gPCAyNTYpIHtcblx0ICAgICAgZC5kZXN0W2QuZGVzdExlbisrXSA9IHN5bTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciBsZW5ndGgsIGRpc3QsIG9mZnM7XG5cdCAgICAgIHZhciBpO1xuXG5cdCAgICAgIHN5bSAtPSAyNTc7XG5cblx0ICAgICAgLyogcG9zc2libHkgZ2V0IG1vcmUgYml0cyBmcm9tIGxlbmd0aCBjb2RlICovXG5cdCAgICAgIGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIGxlbmd0aF9iaXRzW3N5bV0sIGxlbmd0aF9iYXNlW3N5bV0pO1xuXG5cdCAgICAgIGRpc3QgPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgZHQpO1xuXG5cdCAgICAgIC8qIHBvc3NpYmx5IGdldCBtb3JlIGJpdHMgZnJvbSBkaXN0YW5jZSBjb2RlICovXG5cdCAgICAgIG9mZnMgPSBkLmRlc3RMZW4gLSB0aW5mX3JlYWRfYml0cyhkLCBkaXN0X2JpdHNbZGlzdF0sIGRpc3RfYmFzZVtkaXN0XSk7XG5cblx0ICAgICAgLyogY29weSBtYXRjaCAqL1xuXHQgICAgICBmb3IgKGkgPSBvZmZzOyBpIDwgb2ZmcyArIGxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgZC5kZXN0W2QuZGVzdExlbisrXSA9IGQuZGVzdFtpXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8qIGluZmxhdGUgYW4gdW5jb21wcmVzc2VkIGJsb2NrIG9mIGRhdGEgKi9cblx0ZnVuY3Rpb24gdGluZl9pbmZsYXRlX3VuY29tcHJlc3NlZF9ibG9jayhkKSB7XG5cdCAgdmFyIGxlbmd0aCwgaW52bGVuZ3RoO1xuXHQgIHZhciBpO1xuXHQgIFxuXHQgIC8qIHVucmVhZCBmcm9tIGJpdGJ1ZmZlciAqL1xuXHQgIHdoaWxlIChkLmJpdGNvdW50ID4gOCkge1xuXHQgICAgZC5zb3VyY2VJbmRleC0tO1xuXHQgICAgZC5iaXRjb3VudCAtPSA4O1xuXHQgIH1cblxuXHQgIC8qIGdldCBsZW5ndGggKi9cblx0ICBsZW5ndGggPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4ICsgMV07XG5cdCAgbGVuZ3RoID0gMjU2ICogbGVuZ3RoICsgZC5zb3VyY2VbZC5zb3VyY2VJbmRleF07XG5cblx0ICAvKiBnZXQgb25lJ3MgY29tcGxlbWVudCBvZiBsZW5ndGggKi9cblx0ICBpbnZsZW5ndGggPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4ICsgM107XG5cdCAgaW52bGVuZ3RoID0gMjU2ICogaW52bGVuZ3RoICsgZC5zb3VyY2VbZC5zb3VyY2VJbmRleCArIDJdO1xuXG5cdCAgLyogY2hlY2sgbGVuZ3RoICovXG5cdCAgaWYgKGxlbmd0aCAhPT0gKH5pbnZsZW5ndGggJiAweDAwMDBmZmZmKSlcblx0ICAgIHsgcmV0dXJuIFRJTkZfREFUQV9FUlJPUjsgfVxuXG5cdCAgZC5zb3VyY2VJbmRleCArPSA0O1xuXG5cdCAgLyogY29weSBibG9jayAqL1xuXHQgIGZvciAoaSA9IGxlbmd0aDsgaTsgLS1pKVxuXHQgICAgeyBkLmRlc3RbZC5kZXN0TGVuKytdID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXTsgfVxuXG5cdCAgLyogbWFrZSBzdXJlIHdlIHN0YXJ0IG5leHQgYmxvY2sgb24gYSBieXRlIGJvdW5kYXJ5ICovXG5cdCAgZC5iaXRjb3VudCA9IDA7XG5cblx0ICByZXR1cm4gVElORl9PSztcblx0fVxuXG5cdC8qIGluZmxhdGUgc3RyZWFtIGZyb20gc291cmNlIHRvIGRlc3QgKi9cblx0ZnVuY3Rpb24gdGluZl91bmNvbXByZXNzKHNvdXJjZSwgZGVzdCkge1xuXHQgIHZhciBkID0gbmV3IERhdGEoc291cmNlLCBkZXN0KTtcblx0ICB2YXIgYmZpbmFsLCBidHlwZSwgcmVzO1xuXG5cdCAgZG8ge1xuXHQgICAgLyogcmVhZCBmaW5hbCBibG9jayBmbGFnICovXG5cdCAgICBiZmluYWwgPSB0aW5mX2dldGJpdChkKTtcblxuXHQgICAgLyogcmVhZCBibG9jayB0eXBlICgyIGJpdHMpICovXG5cdCAgICBidHlwZSA9IHRpbmZfcmVhZF9iaXRzKGQsIDIsIDApO1xuXG5cdCAgICAvKiBkZWNvbXByZXNzIGJsb2NrICovXG5cdCAgICBzd2l0Y2ggKGJ0eXBlKSB7XG5cdCAgICAgIGNhc2UgMDpcblx0ICAgICAgICAvKiBkZWNvbXByZXNzIHVuY29tcHJlc3NlZCBibG9jayAqL1xuXHQgICAgICAgIHJlcyA9IHRpbmZfaW5mbGF0ZV91bmNvbXByZXNzZWRfYmxvY2soZCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgMTpcblx0ICAgICAgICAvKiBkZWNvbXByZXNzIGJsb2NrIHdpdGggZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xuXHQgICAgICAgIHJlcyA9IHRpbmZfaW5mbGF0ZV9ibG9ja19kYXRhKGQsIHNsdHJlZSwgc2R0cmVlKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgY2FzZSAyOlxuXHQgICAgICAgIC8qIGRlY29tcHJlc3MgYmxvY2sgd2l0aCBkeW5hbWljIGh1ZmZtYW4gdHJlZXMgKi9cblx0ICAgICAgICB0aW5mX2RlY29kZV90cmVlcyhkLCBkLmx0cmVlLCBkLmR0cmVlKTtcblx0ICAgICAgICByZXMgPSB0aW5mX2luZmxhdGVfYmxvY2tfZGF0YShkLCBkLmx0cmVlLCBkLmR0cmVlKTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICByZXMgPSBUSU5GX0RBVEFfRVJST1I7XG5cdCAgICB9XG5cblx0ICAgIGlmIChyZXMgIT09IFRJTkZfT0spXG5cdCAgICAgIHsgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGVycm9yJyk7IH1cblxuXHQgIH0gd2hpbGUgKCFiZmluYWwpO1xuXG5cdCAgaWYgKGQuZGVzdExlbiA8IGQuZGVzdC5sZW5ndGgpIHtcblx0ICAgIGlmICh0eXBlb2YgZC5kZXN0LnNsaWNlID09PSAnZnVuY3Rpb24nKVxuXHQgICAgICB7IHJldHVybiBkLmRlc3Quc2xpY2UoMCwgZC5kZXN0TGVuKTsgfVxuXHQgICAgZWxzZVxuXHQgICAgICB7IHJldHVybiBkLmRlc3Quc3ViYXJyYXkoMCwgZC5kZXN0TGVuKTsgfVxuXHQgIH1cblx0ICBcblx0ICByZXR1cm4gZC5kZXN0O1xuXHR9XG5cblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuXHQgKiAtLSBpbml0aWFsaXphdGlvbiAtLSAqXG5cdCAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0LyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xuXHR0aW5mX2J1aWxkX2ZpeGVkX3RyZWVzKHNsdHJlZSwgc2R0cmVlKTtcblxuXHQvKiBidWlsZCBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyAqL1xuXHR0aW5mX2J1aWxkX2JpdHNfYmFzZShsZW5ndGhfYml0cywgbGVuZ3RoX2Jhc2UsIDQsIDMpO1xuXHR0aW5mX2J1aWxkX2JpdHNfYmFzZShkaXN0X2JpdHMsIGRpc3RfYmFzZSwgMiwgMSk7XG5cblx0LyogZml4IGEgc3BlY2lhbCBjYXNlICovXG5cdGxlbmd0aF9iaXRzWzI4XSA9IDA7XG5cdGxlbmd0aF9iYXNlWzI4XSA9IDI1ODtcblxuXHR2YXIgdGlueUluZmxhdGUgPSB0aW5mX3VuY29tcHJlc3M7XG5cblx0Ly8gVGhlIEJvdW5kaW5nIEJveCBvYmplY3RcblxuXHRmdW5jdGlvbiBkZXJpdmUodjAsIHYxLCB2MiwgdjMsIHQpIHtcblx0ICAgIHJldHVybiBNYXRoLnBvdygxIC0gdCwgMykgKiB2MCArXG5cdCAgICAgICAgMyAqIE1hdGgucG93KDEgLSB0LCAyKSAqIHQgKiB2MSArXG5cdCAgICAgICAgMyAqICgxIC0gdCkgKiBNYXRoLnBvdyh0LCAyKSAqIHYyICtcblx0ICAgICAgICBNYXRoLnBvdyh0LCAzKSAqIHYzO1xuXHR9XG5cdC8qKlxuXHQgKiBBIGJvdW5kaW5nIGJveCBpcyBhbiBlbmNsb3NpbmcgYm94IHRoYXQgZGVzY3JpYmVzIHRoZSBzbWFsbGVzdCBtZWFzdXJlIHdpdGhpbiB3aGljaCBhbGwgdGhlIHBvaW50cyBsaWUuXG5cdCAqIEl0IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBib3VuZGluZyBib3ggb2YgYSBnbHlwaCBvciB0ZXh0IHBhdGguXG5cdCAqXG5cdCAqIE9uIGluaXRpYWxpemF0aW9uLCB4MS95MS94Mi95MiB3aWxsIGJlIE5hTi4gQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIGJveCBpcyBlbXB0eSB1c2luZyBgaXNFbXB0eSgpYC5cblx0ICpcblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuQm91bmRpbmdCb3hcblx0ICogQGNsYXNzXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gQm91bmRpbmdCb3goKSB7XG5cdCAgICB0aGlzLngxID0gTnVtYmVyLk5hTjtcblx0ICAgIHRoaXMueTEgPSBOdW1iZXIuTmFOO1xuXHQgICAgdGhpcy54MiA9IE51bWJlci5OYU47XG5cdCAgICB0aGlzLnkyID0gTnVtYmVyLk5hTjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJvdW5kaW5nIGJveCBpcyBlbXB0eSwgdGhhdCBpcywgbm8gcG9pbnRzIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgYm94IHlldC5cblx0ICovXG5cdEJvdW5kaW5nQm94LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gaXNOYU4odGhpcy54MSkgfHwgaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy54MikgfHwgaXNOYU4odGhpcy55Mik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCB0aGUgcG9pbnQgdG8gdGhlIGJvdW5kaW5nIGJveC5cblx0ICogVGhlIHgxL3kxL3gyL3kyIGNvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGluZyBib3ggd2lsbCBub3cgZW5jb21wYXNzIHRoZSBnaXZlbiBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cblx0ICovXG5cdEJvdW5kaW5nQm94LnByb3RvdHlwZS5hZGRQb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0ICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICBpZiAoaXNOYU4odGhpcy54MSkgfHwgaXNOYU4odGhpcy54MikpIHtcblx0ICAgICAgICAgICAgdGhpcy54MSA9IHg7XG5cdCAgICAgICAgICAgIHRoaXMueDIgPSB4O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoeCA8IHRoaXMueDEpIHtcblx0ICAgICAgICAgICAgdGhpcy54MSA9IHg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh4ID4gdGhpcy54Mikge1xuXHQgICAgICAgICAgICB0aGlzLngyID0geDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIHkgPT09ICdudW1iZXInKSB7XG5cdCAgICAgICAgaWYgKGlzTmFOKHRoaXMueTEpIHx8IGlzTmFOKHRoaXMueTIpKSB7XG5cdCAgICAgICAgICAgIHRoaXMueTEgPSB5O1xuXHQgICAgICAgICAgICB0aGlzLnkyID0geTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHkgPCB0aGlzLnkxKSB7XG5cdCAgICAgICAgICAgIHRoaXMueTEgPSB5O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoeSA+IHRoaXMueTIpIHtcblx0ICAgICAgICAgICAgdGhpcy55MiA9IHk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBYIGNvb3JkaW5hdGUgdG8gdGhlIGJvdW5kaW5nIGJveC5cblx0ICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgWCBjb29yZGluYXRlLlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW50ZXJuYWxseSBpbnNpZGUgb2YgYWRkQmV6aWVyLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuXHQgKi9cblx0Qm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFggPSBmdW5jdGlvbih4KSB7XG5cdCAgICB0aGlzLmFkZFBvaW50KHgsIG51bGwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBZIGNvb3JkaW5hdGUgdG8gdGhlIGJvdW5kaW5nIGJveC5cblx0ICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgWSBjb29yZGluYXRlLlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW50ZXJuYWxseSBpbnNpZGUgb2YgYWRkQmV6aWVyLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuXHQgKi9cblx0Qm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFkgPSBmdW5jdGlvbih5KSB7XG5cdCAgICB0aGlzLmFkZFBvaW50KG51bGwsIHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBCw6l6aWVyIGN1cnZlIHRvIHRoZSBib3VuZGluZyBib3guXG5cdCAqIFRoaXMgZXh0ZW5kcyB0aGUgYm91bmRpbmcgYm94IHRvIGluY2x1ZGUgdGhlIGVudGlyZSBCw6l6aWVyLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geDAgLSBUaGUgc3RhcnRpbmcgWCBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geTAgLSBUaGUgc3RhcnRpbmcgWSBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geDEgLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geTEgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geDIgLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkyIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGVuZGluZyBYIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIGVuZGluZyBZIGNvb3JkaW5hdGUuXG5cdCAqL1xuXHRCb3VuZGluZ0JveC5wcm90b3R5cGUuYWRkQmV6aWVyID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIC8vIFRoaXMgY29kZSBpcyBiYXNlZCBvbiBodHRwOi8vbmlzaGlvaGlyb2thenUuYmxvZ3Nwb3QuY29tLzIwMDkvMDYvaG93LXRvLWNhbGN1bGF0ZS1iZXppZXItY3VydmVzLWJvdW5kaW5nLmh0bWxcblx0ICAgIC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vaWNvbnM4L3N2Zy1wYXRoLWJvdW5kaW5nLWJveFxuXG5cdCAgICB2YXIgcDAgPSBbeDAsIHkwXTtcblx0ICAgIHZhciBwMSA9IFt4MSwgeTFdO1xuXHQgICAgdmFyIHAyID0gW3gyLCB5Ml07XG5cdCAgICB2YXIgcDMgPSBbeCwgeV07XG5cblx0ICAgIHRoaXMuYWRkUG9pbnQoeDAsIHkwKTtcblx0ICAgIHRoaXMuYWRkUG9pbnQoeCwgeSk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDE7IGkrKykge1xuXHQgICAgICAgIHZhciBiID0gNiAqIHAwW2ldIC0gMTIgKiBwMVtpXSArIDYgKiBwMltpXTtcblx0ICAgICAgICB2YXIgYSA9IC0zICogcDBbaV0gKyA5ICogcDFbaV0gLSA5ICogcDJbaV0gKyAzICogcDNbaV07XG5cdCAgICAgICAgdmFyIGMgPSAzICogcDFbaV0gLSAzICogcDBbaV07XG5cblx0ICAgICAgICBpZiAoYSA9PT0gMCkge1xuXHQgICAgICAgICAgICBpZiAoYiA9PT0gMCkgeyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICB2YXIgdCA9IC1jIC8gYjtcblx0ICAgICAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzJDEuYWRkWChkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQpKTsgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGkgPT09IDEpIHsgdGhpcyQxLmFkZFkoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0KSk7IH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgYjJhYyA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGMgKiBhO1xuXHQgICAgICAgIGlmIChiMmFjIDwgMCkgeyBjb250aW51ZTsgfVxuXHQgICAgICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuXHQgICAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG5cdCAgICAgICAgICAgIGlmIChpID09PSAwKSB7IHRoaXMkMS5hZGRYKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDEpKTsgfVxuXHQgICAgICAgICAgICBpZiAoaSA9PT0gMSkgeyB0aGlzJDEuYWRkWShkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQxKSk7IH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG5cdCAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcblx0ICAgICAgICAgICAgaWYgKGkgPT09IDApIHsgdGhpcyQxLmFkZFgoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0MikpOyB9XG5cdCAgICAgICAgICAgIGlmIChpID09PSAxKSB7IHRoaXMkMS5hZGRZKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDIpKTsgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgcXVhZHJhdGljIGN1cnZlIHRvIHRoZSBib3VuZGluZyBib3guXG5cdCAqIFRoaXMgZXh0ZW5kcyB0aGUgYm91bmRpbmcgYm94IHRvIGluY2x1ZGUgdGhlIGVudGlyZSBxdWFkcmF0aWMgY3VydmUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4MCAtIFRoZSBzdGFydGluZyBYIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5MCAtIFRoZSBzdGFydGluZyBZIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4MSAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5MSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGVuZGluZyBYIGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIGVuZGluZyBZIGNvb3JkaW5hdGUuXG5cdCAqL1xuXHRCb3VuZGluZ0JveC5wcm90b3R5cGUuYWRkUXVhZCA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4LCB5KSB7XG5cdCAgICB2YXIgY3AxeCA9IHgwICsgMiAvIDMgKiAoeDEgLSB4MCk7XG5cdCAgICB2YXIgY3AxeSA9IHkwICsgMiAvIDMgKiAoeTEgLSB5MCk7XG5cdCAgICB2YXIgY3AyeCA9IGNwMXggKyAxIC8gMyAqICh4IC0geDApO1xuXHQgICAgdmFyIGNwMnkgPSBjcDF5ICsgMSAvIDMgKiAoeSAtIHkwKTtcblx0ICAgIHRoaXMuYWRkQmV6aWVyKHgwLCB5MCwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG5cdH07XG5cblx0Ly8gR2VvbWV0cmljIG9iamVjdHNcblxuXHQvKipcblx0ICogQSBiw6l6aWVyIHBhdGggY29udGFpbmluZyBhIHNldCBvZiBwYXRoIGNvbW1hbmRzIHNpbWlsYXIgdG8gYSBTVkcgcGF0aC5cblx0ICogUGF0aHMgY2FuIGJlIGRyYXduIG9uIGEgY29udGV4dCB1c2luZyBgZHJhd2AuXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLlBhdGhcblx0ICogQGNsYXNzXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gUGF0aCgpIHtcblx0ICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcblx0ICAgIHRoaXMuZmlsbCA9ICdibGFjayc7XG5cdCAgICB0aGlzLnN0cm9rZSA9IG51bGw7XG5cdCAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHhcblx0ICogQHBhcmFtICB7bnVtYmVyfSB5XG5cdCAqL1xuXHRQYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5KSB7XG5cdCAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuXHQgICAgICAgIHR5cGU6ICdNJyxcblx0ICAgICAgICB4OiB4LFxuXHQgICAgICAgIHk6IHlcblx0ICAgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHhcblx0ICogQHBhcmFtICB7bnVtYmVyfSB5XG5cdCAqL1xuXHRQYXRoLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbih4LCB5KSB7XG5cdCAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuXHQgICAgICAgIHR5cGU6ICdMJyxcblx0ICAgICAgICB4OiB4LFxuXHQgICAgICAgIHk6IHlcblx0ICAgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBjdWJpYyBjdXJ2ZVxuXHQgKiBAZnVuY3Rpb25cblx0ICogY3VydmVUb1xuXHQgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcblx0ICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbCAxXG5cdCAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2wgMVxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHgyIC0geCBvZiBjb250cm9sIDJcblx0ICogQHBhcmFtICB7bnVtYmVyfSB5MiAtIHkgb2YgY29udHJvbCAyXG5cdCAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcblx0ICovXG5cblx0LyoqXG5cdCAqIERyYXdzIGN1YmljIGN1cnZlXG5cdCAqIEBmdW5jdGlvblxuXHQgKiBiZXppZXJDdXJ2ZVRvXG5cdCAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sIDFcblx0ICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbCAxXG5cdCAqIEBwYXJhbSAge251bWJlcn0geDIgLSB4IG9mIGNvbnRyb2wgMlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHkyIC0geSBvZiBjb250cm9sIDJcblx0ICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG5cdCAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuXHQgKiBAc2VlIGN1cnZlVG9cblx0ICovXG5cdFBhdGgucHJvdG90eXBlLmN1cnZlVG8gPSBQYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcblx0ICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG5cdCAgICAgICAgdHlwZTogJ0MnLFxuXHQgICAgICAgIHgxOiB4MSxcblx0ICAgICAgICB5MTogeTEsXG5cdCAgICAgICAgeDI6IHgyLFxuXHQgICAgICAgIHkyOiB5Mixcblx0ICAgICAgICB4OiB4LFxuXHQgICAgICAgIHk6IHlcblx0ICAgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBxdWFkcmF0aWMgY3VydmVcblx0ICogQGZ1bmN0aW9uXG5cdCAqIHF1YWRyYXRpY0N1cnZlVG9cblx0ICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG5cdCAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2xcblx0ICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbFxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcblx0ICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBxdWFkcmF0aWMgY3VydmVcblx0ICogQGZ1bmN0aW9uXG5cdCAqIHF1YWRUb1xuXHQgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcblx0ICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbFxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sXG5cdCAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcblx0ICovXG5cdFBhdGgucHJvdG90eXBlLnF1YWRUbyA9IFBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbih4MSwgeTEsIHgsIHkpIHtcblx0ICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG5cdCAgICAgICAgdHlwZTogJ1EnLFxuXHQgICAgICAgIHgxOiB4MSxcblx0ICAgICAgICB5MTogeTEsXG5cdCAgICAgICAgeDogeCxcblx0ICAgICAgICB5OiB5XG5cdCAgICB9KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2VzIHRoZSBwYXRoXG5cdCAqIEBmdW5jdGlvbiBjbG9zZVBhdGhcblx0ICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDbG9zZSB0aGUgcGF0aFxuXHQgKiBAZnVuY3Rpb24gY2xvc2Vcblx0ICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG5cdCAqL1xuXHRQYXRoLnByb3RvdHlwZS5jbG9zZSA9IFBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcblx0ICAgICAgICB0eXBlOiAnWidcblx0ICAgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgdGhlIGdpdmVuIHBhdGggb3IgbGlzdCBvZiBjb21tYW5kcyB0byB0aGUgY29tbWFuZHMgb2YgdGhpcyBwYXRoLlxuXHQgKiBAcGFyYW0gIHtBcnJheX0gcGF0aE9yQ29tbWFuZHMgLSBhbm90aGVyIG9wZW50eXBlLlBhdGgsIGFuIG9wZW50eXBlLkJvdW5kaW5nQm94LCBvciBhbiBhcnJheSBvZiBjb21tYW5kcy5cblx0ICovXG5cdFBhdGgucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKHBhdGhPckNvbW1hbmRzKSB7XG5cdCAgICBpZiAocGF0aE9yQ29tbWFuZHMuY29tbWFuZHMpIHtcblx0ICAgICAgICBwYXRoT3JDb21tYW5kcyA9IHBhdGhPckNvbW1hbmRzLmNvbW1hbmRzO1xuXHQgICAgfSBlbHNlIGlmIChwYXRoT3JDb21tYW5kcyBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KSB7XG5cdCAgICAgICAgdmFyIGJveCA9IHBhdGhPckNvbW1hbmRzO1xuXHQgICAgICAgIHRoaXMubW92ZVRvKGJveC54MSwgYm94LnkxKTtcblx0ICAgICAgICB0aGlzLmxpbmVUbyhib3gueDIsIGJveC55MSk7XG5cdCAgICAgICAgdGhpcy5saW5lVG8oYm94LngyLCBib3gueTIpO1xuXHQgICAgICAgIHRoaXMubGluZVRvKGJveC54MSwgYm94LnkyKTtcblx0ICAgICAgICB0aGlzLmNsb3NlKCk7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLmNvbW1hbmRzLCBwYXRoT3JDb21tYW5kcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBwYXRoLlxuXHQgKiBAcmV0dXJucyB7b3BlbnR5cGUuQm91bmRpbmdCb3h9XG5cdCAqL1xuXHRQYXRoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIHZhciBib3ggPSBuZXcgQm91bmRpbmdCb3goKTtcblxuXHQgICAgdmFyIHN0YXJ0WCA9IDA7XG5cdCAgICB2YXIgc3RhcnRZID0gMDtcblx0ICAgIHZhciBwcmV2WCA9IDA7XG5cdCAgICB2YXIgcHJldlkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGNtZCA9IHRoaXMkMS5jb21tYW5kc1tpXTtcblx0ICAgICAgICBzd2l0Y2ggKGNtZC50eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2UgJ00nOlxuXHQgICAgICAgICAgICAgICAgYm94LmFkZFBvaW50KGNtZC54LCBjbWQueSk7XG5cdCAgICAgICAgICAgICAgICBzdGFydFggPSBwcmV2WCA9IGNtZC54O1xuXHQgICAgICAgICAgICAgICAgc3RhcnRZID0gcHJldlkgPSBjbWQueTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlICdMJzpcblx0ICAgICAgICAgICAgICAgIGJveC5hZGRQb2ludChjbWQueCwgY21kLnkpO1xuXHQgICAgICAgICAgICAgICAgcHJldlggPSBjbWQueDtcblx0ICAgICAgICAgICAgICAgIHByZXZZID0gY21kLnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnUSc6XG5cdCAgICAgICAgICAgICAgICBib3guYWRkUXVhZChwcmV2WCwgcHJldlksIGNtZC54MSwgY21kLnkxLCBjbWQueCwgY21kLnkpO1xuXHQgICAgICAgICAgICAgICAgcHJldlggPSBjbWQueDtcblx0ICAgICAgICAgICAgICAgIHByZXZZID0gY21kLnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnQyc6XG5cdCAgICAgICAgICAgICAgICBib3guYWRkQmV6aWVyKHByZXZYLCBwcmV2WSwgY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuXHQgICAgICAgICAgICAgICAgcHJldlggPSBjbWQueDtcblx0ICAgICAgICAgICAgICAgIHByZXZZID0gY21kLnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnWic6XG5cdCAgICAgICAgICAgICAgICBwcmV2WCA9IHN0YXJ0WDtcblx0ICAgICAgICAgICAgICAgIHByZXZZID0gc3RhcnRZO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcGF0aCBjb21tYW5kICcgKyBjbWQudHlwZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGJveC5pc0VtcHR5KCkpIHtcblx0ICAgICAgICBib3guYWRkUG9pbnQoMCwgMCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYm94O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3IHRoZSBwYXRoIHRvIGEgMkQgY29udGV4dC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LlxuXHQgKi9cblx0UGF0aC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIGN0eC5iZWdpblBhdGgoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBjbWQgPSB0aGlzJDEuY29tbWFuZHNbaV07XG5cdCAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcblx0ICAgICAgICAgICAgY3R4Lm1vdmVUbyhjbWQueCwgY21kLnkpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuXHQgICAgICAgICAgICBjdHgubGluZVRvKGNtZC54LCBjbWQueSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG5cdCAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcblx0ICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY21kLngxLCBjbWQueTEsIGNtZC54LCBjbWQueSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG5cdCAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLmZpbGwpIHtcblx0ICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsO1xuXHQgICAgICAgIGN0eC5maWxsKCk7XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLnN0cm9rZSkge1xuXHQgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlO1xuXHQgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuXHQgICAgICAgIGN0eC5zdHJva2UoKTtcblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydCB0aGUgUGF0aCB0byBhIHN0cmluZyBvZiBwYXRoIGRhdGEgaW5zdHJ1Y3Rpb25zXG5cdCAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFtkZWNpbWFsUGxhY2VzPTJdIC0gVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdFBhdGgucHJvdG90eXBlLnRvUGF0aERhdGEgPSBmdW5jdGlvbihkZWNpbWFsUGxhY2VzKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgZGVjaW1hbFBsYWNlcyA9IGRlY2ltYWxQbGFjZXMgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxQbGFjZXMgOiAyO1xuXG5cdCAgICBmdW5jdGlvbiBmbG9hdFRvU3RyaW5nKHYpIHtcblx0ICAgICAgICBpZiAoTWF0aC5yb3VuZCh2KSA9PT0gdikge1xuXHQgICAgICAgICAgICByZXR1cm4gJycgKyBNYXRoLnJvdW5kKHYpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2LnRvRml4ZWQoZGVjaW1hbFBsYWNlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwYWNrVmFsdWVzKCkge1xuXHQgICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuXHQgICAgICAgIHZhciBzID0gJyc7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgdmFyIHYgPSBhcmd1bWVudHMkMVtpXTtcblx0ICAgICAgICAgICAgaWYgKHYgPj0gMCAmJiBpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgcyArPSAnICc7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBzICs9IGZsb2F0VG9TdHJpbmcodik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHM7XG5cdCAgICB9XG5cblx0ICAgIHZhciBkID0gJyc7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgY21kID0gdGhpcyQxLmNvbW1hbmRzW2ldO1xuXHQgICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG5cdCAgICAgICAgICAgIGQgKz0gJ00nICsgcGFja1ZhbHVlcyhjbWQueCwgY21kLnkpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuXHQgICAgICAgICAgICBkICs9ICdMJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcblx0ICAgICAgICAgICAgZCArPSAnQycgKyBwYWNrVmFsdWVzKGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcblx0ICAgICAgICAgICAgZCArPSAnUScgKyBwYWNrVmFsdWVzKGNtZC54MSwgY21kLnkxLCBjbWQueCwgY21kLnkpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuXHQgICAgICAgICAgICBkICs9ICdaJztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoZSBwYXRoIHRvIGFuIFNWRyA8cGF0aD4gZWxlbWVudCwgYXMgYSBzdHJpbmcuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW2RlY2ltYWxQbGFjZXM9Ml0gLSBUaGUgYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIGZvciBmbG9hdGluZy1wb2ludCB2YWx1ZXNcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0UGF0aC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbihkZWNpbWFsUGxhY2VzKSB7XG5cdCAgICB2YXIgc3ZnID0gJzxwYXRoIGQ9XCInO1xuXHQgICAgc3ZnICs9IHRoaXMudG9QYXRoRGF0YShkZWNpbWFsUGxhY2VzKTtcblx0ICAgIHN2ZyArPSAnXCInO1xuXHQgICAgaWYgKHRoaXMuZmlsbCAmJiB0aGlzLmZpbGwgIT09ICdibGFjaycpIHtcblx0ICAgICAgICBpZiAodGhpcy5maWxsID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHN2ZyArPSAnIGZpbGw9XCJub25lXCInO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHN2ZyArPSAnIGZpbGw9XCInICsgdGhpcy5maWxsICsgJ1wiJztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLnN0cm9rZSkge1xuXHQgICAgICAgIHN2ZyArPSAnIHN0cm9rZT1cIicgKyB0aGlzLnN0cm9rZSArICdcIiBzdHJva2Utd2lkdGg9XCInICsgdGhpcy5zdHJva2VXaWR0aCArICdcIic7XG5cdCAgICB9XG5cblx0ICAgIHN2ZyArPSAnLz4nO1xuXHQgICAgcmV0dXJuIHN2Zztcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydCB0aGUgcGF0aCB0byBhIERPTSBlbGVtZW50LlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFtkZWNpbWFsUGxhY2VzPTJdIC0gVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzXG5cdCAqIEByZXR1cm4ge1NWR1BhdGhFbGVtZW50fVxuXHQgKi9cblx0UGF0aC5wcm90b3R5cGUudG9ET01FbGVtZW50ID0gZnVuY3Rpb24oZGVjaW1hbFBsYWNlcykge1xuXHQgICAgdmFyIHRlbXBvcmFyeVBhdGggPSB0aGlzLnRvUGF0aERhdGEoZGVjaW1hbFBsYWNlcyk7XG5cdCAgICB2YXIgbmV3UGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncGF0aCcpO1xuXG5cdCAgICBuZXdQYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRlbXBvcmFyeVBhdGgpO1xuXG5cdCAgICByZXR1cm4gbmV3UGF0aDtcblx0fTtcblxuXHQvLyBSdW4tdGltZSBjaGVja2luZyBvZiBwcmVjb25kaXRpb25zLlxuXG5cdGZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHR9XG5cblx0Ly8gUHJlY29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBnaXZlbiBwcmVkaWNhdGUgaXMgdHJ1ZS5cblx0Ly8gSWYgbm90LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuXHRmdW5jdGlvbiBhcmd1bWVudChwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcblx0ICAgIGlmICghcHJlZGljYXRlKSB7XG5cdCAgICAgICAgZmFpbChtZXNzYWdlKTtcblx0ICAgIH1cblx0fVxuXHR2YXIgY2hlY2sgPSB7IGZhaWw6IGZhaWwsIGFyZ3VtZW50OiBhcmd1bWVudCwgYXNzZXJ0OiBhcmd1bWVudCB9O1xuXG5cdC8vIERhdGEgdHlwZXMgdXNlZCBpbiB0aGUgT3BlblR5cGUgZm9udCBmaWxlLlxuXG5cdHZhciBMSU1JVDE2ID0gMzI3Njg7IC8vIFRoZSBsaW1pdCBhdCB3aGljaCBhIDE2LWJpdCBudW1iZXIgc3dpdGNoZXMgc2lnbnMgPT0gMl4xNVxuXHR2YXIgTElNSVQzMiA9IDIxNDc0ODM2NDg7IC8vIFRoZSBsaW1pdCBhdCB3aGljaCBhIDMyLWJpdCBudW1iZXIgc3dpdGNoZXMgc2lnbnMgPT0gMiBeIDMxXG5cblx0LyoqXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLmRlY29kZVxuXHQgKiBAY2xhc3Ncblx0ICovXG5cdHZhciBkZWNvZGUgPSB7fTtcblx0LyoqXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLmVuY29kZVxuXHQgKiBAY2xhc3Ncblx0ICovXG5cdHZhciBlbmNvZGUgPSB7fTtcblx0LyoqXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLnNpemVPZlxuXHQgKiBAY2xhc3Ncblx0ICovXG5cdHZhciBzaXplT2YgPSB7fTtcblxuXHQvLyBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIHZhbHVlLlxuXHRmdW5jdGlvbiBjb25zdGFudCh2KSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgcmV0dXJuIHY7XG5cdCAgICB9O1xuXHR9XG5cblx0Ly8gT3BlblR5cGUgZGF0YSB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogQ29udmVydCBhbiA4LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAxIGJ5dGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuQllURSA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIGNoZWNrLmFyZ3VtZW50KHYgPj0gMCAmJiB2IDw9IDI1NSwgJ0J5dGUgdmFsdWUgc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgMjU1LicpO1xuXHQgICAgcmV0dXJuIFt2XTtcblx0fTtcblx0LyoqXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZU9mLkJZVEUgPSBjb25zdGFudCgxKTtcblxuXHQvKipcblx0ICogQ29udmVydCBhIDgtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAxIGJ5dGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuQ0hBUiA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHJldHVybiBbdi5jaGFyQ29kZUF0KDApXTtcblx0fTtcblxuXHQvKipcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuQ0hBUiA9IGNvbnN0YW50KDEpO1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGFuIEFTQ0lJIHN0cmluZyB0byBhIGxpc3Qgb2YgYnl0ZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuQ0hBUkFSUkFZID0gZnVuY3Rpb24odikge1xuXHQgICAgdmFyIGIgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIGJbaV0gPSB2LmNoYXJDb2RlQXQoaSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0FycmF5fVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZU9mLkNIQVJBUlJBWSA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHJldHVybiB2Lmxlbmd0aDtcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydCBhIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAyIGJ5dGVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLlVTSE9SVCA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHJldHVybiBbKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG5cdH07XG5cblx0LyoqXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZU9mLlVTSE9SVCA9IGNvbnN0YW50KDIpO1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgMTYtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAyIGJ5dGVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLlNIT1JUID0gZnVuY3Rpb24odikge1xuXHQgICAgLy8gVHdvJ3MgY29tcGxlbWVudFxuXHQgICAgaWYgKHYgPj0gTElNSVQxNikge1xuXHQgICAgICAgIHYgPSAtKDIgKiBMSU1JVDE2IC0gdik7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBbKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG5cdH07XG5cblx0LyoqXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZU9mLlNIT1JUID0gY29uc3RhbnQoMik7XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYSAyNC1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMyBieXRlcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9XG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGVuY29kZS5VSU5UMjQgPSBmdW5jdGlvbih2KSB7XG5cdCAgICByZXR1cm4gWyh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5VSU5UMjQgPSBjb25zdGFudCgzKTtcblxuXHQvKipcblx0ICogQ29udmVydCBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLlVMT05HID0gZnVuY3Rpb24odikge1xuXHQgICAgcmV0dXJuIFsodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcblx0fTtcblxuXHQvKipcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuVUxPTkcgPSBjb25zdGFudCg0KTtcblxuXHQvKipcblx0ICogQ29udmVydCBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLkxPTkcgPSBmdW5jdGlvbih2KSB7XG5cdCAgICAvLyBUd28ncyBjb21wbGVtZW50XG5cdCAgICBpZiAodiA+PSBMSU1JVDMyKSB7XG5cdCAgICAgICAgdiA9IC0oMiAqIExJTUlUMzIgLSB2KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIFsodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcblx0fTtcblxuXHQvKipcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuTE9ORyA9IGNvbnN0YW50KDQpO1xuXG5cdGVuY29kZS5GSVhFRCA9IGVuY29kZS5VTE9ORztcblx0c2l6ZU9mLkZJWEVEID0gc2l6ZU9mLlVMT05HO1xuXG5cdGVuY29kZS5GV09SRCA9IGVuY29kZS5TSE9SVDtcblx0c2l6ZU9mLkZXT1JEID0gc2l6ZU9mLlNIT1JUO1xuXG5cdGVuY29kZS5VRldPUkQgPSBlbmNvZGUuVVNIT1JUO1xuXHRzaXplT2YuVUZXT1JEID0gc2l6ZU9mLlVTSE9SVDtcblxuXHQvKipcblx0ICogQ29udmVydCBhIDMyLWJpdCBBcHBsZSBNYWMgdGltZXN0YW1wIGludGVnZXIgdG8gYSBsaXN0IG9mIDggYnl0ZXMsIDY0LWJpdCB0aW1lc3RhbXAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuTE9OR0RBVEVUSU1FID0gZnVuY3Rpb24odikge1xuXHQgICAgcmV0dXJuIFswLCAwLCAwLCAwLCAodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcblx0fTtcblxuXHQvKipcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuTE9OR0RBVEVUSU1FID0gY29uc3RhbnQoOCk7XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYSA0LWNoYXIgdGFnIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ31cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLlRBRyA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIGNoZWNrLmFyZ3VtZW50KHYubGVuZ3RoID09PSA0LCAnVGFnIHNob3VsZCBiZSBleGFjdGx5IDQgQVNDSUkgY2hhcmFjdGVycy4nKTtcblx0ICAgIHJldHVybiBbdi5jaGFyQ29kZUF0KDApLFxuXHQgICAgICAgICAgICB2LmNoYXJDb2RlQXQoMSksXG5cdCAgICAgICAgICAgIHYuY2hhckNvZGVBdCgyKSxcblx0ICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDMpXTtcblx0fTtcblxuXHQvKipcblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuVEFHID0gY29uc3RhbnQoNCk7XG5cblx0Ly8gQ0ZGIGRhdGEgdHlwZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHRlbmNvZGUuQ2FyZDggPSBlbmNvZGUuQllURTtcblx0c2l6ZU9mLkNhcmQ4ID0gc2l6ZU9mLkJZVEU7XG5cblx0ZW5jb2RlLkNhcmQxNiA9IGVuY29kZS5VU0hPUlQ7XG5cdHNpemVPZi5DYXJkMTYgPSBzaXplT2YuVVNIT1JUO1xuXG5cdGVuY29kZS5PZmZTaXplID0gZW5jb2RlLkJZVEU7XG5cdHNpemVPZi5PZmZTaXplID0gc2l6ZU9mLkJZVEU7XG5cblx0ZW5jb2RlLlNJRCA9IGVuY29kZS5VU0hPUlQ7XG5cdHNpemVPZi5TSUQgPSBzaXplT2YuVVNIT1JUO1xuXG5cdC8vIENvbnZlcnQgYSBudW1lcmljIG9wZXJhbmQgb3IgY2hhcnN0cmluZyBudW1iZXIgdG8gYSB2YXJpYWJsZS1zaXplIGxpc3Qgb2YgYnl0ZXMuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgbnVtZXJpYyBvcGVyYW5kIG9yIGNoYXJzdHJpbmcgbnVtYmVyIHRvIGEgdmFyaWFibGUtc2l6ZSBsaXN0IG9mIGJ5dGVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLk5VTUJFUiA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIGlmICh2ID49IC0xMDcgJiYgdiA8PSAxMDcpIHtcblx0ICAgICAgICByZXR1cm4gW3YgKyAxMzldO1xuXHQgICAgfSBlbHNlIGlmICh2ID49IDEwOCAmJiB2IDw9IDExMzEpIHtcblx0ICAgICAgICB2ID0gdiAtIDEwODtcblx0ICAgICAgICByZXR1cm4gWyh2ID4+IDgpICsgMjQ3LCB2ICYgMHhGRl07XG5cdCAgICB9IGVsc2UgaWYgKHYgPj0gLTExMzEgJiYgdiA8PSAtMTA4KSB7XG5cdCAgICAgICAgdiA9IC12IC0gMTA4O1xuXHQgICAgICAgIHJldHVybiBbKHYgPj4gOCkgKyAyNTEsIHYgJiAweEZGXTtcblx0ICAgIH0gZWxzZSBpZiAodiA+PSAtMzI3NjggJiYgdiA8PSAzMjc2Nykge1xuXHQgICAgICAgIHJldHVybiBlbmNvZGUuTlVNQkVSMTYodik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBlbmNvZGUuTlVNQkVSMzIodik7XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZU9mLk5VTUJFUiA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHJldHVybiBlbmNvZGUuTlVNQkVSKHYpLmxlbmd0aDtcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydCBhIHNpZ25lZCBudW1iZXIgYmV0d2VlbiAtMzI3NjggYW5kICszMjc2NyB0byBhIHRocmVlLWJ5dGUgdmFsdWUuXG5cdCAqIFRoaXMgZW5zdXJlcyB3ZSBhbHdheXMgdXNlIHRocmVlIGJ5dGVzLCBidXQgaXMgbm90IHRoZSBtb3N0IGNvbXBhY3QgZm9ybWF0LlxuXHQgKiBAcGFyYW0ge251bWJlcn1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLk5VTUJFUjE2ID0gZnVuY3Rpb24odikge1xuXHQgICAgcmV0dXJuIFsyOCwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG5cdH07XG5cblx0LyoqXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZU9mLk5VTUJFUjE2ID0gY29uc3RhbnQoMyk7XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLSgyXjMxKSBhbmQgKygyXjMxLTEpIHRvIGEgZml2ZS1ieXRlIHZhbHVlLlxuXHQgKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBiZSBzdXJlIHlvdSBhbHdheXMgdXNlIGZvdXIgYnl0ZXMsXG5cdCAqIGF0IHRoZSBleHBlbnNlIG9mIHdhc3RpbmcgYSBmZXcgYnl0ZXMgZm9yIHNtYWxsZXIgbnVtYmVycy5cblx0ICogQHBhcmFtIHtudW1iZXJ9XG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGVuY29kZS5OVU1CRVIzMiA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHJldHVybiBbMjksICh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdHNpemVPZi5OVU1CRVIzMiA9IGNvbnN0YW50KDUpO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLlJFQUwgPSBmdW5jdGlvbih2KSB7XG5cdCAgICB2YXIgdmFsdWUgPSB2LnRvU3RyaW5nKCk7XG5cblx0ICAgIC8vIFNvbWUgbnVtYmVycyB1c2UgYW4gZXBzaWxvbiB0byBlbmNvZGUgdGhlIHZhbHVlLiAoZS5nLiBKYXZhU2NyaXB0IHdpbGwgc3RvcmUgMC4wMDAwMDAxIGFzIDFlLTcpXG5cdCAgICAvLyBUaGlzIGNvZGUgY29udmVydHMgaXQgYmFjayB0byBhIG51bWJlciB3aXRob3V0IHRoZSBlcHNpbG9uLlxuXHQgICAgdmFyIG0gPSAvXFwuKFxcZCo/KSg/Ojl7NSwyMH18MHs1LDIwfSlcXGR7MCwyfSg/OmUoLispfCQpLy5leGVjKHZhbHVlKTtcblx0ICAgIGlmIChtKSB7XG5cdCAgICAgICAgdmFyIGVwc2lsb24gPSBwYXJzZUZsb2F0KCcxZScgKyAoKG1bMl0gPyArbVsyXSA6IDApICsgbVsxXS5sZW5ndGgpKTtcblx0ICAgICAgICB2YWx1ZSA9IChNYXRoLnJvdW5kKHYgKiBlcHNpbG9uKSAvIGVwc2lsb24pLnRvU3RyaW5nKCk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBuaWJibGVzID0gJyc7XG5cdCAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpaTsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGMgPSB2YWx1ZVtpXTtcblx0ICAgICAgICBpZiAoYyA9PT0gJ2UnKSB7XG5cdCAgICAgICAgICAgIG5pYmJsZXMgKz0gdmFsdWVbKytpXSA9PT0gJy0nID8gJ2MnIDogJ2InO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy4nKSB7XG5cdCAgICAgICAgICAgIG5pYmJsZXMgKz0gJ2EnO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy0nKSB7XG5cdCAgICAgICAgICAgIG5pYmJsZXMgKz0gJ2UnO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIG5pYmJsZXMgKz0gYztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIG5pYmJsZXMgKz0gKG5pYmJsZXMubGVuZ3RoICYgMSkgPyAnZicgOiAnZmYnO1xuXHQgICAgdmFyIG91dCA9IFszMF07XG5cdCAgICBmb3IgKHZhciBpJDEgPSAwLCBpaSQxID0gbmliYmxlcy5sZW5ndGg7IGkkMSA8IGlpJDE7IGkkMSArPSAyKSB7XG5cdCAgICAgICAgb3V0LnB1c2gocGFyc2VJbnQobmliYmxlcy5zdWJzdHIoaSQxLCAyKSwgMTYpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG91dDtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9XG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuUkVBTCA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHJldHVybiBlbmNvZGUuUkVBTCh2KS5sZW5ndGg7XG5cdH07XG5cblx0ZW5jb2RlLk5BTUUgPSBlbmNvZGUuQ0hBUkFSUkFZO1xuXHRzaXplT2YuTkFNRSA9IHNpemVPZi5DSEFSQVJSQVk7XG5cblx0ZW5jb2RlLlNUUklORyA9IGVuY29kZS5DSEFSQVJSQVk7XG5cdHNpemVPZi5TVFJJTkcgPSBzaXplT2YuQ0hBUkFSUkFZO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcblx0ICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRkZWNvZGUuVVRGOCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbnVtQnl0ZXMpIHtcblx0ICAgIHZhciBjb2RlUG9pbnRzID0gW107XG5cdCAgICB2YXIgbnVtQ2hhcnMgPSBudW1CeXRlcztcblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQ2hhcnM7IGorKywgb2Zmc2V0ICs9IDEpIHtcblx0ICAgICAgICBjb2RlUG9pbnRzW2pdID0gZGF0YS5nZXRVaW50OChvZmZzZXQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuXHQgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBudW1CeXRlc1xuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0ZGVjb2RlLlVURjE2ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBudW1CeXRlcykge1xuXHQgICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcblx0ICAgIHZhciBudW1DaGFycyA9IG51bUJ5dGVzIC8gMjtcblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQ2hhcnM7IGorKywgb2Zmc2V0ICs9IDIpIHtcblx0ICAgICAgICBjb2RlUG9pbnRzW2pdID0gZGF0YS5nZXRVaW50MTYob2Zmc2V0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVBvaW50cyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYSBKYXZhU2NyaXB0IHN0cmluZyB0byBVVEYxNi1CRS5cblx0ICogQHBhcmFtIHtzdHJpbmd9XG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGVuY29kZS5VVEYxNiA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHZhciBiID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgY29kZXBvaW50ID0gdi5jaGFyQ29kZUF0KGkpO1xuXHQgICAgICAgIGJbYi5sZW5ndGhdID0gKGNvZGVwb2ludCA+PiA4KSAmIDB4RkY7XG5cdCAgICAgICAgYltiLmxlbmd0aF0gPSBjb2RlcG9pbnQgJiAweEZGO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYjtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9XG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuVVRGMTYgPSBmdW5jdGlvbih2KSB7XG5cdCAgICByZXR1cm4gdi5sZW5ndGggKiAyO1xuXHR9O1xuXG5cdC8vIERhdGEgZm9yIGNvbnZlcnRpbmcgb2xkIGVpZ2h0LWJpdCBNYWNpbnRvc2ggZW5jb2RpbmdzIHRvIFVuaWNvZGUuXG5cdC8vIFRoaXMgcmVwcmVzZW50YXRpb24gaXMgb3B0aW1pemVkIGZvciBkZWNvZGluZzsgZW5jb2RpbmcgaXMgc2xvd2VyXG5cdC8vIGFuZCBuZWVkcyBtb3JlIG1lbW9yeS4gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCBhbGwgb3BlbnR5cGUuanMgdXNlcnNcblx0Ly8gd2FudCB0byBvcGVuIGZvbnRzLCBidXQgc2F2aW5nIGEgZm9udCB3aWxsIGJlIGNvbXBhcmF0aXZlbHkgcmFyZVxuXHQvLyBzbyBpdCBjYW4gYmUgbW9yZSBleHBlbnNpdmUuIEtleWVkIGJ5IElBTkEgY2hhcmFjdGVyIHNldCBuYW1lLlxuXHQvL1xuXHQvLyBQeXRob24gc2NyaXB0IGZvciBnZW5lcmF0aW5nIHRoZXNlIHN0cmluZ3M6XG5cdC8vXG5cdC8vICAgICBzID0gdScnLmpvaW4oW2NocihjKS5kZWNvZGUoJ21hY19ncmVlaycpIGZvciBjIGluIHJhbmdlKDEyOCwgMjU2KV0pXG5cdC8vICAgICBwcmludChzLmVuY29kZSgndXRmLTgnKSlcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR2YXIgZWlnaHRCaXRNYWNFbmNvZGluZ3MgPSB7XG5cdCAgICAneC1tYWMtY3JvYXRpYW4nOiAgLy8gUHl0aG9uOiAnbWFjX2Nyb2F0aWFuJ1xuXHQgICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsWg4oSiwrTCqOKJoMW9w5jiiJ7CseKJpOKJpeKIhsK14oiC4oiR4oiPxaHiiKvCqsK6zqnFvsO4JyArXG5cdCAgICAnwr/CocKs4oiaxpLiiYjEhsKrxIzigKbCoMOAw4PDlcWSxZPEkOKAlOKAnOKAneKAmOKAmcO34peK76O/wqnigYTigqzigLnigLrDhsK74oCTwrfigJrigJ7igLDDgsSHw4HEjcOIw43DjsOPw4zDk8OUxJHDksOaw5vDmcSxy4bLnMKvz4DDi8uawrjDisOmy4cnLFxuXHQgICAgJ3gtbWFjLWN5cmlsbGljJzogIC8vIFB5dGhvbjogJ21hY19jeXJpbGxpYydcblx0ICAgICfQkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv4oCgwrDSkMKjwqfigKLCttCGwq7CqeKEotCC0ZLiiaDQg9GT4oiewrHiiaTiiaXRlsK10pHQiNCE0ZTQh9GX0InRmdCK0ZonICtcblx0ICAgICfRmNCFwqziiJrGkuKJiOKIhsKrwrvigKbCoNCL0ZvQjNGc0ZXigJPigJTigJzigJ3igJjigJnDt+KAntCO0Z7Qj9Gf4oSW0IHRkdGP0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/RgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y4nLFxuXHQgICAgJ3gtbWFjLWdhZWxpYyc6IC8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9HQUVMSUMuVFhUXG5cdCAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOG4gsKx4omk4oml4biDxIrEi+G4iuG4i+G4nuG4n8SgxKHhuYDDpsO4JyArXG5cdCAgICAn4bmB4bmW4bmXybzGksW/4bmgwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmeG5oeG6m8O/xbjhuarigqzigLnigLrFtsW34bmrwrfhu7Lhu7PigYrDgsOKw4HDi8OIw43DjsOPw4zDk8OU4pmjw5LDmsObw5nEscOdw73FtMW14bqE4bqF4bqA4bqB4bqC4bqDJyxcblx0ICAgICd4LW1hYy1ncmVlayc6ICAvLyBQeXRob246ICdtYWNfZ3JlZWsnXG5cdCAgICAnw4TCucKyw4nCs8OWw5zOhcOgw6LDpM6EwqjDp8Opw6jDqsOrwqPihKLDrsOv4oCiwr3igLDDtMO2wqbigqzDucO7w7zigKDOk86UzpjOm86ezqDDn8KuwqnOo86qwqfiiaDCsMK3zpHCseKJpOKJpcKlzpLOlc6WzpfOmc6azpzOps6rzqjOqScgK1xuXHQgICAgJ86szp3CrM6fzqHiiYjOpMKrwrvigKbCoM6lzqfOhs6IxZPigJPigJXigJzigJ3igJjigJnDt86JzorOjM6Ozq3Ors6vz4zOj8+NzrHOss+IzrTOtc+GzrPOt865zr7Ous67zrzOvc6/z4DPjs+Bz4PPhM64z4nPgs+Hz4XOts+Kz4vOkM6wXFx1MDBBRCcsXG5cdCAgICAneC1tYWMtaWNlbGFuZGljJzogIC8vIFB5dGhvbjogJ21hY19pY2VsYW5kJ1xuXHQgICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zDncKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuXHQgICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrMOQw7DDnsO+w73Ct+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4cnLFxuXHQgICAgJ3gtbWFjLWludWl0JzogLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL0lOVUlULlRYVFxuXHQgICAgJ+GQg+GQhOGQheGQhuGQiuGQi+GQseGQsuGQs+GQtOGQuOGQueGRieGRjuGRj+GRkOGRkeGRleGRluGRpuGRreGRruGRr+GRsOGRsuGRs+GSg+GSi+GSjOGSjeGSjuGSkOGSkcKw4ZKh4ZKl4ZKm4oCiwrbhkqfCrsKp4oSi4ZKo4ZKq4ZKr4ZK74ZOC4ZOD4ZOE4ZOF4ZOH4ZOI4ZOQ4ZOv4ZOw4ZOx4ZOy4ZO04ZO14ZSF4ZOV4ZOW4ZOXJyArXG5cdCAgICAn4ZOY4ZOa4ZOb4ZOq4ZSo4ZSp4ZSq4ZSr4ZSt4oCmwqDhlK7hlL7hlZXhlZbhlZfigJPigJTigJzigJ3igJjigJnhlZjhlZnhlZrhlZ3hlYbhlYfhlYjhlYnhlYvhlYzhlZDhlb/hloDhloHhloLhloPhloThloXhlo/hlpDhlpHhlpLhlpPhlpThlpXhmbHhmbLhmbPhmbThmbXhmbbhlpbhlqDhlqHhlqLhlqPhlqThlqXhlqbhlbzFgcWCJyxcblx0ICAgICd4LW1hYy1jZSc6ICAvLyBQeXRob246ICdtYWNfbGF0aW4yJ1xuXHQgICAgJ8OExIDEgcOJxITDlsOcw6HEhcSMw6TEjcSGxIfDqcW5xbrEjsOtxI/EksSTxJbDs8SXw7TDtsO1w7rEmsSbw7zigKDCsMSYwqPCp+KAosK2w5/CrsKp4oSixJnCqOKJoMSjxK7Er8Sq4omk4omlxKvEtuKIguKIkcWCxLvEvMS9xL7EucS6xYUnICtcblx0ICAgICfFhsWDwqziiJrFhMWH4oiGwqvCu+KApsKgxYjFkMOVxZHFjOKAk+KAlOKAnOKAneKAmOKAmcO34peKxY3FlMWVxZjigLnigLrFmcWWxZfFoOKAmuKAnsWhxZrFm8OBxaTFpcONxb3FvsWqw5PDlMWrxa7DmsWvxbDFscWyxbPDncO9xLfFu8WBxbzEosuHJyxcblx0ICAgIG1hY2ludG9zaDogIC8vIFB5dGhvbjogJ21hY19yb21hbidcblx0ICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnDpsO4JyArXG5cdCAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKs4oC54oC676yB76yC4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHJyxcblx0ICAgICd4LW1hYy1yb21hbmlhbic6ICAvLyBQeXRob246ICdtYWNfcm9tYW5pYW4nXG5cdCAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgxILImOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pxIPImScgK1xuXHQgICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrOKAueKAusiayJvigKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4cnLFxuXHQgICAgJ3gtbWFjLXR1cmtpc2gnOiAgLy8gUHl0aG9uOiAnbWFjX3R1cmtpc2gnXG5cdCAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuXHQgICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuMSexJ/EsMSxxZ7Fn+KAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZ76Kgy4bLnMKvy5jLmcuawrjLncuby4cnXG5cdH07XG5cblx0LyoqXG5cdCAqIERlY29kZXMgYW4gb2xkLXN0eWxlIE1hY2ludG9zaCBzdHJpbmcuIFJldHVybnMgZWl0aGVyIGEgVW5pY29kZSBKYXZhU2NyaXB0XG5cdCAqIHN0cmluZywgb3IgJ3VuZGVmaW5lZCcgaWYgdGhlIGVuY29kaW5nIGlzIHVuc3VwcG9ydGVkLiBGb3IgZXhhbXBsZSwgd2UgZG9cblx0ICogbm90IHN1cHBvcnQgQ2hpbmVzZSwgSmFwYW5lc2Ugb3IgS29yZWFuIGJlY2F1c2UgdGhlc2Ugd291bGQgbmVlZCBsYXJnZVxuXHQgKiBtYXBwaW5nIHRhYmxlcy5cblx0ICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXdcblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGF0YUxlbmd0aFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZW5jb2Rpbmdcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGRlY29kZS5NQUNTVFJJTkcgPSBmdW5jdGlvbihkYXRhVmlldywgb2Zmc2V0LCBkYXRhTGVuZ3RoLCBlbmNvZGluZykge1xuXHQgICAgdmFyIHRhYmxlID0gZWlnaHRCaXRNYWNFbmNvZGluZ3NbZW5jb2RpbmddO1xuXHQgICAgaWYgKHRhYmxlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcmVzdWx0ID0gJyc7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSk7XG5cdCAgICAgICAgLy8gSW4gYWxsIGVpZ2h0LWJpdCBNYWMgZW5jb2RpbmdzLCB0aGUgY2hhcmFjdGVycyAweDAwLi4weDdGIGFyZVxuXHQgICAgICAgIC8vIG1hcHBlZCB0byBVKzAwMDAuLlUrMDA3Rjsgd2Ugb25seSBuZWVkIHRvIGxvb2sgdXAgdGhlIG90aGVycy5cblx0ICAgICAgICBpZiAoYyA8PSAweDdGKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCArPSB0YWJsZVtjICYgMHg3Rl07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZW5jb2RlLk1BQ1NUUklORy4gUmV0dXJucyBhIGRpY3Rpb25hcnkgZm9yIG1hcHBpbmdcblx0Ly8gVW5pY29kZSBjaGFyYWN0ZXIgY29kZXMgdG8gdGhlaXIgOC1iaXQgTWFjT1MgZXF1aXZhbGVudC4gVGhpcyB0YWJsZVxuXHQvLyBpcyBub3QgZXhhY3RseSBhIHN1cGVyIGNoZWFwIGRhdGEgc3RydWN0dXJlLCBidXQgd2UgZG8gbm90IGNhcmUgYmVjYXVzZVxuXHQvLyBlbmNvZGluZyBNYWNpbnRvc2ggc3RyaW5ncyBpcyBvbmx5IHJhcmVseSBuZWVkZWQgaW4gdHlwaWNhbCBhcHBsaWNhdGlvbnMuXG5cdHZhciBtYWNFbmNvZGluZ1RhYmxlQ2FjaGUgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXcgV2Vha01hcCgpO1xuXHR2YXIgbWFjRW5jb2RpbmdDYWNoZUtleXM7XG5cdHZhciBnZXRNYWNFbmNvZGluZ1RhYmxlID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG5cdCAgICAvLyBTaW5jZSB3ZSB1c2UgZW5jb2RpbmcgYXMgYSBjYWNoZSBrZXkgZm9yIFdlYWtNYXAsIGl0IGhhcyB0byBiZVxuXHQgICAgLy8gYSBTdHJpbmcgb2JqZWN0IGFuZCBub3QgYSBsaXRlcmFsLiBBbmQgYXQgbGVhc3Qgb24gTm9kZUpTIDIuMTAuMSxcblx0ICAgIC8vIFdlYWtNYXAgcmVxdWlyZXMgdGhhdCB0aGUgc2FtZSBTdHJpbmcgaW5zdGFuY2UgaXMgcGFzc2VkIGZvciBjYWNoZSBoaXRzLlxuXHQgICAgaWYgKCFtYWNFbmNvZGluZ0NhY2hlS2V5cykge1xuXHQgICAgICAgIG1hY0VuY29kaW5nQ2FjaGVLZXlzID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgZSBpbiBlaWdodEJpdE1hY0VuY29kaW5ncykge1xuXHQgICAgICAgICAgICAvKmpzaGludCAtVzA1MyAqLyAgLy8gU3VwcHJlc3MgXCJEbyBub3QgdXNlIFN0cmluZyBhcyBhIGNvbnN0cnVjdG9yLlwiXG5cdCAgICAgICAgICAgIG1hY0VuY29kaW5nQ2FjaGVLZXlzW2VdID0gbmV3IFN0cmluZyhlKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBjYWNoZUtleSA9IG1hY0VuY29kaW5nQ2FjaGVLZXlzW2VuY29kaW5nXTtcblx0ICAgIGlmIChjYWNoZUtleSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgIH1cblxuXHQgICAgLy8gV2UgY2FuJ3QgZG8gXCJpZiAoY2FjaGUuaGFzKGtleSkpIHtyZXR1cm4gY2FjaGUuZ2V0KGtleSl9XCIgaGVyZTpcblx0ICAgIC8vIHNpbmNlIGdhcmJhZ2UgY29sbGVjdGlvbiBtYXkgcnVuIGF0IGFueSB0aW1lLCBpdCBjb3VsZCBhbHNvIGtpY2sgaW5cblx0ICAgIC8vIGJldHdlZW4gdGhlIGNhbGxzIHRvIGNhY2hlLmhhcygpIGFuZCBjYWNoZS5nZXQoKS4gSW4gdGhhdCBjYXNlLFxuXHQgICAgLy8gd2Ugd291bGQgcmV0dXJuICd1bmRlZmluZWQnIGV2ZW4gdGhvdWdoIHdlIGRvIHN1cHBvcnQgdGhlIGVuY29kaW5nLlxuXHQgICAgaWYgKG1hY0VuY29kaW5nVGFibGVDYWNoZSkge1xuXHQgICAgICAgIHZhciBjYWNoZWRUYWJsZSA9IG1hY0VuY29kaW5nVGFibGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xuXHQgICAgICAgIGlmIChjYWNoZWRUYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjYWNoZWRUYWJsZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBkZWNvZGluZ1RhYmxlID0gZWlnaHRCaXRNYWNFbmNvZGluZ3NbZW5jb2RpbmddO1xuXHQgICAgaWYgKGRlY29kaW5nVGFibGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICB9XG5cblx0ICAgIHZhciBlbmNvZGluZ1RhYmxlID0ge307XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY29kaW5nVGFibGUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBlbmNvZGluZ1RhYmxlW2RlY29kaW5nVGFibGUuY2hhckNvZGVBdChpKV0gPSBpICsgMHg4MDtcblx0ICAgIH1cblxuXHQgICAgaWYgKG1hY0VuY29kaW5nVGFibGVDYWNoZSkge1xuXHQgICAgICAgIG1hY0VuY29kaW5nVGFibGVDYWNoZS5zZXQoY2FjaGVLZXksIGVuY29kaW5nVGFibGUpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZW5jb2RpbmdUYWJsZTtcblx0fTtcblxuXHQvKipcblx0ICogRW5jb2RlcyBhbiBvbGQtc3R5bGUgTWFjaW50b3NoIHN0cmluZy4gUmV0dXJucyBhIGJ5dGUgYXJyYXkgdXBvbiBzdWNjZXNzLlxuXHQgKiBJZiB0aGUgcmVxdWVzdGVkIGVuY29kaW5nIGlzIHVuc3VwcG9ydGVkLCBvciBpZiB0aGUgaW5wdXQgc3RyaW5nIGNvbnRhaW5zXG5cdCAqIGEgY2hhcmFjdGVyIHRoYXQgY2Fubm90IGJlIGV4cHJlc3NlZCBpbiB0aGUgZW5jb2RpbmcsIHRoZSBmdW5jdGlvbiByZXR1cm5zXG5cdCAqICd1bmRlZmluZWQnLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuTUFDU1RSSU5HID0gZnVuY3Rpb24oc3RyLCBlbmNvZGluZykge1xuXHQgICAgdmFyIHRhYmxlID0gZ2V0TWFjRW5jb2RpbmdUYWJsZShlbmNvZGluZyk7XG5cdCAgICBpZiAodGFibGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICB9XG5cblx0ICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuXHQgICAgICAgIC8vIEluIGFsbCBlaWdodC1iaXQgTWFjIGVuY29kaW5ncywgdGhlIGNoYXJhY3RlcnMgMHgwMC4uMHg3RiBhcmVcblx0ICAgICAgICAvLyBtYXBwZWQgdG8gVSswMDAwLi5VKzAwN0Y7IHdlIG9ubHkgbmVlZCB0byBsb29rIHVwIHRoZSBvdGhlcnMuXG5cdCAgICAgICAgaWYgKGMgPj0gMHg4MCkge1xuXHQgICAgICAgICAgICBjID0gdGFibGVbY107XG5cdCAgICAgICAgICAgIGlmIChjID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIHN0ciBjb250YWlucyBhIFVuaWNvZGUgY2hhcmFjdGVyIHRoYXQgY2Fubm90IGJlIGVuY29kZWRcblx0ICAgICAgICAgICAgICAgIC8vIGluIHRoZSByZXF1ZXN0ZWQgZW5jb2RpbmcuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdFtpXSA9IGM7XG5cdCAgICAgICAgLy8gcmVzdWx0LnB1c2goYyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuTUFDU1RSSU5HID0gZnVuY3Rpb24oc3RyLCBlbmNvZGluZykge1xuXHQgICAgdmFyIGIgPSBlbmNvZGUuTUFDU1RSSU5HKHN0ciwgZW5jb2RpbmcpO1xuXHQgICAgaWYgKGIgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiBiLmxlbmd0aDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICB9XG5cdH07XG5cblx0Ly8gSGVscGVyIGZvciBlbmNvZGUuVkFSREVMVEFTXG5cdGZ1bmN0aW9uIGlzQnl0ZUVuY29kYWJsZSh2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHZhbHVlID49IC0xMjggJiYgdmFsdWUgPD0gMTI3O1xuXHR9XG5cblx0Ly8gSGVscGVyIGZvciBlbmNvZGUuVkFSREVMVEFTXG5cdGZ1bmN0aW9uIGVuY29kZVZhckRlbHRhUnVuQXNaZXJvZXMoZGVsdGFzLCBwb3MsIHJlc3VsdCkge1xuXHQgICAgdmFyIHJ1bkxlbmd0aCA9IDA7XG5cdCAgICB2YXIgbnVtRGVsdGFzID0gZGVsdGFzLmxlbmd0aDtcblx0ICAgIHdoaWxlIChwb3MgPCBudW1EZWx0YXMgJiYgcnVuTGVuZ3RoIDwgNjQgJiYgZGVsdGFzW3Bvc10gPT09IDApIHtcblx0ICAgICAgICArK3Bvcztcblx0ICAgICAgICArK3J1bkxlbmd0aDtcblx0ICAgIH1cblx0ICAgIHJlc3VsdC5wdXNoKDB4ODAgfCAocnVuTGVuZ3RoIC0gMSkpO1xuXHQgICAgcmV0dXJuIHBvcztcblx0fVxuXG5cdC8vIEhlbHBlciBmb3IgZW5jb2RlLlZBUkRFTFRBU1xuXHRmdW5jdGlvbiBlbmNvZGVWYXJEZWx0YVJ1bkFzQnl0ZXMoZGVsdGFzLCBvZmZzZXQsIHJlc3VsdCkge1xuXHQgICAgdmFyIHJ1bkxlbmd0aCA9IDA7XG5cdCAgICB2YXIgbnVtRGVsdGFzID0gZGVsdGFzLmxlbmd0aDtcblx0ICAgIHZhciBwb3MgPSBvZmZzZXQ7XG5cdCAgICB3aGlsZSAocG9zIDwgbnVtRGVsdGFzICYmIHJ1bkxlbmd0aCA8IDY0KSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gZGVsdGFzW3Bvc107XG5cdCAgICAgICAgaWYgKCFpc0J5dGVFbmNvZGFibGUodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFdpdGhpbiBhIGJ5dGUtZW5jb2RlZCBydW4gb2YgZGVsdGFzLCBhIHNpbmdsZSB6ZXJvIGlzIGJlc3Rcblx0ICAgICAgICAvLyBzdG9yZWQgbGl0ZXJhbGx5IGFzIDB4MDAgdmFsdWUuIEhvd2V2ZXIsIGlmIHdlIGhhdmUgdHdvIG9yXG5cdCAgICAgICAgLy8gbW9yZSB6ZXJvZXMgaW4gYSBzZXF1ZW5jZSwgaXQgaXMgYmV0dGVyIHRvIHN0YXJ0IGEgbmV3IHJ1bi5cblx0ICAgICAgICAvLyBGb3JlIGV4YW1wbGUsIHRoZSBzZXF1ZW5jZSBvZiBkZWx0YXMgWzE1LCAxNSwgMCwgMTUsIDE1XVxuXHQgICAgICAgIC8vIGJlY29tZXMgNiBieXRlcyAoMDQgMEYgMEYgMDAgMEYgMEYpIHdoZW4gc3RvcmluZyB0aGUgemVyb1xuXHQgICAgICAgIC8vIHdpdGhpbiB0aGUgY3VycmVudCBydW4sIGJ1dCA3IGJ5dGVzICgwMSAwRiAwRiA4MCAwMSAwRiAwRilcblx0ICAgICAgICAvLyB3aGVuIHN0YXJ0aW5nIGEgbmV3IHJ1bi5cblx0ICAgICAgICBpZiAodmFsdWUgPT09IDAgJiYgcG9zICsgMSA8IG51bURlbHRhcyAmJiBkZWx0YXNbcG9zICsgMV0gPT09IDApIHtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgKytwb3M7XG5cdCAgICAgICAgKytydW5MZW5ndGg7XG5cdCAgICB9XG5cdCAgICByZXN1bHQucHVzaChydW5MZW5ndGggLSAxKTtcblx0ICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBwb3M7ICsraSkge1xuXHQgICAgICAgIHJlc3VsdC5wdXNoKChkZWx0YXNbaV0gKyAyNTYpICYgMHhmZik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcG9zO1xuXHR9XG5cblx0Ly8gSGVscGVyIGZvciBlbmNvZGUuVkFSREVMVEFTXG5cdGZ1bmN0aW9uIGVuY29kZVZhckRlbHRhUnVuQXNXb3JkcyhkZWx0YXMsIG9mZnNldCwgcmVzdWx0KSB7XG5cdCAgICB2YXIgcnVuTGVuZ3RoID0gMDtcblx0ICAgIHZhciBudW1EZWx0YXMgPSBkZWx0YXMubGVuZ3RoO1xuXHQgICAgdmFyIHBvcyA9IG9mZnNldDtcblx0ICAgIHdoaWxlIChwb3MgPCBudW1EZWx0YXMgJiYgcnVuTGVuZ3RoIDwgNjQpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBkZWx0YXNbcG9zXTtcblxuXHQgICAgICAgIC8vIFdpdGhpbiBhIHdvcmQtZW5jb2RlZCBydW4gb2YgZGVsdGFzLCBpdCBpcyBlYXNpZXN0IHRvIHN0YXJ0XG5cdCAgICAgICAgLy8gYSBuZXcgcnVuICh3aXRoIGEgZGlmZmVyZW50IGVuY29kaW5nKSB3aGVuZXZlciB3ZSBlbmNvdW50ZXJcblx0ICAgICAgICAvLyBhIHplcm8gdmFsdWUuIEZvciBleGFtcGxlLCB0aGUgc2VxdWVuY2UgWzB4NjY2NiwgMCwgMHg3Nzc3XVxuXHQgICAgICAgIC8vIG5lZWRzIDcgYnl0ZXMgd2hlbiBzdG9yaW5nIHRoZSB6ZXJvIGluc2lkZSB0aGUgY3VycmVudCBydW5cblx0ICAgICAgICAvLyAoNDIgNjYgNjYgMDAgMDAgNzcgNzcpLCBhbmQgZXF1YWxseSA3IGJ5dGVzIHdoZW4gc3RhcnRpbmcgYVxuXHQgICAgICAgIC8vIG5ldyBydW4gKDQwIDY2IDY2IDgwIDQwIDc3IDc3KS5cblx0ICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gV2l0aGluIGEgd29yZC1lbmNvZGVkIHJ1biBvZiBkZWx0YXMsIGEgc2luZ2xlIHZhbHVlIGluIHRoZVxuXHQgICAgICAgIC8vIHJhbmdlICgtMTI4Li4xMjcpIHNob3VsZCBiZSBlbmNvZGVkIHdpdGhpbiB0aGUgY3VycmVudCBydW5cblx0ICAgICAgICAvLyBiZWNhdXNlIGl0IGlzIG1vcmUgY29tcGFjdC4gRm9yIGV4YW1wbGUsIHRoZSBzZXF1ZW5jZVxuXHQgICAgICAgIC8vIFsweDY2NjYsIDIsIDB4Nzc3N10gYmVjb21lcyA3IGJ5dGVzIHdoZW4gc3RvcmluZyB0aGUgdmFsdWVcblx0ICAgICAgICAvLyBsaXRlcmFsbHkgKDQyIDY2IDY2IDAwIDAyIDc3IDc3KSwgYnV0IDggYnl0ZXMgd2hlbiBzdGFydGluZ1xuXHQgICAgICAgIC8vIGEgbmV3IHJ1biAoNDAgNjYgNjYgMDAgMDIgNDAgNzcgNzcpLlxuXHQgICAgICAgIGlmIChpc0J5dGVFbmNvZGFibGUodmFsdWUpICYmIHBvcyArIDEgPCBudW1EZWx0YXMgJiYgaXNCeXRlRW5jb2RhYmxlKGRlbHRhc1twb3MgKyAxXSkpIHtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgKytwb3M7XG5cdCAgICAgICAgKytydW5MZW5ndGg7XG5cdCAgICB9XG5cdCAgICByZXN1bHQucHVzaCgweDQwIHwgKHJ1bkxlbmd0aCAtIDEpKTtcblx0ICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBwb3M7ICsraSkge1xuXHQgICAgICAgIHZhciB2YWwgPSBkZWx0YXNbaV07XG5cdCAgICAgICAgcmVzdWx0LnB1c2goKCh2YWwgKyAweDEwMDAwKSA+PiA4KSAmIDB4ZmYsICh2YWwgKyAweDEwMCkgJiAweGZmKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBwb3M7XG5cdH1cblxuXHQvKipcblx0ICogRW5jb2RlIGEgbGlzdCBvZiB2YXJpYXRpb24gYWRqdXN0bWVudCBkZWx0YXMuXG5cdCAqXG5cdCAqIFZhcmlhdGlvbiBhZGp1c3RtZW50IGRlbHRhcyBhcmUgdXNlZCBpbiDigJhndmFy4oCZIGFuZCDigJhjdmFy4oCZIHRhYmxlcy5cblx0ICogVGhleSBpbmRpY2F0ZSBob3cgcG9pbnRzIChpbiDigJhndmFy4oCZKSBvciB2YWx1ZXMgKGluIOKAmGN2YXLigJkpIGdldCBhZGp1c3RlZFxuXHQgKiB3aGVuIGdlbmVyYXRpbmcgaW5zdGFuY2VzIG9mIHZhcmlhdGlvbiBmb250cy5cblx0ICpcblx0ICogQHNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL2d2YXIuaHRtXG5cdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvbnRzL1RydWVUeXBlLVJlZmVyZW5jZS1NYW51YWwvUk0wNi9DaGFwNmd2YXIuaHRtbFxuXHQgKiBAcGFyYW0ge0FycmF5fVxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdGVuY29kZS5WQVJERUxUQVMgPSBmdW5jdGlvbihkZWx0YXMpIHtcblx0ICAgIHZhciBwb3MgPSAwO1xuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgd2hpbGUgKHBvcyA8IGRlbHRhcy5sZW5ndGgpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBkZWx0YXNbcG9zXTtcblx0ICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcblx0ICAgICAgICAgICAgcG9zID0gZW5jb2RlVmFyRGVsdGFSdW5Bc1plcm9lcyhkZWx0YXMsIHBvcywgcmVzdWx0KTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID49IC0xMjggJiYgdmFsdWUgPD0gMTI3KSB7XG5cdCAgICAgICAgICAgIHBvcyA9IGVuY29kZVZhckRlbHRhUnVuQXNCeXRlcyhkZWx0YXMsIHBvcywgcmVzdWx0KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBwb3MgPSBlbmNvZGVWYXJEZWx0YVJ1bkFzV29yZHMoZGVsdGFzLCBwb3MsIHJlc3VsdCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvLyBDb252ZXJ0IGEgbGlzdCBvZiB2YWx1ZXMgdG8gYSBDRkYgSU5ERVggc3RydWN0dXJlLlxuXHQvLyBUaGUgdmFsdWVzIHNob3VsZCBiZSBvYmplY3RzIGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZS5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGxcblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLklOREVYID0gZnVuY3Rpb24obCkge1xuXHQgICAgLy92YXIgb2Zmc2V0LCBvZmZzZXRzLCBvZmZzZXRFbmNvZGVyLCBlbmNvZGVkT2Zmc2V0cywgZW5jb2RlZE9mZnNldCwgZGF0YSxcblx0ICAgIC8vICAgIGksIHY7XG5cdCAgICAvLyBCZWNhdXNlIHdlIGhhdmUgdG8ga25vdyB3aGljaCBkYXRhIHR5cGUgdG8gdXNlIHRvIGVuY29kZSB0aGUgb2Zmc2V0cyxcblx0ICAgIC8vIHdlIGhhdmUgdG8gZ28gdGhyb3VnaCB0aGUgdmFsdWVzIHR3aWNlOiBvbmNlIHRvIGVuY29kZSB0aGUgZGF0YSBhbmRcblx0ICAgIC8vIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0cywgdGhlbiBhZ2FpbiB0byBlbmNvZGUgdGhlIG9mZnNldHMgdXNpbmcgdGhlIGZpdHRpbmcgZGF0YSB0eXBlLlxuXHQgICAgdmFyIG9mZnNldCA9IDE7IC8vIEZpcnN0IG9mZnNldCBpcyBhbHdheXMgMS5cblx0ICAgIHZhciBvZmZzZXRzID0gW29mZnNldF07XG5cdCAgICB2YXIgZGF0YSA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIHYgPSBlbmNvZGUuT0JKRUNUKGxbaV0pO1xuXHQgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRhdGEsIHYpO1xuXHQgICAgICAgIG9mZnNldCArPSB2Lmxlbmd0aDtcblx0ICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIFswLCAwXTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGVuY29kZWRPZmZzZXRzID0gW107XG5cdCAgICB2YXIgb2ZmU2l6ZSA9ICgxICsgTWF0aC5mbG9vcihNYXRoLmxvZyhvZmZzZXQpIC8gTWF0aC5sb2coMikpIC8gOCkgfCAwO1xuXHQgICAgdmFyIG9mZnNldEVuY29kZXIgPSBbdW5kZWZpbmVkLCBlbmNvZGUuQllURSwgZW5jb2RlLlVTSE9SVCwgZW5jb2RlLlVJTlQyNCwgZW5jb2RlLlVMT05HXVtvZmZTaXplXTtcblx0ICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9mZnNldHMubGVuZ3RoOyBpJDEgKz0gMSkge1xuXHQgICAgICAgIHZhciBlbmNvZGVkT2Zmc2V0ID0gb2Zmc2V0RW5jb2RlcihvZmZzZXRzW2kkMV0pO1xuXHQgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVuY29kZWRPZmZzZXRzLCBlbmNvZGVkT2Zmc2V0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQoZW5jb2RlLkNhcmQxNihsLmxlbmd0aCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS5PZmZTaXplKG9mZlNpemUpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkT2Zmc2V0cyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QXJyYXl9XG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuSU5ERVggPSBmdW5jdGlvbih2KSB7XG5cdCAgICByZXR1cm4gZW5jb2RlLklOREVYKHYpLmxlbmd0aDtcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydCBhbiBvYmplY3QgdG8gYSBDRkYgRElDVCBzdHJ1Y3R1cmUuXG5cdCAqIFRoZSBrZXlzIHNob3VsZCBiZSBudW1lcmljLlxuXHQgKiBUaGUgdmFsdWVzIHNob3VsZCBiZSBvYmplY3RzIGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLkRJQ1QgPSBmdW5jdGlvbihtKSB7XG5cdCAgICB2YXIgZCA9IFtdO1xuXHQgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhtKTtcblx0ICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIC8vIE9iamVjdC5rZXlzKCkgcmV0dXJuIHN0cmluZyBrZXlzLCBidXQgb3VyIGtleXMgYXJlIGFsd2F5cyBudW1lcmljLlxuXHQgICAgICAgIHZhciBrID0gcGFyc2VJbnQoa2V5c1tpXSwgMCk7XG5cdCAgICAgICAgdmFyIHYgPSBtW2tdO1xuXHQgICAgICAgIC8vIFZhbHVlIGNvbWVzIGJlZm9yZSB0aGUga2V5LlxuXHQgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuT1BFUkFORCh2LnZhbHVlLCB2LnR5cGUpKTtcblx0ICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk9QRVJBVE9SKGspKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fVxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKi9cblx0c2l6ZU9mLkRJQ1QgPSBmdW5jdGlvbihtKSB7XG5cdCAgICByZXR1cm4gZW5jb2RlLkRJQ1QobSkubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLk9QRVJBVE9SID0gZnVuY3Rpb24odikge1xuXHQgICAgaWYgKHYgPCAxMjAwKSB7XG5cdCAgICAgICAgcmV0dXJuIFt2XTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIFsxMiwgdiAtIDEyMDBdO1xuXHQgICAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0FycmF5fSB2XG5cdCAqIEBwYXJhbSB7c3RyaW5nfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuT1BFUkFORCA9IGZ1bmN0aW9uKHYsIHR5cGUpIHtcblx0ICAgIHZhciBkID0gW107XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgICAgICBjaGVjay5hcmd1bWVudCh2Lmxlbmd0aCA9PT0gdHlwZS5sZW5ndGgsICdOb3QgZW5vdWdoIGFyZ3VtZW50cyBnaXZlbiBmb3IgdHlwZScgKyB0eXBlKTtcblx0ICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQU5EKHZbaV0sIHR5cGVbaV0pKTtcblx0ICAgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmICh0eXBlID09PSAnU0lEJykge1xuXHQgICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUih2KSk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2Zmc2V0Jykge1xuXHQgICAgICAgICAgICAvLyBXZSBtYWtlIGl0IGVhc3kgZm9yIG91cnNlbHZlcyBhbmQgYWx3YXlzIGVuY29kZSBvZmZzZXRzIGFzXG5cdCAgICAgICAgICAgIC8vIDQgYnl0ZXMuIFRoaXMgbWFrZXMgb2Zmc2V0IGNhbGN1bGF0aW9uIGZvciB0aGUgdG9wIGRpY3QgZWFzaWVyLlxuXHQgICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUjMyKHYpKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdCAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSKHYpKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyZWFsJykge1xuXHQgICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLlJFQUwodikpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBvcGVyYW5kIHR5cGUgJyArIHR5cGUpO1xuXHQgICAgICAgICAgICAvLyBGSVhNRSBBZGQgc3VwcG9ydCBmb3IgYm9vbGVhbnNcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBkO1xuXHR9O1xuXG5cdGVuY29kZS5PUCA9IGVuY29kZS5CWVRFO1xuXHRzaXplT2YuT1AgPSBzaXplT2YuQllURTtcblxuXHQvLyBtZW1vaXplIGNoYXJzdHJpbmcgZW5jb2RpbmcgdXNpbmcgV2Vha01hcCBpZiBhdmFpbGFibGVcblx0dmFyIHdtbSA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIG5ldyBXZWFrTWFwKCk7XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYSBsaXN0IG9mIENoYXJTdHJpbmcgb3BlcmF0aW9ucyB0byBieXRlcy5cblx0ICogQHBhcmFtIHtBcnJheX1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0ZW5jb2RlLkNIQVJTVFJJTkcgPSBmdW5jdGlvbihvcHMpIHtcblx0ICAgIC8vIFNlZSBlbmNvZGUuTUFDU1RSSU5HIGZvciB3aHkgd2UgZG9uJ3QgZG8gXCJpZiAod21tICYmIHdtbS5oYXMob3BzKSlcIi5cblx0ICAgIGlmICh3bW0pIHtcblx0ICAgICAgICB2YXIgY2FjaGVkVmFsdWUgPSB3bW0uZ2V0KG9wcyk7XG5cdCAgICAgICAgaWYgKGNhY2hlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGQgPSBbXTtcblx0ICAgIHZhciBsZW5ndGggPSBvcHMubGVuZ3RoO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIG9wID0gb3BzW2ldO1xuXHQgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGVbb3AudHlwZV0ob3AudmFsdWUpKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHdtbSkge1xuXHQgICAgICAgIHdtbS5zZXQob3BzLCBkKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7QXJyYXl9XG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuQ0hBUlNUUklORyA9IGZ1bmN0aW9uKG9wcykge1xuXHQgICAgcmV0dXJuIGVuY29kZS5DSEFSU1RSSU5HKG9wcykubGVuZ3RoO1xuXHR9O1xuXG5cdC8vIFV0aWxpdHkgZnVuY3Rpb25zIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZSB0byBieXRlcy5cblx0ICogQHBhcmFtIHtPYmplY3R9XG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGVuY29kZS5PQkpFQ1QgPSBmdW5jdGlvbih2KSB7XG5cdCAgICB2YXIgZW5jb2RpbmdGdW5jdGlvbiA9IGVuY29kZVt2LnR5cGVdO1xuXHQgICAgY2hlY2suYXJndW1lbnQoZW5jb2RpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gZW5jb2RpbmcgZnVuY3Rpb24gZm9yIHR5cGUgJyArIHYudHlwZSk7XG5cdCAgICByZXR1cm4gZW5jb2RpbmdGdW5jdGlvbih2LnZhbHVlKTtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtPYmplY3R9XG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuT0JKRUNUID0gZnVuY3Rpb24odikge1xuXHQgICAgdmFyIHNpemVPZkZ1bmN0aW9uID0gc2l6ZU9mW3YudHlwZV07XG5cdCAgICBjaGVjay5hcmd1bWVudChzaXplT2ZGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gc2l6ZU9mIGZ1bmN0aW9uIGZvciB0eXBlICcgKyB2LnR5cGUpO1xuXHQgICAgcmV0dXJuIHNpemVPZkZ1bmN0aW9uKHYudmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgdGFibGUgb2JqZWN0IHRvIGJ5dGVzLlxuXHQgKiBBIHRhYmxlIGNvbnRhaW5zIGEgbGlzdCBvZiBmaWVsZHMgY29udGFpbmluZyB0aGUgbWV0YWRhdGEgKG5hbWUsIHR5cGUgYW5kIGRlZmF1bHQgdmFsdWUpLlxuXHQgKiBUaGUgdGFibGUgaXRzZWxmIGhhcyB0aGUgZmllbGQgdmFsdWVzIHNldCBhcyBhdHRyaWJ1dGVzLlxuXHQgKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRlbmNvZGUuVEFCTEUgPSBmdW5jdGlvbih0YWJsZSkge1xuXHQgICAgdmFyIGQgPSBbXTtcblx0ICAgIHZhciBsZW5ndGggPSB0YWJsZS5maWVsZHMubGVuZ3RoO1xuXHQgICAgdmFyIHN1YnRhYmxlcyA9IFtdO1xuXHQgICAgdmFyIHN1YnRhYmxlT2Zmc2V0cyA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGZpZWxkID0gdGFibGUuZmllbGRzW2ldO1xuXHQgICAgICAgIHZhciBlbmNvZGluZ0Z1bmN0aW9uID0gZW5jb2RlW2ZpZWxkLnR5cGVdO1xuXHQgICAgICAgIGNoZWNrLmFyZ3VtZW50KGVuY29kaW5nRnVuY3Rpb24gIT09IHVuZGVmaW5lZCwgJ05vIGVuY29kaW5nIGZ1bmN0aW9uIGZvciBmaWVsZCB0eXBlICcgKyBmaWVsZC50eXBlICsgJyAoJyArIGZpZWxkLm5hbWUgKyAnKScpO1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRhYmxlW2ZpZWxkLm5hbWVdO1xuXHQgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGJ5dGVzID0gZW5jb2RpbmdGdW5jdGlvbih2YWx1ZSk7XG5cblx0ICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ1RBQkxFJykge1xuXHQgICAgICAgICAgICBzdWJ0YWJsZU9mZnNldHMucHVzaChkLmxlbmd0aCk7XG5cdCAgICAgICAgICAgIGQgPSBkLmNvbmNhdChbMCwgMF0pO1xuXHQgICAgICAgICAgICBzdWJ0YWJsZXMucHVzaChieXRlcyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZCA9IGQuY29uY2F0KGJ5dGVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkkMSArPSAxKSB7XG5cdCAgICAgICAgdmFyIG8gPSBzdWJ0YWJsZU9mZnNldHNbaSQxXTtcblx0ICAgICAgICB2YXIgb2Zmc2V0ID0gZC5sZW5ndGg7XG5cdCAgICAgICAgY2hlY2suYXJndW1lbnQob2Zmc2V0IDwgNjU1MzYsICdUYWJsZSAnICsgdGFibGUudGFibGVOYW1lICsgJyB0b28gYmlnLicpO1xuXHQgICAgICAgIGRbb10gPSBvZmZzZXQgPj4gODtcblx0ICAgICAgICBkW28gKyAxXSA9IG9mZnNldCAmIDB4ZmY7XG5cdCAgICAgICAgZCA9IGQuY29uY2F0KHN1YnRhYmxlc1tpJDFdKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqL1xuXHRzaXplT2YuVEFCTEUgPSBmdW5jdGlvbih0YWJsZSkge1xuXHQgICAgdmFyIG51bUJ5dGVzID0gMDtcblx0ICAgIHZhciBsZW5ndGggPSB0YWJsZS5maWVsZHMubGVuZ3RoO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGZpZWxkID0gdGFibGUuZmllbGRzW2ldO1xuXHQgICAgICAgIHZhciBzaXplT2ZGdW5jdGlvbiA9IHNpemVPZltmaWVsZC50eXBlXTtcblx0ICAgICAgICBjaGVjay5hcmd1bWVudChzaXplT2ZGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gc2l6ZU9mIGZ1bmN0aW9uIGZvciBmaWVsZCB0eXBlICcgKyBmaWVsZC50eXBlICsgJyAoJyArIGZpZWxkLm5hbWUgKyAnKScpO1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRhYmxlW2ZpZWxkLm5hbWVdO1xuXHQgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbnVtQnl0ZXMgKz0gc2l6ZU9mRnVuY3Rpb24odmFsdWUpO1xuXG5cdCAgICAgICAgLy8gU3VidGFibGVzIHRha2UgMiBtb3JlIGJ5dGVzIGZvciBvZmZzZXRzLlxuXHQgICAgICAgIGlmIChmaWVsZC50eXBlID09PSAnVEFCTEUnKSB7XG5cdCAgICAgICAgICAgIG51bUJ5dGVzICs9IDI7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVtQnl0ZXM7XG5cdH07XG5cblx0ZW5jb2RlLlJFQ09SRCA9IGVuY29kZS5UQUJMRTtcblx0c2l6ZU9mLlJFQ09SRCA9IHNpemVPZi5UQUJMRTtcblxuXHQvLyBNZXJnZSBpbiBhIGxpc3Qgb2YgYnl0ZXMuXG5cdGVuY29kZS5MSVRFUkFMID0gZnVuY3Rpb24odikge1xuXHQgICAgcmV0dXJuIHY7XG5cdH07XG5cblx0c2l6ZU9mLkxJVEVSQUwgPSBmdW5jdGlvbih2KSB7XG5cdCAgICByZXR1cm4gdi5sZW5ndGg7XG5cdH07XG5cblx0Ly8gVGFibGUgbWV0YWRhdGFcblxuXHQvKipcblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuVGFibGVcblx0ICogQGNsYXNzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWVcblx0ICogQHBhcmFtIHtBcnJheX0gZmllbGRzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVGFibGUodGFibGVOYW1lLCBmaWVsZHMsIG9wdGlvbnMpIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcblx0ICAgICAgICB0aGlzJDFbZmllbGQubmFtZV0gPSBmaWVsZC52YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy50YWJsZU5hbWUgPSB0YWJsZU5hbWU7XG5cdCAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcblx0ICAgIGlmIChvcHRpb25zKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcblx0ICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBvcHRpb25LZXlzLmxlbmd0aDsgaSQxICs9IDEpIHtcblx0ICAgICAgICAgICAgdmFyIGsgPSBvcHRpb25LZXlzW2kkMV07XG5cdCAgICAgICAgICAgIHZhciB2ID0gb3B0aW9uc1trXTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMkMVtrXSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzJDFba10gPSB2O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgdGhlIHRhYmxlIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGJ5dGVzXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKi9cblx0VGFibGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIGVuY29kZS5UQUJMRSh0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBzaXplIG9mIHRoZSB0YWJsZS5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0VGFibGUucHJvdG90eXBlLnNpemVPZiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHNpemVPZi5UQUJMRSh0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIHVzaG9ydExpc3QoaXRlbU5hbWUsIGxpc3QsIGNvdW50KSB7XG5cdCAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGNvdW50ID0gbGlzdC5sZW5ndGg7XG5cdCAgICB9XG5cdCAgICB2YXIgZmllbGRzID0gbmV3IEFycmF5KGxpc3QubGVuZ3RoICsgMSk7XG5cdCAgICBmaWVsZHNbMF0gPSB7bmFtZTogaXRlbU5hbWUgKyAnQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGNvdW50fTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGZpZWxkc1tpICsgMV0gPSB7bmFtZTogaXRlbU5hbWUgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxpc3RbaV19O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZpZWxkcztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gdGFibGVMaXN0KGl0ZW1OYW1lLCByZWNvcmRzLCBpdGVtQ2FsbGJhY2spIHtcblx0ICAgIHZhciBjb3VudCA9IHJlY29yZHMubGVuZ3RoO1xuXHQgICAgdmFyIGZpZWxkcyA9IG5ldyBBcnJheShjb3VudCArIDEpO1xuXHQgICAgZmllbGRzWzBdID0ge25hbWU6IGl0ZW1OYW1lICsgJ0NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBjb3VudH07XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgICBmaWVsZHNbaSArIDFdID0ge25hbWU6IGl0ZW1OYW1lICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IGl0ZW1DYWxsYmFjayhyZWNvcmRzW2ldLCBpKX07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmllbGRzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiByZWNvcmRMaXN0KGl0ZW1OYW1lLCByZWNvcmRzLCBpdGVtQ2FsbGJhY2spIHtcblx0ICAgIHZhciBjb3VudCA9IHJlY29yZHMubGVuZ3RoO1xuXHQgICAgdmFyIGZpZWxkcyA9IFtdO1xuXHQgICAgZmllbGRzWzBdID0ge25hbWU6IGl0ZW1OYW1lICsgJ0NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBjb3VudH07XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgICBmaWVsZHMgPSBmaWVsZHMuY29uY2F0KGl0ZW1DYWxsYmFjayhyZWNvcmRzW2ldLCBpKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmllbGRzO1xuXHR9XG5cblx0Ly8gQ29tbW9uIExheW91dCBUYWJsZXNcblxuXHQvKipcblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuQ292ZXJhZ2Vcblx0ICogQGNsYXNzXG5cdCAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAZXh0ZW5kcyBvcGVudHlwZS5UYWJsZVxuXHQgKi9cblx0ZnVuY3Rpb24gQ292ZXJhZ2UoY292ZXJhZ2VUYWJsZSkge1xuXHQgICAgaWYgKGNvdmVyYWdlVGFibGUuZm9ybWF0ID09PSAxKSB7XG5cdCAgICAgICAgVGFibGUuY2FsbCh0aGlzLCAnY292ZXJhZ2VUYWJsZScsXG5cdCAgICAgICAgICAgIFt7bmFtZTogJ2NvdmVyYWdlRm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfV1cblx0ICAgICAgICAgICAgLmNvbmNhdCh1c2hvcnRMaXN0KCdnbHlwaCcsIGNvdmVyYWdlVGFibGUuZ2x5cGhzKSlcblx0ICAgICAgICApO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBjaGVjay5hc3NlcnQoZmFsc2UsICdDYW5cXCd0IGNyZWF0ZSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgMiB5ZXQuJyk7XG5cdCAgICB9XG5cdH1cblx0Q292ZXJhZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuXHRDb3ZlcmFnZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb3ZlcmFnZTtcblxuXHRmdW5jdGlvbiBTY3JpcHRMaXN0KHNjcmlwdExpc3RUYWJsZSkge1xuXHQgICAgVGFibGUuY2FsbCh0aGlzLCAnc2NyaXB0TGlzdFRhYmxlJyxcblx0ICAgICAgICByZWNvcmRMaXN0KCdzY3JpcHRSZWNvcmQnLCBzY3JpcHRMaXN0VGFibGUsIGZ1bmN0aW9uKHNjcmlwdFJlY29yZCwgaSkge1xuXHQgICAgICAgICAgICB2YXIgc2NyaXB0ID0gc2NyaXB0UmVjb3JkLnNjcmlwdDtcblx0ICAgICAgICAgICAgdmFyIGRlZmF1bHRMYW5nU3lzID0gc2NyaXB0LmRlZmF1bHRMYW5nU3lzO1xuXHQgICAgICAgICAgICBjaGVjay5hc3NlcnQoISFkZWZhdWx0TGFuZ1N5cywgJ1VuYWJsZSB0byB3cml0ZSBHU1VCOiBzY3JpcHQgJyArIHNjcmlwdFJlY29yZC50YWcgKyAnIGhhcyBubyBkZWZhdWx0IGxhbmd1YWdlIHN5c3RlbS4nKTtcblx0ICAgICAgICAgICAgcmV0dXJuIFtcblx0ICAgICAgICAgICAgICAgIHtuYW1lOiAnc2NyaXB0VGFnJyArIGksIHR5cGU6ICdUQUcnLCB2YWx1ZTogc2NyaXB0UmVjb3JkLnRhZ30sXG5cdCAgICAgICAgICAgICAgICB7bmFtZTogJ3NjcmlwdCcgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IFRhYmxlKCdzY3JpcHRUYWJsZScsIFtcblx0ICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2RlZmF1bHRMYW5nU3lzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyBUYWJsZSgnZGVmYXVsdExhbmdTeXMnLCBbXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbG9va3VwT3JkZXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ3JlcUZlYXR1cmVJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZGVmYXVsdExhbmdTeXMucmVxRmVhdHVyZUluZGV4fV1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh1c2hvcnRMaXN0KCdmZWF0dXJlSW5kZXgnLCBkZWZhdWx0TGFuZ1N5cy5mZWF0dXJlSW5kZXhlcykpKX1cblx0ICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChyZWNvcmRMaXN0KCdsYW5nU3lzJywgc2NyaXB0LmxhbmdTeXNSZWNvcmRzLCBmdW5jdGlvbihsYW5nU3lzUmVjb3JkLCBpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5nU3lzID0gbGFuZ1N5c1JlY29yZC5sYW5nU3lzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsYW5nU3lzVGFnJyArIGksIHR5cGU6ICdUQUcnLCB2YWx1ZTogbGFuZ1N5c1JlY29yZC50YWd9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsYW5nU3lzJyArIGksIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgVGFibGUoJ2xhbmdTeXMnLCBbXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsb29rdXBPcmRlcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdyZXFGZWF0dXJlSW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxhbmdTeXMucmVxRmVhdHVyZUluZGV4fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHVzaG9ydExpc3QoJ2ZlYXR1cmVJbmRleCcsIGxhbmdTeXMuZmVhdHVyZUluZGV4ZXMpKSl9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF07XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpKX1cblx0ICAgICAgICAgICAgXTtcblx0ICAgICAgICB9KVxuXHQgICAgKTtcblx0fVxuXHRTY3JpcHRMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFibGUucHJvdG90eXBlKTtcblx0U2NyaXB0TGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY3JpcHRMaXN0O1xuXG5cdC8qKlxuXHQgKiBAZXhwb3J0cyBvcGVudHlwZS5GZWF0dXJlTGlzdFxuXHQgKiBAY2xhc3Ncblx0ICogQHBhcmFtIHtvcGVudHlwZS5UYWJsZX1cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBleHRlbmRzIG9wZW50eXBlLlRhYmxlXG5cdCAqL1xuXHRmdW5jdGlvbiBGZWF0dXJlTGlzdChmZWF0dXJlTGlzdFRhYmxlKSB7XG5cdCAgICBUYWJsZS5jYWxsKHRoaXMsICdmZWF0dXJlTGlzdFRhYmxlJyxcblx0ICAgICAgICByZWNvcmRMaXN0KCdmZWF0dXJlUmVjb3JkJywgZmVhdHVyZUxpc3RUYWJsZSwgZnVuY3Rpb24oZmVhdHVyZVJlY29yZCwgaSkge1xuXHQgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcblx0ICAgICAgICAgICAgcmV0dXJuIFtcblx0ICAgICAgICAgICAgICAgIHtuYW1lOiAnZmVhdHVyZVRhZycgKyBpLCB0eXBlOiAnVEFHJywgdmFsdWU6IGZlYXR1cmVSZWNvcmQudGFnfSxcblx0ICAgICAgICAgICAgICAgIHtuYW1lOiAnZmVhdHVyZScgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IFRhYmxlKCdmZWF0dXJlVGFibGUnLCBbXG5cdCAgICAgICAgICAgICAgICAgICAge25hbWU6ICdmZWF0dXJlUGFyYW1zJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBmZWF0dXJlLmZlYXR1cmVQYXJhbXN9IF0uY29uY2F0KHVzaG9ydExpc3QoJ2xvb2t1cExpc3RJbmRleCcsIGZlYXR1cmUubG9va3VwTGlzdEluZGV4ZXMpKSl9XG5cdCAgICAgICAgICAgIF07XG5cdCAgICAgICAgfSlcblx0ICAgICk7XG5cdH1cblx0RmVhdHVyZUxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuXHRGZWF0dXJlTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGZWF0dXJlTGlzdDtcblxuXHQvKipcblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuTG9va3VwTGlzdFxuXHQgKiBAY2xhc3Ncblx0ICogQHBhcmFtIHtvcGVudHlwZS5UYWJsZX1cblx0ICogQHBhcmFtIHtPYmplY3R9XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAZXh0ZW5kcyBvcGVudHlwZS5UYWJsZVxuXHQgKi9cblx0ZnVuY3Rpb24gTG9va3VwTGlzdChsb29rdXBMaXN0VGFibGUsIHN1YnRhYmxlTWFrZXJzKSB7XG5cdCAgICBUYWJsZS5jYWxsKHRoaXMsICdsb29rdXBMaXN0VGFibGUnLCB0YWJsZUxpc3QoJ2xvb2t1cCcsIGxvb2t1cExpc3RUYWJsZSwgZnVuY3Rpb24obG9va3VwVGFibGUpIHtcblx0ICAgICAgICB2YXIgc3VidGFibGVDYWxsYmFjayA9IHN1YnRhYmxlTWFrZXJzW2xvb2t1cFRhYmxlLmxvb2t1cFR5cGVdO1xuXHQgICAgICAgIGNoZWNrLmFzc2VydCghIXN1YnRhYmxlQ2FsbGJhY2ssICdVbmFibGUgdG8gd3JpdGUgR1NVQiBsb29rdXAgdHlwZSAnICsgbG9va3VwVGFibGUubG9va3VwVHlwZSArICcgdGFibGVzLicpO1xuXHQgICAgICAgIHJldHVybiBuZXcgVGFibGUoJ2xvb2t1cFRhYmxlJywgW1xuXHQgICAgICAgICAgICB7bmFtZTogJ2xvb2t1cFR5cGUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxvb2t1cFRhYmxlLmxvb2t1cFR5cGV9LFxuXHQgICAgICAgICAgICB7bmFtZTogJ2xvb2t1cEZsYWcnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxvb2t1cFRhYmxlLmxvb2t1cEZsYWd9XG5cdCAgICAgICAgXS5jb25jYXQodGFibGVMaXN0KCdzdWJ0YWJsZScsIGxvb2t1cFRhYmxlLnN1YnRhYmxlcywgc3VidGFibGVDYWxsYmFjaykpKTtcblx0ICAgIH0pKTtcblx0fVxuXHRMb29rdXBMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFibGUucHJvdG90eXBlKTtcblx0TG9va3VwTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb29rdXBMaXN0O1xuXG5cdC8vIFJlY29yZCA9IHNhbWUgYXMgVGFibGUsIGJ1dCBpbmxpbmVkIChhIFRhYmxlIGhhcyBhbiBvZmZzZXQgYW5kIGl0cyBkYXRhIGlzIGZ1cnRoZXIgaW4gdGhlIHN0cmVhbSlcblx0Ly8gRG9uJ3QgdXNlIG9mZnNldHMgaW5zaWRlIFJlY29yZHMgKHByb2JhYmxlIGJ1ZyksIG9ubHkgaW4gVGFibGVzLlxuXHR2YXIgdGFibGUgPSB7XG5cdCAgICBUYWJsZTogVGFibGUsXG5cdCAgICBSZWNvcmQ6IFRhYmxlLFxuXHQgICAgQ292ZXJhZ2U6IENvdmVyYWdlLFxuXHQgICAgU2NyaXB0TGlzdDogU2NyaXB0TGlzdCxcblx0ICAgIEZlYXR1cmVMaXN0OiBGZWF0dXJlTGlzdCxcblx0ICAgIExvb2t1cExpc3Q6IExvb2t1cExpc3QsXG5cdCAgICB1c2hvcnRMaXN0OiB1c2hvcnRMaXN0LFxuXHQgICAgdGFibGVMaXN0OiB0YWJsZUxpc3QsXG5cdCAgICByZWNvcmRMaXN0OiByZWNvcmRMaXN0LFxuXHR9O1xuXG5cdC8vIFBhcnNpbmcgdXRpbGl0eSBmdW5jdGlvbnNcblxuXHQvLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCBieXRlIGZyb20gdGhlIERhdGFWaWV3LlxuXHRmdW5jdGlvbiBnZXRCeXRlKGRhdGFWaWV3LCBvZmZzZXQpIHtcblx0ICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpO1xuXHR9XG5cblx0Ly8gUmV0cmlldmUgYW4gdW5zaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuXHQvLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5cdGZ1bmN0aW9uIGdldFVTaG9ydChkYXRhVmlldywgb2Zmc2V0KSB7XG5cdCAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCwgZmFsc2UpO1xuXHR9XG5cblx0Ly8gUmV0cmlldmUgYSBzaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuXHQvLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5cdGZ1bmN0aW9uIGdldFNob3J0KGRhdGFWaWV3LCBvZmZzZXQpIHtcblx0ICAgIHJldHVybiBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcblx0fVxuXG5cdC8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIDMyLWJpdCBsb25nIGZyb20gdGhlIERhdGFWaWV3LlxuXHQvLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5cdGZ1bmN0aW9uIGdldFVMb25nKGRhdGFWaWV3LCBvZmZzZXQpIHtcblx0ICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG5cdH1cblxuXHQvLyBSZXRyaWV2ZSBhIDMyLWJpdCBzaWduZWQgZml4ZWQtcG9pbnQgbnVtYmVyICgxNi4xNikgZnJvbSB0aGUgRGF0YVZpZXcuXG5cdC8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cblx0ZnVuY3Rpb24gZ2V0Rml4ZWQoZGF0YVZpZXcsIG9mZnNldCkge1xuXHQgICAgdmFyIGRlY2ltYWwgPSBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcblx0ICAgIHZhciBmcmFjdGlvbiA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyLCBmYWxzZSk7XG5cdCAgICByZXR1cm4gZGVjaW1hbCArIGZyYWN0aW9uIC8gNjU1MzU7XG5cdH1cblxuXHQvLyBSZXRyaWV2ZSBhIDQtY2hhcmFjdGVyIHRhZyBmcm9tIHRoZSBEYXRhVmlldy5cblx0Ly8gVGFncyBhcmUgdXNlZCB0byBpZGVudGlmeSB0YWJsZXMuXG5cdGZ1bmN0aW9uIGdldFRhZyhkYXRhVmlldywgb2Zmc2V0KSB7XG5cdCAgICB2YXIgdGFnID0gJyc7XG5cdCAgICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNDsgaSArPSAxKSB7XG5cdCAgICAgICAgdGFnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0SW50OChpKSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0YWc7XG5cdH1cblxuXHQvLyBSZXRyaWV2ZSBhbiBvZmZzZXQgZnJvbSB0aGUgRGF0YVZpZXcuXG5cdC8vIE9mZnNldHMgYXJlIDEgdG8gNCBieXRlcyBpbiBsZW5ndGgsIGRlcGVuZGluZyBvbiB0aGUgb2ZmU2l6ZSBhcmd1bWVudC5cblx0ZnVuY3Rpb24gZ2V0T2Zmc2V0KGRhdGFWaWV3LCBvZmZzZXQsIG9mZlNpemUpIHtcblx0ICAgIHZhciB2ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2ZmU2l6ZTsgaSArPSAxKSB7XG5cdCAgICAgICAgdiA8PD0gODtcblx0ICAgICAgICB2ICs9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdjtcblx0fVxuXG5cdC8vIFJldHJpZXZlIGEgbnVtYmVyIG9mIGJ5dGVzIGZyb20gc3RhcnQgb2Zmc2V0IHRvIHRoZSBlbmQgb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuXHRmdW5jdGlvbiBnZXRCeXRlcyhkYXRhVmlldywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuXHQgICAgdmFyIGJ5dGVzID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gc3RhcnRPZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMSkge1xuXHQgICAgICAgIGJ5dGVzLnB1c2goZGF0YVZpZXcuZ2V0VWludDgoaSkpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYnl0ZXM7XG5cdH1cblxuXHQvLyBDb252ZXJ0IHRoZSBsaXN0IG9mIGJ5dGVzIHRvIGEgc3RyaW5nLlxuXHRmdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG5cdCAgICB2YXIgcyA9ICcnO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzO1xuXHR9XG5cblx0dmFyIHR5cGVPZmZzZXRzID0ge1xuXHQgICAgYnl0ZTogMSxcblx0ICAgIHVTaG9ydDogMixcblx0ICAgIHNob3J0OiAyLFxuXHQgICAgdUxvbmc6IDQsXG5cdCAgICBmaXhlZDogNCxcblx0ICAgIGxvbmdEYXRlVGltZTogOCxcblx0ICAgIHRhZzogNFxuXHR9O1xuXG5cdC8vIEEgc3RhdGVmdWwgcGFyc2VyIHRoYXQgY2hhbmdlcyB0aGUgb2Zmc2V0IHdoZW5ldmVyIGEgdmFsdWUgaXMgcmV0cmlldmVkLlxuXHQvLyBUaGUgZGF0YSBpcyBhIERhdGFWaWV3LlxuXHRmdW5jdGlvbiBQYXJzZXIoZGF0YSwgb2Zmc2V0KSB7XG5cdCAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXHQgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG5cdCAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gMDtcblx0fVxuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRVaW50OCh0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuXHQgICAgcmV0dXJuIHY7XG5cdH07XG5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZUNoYXIgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcblx0ICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMTtcblx0ICAgIHJldHVybiB2O1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VDYXJkOCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlO1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldFVpbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuXHQgICAgcmV0dXJuIHY7XG5cdH07XG5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcmQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VTSUQgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VTaG9ydCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcblx0ICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcblx0ICAgIHJldHVybiB2O1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VGMkRvdDE0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpIC8gMTYzODQ7XG5cdCAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG5cdCAgICByZXR1cm4gdjtcblx0fTtcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmcgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciB2ID0gZ2V0VUxvbmcodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuXHQgICAgcmV0dXJuIHY7XG5cdH07XG5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDMyID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nO1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VGaXhlZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHYgPSBnZXRGaXhlZCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG5cdCAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG5cdCAgICByZXR1cm4gdjtcblx0fTtcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoKSB7XG5cdCAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG5cdCAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuXHQgICAgdmFyIHN0cmluZyA9ICcnO1xuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBsZW5ndGg7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSkpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gc3RyaW5nO1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VUYWcgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nKDQpO1xuXHR9O1xuXG5cdC8vIExPTkdEQVRFVElNRSBpcyBhIDY0LWJpdCBpbnRlZ2VyLlxuXHQvLyBKYXZhU2NyaXB0IGFuZCB1bml4IHRpbWVzdGFtcHMgdHJhZGl0aW9uYWxseSB1c2UgMzIgYml0cywgc28gd2Vcblx0Ly8gb25seSB0YWtlIHRoZSBsYXN0IDMyIGJpdHMuXG5cdC8vICsgU2luY2UgdW50aWwgMjAzOCB0aG9zZSBiaXRzIHdpbGwgYmUgZmlsbGVkIGJ5IHplcm9zIHdlIGNhbiBpZ25vcmUgdGhlbS5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZUxvbmdEYXRlVGltZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHYgPSBnZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCArIDQpO1xuXHQgICAgLy8gU3VidHJhY3Qgc2Vjb25kcyBiZXR3ZWVuIDAxLzAxLzE5MDQgYW5kIDAxLzAxLzE5NzBcblx0ICAgIC8vIHRvIGNvbnZlcnQgQXBwbGUgTWFjIHRpbWVzdGFtcCB0byBTdGFuZGFyZCBVbml4IHRpbWVzdGFtcFxuXHQgICAgdiAtPSAyMDgyODQ0ODAwO1xuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA4O1xuXHQgICAgcmV0dXJuIHY7XG5cdH07XG5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZVZlcnNpb24gPSBmdW5jdGlvbihtaW5vckJhc2UpIHtcblx0ICAgIHZhciBtYWpvciA9IGdldFVTaG9ydCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG5cblx0ICAgIC8vIEhvdyB0byBpbnRlcnByZXQgdGhlIG1pbm9yIHZlcnNpb24gaXMgdmVyeSB2YWd1ZSBpbiB0aGUgc3BlYy4gMHg1MDAwIGlzIDUsIDB4MTAwMCBpcyAxXG5cdCAgICAvLyBEZWZhdWx0IHJldHVybnMgdGhlIGNvcnJlY3QgbnVtYmVyIGlmIG1pbm9yID0gMHhOMDAwIHdoZXJlIE4gaXMgMC05XG5cdCAgICAvLyBTZXQgbWlub3JCYXNlIHRvIDEgZm9yIHRhYmxlcyB0aGF0IHVzZSBtaW5vciA9IE4gd2hlcmUgTiBpcyAwLTlcblx0ICAgIHZhciBtaW5vciA9IGdldFVTaG9ydCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCArIDIpO1xuXHQgICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuXHQgICAgaWYgKG1pbm9yQmFzZSA9PT0gdW5kZWZpbmVkKSB7IG1pbm9yQmFzZSA9IDB4MTAwMDsgfVxuXHQgICAgcmV0dXJuIG1ham9yICsgbWlub3IgLyBtaW5vckJhc2UgLyAxMDtcblx0fTtcblxuXHRQYXJzZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbih0eXBlLCBhbW91bnQpIHtcblx0ICAgIGlmIChhbW91bnQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGFtb3VudCA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gdHlwZU9mZnNldHNbdHlwZV0gKiBhbW91bnQ7XG5cdH07XG5cblx0Ly8vLy8gUGFyc2luZyBsaXN0cyBhbmQgcmVjb3JkcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0Ly8gUGFyc2UgYSBsaXN0IG9mIDMyIGJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nTGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG5cdCAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgeyBjb3VudCA9IHRoaXMucGFyc2VVTG9uZygpOyB9XG5cdCAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShjb3VudCk7XG5cdCAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG5cdCAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgb2Zmc2V0c1tpXSA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQpO1xuXHQgICAgICAgIG9mZnNldCArPSA0O1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogNDtcblx0ICAgIHJldHVybiBvZmZzZXRzO1xuXHR9O1xuXG5cdC8vIFBhcnNlIGEgbGlzdCBvZiAxNiBiaXQgdW5zaWduZWQgaW50ZWdlcnMuIFRoZSBsZW5ndGggb2YgdGhlIGxpc3QgY2FuIGJlIHJlYWQgb24gdGhlIHN0cmVhbVxuXHQvLyBvciBwcm92aWRlZCBhcyBhbiBhcmd1bWVudC5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2TGlzdCA9XG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnRMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcblx0ICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7IGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpOyB9XG5cdCAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShjb3VudCk7XG5cdCAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG5cdCAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgb2Zmc2V0c1tpXSA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQpO1xuXHQgICAgICAgIG9mZnNldCArPSAyO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogMjtcblx0ICAgIHJldHVybiBvZmZzZXRzO1xuXHR9O1xuXG5cdC8vIFBhcnNlcyBhIGxpc3Qgb2YgMTYgYml0IHNpZ25lZCBpbnRlZ2Vycy5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZVNob3J0TGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG5cdCAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG5cdCAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG5cdCAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgbGlzdFtpXSA9IGRhdGFWaWV3LmdldEludDE2KG9mZnNldCk7XG5cdCAgICAgICAgb2Zmc2V0ICs9IDI7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQgKiAyO1xuXHQgICAgcmV0dXJuIGxpc3Q7XG5cdH07XG5cblx0Ly8gUGFyc2VzIGEgbGlzdCBvZiBieXRlcy5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGVMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcblx0ICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcblx0ICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcblx0ICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgICBsaXN0W2ldID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KyspO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50O1xuXHQgICAgcmV0dXJuIGxpc3Q7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIGEgbGlzdCBvZiBpdGVtcy5cblx0ICogUmVjb3JkIGNvdW50IGlzIG9wdGlvbmFsLCBpZiBvbWl0dGVkIGl0IGlzIHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuXHQgKiBpdGVtQ2FsbGJhY2sgaXMgb25lIG9mIHRoZSBQYXJzZXIgbWV0aG9kcy5cblx0ICovXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VMaXN0ID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIGlmICghaXRlbUNhbGxiYWNrKSB7XG5cdCAgICAgICAgaXRlbUNhbGxiYWNrID0gY291bnQ7XG5cdCAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICB9XG5cdCAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgICBsaXN0W2ldID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyQxKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsaXN0O1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VMaXN0MzIgPSBmdW5jdGlvbihjb3VudCwgaXRlbUNhbGxiYWNrKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgaWYgKCFpdGVtQ2FsbGJhY2spIHtcblx0ICAgICAgICBpdGVtQ2FsbGJhY2sgPSBjb3VudDtcblx0ICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVTG9uZygpO1xuXHQgICAgfVxuXHQgICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgbGlzdFtpXSA9IGl0ZW1DYWxsYmFjay5jYWxsKHRoaXMkMSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGlzdDtcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2UgYSBsaXN0IG9mIHJlY29yZHMuXG5cdCAqIFJlY29yZCBjb3VudCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cblx0ICogRXhhbXBsZSBvZiByZWNvcmREZXNjcmlwdGlvbjogeyBzZXF1ZW5jZUluZGV4OiBQYXJzZXIudVNob3J0LCBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnQgfVxuXHQgKi9cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlY29yZExpc3QgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICAvLyBJZiB0aGUgY291bnQgYXJndW1lbnQgaXMgYWJzZW50LCByZWFkIGl0IGluIHRoZSBzdHJlYW0uXG5cdCAgICBpZiAoIXJlY29yZERlc2NyaXB0aW9uKSB7XG5cdCAgICAgICAgcmVjb3JkRGVzY3JpcHRpb24gPSBjb3VudDtcblx0ICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIH1cblx0ICAgIHZhciByZWNvcmRzID0gbmV3IEFycmF5KGNvdW50KTtcblx0ICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhyZWNvcmREZXNjcmlwdGlvbik7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgICB2YXIgcmVjID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcblx0ICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IHJlY29yZERlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG5cdCAgICAgICAgICAgIHJlY1tmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyQxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVjb3Jkc1tpXSA9IHJlYztcblx0ICAgIH1cblx0ICAgIHJldHVybiByZWNvcmRzO1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VSZWNvcmRMaXN0MzIgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICAvLyBJZiB0aGUgY291bnQgYXJndW1lbnQgaXMgYWJzZW50LCByZWFkIGl0IGluIHRoZSBzdHJlYW0uXG5cdCAgICBpZiAoIXJlY29yZERlc2NyaXB0aW9uKSB7XG5cdCAgICAgICAgcmVjb3JkRGVzY3JpcHRpb24gPSBjb3VudDtcblx0ICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVTG9uZygpO1xuXHQgICAgfVxuXHQgICAgdmFyIHJlY29yZHMgPSBuZXcgQXJyYXkoY291bnQpO1xuXHQgICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKHJlY29yZERlc2NyaXB0aW9uKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHQgICAgICAgIHZhciByZWMgPSB7fTtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGRzW2pdO1xuXHQgICAgICAgICAgICB2YXIgZmllbGRUeXBlID0gcmVjb3JkRGVzY3JpcHRpb25bZmllbGROYW1lXTtcblx0ICAgICAgICAgICAgcmVjW2ZpZWxkTmFtZV0gPSBmaWVsZFR5cGUuY2FsbCh0aGlzJDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZWNvcmRzW2ldID0gcmVjO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlY29yZHM7XG5cdH07XG5cblx0Ly8gUGFyc2UgYSBkYXRhIHN0cnVjdHVyZSBpbnRvIGFuIG9iamVjdFxuXHQvLyBFeGFtcGxlIG9mIGRlc2NyaXB0aW9uOiB7IHNlcXVlbmNlSW5kZXg6IFBhcnNlci51U2hvcnQsIGxvb2t1cExpc3RJbmRleDogUGFyc2VyLnVTaG9ydCB9XG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJ1Y3QgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIGlmICh0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24uY2FsbCh0aGlzKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKGRlc2NyaXB0aW9uKTtcblx0ICAgICAgICB2YXIgc3RydWN0ID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcblx0ICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IGRlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG5cdCAgICAgICAgICAgIHN0cnVjdFtmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyQxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHN0cnVjdDtcblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogUGFyc2UgYSBHUE9TIHZhbHVlUmVjb3JkXG5cdCAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI3ZhbHVlLXJlY29yZFxuXHQgKiB2YWx1ZUZvcm1hdCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cblx0ICovXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VWYWx1ZVJlY29yZCA9IGZ1bmN0aW9uKHZhbHVlRm9ybWF0KSB7XG5cdCAgICBpZiAodmFsdWVGb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHZhbHVlRm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgfVxuXHQgICAgaWYgKHZhbHVlRm9ybWF0ID09PSAwKSB7XG5cdCAgICAgICAgLy8gdmFsdWVGb3JtYXQyIGluIGtlcm5pbmcgcGFpcnMgaXMgbW9zdCBvZnRlbiAwXG5cdCAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHJldHVybiB1bmRlZmluZWQgaW5zdGVhZCBvZiBhbiBlbXB0eSBvYmplY3QsIHRvIHNhdmUgc3BhY2Vcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB2YXIgdmFsdWVSZWNvcmQgPSB7fTtcblxuXHQgICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDAxKSB7IHZhbHVlUmVjb3JkLnhQbGFjZW1lbnQgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuXHQgICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDAyKSB7IHZhbHVlUmVjb3JkLnlQbGFjZW1lbnQgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuXHQgICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDA0KSB7IHZhbHVlUmVjb3JkLnhBZHZhbmNlID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cblx0ICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwOCkgeyB2YWx1ZVJlY29yZC55QWR2YW5jZSA9IHRoaXMucGFyc2VTaG9ydCgpOyB9XG5cblx0ICAgIC8vIERldmljZSB0YWJsZSAobm9uLXZhcmlhYmxlIGZvbnQpIC8gVmFyaWF0aW9uSW5kZXggdGFibGUgKHZhcmlhYmxlIGZvbnQpIG5vdCBzdXBwb3J0ZWRcblx0ICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2ZyLWZyL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9jaGFwdGVyMiNkZXZWYXJJZHhUYmxzXG5cdCAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMTApIHsgdmFsdWVSZWNvcmQueFBsYURldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cblx0ICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAyMCkgeyB2YWx1ZVJlY29yZC55UGxhRGV2aWNlID0gdW5kZWZpbmVkOyB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuXHQgICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDQwKSB7IHZhbHVlUmVjb3JkLnhBZHZEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG5cdCAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwODApIHsgdmFsdWVSZWNvcmQueUFkdkRldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cblxuXHQgICAgcmV0dXJuIHZhbHVlUmVjb3JkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBhIGxpc3Qgb2YgR1BPUyB2YWx1ZVJlY29yZHNcblx0ICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjdmFsdWUtcmVjb3JkXG5cdCAqIHZhbHVlRm9ybWF0IGFuZCB2YWx1ZUNvdW50IGFyZSByZWFkIGZyb20gdGhlIHN0cmVhbS5cblx0ICovXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VWYWx1ZVJlY29yZExpc3QgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICB2YXIgdmFsdWVGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICB2YXIgdmFsdWVDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVDb3VudCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuXHQgICAgICAgIHZhbHVlc1tpXSA9IHRoaXMkMS5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZXM7XG5cdH07XG5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZVBvaW50ZXIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuXHQgICAgdmFyIHN0cnVjdE9mZnNldCA9IHRoaXMucGFyc2VPZmZzZXQxNigpO1xuXHQgICAgaWYgKHN0cnVjdE9mZnNldCA+IDApIHtcblx0ICAgICAgICAvLyBOVUxMIG9mZnNldCA9PiByZXR1cm4gdW5kZWZpbmVkXG5cdCAgICAgICAgcmV0dXJuIG5ldyBQYXJzZXIodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHN0cnVjdE9mZnNldCkucGFyc2VTdHJ1Y3QoZGVzY3JpcHRpb24pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0fTtcblxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlUG9pbnRlcjMyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcblx0ICAgIHZhciBzdHJ1Y3RPZmZzZXQgPSB0aGlzLnBhcnNlT2Zmc2V0MzIoKTtcblx0ICAgIGlmIChzdHJ1Y3RPZmZzZXQgPiAwKSB7XG5cdCAgICAgICAgLy8gTlVMTCBvZmZzZXQgPT4gcmV0dXJuIHVuZGVmaW5lZFxuXHQgICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyBzdHJ1Y3RPZmZzZXQpLnBhcnNlU3RydWN0KGRlc2NyaXB0aW9uKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIGEgbGlzdCBvZiBvZmZzZXRzIHRvIGxpc3RzIG9mIDE2LWJpdCBpbnRlZ2Vycyxcblx0ICogb3IgYSBsaXN0IG9mIG9mZnNldHMgdG8gbGlzdHMgb2Ygb2Zmc2V0cyB0byBhbnkga2luZCBvZiBpdGVtcy5cblx0ICogSWYgaXRlbUNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZCwgYSBsaXN0IG9mIGxpc3Qgb2YgVVNob3J0IGlzIGFzc3VtZWQuXG5cdCAqIElmIHByb3ZpZGVkLCBpdGVtQ2FsbGJhY2sgaXMgY2FsbGVkIG9uIGVhY2ggaXRlbSBhbmQgbXVzdCBwYXJzZSB0aGUgaXRlbS5cblx0ICogU2VlIGV4YW1wbGVzIGluIHRhYmxlcy9nc3ViLmpzXG5cdCAqL1xuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdE9mTGlzdHMgPSBmdW5jdGlvbihpdGVtQ2FsbGJhY2spIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICB2YXIgb2Zmc2V0cyA9IHRoaXMucGFyc2VPZmZzZXQxNkxpc3QoKTtcblx0ICAgIHZhciBjb3VudCA9IG9mZnNldHMubGVuZ3RoO1xuXHQgICAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gdGhpcy5yZWxhdGl2ZU9mZnNldDtcblx0ICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHQgICAgICAgIHZhciBzdGFydCA9IG9mZnNldHNbaV07XG5cdCAgICAgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG5cdCAgICAgICAgICAgIC8vIE5VTEwgb2Zmc2V0XG5cdCAgICAgICAgICAgIC8vIEFkZCBpIGFzIG93bmVkIHByb3BlcnR5IHRvIGxpc3QuIENvbnZlbmllbnQgd2l0aCBhc3NlcnQuXG5cdCAgICAgICAgICAgIGxpc3RbaV0gPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzJDEucmVsYXRpdmVPZmZzZXQgPSBzdGFydDtcblx0ICAgICAgICBpZiAoaXRlbUNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJPZmZzZXRzID0gdGhpcyQxLnBhcnNlT2Zmc2V0MTZMaXN0KCk7XG5cdCAgICAgICAgICAgIHZhciBzdWJMaXN0ID0gbmV3IEFycmF5KHN1Yk9mZnNldHMubGVuZ3RoKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJPZmZzZXRzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzJDEucmVsYXRpdmVPZmZzZXQgPSBzdGFydCArIHN1Yk9mZnNldHNbal07XG5cdCAgICAgICAgICAgICAgICBzdWJMaXN0W2pdID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyQxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsaXN0W2ldID0gc3ViTGlzdDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBsaXN0W2ldID0gdGhpcyQxLnBhcnNlVVNob3J0TGlzdCgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSByZWxhdGl2ZU9mZnNldDtcblx0ICAgIHJldHVybiBsaXN0O1xuXHR9O1xuXG5cdC8vLy8vIENvbXBsZXggdGFibGVzIHBhcnNpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8vIFBhcnNlIGEgY292ZXJhZ2UgdGFibGUgaW4gYSBHU1VCLCBHUE9TIG9yIEdERUYgdGFibGUuXG5cdC8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcHRlcjIuaHRtXG5cdC8vIHBhcnNlci5vZmZzZXQgbXVzdCBwb2ludCB0byB0aGUgc3RhcnQgb2YgdGhlIHRhYmxlIGNvbnRhaW5pbmcgdGhlIGNvdmVyYWdlLlxuXHRQYXJzZXIucHJvdG90eXBlLnBhcnNlQ292ZXJhZ2UgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICB2YXIgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG5cdCAgICB2YXIgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgdmFyIGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGZvcm1hdDogMSxcblx0ICAgICAgICAgICAgZ2x5cGhzOiB0aGlzLnBhcnNlVVNob3J0TGlzdChjb3VudClcblx0ICAgICAgICB9O1xuXHQgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcblx0ICAgICAgICB2YXIgcmFuZ2VzID0gbmV3IEFycmF5KGNvdW50KTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgICAgICAgcmFuZ2VzW2ldID0ge1xuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMkMS5wYXJzZVVTaG9ydCgpLFxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzJDEucGFyc2VVU2hvcnQoKSxcblx0ICAgICAgICAgICAgICAgIGluZGV4OiB0aGlzJDEucGFyc2VVU2hvcnQoKVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBmb3JtYXQ6IDIsXG5cdCAgICAgICAgICAgIHJhbmdlczogcmFuZ2VzXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcignMHgnICsgc3RhcnRPZmZzZXQudG9TdHJpbmcoMTYpICsgJzogQ292ZXJhZ2UgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xuXHR9O1xuXG5cdC8vIFBhcnNlIGEgQ2xhc3MgRGVmaW5pdGlvbiBUYWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cblx0Ly8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVmID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG5cdCAgICB2YXIgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGZvcm1hdDogMSxcblx0ICAgICAgICAgICAgc3RhcnRHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuXHQgICAgICAgICAgICBjbGFzc2VzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpXG5cdCAgICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgZm9ybWF0OiAyLFxuXHQgICAgICAgICAgICByYW5nZXM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBQYXJzZXIudVNob3J0LFxuXHQgICAgICAgICAgICAgICAgZW5kOiBQYXJzZXIudVNob3J0LFxuXHQgICAgICAgICAgICAgICAgY2xhc3NJZDogUGFyc2VyLnVTaG9ydFxuXHQgICAgICAgICAgICB9KVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJzB4JyArIHN0YXJ0T2Zmc2V0LnRvU3RyaW5nKDE2KSArICc6IENsYXNzRGVmIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcblx0fTtcblxuXHQvLy8vLyBTdGF0aWMgbWV0aG9kcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBUaGVzZSBjb252ZW5pZW5jZSBtZXRob2RzIGNhbiBiZSB1c2VkIGFzIGNhbGxiYWNrcyBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIFwidGhpc1wiIGNvbnRleHQgc2V0IHRvIGEgUGFyc2VyIGluc3RhbmNlLlxuXG5cdFBhcnNlci5saXN0ID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdChjb3VudCwgaXRlbUNhbGxiYWNrKTtcblx0ICAgIH07XG5cdH07XG5cblx0UGFyc2VyLmxpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QzMihjb3VudCwgaXRlbUNhbGxiYWNrKTtcblx0ICAgIH07XG5cdH07XG5cblx0UGFyc2VyLnJlY29yZExpc3QgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlY29yZExpc3QoY291bnQsIHJlY29yZERlc2NyaXB0aW9uKTtcblx0ICAgIH07XG5cdH07XG5cblx0UGFyc2VyLnJlY29yZExpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVjb3JkTGlzdDMyKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbik7XG5cdCAgICB9O1xuXHR9O1xuXG5cdFBhcnNlci5wb2ludGVyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoZGVzY3JpcHRpb24pO1xuXHQgICAgfTtcblx0fTtcblxuXHRQYXJzZXIucG9pbnRlcjMyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIzMihkZXNjcmlwdGlvbik7XG5cdCAgICB9O1xuXHR9O1xuXG5cdFBhcnNlci50YWcgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGFnO1xuXHRQYXJzZXIuYnl0ZSA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlO1xuXHRQYXJzZXIudVNob3J0ID0gUGFyc2VyLm9mZnNldDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblx0UGFyc2VyLnVTaG9ydExpc3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdDtcblx0UGFyc2VyLnVMb25nID0gUGFyc2VyLm9mZnNldDMyID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nO1xuXHRQYXJzZXIudUxvbmdMaXN0ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nTGlzdDtcblx0UGFyc2VyLnN0cnVjdCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJ1Y3Q7XG5cdFBhcnNlci5jb3ZlcmFnZSA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VDb3ZlcmFnZTtcblx0UGFyc2VyLmNsYXNzRGVmID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVmO1xuXG5cdC8vLy8vIFNjcmlwdCwgRmVhdHVyZSwgTG9va3VwIGxpc3RzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcHRlcjIuaHRtXG5cblx0dmFyIGxhbmdTeXNUYWJsZSA9IHtcblx0ICAgIHJlc2VydmVkOiBQYXJzZXIudVNob3J0LFxuXHQgICAgcmVxRmVhdHVyZUluZGV4OiBQYXJzZXIudVNob3J0LFxuXHQgICAgZmVhdHVyZUluZGV4ZXM6IFBhcnNlci51U2hvcnRMaXN0XG5cdH07XG5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZVNjcmlwdExpc3QgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIucmVjb3JkTGlzdCh7XG5cdCAgICAgICAgdGFnOiBQYXJzZXIudGFnLFxuXHQgICAgICAgIHNjcmlwdDogUGFyc2VyLnBvaW50ZXIoe1xuXHQgICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czogUGFyc2VyLnBvaW50ZXIobGFuZ1N5c1RhYmxlKSxcblx0ICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFBhcnNlci5yZWNvcmRMaXN0KHtcblx0ICAgICAgICAgICAgICAgIHRhZzogUGFyc2VyLnRhZyxcblx0ICAgICAgICAgICAgICAgIGxhbmdTeXM6IFBhcnNlci5wb2ludGVyKGxhbmdTeXNUYWJsZSlcblx0ICAgICAgICAgICAgfSlcblx0ICAgICAgICB9KVxuXHQgICAgfSkpIHx8IFtdO1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VGZWF0dXJlTGlzdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5yZWNvcmRMaXN0KHtcblx0ICAgICAgICB0YWc6IFBhcnNlci50YWcsXG5cdCAgICAgICAgZmVhdHVyZTogUGFyc2VyLnBvaW50ZXIoe1xuXHQgICAgICAgICAgICBmZWF0dXJlUGFyYW1zOiBQYXJzZXIub2Zmc2V0MTYsXG5cdCAgICAgICAgICAgIGxvb2t1cExpc3RJbmRleGVzOiBQYXJzZXIudVNob3J0TGlzdFxuXHQgICAgICAgIH0pXG5cdCAgICB9KSkgfHwgW107XG5cdH07XG5cblx0UGFyc2VyLnByb3RvdHlwZS5wYXJzZUxvb2t1cExpc3QgPSBmdW5jdGlvbihsb29rdXBUYWJsZVBhcnNlcnMpIHtcblx0ICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIubGlzdChQYXJzZXIucG9pbnRlcihmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgbG9va3VwVHlwZSA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICBjaGVjay5hcmd1bWVudCgxIDw9IGxvb2t1cFR5cGUgJiYgbG9va3VwVHlwZSA8PSA5LCAnR1BPUy9HU1VCIGxvb2t1cCB0eXBlICcgKyBsb29rdXBUeXBlICsgJyB1bmtub3duLicpO1xuXHQgICAgICAgIHZhciBsb29rdXBGbGFnID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIHZhciB1c2VNYXJrRmlsdGVyaW5nU2V0ID0gbG9va3VwRmxhZyAmIDB4MTA7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgbG9va3VwVHlwZTogbG9va3VwVHlwZSxcblx0ICAgICAgICAgICAgbG9va3VwRmxhZzogbG9va3VwRmxhZyxcblx0ICAgICAgICAgICAgc3VidGFibGVzOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihsb29rdXBUYWJsZVBhcnNlcnNbbG9va3VwVHlwZV0pKSxcblx0ICAgICAgICAgICAgbWFya0ZpbHRlcmluZ1NldDogdXNlTWFya0ZpbHRlcmluZ1NldCA/IHRoaXMucGFyc2VVU2hvcnQoKSA6IHVuZGVmaW5lZFxuXHQgICAgICAgIH07XG5cdCAgICB9KSkpIHx8IFtdO1xuXHR9O1xuXG5cdFBhcnNlci5wcm90b3R5cGUucGFyc2VGZWF0dXJlVmFyaWF0aW9uc0xpc3QgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcjMyKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBtYWpvclZlcnNpb24gPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgdmFyIG1pbm9yVmVyc2lvbiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICBjaGVjay5hcmd1bWVudChtYWpvclZlcnNpb24gPT09IDEgJiYgbWlub3JWZXJzaW9uIDwgMSwgJ0dQT1MvR1NVQiBmZWF0dXJlIHZhcmlhdGlvbnMgdGFibGUgdW5rbm93bi4nKTtcblx0ICAgICAgICB2YXIgZmVhdHVyZVZhcmlhdGlvbnMgPSB0aGlzLnBhcnNlUmVjb3JkTGlzdDMyKHtcblx0ICAgICAgICAgICAgY29uZGl0aW9uU2V0T2Zmc2V0OiBQYXJzZXIub2Zmc2V0MzIsXG5cdCAgICAgICAgICAgIGZlYXR1cmVUYWJsZVN1YnN0aXR1dGlvbk9mZnNldDogUGFyc2VyLm9mZnNldDMyXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIGZlYXR1cmVWYXJpYXRpb25zO1xuXHQgICAgfSkgfHwgW107XG5cdH07XG5cblx0dmFyIHBhcnNlID0ge1xuXHQgICAgZ2V0Qnl0ZTogZ2V0Qnl0ZSxcblx0ICAgIGdldENhcmQ4OiBnZXRCeXRlLFxuXHQgICAgZ2V0VVNob3J0OiBnZXRVU2hvcnQsXG5cdCAgICBnZXRDYXJkMTY6IGdldFVTaG9ydCxcblx0ICAgIGdldFNob3J0OiBnZXRTaG9ydCxcblx0ICAgIGdldFVMb25nOiBnZXRVTG9uZyxcblx0ICAgIGdldEZpeGVkOiBnZXRGaXhlZCxcblx0ICAgIGdldFRhZzogZ2V0VGFnLFxuXHQgICAgZ2V0T2Zmc2V0OiBnZXRPZmZzZXQsXG5cdCAgICBnZXRCeXRlczogZ2V0Qnl0ZXMsXG5cdCAgICBieXRlc1RvU3RyaW5nOiBieXRlc1RvU3RyaW5nLFxuXHQgICAgUGFyc2VyOiBQYXJzZXIsXG5cdH07XG5cblx0Ly8gVGhlIGBjbWFwYCB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG5cblx0ZnVuY3Rpb24gcGFyc2VDbWFwVGFibGVGb3JtYXQxMihjbWFwLCBwKSB7XG5cdCAgICAvL1NraXAgcmVzZXJ2ZWQuXG5cdCAgICBwLnBhcnNlVVNob3J0KCk7XG5cblx0ICAgIC8vIExlbmd0aCBpbiBieXRlcyBvZiB0aGUgc3ViLXRhYmxlcy5cblx0ICAgIGNtYXAubGVuZ3RoID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICBjbWFwLmxhbmd1YWdlID0gcC5wYXJzZVVMb25nKCk7XG5cblx0ICAgIHZhciBncm91cENvdW50O1xuXHQgICAgY21hcC5ncm91cENvdW50ID0gZ3JvdXBDb3VudCA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgY21hcC5nbHlwaEluZGV4TWFwID0ge307XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBDb3VudDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIHN0YXJ0Q2hhckNvZGUgPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgICAgICB2YXIgZW5kQ2hhckNvZGUgPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgICAgICB2YXIgc3RhcnRHbHlwaElkID0gcC5wYXJzZVVMb25nKCk7XG5cblx0ICAgICAgICBmb3IgKHZhciBjID0gc3RhcnRDaGFyQ29kZTsgYyA8PSBlbmRDaGFyQ29kZTsgYyArPSAxKSB7XG5cdCAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IHN0YXJ0R2x5cGhJZDtcblx0ICAgICAgICAgICAgc3RhcnRHbHlwaElkKys7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VDbWFwVGFibGVGb3JtYXQ0KGNtYXAsIHAsIGRhdGEsIHN0YXJ0LCBvZmZzZXQpIHtcblx0ICAgIC8vIExlbmd0aCBpbiBieXRlcyBvZiB0aGUgc3ViLXRhYmxlcy5cblx0ICAgIGNtYXAubGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgY21hcC5sYW5ndWFnZSA9IHAucGFyc2VVU2hvcnQoKTtcblxuXHQgICAgLy8gc2VnQ291bnQgaXMgc3RvcmVkIHggMi5cblx0ICAgIHZhciBzZWdDb3VudDtcblx0ICAgIGNtYXAuc2VnQ291bnQgPSBzZWdDb3VudCA9IHAucGFyc2VVU2hvcnQoKSA+PiAxO1xuXG5cdCAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuXHQgICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcblxuXHQgICAgLy8gVGhlIFwidW5yb2xsZWRcIiBtYXBwaW5nIGZyb20gY2hhcmFjdGVyIGNvZGVzIHRvIGdseXBoIGluZGljZXMuXG5cdCAgICBjbWFwLmdseXBoSW5kZXhNYXAgPSB7fTtcblx0ICAgIHZhciBlbmRDb3VudFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNCk7XG5cdCAgICB2YXIgc3RhcnRDb3VudFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogMik7XG5cdCAgICB2YXIgaWREZWx0YVBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogNCk7XG5cdCAgICB2YXIgaWRSYW5nZU9mZnNldFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogNik7XG5cdCAgICB2YXIgZ2x5cGhJbmRleE9mZnNldCA9IHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDg7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ0NvdW50IC0gMTsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGdseXBoSW5kZXggPSAodm9pZCAwKTtcblx0ICAgICAgICB2YXIgZW5kQ291bnQgPSBlbmRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIHZhciBzdGFydENvdW50ID0gc3RhcnRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIHZhciBpZERlbHRhID0gaWREZWx0YVBhcnNlci5wYXJzZVNob3J0KCk7XG5cdCAgICAgICAgdmFyIGlkUmFuZ2VPZmZzZXQgPSBpZFJhbmdlT2Zmc2V0UGFyc2VyLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgZm9yICh2YXIgYyA9IHN0YXJ0Q291bnQ7IGMgPD0gZW5kQ291bnQ7IGMgKz0gMSkge1xuXHQgICAgICAgICAgICBpZiAoaWRSYW5nZU9mZnNldCAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgLy8gVGhlIGlkUmFuZ2VPZmZzZXQgaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGlkUmFuZ2VPZmZzZXQgYXJyYXkuXG5cdCAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBjdXJyZW50IG9mZnNldCBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cblx0ICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgPSAoaWRSYW5nZU9mZnNldFBhcnNlci5vZmZzZXQgKyBpZFJhbmdlT2Zmc2V0UGFyc2VyLnJlbGF0aXZlT2Zmc2V0IC0gMik7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdmFsdWUgb2YgdGhlIGlkUmFuZ2VPZmZzZXQsIHdoaWNoIHdpbGwgbW92ZSB1cyBpbnRvIHRoZSBnbHlwaEluZGV4IGFycmF5LlxuXHQgICAgICAgICAgICAgICAgZ2x5cGhJbmRleE9mZnNldCArPSBpZFJhbmdlT2Zmc2V0O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBUaGVuIGFkZCB0aGUgY2hhcmFjdGVyIGluZGV4IG9mIHRoZSBjdXJyZW50IHNlZ21lbnQsIG11bHRpcGxpZWQgYnkgMiBmb3IgVVNIT1JUcy5cblx0ICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gKGMgLSBzdGFydENvdW50KSAqIDI7XG5cdCAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIGdseXBoSW5kZXhPZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGdseXBoSW5kZXggIT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGdseXBoSW5kZXggKyBpZERlbHRhKSAmIDB4RkZGRjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSAoYyArIGlkRGVsdGEpICYgMHhGRkZGO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgY21hcC5nbHlwaEluZGV4TWFwW2NdID0gZ2x5cGhJbmRleDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH1cblxuXHQvLyBQYXJzZSB0aGUgYGNtYXBgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgbWFwcGluZ3MgZnJvbSBjaGFyYWN0ZXJzIHRvIGdseXBocy5cblx0Ly8gVGhlcmUgYXJlIG1hbnkgYXZhaWxhYmxlIGZvcm1hdHMsIGJ1dCB3ZSBvbmx5IHN1cHBvcnQgdGhlIFdpbmRvd3MgZm9ybWF0IDQgYW5kIDEyLlxuXHQvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBgQ21hcEVuY29kaW5nYCBvYmplY3Qgb3IgbnVsbCBpZiBubyBzdXBwb3J0ZWQgZm9ybWF0IGNvdWxkIGJlIGZvdW5kLlxuXHRmdW5jdGlvbiBwYXJzZUNtYXBUYWJsZShkYXRhLCBzdGFydCkge1xuXHQgICAgdmFyIGNtYXAgPSB7fTtcblx0ICAgIGNtYXAudmVyc2lvbiA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCk7XG5cdCAgICBjaGVjay5hcmd1bWVudChjbWFwLnZlcnNpb24gPT09IDAsICdjbWFwIHRhYmxlIHZlcnNpb24gc2hvdWxkIGJlIDAuJyk7XG5cblx0ICAgIC8vIFRoZSBjbWFwIHRhYmxlIGNhbiBjb250YWluIG1hbnkgc3ViLXRhYmxlcywgZWFjaCB3aXRoIHRoZWlyIG93biBmb3JtYXQuXG5cdCAgICAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gYSBcInBsYXRmb3JtIDBcIiAoVW5pY29kZSBmb3JtYXQpIGFuZCBcInBsYXRmb3JtIDNcIiAoV2luZG93cyBmb3JtYXQpIHRhYmxlLlxuXHQgICAgY21hcC5udW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyAyKTtcblx0ICAgIHZhciBvZmZzZXQgPSAtMTtcblx0ICAgIGZvciAodmFyIGkgPSBjbWFwLm51bVRhYmxlcyAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG5cdCAgICAgICAgdmFyIHBsYXRmb3JtSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSk7XG5cdCAgICAgICAgdmFyIGVuY29kaW5nSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSArIDIpO1xuXHQgICAgICAgIGlmICgocGxhdGZvcm1JZCA9PT0gMyAmJiAoZW5jb2RpbmdJZCA9PT0gMCB8fCBlbmNvZGluZ0lkID09PSAxIHx8IGVuY29kaW5nSWQgPT09IDEwKSkgfHxcblx0ICAgICAgICAgICAgKHBsYXRmb3JtSWQgPT09IDAgJiYgKGVuY29kaW5nSWQgPT09IDAgfHwgZW5jb2RpbmdJZCA9PT0gMSB8fCBlbmNvZGluZ0lkID09PSAyIHx8IGVuY29kaW5nSWQgPT09IDMgfHwgZW5jb2RpbmdJZCA9PT0gNCkpKSB7XG5cdCAgICAgICAgICAgIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHN0YXJ0ICsgNCArIChpICogOCkgKyA0KTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xuXHQgICAgICAgIC8vIFRoZXJlIGlzIG5vIGNtYXAgdGFibGUgaW4gdGhlIGZvbnQgdGhhdCB3ZSBzdXBwb3J0LlxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgY21hcCBzdWItdGFibGVzIGZvdW5kLicpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQpO1xuXHQgICAgY21hcC5mb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG5cblx0ICAgIGlmIChjbWFwLmZvcm1hdCA9PT0gMTIpIHtcblx0ICAgICAgICBwYXJzZUNtYXBUYWJsZUZvcm1hdDEyKGNtYXAsIHApO1xuXHQgICAgfSBlbHNlIGlmIChjbWFwLmZvcm1hdCA9PT0gNCkge1xuXHQgICAgICAgIHBhcnNlQ21hcFRhYmxlRm9ybWF0NChjbWFwLCBwLCBkYXRhLCBzdGFydCwgb2Zmc2V0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGZvcm1hdCA0IGFuZCAxMiBjbWFwIHRhYmxlcyBhcmUgc3VwcG9ydGVkIChmb3VuZCBmb3JtYXQgJyArIGNtYXAuZm9ybWF0ICsgJykuJyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjbWFwO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkU2VnbWVudCh0LCBjb2RlLCBnbHlwaEluZGV4KSB7XG5cdCAgICB0LnNlZ21lbnRzLnB1c2goe1xuXHQgICAgICAgIGVuZDogY29kZSxcblx0ICAgICAgICBzdGFydDogY29kZSxcblx0ICAgICAgICBkZWx0YTogLShjb2RlIC0gZ2x5cGhJbmRleCksXG5cdCAgICAgICAgb2Zmc2V0OiAwLFxuXHQgICAgICAgIGdseXBoSW5kZXg6IGdseXBoSW5kZXhcblx0ICAgIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkVGVybWluYXRvclNlZ21lbnQodCkge1xuXHQgICAgdC5zZWdtZW50cy5wdXNoKHtcblx0ICAgICAgICBlbmQ6IDB4RkZGRixcblx0ICAgICAgICBzdGFydDogMHhGRkZGLFxuXHQgICAgICAgIGRlbHRhOiAxLFxuXHQgICAgICAgIG9mZnNldDogMFxuXHQgICAgfSk7XG5cdH1cblxuXHQvLyBNYWtlIGNtYXAgdGFibGUsIGZvcm1hdCA0IGJ5IGRlZmF1bHQsIDEyIGlmIG5lZWRlZCBvbmx5XG5cdGZ1bmN0aW9uIG1ha2VDbWFwVGFibGUoZ2x5cGhzKSB7XG5cdCAgICAvLyBQbGFuIDAgaXMgdGhlIGJhc2UgVW5pY29kZSBQbGFuIGJ1dCBlbW9qaXMsIGZvciBleGFtcGxlIGFyZSBvbiBhbm90aGVyIHBsYW4sIGFuZCBuZWVkcyBjbWFwIDEyIGZvcm1hdCAod2l0aCAzMmJpdClcblx0ICAgIHZhciBpc1BsYW4wT25seSA9IHRydWU7XG5cdCAgICB2YXIgaTtcblxuXHQgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgY21hcCBmb3JtYXQgMTIgb3IgaWYgZm9ybWF0IDQgb25seSBpcyBmaW5lXG5cdCAgICBmb3IgKGkgPSBnbHlwaHMubGVuZ3RoIC0gMTsgaSA+IDA7IGkgLT0gMSkge1xuXHQgICAgICAgIHZhciBnID0gZ2x5cGhzLmdldChpKTtcblx0ICAgICAgICBpZiAoZy51bmljb2RlID4gNjU1MzUpIHtcblx0ICAgICAgICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBDTUFQIGZvcm1hdCAxMiAobmVlZGVkISknKTtcblx0ICAgICAgICAgICAgaXNQbGFuME9ubHkgPSBmYWxzZTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgY21hcFRhYmxlID0gW1xuXHQgICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdudW1UYWJsZXMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGlzUGxhbjBPbmx5ID8gMSA6IDJ9LFxuXG5cdCAgICAgICAgLy8gQ01BUCA0IGhlYWRlclxuXHQgICAgICAgIHtuYW1lOiAncGxhdGZvcm1JRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogM30sXG5cdCAgICAgICAge25hbWU6ICdlbmNvZGluZ0lEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfSxcblx0ICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBpc1BsYW4wT25seSA/IDEyIDogKDEyICsgOCl9XG5cdCAgICBdO1xuXG5cdCAgICBpZiAoIWlzUGxhbjBPbmx5KVxuXHQgICAgICAgIHsgY21hcFRhYmxlID0gY21hcFRhYmxlLmNvbmNhdChbXG5cdCAgICAgICAgICAgIC8vIENNQVAgMTIgaGVhZGVyXG5cdCAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyUGxhdGZvcm1JRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogM30sIC8vIFdlIGVuY29kZSBvbmx5IGZvciBQbGF0Zm9ybUlEID0gMyAoV2luZG93cykgYmVjYXVzZSBpdCBpcyBzdXBwb3J0ZWQgZXZlcnl3aGVyZVxuXHQgICAgICAgICAgICB7bmFtZTogJ2NtYXAxMkVuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDEwfSxcblx0ICAgICAgICAgICAge25hbWU6ICdjbWFwMTJPZmZzZXQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH1cblx0ICAgICAgICBdKTsgfVxuXG5cdCAgICBjbWFwVGFibGUgPSBjbWFwVGFibGUuY29uY2F0KFtcblx0ICAgICAgICAvLyBDTUFQIDQgU3VidGFibGVcblx0ICAgICAgICB7bmFtZTogJ2Zvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogNH0sXG5cdCAgICAgICAge25hbWU6ICdjbWFwNExlbmd0aCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdsYW5ndWFnZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdzZWdDb3VudFgyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3NlYXJjaFJhbmdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2VudHJ5U2VsZWN0b3InLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAncmFuZ2VTaGlmdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cblx0ICAgIF0pO1xuXG5cdCAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnY21hcCcsIGNtYXBUYWJsZSk7XG5cblx0ICAgIHQuc2VnbWVudHMgPSBbXTtcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuXHQgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGgudW5pY29kZXMubGVuZ3RoOyBqICs9IDEpIHtcblx0ICAgICAgICAgICAgYWRkU2VnbWVudCh0LCBnbHlwaC51bmljb2Rlc1tqXSwgaSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdC5zZWdtZW50cyA9IHQuc2VnbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpO1xuXG5cdCAgICB2YXIgc2VnQ291bnQgPSB0LnNlZ21lbnRzLmxlbmd0aDtcblx0ICAgIHZhciBzZWdDb3VudFRvUmVtb3ZlID0gMDtcblxuXHQgICAgLy8gQ01BUCA0XG5cdCAgICAvLyBTZXQgdXAgcGFyYWxsZWwgc2VnbWVudCBhcnJheXMuXG5cdCAgICB2YXIgZW5kQ291bnRzID0gW107XG5cdCAgICB2YXIgc3RhcnRDb3VudHMgPSBbXTtcblx0ICAgIHZhciBpZERlbHRhcyA9IFtdO1xuXHQgICAgdmFyIGlkUmFuZ2VPZmZzZXRzID0gW107XG5cdCAgICB2YXIgZ2x5cGhJZHMgPSBbXTtcblxuXHQgICAgLy8gQ01BUCAxMlxuXHQgICAgdmFyIGNtYXAxMkdyb3VwcyA9IFtdO1xuXG5cdCAgICAvLyBSZW1pbmRlciB0aGlzIGxvb3AgaXMgbm90IGZvbGxvd2luZyB0aGUgc3BlY2lmaWNhdGlvbiBhdCAxMDAlXG5cdCAgICAvLyBUaGUgc3BlY2lmaWNhdGlvbiAtPiBmaW5kIHN1aXRlcyBvZiBjaGFyYWN0ZXJzIGFuZCBtYWtlIGEgZ3JvdXBcblx0ICAgIC8vIEhlcmUgd2UncmUgZG9pbmcgb25lIGdyb3VwIGZvciBlYWNoIGxldHRlclxuXHQgICAgLy8gRG9pbmcgYXMgdGhlIHNwZWMgY2FuIHNhdmUgOCB0aW1lcyAob3IgbW9yZSkgc3BhY2Vcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBzZWdDb3VudDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIHNlZ21lbnQgPSB0LnNlZ21lbnRzW2ldO1xuXG5cdCAgICAgICAgLy8gQ01BUCA0XG5cdCAgICAgICAgaWYgKHNlZ21lbnQuZW5kIDw9IDY1NTM1ICYmIHNlZ21lbnQuc3RhcnQgPD0gNjU1MzUpIHtcblx0ICAgICAgICAgICAgZW5kQ291bnRzID0gZW5kQ291bnRzLmNvbmNhdCh7bmFtZTogJ2VuZF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmVuZH0pO1xuXHQgICAgICAgICAgICBzdGFydENvdW50cyA9IHN0YXJ0Q291bnRzLmNvbmNhdCh7bmFtZTogJ3N0YXJ0XycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuc3RhcnR9KTtcblx0ICAgICAgICAgICAgaWREZWx0YXMgPSBpZERlbHRhcy5jb25jYXQoe25hbWU6ICdpZERlbHRhXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5kZWx0YX0pO1xuXHQgICAgICAgICAgICBpZFJhbmdlT2Zmc2V0cyA9IGlkUmFuZ2VPZmZzZXRzLmNvbmNhdCh7bmFtZTogJ2lkUmFuZ2VPZmZzZXRfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5vZmZzZXR9KTtcblx0ICAgICAgICAgICAgaWYgKHNlZ21lbnQuZ2x5cGhJZCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICBnbHlwaElkcyA9IGdseXBoSWRzLmNvbmNhdCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuZ2x5cGhJZH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gU2tpcCBVbmljb2RlID4gNjU1MzUgKDE2Yml0IHVuc2lnbmVkIG1heCkgZm9yIENNQVAgNCwgd2lsbCBiZSBhZGRlZCBpbiBDTUFQIDEyXG5cdCAgICAgICAgICAgIHNlZ0NvdW50VG9SZW1vdmUgKz0gMTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDTUFQIDEyXG5cdCAgICAgICAgLy8gU2tpcCBUZXJtaW5hdG9yIFNlZ21lbnRcblx0ICAgICAgICBpZiAoIWlzUGxhbjBPbmx5ICYmIHNlZ21lbnQuZ2x5cGhJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIGNtYXAxMkdyb3VwcyA9IGNtYXAxMkdyb3Vwcy5jb25jYXQoe25hbWU6ICdjbWFwMTJTdGFydF8nICsgaSwgdHlwZTogJ1VMT05HJywgdmFsdWU6IHNlZ21lbnQuc3RhcnR9KTtcblx0ICAgICAgICAgICAgY21hcDEyR3JvdXBzID0gY21hcDEyR3JvdXBzLmNvbmNhdCh7bmFtZTogJ2NtYXAxMkVuZF8nICsgaSwgdHlwZTogJ1VMT05HJywgdmFsdWU6IHNlZ21lbnQuZW5kfSk7XG5cdCAgICAgICAgICAgIGNtYXAxMkdyb3VwcyA9IGNtYXAxMkdyb3Vwcy5jb25jYXQoe25hbWU6ICdjbWFwMTJHbHlwaF8nICsgaSwgdHlwZTogJ1VMT05HJywgdmFsdWU6IHNlZ21lbnQuZ2x5cGhJbmRleH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gQ01BUCA0IFN1YnRhYmxlXG5cdCAgICB0LnNlZ0NvdW50WDIgPSAoc2VnQ291bnQgLSBzZWdDb3VudFRvUmVtb3ZlKSAqIDI7XG5cdCAgICB0LnNlYXJjaFJhbmdlID0gTWF0aC5wb3coMiwgTWF0aC5mbG9vcihNYXRoLmxvZygoc2VnQ291bnQgLSBzZWdDb3VudFRvUmVtb3ZlKSkgLyBNYXRoLmxvZygyKSkpICogMjtcblx0ICAgIHQuZW50cnlTZWxlY3RvciA9IE1hdGgubG9nKHQuc2VhcmNoUmFuZ2UgLyAyKSAvIE1hdGgubG9nKDIpO1xuXHQgICAgdC5yYW5nZVNoaWZ0ID0gdC5zZWdDb3VudFgyIC0gdC5zZWFyY2hSYW5nZTtcblxuXHQgICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoZW5kQ291bnRzKTtcblx0ICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdyZXNlcnZlZFBhZCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0pO1xuXHQgICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoc3RhcnRDb3VudHMpO1xuXHQgICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoaWREZWx0YXMpO1xuXHQgICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoaWRSYW5nZU9mZnNldHMpO1xuXHQgICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoZ2x5cGhJZHMpO1xuXG5cdCAgICB0LmNtYXA0TGVuZ3RoID0gMTQgKyAvLyBTdWJ0YWJsZSBoZWFkZXJcblx0ICAgICAgICBlbmRDb3VudHMubGVuZ3RoICogMiArXG5cdCAgICAgICAgMiArIC8vIHJlc2VydmVkUGFkXG5cdCAgICAgICAgc3RhcnRDb3VudHMubGVuZ3RoICogMiArXG5cdCAgICAgICAgaWREZWx0YXMubGVuZ3RoICogMiArXG5cdCAgICAgICAgaWRSYW5nZU9mZnNldHMubGVuZ3RoICogMiArXG5cdCAgICAgICAgZ2x5cGhJZHMubGVuZ3RoICogMjtcblxuXHQgICAgaWYgKCFpc1BsYW4wT25seSkge1xuXHQgICAgICAgIC8vIENNQVAgMTIgU3VidGFibGVcblx0ICAgICAgICB2YXIgY21hcDEyTGVuZ3RoID0gMTYgKyAvLyBTdWJ0YWJsZSBoZWFkZXJcblx0ICAgICAgICAgICAgY21hcDEyR3JvdXBzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICB0LmNtYXAxMk9mZnNldCA9IDEyICsgKDIgKiAyKSArIDQgKyB0LmNtYXA0TGVuZ3RoO1xuXHQgICAgICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KFtcblx0ICAgICAgICAgICAge25hbWU6ICdjbWFwMTJGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDEyfSxcblx0ICAgICAgICAgICAge25hbWU6ICdjbWFwMTJSZXNlcnZlZCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyTGVuZ3RoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGNtYXAxMkxlbmd0aH0sXG5cdCAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyTGFuZ3VhZ2UnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAgICAgIHtuYW1lOiAnY21hcDEybkdyb3VwcycsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBjbWFwMTJHcm91cHMubGVuZ3RoIC8gM31cblx0ICAgICAgICBdKTtcblxuXHQgICAgICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGNtYXAxMkdyb3Vwcyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0O1xuXHR9XG5cblx0dmFyIGNtYXAgPSB7IHBhcnNlOiBwYXJzZUNtYXBUYWJsZSwgbWFrZTogbWFrZUNtYXBUYWJsZSB9O1xuXG5cdC8vIEdseXBoIGVuY29kaW5nXG5cblx0dmFyIGNmZlN0YW5kYXJkU3RyaW5ncyA9IFtcblx0ICAgICcubm90ZGVmJywgJ3NwYWNlJywgJ2V4Y2xhbScsICdxdW90ZWRibCcsICdudW1iZXJzaWduJywgJ2RvbGxhcicsICdwZXJjZW50JywgJ2FtcGVyc2FuZCcsICdxdW90ZXJpZ2h0Jyxcblx0ICAgICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLCAnemVybycsICdvbmUnLCAndHdvJyxcblx0ICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG5cdCAgICAncXVlc3Rpb24nLCAnYXQnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsXG5cdCAgICAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JywgJ2FzY2lpY2lyY3VtJywgJ3VuZGVyc2NvcmUnLFxuXHQgICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuXHQgICAgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6JywgJ2JyYWNlbGVmdCcsICdiYXInLCAnYnJhY2VyaWdodCcsICdhc2NpaXRpbGRlJywgJ2V4Y2xhbWRvd24nLCAnY2VudCcsICdzdGVybGluZycsXG5cdCAgICAnZnJhY3Rpb24nLCAneWVuJywgJ2Zsb3JpbicsICdzZWN0aW9uJywgJ2N1cnJlbmN5JywgJ3F1b3Rlc2luZ2xlJywgJ3F1b3RlZGJsbGVmdCcsICdndWlsbGVtb3RsZWZ0Jyxcblx0ICAgICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJ2VuZGFzaCcsICdkYWdnZXInLCAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJ3BhcmFncmFwaCcsXG5cdCAgICAnYnVsbGV0JywgJ3F1b3Rlc2luZ2xiYXNlJywgJ3F1b3RlZGJsYmFzZScsICdxdW90ZWRibHJpZ2h0JywgJ2d1aWxsZW1vdHJpZ2h0JywgJ2VsbGlwc2lzJywgJ3BlcnRob3VzYW5kJyxcblx0ICAgICdxdWVzdGlvbmRvd24nLCAnZ3JhdmUnLCAnYWN1dGUnLCAnY2lyY3VtZmxleCcsICd0aWxkZScsICdtYWNyb24nLCAnYnJldmUnLCAnZG90YWNjZW50JywgJ2RpZXJlc2lzJywgJ3JpbmcnLFxuXHQgICAgJ2NlZGlsbGEnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsICdlbWRhc2gnLCAnQUUnLCAnb3JkZmVtaW5pbmUnLCAnTHNsYXNoJywgJ09zbGFzaCcsICdPRScsXG5cdCAgICAnb3JkbWFzY3VsaW5lJywgJ2FlJywgJ2RvdGxlc3NpJywgJ2xzbGFzaCcsICdvc2xhc2gnLCAnb2UnLCAnZ2VybWFuZGJscycsICdvbmVzdXBlcmlvcicsICdsb2dpY2Fsbm90JywgJ211Jyxcblx0ICAgICd0cmFkZW1hcmsnLCAnRXRoJywgJ29uZWhhbGYnLCAncGx1c21pbnVzJywgJ1Rob3JuJywgJ29uZXF1YXJ0ZXInLCAnZGl2aWRlJywgJ2Jyb2tlbmJhcicsICdkZWdyZWUnLCAndGhvcm4nLFxuXHQgICAgJ3RocmVlcXVhcnRlcnMnLCAndHdvc3VwZXJpb3InLCAncmVnaXN0ZXJlZCcsICdtaW51cycsICdldGgnLCAnbXVsdGlwbHknLCAndGhyZWVzdXBlcmlvcicsICdjb3B5cmlnaHQnLFxuXHQgICAgJ0FhY3V0ZScsICdBY2lyY3VtZmxleCcsICdBZGllcmVzaXMnLCAnQWdyYXZlJywgJ0FyaW5nJywgJ0F0aWxkZScsICdDY2VkaWxsYScsICdFYWN1dGUnLCAnRWNpcmN1bWZsZXgnLFxuXHQgICAgJ0VkaWVyZXNpcycsICdFZ3JhdmUnLCAnSWFjdXRlJywgJ0ljaXJjdW1mbGV4JywgJ0lkaWVyZXNpcycsICdJZ3JhdmUnLCAnTnRpbGRlJywgJ09hY3V0ZScsICdPY2lyY3VtZmxleCcsXG5cdCAgICAnT2RpZXJlc2lzJywgJ09ncmF2ZScsICdPdGlsZGUnLCAnU2Nhcm9uJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsICdVZGllcmVzaXMnLCAnVWdyYXZlJywgJ1lhY3V0ZScsXG5cdCAgICAnWWRpZXJlc2lzJywgJ1pjYXJvbicsICdhYWN1dGUnLCAnYWNpcmN1bWZsZXgnLCAnYWRpZXJlc2lzJywgJ2FncmF2ZScsICdhcmluZycsICdhdGlsZGUnLCAnY2NlZGlsbGEnLCAnZWFjdXRlJyxcblx0ICAgICdlY2lyY3VtZmxleCcsICdlZGllcmVzaXMnLCAnZWdyYXZlJywgJ2lhY3V0ZScsICdpY2lyY3VtZmxleCcsICdpZGllcmVzaXMnLCAnaWdyYXZlJywgJ250aWxkZScsICdvYWN1dGUnLFxuXHQgICAgJ29jaXJjdW1mbGV4JywgJ29kaWVyZXNpcycsICdvZ3JhdmUnLCAnb3RpbGRlJywgJ3NjYXJvbicsICd1YWN1dGUnLCAndWNpcmN1bWZsZXgnLCAndWRpZXJlc2lzJywgJ3VncmF2ZScsXG5cdCAgICAneWFjdXRlJywgJ3lkaWVyZXNpcycsICd6Y2Fyb24nLCAnZXhjbGFtc21hbGwnLCAnSHVuZ2FydW1sYXV0c21hbGwnLCAnZG9sbGFyb2xkc3R5bGUnLCAnZG9sbGFyc3VwZXJpb3InLFxuXHQgICAgJ2FtcGVyc2FuZHNtYWxsJywgJ0FjdXRlc21hbGwnLCAncGFyZW5sZWZ0c3VwZXJpb3InLCAncGFyZW5yaWdodHN1cGVyaW9yJywgJzI2NiBmZicsICdvbmVkb3RlbmxlYWRlcicsXG5cdCAgICAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLCAnZm91cm9sZHN0eWxlJywgJ2ZpdmVvbGRzdHlsZScsICdzaXhvbGRzdHlsZScsXG5cdCAgICAnc2V2ZW5vbGRzdHlsZScsICdlaWdodG9sZHN0eWxlJywgJ25pbmVvbGRzdHlsZScsICdjb21tYXN1cGVyaW9yJywgJ3RocmVlcXVhcnRlcnNlbWRhc2gnLCAncGVyaW9kc3VwZXJpb3InLFxuXHQgICAgJ3F1ZXN0aW9uc21hbGwnLCAnYXN1cGVyaW9yJywgJ2JzdXBlcmlvcicsICdjZW50c3VwZXJpb3InLCAnZHN1cGVyaW9yJywgJ2VzdXBlcmlvcicsICdpc3VwZXJpb3InLCAnbHN1cGVyaW9yJyxcblx0ICAgICdtc3VwZXJpb3InLCAnbnN1cGVyaW9yJywgJ29zdXBlcmlvcicsICdyc3VwZXJpb3InLCAnc3N1cGVyaW9yJywgJ3RzdXBlcmlvcicsICdmZicsICdmZmknLCAnZmZsJyxcblx0ICAgICdwYXJlbmxlZnRpbmZlcmlvcicsICdwYXJlbnJpZ2h0aW5mZXJpb3InLCAnQ2lyY3VtZmxleHNtYWxsJywgJ2h5cGhlbnN1cGVyaW9yJywgJ0dyYXZlc21hbGwnLCAnQXNtYWxsJyxcblx0ICAgICdCc21hbGwnLCAnQ3NtYWxsJywgJ0RzbWFsbCcsICdFc21hbGwnLCAnRnNtYWxsJywgJ0dzbWFsbCcsICdIc21hbGwnLCAnSXNtYWxsJywgJ0pzbWFsbCcsICdLc21hbGwnLCAnTHNtYWxsJyxcblx0ICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcblx0ICAgICdYc21hbGwnLCAnWXNtYWxsJywgJ1pzbWFsbCcsICdjb2xvbm1vbmV0YXJ5JywgJ29uZWZpdHRlZCcsICdydXBpYWgnLCAnVGlsZGVzbWFsbCcsICdleGNsYW1kb3duc21hbGwnLFxuXHQgICAgJ2NlbnRvbGRzdHlsZScsICdMc2xhc2hzbWFsbCcsICdTY2Fyb25zbWFsbCcsICdaY2Fyb25zbWFsbCcsICdEaWVyZXNpc3NtYWxsJywgJ0JyZXZlc21hbGwnLCAnQ2Fyb25zbWFsbCcsXG5cdCAgICAnRG90YWNjZW50c21hbGwnLCAnTWFjcm9uc21hbGwnLCAnZmlndXJlZGFzaCcsICdoeXBoZW5pbmZlcmlvcicsICdPZ29uZWtzbWFsbCcsICdSaW5nc21hbGwnLCAnQ2VkaWxsYXNtYWxsJyxcblx0ICAgICdxdWVzdGlvbmRvd25zbWFsbCcsICdvbmVlaWdodGgnLCAndGhyZWVlaWdodGhzJywgJ2ZpdmVlaWdodGhzJywgJ3NldmVuZWlnaHRocycsICdvbmV0aGlyZCcsICd0d290aGlyZHMnLFxuXHQgICAgJ3plcm9zdXBlcmlvcicsICdmb3Vyc3VwZXJpb3InLCAnZml2ZXN1cGVyaW9yJywgJ3NpeHN1cGVyaW9yJywgJ3NldmVuc3VwZXJpb3InLCAnZWlnaHRzdXBlcmlvcicsICduaW5lc3VwZXJpb3InLFxuXHQgICAgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsICd0aHJlZWluZmVyaW9yJywgJ2ZvdXJpbmZlcmlvcicsICdmaXZlaW5mZXJpb3InLCAnc2l4aW5mZXJpb3InLFxuXHQgICAgJ3NldmVuaW5mZXJpb3InLCAnZWlnaHRpbmZlcmlvcicsICduaW5laW5mZXJpb3InLCAnY2VudGluZmVyaW9yJywgJ2RvbGxhcmluZmVyaW9yJywgJ3BlcmlvZGluZmVyaW9yJyxcblx0ICAgICdjb21tYWluZmVyaW9yJywgJ0FncmF2ZXNtYWxsJywgJ0FhY3V0ZXNtYWxsJywgJ0FjaXJjdW1mbGV4c21hbGwnLCAnQXRpbGRlc21hbGwnLCAnQWRpZXJlc2lzc21hbGwnLFxuXHQgICAgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJywgJ0VncmF2ZXNtYWxsJywgJ0VhY3V0ZXNtYWxsJywgJ0VjaXJjdW1mbGV4c21hbGwnLCAnRWRpZXJlc2lzc21hbGwnLFxuXHQgICAgJ0lncmF2ZXNtYWxsJywgJ0lhY3V0ZXNtYWxsJywgJ0ljaXJjdW1mbGV4c21hbGwnLCAnSWRpZXJlc2lzc21hbGwnLCAnRXRoc21hbGwnLCAnTnRpbGRlc21hbGwnLCAnT2dyYXZlc21hbGwnLFxuXHQgICAgJ09hY3V0ZXNtYWxsJywgJ09jaXJjdW1mbGV4c21hbGwnLCAnT3RpbGRlc21hbGwnLCAnT2RpZXJlc2lzc21hbGwnLCAnT0VzbWFsbCcsICdPc2xhc2hzbWFsbCcsICdVZ3JhdmVzbWFsbCcsXG5cdCAgICAnVWFjdXRlc21hbGwnLCAnVWNpcmN1bWZsZXhzbWFsbCcsICdVZGllcmVzaXNzbWFsbCcsICdZYWN1dGVzbWFsbCcsICdUaG9ybnNtYWxsJywgJ1lkaWVyZXNpc3NtYWxsJywgJzAwMS4wMDAnLFxuXHQgICAgJzAwMS4wMDEnLCAnMDAxLjAwMicsICcwMDEuMDAzJywgJ0JsYWNrJywgJ0JvbGQnLCAnQm9vaycsICdMaWdodCcsICdNZWRpdW0nLCAnUmVndWxhcicsICdSb21hbicsICdTZW1pYm9sZCddO1xuXG5cdHZhciBjZmZTdGFuZGFyZEVuY29kaW5nID0gW1xuXHQgICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG5cdCAgICAnJywgJycsICcnLCAnJywgJ3NwYWNlJywgJ2V4Y2xhbScsICdxdW90ZWRibCcsICdudW1iZXJzaWduJywgJ2RvbGxhcicsICdwZXJjZW50JywgJ2FtcGVyc2FuZCcsICdxdW90ZXJpZ2h0Jyxcblx0ICAgICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLCAnemVybycsICdvbmUnLCAndHdvJyxcblx0ICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG5cdCAgICAncXVlc3Rpb24nLCAnYXQnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsXG5cdCAgICAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JywgJ2FzY2lpY2lyY3VtJywgJ3VuZGVyc2NvcmUnLFxuXHQgICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuXHQgICAgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6JywgJ2JyYWNlbGVmdCcsICdiYXInLCAnYnJhY2VyaWdodCcsICdhc2NpaXRpbGRlJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuXHQgICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuXHQgICAgJ2V4Y2xhbWRvd24nLCAnY2VudCcsICdzdGVybGluZycsICdmcmFjdGlvbicsICd5ZW4nLCAnZmxvcmluJywgJ3NlY3Rpb24nLCAnY3VycmVuY3knLCAncXVvdGVzaW5nbGUnLFxuXHQgICAgJ3F1b3RlZGJsbGVmdCcsICdndWlsbGVtb3RsZWZ0JywgJ2d1aWxzaW5nbGxlZnQnLCAnZ3VpbHNpbmdscmlnaHQnLCAnZmknLCAnZmwnLCAnJywgJ2VuZGFzaCcsICdkYWdnZXInLFxuXHQgICAgJ2RhZ2dlcmRibCcsICdwZXJpb2RjZW50ZXJlZCcsICcnLCAncGFyYWdyYXBoJywgJ2J1bGxldCcsICdxdW90ZXNpbmdsYmFzZScsICdxdW90ZWRibGJhc2UnLCAncXVvdGVkYmxyaWdodCcsXG5cdCAgICAnZ3VpbGxlbW90cmlnaHQnLCAnZWxsaXBzaXMnLCAncGVydGhvdXNhbmQnLCAnJywgJ3F1ZXN0aW9uZG93bicsICcnLCAnZ3JhdmUnLCAnYWN1dGUnLCAnY2lyY3VtZmxleCcsICd0aWxkZScsXG5cdCAgICAnbWFjcm9uJywgJ2JyZXZlJywgJ2RvdGFjY2VudCcsICdkaWVyZXNpcycsICcnLCAncmluZycsICdjZWRpbGxhJywgJycsICdodW5nYXJ1bWxhdXQnLCAnb2dvbmVrJywgJ2Nhcm9uJyxcblx0ICAgICdlbWRhc2gnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJ0FFJywgJycsICdvcmRmZW1pbmluZScsICcnLCAnJywgJycsXG5cdCAgICAnJywgJ0xzbGFzaCcsICdPc2xhc2gnLCAnT0UnLCAnb3JkbWFzY3VsaW5lJywgJycsICcnLCAnJywgJycsICcnLCAnYWUnLCAnJywgJycsICcnLCAnZG90bGVzc2knLCAnJywgJycsXG5cdCAgICAnbHNsYXNoJywgJ29zbGFzaCcsICdvZScsICdnZXJtYW5kYmxzJ107XG5cblx0dmFyIGNmZkV4cGVydEVuY29kaW5nID0gW1xuXHQgICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG5cdCAgICAnJywgJycsICcnLCAnJywgJ3NwYWNlJywgJ2V4Y2xhbXNtYWxsJywgJ0h1bmdhcnVtbGF1dHNtYWxsJywgJycsICdkb2xsYXJvbGRzdHlsZScsICdkb2xsYXJzdXBlcmlvcicsXG5cdCAgICAnYW1wZXJzYW5kc21hbGwnLCAnQWN1dGVzbWFsbCcsICdwYXJlbmxlZnRzdXBlcmlvcicsICdwYXJlbnJpZ2h0c3VwZXJpb3InLCAndHdvZG90ZW5sZWFkZXInLCAnb25lZG90ZW5sZWFkZXInLFxuXHQgICAgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnZnJhY3Rpb24nLCAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLFxuXHQgICAgJ2ZvdXJvbGRzdHlsZScsICdmaXZlb2xkc3R5bGUnLCAnc2l4b2xkc3R5bGUnLCAnc2V2ZW5vbGRzdHlsZScsICdlaWdodG9sZHN0eWxlJywgJ25pbmVvbGRzdHlsZScsICdjb2xvbicsXG5cdCAgICAnc2VtaWNvbG9uJywgJ2NvbW1hc3VwZXJpb3InLCAndGhyZWVxdWFydGVyc2VtZGFzaCcsICdwZXJpb2RzdXBlcmlvcicsICdxdWVzdGlvbnNtYWxsJywgJycsICdhc3VwZXJpb3InLFxuXHQgICAgJ2JzdXBlcmlvcicsICdjZW50c3VwZXJpb3InLCAnZHN1cGVyaW9yJywgJ2VzdXBlcmlvcicsICcnLCAnJywgJ2lzdXBlcmlvcicsICcnLCAnJywgJ2xzdXBlcmlvcicsICdtc3VwZXJpb3InLFxuXHQgICAgJ25zdXBlcmlvcicsICdvc3VwZXJpb3InLCAnJywgJycsICdyc3VwZXJpb3InLCAnc3N1cGVyaW9yJywgJ3RzdXBlcmlvcicsICcnLCAnZmYnLCAnZmknLCAnZmwnLCAnZmZpJywgJ2ZmbCcsXG5cdCAgICAncGFyZW5sZWZ0aW5mZXJpb3InLCAnJywgJ3BhcmVucmlnaHRpbmZlcmlvcicsICdDaXJjdW1mbGV4c21hbGwnLCAnaHlwaGVuc3VwZXJpb3InLCAnR3JhdmVzbWFsbCcsICdBc21hbGwnLFxuXHQgICAgJ0JzbWFsbCcsICdDc21hbGwnLCAnRHNtYWxsJywgJ0VzbWFsbCcsICdGc21hbGwnLCAnR3NtYWxsJywgJ0hzbWFsbCcsICdJc21hbGwnLCAnSnNtYWxsJywgJ0tzbWFsbCcsICdMc21hbGwnLFxuXHQgICAgJ01zbWFsbCcsICdOc21hbGwnLCAnT3NtYWxsJywgJ1BzbWFsbCcsICdRc21hbGwnLCAnUnNtYWxsJywgJ1NzbWFsbCcsICdUc21hbGwnLCAnVXNtYWxsJywgJ1ZzbWFsbCcsICdXc21hbGwnLFxuXHQgICAgJ1hzbWFsbCcsICdZc21hbGwnLCAnWnNtYWxsJywgJ2NvbG9ubW9uZXRhcnknLCAnb25lZml0dGVkJywgJ3J1cGlhaCcsICdUaWxkZXNtYWxsJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG5cdCAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuXHQgICAgJ2V4Y2xhbWRvd25zbWFsbCcsICdjZW50b2xkc3R5bGUnLCAnTHNsYXNoc21hbGwnLCAnJywgJycsICdTY2Fyb25zbWFsbCcsICdaY2Fyb25zbWFsbCcsICdEaWVyZXNpc3NtYWxsJyxcblx0ICAgICdCcmV2ZXNtYWxsJywgJ0Nhcm9uc21hbGwnLCAnJywgJ0RvdGFjY2VudHNtYWxsJywgJycsICcnLCAnTWFjcm9uc21hbGwnLCAnJywgJycsICdmaWd1cmVkYXNoJywgJ2h5cGhlbmluZmVyaW9yJyxcblx0ICAgICcnLCAnJywgJ09nb25la3NtYWxsJywgJ1JpbmdzbWFsbCcsICdDZWRpbGxhc21hbGwnLCAnJywgJycsICcnLCAnb25lcXVhcnRlcicsICdvbmVoYWxmJywgJ3RocmVlcXVhcnRlcnMnLFxuXHQgICAgJ3F1ZXN0aW9uZG93bnNtYWxsJywgJ29uZWVpZ2h0aCcsICd0aHJlZWVpZ2h0aHMnLCAnZml2ZWVpZ2h0aHMnLCAnc2V2ZW5laWdodGhzJywgJ29uZXRoaXJkJywgJ3R3b3RoaXJkcycsICcnLFxuXHQgICAgJycsICd6ZXJvc3VwZXJpb3InLCAnb25lc3VwZXJpb3InLCAndHdvc3VwZXJpb3InLCAndGhyZWVzdXBlcmlvcicsICdmb3Vyc3VwZXJpb3InLCAnZml2ZXN1cGVyaW9yJyxcblx0ICAgICdzaXhzdXBlcmlvcicsICdzZXZlbnN1cGVyaW9yJywgJ2VpZ2h0c3VwZXJpb3InLCAnbmluZXN1cGVyaW9yJywgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsXG5cdCAgICAndGhyZWVpbmZlcmlvcicsICdmb3VyaW5mZXJpb3InLCAnZml2ZWluZmVyaW9yJywgJ3NpeGluZmVyaW9yJywgJ3NldmVuaW5mZXJpb3InLCAnZWlnaHRpbmZlcmlvcicsXG5cdCAgICAnbmluZWluZmVyaW9yJywgJ2NlbnRpbmZlcmlvcicsICdkb2xsYXJpbmZlcmlvcicsICdwZXJpb2RpbmZlcmlvcicsICdjb21tYWluZmVyaW9yJywgJ0FncmF2ZXNtYWxsJyxcblx0ICAgICdBYWN1dGVzbWFsbCcsICdBY2lyY3VtZmxleHNtYWxsJywgJ0F0aWxkZXNtYWxsJywgJ0FkaWVyZXNpc3NtYWxsJywgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJyxcblx0ICAgICdFZ3JhdmVzbWFsbCcsICdFYWN1dGVzbWFsbCcsICdFY2lyY3VtZmxleHNtYWxsJywgJ0VkaWVyZXNpc3NtYWxsJywgJ0lncmF2ZXNtYWxsJywgJ0lhY3V0ZXNtYWxsJyxcblx0ICAgICdJY2lyY3VtZmxleHNtYWxsJywgJ0lkaWVyZXNpc3NtYWxsJywgJ0V0aHNtYWxsJywgJ050aWxkZXNtYWxsJywgJ09ncmF2ZXNtYWxsJywgJ09hY3V0ZXNtYWxsJyxcblx0ICAgICdPY2lyY3VtZmxleHNtYWxsJywgJ090aWxkZXNtYWxsJywgJ09kaWVyZXNpc3NtYWxsJywgJ09Fc21hbGwnLCAnT3NsYXNoc21hbGwnLCAnVWdyYXZlc21hbGwnLCAnVWFjdXRlc21hbGwnLFxuXHQgICAgJ1VjaXJjdW1mbGV4c21hbGwnLCAnVWRpZXJlc2lzc21hbGwnLCAnWWFjdXRlc21hbGwnLCAnVGhvcm5zbWFsbCcsICdZZGllcmVzaXNzbWFsbCddO1xuXG5cdHZhciBzdGFuZGFyZE5hbWVzID0gW1xuXHQgICAgJy5ub3RkZWYnLCAnLm51bGwnLCAnbm9ubWFya2luZ3JldHVybicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsXG5cdCAgICAnYW1wZXJzYW5kJywgJ3F1b3Rlc2luZ2xlJywgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsXG5cdCAgICAnemVybycsICdvbmUnLCAndHdvJywgJ3RocmVlJywgJ2ZvdXInLCAnZml2ZScsICdzaXgnLCAnc2V2ZW4nLCAnZWlnaHQnLCAnbmluZScsICdjb2xvbicsICdzZW1pY29sb24nLCAnbGVzcycsXG5cdCAgICAnZXF1YWwnLCAnZ3JlYXRlcicsICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsXG5cdCAgICAnUCcsICdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLFxuXHQgICAgJ2FzY2lpY2lyY3VtJywgJ3VuZGVyc2NvcmUnLCAnZ3JhdmUnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLFxuXHQgICAgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsXG5cdCAgICAnQWRpZXJlc2lzJywgJ0FyaW5nJywgJ0NjZWRpbGxhJywgJ0VhY3V0ZScsICdOdGlsZGUnLCAnT2RpZXJlc2lzJywgJ1VkaWVyZXNpcycsICdhYWN1dGUnLCAnYWdyYXZlJyxcblx0ICAgICdhY2lyY3VtZmxleCcsICdhZGllcmVzaXMnLCAnYXRpbGRlJywgJ2FyaW5nJywgJ2NjZWRpbGxhJywgJ2VhY3V0ZScsICdlZ3JhdmUnLCAnZWNpcmN1bWZsZXgnLCAnZWRpZXJlc2lzJyxcblx0ICAgICdpYWN1dGUnLCAnaWdyYXZlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdudGlsZGUnLCAnb2FjdXRlJywgJ29ncmF2ZScsICdvY2lyY3VtZmxleCcsICdvZGllcmVzaXMnLFxuXHQgICAgJ290aWxkZScsICd1YWN1dGUnLCAndWdyYXZlJywgJ3VjaXJjdW1mbGV4JywgJ3VkaWVyZXNpcycsICdkYWdnZXInLCAnZGVncmVlJywgJ2NlbnQnLCAnc3RlcmxpbmcnLCAnc2VjdGlvbicsXG5cdCAgICAnYnVsbGV0JywgJ3BhcmFncmFwaCcsICdnZXJtYW5kYmxzJywgJ3JlZ2lzdGVyZWQnLCAnY29weXJpZ2h0JywgJ3RyYWRlbWFyaycsICdhY3V0ZScsICdkaWVyZXNpcycsICdub3RlcXVhbCcsXG5cdCAgICAnQUUnLCAnT3NsYXNoJywgJ2luZmluaXR5JywgJ3BsdXNtaW51cycsICdsZXNzZXF1YWwnLCAnZ3JlYXRlcmVxdWFsJywgJ3llbicsICdtdScsICdwYXJ0aWFsZGlmZicsICdzdW1tYXRpb24nLFxuXHQgICAgJ3Byb2R1Y3QnLCAncGknLCAnaW50ZWdyYWwnLCAnb3JkZmVtaW5pbmUnLCAnb3JkbWFzY3VsaW5lJywgJ09tZWdhJywgJ2FlJywgJ29zbGFzaCcsICdxdWVzdGlvbmRvd24nLFxuXHQgICAgJ2V4Y2xhbWRvd24nLCAnbG9naWNhbG5vdCcsICdyYWRpY2FsJywgJ2Zsb3JpbicsICdhcHByb3hlcXVhbCcsICdEZWx0YScsICdndWlsbGVtb3RsZWZ0JywgJ2d1aWxsZW1vdHJpZ2h0Jyxcblx0ICAgICdlbGxpcHNpcycsICdub25icmVha2luZ3NwYWNlJywgJ0FncmF2ZScsICdBdGlsZGUnLCAnT3RpbGRlJywgJ09FJywgJ29lJywgJ2VuZGFzaCcsICdlbWRhc2gnLCAncXVvdGVkYmxsZWZ0Jyxcblx0ICAgICdxdW90ZWRibHJpZ2h0JywgJ3F1b3RlbGVmdCcsICdxdW90ZXJpZ2h0JywgJ2RpdmlkZScsICdsb3plbmdlJywgJ3lkaWVyZXNpcycsICdZZGllcmVzaXMnLCAnZnJhY3Rpb24nLFxuXHQgICAgJ2N1cnJlbmN5JywgJ2d1aWxzaW5nbGxlZnQnLCAnZ3VpbHNpbmdscmlnaHQnLCAnZmknLCAnZmwnLCAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJ3F1b3Rlc2luZ2xiYXNlJyxcblx0ICAgICdxdW90ZWRibGJhc2UnLCAncGVydGhvdXNhbmQnLCAnQWNpcmN1bWZsZXgnLCAnRWNpcmN1bWZsZXgnLCAnQWFjdXRlJywgJ0VkaWVyZXNpcycsICdFZ3JhdmUnLCAnSWFjdXRlJyxcblx0ICAgICdJY2lyY3VtZmxleCcsICdJZGllcmVzaXMnLCAnSWdyYXZlJywgJ09hY3V0ZScsICdPY2lyY3VtZmxleCcsICdhcHBsZScsICdPZ3JhdmUnLCAnVWFjdXRlJywgJ1VjaXJjdW1mbGV4Jyxcblx0ICAgICdVZ3JhdmUnLCAnZG90bGVzc2knLCAnY2lyY3VtZmxleCcsICd0aWxkZScsICdtYWNyb24nLCAnYnJldmUnLCAnZG90YWNjZW50JywgJ3JpbmcnLCAnY2VkaWxsYScsICdodW5nYXJ1bWxhdXQnLFxuXHQgICAgJ29nb25laycsICdjYXJvbicsICdMc2xhc2gnLCAnbHNsYXNoJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWmNhcm9uJywgJ3pjYXJvbicsICdicm9rZW5iYXInLCAnRXRoJywgJ2V0aCcsXG5cdCAgICAnWWFjdXRlJywgJ3lhY3V0ZScsICdUaG9ybicsICd0aG9ybicsICdtaW51cycsICdtdWx0aXBseScsICdvbmVzdXBlcmlvcicsICd0d29zdXBlcmlvcicsICd0aHJlZXN1cGVyaW9yJyxcblx0ICAgICdvbmVoYWxmJywgJ29uZXF1YXJ0ZXInLCAndGhyZWVxdWFydGVycycsICdmcmFuYycsICdHYnJldmUnLCAnZ2JyZXZlJywgJ0lkb3RhY2NlbnQnLCAnU2NlZGlsbGEnLCAnc2NlZGlsbGEnLFxuXHQgICAgJ0NhY3V0ZScsICdjYWN1dGUnLCAnQ2Nhcm9uJywgJ2NjYXJvbicsICdkY3JvYXQnXTtcblxuXHQvKipcblx0ICogVGhpcyBpcyB0aGUgZW5jb2RpbmcgdXNlZCBmb3IgZm9udHMgY3JlYXRlZCBmcm9tIHNjcmF0Y2guXG5cdCAqIEl0IGxvb3BzIHRocm91Z2ggYWxsIGdseXBocyBhbmQgZmluZHMgdGhlIGFwcHJvcHJpYXRlIHVuaWNvZGUgdmFsdWUuXG5cdCAqIFNpbmNlIGl0J3MgbGluZWFyIHRpbWUsIG90aGVyIGVuY29kaW5ncyB3aWxsIGJlIGZhc3Rlci5cblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuRGVmYXVsdEVuY29kaW5nXG5cdCAqIEBjbGFzc1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuXHQgKi9cblx0ZnVuY3Rpb24gRGVmYXVsdEVuY29kaW5nKGZvbnQpIHtcblx0ICAgIHRoaXMuZm9udCA9IGZvbnQ7XG5cdH1cblxuXHREZWZhdWx0RW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbihjKSB7XG5cdCAgICB2YXIgY29kZSA9IGMuY29kZVBvaW50QXQoMCk7XG5cdCAgICB2YXIgZ2x5cGhzID0gdGhpcy5mb250LmdseXBocztcblx0ICAgIGlmIChnbHlwaHMpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBoLnVuaWNvZGVzLmxlbmd0aDsgaiArPSAxKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZ2x5cGgudW5pY29kZXNbal0gPT09IGNvZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZXhwb3J0cyBvcGVudHlwZS5DbWFwRW5jb2Rpbmdcblx0ICogQGNsYXNzXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gY21hcCAtIGEgb2JqZWN0IHdpdGggdGhlIGNtYXAgZW5jb2RlZCBkYXRhXG5cdCAqL1xuXHRmdW5jdGlvbiBDbWFwRW5jb2RpbmcoY21hcCkge1xuXHQgICAgdGhpcy5jbWFwID0gY21hcDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IGMgLSB0aGUgY2hhcmFjdGVyXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGdseXBoIGluZGV4LlxuXHQgKi9cblx0Q21hcEVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24oYykge1xuXHQgICAgcmV0dXJuIHRoaXMuY21hcC5nbHlwaEluZGV4TWFwW2MuY29kZVBvaW50QXQoMCldIHx8IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLkNmZkVuY29kaW5nXG5cdCAqIEBjbGFzc1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIC0gVGhlIGVuY29kaW5nXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNoYXJzZXQgLSBUaGUgY2hhcmFjdGVyIHNldC5cblx0ICovXG5cdGZ1bmN0aW9uIENmZkVuY29kaW5nKGVuY29kaW5nLCBjaGFyc2V0KSB7XG5cdCAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG5cdCAgICB0aGlzLmNoYXJzZXQgPSBjaGFyc2V0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gcyAtIFRoZSBjaGFyYWN0ZXJcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXguXG5cdCAqL1xuXHRDZmZFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKHMpIHtcblx0ICAgIHZhciBjb2RlID0gcy5jb2RlUG9pbnRBdCgwKTtcblx0ICAgIHZhciBjaGFyTmFtZSA9IHRoaXMuZW5jb2RpbmdbY29kZV07XG5cdCAgICByZXR1cm4gdGhpcy5jaGFyc2V0LmluZGV4T2YoY2hhck5hbWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAZXhwb3J0cyBvcGVudHlwZS5HbHlwaE5hbWVzXG5cdCAqIEBjbGFzc1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHBvc3Rcblx0ICovXG5cdGZ1bmN0aW9uIEdseXBoTmFtZXMocG9zdCkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIHN3aXRjaCAocG9zdC52ZXJzaW9uKSB7XG5cdCAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICB0aGlzLm5hbWVzID0gc3RhbmRhcmROYW1lcy5zbGljZSgpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgIHRoaXMubmFtZXMgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocG9zdC5nbHlwaE5hbWVJbmRleFtpXSA8IHN0YW5kYXJkTmFtZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcyQxLm5hbWVzW2ldID0gc3RhbmRhcmROYW1lc1twb3N0LmdseXBoTmFtZUluZGV4W2ldXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcyQxLm5hbWVzW2ldID0gcG9zdC5uYW1lc1twb3N0LmdseXBoTmFtZUluZGV4W2ldIC0gc3RhbmRhcmROYW1lcy5sZW5ndGhdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAyLjU6XG5cdCAgICAgICAgICAgIHRoaXMubmFtZXMgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkkMSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzJDEubmFtZXNbaSQxXSA9IHN0YW5kYXJkTmFtZXNbaSQxICsgcG9zdC5nbHlwaE5hbWVJbmRleFtpJDFdXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgdGhpcy5uYW1lcyA9IFtdO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICB0aGlzLm5hbWVzID0gW107XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGluZGV4IG9mIGEgZ2x5cGggYnkgbmFtZS5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIC0gVGhlIGdseXBoIG5hbWVcblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXhcblx0ICovXG5cdEdseXBoTmFtZXMucHJvdG90eXBlLm5hbWVUb0dseXBoSW5kZXggPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICByZXR1cm4gdGhpcy5uYW1lcy5pbmRleE9mKG5hbWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IGdpZFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRHbHlwaE5hbWVzLnByb3RvdHlwZS5nbHlwaEluZGV4VG9OYW1lID0gZnVuY3Rpb24oZ2lkKSB7XG5cdCAgICByZXR1cm4gdGhpcy5uYW1lc1tnaWRdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAYWxpYXMgb3BlbnR5cGUuYWRkR2x5cGhOYW1lc1xuXHQgKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRHbHlwaE5hbWVzKGZvbnQpIHtcblx0ICAgIHZhciBnbHlwaDtcblx0ICAgIHZhciBnbHlwaEluZGV4TWFwID0gZm9udC50YWJsZXMuY21hcC5nbHlwaEluZGV4TWFwO1xuXHQgICAgdmFyIGNoYXJDb2RlcyA9IE9iamVjdC5rZXlzKGdseXBoSW5kZXhNYXApO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJDb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBjID0gY2hhckNvZGVzW2ldO1xuXHQgICAgICAgIHZhciBnbHlwaEluZGV4ID0gZ2x5cGhJbmRleE1hcFtjXTtcblx0ICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcblx0ICAgICAgICBnbHlwaC5hZGRVbmljb2RlKHBhcnNlSW50KGMpKTtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgZm9udC5nbHlwaHMubGVuZ3RoOyBpJDEgKz0gMSkge1xuXHQgICAgICAgIGdseXBoID0gZm9udC5nbHlwaHMuZ2V0KGkkMSk7XG5cdCAgICAgICAgaWYgKGZvbnQuY2ZmRW5jb2RpbmcpIHtcblx0ICAgICAgICAgICAgaWYgKGZvbnQuaXNDSURGb250KSB7XG5cdCAgICAgICAgICAgICAgICBnbHlwaC5uYW1lID0gJ2dpZCcgKyBpJDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBnbHlwaC5uYW1lID0gZm9udC5jZmZFbmNvZGluZy5jaGFyc2V0W2kkMV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKGZvbnQuZ2x5cGhOYW1lcy5uYW1lcykge1xuXHQgICAgICAgICAgICBnbHlwaC5uYW1lID0gZm9udC5nbHlwaE5hbWVzLmdseXBoSW5kZXhUb05hbWUoaSQxKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdH1cblxuXHQvLyBEcmF3aW5nIHV0aWxpdHkgZnVuY3Rpb25zLlxuXG5cdC8vIERyYXcgYSBsaW5lIG9uIHRoZSBnaXZlbiBjb250ZXh0IGZyb20gcG9pbnQgYHgxLHkxYCB0byBwb2ludCBgeDIseTJgLlxuXHRmdW5jdGlvbiBsaW5lKGN0eCwgeDEsIHkxLCB4MiwgeTIpIHtcblx0ICAgIGN0eC5iZWdpblBhdGgoKTtcblx0ICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblx0ICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcblx0ICAgIGN0eC5zdHJva2UoKTtcblx0fVxuXG5cdHZhciBkcmF3ID0geyBsaW5lOiBsaW5lIH07XG5cblx0Ly8gVGhlIEdseXBoIG9iamVjdFxuXHQvLyBpbXBvcnQgZ2x5ZiBmcm9tICcuL3RhYmxlcy9nbHlmJyBDYW4ndCBiZSBpbXBvcnRlZCBoZXJlLCBiZWNhdXNlIGl0J3MgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG5cblx0ZnVuY3Rpb24gZ2V0UGF0aERlZmluaXRpb24oZ2x5cGgsIHBhdGgpIHtcblx0ICAgIHZhciBfcGF0aCA9IHBhdGggfHwgbmV3IFBhdGgoKTtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBfcGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgX3BhdGggPSBfcGF0aCgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIF9wYXRoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKHApIHtcblx0ICAgICAgICAgICAgX3BhdGggPSBwO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdH1cblx0LyoqXG5cdCAqIEB0eXBlZGVmIEdseXBoT3B0aW9uc1xuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBnbHlwaCBuYW1lXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdW5pY29kZV1cblx0ICogQHByb3BlcnR5IHtBcnJheX0gW3VuaWNvZGVzXVxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3hNaW5dXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeU1pbl1cblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFt4TWF4XVxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3lNYXhdXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYWR2YW5jZVdpZHRoXVxuXHQgKi9cblxuXHQvLyBBIEdseXBoIGlzIGFuIGluZGl2aWR1YWwgbWFyayB0aGF0IG9mdGVuIGNvcnJlc3BvbmRzIHRvIGEgY2hhcmFjdGVyLlxuXHQvLyBTb21lIGdseXBocywgc3VjaCBhcyBsaWdhdHVyZXMsIGFyZSBhIGNvbWJpbmF0aW9uIG9mIG1hbnkgY2hhcmFjdGVycy5cblx0Ly8gR2x5cGhzIGFyZSB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2tzIG9mIGEgZm9udC5cblx0Ly9cblx0Ly8gVGhlIGBHbHlwaGAgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciBkcmF3aW5nIHRoZSBwYXRoIGFuZCBpdHMgcG9pbnRzLlxuXHQvKipcblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuR2x5cGhcblx0ICogQGNsYXNzXG5cdCAqIEBwYXJhbSB7R2x5cGhPcHRpb25zfVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEdseXBoKG9wdGlvbnMpIHtcblx0ICAgIC8vIEJ5IHB1dHRpbmcgYWxsIHRoZSBjb2RlIG9uIGEgcHJvdG90eXBlIGZ1bmN0aW9uICh3aGljaCBpcyBvbmx5IGRlY2xhcmVkIG9uY2UpXG5cdCAgICAvLyB3ZSByZWR1Y2UgdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgZm9yIGxhcmdlciBmb250cyBieSBzb21lIDIlXG5cdCAgICB0aGlzLmJpbmRDb25zdHJ1Y3RvclZhbHVlcyhvcHRpb25zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtHbHlwaE9wdGlvbnN9XG5cdCAqL1xuXHRHbHlwaC5wcm90b3R5cGUuYmluZENvbnN0cnVjdG9yVmFsdWVzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcblxuXHQgICAgLy8gVGhlc2UgdGhyZWUgdmFsdWVzIGNhbm5vdCBiZSBkZWZlcnJlZCBmb3IgbWVtb3J5IG9wdGltaXphdGlvbjpcblx0ICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBudWxsO1xuXHQgICAgdGhpcy51bmljb2RlID0gb3B0aW9ucy51bmljb2RlIHx8IHVuZGVmaW5lZDtcblx0ICAgIHRoaXMudW5pY29kZXMgPSBvcHRpb25zLnVuaWNvZGVzIHx8IG9wdGlvbnMudW5pY29kZSAhPT0gdW5kZWZpbmVkID8gW29wdGlvbnMudW5pY29kZV0gOiBbXTtcblxuXHQgICAgLy8gQnV0IGJ5IGJpbmRpbmcgdGhlc2UgdmFsdWVzIG9ubHkgd2hlbiBuZWNlc3NhcnksIHdlIHJlZHVjZSBjYW5cblx0ICAgIC8vIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGJ5IGFsbW9zdCAzJSBmb3IgbGFyZ2VyIGZvbnRzLlxuXHQgICAgaWYgKG9wdGlvbnMueE1pbikge1xuXHQgICAgICAgIHRoaXMueE1pbiA9IG9wdGlvbnMueE1pbjtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9wdGlvbnMueU1pbikge1xuXHQgICAgICAgIHRoaXMueU1pbiA9IG9wdGlvbnMueU1pbjtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9wdGlvbnMueE1heCkge1xuXHQgICAgICAgIHRoaXMueE1heCA9IG9wdGlvbnMueE1heDtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9wdGlvbnMueU1heCkge1xuXHQgICAgICAgIHRoaXMueU1heCA9IG9wdGlvbnMueU1heDtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9wdGlvbnMuYWR2YW5jZVdpZHRoKSB7XG5cdCAgICAgICAgdGhpcy5hZHZhbmNlV2lkdGggPSBvcHRpb25zLmFkdmFuY2VXaWR0aDtcblx0ICAgIH1cblxuXHQgICAgLy8gVGhlIHBhdGggZm9yIGEgZ2x5cGggaXMgdGhlIG1vc3QgbWVtb3J5IGludGVuc2l2ZSwgYW5kIGlzIGJvdW5kIGFzIGEgdmFsdWVcblx0ICAgIC8vIHdpdGggYSBnZXR0ZXIvc2V0dGVyIHRvIGVuc3VyZSB3ZSBhY3R1YWxseSBkbyBwYXRoIHBhcnNpbmcgb25seSBvbmNlIHRoZVxuXHQgICAgLy8gcGF0aCBpcyBhY3R1YWxseSBuZWVkZWQgYnkgYW55dGhpbmcuXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3BhdGgnLCBnZXRQYXRoRGVmaW5pdGlvbih0aGlzLCBvcHRpb25zLnBhdGgpKTtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9XG5cdCAqL1xuXHRHbHlwaC5wcm90b3R5cGUuYWRkVW5pY29kZSA9IGZ1bmN0aW9uKHVuaWNvZGUpIHtcblx0ICAgIGlmICh0aGlzLnVuaWNvZGVzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIHRoaXMudW5pY29kZSA9IHVuaWNvZGU7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMudW5pY29kZXMucHVzaCh1bmljb2RlKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIGJvdW5kaW5nIGJveCBmb3IgdGhpcyBnbHlwaC5cblx0ICogQHJldHVybiB7b3BlbnR5cGUuQm91bmRpbmdCb3h9XG5cdCAqL1xuXHRHbHlwaC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiB0aGlzLnBhdGguZ2V0Qm91bmRpbmdCb3goKTtcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydCB0aGUgZ2x5cGggdG8gYSBQYXRoIHdlIGNhbiBkcmF3IG9uIGEgZHJhd2luZyBjb250ZXh0LlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG5cdCAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnMgLSB4U2NhbGUsIHlTY2FsZSB0byBzdHJldGNoIHRoZSBnbHlwaC5cblx0ICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gaWYgaGludGluZyBpcyB0byBiZSB1c2VkLCB0aGUgZm9udFxuXHQgKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRofVxuXHQgKi9cblx0R2x5cGgucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbih4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZm9udCkge1xuXHQgICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuXHQgICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuXHQgICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiA3Mjtcblx0ICAgIHZhciBjb21tYW5kcztcblx0ICAgIHZhciBoUG9pbnRzO1xuXHQgICAgaWYgKCFvcHRpb25zKSB7IG9wdGlvbnMgPSB7IH07IH1cblx0ICAgIHZhciB4U2NhbGUgPSBvcHRpb25zLnhTY2FsZTtcblx0ICAgIHZhciB5U2NhbGUgPSBvcHRpb25zLnlTY2FsZTtcblxuXHQgICAgaWYgKG9wdGlvbnMuaGludGluZyAmJiBmb250ICYmIGZvbnQuaGludGluZykge1xuXHQgICAgICAgIC8vIGluIGNhc2Ugb2YgaGludGluZywgdGhlIGhpbnRpbmcgZW5naW5lIHRha2VzIGNhcmVcblx0ICAgICAgICAvLyBvZiBzY2FsaW5nIHRoZSBwb2ludHMgKG5vdCB0aGUgcGF0aCkgYmVmb3JlIGhpbnRpbmcuXG5cdCAgICAgICAgaFBvaW50cyA9IHRoaXMucGF0aCAmJiBmb250LmhpbnRpbmcuZXhlYyh0aGlzLCBmb250U2l6ZSk7XG5cdCAgICAgICAgLy8gaW4gY2FzZSB0aGUgaGludGluZyBlbmdpbmUgZmFpbGVkIGhQb2ludHMgaXMgdW5kZWZpbmVkXG5cdCAgICAgICAgLy8gYW5kIHRodXMgcmV2ZXJ0cyB0byBwbGFpbiByZW5kaW5nXG5cdCAgICB9XG5cblx0ICAgIGlmIChoUG9pbnRzKSB7XG5cdCAgICAgICAgLy8gQ2FsbCBmb250LmhpbnRpbmcuZ2V0Q29tbWFuZHMgaW5zdGVhZCBvZiBgZ2x5Zi5nZXRQYXRoKGhQb2ludHMpLmNvbW1hbmRzYCB0byBhdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcblx0ICAgICAgICBjb21tYW5kcyA9IGZvbnQuaGludGluZy5nZXRDb21tYW5kcyhoUG9pbnRzKTtcblx0ICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcblx0ICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcblx0ICAgICAgICAvLyBUT0RPIGluIGNhc2Ugb2YgaGludGluZyB4eVNjYWxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcblx0ICAgICAgICB4U2NhbGUgPSB5U2NhbGUgPSAxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBjb21tYW5kcyA9IHRoaXMucGF0aC5jb21tYW5kcztcblx0ICAgICAgICB2YXIgc2NhbGUgPSAxIC8gdGhpcy5wYXRoLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcblx0ICAgICAgICBpZiAoeFNjYWxlID09PSB1bmRlZmluZWQpIHsgeFNjYWxlID0gc2NhbGU7IH1cblx0ICAgICAgICBpZiAoeVNjYWxlID09PSB1bmRlZmluZWQpIHsgeVNjYWxlID0gc2NhbGU7IH1cblx0ICAgIH1cblxuXHQgICAgdmFyIHAgPSBuZXcgUGF0aCgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcblx0ICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuXHQgICAgICAgICAgICBwLm1vdmVUbyh4ICsgKGNtZC54ICogeFNjYWxlKSwgeSArICgtY21kLnkgKiB5U2NhbGUpKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcblx0ICAgICAgICAgICAgcC5saW5lVG8oeCArIChjbWQueCAqIHhTY2FsZSksIHkgKyAoLWNtZC55ICogeVNjYWxlKSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG5cdCAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyh4ICsgKGNtZC54MSAqIHhTY2FsZSksIHkgKyAoLWNtZC55MSAqIHlTY2FsZSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ICsgKGNtZC54ICogeFNjYWxlKSwgeSArICgtY21kLnkgKiB5U2NhbGUpKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcblx0ICAgICAgICAgICAgcC5jdXJ2ZVRvKHggKyAoY21kLngxICogeFNjYWxlKSwgeSArICgtY21kLnkxICogeVNjYWxlKSxcblx0ICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLngyICogeFNjYWxlKSwgeSArICgtY21kLnkyICogeVNjYWxlKSxcblx0ICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLnggKiB4U2NhbGUpLCB5ICsgKC1jbWQueSAqIHlTY2FsZSkpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuXHQgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHA7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNwbGl0IHRoZSBnbHlwaCBpbnRvIGNvbnRvdXJzLlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBhbmQgdG9cblx0ICogcHJvdmlkZSByYXcgYWNjZXNzIHRvIHRoZSBUcnVlVHlwZSBnbHlwaCBvdXRsaW5lcy5cblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqL1xuXHRHbHlwaC5wcm90b3R5cGUuZ2V0Q29udG91cnMgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICBpZiAodGhpcy5wb2ludHMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiBbXTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNvbnRvdXJzID0gW107XG5cdCAgICB2YXIgY3VycmVudENvbnRvdXIgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgcHQgPSB0aGlzJDEucG9pbnRzW2ldO1xuXHQgICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuXHQgICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcblx0ICAgICAgICAgICAgY29udG91cnMucHVzaChjdXJyZW50Q29udG91cik7XG5cdCAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcblx0ICAgIHJldHVybiBjb250b3Vycztcblx0fTtcblxuXHQvKipcblx0ICogQ2FsY3VsYXRlIHRoZSB4TWluL3lNaW4veE1heC95TWF4L2xzYi9yc2IgZm9yIGEgR2x5cGguXG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICovXG5cdEdseXBoLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgY29tbWFuZHMgPSB0aGlzLnBhdGguY29tbWFuZHM7XG5cdCAgICB2YXIgeENvb3JkcyA9IFtdO1xuXHQgICAgdmFyIHlDb29yZHMgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgY21kID0gY29tbWFuZHNbaV07XG5cdCAgICAgICAgaWYgKGNtZC50eXBlICE9PSAnWicpIHtcblx0ICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54KTtcblx0ICAgICAgICAgICAgeUNvb3Jkcy5wdXNoKGNtZC55KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdRJyB8fCBjbWQudHlwZSA9PT0gJ0MnKSB7XG5cdCAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueDEpO1xuXHQgICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkxKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuXHQgICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngyKTtcblx0ICAgICAgICAgICAgeUNvb3Jkcy5wdXNoKGNtZC55Mik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgbWV0cmljcyA9IHtcblx0ICAgICAgICB4TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB4Q29vcmRzKSxcblx0ICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5Q29vcmRzKSxcblx0ICAgICAgICB4TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB4Q29vcmRzKSxcblx0ICAgICAgICB5TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB5Q29vcmRzKSxcblx0ICAgICAgICBsZWZ0U2lkZUJlYXJpbmc6IHRoaXMubGVmdFNpZGVCZWFyaW5nXG5cdCAgICB9O1xuXG5cdCAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueE1pbikpIHtcblx0ICAgICAgICBtZXRyaWNzLnhNaW4gPSAwO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueE1heCkpIHtcblx0ICAgICAgICBtZXRyaWNzLnhNYXggPSB0aGlzLmFkdmFuY2VXaWR0aDtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnlNaW4pKSB7XG5cdCAgICAgICAgbWV0cmljcy55TWluID0gMDtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnlNYXgpKSB7XG5cdCAgICAgICAgbWV0cmljcy55TWF4ID0gMDtcblx0ICAgIH1cblxuXHQgICAgbWV0cmljcy5yaWdodFNpZGVCZWFyaW5nID0gdGhpcy5hZHZhbmNlV2lkdGggLSBtZXRyaWNzLmxlZnRTaWRlQmVhcmluZyAtIChtZXRyaWNzLnhNYXggLSBtZXRyaWNzLnhNaW4pO1xuXHQgICAgcmV0dXJuIG1ldHJpY3M7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXcgdGhlIGdseXBoIG9uIHRoZSBnaXZlbiBjb250ZXh0LlxuXHQgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuXHQgKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zIC0geFNjYWxlLCB5U2NhbGUgdG8gc3RyZXRjaCB0aGUgZ2x5cGguXG5cdCAqL1xuXHRHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcblx0ICAgIHRoaXMuZ2V0UGF0aCh4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykuZHJhdyhjdHgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3IHRoZSBwb2ludHMgb2YgdGhlIGdseXBoLlxuXHQgKiBPbi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiBibHVlLCBvZmYtY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gcmVkLlxuXHQgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuXHQgKi9cblx0R2x5cGgucHJvdG90eXBlLmRyYXdQb2ludHMgPSBmdW5jdGlvbihjdHgsIHgsIHksIGZvbnRTaXplKSB7XG5cdCAgICBmdW5jdGlvbiBkcmF3Q2lyY2xlcyhsLCB4LCB5LCBzY2FsZSkge1xuXHQgICAgICAgIHZhciBQSV9TUSA9IE1hdGguUEkgKiAyO1xuXHQgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGwubGVuZ3RoOyBqICs9IDEpIHtcblx0ICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgKGxbal0ueCAqIHNjYWxlKSwgeSArIChsW2pdLnkgKiBzY2FsZSkpO1xuXHQgICAgICAgICAgICBjdHguYXJjKHggKyAobFtqXS54ICogc2NhbGUpLCB5ICsgKGxbal0ueSAqIHNjYWxlKSwgMiwgMCwgUElfU1EsIGZhbHNlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG5cdCAgICAgICAgY3R4LmZpbGwoKTtcblx0ICAgIH1cblxuXHQgICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuXHQgICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuXHQgICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiAyNDtcblx0ICAgIHZhciBzY2FsZSA9IDEgLyB0aGlzLnBhdGgudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG5cdCAgICB2YXIgYmx1ZUNpcmNsZXMgPSBbXTtcblx0ICAgIHZhciByZWRDaXJjbGVzID0gW107XG5cdCAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBjbWQgPSBwYXRoLmNvbW1hbmRzW2ldO1xuXHQgICAgICAgIGlmIChjbWQueCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIGJsdWVDaXJjbGVzLnB1c2goe3g6IGNtZC54LCB5OiAtY21kLnl9KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoY21kLngxICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgcmVkQ2lyY2xlcy5wdXNoKHt4OiBjbWQueDEsIHk6IC1jbWQueTF9KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoY21kLngyICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgcmVkQ2lyY2xlcy5wdXNoKHt4OiBjbWQueDIsIHk6IC1jbWQueTJ9KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGN0eC5maWxsU3R5bGUgPSAnYmx1ZSc7XG5cdCAgICBkcmF3Q2lyY2xlcyhibHVlQ2lyY2xlcywgeCwgeSwgc2NhbGUpO1xuXHQgICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuXHQgICAgZHJhd0NpcmNsZXMocmVkQ2lyY2xlcywgeCwgeSwgc2NhbGUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3IGxpbmVzIGluZGljYXRpbmcgaW1wb3J0YW50IGZvbnQgbWVhc3VyZW1lbnRzLlxuXHQgKiBCbGFjayBsaW5lcyBpbmRpY2F0ZSB0aGUgb3JpZ2luIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSAocG9pbnQgMCwwKS5cblx0ICogQmx1ZSBsaW5lcyBpbmRpY2F0ZSB0aGUgZ2x5cGggYm91bmRpbmcgYm94LlxuXHQgKiBHcmVlbiBsaW5lIGluZGljYXRlcyB0aGUgYWR2YW5jZSB3aWR0aCBvZiB0aGUgZ2x5cGguXG5cdCAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG5cdCAqL1xuXHRHbHlwaC5wcm90b3R5cGUuZHJhd01ldHJpY3MgPSBmdW5jdGlvbihjdHgsIHgsIHksIGZvbnRTaXplKSB7XG5cdCAgICB2YXIgc2NhbGU7XG5cdCAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG5cdCAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG5cdCAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDI0O1xuXHQgICAgc2NhbGUgPSAxIC8gdGhpcy5wYXRoLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcblx0ICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXG5cdCAgICAvLyBEcmF3IHRoZSBvcmlnaW5cblx0ICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG5cdCAgICBkcmF3LmxpbmUoY3R4LCB4LCAtMTAwMDAsIHgsIDEwMDAwKTtcblx0ICAgIGRyYXcubGluZShjdHgsIC0xMDAwMCwgeSwgMTAwMDAsIHkpO1xuXG5cdCAgICAvLyBUaGlzIGNvZGUgaXMgaGVyZSBkdWUgdG8gbWVtb3J5IG9wdGltaXphdGlvbjogYnkgbm90IHVzaW5nXG5cdCAgICAvLyBkZWZhdWx0cyBpbiB0aGUgY29uc3RydWN0b3IsIHdlIHNhdmUgYSBub3RhYmxlIGFtb3VudCBvZiBtZW1vcnkuXG5cdCAgICB2YXIgeE1pbiA9IHRoaXMueE1pbiB8fCAwO1xuXHQgICAgdmFyIHlNaW4gPSB0aGlzLnlNaW4gfHwgMDtcblx0ICAgIHZhciB4TWF4ID0gdGhpcy54TWF4IHx8IDA7XG5cdCAgICB2YXIgeU1heCA9IHRoaXMueU1heCB8fCAwO1xuXHQgICAgdmFyIGFkdmFuY2VXaWR0aCA9IHRoaXMuYWR2YW5jZVdpZHRoIHx8IDA7XG5cblx0ICAgIC8vIERyYXcgdGhlIGdseXBoIGJveFxuXHQgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuXHQgICAgZHJhdy5saW5lKGN0eCwgeCArICh4TWluICogc2NhbGUpLCAtMTAwMDAsIHggKyAoeE1pbiAqIHNjYWxlKSwgMTAwMDApO1xuXHQgICAgZHJhdy5saW5lKGN0eCwgeCArICh4TWF4ICogc2NhbGUpLCAtMTAwMDAsIHggKyAoeE1heCAqIHNjYWxlKSwgMTAwMDApO1xuXHQgICAgZHJhdy5saW5lKGN0eCwgLTEwMDAwLCB5ICsgKC15TWluICogc2NhbGUpLCAxMDAwMCwgeSArICgteU1pbiAqIHNjYWxlKSk7XG5cdCAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXlNYXggKiBzY2FsZSksIDEwMDAwLCB5ICsgKC15TWF4ICogc2NhbGUpKTtcblxuXHQgICAgLy8gRHJhdyB0aGUgYWR2YW5jZSB3aWR0aFxuXHQgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcblx0ICAgIGRyYXcubGluZShjdHgsIHggKyAoYWR2YW5jZVdpZHRoICogc2NhbGUpLCAtMTAwMDAsIHggKyAoYWR2YW5jZVdpZHRoICogc2NhbGUpLCAxMDAwMCk7XG5cdH07XG5cblx0Ly8gVGhlIEdseXBoU2V0IG9iamVjdFxuXG5cdC8vIERlZmluZSBhIHByb3BlcnR5IG9uIHRoZSBnbHlwaCB0aGF0IGRlcGVuZHMgb24gdGhlIHBhdGggYmVpbmcgbG9hZGVkLlxuXHRmdW5jdGlvbiBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgZXh0ZXJuYWxOYW1lLCBpbnRlcm5hbE5hbWUpIHtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbHlwaCwgZXh0ZXJuYWxOYW1lLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgLy8gUmVxdWVzdCB0aGUgcGF0aCBwcm9wZXJ0eSB0byBtYWtlIHN1cmUgdGhlIHBhdGggaXMgbG9hZGVkLlxuXHQgICAgICAgICAgICBnbHlwaC5wYXRoOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgICAgICAgICAgcmV0dXJuIGdseXBoW2ludGVybmFsTmFtZV07XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG5cdCAgICAgICAgICAgIGdseXBoW2ludGVybmFsTmFtZV0gPSBuZXdWYWx1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIEdseXBoU2V0IHJlcHJlc2VudHMgYWxsIGdseXBocyBhdmFpbGFibGUgaW4gdGhlIGZvbnQsIGJ1dCBtb2RlbGxlZCB1c2luZ1xuXHQgKiBhIGRlZmVycmVkIGdseXBoIGxvYWRlciwgZm9yIHJldHJpZXZpbmcgZ2x5cGhzIG9ubHkgb25jZSB0aGV5IGFyZSBhYnNvbHV0ZWx5XG5cdCAqIG5lY2Vzc2FyeSwgdG8ga2VlcCB0aGUgbWVtb3J5IGZvb3RwcmludCBkb3duLlxuXHQgKiBAZXhwb3J0cyBvcGVudHlwZS5HbHlwaFNldFxuXHQgKiBAY2xhc3Ncblx0ICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuXHQgKiBAcGFyYW0ge0FycmF5fVxuXHQgKi9cblx0ZnVuY3Rpb24gR2x5cGhTZXQoZm9udCwgZ2x5cGhzKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgdGhpcy5mb250ID0gZm9udDtcblx0ICAgIHRoaXMuZ2x5cGhzID0ge307XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShnbHlwaHMpKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcyQxLmdseXBoc1tpXSA9IGdseXBoc1tpXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoID0gKGdseXBocyAmJiBnbHlwaHMubGVuZ3RoKSB8fCAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG5cdCAqL1xuXHRHbHlwaFNldC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgpIHtcblx0ICAgIGlmICh0eXBlb2YgdGhpcy5nbHlwaHNbaW5kZXhdID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdGhpcy5nbHlwaHNbaW5kZXhdID0gdGhpcy5nbHlwaHNbaW5kZXhdKCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLmdseXBoc1tpbmRleF07XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtICB7T2JqZWN0fVxuXHQgKi9cblx0R2x5cGhTZXQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpbmRleCwgbG9hZGVyKSB7XG5cdCAgICB0aGlzLmdseXBoc1tpbmRleF0gPSBsb2FkZXI7XG5cdCAgICB0aGlzLmxlbmd0aCsrO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAYWxpYXMgb3BlbnR5cGUuZ2x5cGhMb2FkZXJcblx0ICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gZm9udFxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2x5cGhMb2FkZXIoZm9udCwgaW5kZXgpIHtcblx0ICAgIHJldHVybiBuZXcgR2x5cGgoe2luZGV4OiBpbmRleCwgZm9udDogZm9udH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIGEgc3R1YiBnbHlwaCB0aGF0IGNhbiBiZSBmaWxsZWQgd2l0aCBhbGwgbWV0YWRhdGEgKmV4Y2VwdCpcblx0ICogdGhlIFwicG9pbnRzXCIgYW5kIFwicGF0aFwiIHByb3BlcnRpZXMsIHdoaWNoIG11c3QgYmUgbG9hZGVkIG9ubHkgb25jZVxuXHQgKiB0aGUgZ2x5cGgncyBwYXRoIGlzIGFjdHVhbGx5IHJlcXVlc3RlZCBmb3IgdGV4dCBzaGFwaW5nLlxuXHQgKiBAYWxpYXMgb3BlbnR5cGUudHRmR2x5cGhMb2FkZXJcblx0ICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gZm9udFxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUdseXBoXG5cdCAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IHBvc2l0aW9uXG5cdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSBidWlsZFBhdGhcblx0ICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG5cdCAqL1xuXHRmdW5jdGlvbiB0dGZHbHlwaExvYWRlcihmb250LCBpbmRleCwgcGFyc2VHbHlwaCwgZGF0YSwgcG9zaXRpb24sIGJ1aWxkUGF0aCkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBnbHlwaCA9IG5ldyBHbHlwaCh7aW5kZXg6IGluZGV4LCBmb250OiBmb250fSk7XG5cblx0ICAgICAgICBnbHlwaC5wYXRoID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHBhcnNlR2x5cGgoZ2x5cGgsIGRhdGEsIHBvc2l0aW9uKTtcblx0ICAgICAgICAgICAgdmFyIHBhdGggPSBidWlsZFBhdGgoZm9udC5nbHlwaHMsIGdseXBoKTtcblx0ICAgICAgICAgICAgcGF0aC51bml0c1BlckVtID0gZm9udC51bml0c1BlckVtO1xuXHQgICAgICAgICAgICByZXR1cm4gcGF0aDtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd4TWluJywgJ194TWluJyk7XG5cdCAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd4TWF4JywgJ194TWF4Jyk7XG5cdCAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd5TWluJywgJ195TWluJyk7XG5cdCAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd5TWF4JywgJ195TWF4Jyk7XG5cblx0ICAgICAgICByZXR1cm4gZ2x5cGg7XG5cdCAgICB9O1xuXHR9XG5cdC8qKlxuXHQgKiBAYWxpYXMgb3BlbnR5cGUuY2ZmR2x5cGhMb2FkZXJcblx0ICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gZm9udFxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUNGRkNoYXJzdHJpbmdcblx0ICogQHBhcmFtICB7c3RyaW5nfSBjaGFyc3RyaW5nXG5cdCAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuXHQgKi9cblx0ZnVuY3Rpb24gY2ZmR2x5cGhMb2FkZXIoZm9udCwgaW5kZXgsIHBhcnNlQ0ZGQ2hhcnN0cmluZywgY2hhcnN0cmluZykge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBnbHlwaCA9IG5ldyBHbHlwaCh7aW5kZXg6IGluZGV4LCBmb250OiBmb250fSk7XG5cblx0ICAgICAgICBnbHlwaC5wYXRoID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXRoID0gcGFyc2VDRkZDaGFyc3RyaW5nKGZvbnQsIGdseXBoLCBjaGFyc3RyaW5nKTtcblx0ICAgICAgICAgICAgcGF0aC51bml0c1BlckVtID0gZm9udC51bml0c1BlckVtO1xuXHQgICAgICAgICAgICByZXR1cm4gcGF0aDtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgcmV0dXJuIGdseXBoO1xuXHQgICAgfTtcblx0fVxuXG5cdHZhciBnbHlwaHNldCA9IHsgR2x5cGhTZXQ6IEdseXBoU2V0LCBnbHlwaExvYWRlcjogZ2x5cGhMb2FkZXIsIHR0ZkdseXBoTG9hZGVyOiB0dGZHbHlwaExvYWRlciwgY2ZmR2x5cGhMb2FkZXI6IGNmZkdseXBoTG9hZGVyIH07XG5cblx0Ly8gVGhlIGBDRkZgIHRhYmxlIGNvbnRhaW5zIHRoZSBnbHlwaCBvdXRsaW5lcyBpbiBQb3N0U2NyaXB0IGZvcm1hdC5cblxuXHQvLyBDdXN0b20gZXF1YWxzIGZ1bmN0aW9uIHRoYXQgY2FuIGFsc28gY2hlY2sgbGlzdHMuXG5cdGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG5cdCAgICBpZiAoYSA9PT0gYikge1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcblx0ICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgaWYgKCFlcXVhbHMoYVtpXSwgYltpXSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdH1cblxuXHQvLyBTdWJyb3V0aW5lcyBhcmUgZW5jb2RlZCB1c2luZyB0aGUgbmVnYXRpdmUgaGFsZiBvZiB0aGUgbnVtYmVyIHNwYWNlLlxuXHQvLyBTZWUgdHlwZSAyIGNoYXB0ZXIgNC43IFwiU3Vicm91dGluZSBvcGVyYXRvcnNcIi5cblx0ZnVuY3Rpb24gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKHN1YnJzKSB7XG5cdCAgICB2YXIgYmlhcztcblx0ICAgIGlmIChzdWJycy5sZW5ndGggPCAxMjQwKSB7XG5cdCAgICAgICAgYmlhcyA9IDEwNztcblx0ICAgIH0gZWxzZSBpZiAoc3VicnMubGVuZ3RoIDwgMzM5MDApIHtcblx0ICAgICAgICBiaWFzID0gMTEzMTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgYmlhcyA9IDMyNzY4O1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYmlhcztcblx0fVxuXG5cdC8vIFBhcnNlIGEgYENGRmAgSU5ERVggYXJyYXkuXG5cdC8vIEFuIGluZGV4IGFycmF5IGNvbnNpc3RzIG9mIGEgbGlzdCBvZiBvZmZzZXRzLCB0aGVuIGEgbGlzdCBvZiBvYmplY3RzIGF0IHRob3NlIG9mZnNldHMuXG5cdGZ1bmN0aW9uIHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RhcnQsIGNvbnZlcnNpb25Gbikge1xuXHQgICAgdmFyIG9mZnNldHMgPSBbXTtcblx0ICAgIHZhciBvYmplY3RzID0gW107XG5cdCAgICB2YXIgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuXHQgICAgdmFyIG9iamVjdE9mZnNldDtcblx0ICAgIHZhciBlbmRPZmZzZXQ7XG5cdCAgICBpZiAoY291bnQgIT09IDApIHtcblx0ICAgICAgICB2YXIgb2Zmc2V0U2l6ZSA9IHBhcnNlLmdldEJ5dGUoZGF0YSwgc3RhcnQgKyAyKTtcblx0ICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArICgoY291bnQgKyAxKSAqIG9mZnNldFNpemUpICsgMjtcblx0ICAgICAgICB2YXIgcG9zID0gc3RhcnQgKyAzO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgKyAxOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKHBhcnNlLmdldE9mZnNldChkYXRhLCBwb3MsIG9mZnNldFNpemUpKTtcblx0ICAgICAgICAgICAgcG9zICs9IG9mZnNldFNpemU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gVGhlIHRvdGFsIHNpemUgb2YgdGhlIGluZGV4IGFycmF5IGlzIDQgaGVhZGVyIGJ5dGVzICsgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IG9mZnNldC5cblx0ICAgICAgICBlbmRPZmZzZXQgPSBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2NvdW50XTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZW5kT2Zmc2V0ID0gc3RhcnQgKyAyO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBvZmZzZXRzLmxlbmd0aCAtIDE7IGkkMSArPSAxKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gcGFyc2UuZ2V0Qnl0ZXMoZGF0YSwgb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tpJDFdLCBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2kkMSArIDFdKTtcblx0ICAgICAgICBpZiAoY29udmVyc2lvbkZuKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gY29udmVyc2lvbkZuKHZhbHVlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBvYmplY3RzLnB1c2godmFsdWUpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge29iamVjdHM6IG9iamVjdHMsIHN0YXJ0T2Zmc2V0OiBzdGFydCwgZW5kT2Zmc2V0OiBlbmRPZmZzZXR9O1xuXHR9XG5cblx0Ly8gUGFyc2UgYSBgQ0ZGYCBESUNUIHJlYWwgdmFsdWUuXG5cdGZ1bmN0aW9uIHBhcnNlRmxvYXRPcGVyYW5kKHBhcnNlcikge1xuXHQgICAgdmFyIHMgPSAnJztcblx0ICAgIHZhciBlb2YgPSAxNTtcblx0ICAgIHZhciBsb29rdXAgPSBbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnLicsICdFJywgJ0UtJywgbnVsbCwgJy0nXTtcblx0ICAgIHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgdmFyIGIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cdCAgICAgICAgdmFyIG4xID0gYiA+PiA0O1xuXHQgICAgICAgIHZhciBuMiA9IGIgJiAxNTtcblxuXHQgICAgICAgIGlmIChuMSA9PT0gZW9mKSB7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHMgKz0gbG9va3VwW24xXTtcblxuXHQgICAgICAgIGlmIChuMiA9PT0gZW9mKSB7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHMgKz0gbG9va3VwW24yXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHBhcnNlRmxvYXQocyk7XG5cdH1cblxuXHQvLyBQYXJzZSBhIGBDRkZgIERJQ1Qgb3BlcmFuZC5cblx0ZnVuY3Rpb24gcGFyc2VPcGVyYW5kKHBhcnNlciwgYjApIHtcblx0ICAgIHZhciBiMTtcblx0ICAgIHZhciBiMjtcblx0ICAgIHZhciBiMztcblx0ICAgIHZhciBiNDtcblx0ICAgIGlmIChiMCA9PT0gMjgpIHtcblx0ICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcblx0ICAgICAgICBiMiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcblx0ICAgICAgICByZXR1cm4gYjEgPDwgOCB8IGIyO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYjAgPT09IDI5KSB7XG5cdCAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cdCAgICAgICAgYjIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cdCAgICAgICAgYjMgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cdCAgICAgICAgYjQgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cdCAgICAgICAgcmV0dXJuIGIxIDw8IDI0IHwgYjIgPDwgMTYgfCBiMyA8PCA4IHwgYjQ7XG5cdCAgICB9XG5cblx0ICAgIGlmIChiMCA9PT0gMzApIHtcblx0ICAgICAgICByZXR1cm4gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGIwID49IDMyICYmIGIwIDw9IDI0Nikge1xuXHQgICAgICAgIHJldHVybiBiMCAtIDEzOTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGIwID49IDI0NyAmJiBiMCA8PSAyNTApIHtcblx0ICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcblx0ICAgICAgICByZXR1cm4gKGIwIC0gMjQ3KSAqIDI1NiArIGIxICsgMTA4O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYjAgPj0gMjUxICYmIGIwIDw9IDI1NCkge1xuXHQgICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuXHQgICAgICAgIHJldHVybiAtKGIwIC0gMjUxKSAqIDI1NiAtIGIxIC0gMTA4O1xuXHQgICAgfVxuXG5cdCAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYjAgJyArIGIwKTtcblx0fVxuXG5cdC8vIENvbnZlcnQgdGhlIGVudHJpZXMgcmV0dXJuZWQgYnkgYHBhcnNlRGljdGAgdG8gYSBwcm9wZXIgZGljdGlvbmFyeS5cblx0Ly8gSWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2Ygb25lLCBpdCBpcyB1bnBhY2tlZC5cblx0ZnVuY3Rpb24gZW50cmllc1RvT2JqZWN0KGVudHJpZXMpIHtcblx0ICAgIHZhciBvID0ge307XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIga2V5ID0gZW50cmllc1tpXVswXTtcblx0ICAgICAgICB2YXIgdmFsdWVzID0gZW50cmllc1tpXVsxXTtcblx0ICAgICAgICB2YXIgdmFsdWUgPSAodm9pZCAwKTtcblx0ICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1swXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc05hTihvW2tleV0pKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0ICcgKyBvICsgJyBhbHJlYWR5IGhhcyBrZXkgJyArIGtleSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgb1trZXldID0gdmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBvO1xuXHR9XG5cblx0Ly8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9iamVjdC5cblx0Ly8gQSBkaWN0aW9uYXJ5IGNvbnRhaW5zIGtleS12YWx1ZSBwYWlycyBpbiBhIGNvbXBhY3QgdG9rZW5pemVkIGZvcm1hdC5cblx0ZnVuY3Rpb24gcGFyc2VDRkZEaWN0KGRhdGEsIHN0YXJ0LCBzaXplKSB7XG5cdCAgICBzdGFydCA9IHN0YXJ0ICE9PSB1bmRlZmluZWQgPyBzdGFydCA6IDA7XG5cdCAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cdCAgICB2YXIgZW50cmllcyA9IFtdO1xuXHQgICAgdmFyIG9wZXJhbmRzID0gW107XG5cdCAgICBzaXplID0gc2l6ZSAhPT0gdW5kZWZpbmVkID8gc2l6ZSA6IGRhdGEubGVuZ3RoO1xuXG5cdCAgICB3aGlsZSAocGFyc2VyLnJlbGF0aXZlT2Zmc2V0IDwgc2l6ZSkge1xuXHQgICAgICAgIHZhciBvcCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcblxuXHQgICAgICAgIC8vIFRoZSBmaXJzdCBieXRlIGZvciBlYWNoIGRpY3QgaXRlbSBkaXN0aW5ndWlzaGVzIGJldHdlZW4gb3BlcmF0b3IgKGtleSkgYW5kIG9wZXJhbmQgKHZhbHVlKS5cblx0ICAgICAgICAvLyBWYWx1ZXMgPD0gMjEgYXJlIG9wZXJhdG9ycy5cblx0ICAgICAgICBpZiAob3AgPD0gMjEpIHtcblx0ICAgICAgICAgICAgLy8gVHdvLWJ5dGUgb3BlcmF0b3JzIGhhdmUgYW4gaW5pdGlhbCBlc2NhcGUgYnl0ZSBvZiAxMi5cblx0ICAgICAgICAgICAgaWYgKG9wID09PSAxMikge1xuXHQgICAgICAgICAgICAgICAgb3AgPSAxMjAwICsgcGFyc2VyLnBhcnNlQnl0ZSgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZW50cmllcy5wdXNoKFtvcCwgb3BlcmFuZHNdKTtcblx0ICAgICAgICAgICAgb3BlcmFuZHMgPSBbXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBTaW5jZSB0aGUgb3BlcmFuZHMgKHZhbHVlcykgY29tZSBiZWZvcmUgdGhlIG9wZXJhdG9ycyAoa2V5cyksIHdlIHN0b3JlIGFsbCBvcGVyYW5kcyBpbiBhIGxpc3Rcblx0ICAgICAgICAgICAgLy8gdW50aWwgd2UgZW5jb3VudGVyIGFuIG9wZXJhdG9yLlxuXHQgICAgICAgICAgICBvcGVyYW5kcy5wdXNoKHBhcnNlT3BlcmFuZChwYXJzZXIsIG9wKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZW50cmllc1RvT2JqZWN0KGVudHJpZXMpO1xuXHR9XG5cblx0Ly8gR2l2ZW4gYSBTdHJpbmcgSW5kZXggKFNJRCksIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHN0cmluZy5cblx0Ly8gU3RyaW5ncyBiZWxvdyBpbmRleCAzOTIgYXJlIHN0YW5kYXJkIENGRiBzdHJpbmdzIGFuZCBhcmUgbm90IGVuY29kZWQgaW4gdGhlIGZvbnQuXG5cdGZ1bmN0aW9uIGdldENGRlN0cmluZyhzdHJpbmdzLCBpbmRleCkge1xuXHQgICAgaWYgKGluZGV4IDw9IDM5MCkge1xuXHQgICAgICAgIGluZGV4ID0gY2ZmU3RhbmRhcmRTdHJpbmdzW2luZGV4XTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaW5kZXggPSBzdHJpbmdzW2luZGV4IC0gMzkxXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGluZGV4O1xuXHR9XG5cblx0Ly8gSW50ZXJwcmV0IGEgZGljdGlvbmFyeSBhbmQgcmV0dXJuIGEgbmV3IGRpY3Rpb25hcnkgd2l0aCByZWFkYWJsZSBrZXlzIGFuZCB2YWx1ZXMgZm9yIG1pc3NpbmcgZW50cmllcy5cblx0Ly8gVGhpcyBmdW5jdGlvbiB0YWtlcyBgbWV0YWAgd2hpY2ggaXMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBgb3BlcmFuZGAsIGBuYW1lYCBhbmQgYGRlZmF1bHRgLlxuXHRmdW5jdGlvbiBpbnRlcnByZXREaWN0KGRpY3QsIG1ldGEsIHN0cmluZ3MpIHtcblx0ICAgIHZhciBuZXdEaWN0ID0ge307XG5cdCAgICB2YXIgdmFsdWU7XG5cblx0ICAgIC8vIEJlY2F1c2Ugd2UgYWxzbyB3YW50IHRvIGluY2x1ZGUgbWlzc2luZyB2YWx1ZXMsIHdlIHN0YXJ0IG91dCBmcm9tIHRoZSBtZXRhIGxpc3Rcblx0ICAgIC8vIGFuZCBsb29rdXAgdmFsdWVzIGluIHRoZSBkaWN0LlxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIG0gPSBtZXRhW2ldO1xuXG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobS50eXBlKSkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG5cdCAgICAgICAgICAgIHZhbHVlcy5sZW5ndGggPSBtLnR5cGUubGVuZ3RoO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG0udHlwZS5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBkaWN0W20ub3BdICE9PSB1bmRlZmluZWQgPyBkaWN0W20ub3BdW2pdIDogdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG0udmFsdWUgIT09IHVuZGVmaW5lZCAmJiBtLnZhbHVlW2pdICE9PSB1bmRlZmluZWQgPyBtLnZhbHVlW2pdIDogbnVsbDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChtLnR5cGVbal0gPT09ICdTSUQnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRDRkZTdHJpbmcoc3RyaW5ncywgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFsdWVzW2pdID0gdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbmV3RGljdFttLm5hbWVdID0gdmFsdWVzO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gZGljdFttLm9wXTtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gbS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gbS52YWx1ZSA6IG51bGw7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAobS50eXBlID09PSAnU0lEJykge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRDRkZTdHJpbmcoc3RyaW5ncywgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG5ld0RpY3RbbS5uYW1lXSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG5ld0RpY3Q7XG5cdH1cblxuXHQvLyBQYXJzZSB0aGUgQ0ZGIGhlYWRlci5cblx0ZnVuY3Rpb24gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpIHtcblx0ICAgIHZhciBoZWFkZXIgPSB7fTtcblx0ICAgIGhlYWRlci5mb3JtYXRNYWpvciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0KTtcblx0ICAgIGhlYWRlci5mb3JtYXRNaW5vciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMSk7XG5cdCAgICBoZWFkZXIuc2l6ZSA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMik7XG5cdCAgICBoZWFkZXIub2Zmc2V0U2l6ZSA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMyk7XG5cdCAgICBoZWFkZXIuc3RhcnRPZmZzZXQgPSBzdGFydDtcblx0ICAgIGhlYWRlci5lbmRPZmZzZXQgPSBzdGFydCArIDQ7XG5cdCAgICByZXR1cm4gaGVhZGVyO1xuXHR9XG5cblx0dmFyIFRPUF9ESUNUX01FVEEgPSBbXG5cdCAgICB7bmFtZTogJ3ZlcnNpb24nLCBvcDogMCwgdHlwZTogJ1NJRCd9LFxuXHQgICAge25hbWU6ICdub3RpY2UnLCBvcDogMSwgdHlwZTogJ1NJRCd9LFxuXHQgICAge25hbWU6ICdjb3B5cmlnaHQnLCBvcDogMTIwMCwgdHlwZTogJ1NJRCd9LFxuXHQgICAge25hbWU6ICdmdWxsTmFtZScsIG9wOiAyLCB0eXBlOiAnU0lEJ30sXG5cdCAgICB7bmFtZTogJ2ZhbWlseU5hbWUnLCBvcDogMywgdHlwZTogJ1NJRCd9LFxuXHQgICAge25hbWU6ICd3ZWlnaHQnLCBvcDogNCwgdHlwZTogJ1NJRCd9LFxuXHQgICAge25hbWU6ICdpc0ZpeGVkUGl0Y2gnLCBvcDogMTIwMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcblx0ICAgIHtuYW1lOiAnaXRhbGljQW5nbGUnLCBvcDogMTIwMiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcblx0ICAgIHtuYW1lOiAndW5kZXJsaW5lUG9zaXRpb24nLCBvcDogMTIwMywgdHlwZTogJ251bWJlcicsIHZhbHVlOiAtMTAwfSxcblx0ICAgIHtuYW1lOiAndW5kZXJsaW5lVGhpY2tuZXNzJywgb3A6IDEyMDQsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogNTB9LFxuXHQgICAge25hbWU6ICdwYWludFR5cGUnLCBvcDogMTIwNSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcblx0ICAgIHtuYW1lOiAnY2hhcnN0cmluZ1R5cGUnLCBvcDogMTIwNiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAyfSxcblx0ICAgIHtcblx0ICAgICAgICBuYW1lOiAnZm9udE1hdHJpeCcsXG5cdCAgICAgICAgb3A6IDEyMDcsXG5cdCAgICAgICAgdHlwZTogWydyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCddLFxuXHQgICAgICAgIHZhbHVlOiBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXVxuXHQgICAgfSxcblx0ICAgIHtuYW1lOiAndW5pcXVlSWQnLCBvcDogMTMsIHR5cGU6ICdudW1iZXInfSxcblx0ICAgIHtuYW1lOiAnZm9udEJCb3gnLCBvcDogNSwgdHlwZTogWydudW1iZXInLCAnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInXSwgdmFsdWU6IFswLCAwLCAwLCAwXX0sXG5cdCAgICB7bmFtZTogJ3N0cm9rZVdpZHRoJywgb3A6IDEyMDgsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG5cdCAgICB7bmFtZTogJ3h1aWQnLCBvcDogMTQsIHR5cGU6IFtdLCB2YWx1ZTogbnVsbH0sXG5cdCAgICB7bmFtZTogJ2NoYXJzZXQnLCBvcDogMTUsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG5cdCAgICB7bmFtZTogJ2VuY29kaW5nJywgb3A6IDE2LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuXHQgICAge25hbWU6ICdjaGFyU3RyaW5ncycsIG9wOiAxNywgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcblx0ICAgIHtuYW1lOiAncHJpdmF0ZScsIG9wOiAxOCwgdHlwZTogWydudW1iZXInLCAnb2Zmc2V0J10sIHZhbHVlOiBbMCwgMF19LFxuXHQgICAge25hbWU6ICdyb3MnLCBvcDogMTIzMCwgdHlwZTogWydTSUQnLCAnU0lEJywgJ251bWJlciddfSxcblx0ICAgIHtuYW1lOiAnY2lkRm9udFZlcnNpb24nLCBvcDogMTIzMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcblx0ICAgIHtuYW1lOiAnY2lkRm9udFJldmlzaW9uJywgb3A6IDEyMzIsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG5cdCAgICB7bmFtZTogJ2NpZEZvbnRUeXBlJywgb3A6IDEyMzMsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG5cdCAgICB7bmFtZTogJ2NpZENvdW50Jywgb3A6IDEyMzQsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogODcyMH0sXG5cdCAgICB7bmFtZTogJ3VpZEJhc2UnLCBvcDogMTIzNSwgdHlwZTogJ251bWJlcid9LFxuXHQgICAge25hbWU6ICdmZEFycmF5Jywgb3A6IDEyMzYsIHR5cGU6ICdvZmZzZXQnfSxcblx0ICAgIHtuYW1lOiAnZmRTZWxlY3QnLCBvcDogMTIzNywgdHlwZTogJ29mZnNldCd9LFxuXHQgICAge25hbWU6ICdmb250TmFtZScsIG9wOiAxMjM4LCB0eXBlOiAnU0lEJ31cblx0XTtcblxuXHR2YXIgUFJJVkFURV9ESUNUX01FVEEgPSBbXG5cdCAgICB7bmFtZTogJ3N1YnJzJywgb3A6IDE5LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuXHQgICAge25hbWU6ICdkZWZhdWx0V2lkdGhYJywgb3A6IDIwLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuXHQgICAge25hbWU6ICdub21pbmFsV2lkdGhYJywgb3A6IDIxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9XG5cdF07XG5cblx0Ly8gUGFyc2UgdGhlIENGRiB0b3AgZGljdGlvbmFyeS4gQSBDRkYgdGFibGUgY2FuIGNvbnRhaW4gbXVsdGlwbGUgZm9udHMsIGVhY2ggd2l0aCB0aGVpciBvd24gdG9wIGRpY3Rpb25hcnkuXG5cdC8vIFRoZSB0b3AgZGljdGlvbmFyeSBjb250YWlucyB0aGUgZXNzZW50aWFsIG1ldGFkYXRhIGZvciB0aGUgZm9udCwgdG9nZXRoZXIgd2l0aCB0aGUgcHJpdmF0ZSBkaWN0aW9uYXJ5LlxuXHRmdW5jdGlvbiBwYXJzZUNGRlRvcERpY3QoZGF0YSwgc3RyaW5ncykge1xuXHQgICAgdmFyIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoKTtcblx0ICAgIHJldHVybiBpbnRlcnByZXREaWN0KGRpY3QsIFRPUF9ESUNUX01FVEEsIHN0cmluZ3MpO1xuXHR9XG5cblx0Ly8gUGFyc2UgdGhlIENGRiBwcml2YXRlIGRpY3Rpb25hcnkuIFdlIGRvbid0IGZ1bGx5IHBhcnNlIG91dCBhbGwgdGhlIHZhbHVlcywgb25seSB0aGUgb25lcyB3ZSBuZWVkLlxuXHRmdW5jdGlvbiBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHN0YXJ0LCBzaXplLCBzdHJpbmdzKSB7XG5cdCAgICB2YXIgZGljdCA9IHBhcnNlQ0ZGRGljdChkYXRhLCBzdGFydCwgc2l6ZSk7XG5cdCAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBQUklWQVRFX0RJQ1RfTUVUQSwgc3RyaW5ncyk7XG5cdH1cblxuXHQvLyBSZXR1cm5zIGEgbGlzdCBvZiBcIlRvcCBESUNUXCJzIGZvdW5kIHVzaW5nIGFuIElOREVYIGxpc3QuXG5cdC8vIFVzZWQgdG8gcmVhZCBib3RoIHRoZSB1c3VhbCBoaWdoLWxldmVsIFRvcCBESUNUcyBhbmQgYWxzbyB0aGUgRkRBcnJheVxuXHQvLyBkaXNjb3ZlcmVkIGluc2lkZSBDSUQta2V5ZWQgZm9udHMuICBXaGVuIGEgVG9wIERJQ1QgaGFzIGEgcmVmZXJlbmNlIHRvXG5cdC8vIGEgUHJpdmF0ZSBESUNUIHRoYXQgaXMgcmVhZCBhbmQgc2F2ZWQgaW50byB0aGUgVG9wIERJQ1QuXG5cdC8vXG5cdC8vIEluIGFkZGl0aW9uIHRvIHRoZSBleHBlY3RlZC9vcHRpb25hbCB2YWx1ZXMgYXMgb3V0bGluZWQgaW4gVE9QX0RJQ1RfTUVUQVxuXHQvLyB0aGUgZm9sbG93aW5nIHZhbHVlcyBtaWdodCBiZSBzYXZlZCBpbnRvIHRoZSBUb3AgRElDVC5cblx0Ly9cblx0Ly8gICAgX3N1YnJzIFtdICAgICAgICBhcnJheSBvZiBsb2NhbCBDRkYgc3Vicm91dGluZXMgZnJvbSBQcml2YXRlIERJQ1Rcblx0Ly8gICAgX3N1YnJzQmlhcyAgICAgICBiaWFzIHZhbHVlIGNvbXB1dGVkIGZyb20gbnVtYmVyIG9mIHN1YnJvdXRpbmVzXG5cdC8vICAgICAgICAgICAgICAgICAgICAgIChzZWUgY2FsY0NGRlN1YnJvdXRpbmVCaWFzKCkgYW5kIHBhcnNlQ0ZGQ2hhcnN0cmluZygpKVxuXHQvLyAgICBfZGVmYXVsdFdpZHRoWCAgIGRlZmF1bHQgd2lkdGhzIGZvciBDRkYgY2hhcmFjdGVyc1xuXHQvLyAgICBfbm9taW5hbFdpZHRoWCAgIGJpYXMgYWRkZWQgdG8gd2lkdGggZW1iZWRkZWQgd2l0aGluIGdseXBoIGRlc2NyaXB0aW9uXG5cdC8vXG5cdC8vICAgIF9wcml2YXRlRGljdCAgICAgc2F2ZWQgY29weSBvZiBwYXJzZWQgUHJpdmF0ZSBESUNUIGZyb20gVG9wIERJQ1Rcblx0ZnVuY3Rpb24gZ2F0aGVyQ0ZGVG9wRGljdHMoZGF0YSwgc3RhcnQsIGNmZkluZGV4LCBzdHJpbmdzKSB7XG5cdCAgICB2YXIgdG9wRGljdEFycmF5ID0gW107XG5cdCAgICBmb3IgKHZhciBpVG9wRGljdCA9IDA7IGlUb3BEaWN0IDwgY2ZmSW5kZXgubGVuZ3RoOyBpVG9wRGljdCArPSAxKSB7XG5cdCAgICAgICAgdmFyIHRvcERpY3REYXRhID0gbmV3IERhdGFWaWV3KG5ldyBVaW50OEFycmF5KGNmZkluZGV4W2lUb3BEaWN0XSkuYnVmZmVyKTtcblx0ICAgICAgICB2YXIgdG9wRGljdCA9IHBhcnNlQ0ZGVG9wRGljdCh0b3BEaWN0RGF0YSwgc3RyaW5ncyk7XG5cdCAgICAgICAgdG9wRGljdC5fc3VicnMgPSBbXTtcblx0ICAgICAgICB0b3BEaWN0Ll9zdWJyc0JpYXMgPSAwO1xuXHQgICAgICAgIHZhciBwcml2YXRlU2l6ZSA9IHRvcERpY3QucHJpdmF0ZVswXTtcblx0ICAgICAgICB2YXIgcHJpdmF0ZU9mZnNldCA9IHRvcERpY3QucHJpdmF0ZVsxXTtcblx0ICAgICAgICBpZiAocHJpdmF0ZVNpemUgIT09IDAgJiYgcHJpdmF0ZU9mZnNldCAhPT0gMCkge1xuXHQgICAgICAgICAgICB2YXIgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHByaXZhdGVPZmZzZXQgKyBzdGFydCwgcHJpdmF0ZVNpemUsIHN0cmluZ3MpO1xuXHQgICAgICAgICAgICB0b3BEaWN0Ll9kZWZhdWx0V2lkdGhYID0gcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcblx0ICAgICAgICAgICAgdG9wRGljdC5fbm9taW5hbFdpZHRoWCA9IHByaXZhdGVEaWN0Lm5vbWluYWxXaWR0aFg7XG5cdCAgICAgICAgICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnJPZmZzZXQgPSBwcml2YXRlT2Zmc2V0ICsgcHJpdmF0ZURpY3Quc3VicnM7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdWJyT2Zmc2V0ICsgc3RhcnQpO1xuXHQgICAgICAgICAgICAgICAgdG9wRGljdC5fc3VicnMgPSBzdWJySW5kZXgub2JqZWN0cztcblx0ICAgICAgICAgICAgICAgIHRvcERpY3QuX3N1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyh0b3BEaWN0Ll9zdWJycyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdG9wRGljdC5fcHJpdmF0ZURpY3QgPSBwcml2YXRlRGljdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdG9wRGljdEFycmF5LnB1c2godG9wRGljdCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdG9wRGljdEFycmF5O1xuXHR9XG5cblx0Ly8gUGFyc2UgdGhlIENGRiBjaGFyc2V0IHRhYmxlLCB3aGljaCBjb250YWlucyBpbnRlcm5hbCBuYW1lcyBmb3IgYWxsIHRoZSBnbHlwaHMuXG5cdC8vIFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSBsaXN0IG9mIGdseXBoIG5hbWVzLlxuXHQvLyBTZWUgQWRvYmUgVE4gIzUxNzYgY2hhcHRlciAxMywgXCJDaGFyc2V0c1wiLlxuXHRmdW5jdGlvbiBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIHN0cmluZ3MpIHtcblx0ICAgIHZhciBzaWQ7XG5cdCAgICB2YXIgY291bnQ7XG5cdCAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cblx0ICAgIC8vIFRoZSAubm90ZGVmIGdseXBoIGlzIG5vdCBpbmNsdWRlZCwgc28gc3VidHJhY3QgMS5cblx0ICAgIG5HbHlwaHMgLT0gMTtcblx0ICAgIHZhciBjaGFyc2V0ID0gWycubm90ZGVmJ107XG5cblx0ICAgIHZhciBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuXHQgICAgaWYgKGZvcm1hdCA9PT0gMCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkdseXBoczsgaSArPSAxKSB7XG5cdCAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuXHQgICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG5cdCAgICAgICAgd2hpbGUgKGNoYXJzZXQubGVuZ3RoIDw9IG5HbHlwaHMpIHtcblx0ICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG5cdCAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDw9IGNvdW50OyBpJDEgKz0gMSkge1xuXHQgICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcblx0ICAgICAgICAgICAgICAgIHNpZCArPSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcblx0ICAgICAgICB3aGlsZSAoY2hhcnNldC5sZW5ndGggPD0gbkdseXBocykge1xuXHQgICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcblx0ICAgICAgICAgICAgY291bnQgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDw9IGNvdW50OyBpJDIgKz0gMSkge1xuXHQgICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcblx0ICAgICAgICAgICAgICAgIHNpZCArPSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2hhcnNldCBmb3JtYXQgJyArIGZvcm1hdCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjaGFyc2V0O1xuXHR9XG5cblx0Ly8gUGFyc2UgdGhlIENGRiBlbmNvZGluZyBkYXRhLiBPbmx5IG9uZSBlbmNvZGluZyBjYW4gYmUgc3BlY2lmaWVkIHBlciBmb250LlxuXHQvLyBTZWUgQWRvYmUgVE4gIzUxNzYgY2hhcHRlciAxMiwgXCJFbmNvZGluZ3NcIi5cblx0ZnVuY3Rpb24gcGFyc2VDRkZFbmNvZGluZyhkYXRhLCBzdGFydCwgY2hhcnNldCkge1xuXHQgICAgdmFyIGNvZGU7XG5cdCAgICB2YXIgZW5jID0ge307XG5cdCAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cdCAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcblx0ICAgIGlmIChmb3JtYXQgPT09IDApIHtcblx0ICAgICAgICB2YXIgbkNvZGVzID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Db2RlczsgaSArPSAxKSB7XG5cdCAgICAgICAgICAgIGNvZGUgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuXHQgICAgICAgICAgICBlbmNbY29kZV0gPSBpO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG5cdCAgICAgICAgdmFyIG5SYW5nZXMgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuXHQgICAgICAgIGNvZGUgPSAxO1xuXHQgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG5SYW5nZXM7IGkkMSArPSAxKSB7XG5cdCAgICAgICAgICAgIHZhciBmaXJzdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG5cdCAgICAgICAgICAgIHZhciBuTGVmdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSBmaXJzdDsgaiA8PSBmaXJzdCArIG5MZWZ0OyBqICs9IDEpIHtcblx0ICAgICAgICAgICAgICAgIGVuY1tqXSA9IGNvZGU7XG5cdCAgICAgICAgICAgICAgICBjb2RlICs9IDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBmb3JtYXQgJyArIGZvcm1hdCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuZXcgQ2ZmRW5jb2RpbmcoZW5jLCBjaGFyc2V0KTtcblx0fVxuXG5cdC8vIFRha2UgaW4gY2hhcnN0cmluZyBjb2RlIGFuZCByZXR1cm4gYSBHbHlwaCBvYmplY3QuXG5cdC8vIFRoZSBlbmNvZGluZyBpcyBkZXNjcmliZWQgaW4gdGhlIFR5cGUgMiBDaGFyc3RyaW5nIEZvcm1hdFxuXHQvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXJzdHIyLmh0bVxuXHRmdW5jdGlvbiBwYXJzZUNGRkNoYXJzdHJpbmcoZm9udCwgZ2x5cGgsIGNvZGUpIHtcblx0ICAgIHZhciBjMXg7XG5cdCAgICB2YXIgYzF5O1xuXHQgICAgdmFyIGMyeDtcblx0ICAgIHZhciBjMnk7XG5cdCAgICB2YXIgcCA9IG5ldyBQYXRoKCk7XG5cdCAgICB2YXIgc3RhY2sgPSBbXTtcblx0ICAgIHZhciBuU3RlbXMgPSAwO1xuXHQgICAgdmFyIGhhdmVXaWR0aCA9IGZhbHNlO1xuXHQgICAgdmFyIG9wZW4gPSBmYWxzZTtcblx0ICAgIHZhciB4ID0gMDtcblx0ICAgIHZhciB5ID0gMDtcblx0ICAgIHZhciBzdWJycztcblx0ICAgIHZhciBzdWJyc0JpYXM7XG5cdCAgICB2YXIgZGVmYXVsdFdpZHRoWDtcblx0ICAgIHZhciBub21pbmFsV2lkdGhYO1xuXHQgICAgaWYgKGZvbnQuaXNDSURGb250KSB7XG5cdCAgICAgICAgdmFyIGZkSW5kZXggPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZmRTZWxlY3RbZ2x5cGguaW5kZXhdO1xuXHQgICAgICAgIHZhciBmZERpY3QgPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZmRBcnJheVtmZEluZGV4XTtcblx0ICAgICAgICBzdWJycyA9IGZkRGljdC5fc3VicnM7XG5cdCAgICAgICAgc3VicnNCaWFzID0gZmREaWN0Ll9zdWJyc0JpYXM7XG5cdCAgICAgICAgZGVmYXVsdFdpZHRoWCA9IGZkRGljdC5fZGVmYXVsdFdpZHRoWDtcblx0ICAgICAgICBub21pbmFsV2lkdGhYID0gZmREaWN0Ll9ub21pbmFsV2lkdGhYO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBzdWJycyA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9zdWJycztcblx0ICAgICAgICBzdWJyc0JpYXMgPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fc3VicnNCaWFzO1xuXHQgICAgICAgIGRlZmF1bHRXaWR0aFggPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZGVmYXVsdFdpZHRoWDtcblx0ICAgICAgICBub21pbmFsV2lkdGhYID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX25vbWluYWxXaWR0aFg7XG5cdCAgICB9XG5cdCAgICB2YXIgd2lkdGggPSBkZWZhdWx0V2lkdGhYO1xuXG5cdCAgICBmdW5jdGlvbiBuZXdDb250b3VyKHgsIHkpIHtcblx0ICAgICAgICBpZiAob3Blbikge1xuXHQgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHAubW92ZVRvKHgsIHkpO1xuXHQgICAgICAgIG9wZW4gPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwYXJzZVN0ZW1zKCkge1xuXHQgICAgICAgIHZhciBoYXNXaWR0aEFyZztcblxuXHQgICAgICAgIC8vIFRoZSBudW1iZXIgb2Ygc3RlbSBvcGVyYXRvcnMgb24gdGhlIHN0YWNrIGlzIGFsd2F5cyBldmVuLlxuXHQgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyB1bmV2ZW4sIHRoYXQgbWVhbnMgYSB3aWR0aCBpcyBzcGVjaWZpZWQuXG5cdCAgICAgICAgaGFzV2lkdGhBcmcgPSBzdGFjay5sZW5ndGggJSAyICE9PSAwO1xuXHQgICAgICAgIGlmIChoYXNXaWR0aEFyZyAmJiAhaGF2ZVdpZHRoKSB7XG5cdCAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgblN0ZW1zICs9IHN0YWNrLmxlbmd0aCA+PiAxO1xuXHQgICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG5cdCAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcGFyc2UkJDEoY29kZSkge1xuXHQgICAgICAgIHZhciBiMTtcblx0ICAgICAgICB2YXIgYjI7XG5cdCAgICAgICAgdmFyIGIzO1xuXHQgICAgICAgIHZhciBiNDtcblx0ICAgICAgICB2YXIgY29kZUluZGV4O1xuXHQgICAgICAgIHZhciBzdWJyQ29kZTtcblx0ICAgICAgICB2YXIganB4O1xuXHQgICAgICAgIHZhciBqcHk7XG5cdCAgICAgICAgdmFyIGMzeDtcblx0ICAgICAgICB2YXIgYzN5O1xuXHQgICAgICAgIHZhciBjNHg7XG5cdCAgICAgICAgdmFyIGM0eTtcblxuXHQgICAgICAgIHZhciBpID0gMDtcblx0ICAgICAgICB3aGlsZSAoaSA8IGNvZGUubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHZhciB2ID0gY29kZVtpXTtcblx0ICAgICAgICAgICAgaSArPSAxO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKHYpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gaHN0ZW1cblx0ICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIHZzdGVtXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiAvLyB2bW92ZXRvXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgbmV3Q29udG91cih4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogLy8gcmxpbmV0b1xuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNjogLy8gaGxpbmV0b1xuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogLy8gdmxpbmV0b1xuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgODogLy8gcnJjdXJ2ZXRvXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxMDogLy8gY2FsbHN1YnJcblx0ICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBzdGFjay5wb3AoKSArIHN1YnJzQmlhcztcblx0ICAgICAgICAgICAgICAgICAgICBzdWJyQ29kZSA9IHN1YnJzW2NvZGVJbmRleF07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnJDb2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlJCQxKHN1YnJDb2RlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTE6IC8vIHJldHVyblxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTI6IC8vIGZsZXggb3BlcmF0b3JzXG5cdCAgICAgICAgICAgICAgICAgICAgdiA9IGNvZGVbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM1OiAvLyBmbGV4XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR5MyBkeDQgZHk0IGR4NSBkeTUgZHg2IGR5NiBmZCBmbGV4ICgxMiAzNSkgfC1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkxXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0ganB5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg2XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzR5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnNoaWZ0KCk7ICAgICAgICAgICAgICAgIC8vIGZsZXggZGVwdGhcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzQ6IC8vIGhmbGV4XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHgyIGR5MiBkeDMgZHg0IGR4NSBkeDYgaGZsZXggKDEyIDM0KSB8LVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5OyAgICAgICAgICAgICAgICAgICAgICAvLyBkeTFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5M1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0geTsgICAgICAgICAgICAgICAgICAgICAgLy8gZHk1XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgICAgICAvLyBkeDZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzY6IC8vIGhmbGV4MVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeDQgZHg1IGR5NSBkeDYgaGZsZXgxICgxMiAzNikgfC1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkxXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHk0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7ICAgICAgLy8gZHg2XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM3OiAvLyBmbGV4MVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeTMgZHg0IGR5NCBkeDUgZHk1IGQ2IGZsZXgxICgxMiAzNykgfC1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkxXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0ganB5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGM0eCAtIHgpID4gTWF0aC5hYnMoYzR5IC0geSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGM0eSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnR2x5cGggJyArIGdseXBoLmluZGV4ICsgJzogdW5rbm93biBvcGVyYXRvciAnICsgMTIwMCArIHYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE0OiAvLyBlbmRjaGFyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDAgJiYgIWhhdmVXaWR0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcGVuKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4gPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTg6IC8vIGhzdGVtaG1cblx0ICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE5OiAvLyBoaW50bWFza1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyMDogLy8gY250cm1hc2tcblx0ICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaSArPSAoblN0ZW1zICsgNykgPj4gMztcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjE6IC8vIHJtb3ZldG9cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMiAmJiAhaGF2ZVdpZHRoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDIyOiAvLyBobW92ZXRvXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgbmV3Q29udG91cih4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjM6IC8vIHZzdGVtaG1cblx0ICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDI0OiAvLyByY3VydmVsaW5lXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDI1OiAvLyBybGluZWN1cnZlXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjY6IC8vIHZ2Y3VydmV0b1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gaGhjdXJ2ZXRvXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCAlIDIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDI4OiAvLyBzaG9ydGludFxuXHQgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcblx0ICAgICAgICAgICAgICAgICAgICBiMiA9IGNvZGVbaSArIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpKSA+PiAxNik7XG5cdCAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyOTogLy8gY2FsbGdzdWJyXG5cdCAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gc3RhY2sucG9wKCkgKyBmb250LmdzdWJyc0JpYXM7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VickNvZGUgPSBmb250LmdzdWJyc1tjb2RlSW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZSQkMShzdWJyQ29kZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDMwOiAvLyB2aGN1cnZldG9cblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzE6IC8vIGh2Y3VydmV0b1xuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodiA8IDMyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHbHlwaCAnICsgZ2x5cGguaW5kZXggKyAnOiB1bmtub3duIG9wZXJhdG9yICcgKyB2KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNDcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh2IC0gMTM5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKHYgLSAyNDcpICogMjU2ICsgYjEgKyAxMDgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI1NSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgtKHYgLSAyNTEpICogMjU2IC0gYjEgLSAxMDgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYjMgPSBjb2RlW2kgKyAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYjQgPSBjb2RlW2kgKyAzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSArPSA0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSB8IChiMyA8PCA4KSB8IGI0KSAvIDY1NTM2KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHBhcnNlJCQxKGNvZGUpO1xuXG5cdCAgICBnbHlwaC5hZHZhbmNlV2lkdGggPSB3aWR0aDtcblx0ICAgIHJldHVybiBwO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VDRkZGRFNlbGVjdChkYXRhLCBzdGFydCwgbkdseXBocywgZmRBcnJheUNvdW50KSB7XG5cdCAgICB2YXIgZmRTZWxlY3QgPSBbXTtcblx0ICAgIHZhciBmZEluZGV4O1xuXHQgICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgdmFyIGZvcm1hdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG5cdCAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG5cdCAgICAgICAgLy8gU2ltcGxlIGxpc3Qgb2YgbkdseXBocyBlbGVtZW50c1xuXHQgICAgICAgIGZvciAodmFyIGlHaWQgPSAwOyBpR2lkIDwgbkdseXBoczsgaUdpZCsrKSB7XG5cdCAgICAgICAgICAgIGZkSW5kZXggPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuXHQgICAgICAgICAgICBpZiAoZmRJbmRleCA+PSBmZEFycmF5Q291bnQpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIHRhYmxlIENJRCBGb250IEZEU2VsZWN0IGhhcyBiYWQgRkQgaW5kZXggdmFsdWUgJyArIGZkSW5kZXggKyAnIChGRCBjb3VudCAnICsgZmRBcnJheUNvdW50ICsgJyknKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmZFNlbGVjdC5wdXNoKGZkSW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzKSB7XG5cdCAgICAgICAgLy8gUmFuZ2VzXG5cdCAgICAgICAgdmFyIG5SYW5nZXMgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcblx0ICAgICAgICB2YXIgZmlyc3QgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcblx0ICAgICAgICBpZiAoZmlyc3QgIT09IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgZm9ybWF0IDMgcmFuZ2UgaGFzIGJhZCBpbml0aWFsIEdJRCAnICsgZmlyc3QpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbmV4dDtcblx0ICAgICAgICBmb3IgKHZhciBpUmFuZ2UgPSAwOyBpUmFuZ2UgPCBuUmFuZ2VzOyBpUmFuZ2UrKykge1xuXHQgICAgICAgICAgICBmZEluZGV4ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcblx0ICAgICAgICAgICAgbmV4dCA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuXHQgICAgICAgICAgICBpZiAoZmRJbmRleCA+PSBmZEFycmF5Q291bnQpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIHRhYmxlIENJRCBGb250IEZEU2VsZWN0IGhhcyBiYWQgRkQgaW5kZXggdmFsdWUgJyArIGZkSW5kZXggKyAnIChGRCBjb3VudCAnICsgZmRBcnJheUNvdW50ICsgJyknKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAobmV4dCA+IG5HbHlwaHMpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgR0lEICcgKyBuZXh0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmb3IgKDsgZmlyc3QgPCBuZXh0OyBmaXJzdCsrKSB7XG5cdCAgICAgICAgICAgICAgICBmZFNlbGVjdC5wdXNoKGZkSW5kZXgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZpcnN0ID0gbmV4dDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG5leHQgIT09IG5HbHlwaHMpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgZm9ybWF0IDMgcmFuZ2UgaGFzIGJhZCBmaW5hbCBHSUQgJyArIG5leHQpO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgdGFibGUgaGFzIHVuc3VwcG9ydGVkIGZvcm1hdCAnICsgZm9ybWF0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmZFNlbGVjdDtcblx0fVxuXG5cdC8vIFBhcnNlIHRoZSBgQ0ZGYCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuXHRmdW5jdGlvbiBwYXJzZUNGRlRhYmxlKGRhdGEsIHN0YXJ0LCBmb250KSB7XG5cdCAgICBmb250LnRhYmxlcy5jZmYgPSB7fTtcblx0ICAgIHZhciBoZWFkZXIgPSBwYXJzZUNGRkhlYWRlcihkYXRhLCBzdGFydCk7XG5cdCAgICB2YXIgbmFtZUluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBoZWFkZXIuZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcblx0ICAgIHZhciB0b3BEaWN0SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIG5hbWVJbmRleC5lbmRPZmZzZXQpO1xuXHQgICAgdmFyIHN0cmluZ0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCB0b3BEaWN0SW5kZXguZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcblx0ICAgIHZhciBnbG9iYWxTdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0cmluZ0luZGV4LmVuZE9mZnNldCk7XG5cdCAgICBmb250LmdzdWJycyA9IGdsb2JhbFN1YnJJbmRleC5vYmplY3RzO1xuXHQgICAgZm9udC5nc3VicnNCaWFzID0gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKGZvbnQuZ3N1YnJzKTtcblxuXHQgICAgdmFyIHRvcERpY3RBcnJheSA9IGdhdGhlckNGRlRvcERpY3RzKGRhdGEsIHN0YXJ0LCB0b3BEaWN0SW5kZXgub2JqZWN0cywgc3RyaW5nSW5kZXgub2JqZWN0cyk7XG5cdCAgICBpZiAodG9wRGljdEFycmF5Lmxlbmd0aCAhPT0gMSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIHRhYmxlIGhhcyB0b28gbWFueSBmb250cyBpbiBcXCdGb250U2V0XFwnIC0gY291bnQgb2YgZm9udHMgTmFtZUluZGV4Lmxlbmd0aCA9ICcgKyB0b3BEaWN0QXJyYXkubGVuZ3RoKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHRvcERpY3QgPSB0b3BEaWN0QXJyYXlbMF07XG5cdCAgICBmb250LnRhYmxlcy5jZmYudG9wRGljdCA9IHRvcERpY3Q7XG5cblx0ICAgIGlmICh0b3BEaWN0Ll9wcml2YXRlRGljdCkge1xuXHQgICAgICAgIGZvbnQuZGVmYXVsdFdpZHRoWCA9IHRvcERpY3QuX3ByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG5cdCAgICAgICAgZm9udC5ub21pbmFsV2lkdGhYID0gdG9wRGljdC5fcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRvcERpY3Qucm9zWzBdICE9PSB1bmRlZmluZWQgJiYgdG9wRGljdC5yb3NbMV0gIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGZvbnQuaXNDSURGb250ID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGZvbnQuaXNDSURGb250KSB7XG5cdCAgICAgICAgdmFyIGZkQXJyYXlPZmZzZXQgPSB0b3BEaWN0LmZkQXJyYXk7XG5cdCAgICAgICAgdmFyIGZkU2VsZWN0T2Zmc2V0ID0gdG9wRGljdC5mZFNlbGVjdDtcblx0ICAgICAgICBpZiAoZmRBcnJheU9mZnNldCA9PT0gMCB8fCBmZFNlbGVjdE9mZnNldCA9PT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvbnQgaXMgbWFya2VkIGFzIGEgQ0lEIGZvbnQsIGJ1dCBGREFycmF5IGFuZC9vciBGRFNlbGVjdCBpbmZvcm1hdGlvbiBpcyBtaXNzaW5nJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZkQXJyYXlPZmZzZXQgKz0gc3RhcnQ7XG5cdCAgICAgICAgdmFyIGZkQXJyYXlJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgZmRBcnJheU9mZnNldCk7XG5cdCAgICAgICAgdmFyIGZkQXJyYXkgPSBnYXRoZXJDRkZUb3BEaWN0cyhkYXRhLCBzdGFydCwgZmRBcnJheUluZGV4Lm9iamVjdHMsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuXHQgICAgICAgIHRvcERpY3QuX2ZkQXJyYXkgPSBmZEFycmF5O1xuXHQgICAgICAgIGZkU2VsZWN0T2Zmc2V0ICs9IHN0YXJ0O1xuXHQgICAgICAgIHRvcERpY3QuX2ZkU2VsZWN0ID0gcGFyc2VDRkZGRFNlbGVjdChkYXRhLCBmZFNlbGVjdE9mZnNldCwgZm9udC5udW1HbHlwaHMsIGZkQXJyYXkubGVuZ3RoKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHByaXZhdGVEaWN0T2Zmc2V0ID0gc3RhcnQgKyB0b3BEaWN0LnByaXZhdGVbMV07XG5cdCAgICB2YXIgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHByaXZhdGVEaWN0T2Zmc2V0LCB0b3BEaWN0LnByaXZhdGVbMF0sIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuXHQgICAgZm9udC5kZWZhdWx0V2lkdGhYID0gcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcblx0ICAgIGZvbnQubm9taW5hbFdpZHRoWCA9IHByaXZhdGVEaWN0Lm5vbWluYWxXaWR0aFg7XG5cblx0ICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuXHQgICAgICAgIHZhciBzdWJyT2Zmc2V0ID0gcHJpdmF0ZURpY3RPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcblx0ICAgICAgICB2YXIgc3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdWJyT2Zmc2V0KTtcblx0ICAgICAgICBmb250LnN1YnJzID0gc3VickluZGV4Lm9iamVjdHM7XG5cdCAgICAgICAgZm9udC5zdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5zdWJycyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGZvbnQuc3VicnMgPSBbXTtcblx0ICAgICAgICBmb250LnN1YnJzQmlhcyA9IDA7XG5cdCAgICB9XG5cblx0ICAgIC8vIE9mZnNldHMgaW4gdGhlIHRvcCBkaWN0IGFyZSByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBDRkYgZGF0YSwgc28gYWRkIHRoZSBDRkYgc3RhcnQgb2Zmc2V0LlxuXHQgICAgdmFyIGNoYXJTdHJpbmdzSW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyU3RyaW5ncyk7XG5cdCAgICBmb250Lm5HbHlwaHMgPSBjaGFyU3RyaW5nc0luZGV4Lm9iamVjdHMubGVuZ3RoO1xuXG5cdCAgICB2YXIgY2hhcnNldCA9IHBhcnNlQ0ZGQ2hhcnNldChkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhcnNldCwgZm9udC5uR2x5cGhzLCBzdHJpbmdJbmRleC5vYmplY3RzKTtcblx0ICAgIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAwKSB7XG5cdCAgICAgICAgLy8gU3RhbmRhcmQgZW5jb2Rpbmdcblx0ICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IENmZkVuY29kaW5nKGNmZlN0YW5kYXJkRW5jb2RpbmcsIGNoYXJzZXQpO1xuXHQgICAgfSBlbHNlIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAxKSB7XG5cdCAgICAgICAgLy8gRXhwZXJ0IGVuY29kaW5nXG5cdCAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IG5ldyBDZmZFbmNvZGluZyhjZmZFeHBlcnRFbmNvZGluZywgY2hhcnNldCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBwYXJzZUNGRkVuY29kaW5nKGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5lbmNvZGluZywgY2hhcnNldCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIFByZWZlciB0aGUgQ01BUCBlbmNvZGluZyB0byB0aGUgQ0ZGIGVuY29kaW5nLlxuXHQgICAgZm9udC5lbmNvZGluZyA9IGZvbnQuZW5jb2RpbmcgfHwgZm9udC5jZmZFbmNvZGluZztcblxuXHQgICAgZm9udC5nbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQoZm9udCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbnQubkdseXBoczsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGNoYXJTdHJpbmcgPSBjaGFyU3RyaW5nc0luZGV4Lm9iamVjdHNbaV07XG5cdCAgICAgICAgZm9udC5nbHlwaHMucHVzaChpLCBnbHlwaHNldC5jZmZHbHlwaExvYWRlcihmb250LCBpLCBwYXJzZUNGRkNoYXJzdHJpbmcsIGNoYXJTdHJpbmcpKTtcblx0ICAgIH1cblx0fVxuXG5cdC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBTdHJpbmcgSUQgKFNJRCkuXG5cdC8vIFRoZSBsaXN0IG9mIHN0cmluZ3MgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG5cdGZ1bmN0aW9uIGVuY29kZVN0cmluZyhzLCBzdHJpbmdzKSB7XG5cdCAgICB2YXIgc2lkO1xuXG5cdCAgICAvLyBJcyB0aGUgc3RyaW5nIGluIHRoZSBDRkYgc3RhbmRhcmQgc3RyaW5ncz9cblx0ICAgIHZhciBpID0gY2ZmU3RhbmRhcmRTdHJpbmdzLmluZGV4T2Yocyk7XG5cdCAgICBpZiAoaSA+PSAwKSB7XG5cdCAgICAgICAgc2lkID0gaTtcblx0ICAgIH1cblxuXHQgICAgLy8gSXMgdGhlIHN0cmluZyBhbHJlYWR5IGluIHRoZSBzdHJpbmcgaW5kZXg/XG5cdCAgICBpID0gc3RyaW5ncy5pbmRleE9mKHMpO1xuXHQgICAgaWYgKGkgPj0gMCkge1xuXHQgICAgICAgIHNpZCA9IGkgKyBjZmZTdGFuZGFyZFN0cmluZ3MubGVuZ3RoO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBzaWQgPSBjZmZTdGFuZGFyZFN0cmluZ3MubGVuZ3RoICsgc3RyaW5ncy5sZW5ndGg7XG5cdCAgICAgICAgc3RyaW5ncy5wdXNoKHMpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gc2lkO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZUhlYWRlcigpIHtcblx0ICAgIHJldHVybiBuZXcgdGFibGUuUmVjb3JkKCdIZWFkZXInLCBbXG5cdCAgICAgICAge25hbWU6ICdtYWpvcicsIHR5cGU6ICdDYXJkOCcsIHZhbHVlOiAxfSxcblx0ICAgICAgICB7bmFtZTogJ21pbm9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnaGRyU2l6ZScsIHR5cGU6ICdDYXJkOCcsIHZhbHVlOiA0fSxcblx0ICAgICAgICB7bmFtZTogJ21ham9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDF9XG5cdCAgICBdKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VOYW1lSW5kZXgoZm9udE5hbWVzKSB7XG5cdCAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ05hbWUgSU5ERVgnLCBbXG5cdCAgICAgICAge25hbWU6ICduYW1lcycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cblx0ICAgIF0pO1xuXHQgICAgdC5uYW1lcyA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250TmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB0Lm5hbWVzLnB1c2goe25hbWU6ICduYW1lXycgKyBpLCB0eXBlOiAnTkFNRScsIHZhbHVlOiBmb250TmFtZXNbaV19KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHQ7XG5cdH1cblxuXHQvLyBHaXZlbiBhIGRpY3Rpb25hcnkncyBtZXRhZGF0YSwgY3JlYXRlIGEgRElDVCBzdHJ1Y3R1cmUuXG5cdGZ1bmN0aW9uIG1ha2VEaWN0KG1ldGEsIGF0dHJzLCBzdHJpbmdzKSB7XG5cdCAgICB2YXIgbSA9IHt9O1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGVudHJ5ID0gbWV0YVtpXTtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1tlbnRyeS5uYW1lXTtcblx0ICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXF1YWxzKHZhbHVlLCBlbnRyeS52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdTSUQnKSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGVuY29kZVN0cmluZyh2YWx1ZSwgc3RyaW5ncyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBtW2VudHJ5Lm9wXSA9IHtuYW1lOiBlbnRyeS5uYW1lLCB0eXBlOiBlbnRyeS50eXBlLCB2YWx1ZTogdmFsdWV9O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG07XG5cdH1cblxuXHQvLyBUaGUgVG9wIERJQ1QgaG91c2VzIHRoZSBnbG9iYWwgZm9udCBhdHRyaWJ1dGVzLlxuXHRmdW5jdGlvbiBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncykge1xuXHQgICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdUb3AgRElDVCcsIFtcblx0ICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cblx0ICAgIF0pO1xuXHQgICAgdC5kaWN0ID0gbWFrZURpY3QoVE9QX0RJQ1RfTUVUQSwgYXR0cnMsIHN0cmluZ3MpO1xuXHQgICAgcmV0dXJuIHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpIHtcblx0ICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnVG9wIERJQ1QgSU5ERVgnLCBbXG5cdCAgICAgICAge25hbWU6ICd0b3BEaWN0cycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cblx0ICAgIF0pO1xuXHQgICAgdC50b3BEaWN0cyA9IFt7bmFtZTogJ3RvcERpY3RfMCcsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiB0b3BEaWN0fV07XG5cdCAgICByZXR1cm4gdDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VTdHJpbmdJbmRleChzdHJpbmdzKSB7XG5cdCAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ1N0cmluZyBJTkRFWCcsIFtcblx0ICAgICAgICB7bmFtZTogJ3N0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG5cdCAgICBdKTtcblx0ICAgIHQuc3RyaW5ncyA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdC5zdHJpbmdzLnB1c2goe25hbWU6ICdzdHJpbmdfJyArIGksIHR5cGU6ICdTVFJJTkcnLCB2YWx1ZTogc3RyaW5nc1tpXX0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VHbG9iYWxTdWJySW5kZXgoKSB7XG5cdCAgICAvLyBDdXJyZW50bHkgd2UgZG9uJ3QgdXNlIHN1YnJvdXRpbmVzLlxuXHQgICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ0dsb2JhbCBTdWJyIElOREVYJywgW1xuXHQgICAgICAgIHtuYW1lOiAnc3VicnMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG5cdCAgICBdKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VDaGFyc2V0cyhnbHlwaE5hbWVzLCBzdHJpbmdzKSB7XG5cdCAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ0NoYXJzZXRzJywgW1xuXHQgICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9XG5cdCAgICBdKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhOYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBnbHlwaE5hbWUgPSBnbHlwaE5hbWVzW2ldO1xuXHQgICAgICAgIHZhciBnbHlwaFNJRCA9IGVuY29kZVN0cmluZyhnbHlwaE5hbWUsIHN0cmluZ3MpO1xuXHQgICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdnbHlwaF8nICsgaSwgdHlwZTogJ1NJRCcsIHZhbHVlOiBnbHlwaFNJRH0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdseXBoVG9PcHMoZ2x5cGgpIHtcblx0ICAgIHZhciBvcHMgPSBbXTtcblx0ICAgIHZhciBwYXRoID0gZ2x5cGgucGF0aDtcblx0ICAgIG9wcy5wdXNoKHtuYW1lOiAnd2lkdGgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGdseXBoLmFkdmFuY2VXaWR0aH0pO1xuXHQgICAgdmFyIHggPSAwO1xuXHQgICAgdmFyIHkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGR4ID0gKHZvaWQgMCk7XG5cdCAgICAgICAgdmFyIGR5ID0gKHZvaWQgMCk7XG5cdCAgICAgICAgdmFyIGNtZCA9IHBhdGguY29tbWFuZHNbaV07XG5cdCAgICAgICAgaWYgKGNtZC50eXBlID09PSAnUScpIHtcblx0ICAgICAgICAgICAgLy8gQ0ZGIG9ubHkgc3VwcG9ydHMgYsOpemllciBjdXJ2ZXMsIHNvIGNvbnZlcnQgdGhlIHF1YWQgdG8gYSBiw6l6aWVyLlxuXHQgICAgICAgICAgICB2YXIgXzEzID0gMSAvIDM7XG5cdCAgICAgICAgICAgIHZhciBfMjMgPSAyIC8gMztcblxuXHQgICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBjcmVhdGUgYSBuZXcgY29tbWFuZCBzbyB3ZSBkb24ndCBjaGFuZ2UgdGhlIG9yaWdpbmFsIHBhdGguXG5cdCAgICAgICAgICAgIGNtZCA9IHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6ICdDJyxcblx0ICAgICAgICAgICAgICAgIHg6IGNtZC54LFxuXHQgICAgICAgICAgICAgICAgeTogY21kLnksXG5cdCAgICAgICAgICAgICAgICB4MTogXzEzICogeCArIF8yMyAqIGNtZC54MSxcblx0ICAgICAgICAgICAgICAgIHkxOiBfMTMgKiB5ICsgXzIzICogY21kLnkxLFxuXHQgICAgICAgICAgICAgICAgeDI6IF8xMyAqIGNtZC54ICsgXzIzICogY21kLngxLFxuXHQgICAgICAgICAgICAgICAgeTI6IF8xMyAqIGNtZC55ICsgXzIzICogY21kLnkxXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcblx0ICAgICAgICAgICAgZHggPSBNYXRoLnJvdW5kKGNtZC54IC0geCk7XG5cdCAgICAgICAgICAgIGR5ID0gTWF0aC5yb3VuZChjbWQueSAtIHkpO1xuXHQgICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeH0pO1xuXHQgICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuXHQgICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ3Jtb3ZldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogMjF9KTtcblx0ICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoY21kLngpO1xuXHQgICAgICAgICAgICB5ID0gTWF0aC5yb3VuZChjbWQueSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG5cdCAgICAgICAgICAgIGR4ID0gTWF0aC5yb3VuZChjbWQueCAtIHgpO1xuXHQgICAgICAgICAgICBkeSA9IE1hdGgucm91bmQoY21kLnkgLSB5KTtcblx0ICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcblx0ICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHl9KTtcblx0ICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdybGluZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDV9KTtcblx0ICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoY21kLngpO1xuXHQgICAgICAgICAgICB5ID0gTWF0aC5yb3VuZChjbWQueSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG5cdCAgICAgICAgICAgIHZhciBkeDEgPSBNYXRoLnJvdW5kKGNtZC54MSAtIHgpO1xuXHQgICAgICAgICAgICB2YXIgZHkxID0gTWF0aC5yb3VuZChjbWQueTEgLSB5KTtcblx0ICAgICAgICAgICAgdmFyIGR4MiA9IE1hdGgucm91bmQoY21kLngyIC0gY21kLngxKTtcblx0ICAgICAgICAgICAgdmFyIGR5MiA9IE1hdGgucm91bmQoY21kLnkyIC0gY21kLnkxKTtcblx0ICAgICAgICAgICAgZHggPSBNYXRoLnJvdW5kKGNtZC54IC0gY21kLngyKTtcblx0ICAgICAgICAgICAgZHkgPSBNYXRoLnJvdW5kKGNtZC55IC0gY21kLnkyKTtcblx0ICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeDEnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4MX0pO1xuXHQgICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5MScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHkxfSk7XG5cdCAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgyJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeDJ9KTtcblx0ICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeTInLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5Mn0pO1xuXHQgICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeH0pO1xuXHQgICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuXHQgICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ3JyY3VydmV0bycsIHR5cGU6ICdPUCcsIHZhbHVlOiA4fSk7XG5cdCAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKGNtZC54KTtcblx0ICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoY21kLnkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENvbnRvdXJzIGFyZSBjbG9zZWQgYXV0b21hdGljYWxseS5cblx0ICAgIH1cblxuXHQgICAgb3BzLnB1c2goe25hbWU6ICdlbmRjaGFyJywgdHlwZTogJ09QJywgdmFsdWU6IDE0fSk7XG5cdCAgICByZXR1cm4gb3BzO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZUNoYXJTdHJpbmdzSW5kZXgoZ2x5cGhzKSB7XG5cdCAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ0NoYXJTdHJpbmdzIElOREVYJywgW1xuXHQgICAgICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG5cdCAgICBdKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuXHQgICAgICAgIHZhciBvcHMgPSBnbHlwaFRvT3BzKGdseXBoKTtcblx0ICAgICAgICB0LmNoYXJTdHJpbmdzLnB1c2goe25hbWU6IGdseXBoLm5hbWUsIHR5cGU6ICdDSEFSU1RSSU5HJywgdmFsdWU6IG9wc30pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VQcml2YXRlRGljdChhdHRycywgc3RyaW5ncykge1xuXHQgICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdQcml2YXRlIERJQ1QnLCBbXG5cdCAgICAgICAge25hbWU6ICdkaWN0JywgdHlwZTogJ0RJQ1QnLCB2YWx1ZToge319XG5cdCAgICBdKTtcblx0ICAgIHQuZGljdCA9IG1ha2VEaWN0KFBSSVZBVEVfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG5cdCAgICByZXR1cm4gdDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VDRkZUYWJsZShnbHlwaHMsIG9wdGlvbnMpIHtcblx0ICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdDRkYgJywgW1xuXHQgICAgICAgIHtuYW1lOiAnaGVhZGVyJywgdHlwZTogJ1JFQ09SRCd9LFxuXHQgICAgICAgIHtuYW1lOiAnbmFtZUluZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuXHQgICAgICAgIHtuYW1lOiAndG9wRGljdEluZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuXHQgICAgICAgIHtuYW1lOiAnc3RyaW5nSW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG5cdCAgICAgICAge25hbWU6ICdnbG9iYWxTdWJySW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG5cdCAgICAgICAge25hbWU6ICdjaGFyc2V0cycsIHR5cGU6ICdSRUNPUkQnfSxcblx0ICAgICAgICB7bmFtZTogJ2NoYXJTdHJpbmdzSW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG5cdCAgICAgICAge25hbWU6ICdwcml2YXRlRGljdCcsIHR5cGU6ICdSRUNPUkQnfVxuXHQgICAgXSk7XG5cblx0ICAgIHZhciBmb250U2NhbGUgPSAxIC8gb3B0aW9ucy51bml0c1BlckVtO1xuXHQgICAgLy8gV2UgdXNlIG5vbi16ZXJvIHZhbHVlcyBmb3IgdGhlIG9mZnNldHMgc28gdGhhdCB0aGUgRElDVCBlbmNvZGVzIHRoZW0uXG5cdCAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBzaXplIG9mIHRoZSBUb3AgRElDVCBwbGF5cyBhIHJvbGUgaW4gb2Zmc2V0IGNhbGN1bGF0aW9uLFxuXHQgICAgLy8gYW5kIHRoZSBzaXplIHNob3VsZG4ndCBjaGFuZ2UgYWZ0ZXIgd2UndmUgd3JpdHRlbiBjb3JyZWN0IG9mZnNldHMuXG5cdCAgICB2YXIgYXR0cnMgPSB7XG5cdCAgICAgICAgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uLFxuXHQgICAgICAgIGZ1bGxOYW1lOiBvcHRpb25zLmZ1bGxOYW1lLFxuXHQgICAgICAgIGZhbWlseU5hbWU6IG9wdGlvbnMuZmFtaWx5TmFtZSxcblx0ICAgICAgICB3ZWlnaHQ6IG9wdGlvbnMud2VpZ2h0TmFtZSxcblx0ICAgICAgICBmb250QkJveDogb3B0aW9ucy5mb250QkJveCB8fCBbMCwgMCwgMCwgMF0sXG5cdCAgICAgICAgZm9udE1hdHJpeDogW2ZvbnRTY2FsZSwgMCwgMCwgZm9udFNjYWxlLCAwLCAwXSxcblx0ICAgICAgICBjaGFyc2V0OiA5OTksXG5cdCAgICAgICAgZW5jb2Rpbmc6IDAsXG5cdCAgICAgICAgY2hhclN0cmluZ3M6IDk5OSxcblx0ICAgICAgICBwcml2YXRlOiBbMCwgOTk5XVxuXHQgICAgfTtcblxuXHQgICAgdmFyIHByaXZhdGVBdHRycyA9IHt9O1xuXG5cdCAgICB2YXIgZ2x5cGhOYW1lcyA9IFtdO1xuXHQgICAgdmFyIGdseXBoO1xuXG5cdCAgICAvLyBTa2lwIGZpcnN0IGdseXBoICgubm90ZGVmKVxuXHQgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG5cdCAgICAgICAgZ2x5cGhOYW1lcy5wdXNoKGdseXBoLm5hbWUpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc3RyaW5ncyA9IFtdO1xuXG5cdCAgICB0LmhlYWRlciA9IG1ha2VIZWFkZXIoKTtcblx0ICAgIHQubmFtZUluZGV4ID0gbWFrZU5hbWVJbmRleChbb3B0aW9ucy5wb3N0U2NyaXB0TmFtZV0pO1xuXHQgICAgdmFyIHRvcERpY3QgPSBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncyk7XG5cdCAgICB0LnRvcERpY3RJbmRleCA9IG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCk7XG5cdCAgICB0Lmdsb2JhbFN1YnJJbmRleCA9IG1ha2VHbG9iYWxTdWJySW5kZXgoKTtcblx0ICAgIHQuY2hhcnNldHMgPSBtYWtlQ2hhcnNldHMoZ2x5cGhOYW1lcywgc3RyaW5ncyk7XG5cdCAgICB0LmNoYXJTdHJpbmdzSW5kZXggPSBtYWtlQ2hhclN0cmluZ3NJbmRleChnbHlwaHMpO1xuXHQgICAgdC5wcml2YXRlRGljdCA9IG1ha2VQcml2YXRlRGljdChwcml2YXRlQXR0cnMsIHN0cmluZ3MpO1xuXG5cdCAgICAvLyBOZWVkcyB0byBjb21lIGF0IHRoZSBlbmQsIHRvIGVuY29kZSBhbGwgY3VzdG9tIHN0cmluZ3MgdXNlZCBpbiB0aGUgZm9udC5cblx0ICAgIHQuc3RyaW5nSW5kZXggPSBtYWtlU3RyaW5nSW5kZXgoc3RyaW5ncyk7XG5cblx0ICAgIHZhciBzdGFydE9mZnNldCA9IHQuaGVhZGVyLnNpemVPZigpICtcblx0ICAgICAgICB0Lm5hbWVJbmRleC5zaXplT2YoKSArXG5cdCAgICAgICAgdC50b3BEaWN0SW5kZXguc2l6ZU9mKCkgK1xuXHQgICAgICAgIHQuc3RyaW5nSW5kZXguc2l6ZU9mKCkgK1xuXHQgICAgICAgIHQuZ2xvYmFsU3VickluZGV4LnNpemVPZigpO1xuXHQgICAgYXR0cnMuY2hhcnNldCA9IHN0YXJ0T2Zmc2V0O1xuXG5cdCAgICAvLyBXZSB1c2UgdGhlIENGRiBzdGFuZGFyZCBlbmNvZGluZzsgcHJvcGVyIGVuY29kaW5nIHdpbGwgYmUgaGFuZGxlZCBpbiBjbWFwLlxuXHQgICAgYXR0cnMuZW5jb2RpbmcgPSAwO1xuXHQgICAgYXR0cnMuY2hhclN0cmluZ3MgPSBhdHRycy5jaGFyc2V0ICsgdC5jaGFyc2V0cy5zaXplT2YoKTtcblx0ICAgIGF0dHJzLnByaXZhdGVbMV0gPSBhdHRycy5jaGFyU3RyaW5ncyArIHQuY2hhclN0cmluZ3NJbmRleC5zaXplT2YoKTtcblxuXHQgICAgLy8gUmVjcmVhdGUgdGhlIFRvcCBESUNUIElOREVYIHdpdGggdGhlIGNvcnJlY3Qgb2Zmc2V0cy5cblx0ICAgIHRvcERpY3QgPSBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncyk7XG5cdCAgICB0LnRvcERpY3RJbmRleCA9IG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCk7XG5cblx0ICAgIHJldHVybiB0O1xuXHR9XG5cblx0dmFyIGNmZiA9IHsgcGFyc2U6IHBhcnNlQ0ZGVGFibGUsIG1ha2U6IG1ha2VDRkZUYWJsZSB9O1xuXG5cdC8vIFRoZSBgaGVhZGAgdGFibGUgY29udGFpbnMgZ2xvYmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmb250LlxuXG5cdC8vIFBhcnNlIHRoZSBoZWFkZXIgYGhlYWRgIHRhYmxlXG5cdGZ1bmN0aW9uIHBhcnNlSGVhZFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG5cdCAgICB2YXIgaGVhZCA9IHt9O1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIGhlYWQudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG5cdCAgICBoZWFkLmZvbnRSZXZpc2lvbiA9IE1hdGgucm91bmQocC5wYXJzZUZpeGVkKCkgKiAxMDAwKSAvIDEwMDA7XG5cdCAgICBoZWFkLmNoZWNrU3VtQWRqdXN0bWVudCA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgaGVhZC5tYWdpY051bWJlciA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgY2hlY2suYXJndW1lbnQoaGVhZC5tYWdpY051bWJlciA9PT0gMHg1RjBGM0NGNSwgJ0ZvbnQgaGVhZGVyIGhhcyB3cm9uZyBtYWdpYyBudW1iZXIuJyk7XG5cdCAgICBoZWFkLmZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgaGVhZC51bml0c1BlckVtID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgaGVhZC5jcmVhdGVkID0gcC5wYXJzZUxvbmdEYXRlVGltZSgpO1xuXHQgICAgaGVhZC5tb2RpZmllZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcblx0ICAgIGhlYWQueE1pbiA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgaGVhZC55TWluID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBoZWFkLnhNYXggPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGhlYWQueU1heCA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgaGVhZC5tYWNTdHlsZSA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIGhlYWQubG93ZXN0UmVjUFBFTSA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIGhlYWQuZm9udERpcmVjdGlvbkhpbnQgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGhlYWQuaW5kZXhUb0xvY0Zvcm1hdCA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgaGVhZC5nbHlwaERhdGFGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIHJldHVybiBoZWFkO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZUhlYWRUYWJsZShvcHRpb25zKSB7XG5cdCAgICAvLyBBcHBsZSBNYWMgdGltZXN0YW1wIGVwb2NoIGlzIDAxLzAxLzE5MDQgbm90IDAxLzAxLzE5NzBcblx0ICAgIHZhciB0aW1lc3RhbXAgPSBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyAyMDgyODQ0ODAwO1xuXHQgICAgdmFyIGNyZWF0ZWRUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG5cblx0ICAgIGlmIChvcHRpb25zLmNyZWF0ZWRUaW1lc3RhbXApIHtcblx0ICAgICAgICBjcmVhdGVkVGltZXN0YW1wID0gb3B0aW9ucy5jcmVhdGVkVGltZXN0YW1wICsgMjA4Mjg0NDgwMDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnaGVhZCcsIFtcblx0ICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG5cdCAgICAgICAge25hbWU6ICdmb250UmV2aXNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG5cdCAgICAgICAge25hbWU6ICdjaGVja1N1bUFkanVzdG1lbnQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdtYWdpY051bWJlcicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDVGMEYzQ0Y1fSxcblx0ICAgICAgICB7bmFtZTogJ2ZsYWdzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VuaXRzUGVyRW0nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDEwMDB9LFxuXHQgICAgICAgIHtuYW1lOiAnY3JlYXRlZCcsIHR5cGU6ICdMT05HREFURVRJTUUnLCB2YWx1ZTogY3JlYXRlZFRpbWVzdGFtcH0sXG5cdCAgICAgICAge25hbWU6ICdtb2RpZmllZCcsIHR5cGU6ICdMT05HREFURVRJTUUnLCB2YWx1ZTogdGltZXN0YW1wfSxcblx0ICAgICAgICB7bmFtZTogJ3hNaW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd5TWluJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAneE1heCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3lNYXgnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdtYWNTdHlsZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdsb3dlc3RSZWNQUEVNJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2ZvbnREaXJlY3Rpb25IaW50JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDJ9LFxuXHQgICAgICAgIHtuYW1lOiAnaW5kZXhUb0xvY0Zvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2dseXBoRGF0YUZvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfVxuXHQgICAgXSwgb3B0aW9ucyk7XG5cdH1cblxuXHR2YXIgaGVhZCA9IHsgcGFyc2U6IHBhcnNlSGVhZFRhYmxlLCBtYWtlOiBtYWtlSGVhZFRhYmxlIH07XG5cblx0Ly8gVGhlIGBoaGVhYCB0YWJsZSBjb250YWlucyBpbmZvcm1hdGlvbiBmb3IgaG9yaXpvbnRhbCBsYXlvdXQuXG5cblx0Ly8gUGFyc2UgdGhlIGhvcml6b250YWwgaGVhZGVyIGBoaGVhYCB0YWJsZVxuXHRmdW5jdGlvbiBwYXJzZUhoZWFUYWJsZShkYXRhLCBzdGFydCkge1xuXHQgICAgdmFyIGhoZWEgPSB7fTtcblx0ICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cdCAgICBoaGVhLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuXHQgICAgaGhlYS5hc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgaGhlYS5kZXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGhoZWEubGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgaGhlYS5hZHZhbmNlV2lkdGhNYXggPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICBoaGVhLm1pbkxlZnRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgaGhlYS5taW5SaWdodFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBoaGVhLnhNYXhFeHRlbnQgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGhoZWEuY2FyZXRTbG9wZVJpc2UgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGhoZWEuY2FyZXRTbG9wZVJ1biA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgaGhlYS5jYXJldE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgcC5yZWxhdGl2ZU9mZnNldCArPSA4O1xuXHQgICAgaGhlYS5tZXRyaWNEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBoaGVhLm51bWJlck9mSE1ldHJpY3MgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICByZXR1cm4gaGhlYTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VIaGVhVGFibGUob3B0aW9ucykge1xuXHQgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnaGhlYScsIFtcblx0ICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG5cdCAgICAgICAge25hbWU6ICdhc2NlbmRlcicsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2Rlc2NlbmRlcicsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2xpbmVHYXAnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdhZHZhbmNlV2lkdGhNYXgnLCB0eXBlOiAnVUZXT1JEJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbWluTGVmdFNpZGVCZWFyaW5nJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbWluUmlnaHRTaWRlQmVhcmluZycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3hNYXhFeHRlbnQnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdjYXJldFNsb3BlUmlzZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAxfSxcblx0ICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSdW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdjYXJldE9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMycsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3Jlc2VydmVkNCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ21ldHJpY0RhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdudW1iZXJPZkhNZXRyaWNzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuXHQgICAgXSwgb3B0aW9ucyk7XG5cdH1cblxuXHR2YXIgaGhlYSA9IHsgcGFyc2U6IHBhcnNlSGhlYVRhYmxlLCBtYWtlOiBtYWtlSGhlYVRhYmxlIH07XG5cblx0Ly8gVGhlIGBobXR4YCB0YWJsZSBjb250YWlucyB0aGUgaG9yaXpvbnRhbCBtZXRyaWNzIGZvciBhbGwgZ2x5cGhzLlxuXG5cdC8vIFBhcnNlIHRoZSBgaG10eGAgdGFibGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG5cdC8vIFRoaXMgZnVuY3Rpb24gYXVnbWVudHMgdGhlIGdseXBoIGFycmF5LCBhZGRpbmcgdGhlIGFkdmFuY2VXaWR0aCBhbmQgbGVmdFNpZGVCZWFyaW5nIHRvIGVhY2ggZ2x5cGguXG5cdGZ1bmN0aW9uIHBhcnNlSG10eFRhYmxlKGRhdGEsIHN0YXJ0LCBudW1NZXRyaWNzLCBudW1HbHlwaHMsIGdseXBocykge1xuXHQgICAgdmFyIGFkdmFuY2VXaWR0aDtcblx0ICAgIHZhciBsZWZ0U2lkZUJlYXJpbmc7XG5cdCAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1HbHlwaHM7IGkgKz0gMSkge1xuXHQgICAgICAgIC8vIElmIHRoZSBmb250IGlzIG1vbm9zcGFjZWQsIG9ubHkgb25lIGVudHJ5IGlzIG5lZWRlZC4gVGhpcyBsYXN0IGVudHJ5IGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgZ2x5cGhzLlxuXHQgICAgICAgIGlmIChpIDwgbnVtTWV0cmljcykge1xuXHQgICAgICAgICAgICBhZHZhbmNlV2lkdGggPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgICAgIGxlZnRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG5cdCAgICAgICAgZ2x5cGguYWR2YW5jZVdpZHRoID0gYWR2YW5jZVdpZHRoO1xuXHQgICAgICAgIGdseXBoLmxlZnRTaWRlQmVhcmluZyA9IGxlZnRTaWRlQmVhcmluZztcblx0ICAgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VIbXR4VGFibGUoZ2x5cGhzKSB7XG5cdCAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnaG10eCcsIFtdKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzLmdldChpKTtcblx0ICAgICAgICB2YXIgYWR2YW5jZVdpZHRoID0gZ2x5cGguYWR2YW5jZVdpZHRoIHx8IDA7XG5cdCAgICAgICAgdmFyIGxlZnRTaWRlQmVhcmluZyA9IGdseXBoLmxlZnRTaWRlQmVhcmluZyB8fCAwO1xuXHQgICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdhZHZhbmNlV2lkdGhfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogYWR2YW5jZVdpZHRofSk7XG5cdCAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2xlZnRTaWRlQmVhcmluZ18nICsgaSwgdHlwZTogJ1NIT1JUJywgdmFsdWU6IGxlZnRTaWRlQmVhcmluZ30pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdDtcblx0fVxuXG5cdHZhciBobXR4ID0geyBwYXJzZTogcGFyc2VIbXR4VGFibGUsIG1ha2U6IG1ha2VIbXR4VGFibGUgfTtcblxuXHQvLyBUaGUgYGx0YWdgIHRhYmxlIHN0b3JlcyBJRVRGIEJDUC00NyBsYW5ndWFnZSB0YWdzLiBJdCBhbGxvd3Mgc3VwcG9ydGluZ1xuXG5cdGZ1bmN0aW9uIG1ha2VMdGFnVGFibGUodGFncykge1xuXHQgICAgdmFyIHJlc3VsdCA9IG5ldyB0YWJsZS5UYWJsZSgnbHRhZycsIFtcblx0ICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMX0sXG5cdCAgICAgICAge25hbWU6ICdmbGFncycsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ251bVRhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogdGFncy5sZW5ndGh9XG5cdCAgICBdKTtcblxuXHQgICAgdmFyIHN0cmluZ1Bvb2wgPSAnJztcblx0ICAgIHZhciBzdHJpbmdQb29sT2Zmc2V0ID0gMTIgKyB0YWdzLmxlbmd0aCAqIDQ7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhZ3MubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICB2YXIgcG9zID0gc3RyaW5nUG9vbC5pbmRleE9mKHRhZ3NbaV0pO1xuXHQgICAgICAgIGlmIChwb3MgPCAwKSB7XG5cdCAgICAgICAgICAgIHBvcyA9IHN0cmluZ1Bvb2wubGVuZ3RoO1xuXHQgICAgICAgICAgICBzdHJpbmdQb29sICs9IHRhZ3NbaV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnb2Zmc2V0ICcgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHN0cmluZ1Bvb2xPZmZzZXQgKyBwb3N9KTtcblx0ICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdsZW5ndGggJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogdGFnc1tpXS5sZW5ndGh9KTtcblx0ICAgIH1cblxuXHQgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnc3RyaW5nUG9vbCcsIHR5cGU6ICdDSEFSQVJSQVknLCB2YWx1ZTogc3RyaW5nUG9vbH0pO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlTHRhZ1RhYmxlKGRhdGEsIHN0YXJ0KSB7XG5cdCAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxLCAnVW5zdXBwb3J0ZWQgbHRhZyB0YWJsZSB2ZXJzaW9uLicpO1xuXHQgICAgLy8gVGhlICdsdGFnJyBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IGRlZmluZSBhbnkgZmxhZ3M7IHNraXAgdGhlIGZpZWxkLlxuXHQgICAgcC5za2lwKCd1TG9uZycsIDEpO1xuXHQgICAgdmFyIG51bVRhZ3MgPSBwLnBhcnNlVUxvbmcoKTtcblxuXHQgICAgdmFyIHRhZ3MgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGFnczsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHRhZyA9ICcnO1xuXHQgICAgICAgIHZhciBvZmZzZXQgPSBzdGFydCArIHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICB2YXIgbGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIGZvciAodmFyIGogPSBvZmZzZXQ7IGogPCBvZmZzZXQgKyBsZW5ndGg7ICsraikge1xuXHQgICAgICAgICAgICB0YWcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhLmdldEludDgoaikpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRhZ3MucHVzaCh0YWcpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGFncztcblx0fVxuXG5cdHZhciBsdGFnID0geyBtYWtlOiBtYWtlTHRhZ1RhYmxlLCBwYXJzZTogcGFyc2VMdGFnVGFibGUgfTtcblxuXHQvLyBUaGUgYG1heHBgIHRhYmxlIGVzdGFibGlzaGVzIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGZvciB0aGUgZm9udC5cblxuXHQvLyBQYXJzZSB0aGUgbWF4aW11bSBwcm9maWxlIGBtYXhwYCB0YWJsZS5cblx0ZnVuY3Rpb24gcGFyc2VNYXhwVGFibGUoZGF0YSwgc3RhcnQpIHtcblx0ICAgIHZhciBtYXhwID0ge307XG5cdCAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgbWF4cC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcblx0ICAgIG1heHAubnVtR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgaWYgKG1heHAudmVyc2lvbiA9PT0gMS4wKSB7XG5cdCAgICAgICAgbWF4cC5tYXhQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgbWF4cC5tYXhDb250b3VycyA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICBtYXhwLm1heENvbXBvc2l0ZVBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICBtYXhwLm1heENvbXBvc2l0ZUNvbnRvdXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIG1heHAubWF4Wm9uZXMgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgbWF4cC5tYXhUd2lsaWdodFBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICBtYXhwLm1heFN0b3JhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgbWF4cC5tYXhGdW5jdGlvbkRlZnMgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgbWF4cC5tYXhJbnN0cnVjdGlvbkRlZnMgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgbWF4cC5tYXhTdGFja0VsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIG1heHAubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIG1heHAubWF4Q29tcG9uZW50RWxlbWVudHMgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgbWF4cC5tYXhDb21wb25lbnREZXB0aCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG1heHA7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlTWF4cFRhYmxlKG51bUdseXBocykge1xuXHQgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnbWF4cCcsIFtcblx0ICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAwNTAwMH0sXG5cdCAgICAgICAge25hbWU6ICdudW1HbHlwaHMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG51bUdseXBoc31cblx0ICAgIF0pO1xuXHR9XG5cblx0dmFyIG1heHAgPSB7IHBhcnNlOiBwYXJzZU1heHBUYWJsZSwgbWFrZTogbWFrZU1heHBUYWJsZSB9O1xuXG5cdC8vIFRoZSBgbmFtZWAgbmFtaW5nIHRhYmxlLlxuXG5cdC8vIE5hbWVJRHMgZm9yIHRoZSBuYW1lIHRhYmxlLlxuXHR2YXIgbmFtZVRhYmxlTmFtZXMgPSBbXG5cdCAgICAnY29weXJpZ2h0JywgICAgICAgICAgICAgIC8vIDBcblx0ICAgICdmb250RmFtaWx5JywgICAgICAgICAgICAgLy8gMVxuXHQgICAgJ2ZvbnRTdWJmYW1pbHknLCAgICAgICAgICAvLyAyXG5cdCAgICAndW5pcXVlSUQnLCAgICAgICAgICAgICAgIC8vIDNcblx0ICAgICdmdWxsTmFtZScsICAgICAgICAgICAgICAgLy8gNFxuXHQgICAgJ3ZlcnNpb24nLCAgICAgICAgICAgICAgICAvLyA1XG5cdCAgICAncG9zdFNjcmlwdE5hbWUnLCAgICAgICAgIC8vIDZcblx0ICAgICd0cmFkZW1hcmsnLCAgICAgICAgICAgICAgLy8gN1xuXHQgICAgJ21hbnVmYWN0dXJlcicsICAgICAgICAgICAvLyA4XG5cdCAgICAnZGVzaWduZXInLCAgICAgICAgICAgICAgIC8vIDlcblx0ICAgICdkZXNjcmlwdGlvbicsICAgICAgICAgICAgLy8gMTBcblx0ICAgICdtYW51ZmFjdHVyZXJVUkwnLCAgICAgICAgLy8gMTFcblx0ICAgICdkZXNpZ25lclVSTCcsICAgICAgICAgICAgLy8gMTJcblx0ICAgICdsaWNlbnNlJywgICAgICAgICAgICAgICAgLy8gMTNcblx0ICAgICdsaWNlbnNlVVJMJywgICAgICAgICAgICAgLy8gMTRcblx0ICAgICdyZXNlcnZlZCcsICAgICAgICAgICAgICAgLy8gMTVcblx0ICAgICdwcmVmZXJyZWRGYW1pbHknLCAgICAgICAgLy8gMTZcblx0ICAgICdwcmVmZXJyZWRTdWJmYW1pbHknLCAgICAgLy8gMTdcblx0ICAgICdjb21wYXRpYmxlRnVsbE5hbWUnLCAgICAgLy8gMThcblx0ICAgICdzYW1wbGVUZXh0JywgICAgICAgICAgICAgLy8gMTlcblx0ICAgICdwb3N0U2NyaXB0RmluZEZvbnROYW1lJywgLy8gMjBcblx0ICAgICd3d3NGYW1pbHknLCAgICAgICAgICAgICAgLy8gMjFcblx0ICAgICd3d3NTdWJmYW1pbHknICAgICAgICAgICAgLy8gMjJcblx0XTtcblxuXHR2YXIgbWFjTGFuZ3VhZ2VzID0ge1xuXHQgICAgMDogJ2VuJyxcblx0ICAgIDE6ICdmcicsXG5cdCAgICAyOiAnZGUnLFxuXHQgICAgMzogJ2l0Jyxcblx0ICAgIDQ6ICdubCcsXG5cdCAgICA1OiAnc3YnLFxuXHQgICAgNjogJ2VzJyxcblx0ICAgIDc6ICdkYScsXG5cdCAgICA4OiAncHQnLFxuXHQgICAgOTogJ25vJyxcblx0ICAgIDEwOiAnaGUnLFxuXHQgICAgMTE6ICdqYScsXG5cdCAgICAxMjogJ2FyJyxcblx0ICAgIDEzOiAnZmknLFxuXHQgICAgMTQ6ICdlbCcsXG5cdCAgICAxNTogJ2lzJyxcblx0ICAgIDE2OiAnbXQnLFxuXHQgICAgMTc6ICd0cicsXG5cdCAgICAxODogJ2hyJyxcblx0ICAgIDE5OiAnemgtSGFudCcsXG5cdCAgICAyMDogJ3VyJyxcblx0ICAgIDIxOiAnaGknLFxuXHQgICAgMjI6ICd0aCcsXG5cdCAgICAyMzogJ2tvJyxcblx0ICAgIDI0OiAnbHQnLFxuXHQgICAgMjU6ICdwbCcsXG5cdCAgICAyNjogJ2h1Jyxcblx0ICAgIDI3OiAnZXMnLFxuXHQgICAgMjg6ICdsdicsXG5cdCAgICAyOTogJ3NlJyxcblx0ICAgIDMwOiAnZm8nLFxuXHQgICAgMzE6ICdmYScsXG5cdCAgICAzMjogJ3J1Jyxcblx0ICAgIDMzOiAnemgnLFxuXHQgICAgMzQ6ICdubC1CRScsXG5cdCAgICAzNTogJ2dhJyxcblx0ICAgIDM2OiAnc3EnLFxuXHQgICAgMzc6ICdybycsXG5cdCAgICAzODogJ2N6Jyxcblx0ICAgIDM5OiAnc2snLFxuXHQgICAgNDA6ICdzaScsXG5cdCAgICA0MTogJ3lpJyxcblx0ICAgIDQyOiAnc3InLFxuXHQgICAgNDM6ICdtaycsXG5cdCAgICA0NDogJ2JnJyxcblx0ICAgIDQ1OiAndWsnLFxuXHQgICAgNDY6ICdiZScsXG5cdCAgICA0NzogJ3V6Jyxcblx0ICAgIDQ4OiAna2snLFxuXHQgICAgNDk6ICdhei1DeXJsJyxcblx0ICAgIDUwOiAnYXotQXJhYicsXG5cdCAgICA1MTogJ2h5Jyxcblx0ICAgIDUyOiAna2EnLFxuXHQgICAgNTM6ICdtbycsXG5cdCAgICA1NDogJ2t5Jyxcblx0ICAgIDU1OiAndGcnLFxuXHQgICAgNTY6ICd0aycsXG5cdCAgICA1NzogJ21uLUNOJyxcblx0ICAgIDU4OiAnbW4nLFxuXHQgICAgNTk6ICdwcycsXG5cdCAgICA2MDogJ2tzJyxcblx0ICAgIDYxOiAna3UnLFxuXHQgICAgNjI6ICdzZCcsXG5cdCAgICA2MzogJ2JvJyxcblx0ICAgIDY0OiAnbmUnLFxuXHQgICAgNjU6ICdzYScsXG5cdCAgICA2NjogJ21yJyxcblx0ICAgIDY3OiAnYm4nLFxuXHQgICAgNjg6ICdhcycsXG5cdCAgICA2OTogJ2d1Jyxcblx0ICAgIDcwOiAncGEnLFxuXHQgICAgNzE6ICdvcicsXG5cdCAgICA3MjogJ21sJyxcblx0ICAgIDczOiAna24nLFxuXHQgICAgNzQ6ICd0YScsXG5cdCAgICA3NTogJ3RlJyxcblx0ICAgIDc2OiAnc2knLFxuXHQgICAgNzc6ICdteScsXG5cdCAgICA3ODogJ2ttJyxcblx0ICAgIDc5OiAnbG8nLFxuXHQgICAgODA6ICd2aScsXG5cdCAgICA4MTogJ2lkJyxcblx0ICAgIDgyOiAndGwnLFxuXHQgICAgODM6ICdtcycsXG5cdCAgICA4NDogJ21zLUFyYWInLFxuXHQgICAgODU6ICdhbScsXG5cdCAgICA4NjogJ3RpJyxcblx0ICAgIDg3OiAnb20nLFxuXHQgICAgODg6ICdzbycsXG5cdCAgICA4OTogJ3N3Jyxcblx0ICAgIDkwOiAncncnLFxuXHQgICAgOTE6ICdybicsXG5cdCAgICA5MjogJ255Jyxcblx0ICAgIDkzOiAnbWcnLFxuXHQgICAgOTQ6ICdlbycsXG5cdCAgICAxMjg6ICdjeScsXG5cdCAgICAxMjk6ICdldScsXG5cdCAgICAxMzA6ICdjYScsXG5cdCAgICAxMzE6ICdsYScsXG5cdCAgICAxMzI6ICdxdScsXG5cdCAgICAxMzM6ICdnbicsXG5cdCAgICAxMzQ6ICdheScsXG5cdCAgICAxMzU6ICd0dCcsXG5cdCAgICAxMzY6ICd1ZycsXG5cdCAgICAxMzc6ICdkeicsXG5cdCAgICAxMzg6ICdqdicsXG5cdCAgICAxMzk6ICdzdScsXG5cdCAgICAxNDA6ICdnbCcsXG5cdCAgICAxNDE6ICdhZicsXG5cdCAgICAxNDI6ICdicicsXG5cdCAgICAxNDM6ICdpdScsXG5cdCAgICAxNDQ6ICdnZCcsXG5cdCAgICAxNDU6ICdndicsXG5cdCAgICAxNDY6ICdnYScsXG5cdCAgICAxNDc6ICd0bycsXG5cdCAgICAxNDg6ICdlbC1wb2x5dG9uJyxcblx0ICAgIDE0OTogJ2tsJyxcblx0ICAgIDE1MDogJ2F6Jyxcblx0ICAgIDE1MTogJ25uJ1xuXHR9O1xuXG5cdC8vIE1hY09TIGxhbmd1YWdlIElEIOKGkiBNYWNPUyBzY3JpcHQgSURcblx0Ly9cblx0Ly8gTm90ZSB0aGF0IHRoZSBzY3JpcHQgSUQgaXMgbm90IHN1ZmZpY2llbnQgdG8gZGV0ZXJtaW5lIHdoYXQgZW5jb2Rpbmdcblx0Ly8gdG8gdXNlIGluIFRydWVUeXBlIGZpbGVzLiBGb3Igc29tZSBsYW5ndWFnZXMsIE1hY09TIHVzZWQgYSBtb2RpZmljYXRpb25cblx0Ly8gb2YgYSBtYWluc3RyZWFtIHNjcmlwdC4gRm9yIGV4YW1wbGUsIGFuIEljZWxhbmRpYyBuYW1lIHdvdWxkIGJlIHN0b3JlZFxuXHQvLyB3aXRoIHNtUm9tYW4gaW4gdGhlIFRydWVUeXBlIG5hbWluZyB0YWJsZSwgYnV0IHRoZSBhY3R1YWwgZW5jb2Rpbmdcblx0Ly8gaXMgYSBzcGVjaWFsIEljZWxhbmRpYyB2ZXJzaW9uIG9mIHRoZSBub3JtYWwgTWFjaW50b3NoIFJvbWFuIGVuY29kaW5nLlxuXHQvLyBBcyBhbm90aGVyIGV4YW1wbGUsIEludWt0aXR1dCB1c2VzIGFuIDgtYml0IGVuY29kaW5nIGZvciBDYW5hZGlhbiBBYm9yaWdpbmFsXG5cdC8vIFN5bGxhYmxlcyBidXQgTWFjT1MgaGFkIHJ1biBvdXQgb2YgYXZhaWxhYmxlIHNjcmlwdCBjb2Rlcywgc28gdGhpcyB3YXNcblx0Ly8gZG9uZSBhcyBhIChwcmV0dHkgcmFkaWNhbCkgXCJtb2RpZmljYXRpb25cIiBvZiBFdGhpb3BpYy5cblx0Ly9cblx0Ly8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL1JlYWRtZS50eHRcblx0dmFyIG1hY0xhbmd1YWdlVG9TY3JpcHQgPSB7XG5cdCAgICAwOiAwLCAgLy8gbGFuZ0VuZ2xpc2gg4oaSIHNtUm9tYW5cblx0ICAgIDE6IDAsICAvLyBsYW5nRnJlbmNoIOKGkiBzbVJvbWFuXG5cdCAgICAyOiAwLCAgLy8gbGFuZ0dlcm1hbiDihpIgc21Sb21hblxuXHQgICAgMzogMCwgIC8vIGxhbmdJdGFsaWFuIOKGkiBzbVJvbWFuXG5cdCAgICA0OiAwLCAgLy8gbGFuZ0R1dGNoIOKGkiBzbVJvbWFuXG5cdCAgICA1OiAwLCAgLy8gbGFuZ1N3ZWRpc2gg4oaSIHNtUm9tYW5cblx0ICAgIDY6IDAsICAvLyBsYW5nU3BhbmlzaCDihpIgc21Sb21hblxuXHQgICAgNzogMCwgIC8vIGxhbmdEYW5pc2gg4oaSIHNtUm9tYW5cblx0ICAgIDg6IDAsICAvLyBsYW5nUG9ydHVndWVzZSDihpIgc21Sb21hblxuXHQgICAgOTogMCwgIC8vIGxhbmdOb3J3ZWdpYW4g4oaSIHNtUm9tYW5cblx0ICAgIDEwOiA1LCAgLy8gbGFuZ0hlYnJldyDihpIgc21IZWJyZXdcblx0ICAgIDExOiAxLCAgLy8gbGFuZ0phcGFuZXNlIOKGkiBzbUphcGFuZXNlXG5cdCAgICAxMjogNCwgIC8vIGxhbmdBcmFiaWMg4oaSIHNtQXJhYmljXG5cdCAgICAxMzogMCwgIC8vIGxhbmdGaW5uaXNoIOKGkiBzbVJvbWFuXG5cdCAgICAxNDogNiwgIC8vIGxhbmdHcmVlayDihpIgc21HcmVla1xuXHQgICAgMTU6IDAsICAvLyBsYW5nSWNlbGFuZGljIOKGkiBzbVJvbWFuIChtb2RpZmllZClcblx0ICAgIDE2OiAwLCAgLy8gbGFuZ01hbHRlc2Ug4oaSIHNtUm9tYW5cblx0ICAgIDE3OiAwLCAgLy8gbGFuZ1R1cmtpc2gg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuXHQgICAgMTg6IDAsICAvLyBsYW5nQ3JvYXRpYW4g4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuXHQgICAgMTk6IDIsICAvLyBsYW5nVHJhZENoaW5lc2Ug4oaSIHNtVHJhZENoaW5lc2Vcblx0ICAgIDIwOiA0LCAgLy8gbGFuZ1VyZHUg4oaSIHNtQXJhYmljXG5cdCAgICAyMTogOSwgIC8vIGxhbmdIaW5kaSDihpIgc21EZXZhbmFnYXJpXG5cdCAgICAyMjogMjEsICAvLyBsYW5nVGhhaSDihpIgc21UaGFpXG5cdCAgICAyMzogMywgIC8vIGxhbmdLb3JlYW4g4oaSIHNtS29yZWFuXG5cdCAgICAyNDogMjksICAvLyBsYW5nTGl0aHVhbmlhbiDihpIgc21DZW50cmFsRXVyb1JvbWFuXG5cdCAgICAyNTogMjksICAvLyBsYW5nUG9saXNoIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cblx0ICAgIDI2OiAyOSwgIC8vIGxhbmdIdW5nYXJpYW4g4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuXHQgICAgMjc6IDI5LCAgLy8gbGFuZ0VzdG9uaWFuIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cblx0ICAgIDI4OiAyOSwgIC8vIGxhbmdMYXR2aWFuIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cblx0ICAgIDI5OiAwLCAgLy8gbGFuZ1NhbWkg4oaSIHNtUm9tYW5cblx0ICAgIDMwOiAwLCAgLy8gbGFuZ0Zhcm9lc2Ug4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuXHQgICAgMzE6IDQsICAvLyBsYW5nRmFyc2kg4oaSIHNtQXJhYmljIChtb2RpZmllZClcblx0ICAgIDMyOiA3LCAgLy8gbGFuZ1J1c3NpYW4g4oaSIHNtQ3lyaWxsaWNcblx0ICAgIDMzOiAyNSwgIC8vIGxhbmdTaW1wQ2hpbmVzZSDihpIgc21TaW1wQ2hpbmVzZVxuXHQgICAgMzQ6IDAsICAvLyBsYW5nRmxlbWlzaCDihpIgc21Sb21hblxuXHQgICAgMzU6IDAsICAvLyBsYW5nSXJpc2hHYWVsaWMg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuXHQgICAgMzY6IDAsICAvLyBsYW5nQWxiYW5pYW4g4oaSIHNtUm9tYW5cblx0ICAgIDM3OiAwLCAgLy8gbGFuZ1JvbWFuaWFuIOKGkiBzbVJvbWFuIChtb2RpZmllZClcblx0ICAgIDM4OiAyOSwgIC8vIGxhbmdDemVjaCDihpIgc21DZW50cmFsRXVyb1JvbWFuXG5cdCAgICAzOTogMjksICAvLyBsYW5nU2xvdmFrIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cblx0ICAgIDQwOiAwLCAgLy8gbGFuZ1Nsb3ZlbmlhbiDihpIgc21Sb21hbiAobW9kaWZpZWQpXG5cdCAgICA0MTogNSwgIC8vIGxhbmdZaWRkaXNoIOKGkiBzbUhlYnJld1xuXHQgICAgNDI6IDcsICAvLyBsYW5nU2VyYmlhbiDihpIgc21DeXJpbGxpY1xuXHQgICAgNDM6IDcsICAvLyBsYW5nTWFjZWRvbmlhbiDihpIgc21DeXJpbGxpY1xuXHQgICAgNDQ6IDcsICAvLyBsYW5nQnVsZ2FyaWFuIOKGkiBzbUN5cmlsbGljXG5cdCAgICA0NTogNywgIC8vIGxhbmdVa3JhaW5pYW4g4oaSIHNtQ3lyaWxsaWMgKG1vZGlmaWVkKVxuXHQgICAgNDY6IDcsICAvLyBsYW5nQnllbG9ydXNzaWFuIOKGkiBzbUN5cmlsbGljXG5cdCAgICA0NzogNywgIC8vIGxhbmdVemJlayDihpIgc21DeXJpbGxpY1xuXHQgICAgNDg6IDcsICAvLyBsYW5nS2F6YWtoIOKGkiBzbUN5cmlsbGljXG5cdCAgICA0OTogNywgIC8vIGxhbmdBemVyYmFpamFuaSDihpIgc21DeXJpbGxpY1xuXHQgICAgNTA6IDQsICAvLyBsYW5nQXplcmJhaWphbkFyIOKGkiBzbUFyYWJpY1xuXHQgICAgNTE6IDI0LCAgLy8gbGFuZ0FybWVuaWFuIOKGkiBzbUFybWVuaWFuXG5cdCAgICA1MjogMjMsICAvLyBsYW5nR2VvcmdpYW4g4oaSIHNtR2VvcmdpYW5cblx0ICAgIDUzOiA3LCAgLy8gbGFuZ01vbGRhdmlhbiDihpIgc21DeXJpbGxpY1xuXHQgICAgNTQ6IDcsICAvLyBsYW5nS2lyZ2hpeiDihpIgc21DeXJpbGxpY1xuXHQgICAgNTU6IDcsICAvLyBsYW5nVGFqaWtpIOKGkiBzbUN5cmlsbGljXG5cdCAgICA1NjogNywgIC8vIGxhbmdUdXJrbWVuIOKGkiBzbUN5cmlsbGljXG5cdCAgICA1NzogMjcsICAvLyBsYW5nTW9uZ29saWFuIOKGkiBzbU1vbmdvbGlhblxuXHQgICAgNTg6IDcsICAvLyBsYW5nTW9uZ29saWFuQ3lyIOKGkiBzbUN5cmlsbGljXG5cdCAgICA1OTogNCwgIC8vIGxhbmdQYXNodG8g4oaSIHNtQXJhYmljXG5cdCAgICA2MDogNCwgIC8vIGxhbmdLdXJkaXNoIOKGkiBzbUFyYWJpY1xuXHQgICAgNjE6IDQsICAvLyBsYW5nS2FzaG1pcmkg4oaSIHNtQXJhYmljXG5cdCAgICA2MjogNCwgIC8vIGxhbmdTaW5kaGkg4oaSIHNtQXJhYmljXG5cdCAgICA2MzogMjYsICAvLyBsYW5nVGliZXRhbiDihpIgc21UaWJldGFuXG5cdCAgICA2NDogOSwgIC8vIGxhbmdOZXBhbGkg4oaSIHNtRGV2YW5hZ2FyaVxuXHQgICAgNjU6IDksICAvLyBsYW5nU2Fuc2tyaXQg4oaSIHNtRGV2YW5hZ2FyaVxuXHQgICAgNjY6IDksICAvLyBsYW5nTWFyYXRoaSDihpIgc21EZXZhbmFnYXJpXG5cdCAgICA2NzogMTMsICAvLyBsYW5nQmVuZ2FsaSDihpIgc21CZW5nYWxpXG5cdCAgICA2ODogMTMsICAvLyBsYW5nQXNzYW1lc2Ug4oaSIHNtQmVuZ2FsaVxuXHQgICAgNjk6IDExLCAgLy8gbGFuZ0d1amFyYXRpIOKGkiBzbUd1amFyYXRpXG5cdCAgICA3MDogMTAsICAvLyBsYW5nUHVuamFiaSDihpIgc21HdXJtdWtoaVxuXHQgICAgNzE6IDEyLCAgLy8gbGFuZ09yaXlhIOKGkiBzbU9yaXlhXG5cdCAgICA3MjogMTcsICAvLyBsYW5nTWFsYXlhbGFtIOKGkiBzbU1hbGF5YWxhbVxuXHQgICAgNzM6IDE2LCAgLy8gbGFuZ0thbm5hZGEg4oaSIHNtS2FubmFkYVxuXHQgICAgNzQ6IDE0LCAgLy8gbGFuZ1RhbWlsIOKGkiBzbVRhbWlsXG5cdCAgICA3NTogMTUsICAvLyBsYW5nVGVsdWd1IOKGkiBzbVRlbHVndVxuXHQgICAgNzY6IDE4LCAgLy8gbGFuZ1NpbmhhbGVzZSDihpIgc21TaW5oYWxlc2Vcblx0ICAgIDc3OiAxOSwgIC8vIGxhbmdCdXJtZXNlIOKGkiBzbUJ1cm1lc2Vcblx0ICAgIDc4OiAyMCwgIC8vIGxhbmdLaG1lciDihpIgc21LaG1lclxuXHQgICAgNzk6IDIyLCAgLy8gbGFuZ0xhbyDihpIgc21MYW9cblx0ICAgIDgwOiAzMCwgIC8vIGxhbmdWaWV0bmFtZXNlIOKGkiBzbVZpZXRuYW1lc2Vcblx0ICAgIDgxOiAwLCAgLy8gbGFuZ0luZG9uZXNpYW4g4oaSIHNtUm9tYW5cblx0ICAgIDgyOiAwLCAgLy8gbGFuZ1RhZ2Fsb2cg4oaSIHNtUm9tYW5cblx0ICAgIDgzOiAwLCAgLy8gbGFuZ01hbGF5Um9tYW4g4oaSIHNtUm9tYW5cblx0ICAgIDg0OiA0LCAgLy8gbGFuZ01hbGF5QXJhYmljIOKGkiBzbUFyYWJpY1xuXHQgICAgODU6IDI4LCAgLy8gbGFuZ0FtaGFyaWMg4oaSIHNtRXRoaW9waWNcblx0ICAgIDg2OiAyOCwgIC8vIGxhbmdUaWdyaW55YSDihpIgc21FdGhpb3BpY1xuXHQgICAgODc6IDI4LCAgLy8gbGFuZ09yb21vIOKGkiBzbUV0aGlvcGljXG5cdCAgICA4ODogMCwgIC8vIGxhbmdTb21hbGkg4oaSIHNtUm9tYW5cblx0ICAgIDg5OiAwLCAgLy8gbGFuZ1N3YWhpbGkg4oaSIHNtUm9tYW5cblx0ICAgIDkwOiAwLCAgLy8gbGFuZ0tpbnlhcndhbmRhIOKGkiBzbVJvbWFuXG5cdCAgICA5MTogMCwgIC8vIGxhbmdSdW5kaSDihpIgc21Sb21hblxuXHQgICAgOTI6IDAsICAvLyBsYW5nTnlhbmphIOKGkiBzbVJvbWFuXG5cdCAgICA5MzogMCwgIC8vIGxhbmdNYWxhZ2FzeSDihpIgc21Sb21hblxuXHQgICAgOTQ6IDAsICAvLyBsYW5nRXNwZXJhbnRvIOKGkiBzbVJvbWFuXG5cdCAgICAxMjg6IDAsICAvLyBsYW5nV2Vsc2gg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuXHQgICAgMTI5OiAwLCAgLy8gbGFuZ0Jhc3F1ZSDihpIgc21Sb21hblxuXHQgICAgMTMwOiAwLCAgLy8gbGFuZ0NhdGFsYW4g4oaSIHNtUm9tYW5cblx0ICAgIDEzMTogMCwgIC8vIGxhbmdMYXRpbiDihpIgc21Sb21hblxuXHQgICAgMTMyOiAwLCAgLy8gbGFuZ1F1ZWNodWEg4oaSIHNtUm9tYW5cblx0ICAgIDEzMzogMCwgIC8vIGxhbmdHdWFyYW5pIOKGkiBzbVJvbWFuXG5cdCAgICAxMzQ6IDAsICAvLyBsYW5nQXltYXJhIOKGkiBzbVJvbWFuXG5cdCAgICAxMzU6IDcsICAvLyBsYW5nVGF0YXIg4oaSIHNtQ3lyaWxsaWNcblx0ICAgIDEzNjogNCwgIC8vIGxhbmdVaWdodXIg4oaSIHNtQXJhYmljXG5cdCAgICAxMzc6IDI2LCAgLy8gbGFuZ0R6b25na2hhIOKGkiBzbVRpYmV0YW5cblx0ICAgIDEzODogMCwgIC8vIGxhbmdKYXZhbmVzZVJvbSDihpIgc21Sb21hblxuXHQgICAgMTM5OiAwLCAgLy8gbGFuZ1N1bmRhbmVzZVJvbSDihpIgc21Sb21hblxuXHQgICAgMTQwOiAwLCAgLy8gbGFuZ0dhbGljaWFuIOKGkiBzbVJvbWFuXG5cdCAgICAxNDE6IDAsICAvLyBsYW5nQWZyaWthYW5zIOKGkiBzbVJvbWFuXG5cdCAgICAxNDI6IDAsICAvLyBsYW5nQnJldG9uIOKGkiBzbVJvbWFuIChtb2RpZmllZClcblx0ICAgIDE0MzogMjgsICAvLyBsYW5nSW51a3RpdHV0IOKGkiBzbUV0aGlvcGljIChtb2RpZmllZClcblx0ICAgIDE0NDogMCwgIC8vIGxhbmdTY290dGlzaEdhZWxpYyDihpIgc21Sb21hbiAobW9kaWZpZWQpXG5cdCAgICAxNDU6IDAsICAvLyBsYW5nTWFueEdhZWxpYyDihpIgc21Sb21hbiAobW9kaWZpZWQpXG5cdCAgICAxNDY6IDAsICAvLyBsYW5nSXJpc2hHYWVsaWNTY3JpcHQg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuXHQgICAgMTQ3OiAwLCAgLy8gbGFuZ1RvbmdhbiDihpIgc21Sb21hblxuXHQgICAgMTQ4OiA2LCAgLy8gbGFuZ0dyZWVrQW5jaWVudCDihpIgc21Sb21hblxuXHQgICAgMTQ5OiAwLCAgLy8gbGFuZ0dyZWVubGFuZGljIOKGkiBzbVJvbWFuXG5cdCAgICAxNTA6IDAsICAvLyBsYW5nQXplcmJhaWphblJvbWFuIOKGkiBzbVJvbWFuXG5cdCAgICAxNTE6IDAgICAvLyBsYW5nTnlub3JzayDihpIgc21Sb21hblxuXHR9O1xuXG5cdC8vIFdoaWxlIE1pY3Jvc29mdCBpbmRpY2F0ZXMgYSByZWdpb24vY291bnRyeSBmb3IgYWxsIGl0cyBsYW5ndWFnZVxuXHQvLyBJRHMsIHdlIG9taXQgdGhlIHJlZ2lvbiBjb2RlIGlmIGl0J3MgZXF1YWwgdG8gdGhlIFwibW9zdCBsaWtlbHlcblx0Ly8gcmVnaW9uIHN1YnRhZ1wiIGFjY29yZGluZyB0byBVbmljb2RlIENMRFIuIEZvciBzY3JpcHRzLCB3ZSBvbWl0XG5cdC8vIHRoZSBzdWJ0YWcgaWYgaXQgaXMgZXF1YWwgdG8gdGhlIFN1cHByZXNzLVNjcmlwdCBlbnRyeSBpbiB0aGVcblx0Ly8gSUFOQSBsYW5ndWFnZSBzdWJ0YWcgcmVnaXN0cnkgZm9yIElFVEYgQkNQIDQ3LlxuXHQvL1xuXHQvLyBGb3IgZXhhbXBsZSwgTWljcm9zb2Z0IHN0YXRlcyB0aGF0IGl0cyBsYW5ndWFnZSBjb2RlIDB4MDQxQSBpc1xuXHQvLyBDcm9hdGlhbiBpbiBDcm9hdGlhLiBXZSB0cmFuc2Zvcm0gdGhpcyB0byB0aGUgQkNQIDQ3IGxhbmd1YWdlIGNvZGUgJ2hyJ1xuXHQvLyBhbmQgbm90ICdoci1IUicgYmVjYXVzZSBDcm9hdGlhIGlzIHRoZSBkZWZhdWx0IGNvdW50cnkgZm9yIENyb2F0aWFuLFxuXHQvLyBhY2NvcmRpbmcgdG8gVW5pY29kZSBDTERSLiBBcyBhbm90aGVyIGV4YW1wbGUsIE1pY3Jvc29mdCBzdGF0ZXNcblx0Ly8gdGhhdCAweDEwMUEgaXMgQ3JvYXRpYW4gKExhdGluKSBpbiBCb3NuaWEtSGVyemVnb3ZpbmEuIFdlIHRyYW5zZm9ybVxuXHQvLyB0aGlzIHRvICdoci1CQScgYW5kIG5vdCAnaHItTGF0bi1CQScgYmVjYXVzZSBMYXRpbiBpcyB0aGUgZGVmYXVsdCBzY3JpcHRcblx0Ly8gZm9yIHRoZSBDcm9hdGlhbiBsYW5ndWFnZSwgYWNjb3JkaW5nIHRvIElBTkEuXG5cdC8vXG5cdC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvY2xkci9jaGFydHMvbGF0ZXN0L3N1cHBsZW1lbnRhbC9saWtlbHlfc3VidGFncy5odG1sXG5cdC8vIGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbGFuZ3VhZ2Utc3VidGFnLXJlZ2lzdHJ5L2xhbmd1YWdlLXN1YnRhZy1yZWdpc3RyeVxuXHR2YXIgd2luZG93c0xhbmd1YWdlcyA9IHtcblx0ICAgIDB4MDQzNjogJ2FmJyxcblx0ICAgIDB4MDQxQzogJ3NxJyxcblx0ICAgIDB4MDQ4NDogJ2dzdycsXG5cdCAgICAweDA0NUU6ICdhbScsXG5cdCAgICAweDE0MDE6ICdhci1EWicsXG5cdCAgICAweDNDMDE6ICdhci1CSCcsXG5cdCAgICAweDBDMDE6ICdhcicsXG5cdCAgICAweDA4MDE6ICdhci1JUScsXG5cdCAgICAweDJDMDE6ICdhci1KTycsXG5cdCAgICAweDM0MDE6ICdhci1LVycsXG5cdCAgICAweDMwMDE6ICdhci1MQicsXG5cdCAgICAweDEwMDE6ICdhci1MWScsXG5cdCAgICAweDE4MDE6ICdhcnknLFxuXHQgICAgMHgyMDAxOiAnYXItT00nLFxuXHQgICAgMHg0MDAxOiAnYXItUUEnLFxuXHQgICAgMHgwNDAxOiAnYXItU0EnLFxuXHQgICAgMHgyODAxOiAnYXItU1knLFxuXHQgICAgMHgxQzAxOiAnYWViJyxcblx0ICAgIDB4MzgwMTogJ2FyLUFFJyxcblx0ICAgIDB4MjQwMTogJ2FyLVlFJyxcblx0ICAgIDB4MDQyQjogJ2h5Jyxcblx0ICAgIDB4MDQ0RDogJ2FzJyxcblx0ICAgIDB4MDgyQzogJ2F6LUN5cmwnLFxuXHQgICAgMHgwNDJDOiAnYXonLFxuXHQgICAgMHgwNDZEOiAnYmEnLFxuXHQgICAgMHgwNDJEOiAnZXUnLFxuXHQgICAgMHgwNDIzOiAnYmUnLFxuXHQgICAgMHgwODQ1OiAnYm4nLFxuXHQgICAgMHgwNDQ1OiAnYm4tSU4nLFxuXHQgICAgMHgyMDFBOiAnYnMtQ3lybCcsXG5cdCAgICAweDE0MUE6ICdicycsXG5cdCAgICAweDA0N0U6ICdicicsXG5cdCAgICAweDA0MDI6ICdiZycsXG5cdCAgICAweDA0MDM6ICdjYScsXG5cdCAgICAweDBDMDQ6ICd6aC1ISycsXG5cdCAgICAweDE0MDQ6ICd6aC1NTycsXG5cdCAgICAweDA4MDQ6ICd6aCcsXG5cdCAgICAweDEwMDQ6ICd6aC1TRycsXG5cdCAgICAweDA0MDQ6ICd6aC1UVycsXG5cdCAgICAweDA0ODM6ICdjbycsXG5cdCAgICAweDA0MUE6ICdocicsXG5cdCAgICAweDEwMUE6ICdoci1CQScsXG5cdCAgICAweDA0MDU6ICdjcycsXG5cdCAgICAweDA0MDY6ICdkYScsXG5cdCAgICAweDA0OEM6ICdwcnMnLFxuXHQgICAgMHgwNDY1OiAnZHYnLFxuXHQgICAgMHgwODEzOiAnbmwtQkUnLFxuXHQgICAgMHgwNDEzOiAnbmwnLFxuXHQgICAgMHgwQzA5OiAnZW4tQVUnLFxuXHQgICAgMHgyODA5OiAnZW4tQlonLFxuXHQgICAgMHgxMDA5OiAnZW4tQ0EnLFxuXHQgICAgMHgyNDA5OiAnZW4tMDI5Jyxcblx0ICAgIDB4NDAwOTogJ2VuLUlOJyxcblx0ICAgIDB4MTgwOTogJ2VuLUlFJyxcblx0ICAgIDB4MjAwOTogJ2VuLUpNJyxcblx0ICAgIDB4NDQwOTogJ2VuLU1ZJyxcblx0ICAgIDB4MTQwOTogJ2VuLU5aJyxcblx0ICAgIDB4MzQwOTogJ2VuLVBIJyxcblx0ICAgIDB4NDgwOTogJ2VuLVNHJyxcblx0ICAgIDB4MUMwOTogJ2VuLVpBJyxcblx0ICAgIDB4MkMwOTogJ2VuLVRUJyxcblx0ICAgIDB4MDgwOTogJ2VuLUdCJyxcblx0ICAgIDB4MDQwOTogJ2VuJyxcblx0ICAgIDB4MzAwOTogJ2VuLVpXJyxcblx0ICAgIDB4MDQyNTogJ2V0Jyxcblx0ICAgIDB4MDQzODogJ2ZvJyxcblx0ICAgIDB4MDQ2NDogJ2ZpbCcsXG5cdCAgICAweDA0MEI6ICdmaScsXG5cdCAgICAweDA4MEM6ICdmci1CRScsXG5cdCAgICAweDBDMEM6ICdmci1DQScsXG5cdCAgICAweDA0MEM6ICdmcicsXG5cdCAgICAweDE0MEM6ICdmci1MVScsXG5cdCAgICAweDE4MEM6ICdmci1NQycsXG5cdCAgICAweDEwMEM6ICdmci1DSCcsXG5cdCAgICAweDA0NjI6ICdmeScsXG5cdCAgICAweDA0NTY6ICdnbCcsXG5cdCAgICAweDA0Mzc6ICdrYScsXG5cdCAgICAweDBDMDc6ICdkZS1BVCcsXG5cdCAgICAweDA0MDc6ICdkZScsXG5cdCAgICAweDE0MDc6ICdkZS1MSScsXG5cdCAgICAweDEwMDc6ICdkZS1MVScsXG5cdCAgICAweDA4MDc6ICdkZS1DSCcsXG5cdCAgICAweDA0MDg6ICdlbCcsXG5cdCAgICAweDA0NkY6ICdrbCcsXG5cdCAgICAweDA0NDc6ICdndScsXG5cdCAgICAweDA0Njg6ICdoYScsXG5cdCAgICAweDA0MEQ6ICdoZScsXG5cdCAgICAweDA0Mzk6ICdoaScsXG5cdCAgICAweDA0MEU6ICdodScsXG5cdCAgICAweDA0MEY6ICdpcycsXG5cdCAgICAweDA0NzA6ICdpZycsXG5cdCAgICAweDA0MjE6ICdpZCcsXG5cdCAgICAweDA0NUQ6ICdpdScsXG5cdCAgICAweDA4NUQ6ICdpdS1MYXRuJyxcblx0ICAgIDB4MDgzQzogJ2dhJyxcblx0ICAgIDB4MDQzNDogJ3hoJyxcblx0ICAgIDB4MDQzNTogJ3p1Jyxcblx0ICAgIDB4MDQxMDogJ2l0Jyxcblx0ICAgIDB4MDgxMDogJ2l0LUNIJyxcblx0ICAgIDB4MDQxMTogJ2phJyxcblx0ICAgIDB4MDQ0QjogJ2tuJyxcblx0ICAgIDB4MDQzRjogJ2trJyxcblx0ICAgIDB4MDQ1MzogJ2ttJyxcblx0ICAgIDB4MDQ4NjogJ3F1YycsXG5cdCAgICAweDA0ODc6ICdydycsXG5cdCAgICAweDA0NDE6ICdzdycsXG5cdCAgICAweDA0NTc6ICdrb2snLFxuXHQgICAgMHgwNDEyOiAna28nLFxuXHQgICAgMHgwNDQwOiAna3knLFxuXHQgICAgMHgwNDU0OiAnbG8nLFxuXHQgICAgMHgwNDI2OiAnbHYnLFxuXHQgICAgMHgwNDI3OiAnbHQnLFxuXHQgICAgMHgwODJFOiAnZHNiJyxcblx0ICAgIDB4MDQ2RTogJ2xiJyxcblx0ICAgIDB4MDQyRjogJ21rJyxcblx0ICAgIDB4MDgzRTogJ21zLUJOJyxcblx0ICAgIDB4MDQzRTogJ21zJyxcblx0ICAgIDB4MDQ0QzogJ21sJyxcblx0ICAgIDB4MDQzQTogJ210Jyxcblx0ICAgIDB4MDQ4MTogJ21pJyxcblx0ICAgIDB4MDQ3QTogJ2FybicsXG5cdCAgICAweDA0NEU6ICdtcicsXG5cdCAgICAweDA0N0M6ICdtb2gnLFxuXHQgICAgMHgwNDUwOiAnbW4nLFxuXHQgICAgMHgwODUwOiAnbW4tQ04nLFxuXHQgICAgMHgwNDYxOiAnbmUnLFxuXHQgICAgMHgwNDE0OiAnbmInLFxuXHQgICAgMHgwODE0OiAnbm4nLFxuXHQgICAgMHgwNDgyOiAnb2MnLFxuXHQgICAgMHgwNDQ4OiAnb3InLFxuXHQgICAgMHgwNDYzOiAncHMnLFxuXHQgICAgMHgwNDE1OiAncGwnLFxuXHQgICAgMHgwNDE2OiAncHQnLFxuXHQgICAgMHgwODE2OiAncHQtUFQnLFxuXHQgICAgMHgwNDQ2OiAncGEnLFxuXHQgICAgMHgwNDZCOiAncXUtQk8nLFxuXHQgICAgMHgwODZCOiAncXUtRUMnLFxuXHQgICAgMHgwQzZCOiAncXUnLFxuXHQgICAgMHgwNDE4OiAncm8nLFxuXHQgICAgMHgwNDE3OiAncm0nLFxuXHQgICAgMHgwNDE5OiAncnUnLFxuXHQgICAgMHgyNDNCOiAnc21uJyxcblx0ICAgIDB4MTAzQjogJ3Ntai1OTycsXG5cdCAgICAweDE0M0I6ICdzbWonLFxuXHQgICAgMHgwQzNCOiAnc2UtRkknLFxuXHQgICAgMHgwNDNCOiAnc2UnLFxuXHQgICAgMHgwODNCOiAnc2UtU0UnLFxuXHQgICAgMHgyMDNCOiAnc21zJyxcblx0ICAgIDB4MTgzQjogJ3NtYS1OTycsXG5cdCAgICAweDFDM0I6ICdzbXMnLFxuXHQgICAgMHgwNDRGOiAnc2EnLFxuXHQgICAgMHgxQzFBOiAnc3ItQ3lybC1CQScsXG5cdCAgICAweDBDMUE6ICdzcicsXG5cdCAgICAweDE4MUE6ICdzci1MYXRuLUJBJyxcblx0ICAgIDB4MDgxQTogJ3NyLUxhdG4nLFxuXHQgICAgMHgwNDZDOiAnbnNvJyxcblx0ICAgIDB4MDQzMjogJ3RuJyxcblx0ICAgIDB4MDQ1QjogJ3NpJyxcblx0ICAgIDB4MDQxQjogJ3NrJyxcblx0ICAgIDB4MDQyNDogJ3NsJyxcblx0ICAgIDB4MkMwQTogJ2VzLUFSJyxcblx0ICAgIDB4NDAwQTogJ2VzLUJPJyxcblx0ICAgIDB4MzQwQTogJ2VzLUNMJyxcblx0ICAgIDB4MjQwQTogJ2VzLUNPJyxcblx0ICAgIDB4MTQwQTogJ2VzLUNSJyxcblx0ICAgIDB4MUMwQTogJ2VzLURPJyxcblx0ICAgIDB4MzAwQTogJ2VzLUVDJyxcblx0ICAgIDB4NDQwQTogJ2VzLVNWJyxcblx0ICAgIDB4MTAwQTogJ2VzLUdUJyxcblx0ICAgIDB4NDgwQTogJ2VzLUhOJyxcblx0ICAgIDB4MDgwQTogJ2VzLU1YJyxcblx0ICAgIDB4NEMwQTogJ2VzLU5JJyxcblx0ICAgIDB4MTgwQTogJ2VzLVBBJyxcblx0ICAgIDB4M0MwQTogJ2VzLVBZJyxcblx0ICAgIDB4MjgwQTogJ2VzLVBFJyxcblx0ICAgIDB4NTAwQTogJ2VzLVBSJyxcblxuXHQgICAgLy8gTWljcm9zb2Z0IGhhcyBkZWZpbmVkIHR3byBkaWZmZXJlbnQgbGFuZ3VhZ2UgY29kZXMgZm9yXG5cdCAgICAvLyDigJxTcGFuaXNoIHdpdGggbW9kZXJuIHNvcnRpbmfigJ0gYW5kIOKAnFNwYW5pc2ggd2l0aCB0cmFkaXRpb25hbFxuXHQgICAgLy8gc29ydGluZ+KAnS4gVGhpcyBtYWtlcyBzZW5zZSBmb3IgY29sbGF0aW9uIEFQSXMsIGFuZCBpdCB3b3VsZCBiZVxuXHQgICAgLy8gcG9zc2libGUgdG8gZXhwcmVzcyB0aGlzIGluIEJDUCA0NyBsYW5ndWFnZSB0YWdzIHZpYSBVbmljb2RlXG5cdCAgICAvLyBleHRlbnNpb25zIChlZy4sIGVzLXUtY28tdHJhZCBpcyBTcGFuaXNoIHdpdGggdHJhZGl0aW9uYWxcblx0ICAgIC8vIHNvcnRpbmcpLiBIb3dldmVyLCBmb3Igc3RvcmluZyBuYW1lcyBpbiBmb250cywgdGhlIGRpc3RpbmN0aW9uXG5cdCAgICAvLyBkb2VzIG5vdCBtYWtlIHNlbnNlLCBzbyB3ZSBnaXZlIOKAnGVz4oCdIGluIGJvdGggY2FzZXMuXG5cdCAgICAweDBDMEE6ICdlcycsXG5cdCAgICAweDA0MEE6ICdlcycsXG5cblx0ICAgIDB4NTQwQTogJ2VzLVVTJyxcblx0ICAgIDB4MzgwQTogJ2VzLVVZJyxcblx0ICAgIDB4MjAwQTogJ2VzLVZFJyxcblx0ICAgIDB4MDgxRDogJ3N2LUZJJyxcblx0ICAgIDB4MDQxRDogJ3N2Jyxcblx0ICAgIDB4MDQ1QTogJ3N5cicsXG5cdCAgICAweDA0Mjg6ICd0ZycsXG5cdCAgICAweDA4NUY6ICd0em0nLFxuXHQgICAgMHgwNDQ5OiAndGEnLFxuXHQgICAgMHgwNDQ0OiAndHQnLFxuXHQgICAgMHgwNDRBOiAndGUnLFxuXHQgICAgMHgwNDFFOiAndGgnLFxuXHQgICAgMHgwNDUxOiAnYm8nLFxuXHQgICAgMHgwNDFGOiAndHInLFxuXHQgICAgMHgwNDQyOiAndGsnLFxuXHQgICAgMHgwNDgwOiAndWcnLFxuXHQgICAgMHgwNDIyOiAndWsnLFxuXHQgICAgMHgwNDJFOiAnaHNiJyxcblx0ICAgIDB4MDQyMDogJ3VyJyxcblx0ICAgIDB4MDg0MzogJ3V6LUN5cmwnLFxuXHQgICAgMHgwNDQzOiAndXonLFxuXHQgICAgMHgwNDJBOiAndmknLFxuXHQgICAgMHgwNDUyOiAnY3knLFxuXHQgICAgMHgwNDg4OiAnd28nLFxuXHQgICAgMHgwNDg1OiAnc2FoJyxcblx0ICAgIDB4MDQ3ODogJ2lpJyxcblx0ICAgIDB4MDQ2QTogJ3lvJ1xuXHR9O1xuXG5cdC8vIFJldHVybnMgYSBJRVRGIEJDUCA0NyBsYW5ndWFnZSBjb2RlLCBmb3IgZXhhbXBsZSAnemgtSGFudCdcblx0Ly8gZm9yICdDaGluZXNlIGluIHRoZSB0cmFkaXRpb25hbCBzY3JpcHQnLlxuXHRmdW5jdGlvbiBnZXRMYW5ndWFnZUNvZGUocGxhdGZvcm1JRCwgbGFuZ3VhZ2VJRCwgbHRhZykge1xuXHQgICAgc3dpdGNoIChwbGF0Zm9ybUlEKSB7XG5cdCAgICAgICAgY2FzZSAwOiAgLy8gVW5pY29kZVxuXHQgICAgICAgICAgICBpZiAobGFuZ3VhZ2VJRCA9PT0gMHhGRkZGKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJ3VuZCc7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAobHRhZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGx0YWdbbGFuZ3VhZ2VJRF07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBicmVhaztcblxuXHQgICAgICAgIGNhc2UgMTogIC8vIE1hY2ludG9zaFxuXHQgICAgICAgICAgICByZXR1cm4gbWFjTGFuZ3VhZ2VzW2xhbmd1YWdlSURdO1xuXG5cdCAgICAgICAgY2FzZSAzOiAgLy8gV2luZG93c1xuXHQgICAgICAgICAgICByZXR1cm4gd2luZG93c0xhbmd1YWdlc1tsYW5ndWFnZUlEXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdHZhciB1dGYxNiA9ICd1dGYtMTYnO1xuXG5cdC8vIE1hY09TIHNjcmlwdCBJRCDihpIgZW5jb2RpbmcuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBkZWZhdWx0IGNhc2UsXG5cdC8vIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IG1hY0xhbmd1YWdlRW5jb2RpbmdzLlxuXHR2YXIgbWFjU2NyaXB0RW5jb2RpbmdzID0ge1xuXHQgICAgMDogJ21hY2ludG9zaCcsICAgICAgICAgICAvLyBzbVJvbWFuXG5cdCAgICAxOiAneC1tYWMtamFwYW5lc2UnLCAgICAgIC8vIHNtSmFwYW5lc2Vcblx0ICAgIDI6ICd4LW1hYy1jaGluZXNldHJhZCcsICAgLy8gc21UcmFkQ2hpbmVzZVxuXHQgICAgMzogJ3gtbWFjLWtvcmVhbicsICAgICAgICAvLyBzbUtvcmVhblxuXHQgICAgNjogJ3gtbWFjLWdyZWVrJywgICAgICAgICAvLyBzbUdyZWVrXG5cdCAgICA3OiAneC1tYWMtY3lyaWxsaWMnLCAgICAgIC8vIHNtQ3lyaWxsaWNcblx0ICAgIDk6ICd4LW1hYy1kZXZhbmFnYWknLCAgICAgLy8gc21EZXZhbmFnYXJpXG5cdCAgICAxMDogJ3gtbWFjLWd1cm11a2hpJywgICAgIC8vIHNtR3VybXVraGlcblx0ICAgIDExOiAneC1tYWMtZ3VqYXJhdGknLCAgICAgLy8gc21HdWphcmF0aVxuXHQgICAgMTI6ICd4LW1hYy1vcml5YScsICAgICAgICAvLyBzbU9yaXlhXG5cdCAgICAxMzogJ3gtbWFjLWJlbmdhbGknLCAgICAgIC8vIHNtQmVuZ2FsaVxuXHQgICAgMTQ6ICd4LW1hYy10YW1pbCcsICAgICAgICAvLyBzbVRhbWlsXG5cdCAgICAxNTogJ3gtbWFjLXRlbHVndScsICAgICAgIC8vIHNtVGVsdWd1XG5cdCAgICAxNjogJ3gtbWFjLWthbm5hZGEnLCAgICAgIC8vIHNtS2FubmFkYVxuXHQgICAgMTc6ICd4LW1hYy1tYWxheWFsYW0nLCAgICAvLyBzbU1hbGF5YWxhbVxuXHQgICAgMTg6ICd4LW1hYy1zaW5oYWxlc2UnLCAgICAvLyBzbVNpbmhhbGVzZVxuXHQgICAgMTk6ICd4LW1hYy1idXJtZXNlJywgICAgICAvLyBzbUJ1cm1lc2Vcblx0ICAgIDIwOiAneC1tYWMta2htZXInLCAgICAgICAgLy8gc21LaG1lclxuXHQgICAgMjE6ICd4LW1hYy10aGFpJywgICAgICAgICAvLyBzbVRoYWlcblx0ICAgIDIyOiAneC1tYWMtbGFvJywgICAgICAgICAgLy8gc21MYW9cblx0ICAgIDIzOiAneC1tYWMtZ2VvcmdpYW4nLCAgICAgLy8gc21HZW9yZ2lhblxuXHQgICAgMjQ6ICd4LW1hYy1hcm1lbmlhbicsICAgICAvLyBzbUFybWVuaWFuXG5cdCAgICAyNTogJ3gtbWFjLWNoaW5lc2VzaW1wJywgIC8vIHNtU2ltcENoaW5lc2Vcblx0ICAgIDI2OiAneC1tYWMtdGliZXRhbicsICAgICAgLy8gc21UaWJldGFuXG5cdCAgICAyNzogJ3gtbWFjLW1vbmdvbGlhbicsICAgIC8vIHNtTW9uZ29saWFuXG5cdCAgICAyODogJ3gtbWFjLWV0aGlvcGljJywgICAgIC8vIHNtRXRoaW9waWNcblx0ICAgIDI5OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gc21DZW50cmFsRXVyb1JvbWFuXG5cdCAgICAzMDogJ3gtbWFjLXZpZXRuYW1lc2UnLCAgIC8vIHNtVmlldG5hbWVzZVxuXHQgICAgMzE6ICd4LW1hYy1leHRhcmFiaWMnICAgICAvLyBzbUV4dEFyYWJpY1xuXHR9O1xuXG5cdC8vIE1hY09TIGxhbmd1YWdlIElEIOKGkiBlbmNvZGluZy4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIGV4Y2VwdGlvbmFsXG5cdC8vIGNhc2VzLCB3aGljaCBvdmVycmlkZSBtYWNTY3JpcHRFbmNvZGluZ3MuIEZvciB3cml0aW5nIE1hY09TIG5hbWluZ1xuXHQvLyB0YWJsZXMsIHdlIG5lZWQgdG8gZW1pdCBhIE1hY09TIHNjcmlwdCBJRC4gVGhlcmVmb3JlLCB3ZSBjYW5ub3Rcblx0Ly8gbWVyZ2UgbWFjU2NyaXB0RW5jb2RpbmdzIGludG8gbWFjTGFuZ3VhZ2VFbmNvZGluZ3MuXG5cdC8vXG5cdC8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9SZWFkbWUudHh0XG5cdHZhciBtYWNMYW5ndWFnZUVuY29kaW5ncyA9IHtcblx0ICAgIDE1OiAneC1tYWMtaWNlbGFuZGljJywgICAgLy8gbGFuZ0ljZWxhbmRpY1xuXHQgICAgMTc6ICd4LW1hYy10dXJraXNoJywgICAgICAvLyBsYW5nVHVya2lzaFxuXHQgICAgMTg6ICd4LW1hYy1jcm9hdGlhbicsICAgICAvLyBsYW5nQ3JvYXRpYW5cblx0ICAgIDI0OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ0xpdGh1YW5pYW5cblx0ICAgIDI1OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ1BvbGlzaFxuXHQgICAgMjY6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nSHVuZ2FyaWFuXG5cdCAgICAyNzogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdFc3RvbmlhblxuXHQgICAgMjg6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nTGF0dmlhblxuXHQgICAgMzA6ICd4LW1hYy1pY2VsYW5kaWMnLCAgICAvLyBsYW5nRmFyb2VzZVxuXHQgICAgMzc6ICd4LW1hYy1yb21hbmlhbicsICAgICAvLyBsYW5nUm9tYW5pYW5cblx0ICAgIDM4OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ0N6ZWNoXG5cdCAgICAzOTogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdTbG92YWtcblx0ICAgIDQwOiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ1Nsb3ZlbmlhblxuXHQgICAgMTQzOiAneC1tYWMtaW51aXQnLCAgICAgICAvLyBsYW5nSW51a3RpdHV0XG5cdCAgICAxNDY6ICd4LW1hYy1nYWVsaWMnICAgICAgIC8vIGxhbmdJcmlzaEdhZWxpY1NjcmlwdFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldEVuY29kaW5nKHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIGxhbmd1YWdlSUQpIHtcblx0ICAgIHN3aXRjaCAocGxhdGZvcm1JRCkge1xuXHQgICAgICAgIGNhc2UgMDogIC8vIFVuaWNvZGVcblx0ICAgICAgICAgICAgcmV0dXJuIHV0ZjE2O1xuXG5cdCAgICAgICAgY2FzZSAxOiAgLy8gQXBwbGUgTWFjaW50b3NoXG5cdCAgICAgICAgICAgIHJldHVybiBtYWNMYW5ndWFnZUVuY29kaW5nc1tsYW5ndWFnZUlEXSB8fCBtYWNTY3JpcHRFbmNvZGluZ3NbZW5jb2RpbmdJRF07XG5cblx0ICAgICAgICBjYXNlIDM6ICAvLyBNaWNyb3NvZnQgV2luZG93c1xuXHQgICAgICAgICAgICBpZiAoZW5jb2RpbmdJRCA9PT0gMSB8fCBlbmNvZGluZ0lEID09PSAxMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHV0ZjE2O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBQYXJzZSB0aGUgbmFtaW5nIGBuYW1lYCB0YWJsZS5cblx0Ly8gRklYTUU6IEZvcm1hdCAxIGFkZGl0aW9uYWwgZmllbGRzIGFyZSBub3Qgc3VwcG9ydGVkIHlldC5cblx0Ly8gbHRhZyBpcyB0aGUgY29udGVudCBvZiB0aGUgYGx0YWcnIHRhYmxlLCBzdWNoIGFzIFsnZW4nLCAnemgtSGFucycsICdkZS1DSC0xOTA0J10uXG5cdGZ1bmN0aW9uIHBhcnNlTmFtZVRhYmxlKGRhdGEsIHN0YXJ0LCBsdGFnKSB7XG5cdCAgICB2YXIgbmFtZSA9IHt9O1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIHZhciBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICB2YXIgY291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICB2YXIgc3RyaW5nT2Zmc2V0ID0gcC5vZmZzZXQgKyBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgICB2YXIgcGxhdGZvcm1JRCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICB2YXIgZW5jb2RpbmdJRCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICB2YXIgbGFuZ3VhZ2VJRCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICB2YXIgbmFtZUlEID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIHZhciBwcm9wZXJ0eSA9IG5hbWVUYWJsZU5hbWVzW25hbWVJRF0gfHwgbmFtZUlEO1xuXHQgICAgICAgIHZhciBieXRlTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIHZhciBvZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgdmFyIGxhbmd1YWdlID0gZ2V0TGFuZ3VhZ2VDb2RlKHBsYXRmb3JtSUQsIGxhbmd1YWdlSUQsIGx0YWcpO1xuXHQgICAgICAgIHZhciBlbmNvZGluZyA9IGdldEVuY29kaW5nKHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIGxhbmd1YWdlSUQpO1xuXHQgICAgICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIGxhbmd1YWdlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgdmFyIHRleHQgPSAodm9pZCAwKTtcblx0ICAgICAgICAgICAgaWYgKGVuY29kaW5nID09PSB1dGYxNikge1xuXHQgICAgICAgICAgICAgICAgdGV4dCA9IGRlY29kZS5VVEYxNihkYXRhLCBzdHJpbmdPZmZzZXQgKyBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGV4dCA9IGRlY29kZS5NQUNTVFJJTkcoZGF0YSwgc3RyaW5nT2Zmc2V0ICsgb2Zmc2V0LCBieXRlTGVuZ3RoLCBlbmNvZGluZyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodGV4dCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9ucyA9IG5hbWVbcHJvcGVydHldO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25zID0gbmFtZVtwcm9wZXJ0eV0gPSB7fTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25zW2xhbmd1YWdlXSA9IHRleHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBsYW5nVGFnQ291bnQgPSAwO1xuXHQgICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIC8vIEZJWE1FOiBBbHNvIGhhbmRsZSBNaWNyb3NvZnQncyAnbmFtZScgdGFibGUgMS5cblx0ICAgICAgICBsYW5nVGFnQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gezIzOiAnZm9vJ30g4oaSIHsnZm9vJzogMjN9XG5cdC8vIFsnYmFyJywgJ2JheiddIOKGkiB7J2Jhcic6IDAsICdiYXonOiAxfVxuXHRmdW5jdGlvbiByZXZlcnNlRGljdChkaWN0KSB7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gZGljdCkge1xuXHQgICAgICAgIHJlc3VsdFtkaWN0W2tleV1dID0gcGFyc2VJbnQoa2V5KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VOYW1lUmVjb3JkKHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIGxhbmd1YWdlSUQsIG5hbWVJRCwgbGVuZ3RoLCBvZmZzZXQpIHtcblx0ICAgIHJldHVybiBuZXcgdGFibGUuUmVjb3JkKCdOYW1lUmVjb3JkJywgW1xuXHQgICAgICAgIHtuYW1lOiAncGxhdGZvcm1JRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogcGxhdGZvcm1JRH0sXG5cdCAgICAgICAge25hbWU6ICdlbmNvZGluZ0lEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBlbmNvZGluZ0lEfSxcblx0ICAgICAgICB7bmFtZTogJ2xhbmd1YWdlSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxhbmd1YWdlSUR9LFxuXHQgICAgICAgIHtuYW1lOiAnbmFtZUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBuYW1lSUR9LFxuXHQgICAgICAgIHtuYW1lOiAnbGVuZ3RoJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsZW5ndGh9LFxuXHQgICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBvZmZzZXR9XG5cdCAgICBdKTtcblx0fVxuXG5cdC8vIEZpbmRzIHRoZSBwb3NpdGlvbiBvZiBuZWVkbGUgaW4gaGF5c3RhY2ssIG9yIC0xIGlmIG5vdCB0aGVyZS5cblx0Ly8gTGlrZSBTdHJpbmcuaW5kZXhPZigpLCBidXQgZm9yIGFycmF5cy5cblx0ZnVuY3Rpb24gZmluZFN1YkFycmF5KG5lZWRsZSwgaGF5c3RhY2spIHtcblx0ICAgIHZhciBuZWVkbGVMZW5ndGggPSBuZWVkbGUubGVuZ3RoO1xuXHQgICAgdmFyIGxpbWl0ID0gaGF5c3RhY2subGVuZ3RoIC0gbmVlZGxlTGVuZ3RoICsgMTtcblxuXHQgICAgbG9vcDpcblx0ICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8IGxpbWl0OyBwb3MrKykge1xuXHQgICAgICAgIGZvciAoOyBwb3MgPCBsaW1pdDsgcG9zKyspIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuZWVkbGVMZW5ndGg7IGsrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGhheXN0YWNrW3BvcyArIGtdICE9PSBuZWVkbGVba10pIHtcblx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBvcztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiAtMTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFN0cmluZ1RvUG9vbChzLCBwb29sKSB7XG5cdCAgICB2YXIgb2Zmc2V0ID0gZmluZFN1YkFycmF5KHMsIHBvb2wpO1xuXHQgICAgaWYgKG9mZnNldCA8IDApIHtcblx0ICAgICAgICBvZmZzZXQgPSBwb29sLmxlbmd0aDtcblx0ICAgICAgICB2YXIgaSA9IDA7XG5cdCAgICAgICAgdmFyIGxlbiA9IHMubGVuZ3RoO1xuXHQgICAgICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcblx0ICAgICAgICAgICAgcG9vbC5wdXNoKHNbaV0pO1xuXHQgICAgICAgIH1cblxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb2Zmc2V0O1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZU5hbWVUYWJsZShuYW1lcywgbHRhZykge1xuXHQgICAgdmFyIG5hbWVJRDtcblx0ICAgIHZhciBuYW1lSURzID0gW107XG5cblx0ICAgIHZhciBuYW1lc1dpdGhOdW1lcmljS2V5cyA9IHt9O1xuXHQgICAgdmFyIG5hbWVUYWJsZUlkcyA9IHJldmVyc2VEaWN0KG5hbWVUYWJsZU5hbWVzKTtcblx0ICAgIGZvciAodmFyIGtleSBpbiBuYW1lcykge1xuXHQgICAgICAgIHZhciBpZCA9IG5hbWVUYWJsZUlkc1trZXldO1xuXHQgICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIGlkID0ga2V5O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIG5hbWVJRCA9IHBhcnNlSW50KGlkKTtcblxuXHQgICAgICAgIGlmIChpc05hTihuYW1lSUQpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmFtZSB0YWJsZSBlbnRyeSBcIicgKyBrZXkgKyAnXCIgZG9lcyBub3QgZXhpc3QsIHNlZSBuYW1lVGFibGVOYW1lcyBmb3IgY29tcGxldGUgbGlzdC4nKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBuYW1lc1dpdGhOdW1lcmljS2V5c1tuYW1lSURdID0gbmFtZXNba2V5XTtcblx0ICAgICAgICBuYW1lSURzLnB1c2gobmFtZUlEKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIG1hY0xhbmd1YWdlSWRzID0gcmV2ZXJzZURpY3QobWFjTGFuZ3VhZ2VzKTtcblx0ICAgIHZhciB3aW5kb3dzTGFuZ3VhZ2VJZHMgPSByZXZlcnNlRGljdCh3aW5kb3dzTGFuZ3VhZ2VzKTtcblxuXHQgICAgdmFyIG5hbWVSZWNvcmRzID0gW107XG5cdCAgICB2YXIgc3RyaW5nUG9vbCA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVJRHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBuYW1lSUQgPSBuYW1lSURzW2ldO1xuXHQgICAgICAgIHZhciB0cmFuc2xhdGlvbnMgPSBuYW1lc1dpdGhOdW1lcmljS2V5c1tuYW1lSURdO1xuXHQgICAgICAgIGZvciAodmFyIGxhbmcgaW4gdHJhbnNsYXRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciB0ZXh0ID0gdHJhbnNsYXRpb25zW2xhbmddO1xuXG5cdCAgICAgICAgICAgIC8vIEZvciBNYWNPUywgd2UgdHJ5IHRvIGVtaXQgdGhlIG5hbWUgaW4gdGhlIGZvcm0gdGhhdCB3YXMgaW50cm9kdWNlZFxuXHQgICAgICAgICAgICAvLyBpbiB0aGUgaW5pdGlhbCB2ZXJzaW9uIG9mIHRoZSBUcnVlVHlwZSBzcGVjIChpbiB0aGUgbGF0ZSAxOTgwcykuXG5cdCAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoaXMgY2FuIGZhaWwgZm9yIHZhcmlvdXMgcmVhc29uczogdGhlIHJlcXVlc3RlZCBCQ1AgNDdcblx0ICAgICAgICAgICAgLy8gbGFuZ3VhZ2UgY29kZSBtaWdodCBub3QgaGF2ZSBhbiBvbGQtc3R5bGUgTWFjIGVxdWl2YWxlbnQ7XG5cdCAgICAgICAgICAgIC8vIHdlIG1pZ2h0IG5vdCBoYXZlIGEgY29kZWMgZm9yIHRoZSBuZWVkZWQgY2hhcmFjdGVyIGVuY29kaW5nO1xuXHQgICAgICAgICAgICAvLyBvciB0aGUgbmFtZSBtaWdodCBjb250YWluIGNoYXJhY3RlcnMgdGhhdCBjYW5ub3QgYmUgZXhwcmVzc2VkXG5cdCAgICAgICAgICAgIC8vIGluIHRoZSBvbGQtc3R5bGUgTWFjaW50b3NoIGVuY29kaW5nLiBJbiBjYXNlIG9mIGZhaWx1cmUsIHdlIGVtaXRcblx0ICAgICAgICAgICAgLy8gdGhlIG5hbWUgaW4gYSBtb3JlIG1vZGVybiBmYXNoaW9uIChVbmljb2RlIGVuY29kaW5nIHdpdGggQkNQIDQ3XG5cdCAgICAgICAgICAgIC8vIGxhbmd1YWdlIHRhZ3MpIHRoYXQgaXMgcmVjb2duaXplZCBieSBNYWNPUyAxMC41LCByZWxlYXNlZCBpbiAyMDA5LlxuXHQgICAgICAgICAgICAvLyBJZiBmb250cyB3ZXJlIG9ubHkgcmVhZCBieSBvcGVyYXRpbmcgc3lzdGVtcywgd2UgY291bGQgc2ltcGx5XG5cdCAgICAgICAgICAgIC8vIGVtaXQgYWxsIG5hbWVzIGluIHRoZSBtb2Rlcm4gZm9ybTsgdGhpcyB3b3VsZCBiZSBtdWNoIGVhc2llci5cblx0ICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhlcmUgYXJlIG1hbnkgYXBwbGljYXRpb25zIGFuZCBsaWJyYXJpZXMgdGhhdCByZWFkXG5cdCAgICAgICAgICAgIC8vICduYW1lJyB0YWJsZXMgZGlyZWN0bHksIGFuZCB0aGVzZSB3aWxsIHVzdWFsbHkgb25seSByZWNvZ25pemVcblx0ICAgICAgICAgICAgLy8gdGhlIGFuY2llbnQgZm9ybSAoc2lsZW50bHkgc2tpcHBpbmcgdGhlIHVucmVjb2duaXplZCBuYW1lcykuXG5cdCAgICAgICAgICAgIHZhciBtYWNQbGF0Zm9ybSA9IDE7ICAvLyBNYWNpbnRvc2hcblx0ICAgICAgICAgICAgdmFyIG1hY0xhbmd1YWdlID0gbWFjTGFuZ3VhZ2VJZHNbbGFuZ107XG5cdCAgICAgICAgICAgIHZhciBtYWNTY3JpcHQgPSBtYWNMYW5ndWFnZVRvU2NyaXB0W21hY0xhbmd1YWdlXTtcblx0ICAgICAgICAgICAgdmFyIG1hY0VuY29kaW5nID0gZ2V0RW5jb2RpbmcobWFjUGxhdGZvcm0sIG1hY1NjcmlwdCwgbWFjTGFuZ3VhZ2UpO1xuXHQgICAgICAgICAgICB2YXIgbWFjTmFtZSA9IGVuY29kZS5NQUNTVFJJTkcodGV4dCwgbWFjRW5jb2RpbmcpO1xuXHQgICAgICAgICAgICBpZiAobWFjTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICBtYWNQbGF0Zm9ybSA9IDA7ICAvLyBVbmljb2RlXG5cdCAgICAgICAgICAgICAgICBtYWNMYW5ndWFnZSA9IGx0YWcuaW5kZXhPZihsYW5nKTtcblx0ICAgICAgICAgICAgICAgIGlmIChtYWNMYW5ndWFnZSA8IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBtYWNMYW5ndWFnZSA9IGx0YWcubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgIGx0YWcucHVzaChsYW5nKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgbWFjU2NyaXB0ID0gNDsgIC8vIFVuaWNvZGUgMi4wIGFuZCBsYXRlclxuXHQgICAgICAgICAgICAgICAgbWFjTmFtZSA9IGVuY29kZS5VVEYxNih0ZXh0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBtYWNOYW1lT2Zmc2V0ID0gYWRkU3RyaW5nVG9Qb29sKG1hY05hbWUsIHN0cmluZ1Bvb2wpO1xuXHQgICAgICAgICAgICBuYW1lUmVjb3Jkcy5wdXNoKG1ha2VOYW1lUmVjb3JkKG1hY1BsYXRmb3JtLCBtYWNTY3JpcHQsIG1hY0xhbmd1YWdlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVJRCwgbWFjTmFtZS5sZW5ndGgsIG1hY05hbWVPZmZzZXQpKTtcblxuXHQgICAgICAgICAgICB2YXIgd2luTGFuZ3VhZ2UgPSB3aW5kb3dzTGFuZ3VhZ2VJZHNbbGFuZ107XG5cdCAgICAgICAgICAgIGlmICh3aW5MYW5ndWFnZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luTmFtZSA9IGVuY29kZS5VVEYxNih0ZXh0KTtcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lT2Zmc2V0ID0gYWRkU3RyaW5nVG9Qb29sKHdpbk5hbWUsIHN0cmluZ1Bvb2wpO1xuXHQgICAgICAgICAgICAgICAgbmFtZVJlY29yZHMucHVzaChtYWtlTmFtZVJlY29yZCgzLCAxLCB3aW5MYW5ndWFnZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZUlELCB3aW5OYW1lLmxlbmd0aCwgd2luTmFtZU9mZnNldCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBuYW1lUmVjb3Jkcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgICAgICByZXR1cm4gKChhLnBsYXRmb3JtSUQgLSBiLnBsYXRmb3JtSUQpIHx8XG5cdCAgICAgICAgICAgICAgICAoYS5lbmNvZGluZ0lEIC0gYi5lbmNvZGluZ0lEKSB8fFxuXHQgICAgICAgICAgICAgICAgKGEubGFuZ3VhZ2VJRCAtIGIubGFuZ3VhZ2VJRCkgfHxcblx0ICAgICAgICAgICAgICAgIChhLm5hbWVJRCAtIGIubmFtZUlEKSk7XG5cdCAgICB9KTtcblxuXHQgICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ25hbWUnLCBbXG5cdCAgICAgICAge25hbWU6ICdmb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnY291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG5hbWVSZWNvcmRzLmxlbmd0aH0sXG5cdCAgICAgICAge25hbWU6ICdzdHJpbmdPZmZzZXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDYgKyBuYW1lUmVjb3Jkcy5sZW5ndGggKiAxMn1cblx0ICAgIF0pO1xuXG5cdCAgICBmb3IgKHZhciByID0gMDsgciA8IG5hbWVSZWNvcmRzLmxlbmd0aDsgcisrKSB7XG5cdCAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3JlY29yZF8nICsgciwgdHlwZTogJ1JFQ09SRCcsIHZhbHVlOiBuYW1lUmVjb3Jkc1tyXX0pO1xuXHQgICAgfVxuXG5cdCAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnc3RyaW5ncycsIHR5cGU6ICdMSVRFUkFMJywgdmFsdWU6IHN0cmluZ1Bvb2x9KTtcblx0ICAgIHJldHVybiB0O1xuXHR9XG5cblx0dmFyIF9uYW1lID0geyBwYXJzZTogcGFyc2VOYW1lVGFibGUsIG1ha2U6IG1ha2VOYW1lVGFibGUgfTtcblxuXHQvLyBUaGUgYE9TLzJgIHRhYmxlIGNvbnRhaW5zIG1ldHJpY3MgcmVxdWlyZWQgaW4gT3BlblR5cGUgZm9udHMuXG5cblx0dmFyIHVuaWNvZGVSYW5nZXMgPSBbXG5cdCAgICB7YmVnaW46IDB4MDAwMCwgZW5kOiAweDAwN0Z9LCAvLyBCYXNpYyBMYXRpblxuXHQgICAge2JlZ2luOiAweDAwODAsIGVuZDogMHgwMEZGfSwgLy8gTGF0aW4tMSBTdXBwbGVtZW50XG5cdCAgICB7YmVnaW46IDB4MDEwMCwgZW5kOiAweDAxN0Z9LCAvLyBMYXRpbiBFeHRlbmRlZC1BXG5cdCAgICB7YmVnaW46IDB4MDE4MCwgZW5kOiAweDAyNEZ9LCAvLyBMYXRpbiBFeHRlbmRlZC1CXG5cdCAgICB7YmVnaW46IDB4MDI1MCwgZW5kOiAweDAyQUZ9LCAvLyBJUEEgRXh0ZW5zaW9uc1xuXHQgICAge2JlZ2luOiAweDAyQjAsIGVuZDogMHgwMkZGfSwgLy8gU3BhY2luZyBNb2RpZmllciBMZXR0ZXJzXG5cdCAgICB7YmVnaW46IDB4MDMwMCwgZW5kOiAweDAzNkZ9LCAvLyBDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3Ncblx0ICAgIHtiZWdpbjogMHgwMzcwLCBlbmQ6IDB4MDNGRn0sIC8vIEdyZWVrIGFuZCBDb3B0aWNcblx0ICAgIHtiZWdpbjogMHgyQzgwLCBlbmQ6IDB4MkNGRn0sIC8vIENvcHRpY1xuXHQgICAge2JlZ2luOiAweDA0MDAsIGVuZDogMHgwNEZGfSwgLy8gQ3lyaWxsaWNcblx0ICAgIHtiZWdpbjogMHgwNTMwLCBlbmQ6IDB4MDU4Rn0sIC8vIEFybWVuaWFuXG5cdCAgICB7YmVnaW46IDB4MDU5MCwgZW5kOiAweDA1RkZ9LCAvLyBIZWJyZXdcblx0ICAgIHtiZWdpbjogMHhBNTAwLCBlbmQ6IDB4QTYzRn0sIC8vIFZhaVxuXHQgICAge2JlZ2luOiAweDA2MDAsIGVuZDogMHgwNkZGfSwgLy8gQXJhYmljXG5cdCAgICB7YmVnaW46IDB4MDdDMCwgZW5kOiAweDA3RkZ9LCAvLyBOS29cblx0ICAgIHtiZWdpbjogMHgwOTAwLCBlbmQ6IDB4MDk3Rn0sIC8vIERldmFuYWdhcmlcblx0ICAgIHtiZWdpbjogMHgwOTgwLCBlbmQ6IDB4MDlGRn0sIC8vIEJlbmdhbGlcblx0ICAgIHtiZWdpbjogMHgwQTAwLCBlbmQ6IDB4MEE3Rn0sIC8vIEd1cm11a2hpXG5cdCAgICB7YmVnaW46IDB4MEE4MCwgZW5kOiAweDBBRkZ9LCAvLyBHdWphcmF0aVxuXHQgICAge2JlZ2luOiAweDBCMDAsIGVuZDogMHgwQjdGfSwgLy8gT3JpeWFcblx0ICAgIHtiZWdpbjogMHgwQjgwLCBlbmQ6IDB4MEJGRn0sIC8vIFRhbWlsXG5cdCAgICB7YmVnaW46IDB4MEMwMCwgZW5kOiAweDBDN0Z9LCAvLyBUZWx1Z3Vcblx0ICAgIHtiZWdpbjogMHgwQzgwLCBlbmQ6IDB4MENGRn0sIC8vIEthbm5hZGFcblx0ICAgIHtiZWdpbjogMHgwRDAwLCBlbmQ6IDB4MEQ3Rn0sIC8vIE1hbGF5YWxhbVxuXHQgICAge2JlZ2luOiAweDBFMDAsIGVuZDogMHgwRTdGfSwgLy8gVGhhaVxuXHQgICAge2JlZ2luOiAweDBFODAsIGVuZDogMHgwRUZGfSwgLy8gTGFvXG5cdCAgICB7YmVnaW46IDB4MTBBMCwgZW5kOiAweDEwRkZ9LCAvLyBHZW9yZ2lhblxuXHQgICAge2JlZ2luOiAweDFCMDAsIGVuZDogMHgxQjdGfSwgLy8gQmFsaW5lc2Vcblx0ICAgIHtiZWdpbjogMHgxMTAwLCBlbmQ6IDB4MTFGRn0sIC8vIEhhbmd1bCBKYW1vXG5cdCAgICB7YmVnaW46IDB4MUUwMCwgZW5kOiAweDFFRkZ9LCAvLyBMYXRpbiBFeHRlbmRlZCBBZGRpdGlvbmFsXG5cdCAgICB7YmVnaW46IDB4MUYwMCwgZW5kOiAweDFGRkZ9LCAvLyBHcmVlayBFeHRlbmRlZFxuXHQgICAge2JlZ2luOiAweDIwMDAsIGVuZDogMHgyMDZGfSwgLy8gR2VuZXJhbCBQdW5jdHVhdGlvblxuXHQgICAge2JlZ2luOiAweDIwNzAsIGVuZDogMHgyMDlGfSwgLy8gU3VwZXJzY3JpcHRzIEFuZCBTdWJzY3JpcHRzXG5cdCAgICB7YmVnaW46IDB4MjBBMCwgZW5kOiAweDIwQ0Z9LCAvLyBDdXJyZW5jeSBTeW1ib2xcblx0ICAgIHtiZWdpbjogMHgyMEQwLCBlbmQ6IDB4MjBGRn0sIC8vIENvbWJpbmluZyBEaWFjcml0aWNhbCBNYXJrcyBGb3IgU3ltYm9sc1xuXHQgICAge2JlZ2luOiAweDIxMDAsIGVuZDogMHgyMTRGfSwgLy8gTGV0dGVybGlrZSBTeW1ib2xzXG5cdCAgICB7YmVnaW46IDB4MjE1MCwgZW5kOiAweDIxOEZ9LCAvLyBOdW1iZXIgRm9ybXNcblx0ICAgIHtiZWdpbjogMHgyMTkwLCBlbmQ6IDB4MjFGRn0sIC8vIEFycm93c1xuXHQgICAge2JlZ2luOiAweDIyMDAsIGVuZDogMHgyMkZGfSwgLy8gTWF0aGVtYXRpY2FsIE9wZXJhdG9yc1xuXHQgICAge2JlZ2luOiAweDIzMDAsIGVuZDogMHgyM0ZGfSwgLy8gTWlzY2VsbGFuZW91cyBUZWNobmljYWxcblx0ICAgIHtiZWdpbjogMHgyNDAwLCBlbmQ6IDB4MjQzRn0sIC8vIENvbnRyb2wgUGljdHVyZXNcblx0ICAgIHtiZWdpbjogMHgyNDQwLCBlbmQ6IDB4MjQ1Rn0sIC8vIE9wdGljYWwgQ2hhcmFjdGVyIFJlY29nbml0aW9uXG5cdCAgICB7YmVnaW46IDB4MjQ2MCwgZW5kOiAweDI0RkZ9LCAvLyBFbmNsb3NlZCBBbHBoYW51bWVyaWNzXG5cdCAgICB7YmVnaW46IDB4MjUwMCwgZW5kOiAweDI1N0Z9LCAvLyBCb3ggRHJhd2luZ1xuXHQgICAge2JlZ2luOiAweDI1ODAsIGVuZDogMHgyNTlGfSwgLy8gQmxvY2sgRWxlbWVudHNcblx0ICAgIHtiZWdpbjogMHgyNUEwLCBlbmQ6IDB4MjVGRn0sIC8vIEdlb21ldHJpYyBTaGFwZXNcblx0ICAgIHtiZWdpbjogMHgyNjAwLCBlbmQ6IDB4MjZGRn0sIC8vIE1pc2NlbGxhbmVvdXMgU3ltYm9sc1xuXHQgICAge2JlZ2luOiAweDI3MDAsIGVuZDogMHgyN0JGfSwgLy8gRGluZ2JhdHNcblx0ICAgIHtiZWdpbjogMHgzMDAwLCBlbmQ6IDB4MzAzRn0sIC8vIENKSyBTeW1ib2xzIEFuZCBQdW5jdHVhdGlvblxuXHQgICAge2JlZ2luOiAweDMwNDAsIGVuZDogMHgzMDlGfSwgLy8gSGlyYWdhbmFcblx0ICAgIHtiZWdpbjogMHgzMEEwLCBlbmQ6IDB4MzBGRn0sIC8vIEthdGFrYW5hXG5cdCAgICB7YmVnaW46IDB4MzEwMCwgZW5kOiAweDMxMkZ9LCAvLyBCb3BvbW9mb1xuXHQgICAge2JlZ2luOiAweDMxMzAsIGVuZDogMHgzMThGfSwgLy8gSGFuZ3VsIENvbXBhdGliaWxpdHkgSmFtb1xuXHQgICAge2JlZ2luOiAweEE4NDAsIGVuZDogMHhBODdGfSwgLy8gUGhhZ3MtcGFcblx0ICAgIHtiZWdpbjogMHgzMjAwLCBlbmQ6IDB4MzJGRn0sIC8vIEVuY2xvc2VkIENKSyBMZXR0ZXJzIEFuZCBNb250aHNcblx0ICAgIHtiZWdpbjogMHgzMzAwLCBlbmQ6IDB4MzNGRn0sIC8vIENKSyBDb21wYXRpYmlsaXR5XG5cdCAgICB7YmVnaW46IDB4QUMwMCwgZW5kOiAweEQ3QUZ9LCAvLyBIYW5ndWwgU3lsbGFibGVzXG5cdCAgICB7YmVnaW46IDB4RDgwMCwgZW5kOiAweERGRkZ9LCAvLyBOb24tUGxhbmUgMCAqXG5cdCAgICB7YmVnaW46IDB4MTA5MDAsIGVuZDogMHgxMDkxRn0sIC8vIFBob2VuaWNpYVxuXHQgICAge2JlZ2luOiAweDRFMDAsIGVuZDogMHg5RkZGfSwgLy8gQ0pLIFVuaWZpZWQgSWRlb2dyYXBoc1xuXHQgICAge2JlZ2luOiAweEUwMDAsIGVuZDogMHhGOEZGfSwgLy8gUHJpdmF0ZSBVc2UgQXJlYSAocGxhbmUgMClcblx0ICAgIHtiZWdpbjogMHgzMUMwLCBlbmQ6IDB4MzFFRn0sIC8vIENKSyBTdHJva2VzXG5cdCAgICB7YmVnaW46IDB4RkIwMCwgZW5kOiAweEZCNEZ9LCAvLyBBbHBoYWJldGljIFByZXNlbnRhdGlvbiBGb3Jtc1xuXHQgICAge2JlZ2luOiAweEZCNTAsIGVuZDogMHhGREZGfSwgLy8gQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1BXG5cdCAgICB7YmVnaW46IDB4RkUyMCwgZW5kOiAweEZFMkZ9LCAvLyBDb21iaW5pbmcgSGFsZiBNYXJrc1xuXHQgICAge2JlZ2luOiAweEZFMTAsIGVuZDogMHhGRTFGfSwgLy8gVmVydGljYWwgRm9ybXNcblx0ICAgIHtiZWdpbjogMHhGRTUwLCBlbmQ6IDB4RkU2Rn0sIC8vIFNtYWxsIEZvcm0gVmFyaWFudHNcblx0ICAgIHtiZWdpbjogMHhGRTcwLCBlbmQ6IDB4RkVGRn0sIC8vIEFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQlxuXHQgICAge2JlZ2luOiAweEZGMDAsIGVuZDogMHhGRkVGfSwgLy8gSGFsZndpZHRoIEFuZCBGdWxsd2lkdGggRm9ybXNcblx0ICAgIHtiZWdpbjogMHhGRkYwLCBlbmQ6IDB4RkZGRn0sIC8vIFNwZWNpYWxzXG5cdCAgICB7YmVnaW46IDB4MEYwMCwgZW5kOiAweDBGRkZ9LCAvLyBUaWJldGFuXG5cdCAgICB7YmVnaW46IDB4MDcwMCwgZW5kOiAweDA3NEZ9LCAvLyBTeXJpYWNcblx0ICAgIHtiZWdpbjogMHgwNzgwLCBlbmQ6IDB4MDdCRn0sIC8vIFRoYWFuYVxuXHQgICAge2JlZ2luOiAweDBEODAsIGVuZDogMHgwREZGfSwgLy8gU2luaGFsYVxuXHQgICAge2JlZ2luOiAweDEwMDAsIGVuZDogMHgxMDlGfSwgLy8gTXlhbm1hclxuXHQgICAge2JlZ2luOiAweDEyMDAsIGVuZDogMHgxMzdGfSwgLy8gRXRoaW9waWNcblx0ICAgIHtiZWdpbjogMHgxM0EwLCBlbmQ6IDB4MTNGRn0sIC8vIENoZXJva2VlXG5cdCAgICB7YmVnaW46IDB4MTQwMCwgZW5kOiAweDE2N0Z9LCAvLyBVbmlmaWVkIENhbmFkaWFuIEFib3JpZ2luYWwgU3lsbGFiaWNzXG5cdCAgICB7YmVnaW46IDB4MTY4MCwgZW5kOiAweDE2OUZ9LCAvLyBPZ2hhbVxuXHQgICAge2JlZ2luOiAweDE2QTAsIGVuZDogMHgxNkZGfSwgLy8gUnVuaWNcblx0ICAgIHtiZWdpbjogMHgxNzgwLCBlbmQ6IDB4MTdGRn0sIC8vIEtobWVyXG5cdCAgICB7YmVnaW46IDB4MTgwMCwgZW5kOiAweDE4QUZ9LCAvLyBNb25nb2xpYW5cblx0ICAgIHtiZWdpbjogMHgyODAwLCBlbmQ6IDB4MjhGRn0sIC8vIEJyYWlsbGUgUGF0dGVybnNcblx0ICAgIHtiZWdpbjogMHhBMDAwLCBlbmQ6IDB4QTQ4Rn0sIC8vIFlpIFN5bGxhYmxlc1xuXHQgICAge2JlZ2luOiAweDE3MDAsIGVuZDogMHgxNzFGfSwgLy8gVGFnYWxvZ1xuXHQgICAge2JlZ2luOiAweDEwMzAwLCBlbmQ6IDB4MTAzMkZ9LCAvLyBPbGQgSXRhbGljXG5cdCAgICB7YmVnaW46IDB4MTAzMzAsIGVuZDogMHgxMDM0Rn0sIC8vIEdvdGhpY1xuXHQgICAge2JlZ2luOiAweDEwNDAwLCBlbmQ6IDB4MTA0NEZ9LCAvLyBEZXNlcmV0XG5cdCAgICB7YmVnaW46IDB4MUQwMDAsIGVuZDogMHgxRDBGRn0sIC8vIEJ5emFudGluZSBNdXNpY2FsIFN5bWJvbHNcblx0ICAgIHtiZWdpbjogMHgxRDQwMCwgZW5kOiAweDFEN0ZGfSwgLy8gTWF0aGVtYXRpY2FsIEFscGhhbnVtZXJpYyBTeW1ib2xzXG5cdCAgICB7YmVnaW46IDB4RkYwMDAsIGVuZDogMHhGRkZGRH0sIC8vIFByaXZhdGUgVXNlIChwbGFuZSAxNSlcblx0ICAgIHtiZWdpbjogMHhGRTAwLCBlbmQ6IDB4RkUwRn0sIC8vIFZhcmlhdGlvbiBTZWxlY3RvcnNcblx0ICAgIHtiZWdpbjogMHhFMDAwMCwgZW5kOiAweEUwMDdGfSwgLy8gVGFnc1xuXHQgICAge2JlZ2luOiAweDE5MDAsIGVuZDogMHgxOTRGfSwgLy8gTGltYnVcblx0ICAgIHtiZWdpbjogMHgxOTUwLCBlbmQ6IDB4MTk3Rn0sIC8vIFRhaSBMZVxuXHQgICAge2JlZ2luOiAweDE5ODAsIGVuZDogMHgxOURGfSwgLy8gTmV3IFRhaSBMdWVcblx0ICAgIHtiZWdpbjogMHgxQTAwLCBlbmQ6IDB4MUExRn0sIC8vIEJ1Z2luZXNlXG5cdCAgICB7YmVnaW46IDB4MkMwMCwgZW5kOiAweDJDNUZ9LCAvLyBHbGFnb2xpdGljXG5cdCAgICB7YmVnaW46IDB4MkQzMCwgZW5kOiAweDJEN0Z9LCAvLyBUaWZpbmFnaFxuXHQgICAge2JlZ2luOiAweDREQzAsIGVuZDogMHg0REZGfSwgLy8gWWlqaW5nIEhleGFncmFtIFN5bWJvbHNcblx0ICAgIHtiZWdpbjogMHhBODAwLCBlbmQ6IDB4QTgyRn0sIC8vIFN5bG90aSBOYWdyaVxuXHQgICAge2JlZ2luOiAweDEwMDAwLCBlbmQ6IDB4MTAwN0Z9LCAvLyBMaW5lYXIgQiBTeWxsYWJhcnlcblx0ICAgIHtiZWdpbjogMHgxMDE0MCwgZW5kOiAweDEwMThGfSwgLy8gQW5jaWVudCBHcmVlayBOdW1iZXJzXG5cdCAgICB7YmVnaW46IDB4MTAzODAsIGVuZDogMHgxMDM5Rn0sIC8vIFVnYXJpdGljXG5cdCAgICB7YmVnaW46IDB4MTAzQTAsIGVuZDogMHgxMDNERn0sIC8vIE9sZCBQZXJzaWFuXG5cdCAgICB7YmVnaW46IDB4MTA0NTAsIGVuZDogMHgxMDQ3Rn0sIC8vIFNoYXZpYW5cblx0ICAgIHtiZWdpbjogMHgxMDQ4MCwgZW5kOiAweDEwNEFGfSwgLy8gT3NtYW55YVxuXHQgICAge2JlZ2luOiAweDEwODAwLCBlbmQ6IDB4MTA4M0Z9LCAvLyBDeXByaW90IFN5bGxhYmFyeVxuXHQgICAge2JlZ2luOiAweDEwQTAwLCBlbmQ6IDB4MTBBNUZ9LCAvLyBLaGFyb3NodGhpXG5cdCAgICB7YmVnaW46IDB4MUQzMDAsIGVuZDogMHgxRDM1Rn0sIC8vIFRhaSBYdWFuIEppbmcgU3ltYm9sc1xuXHQgICAge2JlZ2luOiAweDEyMDAwLCBlbmQ6IDB4MTIzRkZ9LCAvLyBDdW5laWZvcm1cblx0ICAgIHtiZWdpbjogMHgxRDM2MCwgZW5kOiAweDFEMzdGfSwgLy8gQ291bnRpbmcgUm9kIE51bWVyYWxzXG5cdCAgICB7YmVnaW46IDB4MUI4MCwgZW5kOiAweDFCQkZ9LCAvLyBTdW5kYW5lc2Vcblx0ICAgIHtiZWdpbjogMHgxQzAwLCBlbmQ6IDB4MUM0Rn0sIC8vIExlcGNoYVxuXHQgICAge2JlZ2luOiAweDFDNTAsIGVuZDogMHgxQzdGfSwgLy8gT2wgQ2hpa2lcblx0ICAgIHtiZWdpbjogMHhBODgwLCBlbmQ6IDB4QThERn0sIC8vIFNhdXJhc2h0cmFcblx0ICAgIHtiZWdpbjogMHhBOTAwLCBlbmQ6IDB4QTkyRn0sIC8vIEtheWFoIExpXG5cdCAgICB7YmVnaW46IDB4QTkzMCwgZW5kOiAweEE5NUZ9LCAvLyBSZWphbmdcblx0ICAgIHtiZWdpbjogMHhBQTAwLCBlbmQ6IDB4QUE1Rn0sIC8vIENoYW1cblx0ICAgIHtiZWdpbjogMHgxMDE5MCwgZW5kOiAweDEwMUNGfSwgLy8gQW5jaWVudCBTeW1ib2xzXG5cdCAgICB7YmVnaW46IDB4MTAxRDAsIGVuZDogMHgxMDFGRn0sIC8vIFBoYWlzdG9zIERpc2Ncblx0ICAgIHtiZWdpbjogMHgxMDJBMCwgZW5kOiAweDEwMkRGfSwgLy8gQ2FyaWFuXG5cdCAgICB7YmVnaW46IDB4MUYwMzAsIGVuZDogMHgxRjA5Rn0gIC8vIERvbWlubyBUaWxlc1xuXHRdO1xuXG5cdGZ1bmN0aW9uIGdldFVuaWNvZGVSYW5nZSh1bmljb2RlKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaWNvZGVSYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgcmFuZ2UgPSB1bmljb2RlUmFuZ2VzW2ldO1xuXHQgICAgICAgIGlmICh1bmljb2RlID49IHJhbmdlLmJlZ2luICYmIHVuaWNvZGUgPCByYW5nZS5lbmQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gLTE7XG5cdH1cblxuXHQvLyBQYXJzZSB0aGUgT1MvMiBhbmQgV2luZG93cyBtZXRyaWNzIGBPUy8yYCB0YWJsZVxuXHRmdW5jdGlvbiBwYXJzZU9TMlRhYmxlKGRhdGEsIHN0YXJ0KSB7XG5cdCAgICB2YXIgb3MyID0ge307XG5cdCAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgb3MyLnZlcnNpb24gPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICBvczIueEF2Z0NoYXJXaWR0aCA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgb3MyLnVzV2VpZ2h0Q2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICBvczIudXNXaWR0aENsYXNzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgb3MyLmZzVHlwZSA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIG9zMi55U3Vic2NyaXB0WFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIG9zMi55U3Vic2NyaXB0WVNpemUgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIG9zMi55U3Vic2NyaXB0WE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgb3MyLnlTdWJzY3JpcHRZT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBvczIueVN1cGVyc2NyaXB0WFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIG9zMi55U3VwZXJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgb3MyLnlTdXBlcnNjcmlwdFhPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIG9zMi55U3VwZXJzY3JpcHRZT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBvczIueVN0cmlrZW91dFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIG9zMi55U3RyaWtlb3V0UG9zaXRpb24gPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIG9zMi5zRmFtaWx5Q2xhc3MgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIG9zMi5wYW5vc2UgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHQgICAgICAgIG9zMi5wYW5vc2VbaV0gPSBwLnBhcnNlQnl0ZSgpO1xuXHQgICAgfVxuXG5cdCAgICBvczIudWxVbmljb2RlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICBvczIudWxVbmljb2RlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICBvczIudWxVbmljb2RlUmFuZ2UzID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICBvczIudWxVbmljb2RlUmFuZ2U0ID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICBvczIuYWNoVmVuZElEID0gU3RyaW5nLmZyb21DaGFyQ29kZShwLnBhcnNlQnl0ZSgpLCBwLnBhcnNlQnl0ZSgpLCBwLnBhcnNlQnl0ZSgpLCBwLnBhcnNlQnl0ZSgpKTtcblx0ICAgIG9zMi5mc1NlbGVjdGlvbiA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIG9zMi51c0ZpcnN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgb3MyLnVzTGFzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIG9zMi5zVHlwb0FzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBvczIuc1R5cG9EZXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIG9zMi5zVHlwb0xpbmVHYXAgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIG9zMi51c1dpbkFzY2VudCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIG9zMi51c1dpbkRlc2NlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICBpZiAob3MyLnZlcnNpb24gPj0gMSkge1xuXHQgICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICAgICAgb3MyLnVsQ29kZVBhZ2VSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG9zMi52ZXJzaW9uID49IDIpIHtcblx0ICAgICAgICBvczIuc3hIZWlnaHQgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgICAgICBvczIuc0NhcEhlaWdodCA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgICAgIG9zMi51c0RlZmF1bHRDaGFyID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIG9zMi51c0JyZWFrQ2hhciA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICBvczIudXNNYXhDb250ZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb3MyO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZU9TMlRhYmxlKG9wdGlvbnMpIHtcblx0ICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ09TLzInLCBbXG5cdCAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAweDAwMDN9LFxuXHQgICAgICAgIHtuYW1lOiAneEF2Z0NoYXJXaWR0aCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VzV2VpZ2h0Q2xhc3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndXNXaWR0aENsYXNzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2ZzVHlwZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNjUwfSxcblx0ICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRZU2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA2OTl9LFxuXHQgICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFhPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WU9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAxNDB9LFxuXHQgICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNjUwfSxcblx0ICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY5OX0sXG5cdCAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRYT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WU9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA0Nzl9LFxuXHQgICAgICAgIHtuYW1lOiAneVN0cmlrZW91dFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNDl9LFxuXHQgICAgICAgIHtuYW1lOiAneVN0cmlrZW91dFBvc2l0aW9uJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDI1OH0sXG5cdCAgICAgICAge25hbWU6ICdzRmFtaWx5Q2xhc3MnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdiRmFtaWx5VHlwZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnYlNlcmlmU3R5bGUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2JXZWlnaHQnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2JQcm9wb3J0aW9uJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdiQ29udHJhc3QnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2JTdHJva2VWYXJpYXRpb24nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2JBcm1TdHlsZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnYkxldHRlcmZvcm0nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2JNaWRsaW5lJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdiWEhlaWdodCcsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2U0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnYWNoVmVuZElEJywgdHlwZTogJ0NIQVJBUlJBWScsIHZhbHVlOiAnWFhYWCd9LFxuXHQgICAgICAgIHtuYW1lOiAnZnNTZWxlY3Rpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndXNGaXJzdENoYXJJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd1c0xhc3RDaGFySW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnc1R5cG9Bc2NlbmRlcicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3NUeXBvRGVzY2VuZGVyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnc1R5cG9MaW5lR2FwJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndXNXaW5Bc2NlbnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndXNXaW5EZXNjZW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VsQ29kZVBhZ2VSYW5nZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd1bENvZGVQYWdlUmFuZ2UyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnc3hIZWlnaHQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdzQ2FwSGVpZ2h0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndXNEZWZhdWx0Q2hhcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd1c0JyZWFrQ2hhcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICd1c01heENvbnRleHQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG5cdCAgICBdLCBvcHRpb25zKTtcblx0fVxuXG5cdHZhciBvczIgPSB7IHBhcnNlOiBwYXJzZU9TMlRhYmxlLCBtYWtlOiBtYWtlT1MyVGFibGUsIHVuaWNvZGVSYW5nZXM6IHVuaWNvZGVSYW5nZXMsIGdldFVuaWNvZGVSYW5nZTogZ2V0VW5pY29kZVJhbmdlIH07XG5cblx0Ly8gVGhlIGBwb3N0YCB0YWJsZSBzdG9yZXMgYWRkaXRpb25hbCBQb3N0U2NyaXB0IGluZm9ybWF0aW9uLCBzdWNoIGFzIGdseXBoIG5hbWVzLlxuXG5cdC8vIFBhcnNlIHRoZSBQb3N0U2NyaXB0IGBwb3N0YCB0YWJsZVxuXHRmdW5jdGlvbiBwYXJzZVBvc3RUYWJsZShkYXRhLCBzdGFydCkge1xuXHQgICAgdmFyIHBvc3QgPSB7fTtcblx0ICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cdCAgICBwb3N0LnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuXHQgICAgcG9zdC5pdGFsaWNBbmdsZSA9IHAucGFyc2VGaXhlZCgpO1xuXHQgICAgcG9zdC51bmRlcmxpbmVQb3NpdGlvbiA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgcG9zdC51bmRlcmxpbmVUaGlja25lc3MgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIHBvc3QuaXNGaXhlZFBpdGNoID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICBwb3N0Lm1pbk1lbVR5cGU0MiA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgcG9zdC5tYXhNZW1UeXBlNDIgPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgIHBvc3QubWluTWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgIHBvc3QubWF4TWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgIHN3aXRjaCAocG9zdC52ZXJzaW9uKSB7XG5cdCAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICBwb3N0Lm5hbWVzID0gc3RhbmRhcmROYW1lcy5zbGljZSgpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgIHBvc3QubnVtYmVyT2ZHbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgICAgIHBvc3QuZ2x5cGhOYW1lSW5kZXggPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBwb3N0LmdseXBoTmFtZUluZGV4W2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcG9zdC5uYW1lcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpJDErKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHBvc3QuZ2x5cGhOYW1lSW5kZXhbaSQxXSA+PSBzdGFuZGFyZE5hbWVzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lTGVuZ3RoID0gcC5wYXJzZUNoYXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICBwb3N0Lm5hbWVzLnB1c2gocC5wYXJzZVN0cmluZyhuYW1lTGVuZ3RoKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIDIuNTpcblx0ICAgICAgICAgICAgcG9zdC5udW1iZXJPZkdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICAgICAgcG9zdC5vZmZzZXQgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkkMisrKSB7XG5cdCAgICAgICAgICAgICAgICBwb3N0Lm9mZnNldFtpJDJdID0gcC5wYXJzZUNoYXIoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHBvc3Q7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlUG9zdFRhYmxlKCkge1xuXHQgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgncG9zdCcsIFtcblx0ICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAzMDAwMH0sXG5cdCAgICAgICAge25hbWU6ICdpdGFsaWNBbmdsZScsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAndW5kZXJsaW5lVGhpY2tuZXNzJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnaXNGaXhlZFBpdGNoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbWluTWVtVHlwZTQyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbWF4TWVtVHlwZTQyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnbWluTWVtVHlwZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdtYXhNZW1UeXBlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfVxuXHQgICAgXSk7XG5cdH1cblxuXHR2YXIgcG9zdCA9IHsgcGFyc2U6IHBhcnNlUG9zdFRhYmxlLCBtYWtlOiBtYWtlUG9zdFRhYmxlIH07XG5cblx0Ly8gVGhlIGBHU1VCYCB0YWJsZSBjb250YWlucyBsaWdhdHVyZXMsIGFtb25nIG90aGVyIHRoaW5ncy5cblxuXHR2YXIgc3VidGFibGVQYXJzZXJzID0gbmV3IEFycmF5KDkpOyAgICAgICAgIC8vIHN1YnRhYmxlUGFyc2Vyc1swXSBpcyB1bnVzZWRcblxuXHQvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI1NTXG5cdHN1YnRhYmxlUGFyc2Vyc1sxXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMSgpIHtcblx0ICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcblx0ICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuXHQgICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcblx0ICAgICAgICAgICAgZGVsdGFHbHlwaElkOiB0aGlzLnBhcnNlVVNob3J0KClcblx0ICAgICAgICB9O1xuXHQgICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAyLFxuXHQgICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcblx0ICAgICAgICAgICAgc3Vic3RpdHV0ZTogdGhpcy5wYXJzZU9mZnNldDE2TGlzdCgpXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IGxvb2t1cCB0eXBlIDEgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xuXHR9O1xuXG5cdC8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jTVNcblx0c3VidGFibGVQYXJzZXJzWzJdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAyKCkge1xuXHQgICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIE11bHRpcGxlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuXHQgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuXHQgICAgICAgIHNlcXVlbmNlczogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKClcblx0ICAgIH07XG5cdH07XG5cblx0Ly8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNBU1xuXHRzdWJ0YWJsZVBhcnNlcnNbM10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDMoKSB7XG5cdCAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgQWx0ZXJuYXRlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuXHQgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuXHQgICAgICAgIGFsdGVybmF0ZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cygpXG5cdCAgICB9O1xuXHR9O1xuXG5cdC8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jTFNcblx0c3VidGFibGVQYXJzZXJzWzRdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA0KCkge1xuXHQgICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIGxpZ2F0dXJlIHRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG5cdCAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG5cdCAgICAgICAgbGlnYXR1cmVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBsaWdHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuXHQgICAgICAgICAgICAgICAgY29tcG9uZW50czogdGhpcy5wYXJzZVVTaG9ydExpc3QodGhpcy5wYXJzZVVTaG9ydCgpIC0gMSlcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KVxuXHQgICAgfTtcblx0fTtcblxuXHR2YXIgbG9va3VwUmVjb3JkRGVzYyA9IHtcblx0ICAgIHNlcXVlbmNlSW5kZXg6IFBhcnNlci51U2hvcnQsXG5cdCAgICBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnRcblx0fTtcblxuXHQvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0NTRlxuXHRzdWJ0YWJsZVBhcnNlcnNbNV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDUoKSB7XG5cdCAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG5cdCAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cblx0ICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcblx0ICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG5cdCAgICAgICAgICAgIHJ1bGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZ2x5cGhDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCAtIDEpLFxuXHQgICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHN1YnN0Q291bnQsIGxvb2t1cFJlY29yZERlc2MpXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KVxuXHQgICAgICAgIH07XG5cdCAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAyKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuXHQgICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcblx0ICAgICAgICAgICAgY2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG5cdCAgICAgICAgICAgIGNsYXNzU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGdseXBoQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3Vic3RDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2xhc3NlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCAtIDEpLFxuXHQgICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHN1YnN0Q291bnQsIGxvb2t1cFJlY29yZERlc2MpXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KVxuXHQgICAgICAgIH07XG5cdCAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAzKSB7XG5cdCAgICAgICAgdmFyIGdseXBoQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgdmFyIHN1YnN0Q291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuXHQgICAgICAgICAgICBjb3ZlcmFnZXM6IHRoaXMucGFyc2VMaXN0KGdseXBoQ291bnQsIFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuXHQgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChzdWJzdENvdW50LCBsb29rdXBSZWNvcmREZXNjKVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBjaGVjay5hc3NlcnQoZmFsc2UsICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBsb29rdXAgdHlwZSA1IGZvcm1hdCBtdXN0IGJlIDEsIDIgb3IgMy4nKTtcblx0fTtcblxuXHQvLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0NDXG5cdHN1YnRhYmxlUGFyc2Vyc1s2XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNigpIHtcblx0ICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcblx0ICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuXHQgICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcblx0ICAgICAgICAgICAgY2hhaW5SdWxlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYWNrdHJhY2s6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG5cdCAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VTaG9ydCgpIC0gMSksXG5cdCAgICAgICAgICAgICAgICAgICAgbG9va2FoZWFkOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuXHQgICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGxvb2t1cFJlY29yZERlc2MpXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KVxuXHQgICAgICAgIH07XG5cdCAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAyKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG5cdCAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuXHQgICAgICAgICAgICBiYWNrdHJhY2tDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcblx0ICAgICAgICAgICAgaW5wdXRDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcblx0ICAgICAgICAgICAgbG9va2FoZWFkQ2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG5cdCAgICAgICAgICAgIGNoYWluQ2xhc3NTZXQ6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFja3RyYWNrOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuXHQgICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlU2hvcnQoKSAtIDEpLFxuXHQgICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZDogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcblx0ICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChsb29rdXBSZWNvcmREZXNjKVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSlcblx0ICAgICAgICB9O1xuXHQgICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMykge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAzLFxuXHQgICAgICAgICAgICBiYWNrdHJhY2tDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG5cdCAgICAgICAgICAgIGlucHV0Q292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuXHQgICAgICAgICAgICBsb29rYWhlYWRDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG5cdCAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGxvb2t1cFJlY29yZERlc2MpXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IGxvb2t1cCB0eXBlIDYgZm9ybWF0IG11c3QgYmUgMSwgMiBvciAzLicpO1xuXHR9O1xuXG5cdC8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jRVNcblx0c3VidGFibGVQYXJzZXJzWzddID0gZnVuY3Rpb24gcGFyc2VMb29rdXA3KCkge1xuXHQgICAgLy8gRXh0ZW5zaW9uIFN1YnN0aXR1dGlvbiBzdWJ0YWJsZVxuXHQgICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIEV4dGVuc2lvbiBTdWJzdGl0dXRpb24gc3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJyk7XG5cdCAgICB2YXIgZXh0ZW5zaW9uTG9va3VwVHlwZSA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIHZhciBleHRlbnNpb25QYXJzZXIgPSBuZXcgUGFyc2VyKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnBhcnNlVUxvbmcoKSk7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuXHQgICAgICAgIGxvb2t1cFR5cGU6IGV4dGVuc2lvbkxvb2t1cFR5cGUsXG5cdCAgICAgICAgZXh0ZW5zaW9uOiBzdWJ0YWJsZVBhcnNlcnNbZXh0ZW5zaW9uTG9va3VwVHlwZV0uY2FsbChleHRlbnNpb25QYXJzZXIpXG5cdCAgICB9O1xuXHR9O1xuXG5cdC8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jUkNDU1xuXHRzdWJ0YWJsZVBhcnNlcnNbOF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDgoKSB7XG5cdCAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgUmV2ZXJzZSBDaGFpbmluZyBDb250ZXh0dWFsIFNpbmdsZSBTdWJzdGl0dXRpb24gU3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJyk7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcblx0ICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcblx0ICAgICAgICBiYWNrdHJhY2tDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG5cdCAgICAgICAgbG9va2FoZWFkQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuXHQgICAgICAgIHN1YnN0aXR1dGVzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpXG5cdCAgICB9O1xuXHR9O1xuXG5cdC8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3N1Yi5odG1cblx0ZnVuY3Rpb24gcGFyc2VHc3ViVGFibGUoZGF0YSwgc3RhcnQpIHtcblx0ICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcblx0ICAgIHZhciBwID0gbmV3IFBhcnNlcihkYXRhLCBzdGFydCk7XG5cdCAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oMSk7XG5cdCAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEgfHwgdGFibGVWZXJzaW9uID09PSAxLjEsICdVbnN1cHBvcnRlZCBHU1VCIHRhYmxlIHZlcnNpb24uJyk7XG5cdCAgICBpZiAodGFibGVWZXJzaW9uID09PSAxKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuXHQgICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuXHQgICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG5cdCAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2Vycylcblx0ICAgICAgICB9O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG5cdCAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG5cdCAgICAgICAgICAgIGZlYXR1cmVzOiBwLnBhcnNlRmVhdHVyZUxpc3QoKSxcblx0ICAgICAgICAgICAgbG9va3VwczogcC5wYXJzZUxvb2t1cExpc3Qoc3VidGFibGVQYXJzZXJzKSxcblx0ICAgICAgICAgICAgdmFyaWF0aW9uczogcC5wYXJzZUZlYXR1cmVWYXJpYXRpb25zTGlzdCgpXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblxuXHR9XG5cblx0Ly8gR1NVQiBXcml0aW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0dmFyIHN1YnRhYmxlTWFrZXJzID0gbmV3IEFycmF5KDkpO1xuXG5cdHN1YnRhYmxlTWFrZXJzWzFdID0gZnVuY3Rpb24gbWFrZUxvb2t1cDEoc3VidGFibGUpIHtcblx0ICAgIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3N1YnN0aXR1dGlvblRhYmxlJywgW1xuXHQgICAgICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfSxcblx0ICAgICAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfSxcblx0ICAgICAgICAgICAge25hbWU6ICdkZWx0YUdseXBoSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHN1YnRhYmxlLmRlbHRhR2x5cGhJZH1cblx0ICAgICAgICBdKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG5cdCAgICAgICAgICAgIHtuYW1lOiAnc3Vic3RGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDJ9LFxuXHQgICAgICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9XG5cdCAgICAgICAgXS5jb25jYXQodGFibGUudXNob3J0TGlzdCgnc3Vic3RpdHV0ZScsIHN1YnRhYmxlLnN1YnN0aXR1dGUpKSk7XG5cdCAgICB9XG5cdCAgICBjaGVjay5mYWlsKCdMb29rdXAgdHlwZSAxIHN1YnN0Rm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xuXHR9O1xuXG5cdHN1YnRhYmxlTWFrZXJzWzNdID0gZnVuY3Rpb24gbWFrZUxvb2t1cDMoc3VidGFibGUpIHtcblx0ICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSwgJ0xvb2t1cCB0eXBlIDMgc3Vic3RGb3JtYXQgbXVzdCBiZSAxLicpO1xuXHQgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG5cdCAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG5cdCAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfVxuXHQgICAgXS5jb25jYXQodGFibGUudGFibGVMaXN0KCdhbHRTZXQnLCBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzLCBmdW5jdGlvbihhbHRlcm5hdGVTZXQpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdhbHRlcm5hdGVTZXRUYWJsZScsIHRhYmxlLnVzaG9ydExpc3QoJ2FsdGVybmF0ZScsIGFsdGVybmF0ZVNldCkpO1xuXHQgICAgfSkpKTtcblx0fTtcblxuXHRzdWJ0YWJsZU1ha2Vyc1s0XSA9IGZ1bmN0aW9uIG1ha2VMb29rdXA0KHN1YnRhYmxlKSB7XG5cdCAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEsICdMb29rdXAgdHlwZSA0IHN1YnN0Rm9ybWF0IG11c3QgYmUgMS4nKTtcblx0ICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3N1YnN0aXR1dGlvblRhYmxlJywgW1xuXHQgICAgICAgIHtuYW1lOiAnc3Vic3RGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuXHQgICAgICAgIHtuYW1lOiAnY292ZXJhZ2UnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKX1cblx0ICAgIF0uY29uY2F0KHRhYmxlLnRhYmxlTGlzdCgnbGlnU2V0Jywgc3VidGFibGUubGlnYXR1cmVTZXRzLCBmdW5jdGlvbihsaWdhdHVyZVNldCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2xpZ2F0dXJlU2V0VGFibGUnLCB0YWJsZS50YWJsZUxpc3QoJ2xpZ2F0dXJlJywgbGlnYXR1cmVTZXQsIGZ1bmN0aW9uKGxpZ2F0dXJlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2xpZ2F0dXJlVGFibGUnLFxuXHQgICAgICAgICAgICAgICAgW3tuYW1lOiAnbGlnR2x5cGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxpZ2F0dXJlLmxpZ0dseXBofV1cblx0ICAgICAgICAgICAgICAgIC5jb25jYXQodGFibGUudXNob3J0TGlzdCgnY29tcG9uZW50JywgbGlnYXR1cmUuY29tcG9uZW50cywgbGlnYXR1cmUuY29tcG9uZW50cy5sZW5ndGggKyAxKSlcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICB9KSk7XG5cdCAgICB9KSkpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIG1ha2VHc3ViVGFibGUoZ3N1Yikge1xuXHQgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnR1NVQicsIFtcblx0ICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMHgxMDAwMH0sXG5cdCAgICAgICAge25hbWU6ICdzY3JpcHRzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5TY3JpcHRMaXN0KGdzdWIuc2NyaXB0cyl9LFxuXHQgICAgICAgIHtuYW1lOiAnZmVhdHVyZXMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkZlYXR1cmVMaXN0KGdzdWIuZmVhdHVyZXMpfSxcblx0ICAgICAgICB7bmFtZTogJ2xvb2t1cHMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkxvb2t1cExpc3QoZ3N1Yi5sb29rdXBzLCBzdWJ0YWJsZU1ha2Vycyl9XG5cdCAgICBdKTtcblx0fVxuXG5cdHZhciBnc3ViID0geyBwYXJzZTogcGFyc2VHc3ViVGFibGUsIG1ha2U6IG1ha2VHc3ViVGFibGUgfTtcblxuXHQvLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cblxuXHQvLyBQYXJzZSB0aGUgbWV0YWRhdGEgYG1ldGFgIHRhYmxlLlxuXHQvLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA2L0NoYXA2bWV0YS5odG1sXG5cdGZ1bmN0aW9uIHBhcnNlTWV0YVRhYmxlKGRhdGEsIHN0YXJ0KSB7XG5cdCAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuXHQgICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxLCAnVW5zdXBwb3J0ZWQgTUVUQSB0YWJsZSB2ZXJzaW9uLicpO1xuXHQgICAgcC5wYXJzZVVMb25nKCk7IC8vIGZsYWdzIC0gY3VycmVudGx5IHVudXNlZCBhbmQgc2V0IHRvIDBcblx0ICAgIHAucGFyc2VVTG9uZygpOyAvLyB0YWJsZU9mZnNldFxuXHQgICAgdmFyIG51bURhdGFNYXBzID0gcC5wYXJzZVVMb25nKCk7XG5cblx0ICAgIHZhciB0YWdzID0ge307XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGFNYXBzOyBpKyspIHtcblx0ICAgICAgICB2YXIgdGFnID0gcC5wYXJzZVRhZygpO1xuXHQgICAgICAgIHZhciBkYXRhT2Zmc2V0ID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICAgICAgdmFyIGRhdGFMZW5ndGggPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgICAgICB2YXIgdGV4dCA9IGRlY29kZS5VVEY4KGRhdGEsIHN0YXJ0ICsgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCk7XG5cblx0ICAgICAgICB0YWdzW3RhZ10gPSB0ZXh0O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRhZ3M7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlTWV0YVRhYmxlKHRhZ3MpIHtcblx0ICAgIHZhciBudW1UYWdzID0gT2JqZWN0LmtleXModGFncykubGVuZ3RoO1xuXHQgICAgdmFyIHN0cmluZ1Bvb2wgPSAnJztcblx0ICAgIHZhciBzdHJpbmdQb29sT2Zmc2V0ID0gMTYgKyBudW1UYWdzICogMTI7XG5cblx0ICAgIHZhciByZXN1bHQgPSBuZXcgdGFibGUuVGFibGUoJ21ldGEnLCBbXG5cdCAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDF9LFxuXHQgICAgICAgIHtuYW1lOiAnZmxhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdvZmZzZXQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogc3RyaW5nUG9vbE9mZnNldH0sXG5cdCAgICAgICAge25hbWU6ICdudW1UYWdzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IG51bVRhZ3N9XG5cdCAgICBdKTtcblxuXHQgICAgZm9yICh2YXIgdGFnIGluIHRhZ3MpIHtcblx0ICAgICAgICB2YXIgcG9zID0gc3RyaW5nUG9vbC5sZW5ndGg7XG5cdCAgICAgICAgc3RyaW5nUG9vbCArPSB0YWdzW3RhZ107XG5cblx0ICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICd0YWcgJyArIHRhZywgdHlwZTogJ1RBRycsIHZhbHVlOiB0YWd9KTtcblx0ICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdvZmZzZXQgJyArIHRhZywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHN0cmluZ1Bvb2xPZmZzZXQgKyBwb3N9KTtcblx0ICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdsZW5ndGggJyArIHRhZywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHRhZ3NbdGFnXS5sZW5ndGh9KTtcblx0ICAgIH1cblxuXHQgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnc3RyaW5nUG9vbCcsIHR5cGU6ICdDSEFSQVJSQVknLCB2YWx1ZTogc3RyaW5nUG9vbH0pO1xuXG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0dmFyIG1ldGEgPSB7IHBhcnNlOiBwYXJzZU1ldGFUYWJsZSwgbWFrZTogbWFrZU1ldGFUYWJsZSB9O1xuXG5cdC8vIFRoZSBgc2ZudGAgd3JhcHBlciBwcm92aWRlcyBvcmdhbml6YXRpb24gZm9yIHRoZSB0YWJsZXMgaW4gdGhlIGZvbnQuXG5cblx0ZnVuY3Rpb24gbG9nMih2KSB7XG5cdCAgICByZXR1cm4gTWF0aC5sb2codikgLyBNYXRoLmxvZygyKSB8IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21wdXRlQ2hlY2tTdW0oYnl0ZXMpIHtcblx0ICAgIHdoaWxlIChieXRlcy5sZW5ndGggJSA0ICE9PSAwKSB7XG5cdCAgICAgICAgYnl0ZXMucHVzaCgwKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHN1bSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG5cdCAgICAgICAgc3VtICs9IChieXRlc1tpXSA8PCAyNCkgK1xuXHQgICAgICAgICAgICAoYnl0ZXNbaSArIDFdIDw8IDE2KSArXG5cdCAgICAgICAgICAgIChieXRlc1tpICsgMl0gPDwgOCkgK1xuXHQgICAgICAgICAgICAoYnl0ZXNbaSArIDNdKTtcblx0ICAgIH1cblxuXHQgICAgc3VtICU9IE1hdGgucG93KDIsIDMyKTtcblx0ICAgIHJldHVybiBzdW07XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlVGFibGVSZWNvcmQodGFnLCBjaGVja1N1bSwgb2Zmc2V0LCBsZW5ndGgpIHtcblx0ICAgIHJldHVybiBuZXcgdGFibGUuUmVjb3JkKCdUYWJsZSBSZWNvcmQnLCBbXG5cdCAgICAgICAge25hbWU6ICd0YWcnLCB0eXBlOiAnVEFHJywgdmFsdWU6IHRhZyAhPT0gdW5kZWZpbmVkID8gdGFnIDogJyd9LFxuXHQgICAgICAgIHtuYW1lOiAnY2hlY2tTdW0nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogY2hlY2tTdW0gIT09IHVuZGVmaW5lZCA/IGNoZWNrU3VtIDogMH0sXG5cdCAgICAgICAge25hbWU6ICdvZmZzZXQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogb2Zmc2V0ICE9PSB1bmRlZmluZWQgPyBvZmZzZXQgOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2xlbmd0aCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBsZW5ndGggIT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IDB9XG5cdCAgICBdKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VTZm50VGFibGUodGFibGVzKSB7XG5cdCAgICB2YXIgc2ZudCA9IG5ldyB0YWJsZS5UYWJsZSgnc2ZudCcsIFtcblx0ICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVEFHJywgdmFsdWU6ICdPVFRPJ30sXG5cdCAgICAgICAge25hbWU6ICdudW1UYWJsZXMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnc2VhcmNoUmFuZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuXHQgICAgICAgIHtuYW1lOiAnZW50cnlTZWxlY3RvcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICdyYW5nZVNoaWZ0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuXHQgICAgXSk7XG5cdCAgICBzZm50LnRhYmxlcyA9IHRhYmxlcztcblx0ICAgIHNmbnQubnVtVGFibGVzID0gdGFibGVzLmxlbmd0aDtcblx0ICAgIHZhciBoaWdoZXN0UG93ZXJPZjIgPSBNYXRoLnBvdygyLCBsb2cyKHNmbnQubnVtVGFibGVzKSk7XG5cdCAgICBzZm50LnNlYXJjaFJhbmdlID0gMTYgKiBoaWdoZXN0UG93ZXJPZjI7XG5cdCAgICBzZm50LmVudHJ5U2VsZWN0b3IgPSBsb2cyKGhpZ2hlc3RQb3dlck9mMik7XG5cdCAgICBzZm50LnJhbmdlU2hpZnQgPSBzZm50Lm51bVRhYmxlcyAqIDE2IC0gc2ZudC5zZWFyY2hSYW5nZTtcblxuXHQgICAgdmFyIHJlY29yZEZpZWxkcyA9IFtdO1xuXHQgICAgdmFyIHRhYmxlRmllbGRzID0gW107XG5cblx0ICAgIHZhciBvZmZzZXQgPSBzZm50LnNpemVPZigpICsgKG1ha2VUYWJsZVJlY29yZCgpLnNpemVPZigpICogc2ZudC5udW1UYWJsZXMpO1xuXHQgICAgd2hpbGUgKG9mZnNldCAlIDQgIT09IDApIHtcblx0ICAgICAgICBvZmZzZXQgKz0gMTtcblx0ICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiAncGFkZGluZycsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9KTtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJsZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgdCA9IHRhYmxlc1tpXTtcblx0ICAgICAgICBjaGVjay5hcmd1bWVudCh0LnRhYmxlTmFtZS5sZW5ndGggPT09IDQsICdUYWJsZSBuYW1lJyArIHQudGFibGVOYW1lICsgJyBpcyBpbnZhbGlkLicpO1xuXHQgICAgICAgIHZhciB0YWJsZUxlbmd0aCA9IHQuc2l6ZU9mKCk7XG5cdCAgICAgICAgdmFyIHRhYmxlUmVjb3JkID0gbWFrZVRhYmxlUmVjb3JkKHQudGFibGVOYW1lLCBjb21wdXRlQ2hlY2tTdW0odC5lbmNvZGUoKSksIG9mZnNldCwgdGFibGVMZW5ndGgpO1xuXHQgICAgICAgIHJlY29yZEZpZWxkcy5wdXNoKHtuYW1lOiB0YWJsZVJlY29yZC50YWcgKyAnIFRhYmxlIFJlY29yZCcsIHR5cGU6ICdSRUNPUkQnLCB2YWx1ZTogdGFibGVSZWNvcmR9KTtcblx0ICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiB0LnRhYmxlTmFtZSArICcgdGFibGUnLCB0eXBlOiAnUkVDT1JEJywgdmFsdWU6IHR9KTtcblx0ICAgICAgICBvZmZzZXQgKz0gdGFibGVMZW5ndGg7XG5cdCAgICAgICAgY2hlY2suYXJndW1lbnQoIWlzTmFOKG9mZnNldCksICdTb21ldGhpbmcgd2VudCB3cm9uZyBjYWxjdWxhdGluZyB0aGUgb2Zmc2V0LicpO1xuXHQgICAgICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG5cdCAgICAgICAgICAgIG9mZnNldCArPSAxO1xuXHQgICAgICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiAncGFkZGluZycsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIFRhYmxlIHJlY29yZHMgbmVlZCB0byBiZSBzb3J0ZWQgYWxwaGFiZXRpY2FsbHkuXG5cdCAgICByZWNvcmRGaWVsZHMuc29ydChmdW5jdGlvbihyMSwgcjIpIHtcblx0ICAgICAgICBpZiAocjEudmFsdWUudGFnID4gcjIudmFsdWUudGFnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgc2ZudC5maWVsZHMgPSBzZm50LmZpZWxkcy5jb25jYXQocmVjb3JkRmllbGRzKTtcblx0ICAgIHNmbnQuZmllbGRzID0gc2ZudC5maWVsZHMuY29uY2F0KHRhYmxlRmllbGRzKTtcblx0ICAgIHJldHVybiBzZm50O1xuXHR9XG5cblx0Ly8gR2V0IHRoZSBtZXRyaWNzIGZvciBhIGNoYXJhY3Rlci4gSWYgdGhlIHN0cmluZyBoYXMgbW9yZSB0aGFuIG9uZSBjaGFyYWN0ZXJcblx0Ly8gdGhpcyBmdW5jdGlvbiByZXR1cm5zIG1ldHJpY3MgZm9yIHRoZSBmaXJzdCBhdmFpbGFibGUgY2hhcmFjdGVyLlxuXHQvLyBZb3UgY2FuIHByb3ZpZGUgb3B0aW9uYWwgZmFsbGJhY2sgbWV0cmljcyBpZiBubyBjaGFyYWN0ZXJzIGFyZSBhdmFpbGFibGUuXG5cdGZ1bmN0aW9uIG1ldHJpY3NGb3JDaGFyKGZvbnQsIGNoYXJzLCBub3RGb3VuZE1ldHJpY3MpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgZ2x5cGhJbmRleCA9IGZvbnQuY2hhclRvR2x5cGhJbmRleChjaGFyc1tpXSk7XG5cdCAgICAgICAgaWYgKGdseXBoSW5kZXggPiAwKSB7XG5cdCAgICAgICAgICAgIHZhciBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcblx0ICAgICAgICAgICAgcmV0dXJuIGdseXBoLmdldE1ldHJpY3MoKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBub3RGb3VuZE1ldHJpY3M7XG5cdH1cblxuXHRmdW5jdGlvbiBhdmVyYWdlKHZzKSB7XG5cdCAgICB2YXIgc3VtID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdnMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICBzdW0gKz0gdnNbaV07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzdW0gLyB2cy5sZW5ndGg7XG5cdH1cblxuXHQvLyBDb252ZXJ0IHRoZSBmb250IG9iamVjdCB0byBhIFNGTlQgZGF0YSBzdHJ1Y3R1cmUuXG5cdC8vIFRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IHRhYmxlcyBhbmQgbWV0YWRhdGEgdG8gY3JlYXRlIGEgYmluYXJ5IE9URiBmaWxlLlxuXHRmdW5jdGlvbiBmb250VG9TZm50VGFibGUoZm9udCkge1xuXHQgICAgdmFyIHhNaW5zID0gW107XG5cdCAgICB2YXIgeU1pbnMgPSBbXTtcblx0ICAgIHZhciB4TWF4cyA9IFtdO1xuXHQgICAgdmFyIHlNYXhzID0gW107XG5cdCAgICB2YXIgYWR2YW5jZVdpZHRocyA9IFtdO1xuXHQgICAgdmFyIGxlZnRTaWRlQmVhcmluZ3MgPSBbXTtcblx0ICAgIHZhciByaWdodFNpZGVCZWFyaW5ncyA9IFtdO1xuXHQgICAgdmFyIGZpcnN0Q2hhckluZGV4O1xuXHQgICAgdmFyIGxhc3RDaGFySW5kZXggPSAwO1xuXHQgICAgdmFyIHVsVW5pY29kZVJhbmdlMSA9IDA7XG5cdCAgICB2YXIgdWxVbmljb2RlUmFuZ2UyID0gMDtcblx0ICAgIHZhciB1bFVuaWNvZGVSYW5nZTMgPSAwO1xuXHQgICAgdmFyIHVsVW5pY29kZVJhbmdlNCA9IDA7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9udC5nbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBocy5nZXQoaSk7XG5cdCAgICAgICAgdmFyIHVuaWNvZGUgPSBnbHlwaC51bmljb2RlIHwgMDtcblxuXHQgICAgICAgIGlmIChpc05hTihnbHlwaC5hZHZhbmNlV2lkdGgpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2x5cGggJyArIGdseXBoLm5hbWUgKyAnICgnICsgaSArICcpOiBhZHZhbmNlV2lkdGggaXMgbm90IGEgbnVtYmVyLicpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChmaXJzdENoYXJJbmRleCA+IHVuaWNvZGUgfHwgZmlyc3RDaGFySW5kZXggPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAvLyBpZ25vcmUgLm5vdGRlZiBjaGFyXG5cdCAgICAgICAgICAgIGlmICh1bmljb2RlID4gMCkge1xuXHQgICAgICAgICAgICAgICAgZmlyc3RDaGFySW5kZXggPSB1bmljb2RlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGxhc3RDaGFySW5kZXggPCB1bmljb2RlKSB7XG5cdCAgICAgICAgICAgIGxhc3RDaGFySW5kZXggPSB1bmljb2RlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBwb3NpdGlvbiA9IG9zMi5nZXRVbmljb2RlUmFuZ2UodW5pY29kZSk7XG5cdCAgICAgICAgaWYgKHBvc2l0aW9uIDwgMzIpIHtcblx0ICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2UxIHw9IDEgPDwgcG9zaXRpb247XG5cdCAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IDY0KSB7XG5cdCAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlMiB8PSAxIDw8IHBvc2l0aW9uIC0gMzI7XG5cdCAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IDk2KSB7XG5cdCAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlMyB8PSAxIDw8IHBvc2l0aW9uIC0gNjQ7XG5cdCAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IDEyMykge1xuXHQgICAgICAgICAgICB1bFVuaWNvZGVSYW5nZTQgfD0gMSA8PCBwb3NpdGlvbiAtIDk2O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pY29kZSByYW5nZXMgYml0cyA+IDEyMyBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFNraXAgbm9uLWltcG9ydGFudCBjaGFyYWN0ZXJzLlxuXHQgICAgICAgIGlmIChnbHlwaC5uYW1lID09PSAnLm5vdGRlZicpIHsgY29udGludWU7IH1cblx0ICAgICAgICB2YXIgbWV0cmljcyA9IGdseXBoLmdldE1ldHJpY3MoKTtcblx0ICAgICAgICB4TWlucy5wdXNoKG1ldHJpY3MueE1pbik7XG5cdCAgICAgICAgeU1pbnMucHVzaChtZXRyaWNzLnlNaW4pO1xuXHQgICAgICAgIHhNYXhzLnB1c2gobWV0cmljcy54TWF4KTtcblx0ICAgICAgICB5TWF4cy5wdXNoKG1ldHJpY3MueU1heCk7XG5cdCAgICAgICAgbGVmdFNpZGVCZWFyaW5ncy5wdXNoKG1ldHJpY3MubGVmdFNpZGVCZWFyaW5nKTtcblx0ICAgICAgICByaWdodFNpZGVCZWFyaW5ncy5wdXNoKG1ldHJpY3MucmlnaHRTaWRlQmVhcmluZyk7XG5cdCAgICAgICAgYWR2YW5jZVdpZHRocy5wdXNoKGdseXBoLmFkdmFuY2VXaWR0aCk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBnbG9iYWxzID0ge1xuXHQgICAgICAgIHhNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHhNaW5zKSxcblx0ICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5TWlucyksXG5cdCAgICAgICAgeE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeE1heHMpLFxuXHQgICAgICAgIHlNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHlNYXhzKSxcblx0ICAgICAgICBhZHZhbmNlV2lkdGhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIGFkdmFuY2VXaWR0aHMpLFxuXHQgICAgICAgIGFkdmFuY2VXaWR0aEF2ZzogYXZlcmFnZShhZHZhbmNlV2lkdGhzKSxcblx0ICAgICAgICBtaW5MZWZ0U2lkZUJlYXJpbmc6IE1hdGgubWluLmFwcGx5KG51bGwsIGxlZnRTaWRlQmVhcmluZ3MpLFxuXHQgICAgICAgIG1heExlZnRTaWRlQmVhcmluZzogTWF0aC5tYXguYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG5cdCAgICAgICAgbWluUmlnaHRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgcmlnaHRTaWRlQmVhcmluZ3MpXG5cdCAgICB9O1xuXHQgICAgZ2xvYmFscy5hc2NlbmRlciA9IGZvbnQuYXNjZW5kZXI7XG5cdCAgICBnbG9iYWxzLmRlc2NlbmRlciA9IGZvbnQuZGVzY2VuZGVyO1xuXG5cdCAgICB2YXIgaGVhZFRhYmxlID0gaGVhZC5tYWtlKHtcblx0ICAgICAgICBmbGFnczogMywgLy8gMDAwMDAwMTEgKGJhc2VsaW5lIGZvciBmb250IGF0IHk9MDsgbGVmdCBzaWRlYmVhcmluZyBwb2ludCBhdCB4PTApXG5cdCAgICAgICAgdW5pdHNQZXJFbTogZm9udC51bml0c1BlckVtLFxuXHQgICAgICAgIHhNaW46IGdsb2JhbHMueE1pbixcblx0ICAgICAgICB5TWluOiBnbG9iYWxzLnlNaW4sXG5cdCAgICAgICAgeE1heDogZ2xvYmFscy54TWF4LFxuXHQgICAgICAgIHlNYXg6IGdsb2JhbHMueU1heCxcblx0ICAgICAgICBsb3dlc3RSZWNQUEVNOiAzLFxuXHQgICAgICAgIGNyZWF0ZWRUaW1lc3RhbXA6IGZvbnQuY3JlYXRlZFRpbWVzdGFtcFxuXHQgICAgfSk7XG5cblx0ICAgIHZhciBoaGVhVGFibGUgPSBoaGVhLm1ha2Uoe1xuXHQgICAgICAgIGFzY2VuZGVyOiBnbG9iYWxzLmFzY2VuZGVyLFxuXHQgICAgICAgIGRlc2NlbmRlcjogZ2xvYmFscy5kZXNjZW5kZXIsXG5cdCAgICAgICAgYWR2YW5jZVdpZHRoTWF4OiBnbG9iYWxzLmFkdmFuY2VXaWR0aE1heCxcblx0ICAgICAgICBtaW5MZWZ0U2lkZUJlYXJpbmc6IGdsb2JhbHMubWluTGVmdFNpZGVCZWFyaW5nLFxuXHQgICAgICAgIG1pblJpZ2h0U2lkZUJlYXJpbmc6IGdsb2JhbHMubWluUmlnaHRTaWRlQmVhcmluZyxcblx0ICAgICAgICB4TWF4RXh0ZW50OiBnbG9iYWxzLm1heExlZnRTaWRlQmVhcmluZyArIChnbG9iYWxzLnhNYXggLSBnbG9iYWxzLnhNaW4pLFxuXHQgICAgICAgIG51bWJlck9mSE1ldHJpY3M6IGZvbnQuZ2x5cGhzLmxlbmd0aFxuXHQgICAgfSk7XG5cblx0ICAgIHZhciBtYXhwVGFibGUgPSBtYXhwLm1ha2UoZm9udC5nbHlwaHMubGVuZ3RoKTtcblxuXHQgICAgdmFyIG9zMlRhYmxlID0gb3MyLm1ha2Uoe1xuXHQgICAgICAgIHhBdmdDaGFyV2lkdGg6IE1hdGgucm91bmQoZ2xvYmFscy5hZHZhbmNlV2lkdGhBdmcpLFxuXHQgICAgICAgIHVzV2VpZ2h0Q2xhc3M6IGZvbnQudGFibGVzLm9zMi51c1dlaWdodENsYXNzLFxuXHQgICAgICAgIHVzV2lkdGhDbGFzczogZm9udC50YWJsZXMub3MyLnVzV2lkdGhDbGFzcyxcblx0ICAgICAgICB1c0ZpcnN0Q2hhckluZGV4OiBmaXJzdENoYXJJbmRleCxcblx0ICAgICAgICB1c0xhc3RDaGFySW5kZXg6IGxhc3RDaGFySW5kZXgsXG5cdCAgICAgICAgdWxVbmljb2RlUmFuZ2UxOiB1bFVuaWNvZGVSYW5nZTEsXG5cdCAgICAgICAgdWxVbmljb2RlUmFuZ2UyOiB1bFVuaWNvZGVSYW5nZTIsXG5cdCAgICAgICAgdWxVbmljb2RlUmFuZ2UzOiB1bFVuaWNvZGVSYW5nZTMsXG5cdCAgICAgICAgdWxVbmljb2RlUmFuZ2U0OiB1bFVuaWNvZGVSYW5nZTQsXG5cdCAgICAgICAgZnNTZWxlY3Rpb246IGZvbnQudGFibGVzLm9zMi5mc1NlbGVjdGlvbiwgLy8gUkVHVUxBUlxuXHQgICAgICAgIC8vIFNlZSBodHRwOi8vdHlwb3BoaWxlLmNvbS9ub2RlLzEzMDgxIGZvciBtb3JlIGluZm8gb24gdmVydGljYWwgbWV0cmljcy5cblx0ICAgICAgICAvLyBXZSBnZXQgbWV0cmljcyBmb3IgdHlwaWNhbCBjaGFyYWN0ZXJzIChzdWNoIGFzIFwieFwiIGZvciB4SGVpZ2h0KS5cblx0ICAgICAgICAvLyBXZSBwcm92aWRlIHNvbWUgZmFsbGJhY2sgY2hhcmFjdGVycyBpZiBjaGFyYWN0ZXJzIGFyZSB1bmF2YWlsYWJsZTogdGhlaXJcblx0ICAgICAgICAvLyBvcmRlcmluZyB3YXMgY2hvc2VuIGV4cGVyaW1lbnRhbGx5LlxuXHQgICAgICAgIHNUeXBvQXNjZW5kZXI6IGdsb2JhbHMuYXNjZW5kZXIsXG5cdCAgICAgICAgc1R5cG9EZXNjZW5kZXI6IGdsb2JhbHMuZGVzY2VuZGVyLFxuXHQgICAgICAgIHNUeXBvTGluZUdhcDogMCxcblx0ICAgICAgICB1c1dpbkFzY2VudDogZ2xvYmFscy55TWF4LFxuXHQgICAgICAgIHVzV2luRGVzY2VudDogTWF0aC5hYnMoZ2xvYmFscy55TWluKSxcblx0ICAgICAgICB1bENvZGVQYWdlUmFuZ2UxOiAxLCAvLyBGSVhNRTogaGFyZC1jb2RlIExhdGluIDEgc3VwcG9ydCBmb3Igbm93XG5cdCAgICAgICAgc3hIZWlnaHQ6IG1ldHJpY3NGb3JDaGFyKGZvbnQsICd4eXZ3Jywge3lNYXg6IE1hdGgucm91bmQoZ2xvYmFscy5hc2NlbmRlciAvIDIpfSkueU1heCxcblx0ICAgICAgICBzQ2FwSGVpZ2h0OiBtZXRyaWNzRm9yQ2hhcihmb250LCAnSElLTEVGSk1OVFpCRFBSQUdPUVNVVldYWScsIGdsb2JhbHMpLnlNYXgsXG5cdCAgICAgICAgdXNEZWZhdWx0Q2hhcjogZm9udC5oYXNDaGFyKCcgJykgPyAzMiA6IDAsIC8vIFVzZSBzcGFjZSBhcyB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIsIGlmIGF2YWlsYWJsZS5cblx0ICAgICAgICB1c0JyZWFrQ2hhcjogZm9udC5oYXNDaGFyKCcgJykgPyAzMiA6IDAgLy8gVXNlIHNwYWNlIGFzIHRoZSBicmVhayBjaGFyYWN0ZXIsIGlmIGF2YWlsYWJsZS5cblx0ICAgIH0pO1xuXG5cdCAgICB2YXIgaG10eFRhYmxlID0gaG10eC5tYWtlKGZvbnQuZ2x5cGhzKTtcblx0ICAgIHZhciBjbWFwVGFibGUgPSBjbWFwLm1ha2UoZm9udC5nbHlwaHMpO1xuXG5cdCAgICB2YXIgZW5nbGlzaEZhbWlseU5hbWUgPSBmb250LmdldEVuZ2xpc2hOYW1lKCdmb250RmFtaWx5Jyk7XG5cdCAgICB2YXIgZW5nbGlzaFN0eWxlTmFtZSA9IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ2ZvbnRTdWJmYW1pbHknKTtcblx0ICAgIHZhciBlbmdsaXNoRnVsbE5hbWUgPSBlbmdsaXNoRmFtaWx5TmFtZSArICcgJyArIGVuZ2xpc2hTdHlsZU5hbWU7XG5cdCAgICB2YXIgcG9zdFNjcmlwdE5hbWUgPSBmb250LmdldEVuZ2xpc2hOYW1lKCdwb3N0U2NyaXB0TmFtZScpO1xuXHQgICAgaWYgKCFwb3N0U2NyaXB0TmFtZSkge1xuXHQgICAgICAgIHBvc3RTY3JpcHROYW1lID0gZW5nbGlzaEZhbWlseU5hbWUucmVwbGFjZSgvXFxzL2csICcnKSArICctJyArIGVuZ2xpc2hTdHlsZU5hbWU7XG5cdCAgICB9XG5cblx0ICAgIHZhciBuYW1lcyA9IHt9O1xuXHQgICAgZm9yICh2YXIgbiBpbiBmb250Lm5hbWVzKSB7XG5cdCAgICAgICAgbmFtZXNbbl0gPSBmb250Lm5hbWVzW25dO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIW5hbWVzLnVuaXF1ZUlEKSB7XG5cdCAgICAgICAgbmFtZXMudW5pcXVlSUQgPSB7ZW46IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ21hbnVmYWN0dXJlcicpICsgJzonICsgZW5nbGlzaEZ1bGxOYW1lfTtcblx0ICAgIH1cblxuXHQgICAgaWYgKCFuYW1lcy5wb3N0U2NyaXB0TmFtZSkge1xuXHQgICAgICAgIG5hbWVzLnBvc3RTY3JpcHROYW1lID0ge2VuOiBwb3N0U2NyaXB0TmFtZX07XG5cdCAgICB9XG5cblx0ICAgIGlmICghbmFtZXMucHJlZmVycmVkRmFtaWx5KSB7XG5cdCAgICAgICAgbmFtZXMucHJlZmVycmVkRmFtaWx5ID0gZm9udC5uYW1lcy5mb250RmFtaWx5O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIW5hbWVzLnByZWZlcnJlZFN1YmZhbWlseSkge1xuXHQgICAgICAgIG5hbWVzLnByZWZlcnJlZFN1YmZhbWlseSA9IGZvbnQubmFtZXMuZm9udFN1YmZhbWlseTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGxhbmd1YWdlVGFncyA9IFtdO1xuXHQgICAgdmFyIG5hbWVUYWJsZSA9IF9uYW1lLm1ha2UobmFtZXMsIGxhbmd1YWdlVGFncyk7XG5cdCAgICB2YXIgbHRhZ1RhYmxlID0gKGxhbmd1YWdlVGFncy5sZW5ndGggPiAwID8gbHRhZy5tYWtlKGxhbmd1YWdlVGFncykgOiB1bmRlZmluZWQpO1xuXG5cdCAgICB2YXIgcG9zdFRhYmxlID0gcG9zdC5tYWtlKCk7XG5cdCAgICB2YXIgY2ZmVGFibGUgPSBjZmYubWFrZShmb250LmdseXBocywge1xuXHQgICAgICAgIHZlcnNpb246IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ3ZlcnNpb24nKSxcblx0ICAgICAgICBmdWxsTmFtZTogZW5nbGlzaEZ1bGxOYW1lLFxuXHQgICAgICAgIGZhbWlseU5hbWU6IGVuZ2xpc2hGYW1pbHlOYW1lLFxuXHQgICAgICAgIHdlaWdodE5hbWU6IGVuZ2xpc2hTdHlsZU5hbWUsXG5cdCAgICAgICAgcG9zdFNjcmlwdE5hbWU6IHBvc3RTY3JpcHROYW1lLFxuXHQgICAgICAgIHVuaXRzUGVyRW06IGZvbnQudW5pdHNQZXJFbSxcblx0ICAgICAgICBmb250QkJveDogWzAsIGdsb2JhbHMueU1pbiwgZ2xvYmFscy5hc2NlbmRlciwgZ2xvYmFscy5hZHZhbmNlV2lkdGhNYXhdXG5cdCAgICB9KTtcblxuXHQgICAgdmFyIG1ldGFUYWJsZSA9IChmb250Lm1ldGFzICYmIE9iamVjdC5rZXlzKGZvbnQubWV0YXMpLmxlbmd0aCA+IDApID8gbWV0YS5tYWtlKGZvbnQubWV0YXMpIDogdW5kZWZpbmVkO1xuXG5cdCAgICAvLyBUaGUgb3JkZXIgZG9lcyBub3QgbWF0dGVyIGJlY2F1c2UgbWFrZVNmbnRUYWJsZSgpIHdpbGwgc29ydCB0aGVtLlxuXHQgICAgdmFyIHRhYmxlcyA9IFtoZWFkVGFibGUsIGhoZWFUYWJsZSwgbWF4cFRhYmxlLCBvczJUYWJsZSwgbmFtZVRhYmxlLCBjbWFwVGFibGUsIHBvc3RUYWJsZSwgY2ZmVGFibGUsIGhtdHhUYWJsZV07XG5cdCAgICBpZiAobHRhZ1RhYmxlKSB7XG5cdCAgICAgICAgdGFibGVzLnB1c2gobHRhZ1RhYmxlKTtcblx0ICAgIH1cblx0ICAgIC8vIE9wdGlvbmFsIHRhYmxlc1xuXHQgICAgaWYgKGZvbnQudGFibGVzLmdzdWIpIHtcblx0ICAgICAgICB0YWJsZXMucHVzaChnc3ViLm1ha2UoZm9udC50YWJsZXMuZ3N1YikpO1xuXHQgICAgfVxuXHQgICAgaWYgKG1ldGFUYWJsZSkge1xuXHQgICAgICAgIHRhYmxlcy5wdXNoKG1ldGFUYWJsZSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBzZm50VGFibGUgPSBtYWtlU2ZudFRhYmxlKHRhYmxlcyk7XG5cblx0ICAgIC8vIENvbXB1dGUgdGhlIGZvbnQncyBjaGVja1N1bSBhbmQgc3RvcmUgaXQgaW4gaGVhZC5jaGVja1N1bUFkanVzdG1lbnQuXG5cdCAgICB2YXIgYnl0ZXMgPSBzZm50VGFibGUuZW5jb2RlKCk7XG5cdCAgICB2YXIgY2hlY2tTdW0gPSBjb21wdXRlQ2hlY2tTdW0oYnl0ZXMpO1xuXHQgICAgdmFyIHRhYmxlRmllbGRzID0gc2ZudFRhYmxlLmZpZWxkcztcblx0ICAgIHZhciBjaGVja1N1bUFkanVzdGVkID0gZmFsc2U7XG5cdCAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0YWJsZUZpZWxkcy5sZW5ndGg7IGkkMSArPSAxKSB7XG5cdCAgICAgICAgaWYgKHRhYmxlRmllbGRzW2kkMV0ubmFtZSA9PT0gJ2hlYWQgdGFibGUnKSB7XG5cdCAgICAgICAgICAgIHRhYmxlRmllbGRzW2kkMV0udmFsdWUuY2hlY2tTdW1BZGp1c3RtZW50ID0gMHhCMUIwQUZCQSAtIGNoZWNrU3VtO1xuXHQgICAgICAgICAgICBjaGVja1N1bUFkanVzdGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoIWNoZWNrU3VtQWRqdXN0ZWQpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlYWQgdGFibGUgd2l0aCBjaGVja1N1bSB0byBhZGp1c3QuJyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBzZm50VGFibGU7XG5cdH1cblxuXHR2YXIgc2ZudCA9IHsgbWFrZTogbWFrZVNmbnRUYWJsZSwgZm9udFRvVGFibGU6IGZvbnRUb1NmbnRUYWJsZSwgY29tcHV0ZUNoZWNrU3VtOiBjb21wdXRlQ2hlY2tTdW0gfTtcblxuXHQvLyBUaGUgTGF5b3V0IG9iamVjdCBpcyB0aGUgcHJvdG90eXBlIG9mIFN1YnN0aXR1dGlvbiBvYmplY3RzLCBhbmQgcHJvdmlkZXNcblxuXHRmdW5jdGlvbiBzZWFyY2hUYWcoYXJyLCB0YWcpIHtcblx0ICAgIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuXHQgICAgdmFyIGltaW4gPSAwO1xuXHQgICAgdmFyIGltYXggPSBhcnIubGVuZ3RoIC0gMTtcblx0ICAgIHdoaWxlIChpbWluIDw9IGltYXgpIHtcblx0ICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG5cdCAgICAgICAgdmFyIHZhbCA9IGFycltpbWlkXS50YWc7XG5cdCAgICAgICAgaWYgKHZhbCA9PT0gdGFnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBpbWlkO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodmFsIDwgdGFnKSB7XG5cdCAgICAgICAgICAgIGltaW4gPSBpbWlkICsgMTtcblx0ICAgICAgICB9IGVsc2UgeyBpbWF4ID0gaW1pZCAtIDE7IH1cblx0ICAgIH1cblx0ICAgIC8vIE5vdCBmb3VuZDogcmV0dXJuIC0xLWluc2VydGlvbiBwb2ludFxuXHQgICAgcmV0dXJuIC1pbWluIC0gMTtcblx0fVxuXG5cdGZ1bmN0aW9uIGJpblNlYXJjaChhcnIsIHZhbHVlKSB7XG5cdCAgICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cblx0ICAgIHZhciBpbWluID0gMDtcblx0ICAgIHZhciBpbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG5cdCAgICB3aGlsZSAoaW1pbiA8PSBpbWF4KSB7XG5cdCAgICAgICAgdmFyIGltaWQgPSAoaW1pbiArIGltYXgpID4+PiAxO1xuXHQgICAgICAgIHZhciB2YWwgPSBhcnJbaW1pZF07XG5cdCAgICAgICAgaWYgKHZhbCA9PT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGltaWQ7XG5cdCAgICAgICAgfSBlbHNlIGlmICh2YWwgPCB2YWx1ZSkge1xuXHQgICAgICAgICAgICBpbWluID0gaW1pZCArIDE7XG5cdCAgICAgICAgfSBlbHNlIHsgaW1heCA9IGltaWQgLSAxOyB9XG5cdCAgICB9XG5cdCAgICAvLyBOb3QgZm91bmQ6IHJldHVybiAtMS1pbnNlcnRpb24gcG9pbnRcblx0ICAgIHJldHVybiAtaW1pbiAtIDE7XG5cdH1cblxuXHQvLyBiaW5hcnkgc2VhcmNoIGluIGEgbGlzdCBvZiByYW5nZXMgKGNvdmVyYWdlLCBjbGFzcyBkZWZpbml0aW9uKVxuXHRmdW5jdGlvbiBzZWFyY2hSYW5nZShyYW5nZXMsIHZhbHVlKSB7XG5cdCAgICAvLyBqc2hpbnQgYml0d2lzZTogZmFsc2Vcblx0ICAgIHZhciByYW5nZTtcblx0ICAgIHZhciBpbWluID0gMDtcblx0ICAgIHZhciBpbWF4ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG5cdCAgICB3aGlsZSAoaW1pbiA8PSBpbWF4KSB7XG5cdCAgICAgICAgdmFyIGltaWQgPSAoaW1pbiArIGltYXgpID4+PiAxO1xuXHQgICAgICAgIHJhbmdlID0gcmFuZ2VzW2ltaWRdO1xuXHQgICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuXHQgICAgICAgIGlmIChzdGFydCA9PT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPCB2YWx1ZSkge1xuXHQgICAgICAgICAgICBpbWluID0gaW1pZCArIDE7XG5cdCAgICAgICAgfSBlbHNlIHsgaW1heCA9IGltaWQgLSAxOyB9XG5cdCAgICB9XG5cdCAgICBpZiAoaW1pbiA+IDApIHtcblx0ICAgICAgICByYW5nZSA9IHJhbmdlc1tpbWluIC0gMV07XG5cdCAgICAgICAgaWYgKHZhbHVlID4gcmFuZ2UuZW5kKSB7IHJldHVybiAwOyB9XG5cdCAgICAgICAgcmV0dXJuIHJhbmdlO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLkxheW91dFxuXHQgKiBAY2xhc3Ncblx0ICovXG5cdGZ1bmN0aW9uIExheW91dChmb250LCB0YWJsZU5hbWUpIHtcblx0ICAgIHRoaXMuZm9udCA9IGZvbnQ7XG5cdCAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcblx0fVxuXG5cdExheW91dC5wcm90b3R5cGUgPSB7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmluYXJ5IHNlYXJjaCBhbiBvYmplY3QgYnkgXCJ0YWdcIiBwcm9wZXJ0eVxuXHQgICAgICogQGluc3RhbmNlXG5cdCAgICAgKiBAZnVuY3Rpb24gc2VhcmNoVGFnXG5cdCAgICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuTGF5b3V0XG5cdCAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG5cdCAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZ1xuXHQgICAgICogQHJldHVybiB7bnVtYmVyfVxuXHQgICAgICovXG5cdCAgICBzZWFyY2hUYWc6IHNlYXJjaFRhZyxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCaW5hcnkgc2VhcmNoIGluIGEgbGlzdCBvZiBudW1iZXJzXG5cdCAgICAgKiBAaW5zdGFuY2Vcblx0ICAgICAqIEBmdW5jdGlvbiBiaW5TZWFyY2hcblx0ICAgICAqIEBtZW1iZXJvZiBvcGVudHlwZS5MYXlvdXRcblx0ICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnJcblx0ICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcblx0ICAgICAqIEByZXR1cm4ge251bWJlcn1cblx0ICAgICAqL1xuXHQgICAgYmluU2VhcmNoOiBiaW5TZWFyY2gsXG5cblx0ICAgIC8qKlxuXHQgICAgICogR2V0IG9yIGNyZWF0ZSB0aGUgTGF5b3V0IHRhYmxlIChHU1VCLCBHUE9TIGV0YykuXG5cdCAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjcmVhdGUgLSBXaGV0aGVyIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBHU1VCIG9yIEdQT1MgdGFibGUuXG5cdCAgICAgKi9cblx0ICAgIGdldFRhYmxlOiBmdW5jdGlvbihjcmVhdGUpIHtcblx0ICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV07XG5cdCAgICAgICAgaWYgKCFsYXlvdXQgJiYgY3JlYXRlKSB7XG5cdCAgICAgICAgICAgIGxheW91dCA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdID0gdGhpcy5jcmVhdGVEZWZhdWx0VGFibGUoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxheW91dDtcblx0ICAgIH0sXG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJucyBhbGwgc2NyaXB0cyBpbiB0aGUgc3Vic3RpdHV0aW9uIHRhYmxlLlxuXHQgICAgICogQGluc3RhbmNlXG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgZ2V0U2NyaXB0TmFtZXM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldFRhYmxlKCk7XG5cdCAgICAgICAgaWYgKCFsYXlvdXQpIHsgcmV0dXJuIFtdOyB9XG5cdCAgICAgICAgcmV0dXJuIGxheW91dC5zY3JpcHRzLm1hcChmdW5jdGlvbihzY3JpcHQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNjcmlwdC50YWc7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgdGhlIGJlc3QgYmV0IGZvciBhIHNjcmlwdCBuYW1lLlxuXHQgICAgICogUmV0dXJucyAnREZMVCcgaWYgaXQgZXhpc3RzLlxuXHQgICAgICogSWYgbm90LCByZXR1cm5zICdsYXRuJyBpZiBpdCBleGlzdHMuXG5cdCAgICAgKiBJZiBuZWl0aGVyIGV4aXN0LCByZXR1cm5zIHVuZGVmaW5lZC5cblx0ICAgICAqL1xuXHQgICAgZ2V0RGVmYXVsdFNjcmlwdE5hbWU6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldFRhYmxlKCk7XG5cdCAgICAgICAgaWYgKCFsYXlvdXQpIHsgcmV0dXJuOyB9XG5cdCAgICAgICAgdmFyIGhhc0xhdG4gPSBmYWxzZTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dC5zY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gbGF5b3V0LnNjcmlwdHNbaV0udGFnO1xuXHQgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ0RGTFQnKSB7IHJldHVybiBuYW1lOyB9XG5cdCAgICAgICAgICAgIGlmIChuYW1lID09PSAnbGF0bicpIHsgaGFzTGF0biA9IHRydWU7IH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGhhc0xhdG4pIHsgcmV0dXJuICdsYXRuJzsgfVxuXHQgICAgfSxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIGFsbCBMYW5nU3lzUmVjb3JkcyBpbiB0aGUgZ2l2ZW4gc2NyaXB0LlxuXHQgICAgICogQGluc3RhbmNlXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhpcyBzY3JpcHQgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cblx0ICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGFnIGFuZCBzY3JpcHQgcHJvcGVydGllcy5cblx0ICAgICAqL1xuXHQgICAgZ2V0U2NyaXB0VGFibGU6IGZ1bmN0aW9uKHNjcmlwdCwgY3JlYXRlKSB7XG5cdCAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0VGFibGUoY3JlYXRlKTtcblx0ICAgICAgICBpZiAobGF5b3V0KSB7XG5cdCAgICAgICAgICAgIHNjcmlwdCA9IHNjcmlwdCB8fCAnREZMVCc7XG5cdCAgICAgICAgICAgIHZhciBzY3JpcHRzID0gbGF5b3V0LnNjcmlwdHM7XG5cdCAgICAgICAgICAgIHZhciBwb3MgPSBzZWFyY2hUYWcobGF5b3V0LnNjcmlwdHMsIHNjcmlwdCk7XG5cdCAgICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdHNbcG9zXS5zY3JpcHQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2NyID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHRhZzogc2NyaXB0LFxuXHQgICAgICAgICAgICAgICAgICAgIHNjcmlwdDoge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czoge3Jlc2VydmVkOiAwLCByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZiwgZmVhdHVyZUluZGV4ZXM6IFtdfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFtdXG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHNjcmlwdHMuc3BsaWNlKC0xIC0gcG9zLCAwLCBzY3IpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNjci5zY3JpcHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgYSBsYW5ndWFnZSBzeXN0ZW0gdGFibGVcblx0ICAgICAqIEBpbnN0YW5jZVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGxmdCddXG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhpcyBsYW5nU3lzVGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cblx0ICAgICAqIEByZXR1cm4ge09iamVjdH1cblx0ICAgICAqL1xuXHQgICAgZ2V0TGFuZ1N5c1RhYmxlOiBmdW5jdGlvbihzY3JpcHQsIGxhbmd1YWdlLCBjcmVhdGUpIHtcblx0ICAgICAgICB2YXIgc2NyaXB0VGFibGUgPSB0aGlzLmdldFNjcmlwdFRhYmxlKHNjcmlwdCwgY3JlYXRlKTtcblx0ICAgICAgICBpZiAoc2NyaXB0VGFibGUpIHtcblx0ICAgICAgICAgICAgaWYgKCFsYW5ndWFnZSB8fCBsYW5ndWFnZSA9PT0gJ2RmbHQnIHx8IGxhbmd1YWdlID09PSAnREZMVCcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRUYWJsZS5kZWZhdWx0TGFuZ1N5cztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcG9zID0gc2VhcmNoVGFnKHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzLCBsYW5ndWFnZSk7XG5cdCAgICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzW3Bvc10ubGFuZ1N5cztcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChjcmVhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBsYW5nU3lzUmVjb3JkID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHRhZzogbGFuZ3VhZ2UsXG5cdCAgICAgICAgICAgICAgICAgICAgbGFuZ1N5czoge3Jlc2VydmVkOiAwLCByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZiwgZmVhdHVyZUluZGV4ZXM6IFtdfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzLnNwbGljZSgtMSAtIHBvcywgMCwgbGFuZ1N5c1JlY29yZCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ1N5c1JlY29yZC5sYW5nU3lzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXQgYSBzcGVjaWZpYyBmZWF0dXJlIHRhYmxlLlxuXHQgICAgICogQGluc3RhbmNlXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gT25lIG9mIHRoZSBjb2RlcyBsaXN0ZWQgYXQgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9mZWF0dXJlbGlzdC5odG1cblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGUgZmVhdHVyZSB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fVxuXHQgICAgICovXG5cdCAgICBnZXRGZWF0dXJlVGFibGU6IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGNyZWF0ZSkge1xuXHQgICAgICAgIHZhciBsYW5nU3lzVGFibGUgPSB0aGlzLmdldExhbmdTeXNUYWJsZShzY3JpcHQsIGxhbmd1YWdlLCBjcmVhdGUpO1xuXHQgICAgICAgIGlmIChsYW5nU3lzVGFibGUpIHtcblx0ICAgICAgICAgICAgdmFyIGZlYXR1cmVSZWNvcmQ7XG5cdCAgICAgICAgICAgIHZhciBmZWF0SW5kZXhlcyA9IGxhbmdTeXNUYWJsZS5mZWF0dXJlSW5kZXhlcztcblx0ICAgICAgICAgICAgdmFyIGFsbEZlYXR1cmVzID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0uZmVhdHVyZXM7XG5cdCAgICAgICAgICAgIC8vIFRoZSBGZWF0dXJlSW5kZXggYXJyYXkgb2YgaW5kaWNlcyBpcyBpbiBhcmJpdHJhcnkgb3JkZXIsXG5cdCAgICAgICAgICAgIC8vIGV2ZW4gaWYgYWxsRmVhdHVyZXMgaXMgc29ydGVkIGFscGhhYmV0aWNhbGx5IGJ5IGZlYXR1cmUgdGFnLlxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBmZWF0dXJlUmVjb3JkID0gYWxsRmVhdHVyZXNbZmVhdEluZGV4ZXNbaV1dO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVSZWNvcmQudGFnID09PSBmZWF0dXJlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoY3JlYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbGxGZWF0dXJlcy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAvLyBBdXRvbWF0aWMgb3JkZXJpbmcgb2YgZmVhdHVyZXMgd291bGQgcmVxdWlyZSB0byBzaGlmdCBmZWF0dXJlIGluZGV4ZXMgaW4gdGhlIHNjcmlwdCBsaXN0LlxuXHQgICAgICAgICAgICAgICAgY2hlY2suYXNzZXJ0KGluZGV4ID09PSAwIHx8IGZlYXR1cmUgPj0gYWxsRmVhdHVyZXNbaW5kZXggLSAxXS50YWcsICdGZWF0dXJlcyBtdXN0IGJlIGFkZGVkIGluIGFscGhhYmV0aWNhbCBvcmRlci4nKTtcblx0ICAgICAgICAgICAgICAgIGZlYXR1cmVSZWNvcmQgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGFnOiBmZWF0dXJlLFxuXHQgICAgICAgICAgICAgICAgICAgIGZlYXR1cmU6IHsgcGFyYW1zOiAwLCBsb29rdXBMaXN0SW5kZXhlczogW10gfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzLnB1c2goZmVhdHVyZVJlY29yZCk7XG5cdCAgICAgICAgICAgICAgICBmZWF0SW5kZXhlcy5wdXNoKGluZGV4KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlUmVjb3JkLmZlYXR1cmU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIEdldCB0aGUgbG9va3VwIHRhYmxlcyBvZiBhIGdpdmVuIHR5cGUgZm9yIGEgc2NyaXB0L2xhbmd1YWdlL2ZlYXR1cmUuXG5cdCAgICAgKiBAaW5zdGFuY2Vcblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cblx0ICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIGNvZGVcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb29rdXBUeXBlIC0gMSB0byA5XG5cdCAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhlIGxvb2t1cCB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LCB3aXRoIG5vIHN1YnRhYmxlcy5cblx0ICAgICAqIEByZXR1cm4ge09iamVjdFtdfVxuXHQgICAgICovXG5cdCAgICBnZXRMb29rdXBUYWJsZXM6IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGxvb2t1cFR5cGUsIGNyZWF0ZSkge1xuXHQgICAgICAgIHZhciBmZWF0dXJlVGFibGUgPSB0aGlzLmdldEZlYXR1cmVUYWJsZShzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCBjcmVhdGUpO1xuXHQgICAgICAgIHZhciB0YWJsZXMgPSBbXTtcblx0ICAgICAgICBpZiAoZmVhdHVyZVRhYmxlKSB7XG5cdCAgICAgICAgICAgIHZhciBsb29rdXBUYWJsZTtcblx0ICAgICAgICAgICAgdmFyIGxvb2t1cExpc3RJbmRleGVzID0gZmVhdHVyZVRhYmxlLmxvb2t1cExpc3RJbmRleGVzO1xuXHQgICAgICAgICAgICB2YXIgYWxsTG9va3VwcyA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdLmxvb2t1cHM7XG5cdCAgICAgICAgICAgIC8vIGxvb2t1cExpc3RJbmRleGVzIGFyZSBpbiBubyBwYXJ0aWN1bGFyIG9yZGVyLCBzbyB1c2UgbmFpdmUgc2VhcmNoLlxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvb2t1cExpc3RJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBsb29rdXBUYWJsZSA9IGFsbExvb2t1cHNbbG9va3VwTGlzdEluZGV4ZXNbaV1dO1xuXHQgICAgICAgICAgICAgICAgaWYgKGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUgPT09IGxvb2t1cFR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0YWJsZXMucHVzaChsb29rdXBUYWJsZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRhYmxlcy5sZW5ndGggPT09IDAgJiYgY3JlYXRlKSB7XG5cdCAgICAgICAgICAgICAgICBsb29rdXBUYWJsZSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuXHQgICAgICAgICAgICAgICAgICAgIGxvb2t1cEZsYWc6IDAsXG5cdCAgICAgICAgICAgICAgICAgICAgc3VidGFibGVzOiBbXSxcblx0ICAgICAgICAgICAgICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1bmRlZmluZWRcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbGxMb29rdXBzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIGFsbExvb2t1cHMucHVzaChsb29rdXBUYWJsZSk7XG5cdCAgICAgICAgICAgICAgICBsb29rdXBMaXN0SW5kZXhlcy5wdXNoKGluZGV4KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbbG9va3VwVGFibGVdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0YWJsZXM7XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIEZpbmQgYSBnbHlwaCBpbiBhIGNsYXNzIGRlZmluaXRpb24gdGFibGVcblx0ICAgICAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9jaGFwdGVyMiNjbGFzcy1kZWZpbml0aW9uLXRhYmxlXG5cdCAgICAgKiBAcGFyYW0ge29iamVjdH0gY2xhc3NEZWZUYWJsZSAtIGFuIE9wZW5UeXBlIExheW91dCBjbGFzcyBkZWZpbml0aW9uIHRhYmxlXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgZ2x5cGggdG8gZmluZFxuXHQgICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgbm90IGZvdW5kXG5cdCAgICAgKi9cblx0ICAgIGdldEdseXBoQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzRGVmVGFibGUsIGdseXBoSW5kZXgpIHtcblx0ICAgICAgICBzd2l0Y2ggKGNsYXNzRGVmVGFibGUuZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgIGlmIChjbGFzc0RlZlRhYmxlLnN0YXJ0R2x5cGggPD0gZ2x5cGhJbmRleCAmJiBnbHlwaEluZGV4IDwgY2xhc3NEZWZUYWJsZS5zdGFydEdseXBoICsgY2xhc3NEZWZUYWJsZS5jbGFzc2VzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc0RlZlRhYmxlLmNsYXNzZXNbZ2x5cGhJbmRleCAtIGNsYXNzRGVmVGFibGUuc3RhcnRHbHlwaF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VhcmNoUmFuZ2UoY2xhc3NEZWZUYWJsZS5yYW5nZXMsIGdseXBoSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlID8gcmFuZ2UuY2xhc3NJZCA6IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSxcblxuXHQgICAgLyoqXG5cdCAgICAgKiBGaW5kIGEgZ2x5cGggaW4gYSBjb3ZlcmFnZSB0YWJsZVxuXHQgICAgICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2NoYXB0ZXIyI2NvdmVyYWdlLXRhYmxlXG5cdCAgICAgKiBAcGFyYW0ge29iamVjdH0gY292ZXJhZ2VUYWJsZSAtIGFuIE9wZW5UeXBlIExheW91dCBjb3ZlcmFnZSB0YWJsZVxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IGdseXBoSW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGdseXBoIHRvIGZpbmRcblx0ICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0xIGlmIG5vdCBmb3VuZFxuXHQgICAgICovXG5cdCAgICBnZXRDb3ZlcmFnZUluZGV4OiBmdW5jdGlvbihjb3ZlcmFnZVRhYmxlLCBnbHlwaEluZGV4KSB7XG5cdCAgICAgICAgc3dpdGNoIChjb3ZlcmFnZVRhYmxlLmZvcm1hdCkge1xuXHQgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBiaW5TZWFyY2goY292ZXJhZ2VUYWJsZS5nbHlwaHMsIGdseXBoSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IC0xO1xuXHQgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWFyY2hSYW5nZShjb3ZlcmFnZVRhYmxlLnJhbmdlcywgZ2x5cGhJbmRleCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UgPyByYW5nZS5pbmRleCArIGdseXBoSW5kZXggLSByYW5nZS5zdGFydCA6IC0xO1xuXHQgICAgICAgIH1cblx0ICAgIH0sXG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBnbHlwaCBpbmRleGVzIG9mIGEgY292ZXJhZ2UgdGFibGUuXG5cdCAgICAgKiBGb3JtYXQgMTogdGhlIGxpc3QgaXMgc3RvcmVkIHJhd1xuXHQgICAgICogRm9ybWF0IDI6IGNvbXBhY3QgbGlzdCBhcyByYW5nZSByZWNvcmRzLlxuXHQgICAgICogQGluc3RhbmNlXG5cdCAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvdmVyYWdlVGFibGVcblx0ICAgICAqIEByZXR1cm4ge0FycmF5fVxuXHQgICAgICovXG5cdCAgICBleHBhbmRDb3ZlcmFnZTogZnVuY3Rpb24oY292ZXJhZ2VUYWJsZSkge1xuXHQgICAgICAgIGlmIChjb3ZlcmFnZVRhYmxlLmZvcm1hdCA9PT0gMSkge1xuXHQgICAgICAgICAgICByZXR1cm4gY292ZXJhZ2VUYWJsZS5nbHlwaHM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGdseXBocyA9IFtdO1xuXHQgICAgICAgICAgICB2YXIgcmFuZ2VzID0gY292ZXJhZ2VUYWJsZS5yYW5nZXM7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcblx0ICAgICAgICAgICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPD0gZW5kOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBnbHlwaHMucHVzaChqKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZ2x5cGhzO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHR9O1xuXG5cdC8vIFRoZSBQb3NpdGlvbiBvYmplY3QgcHJvdmlkZXMgdXRpbGl0eSBtZXRob2RzIHRvIG1hbmlwdWxhdGVcblxuXHQvKipcblx0ICogQGV4cG9ydHMgb3BlbnR5cGUuUG9zaXRpb25cblx0ICogQGNsYXNzXG5cdCAqIEBleHRlbmRzIG9wZW50eXBlLkxheW91dFxuXHQgKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gUG9zaXRpb24oZm9udCkge1xuXHQgICAgTGF5b3V0LmNhbGwodGhpcywgZm9udCwgJ2dwb3MnKTtcblx0fVxuXG5cdFBvc2l0aW9uLnByb3RvdHlwZSA9IExheW91dC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIEluaXQgc29tZSBkYXRhIGZvciBmYXN0ZXIgYW5kIGVhc2llciBhY2Nlc3MgbGF0ZXIuXG5cdCAqL1xuXHRQb3NpdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHNjcmlwdCA9IHRoaXMuZ2V0RGVmYXVsdFNjcmlwdE5hbWUoKTtcblx0ICAgIHRoaXMuZGVmYXVsdEtlcm5pbmdUYWJsZXMgPSB0aGlzLmdldEtlcm5pbmdUYWJsZXMoc2NyaXB0KTtcblx0fTtcblxuXHQvKipcblx0ICogRmluZCBhIGdseXBoIHBhaXIgaW4gYSBsaXN0IG9mIGxvb2t1cCB0YWJsZXMgb2YgdHlwZSAyIGFuZCByZXRyaWV2ZSB0aGUgeEFkdmFuY2Uga2VybmluZyB2YWx1ZS5cblx0ICpcblx0ICogQHBhcmFtIHtpbnRlZ2VyfSBsZWZ0SW5kZXggLSBsZWZ0IGdseXBoIGluZGV4XG5cdCAqIEBwYXJhbSB7aW50ZWdlcn0gcmlnaHRJbmRleCAtIHJpZ2h0IGdseXBoIGluZGV4XG5cdCAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuXHQgKi9cblx0UG9zaXRpb24ucHJvdG90eXBlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uKGtlcm5pbmdMb29rdXBzLCBsZWZ0SW5kZXgsIHJpZ2h0SW5kZXgpIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtlcm5pbmdMb29rdXBzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHN1YnRhYmxlcyA9IGtlcm5pbmdMb29rdXBzW2ldLnN1YnRhYmxlcztcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1YnRhYmxlcy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbal07XG5cdCAgICAgICAgICAgIHZhciBjb3ZJbmRleCA9IHRoaXMkMS5nZXRDb3ZlcmFnZUluZGV4KHN1YnRhYmxlLmNvdmVyYWdlLCBsZWZ0SW5kZXgpO1xuXHQgICAgICAgICAgICBpZiAoY292SW5kZXggPCAwKSB7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgIHN3aXRjaCAoc3VidGFibGUucG9zRm9ybWF0KSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIFBhaXIgQWRqdXN0bWVudCBQb3NpdGlvbmluZyBGb3JtYXQgMVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYWlyU2V0ID0gc3VidGFibGUucGFpclNldHNbY292SW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcGFpclNldC5sZW5ndGg7IGsrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJTZXRba107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWlyLnNlY29uZEdseXBoID09PSByaWdodEluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpci52YWx1ZTEgJiYgcGFpci52YWx1ZTEueEFkdmFuY2UgfHwgMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgICAvLyBsZWZ0IGdseXBoIGZvdW5kLCBub3QgcmlnaHQgZ2x5cGggLSB0cnkgbmV4dCBzdWJ0YWJsZVxuXHQgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBQYWlyIEFkanVzdG1lbnQgUG9zaXRpb25pbmcgRm9ybWF0IDJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3MxID0gdGhpcyQxLmdldEdseXBoQ2xhc3Moc3VidGFibGUuY2xhc3NEZWYxLCBsZWZ0SW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjbGFzczIgPSB0aGlzJDEuZ2V0R2x5cGhDbGFzcyhzdWJ0YWJsZS5jbGFzc0RlZjIsIHJpZ2h0SW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYWlyJDEgPSBzdWJ0YWJsZS5jbGFzc1JlY29yZHNbY2xhc3MxXVtjbGFzczJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyJDEudmFsdWUxICYmIHBhaXIkMS52YWx1ZTEueEFkdmFuY2UgfHwgMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBMaXN0IGFsbCBrZXJuaW5nIGxvb2t1cCB0YWJsZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ10gLSB1c2UgZm9udC5wb3NpdGlvbi5nZXREZWZhdWx0U2NyaXB0TmFtZSgpIGZvciBhIGJldHRlciBkZWZhdWx0IHZhbHVlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX0gVGhlIGxpc3Qgb2Yga2VybmluZyBsb29rdXAgdGFibGVzIChtYXkgYmUgZW1wdHkpLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gR1BPUyB0YWJsZSAoYW5kIHdlIHNob3VsZCB1c2UgdGhlIGtlcm4gdGFibGUpXG5cdCAqL1xuXHRQb3NpdGlvbi5wcm90b3R5cGUuZ2V0S2VybmluZ1RhYmxlcyA9IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UpIHtcblx0ICAgIGlmICh0aGlzLmZvbnQudGFibGVzLmdwb3MpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgJ2tlcm4nLCAyKTtcblx0ICAgIH1cblx0fTtcblxuXHQvLyBUaGUgU3Vic3RpdHV0aW9uIG9iamVjdCBwcm92aWRlcyB1dGlsaXR5IG1ldGhvZHMgdG8gbWFuaXB1bGF0ZVxuXG5cdC8qKlxuXHQgKiBAZXhwb3J0cyBvcGVudHlwZS5TdWJzdGl0dXRpb25cblx0ICogQGNsYXNzXG5cdCAqIEBleHRlbmRzIG9wZW50eXBlLkxheW91dFxuXHQgKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gU3Vic3RpdHV0aW9uKGZvbnQpIHtcblx0ICAgIExheW91dC5jYWxsKHRoaXMsIGZvbnQsICdnc3ViJyk7XG5cdH1cblxuXHQvLyBDaGVjayBpZiAyIGFycmF5cyBvZiBwcmltaXRpdmVzIGFyZSBlcXVhbC5cblx0ZnVuY3Rpb24gYXJyYXlzRXF1YWwoYXIxLCBhcjIpIHtcblx0ICAgIHZhciBuID0gYXIxLmxlbmd0aDtcblx0ICAgIGlmIChuICE9PSBhcjIubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICBpZiAoYXIxW2ldICE9PSBhcjJbaV0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEZpbmQgdGhlIGZpcnN0IHN1YnRhYmxlIG9mIGEgbG9va3VwIHRhYmxlIGluIGEgcGFydGljdWxhciBmb3JtYXQuXG5cdGZ1bmN0aW9uIGdldFN1YnN0Rm9ybWF0KGxvb2t1cFRhYmxlLCBmb3JtYXQsIGRlZmF1bHRTdWJ0YWJsZSkge1xuXHQgICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlcztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuXHQgICAgICAgIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzdWJ0YWJsZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoZGVmYXVsdFN1YnRhYmxlKSB7XG5cdCAgICAgICAgc3VidGFibGVzLnB1c2goZGVmYXVsdFN1YnRhYmxlKTtcblx0ICAgICAgICByZXR1cm4gZGVmYXVsdFN1YnRhYmxlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUgPSBMYXlvdXQucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBkZWZhdWx0IEdTVUIgdGFibGUuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gZ3N1YiAtIFRoZSBHU1VCIHRhYmxlLlxuXHQgKi9cblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5jcmVhdGVEZWZhdWx0VGFibGUgPSBmdW5jdGlvbigpIHtcblx0ICAgIC8vIEdlbmVyYXRlIGEgZGVmYXVsdCBlbXB0eSBHU1VCIHRhYmxlIHdpdGgganVzdCBhIERGTFQgc2NyaXB0IGFuZCBkZmx0IGxhbmcgc3lzLlxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgICB2ZXJzaW9uOiAxLFxuXHQgICAgICAgIHNjcmlwdHM6IFt7XG5cdCAgICAgICAgICAgIHRhZzogJ0RGTFQnLFxuXHQgICAgICAgICAgICBzY3JpcHQ6IHtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHRMYW5nU3lzOiB7IHJlc2VydmVkOiAwLCByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZiwgZmVhdHVyZUluZGV4ZXM6IFtdIH0sXG5cdCAgICAgICAgICAgICAgICBsYW5nU3lzUmVjb3JkczogW11cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1dLFxuXHQgICAgICAgIGZlYXR1cmVzOiBbXSxcblx0ICAgICAgICBsb29rdXBzOiBbXVxuXHQgICAgfTtcblx0fTtcblxuXHQvKipcblx0ICogTGlzdCBhbGwgc2luZ2xlIHN1YnN0aXR1dGlvbnMgKGxvb2t1cCB0eXBlIDEpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2FhbHQnLCAnc2FsdCcsICdzczAxJy4uLilcblx0ICogQHJldHVybiB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgLSBUaGUgbGlzdCBvZiBzdWJzdGl0dXRpb25zLlxuXHQgKi9cblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRTaW5nbGUgPSBmdW5jdGlvbihmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG5cdCAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgdmFyIHN1YnN0aXR1dGlvbnMgPSBbXTtcblx0ICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAxKTtcblx0ICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlc1tpZHhdLnN1YnRhYmxlcztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG5cdCAgICAgICAgICAgIHZhciBnbHlwaHMgPSB0aGlzJDEuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuXHQgICAgICAgICAgICB2YXIgaiA9ICh2b2lkIDApO1xuXHQgICAgICAgICAgICBpZiAoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IHN1YnRhYmxlLmRlbHRhR2x5cGhJZDtcblx0ICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbal07XG5cdCAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsgc3ViOiBnbHlwaCwgYnk6IGdseXBoICsgZGVsdGEgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3Vic3RpdHV0ZSA9IHN1YnRhYmxlLnN1YnN0aXR1dGU7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsgc3ViOiBnbHlwaHNbal0sIGJ5OiBzdWJzdGl0dXRlW2pdIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7XG5cdH07XG5cblx0LyoqXG5cdCAqIExpc3QgYWxsIGFsdGVybmF0ZXMgKGxvb2t1cCB0eXBlIDMpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2FhbHQnLCAnc2FsdCcuLi4pXG5cdCAqIEByZXR1cm4ge0FycmF5fSBhbHRlcm5hdGVzIC0gVGhlIGxpc3Qgb2YgYWx0ZXJuYXRlc1xuXHQgKi9cblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRBbHRlcm5hdGVzID0gZnVuY3Rpb24oZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIHZhciBhbHRlcm5hdGVzID0gW107XG5cdCAgICB2YXIgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMyk7XG5cdCAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuXHQgICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcyQxLmV4cGFuZENvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKTtcblx0ICAgICAgICAgICAgdmFyIGFsdGVybmF0ZVNldHMgPSBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgYWx0ZXJuYXRlcy5wdXNoKHsgc3ViOiBnbHlwaHNbal0sIGJ5OiBhbHRlcm5hdGVTZXRzW2pdIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGFsdGVybmF0ZXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIExpc3QgYWxsIGxpZ2F0dXJlcyAobG9va3VwIHR5cGUgNCkgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG5cdCAqIFRoZSByZXN1bHQgaXMgYW4gYXJyYXkgb2YgbGlnYXR1cmUgb2JqZWN0cyBsaWtlIHsgc3ViOiBbaWRzXSwgYnk6IGlkIH1cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG5cdCAqIEByZXR1cm4ge0FycmF5fSBsaWdhdHVyZXMgLSBUaGUgbGlzdCBvZiBsaWdhdHVyZXMuXG5cdCAqL1xuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldExpZ2F0dXJlcyA9IGZ1bmN0aW9uKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICB2YXIgbGlnYXR1cmVzID0gW107XG5cdCAgICB2YXIgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgNCk7XG5cdCAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuXHQgICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcyQxLmV4cGFuZENvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKTtcblx0ICAgICAgICAgICAgdmFyIGxpZ2F0dXJlU2V0cyA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0cztcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdGFydEdseXBoID0gZ2x5cGhzW2pdO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxpZ1NldCA9IGxpZ2F0dXJlU2V0c1tqXTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGlnU2V0Lmxlbmd0aDsgaysrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxpZyA9IGxpZ1NldFtrXTtcblx0ICAgICAgICAgICAgICAgICAgICBsaWdhdHVyZXMucHVzaCh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YjogW3N0YXJ0R2x5cGhdLmNvbmNhdChsaWcuY29tcG9uZW50cyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJ5OiBsaWcubGlnR2x5cGhcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBsaWdhdHVyZXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBvciBtb2RpZnkgYSBzaW5nbGUgc3Vic3RpdHV0aW9uIChsb29rdXAgdHlwZSAxKVxuXHQgKiBGb3JtYXQgMiwgbW9yZSBmbGV4aWJsZSwgaXMgYWx3YXlzIHVzZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3Vic3RpdHV0aW9uIC0geyBzdWI6IGlkLCBkZWx0YTogbnVtYmVyIH0gZm9yIGZvcm1hdCAxIG9yIHsgc3ViOiBpZCwgYnk6IGlkIH0gZm9yIGZvcm1hdCAyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuXHQgKi9cblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRTaW5nbGUgPSBmdW5jdGlvbihmZWF0dXJlLCBzdWJzdGl0dXRpb24sIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcblx0ICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDEsIHRydWUpWzBdO1xuXHQgICAgdmFyIHN1YnRhYmxlID0gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIDIsIHsgICAgICAgICAgICAgICAgLy8gbG9va3VwIHR5cGUgMSBzdWJ0YWJsZSwgZm9ybWF0IDIsIGNvdmVyYWdlIGZvcm1hdCAxXG5cdCAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG5cdCAgICAgICAgY292ZXJhZ2U6IHtmb3JtYXQ6IDEsIGdseXBoczogW119LFxuXHQgICAgICAgIHN1YnN0aXR1dGU6IFtdXG5cdCAgICB9KTtcblx0ICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsICdMaWdhdHVyZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCk7XG5cdCAgICB2YXIgY292ZXJhZ2VHbHlwaCA9IHN1YnN0aXR1dGlvbi5zdWI7XG5cdCAgICB2YXIgcG9zID0gdGhpcy5iaW5TZWFyY2goc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLCBjb3ZlcmFnZUdseXBoKTtcblx0ICAgIGlmIChwb3MgPCAwKSB7XG5cdCAgICAgICAgcG9zID0gLTEgLSBwb3M7XG5cdCAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLnNwbGljZShwb3MsIDAsIGNvdmVyYWdlR2x5cGgpO1xuXHQgICAgICAgIHN1YnRhYmxlLnN1YnN0aXR1dGUuc3BsaWNlKHBvcywgMCwgMCk7XG5cdCAgICB9XG5cdCAgICBzdWJ0YWJsZS5zdWJzdGl0dXRlW3Bvc10gPSBzdWJzdGl0dXRpb24uYnk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBvciBtb2RpZnkgYW4gYWx0ZXJuYXRlIHN1YnN0aXR1dGlvbiAobG9va3VwIHR5cGUgMSlcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzdGl0dXRpb24gLSB7IHN1YjogaWQsIGJ5OiBbaWRzXSB9XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG5cdCAqL1xuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZEFsdGVybmF0ZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHN1YnN0aXR1dGlvbiwgc2NyaXB0LCBsYW5ndWFnZSkge1xuXHQgICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMywgdHJ1ZSlbMF07XG5cdCAgICB2YXIgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMSwgeyAgICAgICAgICAgICAgICAvLyBsb29rdXAgdHlwZSAzIHN1YnRhYmxlLCBmb3JtYXQgMSwgY292ZXJhZ2UgZm9ybWF0IDFcblx0ICAgICAgICBzdWJzdEZvcm1hdDogMSxcblx0ICAgICAgICBjb3ZlcmFnZToge2Zvcm1hdDogMSwgZ2x5cGhzOiBbXX0sXG5cdCAgICAgICAgYWx0ZXJuYXRlU2V0czogW11cblx0ICAgIH0pO1xuXHQgICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSwgJ0xpZ2F0dXJlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICsgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0KTtcblx0ICAgIHZhciBjb3ZlcmFnZUdseXBoID0gc3Vic3RpdHV0aW9uLnN1Yjtcblx0ICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuXHQgICAgaWYgKHBvcyA8IDApIHtcblx0ICAgICAgICBwb3MgPSAtMSAtIHBvcztcblx0ICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG5cdCAgICAgICAgc3VidGFibGUuYWx0ZXJuYXRlU2V0cy5zcGxpY2UocG9zLCAwLCAwKTtcblx0ICAgIH1cblx0ICAgIHN1YnRhYmxlLmFsdGVybmF0ZVNldHNbcG9zXSA9IHN1YnN0aXR1dGlvbi5ieTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgbGlnYXR1cmUgKGxvb2t1cCB0eXBlIDQpXG5cdCAqIExpZ2F0dXJlcyB3aXRoIG1vcmUgY29tcG9uZW50cyBtdXN0IGJlIHN0b3JlZCBhaGVhZCBvZiB0aG9zZSB3aXRoIGZld2VyIGNvbXBvbmVudHMgaW4gb3JkZXIgdG8gYmUgZm91bmRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsaWdhdHVyZSAtIHsgc3ViOiBbaWRzXSwgYnk6IGlkIH1cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cblx0ICovXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkTGlnYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlLCBsaWdhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuXHQgICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgNCwgdHJ1ZSlbMF07XG5cdCAgICB2YXIgc3VidGFibGUgPSBsb29rdXBUYWJsZS5zdWJ0YWJsZXNbMF07XG5cdCAgICBpZiAoIXN1YnRhYmxlKSB7XG5cdCAgICAgICAgc3VidGFibGUgPSB7ICAgICAgICAgICAgICAgIC8vIGxvb2t1cCB0eXBlIDQgc3VidGFibGUsIGZvcm1hdCAxLCBjb3ZlcmFnZSBmb3JtYXQgMVxuXHQgICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcblx0ICAgICAgICAgICAgY292ZXJhZ2U6IHsgZm9ybWF0OiAxLCBnbHlwaHM6IFtdIH0sXG5cdCAgICAgICAgICAgIGxpZ2F0dXJlU2V0czogW11cblx0ICAgICAgICB9O1xuXHQgICAgICAgIGxvb2t1cFRhYmxlLnN1YnRhYmxlc1swXSA9IHN1YnRhYmxlO1xuXHQgICAgfVxuXHQgICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSwgJ0xpZ2F0dXJlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICsgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0KTtcblx0ICAgIHZhciBjb3ZlcmFnZUdseXBoID0gbGlnYXR1cmUuc3ViWzBdO1xuXHQgICAgdmFyIGxpZ0NvbXBvbmVudHMgPSBsaWdhdHVyZS5zdWIuc2xpY2UoMSk7XG5cdCAgICB2YXIgbGlnYXR1cmVUYWJsZSA9IHtcblx0ICAgICAgICBsaWdHbHlwaDogbGlnYXR1cmUuYnksXG5cdCAgICAgICAgY29tcG9uZW50czogbGlnQ29tcG9uZW50c1xuXHQgICAgfTtcblx0ICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuXHQgICAgaWYgKHBvcyA+PSAwKSB7XG5cdCAgICAgICAgLy8gbGlnYXR1cmVTZXQgYWxyZWFkeSBleGlzdHNcblx0ICAgICAgICB2YXIgbGlnYXR1cmVTZXQgPSBzdWJ0YWJsZS5saWdhdHVyZVNldHNbcG9zXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpZ2F0dXJlU2V0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vIElmIGxpZ2F0dXJlIGFscmVhZHkgZXhpc3RzLCByZXR1cm4uXG5cdCAgICAgICAgICAgIGlmIChhcnJheXNFcXVhbChsaWdhdHVyZVNldFtpXS5jb21wb25lbnRzLCBsaWdDb21wb25lbnRzKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGxpZ2F0dXJlIGRvZXMgbm90IGV4aXN0OiBhZGQgaXQuXG5cdCAgICAgICAgbGlnYXR1cmVTZXQucHVzaChsaWdhdHVyZVRhYmxlKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxpZ2F0dXJlU2V0IGFuZCBhZGQgY292ZXJhZ2UgZm9yIHRoZSBmaXJzdCBnbHlwaC5cblx0ICAgICAgICBwb3MgPSAtMSAtIHBvcztcblx0ICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG5cdCAgICAgICAgc3VidGFibGUubGlnYXR1cmVTZXRzLnNwbGljZShwb3MsIDAsIFtsaWdhdHVyZVRhYmxlXSk7XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIExpc3QgYWxsIGZlYXR1cmUgZGF0YSBmb3IgYSBnaXZlbiBzY3JpcHQgYW5kIGxhbmd1YWdlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuXHQgKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG5cdCAqL1xuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldEZlYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG5cdCAgICBpZiAoL3NzXFxkXFxkLy50ZXN0KGZlYXR1cmUpKSB7XG5cdCAgICAgICAgLy8gc3MwMSAtIHNzMjBcblx0ICAgICAgICByZXR1cm4gdGhpcy5nZXRTaW5nbGUoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSk7XG5cdCAgICB9XG5cdCAgICBzd2l0Y2ggKGZlYXR1cmUpIHtcblx0ICAgICAgICBjYXNlICdhYWx0Jzpcblx0ICAgICAgICBjYXNlICdzYWx0Jzpcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2luZ2xlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpXG5cdCAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLmdldEFsdGVybmF0ZXMoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkpO1xuXHQgICAgICAgIGNhc2UgJ2RsaWcnOlxuXHQgICAgICAgIGNhc2UgJ2xpZ2EnOlxuXHQgICAgICAgIGNhc2UgJ3JsaWcnOiByZXR1cm4gdGhpcy5nZXRMaWdhdHVyZXMoZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBzdWJzdGl0dXRpb24gdG8gYSBmZWF0dXJlIGZvciBhIGdpdmVuIHNjcmlwdCBhbmQgbGFuZ3VhZ2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdWIgLSB0aGUgc3Vic3RpdHV0aW9uIHRvIGFkZCAoYW4gb2JqZWN0IGxpa2UgeyBzdWI6IGlkIG9yIFtpZHNdLCBieTogaWQgb3IgW2lkc10gfSlcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cblx0ICovXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG5cdCAgICBpZiAoL3NzXFxkXFxkLy50ZXN0KGZlYXR1cmUpKSB7XG5cdCAgICAgICAgLy8gc3MwMSAtIHNzMjBcblx0ICAgICAgICByZXR1cm4gdGhpcy5hZGRTaW5nbGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcblx0ICAgIH1cblx0ICAgIHN3aXRjaCAoZmVhdHVyZSkge1xuXHQgICAgICAgIGNhc2UgJ2FhbHQnOlxuXHQgICAgICAgIGNhc2UgJ3NhbHQnOlxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHN1Yi5ieSA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFNpbmdsZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEFsdGVybmF0ZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuXHQgICAgICAgIGNhc2UgJ2RsaWcnOlxuXHQgICAgICAgIGNhc2UgJ2xpZ2EnOlxuXHQgICAgICAgIGNhc2UgJ3JsaWcnOlxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRMaWdhdHVyZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0fTtcblxuXHRmdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG5cdCAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cdH1cblxuXHRmdW5jdGlvbiBub2RlQnVmZmVyVG9BcnJheUJ1ZmZlcihidWZmZXIpIHtcblx0ICAgIHZhciBhYiA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIubGVuZ3RoKTtcblx0ICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICB2aWV3W2ldID0gYnVmZmVyW2ldO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gYWI7XG5cdH1cblxuXHRmdW5jdGlvbiBhcnJheUJ1ZmZlclRvTm9kZUJ1ZmZlcihhYikge1xuXHQgICAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYWIuYnl0ZUxlbmd0aCk7XG5cdCAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgYnVmZmVyW2ldID0gdmlld1tpXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGJ1ZmZlcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrQXJndW1lbnQoZXhwcmVzc2lvbiwgbWVzc2FnZSkge1xuXHQgICAgaWYgKCFleHByZXNzaW9uKSB7XG5cdCAgICAgICAgdGhyb3cgbWVzc2FnZTtcblx0ICAgIH1cblx0fVxuXG5cdC8vIFRoZSBgZ2x5ZmAgdGFibGUgZGVzY3JpYmVzIHRoZSBnbHlwaHMgaW4gVHJ1ZVR5cGUgb3V0bGluZSBmb3JtYXQuXG5cblx0Ly8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgZGF0YSBmb3IgYSBnbHlwaC5cblx0ZnVuY3Rpb24gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHJldmlvdXNWYWx1ZSwgc2hvcnRWZWN0b3JCaXRNYXNrLCBzYW1lQml0TWFzaykge1xuXHQgICAgdmFyIHY7XG5cdCAgICBpZiAoKGZsYWcgJiBzaG9ydFZlY3RvckJpdE1hc2spID4gMCkge1xuXHQgICAgICAgIC8vIFRoZSBjb29yZGluYXRlIGlzIDEgYnl0ZSBsb25nLlxuXHQgICAgICAgIHYgPSBwLnBhcnNlQnl0ZSgpO1xuXHQgICAgICAgIC8vIFRoZSBgc2FtZWAgYml0IGlzIHJlLXVzZWQgZm9yIHNob3J0IHZhbHVlcyB0byBzaWduaWZ5IHRoZSBzaWduIG9mIHRoZSB2YWx1ZS5cblx0ICAgICAgICBpZiAoKGZsYWcgJiBzYW1lQml0TWFzaykgPT09IDApIHtcblx0ICAgICAgICAgICAgdiA9IC12O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlICsgdjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gIFRoZSBjb29yZGluYXRlIGlzIDIgYnl0ZXMgbG9uZy5cblx0ICAgICAgICAvLyBJZiB0aGUgYHNhbWVgIGJpdCBpcyBzZXQsIHRoZSBjb29yZGluYXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyBjb29yZGluYXRlLlxuXHQgICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA+IDApIHtcblx0ICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWU7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgYXMgYSBzaWduZWQgMTYtYml0IGRlbHRhIHZhbHVlLlxuXHQgICAgICAgICAgICB2ID0gcHJldmlvdXNWYWx1ZSArIHAucGFyc2VTaG9ydCgpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHY7XG5cdH1cblxuXHQvLyBQYXJzZSBhIFRydWVUeXBlIGdseXBoLlxuXHRmdW5jdGlvbiBwYXJzZUdseXBoKGdseXBoLCBkYXRhLCBzdGFydCkge1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIGdseXBoLm51bWJlck9mQ29udG91cnMgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGdseXBoLl94TWluID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICBnbHlwaC5feU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgZ2x5cGguX3hNYXggPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgIGdseXBoLl95TWF4ID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICB2YXIgZmxhZ3M7XG5cdCAgICB2YXIgZmxhZztcblxuXHQgICAgaWYgKGdseXBoLm51bWJlck9mQ29udG91cnMgPiAwKSB7XG5cdCAgICAgICAgLy8gVGhpcyBnbHlwaCBpcyBub3QgYSBjb21wb3NpdGUuXG5cdCAgICAgICAgdmFyIGVuZFBvaW50SW5kaWNlcyA9IGdseXBoLmVuZFBvaW50SW5kaWNlcyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGgubnVtYmVyT2ZDb250b3VyczsgaSArPSAxKSB7XG5cdCAgICAgICAgICAgIGVuZFBvaW50SW5kaWNlcy5wdXNoKHAucGFyc2VVU2hvcnQoKSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGg7IGkkMSArPSAxKSB7XG5cdCAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucy5wdXNoKHAucGFyc2VCeXRlKCkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBudW1iZXJPZkNvb3JkaW5hdGVzID0gZW5kUG9pbnRJbmRpY2VzW2VuZFBvaW50SW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XG5cdCAgICAgICAgZmxhZ3MgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDIgKz0gMSkge1xuXHQgICAgICAgICAgICBmbGFnID0gcC5wYXJzZUJ5dGUoKTtcblx0ICAgICAgICAgICAgZmxhZ3MucHVzaChmbGFnKTtcblx0ICAgICAgICAgICAgLy8gSWYgYml0IDMgaXMgc2V0LCB3ZSByZXBlYXQgdGhpcyBmbGFnIG4gdGltZXMsIHdoZXJlIG4gaXMgdGhlIG5leHQgYnl0ZS5cblx0ICAgICAgICAgICAgaWYgKChmbGFnICYgOCkgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVwZWF0Q291bnQgPSBwLnBhcnNlQnl0ZSgpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBlYXRDb3VudDsgaiArPSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZmxhZ3MucHVzaChmbGFnKTtcblx0ICAgICAgICAgICAgICAgICAgICBpJDIgKz0gMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGNoZWNrLmFyZ3VtZW50KGZsYWdzLmxlbmd0aCA9PT0gbnVtYmVyT2ZDb29yZGluYXRlcywgJ0JhZCBmbGFncy4nKTtcblxuXHQgICAgICAgIGlmIChlbmRQb2ludEluZGljZXMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG5cdCAgICAgICAgICAgIHZhciBwb2ludDtcblx0ICAgICAgICAgICAgLy8gWC9ZIGNvb3JkaW5hdGVzIGFyZSByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgcG9pbnQsIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IHBvaW50IHdoaWNoIGlzIHJlbGF0aXZlIHRvIDAsMC5cblx0ICAgICAgICAgICAgaWYgKG51bWJlck9mQ29vcmRpbmF0ZXMgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDMgKz0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpJDNdO1xuXHQgICAgICAgICAgICAgICAgICAgIHBvaW50ID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgcG9pbnQub25DdXJ2ZSA9ICEhKGZsYWcgJiAxKTtcblx0ICAgICAgICAgICAgICAgICAgICBwb2ludC5sYXN0UG9pbnRPZkNvbnRvdXIgPSBlbmRQb2ludEluZGljZXMuaW5kZXhPZihpJDMpID49IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgcHggPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQ0ICs9IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaSQ0XTtcblx0ICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpJDRdO1xuXHQgICAgICAgICAgICAgICAgICAgIHBvaW50LnggPSBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBweCwgMiwgMTYpO1xuXHQgICAgICAgICAgICAgICAgICAgIHB4ID0gcG9pbnQueDtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIHB5ID0gMDtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkkNSA9IDA7IGkkNSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkkNSArPSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2kkNV07XG5cdCAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaSQ1XTtcblx0ICAgICAgICAgICAgICAgICAgICBwb2ludC55ID0gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHksIDQsIDMyKTtcblx0ICAgICAgICAgICAgICAgICAgICBweSA9IHBvaW50Lnk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBwb2ludHM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChnbHlwaC5udW1iZXJPZkNvbnRvdXJzID09PSAwKSB7XG5cdCAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGdseXBoLmlzQ29tcG9zaXRlID0gdHJ1ZTtcblx0ICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcblx0ICAgICAgICBnbHlwaC5jb21wb25lbnRzID0gW107XG5cdCAgICAgICAgdmFyIG1vcmVDb21wb25lbnRzID0gdHJ1ZTtcblx0ICAgICAgICB3aGlsZSAobW9yZUNvbXBvbmVudHMpIHtcblx0ICAgICAgICAgICAgZmxhZ3MgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB7XG5cdCAgICAgICAgICAgICAgICBnbHlwaEluZGV4OiBwLnBhcnNlVVNob3J0KCksXG5cdCAgICAgICAgICAgICAgICB4U2NhbGU6IDEsXG5cdCAgICAgICAgICAgICAgICBzY2FsZTAxOiAwLFxuXHQgICAgICAgICAgICAgICAgc2NhbGUxMDogMCxcblx0ICAgICAgICAgICAgICAgIHlTY2FsZTogMSxcblx0ICAgICAgICAgICAgICAgIGR4OiAwLFxuXHQgICAgICAgICAgICAgICAgZHk6IDBcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgaWYgKChmbGFncyAmIDEpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgd29yZHNcblx0ICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAyKSA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG9mZnNldFxuXHQgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keCA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keSA9IHAucGFyc2VTaG9ydCgpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG1hdGNoZWQgcG9pbnRzXG5cdCAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm1hdGNoZWRQb2ludHMgPSBbcC5wYXJzZVVTaG9ydCgpLCBwLnBhcnNlVVNob3J0KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIGFyZSBieXRlc1xuXHQgICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIDIpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgb2Zmc2V0XG5cdCAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR4ID0gcC5wYXJzZUNoYXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlQ2hhcigpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG1hdGNoZWQgcG9pbnRzXG5cdCAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm1hdGNoZWRQb2ludHMgPSBbcC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoKGZsYWdzICYgOCkgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgc2NhbGVcblx0ICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiA2NCkgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFuIFggLyBZIHNjYWxlXG5cdCAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcblx0ICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIDEyOCkgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgMngyIHRyYW5zZm9ybWF0aW9uXG5cdCAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcblx0ICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zY2FsZTAxID0gcC5wYXJzZUYyRG90MTQoKTtcblx0ICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zY2FsZTEwID0gcC5wYXJzZUYyRG90MTQoKTtcblx0ICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZ2x5cGguY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG5cdCAgICAgICAgICAgIG1vcmVDb21wb25lbnRzID0gISEoZmxhZ3MgJiAzMik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChmbGFncyAmIDB4MTAwKSB7XG5cdCAgICAgICAgICAgIC8vIFdlIGhhdmUgaW5zdHJ1Y3Rpb25zXG5cdCAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9uTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSQ2ID0gMDsgaSQ2IDwgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGg7IGkkNiArPSAxKSB7XG5cdCAgICAgICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMucHVzaChwLnBhcnNlQnl0ZSgpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXG5cdC8vIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBwb2ludHMgYW5kIHJldHVybiBhIG5ldyBhcnJheS5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnRzKHBvaW50cywgdHJhbnNmb3JtKSB7XG5cdCAgICB2YXIgbmV3UG9pbnRzID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcblx0ICAgICAgICB2YXIgbmV3UHQgPSB7XG5cdCAgICAgICAgICAgIHg6IHRyYW5zZm9ybS54U2NhbGUgKiBwdC54ICsgdHJhbnNmb3JtLnNjYWxlMDEgKiBwdC55ICsgdHJhbnNmb3JtLmR4LFxuXHQgICAgICAgICAgICB5OiB0cmFuc2Zvcm0uc2NhbGUxMCAqIHB0LnggKyB0cmFuc2Zvcm0ueVNjYWxlICogcHQueSArIHRyYW5zZm9ybS5keSxcblx0ICAgICAgICAgICAgb25DdXJ2ZTogcHQub25DdXJ2ZSxcblx0ICAgICAgICAgICAgbGFzdFBvaW50T2ZDb250b3VyOiBwdC5sYXN0UG9pbnRPZkNvbnRvdXJcblx0ICAgICAgICB9O1xuXHQgICAgICAgIG5ld1BvaW50cy5wdXNoKG5ld1B0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG5ld1BvaW50cztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENvbnRvdXJzKHBvaW50cykge1xuXHQgICAgdmFyIGNvbnRvdXJzID0gW107XG5cdCAgICB2YXIgY3VycmVudENvbnRvdXIgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuXHQgICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuXHQgICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcblx0ICAgICAgICAgICAgY29udG91cnMucHVzaChjdXJyZW50Q29udG91cik7XG5cdCAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcblx0ICAgIHJldHVybiBjb250b3Vycztcblx0fVxuXG5cdC8vIENvbnZlcnQgdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmUgdG8gYSBQYXRoLlxuXHRmdW5jdGlvbiBnZXRQYXRoKHBvaW50cykge1xuXHQgICAgdmFyIHAgPSBuZXcgUGF0aCgpO1xuXHQgICAgaWYgKCFwb2ludHMpIHtcblx0ICAgICAgICByZXR1cm4gcDtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNvbnRvdXJzID0gZ2V0Q29udG91cnMocG9pbnRzKTtcblxuXHQgICAgZm9yICh2YXIgY29udG91ckluZGV4ID0gMDsgY29udG91ckluZGV4IDwgY29udG91cnMubGVuZ3RoOyArK2NvbnRvdXJJbmRleCkge1xuXHQgICAgICAgIHZhciBjb250b3VyID0gY29udG91cnNbY29udG91ckluZGV4XTtcblxuXHQgICAgICAgIHZhciBwcmV2ID0gbnVsbDtcblx0ICAgICAgICB2YXIgY3VyciA9IGNvbnRvdXJbY29udG91ci5sZW5ndGggLSAxXTtcblx0ICAgICAgICB2YXIgbmV4dCA9IGNvbnRvdXJbMF07XG5cblx0ICAgICAgICBpZiAoY3Vyci5vbkN1cnZlKSB7XG5cdCAgICAgICAgICAgIHAubW92ZVRvKGN1cnIueCwgY3Vyci55KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAobmV4dC5vbkN1cnZlKSB7XG5cdCAgICAgICAgICAgICAgICBwLm1vdmVUbyhuZXh0LngsIG5leHQueSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBJZiBib3RoIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgb2ZmLWN1cnZlLCBzdGFydCBhdCB0aGVpciBtaWRkbGUuXG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB7eDogKGN1cnIueCArIG5leHQueCkgKiAwLjUsIHk6IChjdXJyLnkgKyBuZXh0LnkpICogMC41fTtcblx0ICAgICAgICAgICAgICAgIHAubW92ZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250b3VyLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgIHByZXYgPSBjdXJyO1xuXHQgICAgICAgICAgICBjdXJyID0gbmV4dDtcblx0ICAgICAgICAgICAgbmV4dCA9IGNvbnRvdXJbKGkgKyAxKSAlIGNvbnRvdXIubGVuZ3RoXTtcblxuXHQgICAgICAgICAgICBpZiAoY3Vyci5vbkN1cnZlKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc3RyYWlnaHQgbGluZS5cblx0ICAgICAgICAgICAgICAgIHAubGluZVRvKGN1cnIueCwgY3Vyci55KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwcmV2MiA9IHByZXY7XG5cdCAgICAgICAgICAgICAgICB2YXIgbmV4dDIgPSBuZXh0O1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoIXByZXYub25DdXJ2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHByZXYyID0geyB4OiAoY3Vyci54ICsgcHJldi54KSAqIDAuNSwgeTogKGN1cnIueSArIHByZXYueSkgKiAwLjUgfTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKCFuZXh0Lm9uQ3VydmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBuZXh0MiA9IHsgeDogKGN1cnIueCArIG5leHQueCkgKiAwLjUsIHk6IChjdXJyLnkgKyBuZXh0LnkpICogMC41IH07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyhjdXJyLngsIGN1cnIueSwgbmV4dDIueCwgbmV4dDIueSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBwLmNsb3NlUGF0aCgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHA7XG5cdH1cblxuXHRmdW5jdGlvbiBidWlsZFBhdGgoZ2x5cGhzLCBnbHlwaCkge1xuXHQgICAgaWYgKGdseXBoLmlzQ29tcG9zaXRlKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaC5jb21wb25lbnRzLmxlbmd0aDsgaiArPSAxKSB7XG5cdCAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBnbHlwaC5jb21wb25lbnRzW2pdO1xuXHQgICAgICAgICAgICB2YXIgY29tcG9uZW50R2x5cGggPSBnbHlwaHMuZ2V0KGNvbXBvbmVudC5nbHlwaEluZGV4KTtcblx0ICAgICAgICAgICAgLy8gRm9yY2UgdGhlIHR0ZkdseXBoTG9hZGVyIHRvIHBhcnNlIHRoZSBnbHlwaC5cblx0ICAgICAgICAgICAgY29tcG9uZW50R2x5cGguZ2V0UGF0aCgpO1xuXHQgICAgICAgICAgICBpZiAoY29tcG9uZW50R2x5cGgucG9pbnRzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSAodm9pZCAwKTtcblx0ICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQubWF0Y2hlZFBvaW50cyA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHBvc2l0aW9uZWQgYnkgb2Zmc2V0XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQb2ludHMgPSB0cmFuc2Zvcm1Qb2ludHMoY29tcG9uZW50R2x5cGgucG9pbnRzLCBjb21wb25lbnQpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgcG9zaXRpb25lZCBieSBtYXRjaGVkIHBvaW50c1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICgoY29tcG9uZW50Lm1hdGNoZWRQb2ludHNbMF0gPiBnbHlwaC5wb2ludHMubGVuZ3RoIC0gMSkgfHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzFdID4gY29tcG9uZW50R2x5cGgucG9pbnRzLmxlbmd0aCAtIDEpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdNYXRjaGVkIHBvaW50cyBvdXQgb2YgcmFuZ2UgaW4gJyArIGdseXBoLm5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RQdCA9IGdseXBoLnBvaW50c1tjb21wb25lbnQubWF0Y2hlZFBvaW50c1swXV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZFB0ID0gY29tcG9uZW50R2x5cGgucG9pbnRzW2NvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzFdXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB4U2NhbGU6IGNvbXBvbmVudC54U2NhbGUsIHNjYWxlMDE6IGNvbXBvbmVudC5zY2FsZTAxLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTEwOiBjb21wb25lbnQuc2NhbGUxMCwgeVNjYWxlOiBjb21wb25lbnQueVNjYWxlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkeDogMCwgZHk6IDBcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHNlY29uZFB0ID0gdHJhbnNmb3JtUG9pbnRzKFtzZWNvbmRQdF0sIHRyYW5zZm9ybSlbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmR4ID0gZmlyc3RQdC54IC0gc2Vjb25kUHQueDtcblx0ICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0uZHkgPSBmaXJzdFB0LnkgLSBzZWNvbmRQdC55O1xuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKGNvbXBvbmVudEdseXBoLnBvaW50cywgdHJhbnNmb3JtKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IGdseXBoLnBvaW50cy5jb25jYXQodHJhbnNmb3JtZWRQb2ludHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZ2V0UGF0aChnbHlwaC5wb2ludHMpO1xuXHR9XG5cblx0Ly8gUGFyc2UgYWxsIHRoZSBnbHlwaHMgYWNjb3JkaW5nIHRvIHRoZSBvZmZzZXRzIGZyb20gdGhlIGBsb2NhYCB0YWJsZS5cblx0ZnVuY3Rpb24gcGFyc2VHbHlmVGFibGUoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQpIHtcblx0ICAgIHZhciBnbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQoZm9udCk7XG5cblx0ICAgIC8vIFRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxvY2EgdGFibGUgaXMgaW52YWxpZC5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYS5sZW5ndGggLSAxOyBpICs9IDEpIHtcblx0ICAgICAgICB2YXIgb2Zmc2V0ID0gbG9jYVtpXTtcblx0ICAgICAgICB2YXIgbmV4dE9mZnNldCA9IGxvY2FbaSArIDFdO1xuXHQgICAgICAgIGlmIChvZmZzZXQgIT09IG5leHRPZmZzZXQpIHtcblx0ICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQudHRmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VHbHlwaCwgZGF0YSwgc3RhcnQgKyBvZmZzZXQsIGJ1aWxkUGF0aCkpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LmdseXBoTG9hZGVyKGZvbnQsIGkpKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBnbHlwaHM7XG5cdH1cblxuXHR2YXIgZ2x5ZiA9IHsgZ2V0UGF0aDogZ2V0UGF0aCwgcGFyc2U6IHBhcnNlR2x5ZlRhYmxlIH07XG5cblx0LyogQSBUcnVlVHlwZSBmb250IGhpbnRpbmcgaW50ZXJwcmV0ZXIuXG5cdCpcblx0KiAoYykgMjAxNyBBeGVsIEtpdHRlbmJlcmdlclxuXHQqXG5cdCogVGhpcyBpbnRlcnByZXRlciBoYXMgYmVlbiBpbXBsZW1lbnRlZCBhY2NvcmRpbmcgdG8gdGhpcyBkb2N1bWVudGF0aW9uOlxuXHQqIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDUvQ2hhcDUuaHRtbFxuXHQqXG5cdCogQWNjb3JkaW5nIHRvIHRoZSBkb2N1bWVudGF0aW9uIEYyNERPVDYgdmFsdWVzIGFyZSB1c2VkIGZvciBwaXhlbHMuXG5cdCogVGhhdCBtZWFucyBjYWxjdWxhdGlvbiBpcyAxLzY0IHBpeGVsIGFjY3VyYXRlIGFuZCB1c2VzIGludGVnZXIgb3BlcmF0aW9ucy5cblx0KiBIb3dldmVyLCBKYXZhc2NyaXB0IGhhcyBmbG9hdGluZyBwb2ludCBvcGVyYXRpb25zIGJ5IGRlZmF1bHQgYW5kIG9ubHlcblx0KiB0aG9zZSBhcmUgYXZhaWxhYmxlLiBPbmUgY291bGQgbWFrZSBhIGNhc2UgdG8gc2ltdWxhdGUgdGhlIDEvNjQgYWNjdXJhY3lcblx0KiBleGFjdGx5IGJ5IHRydW5jYXRpbmcgYWZ0ZXIgZXZlcnkgZGl2aXNpb24gb3BlcmF0aW9uXG5cdCogKGZvciBleGFtcGxlIHdpdGggPDwgMCkgdG8gZ2V0IHBpeGVsIGV4YWN0bHkgcmVzdWx0cyBhcyBvdGhlciBUcnVlVHlwZVxuXHQqIGltcGxlbWVudGF0aW9ucy4gSXQgbWF5IG1ha2Ugc2Vuc2Ugc2luY2Ugc29tZSBmb250cyBhcmUgcGl4ZWwgb3B0aW1pemVkXG5cdCogYnkgaGFuZCB1c2luZyBERUxUQVAgaW5zdHJ1Y3Rpb25zLiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0XG5cdCogYW5kIHJhdGhlciB1c2VzIGZ1bGwgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uLlxuXHQqXG5cdCogeFNjYWxlLCB5U2NhbGUgYW5kIHJvdGF0aW9uIGlzIGN1cnJlbnRseSBpZ25vcmVkLlxuXHQqXG5cdCogQSBmZXcgbm9uLXRyaXZpYWwgaW5zdHJ1Y3Rpb25zIGFyZSBtaXNzaW5nIGFzIEkgZGlkbid0IGVuY291bnRlciB5ZXRcblx0KiBhIGZvbnQgdGhhdCB1c2VkIHRoZW0gdG8gdGVzdCBhIHBvc3NpYmxlIGltcGxlbWVudGF0aW9uLlxuXHQqXG5cdCogU29tZSBmb250cyBzZWVtIHRvIHVzZSB1bmRvY3VtZW50ZWQgZmVhdHVyZXMgcmVnYXJkaW5nIHRoZSB0d2lsaWdodCB6b25lLlxuXHQqIE9ubHkgc29tZSBvZiB0aGVtIGFyZSBpbXBsZW1lbnRlZCBhcyB0aGV5IHdlcmUgZW5jb3VudGVyZWQuXG5cdCpcblx0KiBUaGUgZXhwb3J0cy5ERUJVRyBzdGF0ZW1lbnRzIGFyZSByZW1vdmVkIG9uIHRoZSBtaW5pZmllZCBkaXN0cmlidXRpb24gZmlsZS5cblx0Ki9cblxuXHR2YXIgaW5zdHJ1Y3Rpb25UYWJsZTtcblx0dmFyIGV4ZWM7XG5cdHZhciBleGVjR2x5cGg7XG5cdHZhciBleGVjQ29tcG9uZW50O1xuXG5cdC8qXG5cdCogQ3JlYXRlcyBhIGhpbnRpbmcgb2JqZWN0LlxuXHQqXG5cdCogVGhlcmUgb3VnaHQgdG8gYmUgZXhhY3RseSBvbmVcblx0KiBmb3IgZWFjaCB0cnVldHlwZSBmb250IHRoYXQgaXMgdXNlZCBmb3IgaGludGluZy5cblx0Ki9cblx0ZnVuY3Rpb24gSGludGluZyhmb250KSB7XG5cdCAgICAvLyB0aGUgZm9udCB0aGlzIGhpbnRpbmcgb2JqZWN0IGlzIGZvclxuXHQgICAgdGhpcy5mb250ID0gZm9udDtcblxuXHQgICAgdGhpcy5nZXRDb21tYW5kcyA9IGZ1bmN0aW9uIChoUG9pbnRzKSB7XG5cdCAgICAgICAgcmV0dXJuIGdseWYuZ2V0UGF0aChoUG9pbnRzKS5jb21tYW5kcztcblx0ICAgIH07XG5cblx0ICAgIC8vIGNhY2hlZCBzdGF0ZXNcblx0ICAgIHRoaXMuX2ZwZ21TdGF0ZSAgPVxuXHQgICAgdGhpcy5fcHJlcFN0YXRlICA9XG5cdCAgICAgICAgdW5kZWZpbmVkO1xuXG5cdCAgICAvLyBlcnJvclN0YXRlXG5cdCAgICAvLyAwIC4uLiBhbGwgb2theVxuXHQgICAgLy8gMSAuLi4gaGFkIGFuIGVycm9yIGluIGEgZ2x5Zixcblx0ICAgIC8vICAgICAgIGNvbnRpbnVlIHdvcmtpbmcgYnV0IHN0b3Agc3BhbW1pbmdcblx0ICAgIC8vICAgICAgIHRoZSBjb25zb2xlXG5cdCAgICAvLyAyIC4uLiBlcnJvciBhdCBwcmVwLCBzdG9wIGhpbnRpbmcgYXQgdGhpcyBwcGVtXG5cdCAgICAvLyAzIC4uLiBlcnJvciBhdCBmcGVnLCBzdG9wIGhpbnRpbmcgZm9yIHRoaXMgZm9udCBhdCBhbGxcblx0ICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAwO1xuXHR9XG5cblx0Lypcblx0KiBOb3Qgcm91bmRpbmcuXG5cdCovXG5cdGZ1bmN0aW9uIHJvdW5kT2ZmKHYpIHtcblx0ICAgIHJldHVybiB2O1xuXHR9XG5cblx0Lypcblx0KiBSb3VuZGluZyB0byBncmlkLlxuXHQqL1xuXHRmdW5jdGlvbiByb3VuZFRvR3JpZCh2KSB7XG5cdCAgICAvL1JvdW5kaW5nIGluIFRUIGlzIHN1cHBvc2VkIHRvIFwic3ltbWV0cmljYWwgYXJvdW5kIHplcm9cIlxuXHQgICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGgucm91bmQoTWF0aC5hYnModikpO1xuXHR9XG5cblx0Lypcblx0KiBSb3VuZGluZyB0byBkb3VibGUgZ3JpZC5cblx0Ki9cblx0ZnVuY3Rpb24gcm91bmRUb0RvdWJsZUdyaWQodikge1xuXHQgICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGgucm91bmQoTWF0aC5hYnModiAqIDIpKSAvIDI7XG5cdH1cblxuXHQvKlxuXHQqIFJvdW5kaW5nIHRvIGhhbGYgZ3JpZC5cblx0Ki9cblx0ZnVuY3Rpb24gcm91bmRUb0hhbGZHcmlkKHYpIHtcblx0ICAgIHJldHVybiBNYXRoLnNpZ24odikgKiAoTWF0aC5yb3VuZChNYXRoLmFicyh2KSArIDAuNSkgLSAwLjUpO1xuXHR9XG5cblx0Lypcblx0KiBSb3VuZGluZyB0byB1cCB0byBncmlkLlxuXHQqL1xuXHRmdW5jdGlvbiByb3VuZFVwVG9HcmlkKHYpIHtcblx0ICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLmNlaWwoTWF0aC5hYnModikpO1xuXHR9XG5cblx0Lypcblx0KiBSb3VuZGluZyB0byBkb3duIHRvIGdyaWQuXG5cdCovXG5cdGZ1bmN0aW9uIHJvdW5kRG93blRvR3JpZCh2KSB7XG5cdCAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5mbG9vcihNYXRoLmFicyh2KSk7XG5cdH1cblxuXHQvKlxuXHQqIFN1cGVyIHJvdW5kaW5nLlxuXHQqL1xuXHR2YXIgcm91bmRTdXBlciA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgICB2YXIgcGVyaW9kID0gdGhpcy5zclBlcmlvZDtcblx0ICAgIHZhciBwaGFzZSA9IHRoaXMuc3JQaGFzZTtcblx0ICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLnNyVGhyZXNob2xkO1xuXHQgICAgdmFyIHNpZ24gPSAxO1xuXG5cdCAgICBpZiAodiA8IDApIHtcblx0ICAgICAgICB2ID0gLXY7XG5cdCAgICAgICAgc2lnbiA9IC0xO1xuXHQgICAgfVxuXG5cdCAgICB2ICs9IHRocmVzaG9sZCAtIHBoYXNlO1xuXG5cdCAgICB2ID0gTWF0aC50cnVuYyh2IC8gcGVyaW9kKSAqIHBlcmlvZDtcblxuXHQgICAgdiArPSBwaGFzZTtcblxuXHQgICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly94Z3JpZGZpdC5zb3VyY2Vmb3JnZS5uZXQvcm91bmQuaHRtbFxuXHQgICAgaWYgKHYgPCAwKSB7IHJldHVybiBwaGFzZSAqIHNpZ247IH1cblxuXHQgICAgcmV0dXJuIHYgKiBzaWduO1xuXHR9O1xuXG5cdC8qXG5cdCogVW5pdCB2ZWN0b3Igb2YgeC1heGlzLlxuXHQqL1xuXHR2YXIgeFVuaXRWZWN0b3IgPSB7XG5cdCAgICB4OiAxLFxuXG5cdCAgICB5OiAwLFxuXG5cdCAgICBheGlzOiAneCcsXG5cblx0ICAgIC8vIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG5cdCAgICAvLyBvMS9vMiAuLi4gaWYgdHJ1ZSwgcmVzcGVjdGl2ZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyB1c2VkLlxuXHQgICAgZGlzdGFuY2U6IGZ1bmN0aW9uIChwMSwgcDIsIG8xLCBvMikge1xuXHQgICAgICAgIHJldHVybiAobzEgPyBwMS54byA6IHAxLngpIC0gKG8yID8gcDIueG8gOiBwMi54KTtcblx0ICAgIH0sXG5cblx0ICAgIC8vIE1vdmVzIHBvaW50IHAgc28gdGhlIG1vdmVkIHBvc2l0aW9uIGhhcyB0aGUgc2FtZSByZWxhdGl2ZVxuXHQgICAgLy8gcG9zaXRpb24gdG8gdGhlIG1vdmVkIHBvc2l0aW9ucyBvZiBycDEgYW5kIHJwMiB0aGFuIHRoZVxuXHQgICAgLy8gb3JpZ2luYWwgcG9zaXRpb25zIGhhZC5cblx0ICAgIC8vXG5cdCAgICAvLyBTZWUgQVBQRU5ESVggb24gSU5URVJQT0xBVEUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG5cdCAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gKHAsIHJwMSwgcnAyLCBwdikge1xuXHQgICAgICAgIHZhciBkbzE7XG5cdCAgICAgICAgdmFyIGRvMjtcblx0ICAgICAgICB2YXIgZG9hMTtcblx0ICAgICAgICB2YXIgZG9hMjtcblx0ICAgICAgICB2YXIgZG0xO1xuXHQgICAgICAgIHZhciBkbTI7XG5cdCAgICAgICAgdmFyIGR0O1xuXG5cdCAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuXHQgICAgICAgICAgICBkbzEgPSBwLnhvIC0gcnAxLnhvO1xuXHQgICAgICAgICAgICBkbzIgPSBwLnhvIC0gcnAyLnhvO1xuXHQgICAgICAgICAgICBkbTEgPSBycDEueCAtIHJwMS54bztcblx0ICAgICAgICAgICAgZG0yID0gcnAyLnggLSBycDIueG87XG5cdCAgICAgICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuXHQgICAgICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcblx0ICAgICAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuXHQgICAgICAgICAgICBpZiAoZHQgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHAueCA9IHAueG8gKyAoZG0xICsgZG0yKSAvIDI7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBwLnggPSBwLnhvICsgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0O1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZG8xID0gcHYuZGlzdGFuY2UocCwgcnAxLCB0cnVlLCB0cnVlKTtcblx0ICAgICAgICBkbzIgPSBwdi5kaXN0YW5jZShwLCBycDIsIHRydWUsIHRydWUpO1xuXHQgICAgICAgIGRtMSA9IHB2LmRpc3RhbmNlKHJwMSwgcnAxLCBmYWxzZSwgdHJ1ZSk7XG5cdCAgICAgICAgZG0yID0gcHYuZGlzdGFuY2UocnAyLCBycDIsIGZhbHNlLCB0cnVlKTtcblx0ICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcblx0ICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcblx0ICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG5cdCAgICAgICAgaWYgKGR0ID09PSAwKSB7XG5cdCAgICAgICAgICAgIHhVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKyBkbTIpIC8gMiwgcHYsIHRydWUpO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgeFVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0LCBwdiwgdHJ1ZSk7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBTbG9wZSBvZiBsaW5lIG5vcm1hbCB0byB0aGlzXG5cdCAgICBub3JtYWxTbG9wZTogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuXG5cdCAgICAvLyBTZXRzIHRoZSBwb2ludCAncCcgcmVsYXRpdmUgdG8gcG9pbnQgJ3JwJ1xuXHQgICAgLy8gYnkgdGhlIGRpc3RhbmNlICdkJy5cblx0ICAgIC8vXG5cdCAgICAvLyBTZWUgQVBQRU5ESVggb24gU0VUUkVMQVRJVkUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG5cdCAgICAvL1xuXHQgICAgLy8gcCAgIC4uLiBwb2ludCB0byBzZXRcblx0ICAgIC8vIHJwICAuLi4gcmVmZXJlbmNlIHBvaW50XG5cdCAgICAvLyBkICAgLi4uIGRpc3RhbmNlIG9uIHByb2plY3Rpb24gdmVjdG9yXG5cdCAgICAvLyBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuXHQgICAgLy8gb3JnIC4uLiBpZiB0cnVlLCB1c2VzIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBvZiBycCBhcyByZWZlcmVuY2UuXG5cdCAgICBzZXRSZWxhdGl2ZTogZnVuY3Rpb24gKHAsIHJwLCBkLCBwdiwgb3JnKSB7XG5cdCAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuXHQgICAgICAgICAgICBwLnggPSAob3JnID8gcnAueG8gOiBycC54KSArIGQ7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcnB4ID0gb3JnID8gcnAueG8gOiBycC54O1xuXHQgICAgICAgIHZhciBycHkgPSBvcmcgPyBycC55byA6IHJwLnk7XG5cdCAgICAgICAgdmFyIHJwZHggPSBycHggKyBkICogcHYueDtcblx0ICAgICAgICB2YXIgcnBkeSA9IHJweSArIGQgKiBwdi55O1xuXG5cdCAgICAgICAgcC54ID0gcnBkeCArIChwLnkgLSBycGR5KSAvIHB2Lm5vcm1hbFNsb3BlO1xuXHQgICAgfSxcblxuXHQgICAgLy8gU2xvcGUgb2YgdmVjdG9yIGxpbmUuXG5cdCAgICBzbG9wZTogMCxcblxuXHQgICAgLy8gVG91Y2hlcyB0aGUgcG9pbnQgcC5cblx0ICAgIHRvdWNoOiBmdW5jdGlvbiAocCkge1xuXHQgICAgICAgIHAueFRvdWNoZWQgPSB0cnVlO1xuXHQgICAgfSxcblxuXHQgICAgLy8gVGVzdHMgaWYgYSBwb2ludCBwIGlzIHRvdWNoZWQuXG5cdCAgICB0b3VjaGVkOiBmdW5jdGlvbiAocCkge1xuXHQgICAgICAgIHJldHVybiBwLnhUb3VjaGVkO1xuXHQgICAgfSxcblxuXHQgICAgLy8gVW50b3VjaGVzIHRoZSBwb2ludCBwLlxuXHQgICAgdW50b3VjaDogZnVuY3Rpb24gKHApIHtcblx0ICAgICAgICBwLnhUb3VjaGVkID0gZmFsc2U7XG5cdCAgICB9XG5cdH07XG5cblx0Lypcblx0KiBVbml0IHZlY3RvciBvZiB5LWF4aXMuXG5cdCovXG5cdHZhciB5VW5pdFZlY3RvciA9IHtcblx0ICAgIHg6IDAsXG5cblx0ICAgIHk6IDEsXG5cblx0ICAgIGF4aXM6ICd5JyxcblxuXHQgICAgLy8gR2V0cyB0aGUgcHJvamVjdGVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cblx0ICAgIC8vIG8xL28yIC4uLiBpZiB0cnVlLCByZXNwZWN0aXZlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHVzZWQuXG5cdCAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHAxLCBwMiwgbzEsIG8yKSB7XG5cdCAgICAgICAgcmV0dXJuIChvMSA/IHAxLnlvIDogcDEueSkgLSAobzIgPyBwMi55byA6IHAyLnkpO1xuXHQgICAgfSxcblxuXHQgICAgLy8gTW92ZXMgcG9pbnQgcCBzbyB0aGUgbW92ZWQgcG9zaXRpb24gaGFzIHRoZSBzYW1lIHJlbGF0aXZlXG5cdCAgICAvLyBwb3NpdGlvbiB0byB0aGUgbW92ZWQgcG9zaXRpb25zIG9mIHJwMSBhbmQgcnAyIHRoYW4gdGhlXG5cdCAgICAvLyBvcmlnaW5hbCBwb3NpdGlvbnMgaGFkLlxuXHQgICAgLy9cblx0ICAgIC8vIFNlZSBBUFBFTkRJWCBvbiBJTlRFUlBPTEFURSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cblx0ICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiAocCwgcnAxLCBycDIsIHB2KSB7XG5cdCAgICAgICAgdmFyIGRvMTtcblx0ICAgICAgICB2YXIgZG8yO1xuXHQgICAgICAgIHZhciBkb2ExO1xuXHQgICAgICAgIHZhciBkb2EyO1xuXHQgICAgICAgIHZhciBkbTE7XG5cdCAgICAgICAgdmFyIGRtMjtcblx0ICAgICAgICB2YXIgZHQ7XG5cblx0ICAgICAgICBpZiAoIXB2IHx8IHB2ID09PSB0aGlzKSB7XG5cdCAgICAgICAgICAgIGRvMSA9IHAueW8gLSBycDEueW87XG5cdCAgICAgICAgICAgIGRvMiA9IHAueW8gLSBycDIueW87XG5cdCAgICAgICAgICAgIGRtMSA9IHJwMS55IC0gcnAxLnlvO1xuXHQgICAgICAgICAgICBkbTIgPSBycDIueSAtIHJwMi55bztcblx0ICAgICAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG5cdCAgICAgICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuXHQgICAgICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG5cdCAgICAgICAgICAgIGlmIChkdCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgcC55ID0gcC55byArIChkbTEgKyBkbTIpIC8gMjtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHAueSA9IHAueW8gKyAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQ7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBkbzEgPSBwdi5kaXN0YW5jZShwLCBycDEsIHRydWUsIHRydWUpO1xuXHQgICAgICAgIGRvMiA9IHB2LmRpc3RhbmNlKHAsIHJwMiwgdHJ1ZSwgdHJ1ZSk7XG5cdCAgICAgICAgZG0xID0gcHYuZGlzdGFuY2UocnAxLCBycDEsIGZhbHNlLCB0cnVlKTtcblx0ICAgICAgICBkbTIgPSBwdi5kaXN0YW5jZShycDIsIHJwMiwgZmFsc2UsIHRydWUpO1xuXHQgICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuXHQgICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuXHQgICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cblx0ICAgICAgICBpZiAoZHQgPT09IDApIHtcblx0ICAgICAgICAgICAgeVVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSArIGRtMikgLyAyLCBwdiwgdHJ1ZSk7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB5VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQsIHB2LCB0cnVlKTtcblx0ICAgIH0sXG5cblx0ICAgIC8vIFNsb3BlIG9mIGxpbmUgbm9ybWFsIHRvIHRoaXMuXG5cdCAgICBub3JtYWxTbG9wZTogMCxcblxuXHQgICAgLy8gU2V0cyB0aGUgcG9pbnQgJ3AnIHJlbGF0aXZlIHRvIHBvaW50ICdycCdcblx0ICAgIC8vIGJ5IHRoZSBkaXN0YW5jZSAnZCdcblx0ICAgIC8vXG5cdCAgICAvLyBTZWUgQVBQRU5ESVggb24gU0VUUkVMQVRJVkUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG5cdCAgICAvL1xuXHQgICAgLy8gcCAgIC4uLiBwb2ludCB0byBzZXRcblx0ICAgIC8vIHJwICAuLi4gcmVmZXJlbmNlIHBvaW50XG5cdCAgICAvLyBkICAgLi4uIGRpc3RhbmNlIG9uIHByb2plY3Rpb24gdmVjdG9yXG5cdCAgICAvLyBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuXHQgICAgLy8gb3JnIC4uLiBpZiB0cnVlLCB1c2VzIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBvZiBycCBhcyByZWZlcmVuY2UuXG5cdCAgICBzZXRSZWxhdGl2ZTogZnVuY3Rpb24gKHAsIHJwLCBkLCBwdiwgb3JnKSB7XG5cdCAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuXHQgICAgICAgICAgICBwLnkgPSAob3JnID8gcnAueW8gOiBycC55KSArIGQ7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcnB4ID0gb3JnID8gcnAueG8gOiBycC54O1xuXHQgICAgICAgIHZhciBycHkgPSBvcmcgPyBycC55byA6IHJwLnk7XG5cdCAgICAgICAgdmFyIHJwZHggPSBycHggKyBkICogcHYueDtcblx0ICAgICAgICB2YXIgcnBkeSA9IHJweSArIGQgKiBwdi55O1xuXG5cdCAgICAgICAgcC55ID0gcnBkeSArIHB2Lm5vcm1hbFNsb3BlICogKHAueCAtIHJwZHgpO1xuXHQgICAgfSxcblxuXHQgICAgLy8gU2xvcGUgb2YgdmVjdG9yIGxpbmUuXG5cdCAgICBzbG9wZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuXG5cdCAgICAvLyBUb3VjaGVzIHRoZSBwb2ludCBwLlxuXHQgICAgdG91Y2g6IGZ1bmN0aW9uIChwKSB7XG5cdCAgICAgICAgcC55VG91Y2hlZCA9IHRydWU7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBUZXN0cyBpZiBhIHBvaW50IHAgaXMgdG91Y2hlZC5cblx0ICAgIHRvdWNoZWQ6IGZ1bmN0aW9uIChwKSB7XG5cdCAgICAgICAgcmV0dXJuIHAueVRvdWNoZWQ7XG5cdCAgICB9LFxuXG5cdCAgICAvLyBVbnRvdWNoZXMgdGhlIHBvaW50IHAuXG5cdCAgICB1bnRvdWNoOiBmdW5jdGlvbiAocCkge1xuXHQgICAgICAgIHAueVRvdWNoZWQgPSBmYWxzZTtcblx0ICAgIH1cblx0fTtcblxuXHRPYmplY3QuZnJlZXplKHhVbml0VmVjdG9yKTtcblx0T2JqZWN0LmZyZWV6ZSh5VW5pdFZlY3Rvcik7XG5cblx0Lypcblx0KiBDcmVhdGVzIGEgdW5pdCB2ZWN0b3IgdGhhdCBpcyBub3QgeC0gb3IgeS1heGlzLlxuXHQqL1xuXHRmdW5jdGlvbiBVbml0VmVjdG9yKHgsIHkpIHtcblx0ICAgIHRoaXMueCA9IHg7XG5cdCAgICB0aGlzLnkgPSB5O1xuXHQgICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuXHQgICAgdGhpcy5zbG9wZSA9IHkgLyB4O1xuXHQgICAgdGhpcy5ub3JtYWxTbG9wZSA9IC14IC8geTtcblx0ICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG5cdH1cblxuXHQvKlxuXHQqIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG5cdCogbzEvbzIgLi4uIGlmIHRydWUsIHJlc3BlY3RpdmUgb3JpZ2luYWwgcG9zaXRpb24gaXMgdXNlZC5cblx0Ki9cblx0VW5pdFZlY3Rvci5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbihwMSwgcDIsIG8xLCBvMikge1xuXHQgICAgcmV0dXJuIChcblx0ICAgICAgICB0aGlzLnggKiB4VW5pdFZlY3Rvci5kaXN0YW5jZShwMSwgcDIsIG8xLCBvMikgK1xuXHQgICAgICAgIHRoaXMueSAqIHlVbml0VmVjdG9yLmRpc3RhbmNlKHAxLCBwMiwgbzEsIG8yKVxuXHQgICAgKTtcblx0fTtcblxuXHQvKlxuXHQqIE1vdmVzIHBvaW50IHAgc28gdGhlIG1vdmVkIHBvc2l0aW9uIGhhcyB0aGUgc2FtZSByZWxhdGl2ZVxuXHQqIHBvc2l0aW9uIHRvIHRoZSBtb3ZlZCBwb3NpdGlvbnMgb2YgcnAxIGFuZCBycDIgdGhhbiB0aGVcblx0KiBvcmlnaW5hbCBwb3NpdGlvbnMgaGFkLlxuXHQqXG5cdCogU2VlIEFQUEVORElYIG9uIElOVEVSUE9MQVRFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuXHQqL1xuXHRVbml0VmVjdG9yLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHAsIHJwMSwgcnAyLCBwdikge1xuXHQgICAgdmFyIGRtMTtcblx0ICAgIHZhciBkbTI7XG5cdCAgICB2YXIgZG8xO1xuXHQgICAgdmFyIGRvMjtcblx0ICAgIHZhciBkb2ExO1xuXHQgICAgdmFyIGRvYTI7XG5cdCAgICB2YXIgZHQ7XG5cblx0ICAgIGRvMSA9IHB2LmRpc3RhbmNlKHAsIHJwMSwgdHJ1ZSwgdHJ1ZSk7XG5cdCAgICBkbzIgPSBwdi5kaXN0YW5jZShwLCBycDIsIHRydWUsIHRydWUpO1xuXHQgICAgZG0xID0gcHYuZGlzdGFuY2UocnAxLCBycDEsIGZhbHNlLCB0cnVlKTtcblx0ICAgIGRtMiA9IHB2LmRpc3RhbmNlKHJwMiwgcnAyLCBmYWxzZSwgdHJ1ZSk7XG5cdCAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcblx0ICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuXHQgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuXHQgICAgaWYgKGR0ID09PSAwKSB7XG5cdCAgICAgICAgdGhpcy5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICsgZG0yKSAvIDIsIHB2LCB0cnVlKTtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0LCBwdiwgdHJ1ZSk7XG5cdH07XG5cblx0Lypcblx0KiBTZXRzIHRoZSBwb2ludCAncCcgcmVsYXRpdmUgdG8gcG9pbnQgJ3JwJ1xuXHQqIGJ5IHRoZSBkaXN0YW5jZSAnZCdcblx0KlxuXHQqIFNlZSBBUFBFTkRJWCBvbiBTRVRSRUxBVElWRSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cblx0KlxuXHQqIHAgICAuLi4gIHBvaW50IHRvIHNldFxuXHQqIHJwICAuLi4gcmVmZXJlbmNlIHBvaW50XG5cdCogZCAgIC4uLiBkaXN0YW5jZSBvbiBwcm9qZWN0aW9uIHZlY3RvclxuXHQqIHB2ICAuLi4gcHJvamVjdGlvbiB2ZWN0b3IgKHVuZGVmaW5lZCA9IHRoaXMpXG5cdCogb3JnIC4uLiBpZiB0cnVlLCB1c2VzIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBvZiBycCBhcyByZWZlcmVuY2UuXG5cdCovXG5cdFVuaXRWZWN0b3IucHJvdG90eXBlLnNldFJlbGF0aXZlID0gZnVuY3Rpb24ocCwgcnAsIGQsIHB2LCBvcmcpIHtcblx0ICAgIHB2ID0gcHYgfHwgdGhpcztcblxuXHQgICAgdmFyIHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcblx0ICAgIHZhciBycHkgPSBvcmcgPyBycC55byA6IHJwLnk7XG5cdCAgICB2YXIgcnBkeCA9IHJweCArIGQgKiBwdi54O1xuXHQgICAgdmFyIHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuXHQgICAgdmFyIHB2bnMgPSBwdi5ub3JtYWxTbG9wZTtcblx0ICAgIHZhciBmdnMgPSB0aGlzLnNsb3BlO1xuXG5cdCAgICB2YXIgcHggPSBwLng7XG5cdCAgICB2YXIgcHkgPSBwLnk7XG5cblx0ICAgIHAueCA9IChmdnMgKiBweCAtIHB2bnMgKiBycGR4ICsgcnBkeSAtIHB5KSAvIChmdnMgLSBwdm5zKTtcblx0ICAgIHAueSA9IGZ2cyAqIChwLnggLSBweCkgKyBweTtcblx0fTtcblxuXHQvKlxuXHQqIFRvdWNoZXMgdGhlIHBvaW50IHAuXG5cdCovXG5cdFVuaXRWZWN0b3IucHJvdG90eXBlLnRvdWNoID0gZnVuY3Rpb24ocCkge1xuXHQgICAgcC54VG91Y2hlZCA9IHRydWU7XG5cdCAgICBwLnlUb3VjaGVkID0gdHJ1ZTtcblx0fTtcblxuXHQvKlxuXHQqIFJldHVybnMgYSB1bml0IHZlY3RvciB3aXRoIHgveSBjb29yZGluYXRlcy5cblx0Ki9cblx0ZnVuY3Rpb24gZ2V0VW5pdFZlY3Rvcih4LCB5KSB7XG5cdCAgICB2YXIgZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblxuXHQgICAgeCAvPSBkO1xuXHQgICAgeSAvPSBkO1xuXG5cdCAgICBpZiAoeCA9PT0gMSAmJiB5ID09PSAwKSB7IHJldHVybiB4VW5pdFZlY3RvcjsgfVxuXHQgICAgZWxzZSBpZiAoeCA9PT0gMCAmJiB5ID09PSAxKSB7IHJldHVybiB5VW5pdFZlY3RvcjsgfVxuXHQgICAgZWxzZSB7IHJldHVybiBuZXcgVW5pdFZlY3Rvcih4LCB5KTsgfVxuXHR9XG5cblx0Lypcblx0KiBDcmVhdGVzIGEgcG9pbnQgaW4gdGhlIGhpbnRpbmcgZW5naW5lLlxuXHQqL1xuXHRmdW5jdGlvbiBIUG9pbnQoXG5cdCAgICB4LFxuXHQgICAgeSxcblx0ICAgIGxhc3RQb2ludE9mQ29udG91cixcblx0ICAgIG9uQ3VydmVcblx0KSB7XG5cdCAgICB0aGlzLnggPSB0aGlzLnhvID0gTWF0aC5yb3VuZCh4ICogNjQpIC8gNjQ7IC8vIGhpbnRlZCB4IHZhbHVlIGFuZCBvcmlnaW5hbCB4LXZhbHVlXG5cdCAgICB0aGlzLnkgPSB0aGlzLnlvID0gTWF0aC5yb3VuZCh5ICogNjQpIC8gNjQ7IC8vIGhpbnRlZCB5IHZhbHVlIGFuZCBvcmlnaW5hbCB5LXZhbHVlXG5cblx0ICAgIHRoaXMubGFzdFBvaW50T2ZDb250b3VyID0gbGFzdFBvaW50T2ZDb250b3VyO1xuXHQgICAgdGhpcy5vbkN1cnZlID0gb25DdXJ2ZTtcblx0ICAgIHRoaXMucHJldlBvaW50T25Db250b3VyID0gdW5kZWZpbmVkO1xuXHQgICAgdGhpcy5uZXh0UG9pbnRPbkNvbnRvdXIgPSB1bmRlZmluZWQ7XG5cdCAgICB0aGlzLnhUb3VjaGVkID0gZmFsc2U7XG5cdCAgICB0aGlzLnlUb3VjaGVkID0gZmFsc2U7XG5cblx0ICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcblx0fVxuXG5cdC8qXG5cdCogUmV0dXJucyB0aGUgbmV4dCB0b3VjaGVkIHBvaW50IG9uIHRoZSBjb250b3VyLlxuXHQqXG5cdCogdiAgLi4uIHVuaXQgdmVjdG9yIHRvIHRlc3QgdG91Y2ggYXhpcy5cblx0Ki9cblx0SFBvaW50LnByb3RvdHlwZS5uZXh0VG91Y2hlZCA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHZhciBwID0gdGhpcy5uZXh0UG9pbnRPbkNvbnRvdXI7XG5cblx0ICAgIHdoaWxlICghdi50b3VjaGVkKHApICYmIHAgIT09IHRoaXMpIHsgcCA9IHAubmV4dFBvaW50T25Db250b3VyOyB9XG5cblx0ICAgIHJldHVybiBwO1xuXHR9O1xuXG5cdC8qXG5cdCogUmV0dXJucyB0aGUgcHJldmlvdXMgdG91Y2hlZCBwb2ludCBvbiB0aGUgY29udG91clxuXHQqXG5cdCogdiAgLi4uIHVuaXQgdmVjdG9yIHRvIHRlc3QgdG91Y2ggYXhpcy5cblx0Ki9cblx0SFBvaW50LnByb3RvdHlwZS5wcmV2VG91Y2hlZCA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHZhciBwID0gdGhpcy5wcmV2UG9pbnRPbkNvbnRvdXI7XG5cblx0ICAgIHdoaWxlICghdi50b3VjaGVkKHApICYmIHAgIT09IHRoaXMpIHsgcCA9IHAucHJldlBvaW50T25Db250b3VyOyB9XG5cblx0ICAgIHJldHVybiBwO1xuXHR9O1xuXG5cdC8qXG5cdCogVGhlIHplcm8gcG9pbnQuXG5cdCovXG5cdHZhciBIUFplcm8gPSBPYmplY3QuZnJlZXplKG5ldyBIUG9pbnQoMCwgMCkpO1xuXG5cdC8qXG5cdCogVGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlIGludGVycHJldGVyLlxuXHQqXG5cdCogTm90ZTogRnJlZXppbmcgdGhlIGRlZmF1bHRTdGF0ZSBhbmQgdGhlbiBkZXJpdmluZyBmcm9tIGl0XG5cdCogbWFrZXMgdGhlIFY4IEphdmFzY3JpcHQgZW5naW5lIGdvaW5nIGF3a3dhcmQsXG5cdCogc28gdGhpcyBpcyBhdm9pZGVkLCBhbGJlaXQgdGhlIGRlZmF1bHRTdGF0ZSBzaG91bGRuJ3Rcblx0KiBldmVyIGNoYW5nZS5cblx0Ki9cblx0dmFyIGRlZmF1bHRTdGF0ZSA9IHtcblx0ICAgIGN2Q3V0SW46IDE3IC8gMTYsICAgIC8vIGNvbnRyb2wgdmFsdWUgY3V0IGluXG5cdCAgICBkZWx0YUJhc2U6IDksXG5cdCAgICBkZWx0YVNoaWZ0OiAwLjEyNSxcblx0ICAgIGxvb3A6IDEsICAgICAgICAgICAgIC8vIGxvb3BzIHNvbWUgaW5zdHJ1Y3Rpb25zXG5cdCAgICBtaW5EaXM6IDEsICAgICAgICAgICAvLyBtaW5pbXVtIGRpc3RhbmNlXG5cdCAgICBhdXRvRmxpcDogdHJ1ZVxuXHR9O1xuXG5cdC8qXG5cdCogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGludGVycHJldGVyLlxuXHQqXG5cdCogZW52ICAuLi4gJ2ZwZ20nIG9yICdwcmVwJyBvciAnZ2x5Zidcblx0KiBwcm9nIC4uLiB0aGUgcHJvZ3JhbVxuXHQqL1xuXHRmdW5jdGlvbiBTdGF0ZShlbnYsIHByb2cpIHtcblx0ICAgIHRoaXMuZW52ID0gZW52O1xuXHQgICAgdGhpcy5zdGFjayA9IFtdO1xuXHQgICAgdGhpcy5wcm9nID0gcHJvZztcblxuXHQgICAgc3dpdGNoIChlbnYpIHtcblx0ICAgICAgICBjYXNlICdnbHlmJyA6XG5cdCAgICAgICAgICAgIHRoaXMuenAwID0gdGhpcy56cDEgPSB0aGlzLnpwMiA9IDE7XG5cdCAgICAgICAgICAgIHRoaXMucnAwID0gdGhpcy5ycDEgPSB0aGlzLnJwMiA9IDA7XG5cdCAgICAgICAgICAgIC8qIGZhbGwgdGhyb3VnaCAqL1xuXHQgICAgICAgIGNhc2UgJ3ByZXAnIDpcblx0ICAgICAgICAgICAgdGhpcy5mdiA9IHRoaXMucHYgPSB0aGlzLmRwdiA9IHhVbml0VmVjdG9yO1xuXHQgICAgICAgICAgICB0aGlzLnJvdW5kID0gcm91bmRUb0dyaWQ7XG5cdCAgICB9XG5cdH1cblxuXHQvKlxuXHQqIEV4ZWN1dGVzIGEgZ2x5cGggcHJvZ3JhbS5cblx0KlxuXHQqIFRoaXMgZG9lcyB0aGUgaGludGluZyBmb3IgZWFjaCBnbHlwaC5cblx0KlxuXHQqIFJldHVybnMgYW4gYXJyYXkgb2YgbW92ZWQgcG9pbnRzLlxuXHQqXG5cdCogZ2x5cGg6IHRoZSBnbHlwaCB0byBoaW50XG5cdCogcHBlbTogdGhlIHNpemUgdGhlIGdseXBoIGlzIHJlbmRlcmVkIGZvclxuXHQqL1xuXHRIaW50aW5nLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oZ2x5cGgsIHBwZW0pIHtcblx0ICAgIGlmICh0eXBlb2YgcHBlbSAhPT0gJ251bWJlcicpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IHNpemUgaXMgbm90IGEgbnVtYmVyIScpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBSZWNlaXZlZCBhIGZhdGFsIGVycm9yLCBkb24ndCBkbyBhbnkgaGludGluZyBhbnltb3JlLlxuXHQgICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPiAyKSB7IHJldHVybjsgfVxuXG5cdCAgICB2YXIgZm9udCA9IHRoaXMuZm9udDtcblx0ICAgIHZhciBwcmVwU3RhdGUgPSB0aGlzLl9wcmVwU3RhdGU7XG5cblx0ICAgIGlmICghcHJlcFN0YXRlIHx8IHByZXBTdGF0ZS5wcGVtICE9PSBwcGVtKSB7XG5cdCAgICAgICAgdmFyIGZwZ21TdGF0ZSA9IHRoaXMuX2ZwZ21TdGF0ZTtcblxuXHQgICAgICAgIGlmICghZnBnbVN0YXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEV4ZWN1dGVzIHRoZSBmcGdtIHN0YXRlLlxuXHQgICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWQgYnkgZm9udHMgdG8gZGVmaW5lIGZ1bmN0aW9ucy5cblx0ICAgICAgICAgICAgU3RhdGUucHJvdG90eXBlID0gZGVmYXVsdFN0YXRlO1xuXG5cdCAgICAgICAgICAgIGZwZ21TdGF0ZSA9XG5cdCAgICAgICAgICAgIHRoaXMuX2ZwZ21TdGF0ZSA9XG5cdCAgICAgICAgICAgICAgICBuZXcgU3RhdGUoJ2ZwZ20nLCBmb250LnRhYmxlcy5mcGdtKTtcblxuXHQgICAgICAgICAgICBmcGdtU3RhdGUuZnVuY3MgPSBbIF07XG5cdCAgICAgICAgICAgIGZwZ21TdGF0ZS5mb250ID0gZm9udDtcblxuXHQgICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgRlBHTS0tLScpO1xuXHQgICAgICAgICAgICAgICAgZnBnbVN0YXRlLnN0ZXAgPSAtMTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBleGVjKGZwZ21TdGF0ZSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaW50aW5nIGVycm9yIGluIEZQR006JyArIGUpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDM7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBFeGVjdXRlcyB0aGUgcHJlcCBwcm9ncmFtIGZvciB0aGlzIHBwZW0gc2V0dGluZy5cblx0ICAgICAgICAvLyBUaGlzIGlzIHVzZWQgYnkgZm9udHMgdG8gc2V0IGN2dCB2YWx1ZXNcblx0ICAgICAgICAvLyBkZXBlbmRpbmcgb24gdG8gYmUgcmVuZGVyZWQgZm9udCBzaXplLlxuXG5cdCAgICAgICAgU3RhdGUucHJvdG90eXBlID0gZnBnbVN0YXRlO1xuXHQgICAgICAgIHByZXBTdGF0ZSA9XG5cdCAgICAgICAgdGhpcy5fcHJlcFN0YXRlID1cblx0ICAgICAgICAgICAgbmV3IFN0YXRlKCdwcmVwJywgZm9udC50YWJsZXMucHJlcCk7XG5cblx0ICAgICAgICBwcmVwU3RhdGUucHBlbSA9IHBwZW07XG5cblx0ICAgICAgICAvLyBDcmVhdGVzIGEgY29weSBvZiB0aGUgY3Z0IHRhYmxlXG5cdCAgICAgICAgLy8gYW5kIHNjYWxlcyBpdCB0byB0aGUgY3VycmVudCBwcGVtIHNldHRpbmcuXG5cdCAgICAgICAgdmFyIG9DdnQgPSBmb250LnRhYmxlcy5jdnQ7XG5cdCAgICAgICAgaWYgKG9DdnQpIHtcblx0ICAgICAgICAgICAgdmFyIGN2dCA9IHByZXBTdGF0ZS5jdnQgPSBuZXcgQXJyYXkob0N2dC5sZW5ndGgpO1xuXHQgICAgICAgICAgICB2YXIgc2NhbGUgPSBwcGVtIC8gZm9udC51bml0c1BlckVtO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG9DdnQubGVuZ3RoOyBjKyspIHtcblx0ICAgICAgICAgICAgICAgIGN2dFtjXSA9IG9DdnRbY10gKiBzY2FsZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHByZXBTdGF0ZS5jdnQgPSBbXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuXHQgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBQUkVQLS0tJyk7XG5cdCAgICAgICAgICAgIHByZXBTdGF0ZS5zdGVwID0gLTE7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgZXhlYyhwcmVwU3RhdGUpO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPCAyKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGludGluZyBlcnJvciBpbiBQUkVQOicgKyBlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9lcnJvclN0YXRlID0gMjtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLl9lcnJvclN0YXRlID4gMSkgeyByZXR1cm47IH1cblxuXHQgICAgdHJ5IHtcblx0ICAgICAgICByZXR1cm4gZXhlY0dseXBoKGdseXBoLCBwcmVwU3RhdGUpO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgIGlmICh0aGlzLl9lcnJvclN0YXRlIDwgMSkge1xuXHQgICAgICAgICAgICBjb25zb2xlLmxvZygnSGludGluZyBlcnJvcjonICsgZSk7XG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKCdOb3RlOiBmdXJ0aGVyIGhpbnRpbmcgZXJyb3JzIGFyZSBzaWxlbmNlZCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9lcnJvclN0YXRlID0gMTtcblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXHR9O1xuXG5cdC8qXG5cdCogRXhlY3V0ZXMgdGhlIGhpbnRpbmcgcHJvZ3JhbSBmb3IgYSBnbHlwaC5cblx0Ki9cblx0ZXhlY0dseXBoID0gZnVuY3Rpb24oZ2x5cGgsIHByZXBTdGF0ZSkge1xuXHQgICAgLy8gb3JpZ2luYWwgcG9pbnQgcG9zaXRpb25zXG5cdCAgICB2YXIgeFNjYWxlID0gcHJlcFN0YXRlLnBwZW0gLyBwcmVwU3RhdGUuZm9udC51bml0c1BlckVtO1xuXHQgICAgdmFyIHlTY2FsZSA9IHhTY2FsZTtcblx0ICAgIHZhciBjb21wb25lbnRzID0gZ2x5cGguY29tcG9uZW50cztcblx0ICAgIHZhciBjb250b3Vycztcblx0ICAgIHZhciBnWm9uZTtcblx0ICAgIHZhciBzdGF0ZTtcblxuXHQgICAgU3RhdGUucHJvdG90eXBlID0gcHJlcFN0YXRlO1xuXHQgICAgaWYgKCFjb21wb25lbnRzKSB7XG5cdCAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoJ2dseWYnLCBnbHlwaC5pbnN0cnVjdGlvbnMpO1xuXHQgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIEdMWVBILS0tJyk7XG5cdCAgICAgICAgICAgIHN0YXRlLnN0ZXAgPSAtMTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZXhlY0NvbXBvbmVudChnbHlwaCwgc3RhdGUsIHhTY2FsZSwgeVNjYWxlKTtcblx0ICAgICAgICBnWm9uZSA9IHN0YXRlLmdab25lO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgZm9udCA9IHByZXBTdGF0ZS5mb250O1xuXHQgICAgICAgIGdab25lID0gW107XG5cdCAgICAgICAgY29udG91cnMgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuXHQgICAgICAgICAgICB2YXIgY2cgPSBmb250LmdseXBocy5nZXQoYy5nbHlwaEluZGV4KTtcblxuXHQgICAgICAgICAgICBzdGF0ZSA9IG5ldyBTdGF0ZSgnZ2x5ZicsIGNnLmluc3RydWN0aW9ucyk7XG5cblx0ICAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIENPTVAgJyArIGkgKyAnLS0tJyk7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwID0gLTE7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBleGVjQ29tcG9uZW50KGNnLCBzdGF0ZSwgeFNjYWxlLCB5U2NhbGUpO1xuXHQgICAgICAgICAgICAvLyBhcHBlbmRzIHRoZSBjb21wdXRlZCBwb2ludHMgdG8gdGhlIHJlc3VsdCBhcnJheVxuXHQgICAgICAgICAgICAvLyBwb3N0IHByb2Nlc3NlcyB0aGUgY29tcG9uZW50IHBvaW50c1xuXHQgICAgICAgICAgICB2YXIgZHggPSBNYXRoLnJvdW5kKGMuZHggKiB4U2NhbGUpO1xuXHQgICAgICAgICAgICB2YXIgZHkgPSBNYXRoLnJvdW5kKGMuZHkgKiB5U2NhbGUpO1xuXHQgICAgICAgICAgICB2YXIgZ3ogPSBzdGF0ZS5nWm9uZTtcblx0ICAgICAgICAgICAgdmFyIGNjID0gc3RhdGUuY29udG91cnM7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHBpID0gMDsgcGkgPCBnei5sZW5ndGg7IHBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwID0gZ3pbcGldO1xuXHQgICAgICAgICAgICAgICAgcC54VG91Y2hlZCA9IHAueVRvdWNoZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHAueG8gPSBwLnggPSBwLnggKyBkeDtcblx0ICAgICAgICAgICAgICAgIHAueW8gPSBwLnkgPSBwLnkgKyBkeTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBnTGVuID0gZ1pvbmUubGVuZ3RoO1xuXHQgICAgICAgICAgICBnWm9uZS5wdXNoLmFwcGx5KGdab25lLCBneik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2MubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY2Nbal0gKyBnTGVuKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChnbHlwaC5pbnN0cnVjdGlvbnMgJiYgIXN0YXRlLmluaGliaXRHcmlkRml0KSB7XG5cdCAgICAgICAgICAgIC8vIHRoZSBjb21wb3NpdGUgaGFzIGluc3RydWN0aW9ucyBvbiBpdHMgb3duXG5cdCAgICAgICAgICAgIHN0YXRlID0gbmV3IFN0YXRlKCdnbHlmJywgZ2x5cGguaW5zdHJ1Y3Rpb25zKTtcblxuXHQgICAgICAgICAgICBzdGF0ZS5nWm9uZSA9IHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IGdab25lO1xuXG5cdCAgICAgICAgICAgIHN0YXRlLmNvbnRvdXJzID0gY29udG91cnM7XG5cblx0ICAgICAgICAgICAgLy8gbm90ZTogSFBaZXJvIGNhbm5vdCBiZSB1c2VkIGhlcmUsIHNpbmNlXG5cdCAgICAgICAgICAgIC8vICAgICAgIHRoZSBwb2ludCBtaWdodCBiZSBtb2RpZmllZFxuXHQgICAgICAgICAgICBnWm9uZS5wdXNoKFxuXHQgICAgICAgICAgICAgICAgbmV3IEhQb2ludCgwLCAwKSxcblx0ICAgICAgICAgICAgICAgIG5ldyBIUG9pbnQoTWF0aC5yb3VuZChnbHlwaC5hZHZhbmNlV2lkdGggKiB4U2NhbGUpLCAwKVxuXHQgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBDT01QT1NJVEUtLS0nKTtcblx0ICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAgPSAtMTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGV4ZWMoc3RhdGUpO1xuXG5cdCAgICAgICAgICAgIGdab25lLmxlbmd0aCAtPSAyO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGdab25lO1xuXHR9O1xuXG5cdC8qXG5cdCogRXhlY3V0ZXMgdGhlIGhpbnRpbmcgcHJvZ3JhbSBmb3IgYSBjb21wb25lbnQgb2YgYSBtdWx0aS1jb21wb25lbnQgZ2x5cGhcblx0KiBvciBvZiB0aGUgZ2x5cGggaXRzZWxmIGZvciBhIG5vbi1jb21wb25lbnQgZ2x5cGguXG5cdCovXG5cdGV4ZWNDb21wb25lbnQgPSBmdW5jdGlvbihnbHlwaCwgc3RhdGUsIHhTY2FsZSwgeVNjYWxlKVxuXHR7XG5cdCAgICB2YXIgcG9pbnRzID0gZ2x5cGgucG9pbnRzIHx8IFtdO1xuXHQgICAgdmFyIHBMZW4gPSBwb2ludHMubGVuZ3RoO1xuXHQgICAgdmFyIGdab25lID0gc3RhdGUuZ1pvbmUgPSBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBbXTtcblx0ICAgIHZhciBjb250b3VycyA9IHN0YXRlLmNvbnRvdXJzID0gW107XG5cblx0ICAgIC8vIFNjYWxlcyB0aGUgb3JpZ2luYWwgcG9pbnRzIGFuZFxuXHQgICAgLy8gbWFrZXMgY29waWVzIGZvciB0aGUgaGludGVkIHBvaW50cy5cblx0ICAgIHZhciBjcDsgLy8gY3VycmVudCBwb2ludFxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwTGVuOyBpKyspIHtcblx0ICAgICAgICBjcCA9IHBvaW50c1tpXTtcblxuXHQgICAgICAgIGdab25lW2ldID0gbmV3IEhQb2ludChcblx0ICAgICAgICAgICAgY3AueCAqIHhTY2FsZSxcblx0ICAgICAgICAgICAgY3AueSAqIHlTY2FsZSxcblx0ICAgICAgICAgICAgY3AubGFzdFBvaW50T2ZDb250b3VyLFxuXHQgICAgICAgICAgICBjcC5vbkN1cnZlXG5cdCAgICAgICAgKTtcblx0ICAgIH1cblxuXHQgICAgLy8gQ2hhaW4gbGlua3MgdGhlIGNvbnRvdXJzLlxuXHQgICAgdmFyIHNwOyAvLyBzdGFydCBwb2ludFxuXHQgICAgdmFyIG5wOyAvLyBuZXh0IHBvaW50XG5cblx0ICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBMZW47IGkkMSsrKSB7XG5cdCAgICAgICAgY3AgPSBnWm9uZVtpJDFdO1xuXG5cdCAgICAgICAgaWYgKCFzcCkge1xuXHQgICAgICAgICAgICBzcCA9IGNwO1xuXHQgICAgICAgICAgICBjb250b3Vycy5wdXNoKGkkMSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGNwLmxhc3RQb2ludE9mQ29udG91cikge1xuXHQgICAgICAgICAgICBjcC5uZXh0UG9pbnRPbkNvbnRvdXIgPSBzcDtcblx0ICAgICAgICAgICAgc3AucHJldlBvaW50T25Db250b3VyID0gY3A7XG5cdCAgICAgICAgICAgIHNwID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIG5wID0gZ1pvbmVbaSQxICsgMV07XG5cdCAgICAgICAgICAgIGNwLm5leHRQb2ludE9uQ29udG91ciA9IG5wO1xuXHQgICAgICAgICAgICBucC5wcmV2UG9pbnRPbkNvbnRvdXIgPSBjcDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChzdGF0ZS5pbmhpYml0R3JpZEZpdCkgeyByZXR1cm47IH1cblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcblx0ICAgICAgICBjb25zb2xlLmxvZygnUFJPQ0VTU0lORyBHTFlQSCcsIHN0YXRlLnN0YWNrKTtcblx0ICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBwTGVuOyBpJDIrKykge1xuXHQgICAgICAgICAgICBjb25zb2xlLmxvZyhpJDIsIGdab25lW2kkMl0ueCwgZ1pvbmVbaSQyXS55KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGdab25lLnB1c2goXG5cdCAgICAgICAgbmV3IEhQb2ludCgwLCAwKSxcblx0ICAgICAgICBuZXcgSFBvaW50KE1hdGgucm91bmQoZ2x5cGguYWR2YW5jZVdpZHRoICogeFNjYWxlKSwgMClcblx0ICAgICk7XG5cblx0ICAgIGV4ZWMoc3RhdGUpO1xuXG5cdCAgICAvLyBSZW1vdmVzIHRoZSBleHRyYSBwb2ludHMuXG5cdCAgICBnWm9uZS5sZW5ndGggLT0gMjtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcblx0ICAgICAgICBjb25zb2xlLmxvZygnRklOSVNIRUQgR0xZUEgnLCBzdGF0ZS5zdGFjayk7XG5cdCAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgcExlbjsgaSQzKyspIHtcblx0ICAgICAgICAgICAgY29uc29sZS5sb2coaSQzLCBnWm9uZVtpJDNdLngsIGdab25lW2kkM10ueSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHR9O1xuXG5cdC8qXG5cdCogRXhlY3V0ZXMgdGhlIHByb2dyYW0gbG9hZGVkIGluIHN0YXRlLlxuXHQqL1xuXHRleGVjID0gZnVuY3Rpb24oc3RhdGUpIHtcblx0ICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcblxuXHQgICAgaWYgKCFwcm9nKSB7IHJldHVybjsgfVxuXG5cdCAgICB2YXIgcExlbiA9IHByb2cubGVuZ3RoO1xuXHQgICAgdmFyIGlucztcblxuXHQgICAgZm9yIChzdGF0ZS5pcCA9IDA7IHN0YXRlLmlwIDwgcExlbjsgc3RhdGUuaXArKykge1xuXHQgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IHN0YXRlLnN0ZXArKzsgfVxuXHQgICAgICAgIGlucyA9IGluc3RydWN0aW9uVGFibGVbcHJvZ1tzdGF0ZS5pcF1dO1xuXG5cdCAgICAgICAgaWYgKCFpbnMpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuXHQgICAgICAgICAgICAgICAgJ3Vua25vd24gaW5zdHJ1Y3Rpb246IDB4JyArXG5cdCAgICAgICAgICAgICAgICBOdW1iZXIocHJvZ1tzdGF0ZS5pcF0pLnRvU3RyaW5nKDE2KVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlucyhzdGF0ZSk7XG5cblx0ICAgICAgICAvLyB2ZXJ5IGV4dGVuc2l2ZSBkZWJ1Z2dpbmcgZm9yIGVhY2ggc3RlcFxuXHQgICAgICAgIC8qXG5cdCAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcblx0ICAgICAgICAgICAgdmFyIGRhO1xuXHQgICAgICAgICAgICBpZiAoc3RhdGUuZ1pvbmUpIHtcblx0ICAgICAgICAgICAgICAgIGRhID0gW107XG5cdCAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLmdab25lLmxlbmd0aDsgaSsrKVxuXHQgICAgICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgICAgICAgIGRhLnB1c2goaSArICcgJyArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmdab25lW2ldLnggKiA2NCArICcgJyArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmdab25lW2ldLnkgKiA2NCArICcgJyArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5nWm9uZVtpXS54VG91Y2hlZCA/ICd4JyA6ICcnKSArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5nWm9uZVtpXS55VG91Y2hlZCA/ICd5JyA6ICcnKVxuXHQgICAgICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnR1onLCBkYSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoc3RhdGUudFpvbmUpIHtcblx0ICAgICAgICAgICAgICAgIGRhID0gW107XG5cdCAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnRab25lLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGEucHVzaChpICsgJyAnICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudFpvbmVbaV0ueCAqIDY0ICsgJyAnICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudFpvbmVbaV0ueSAqIDY0ICsgJyAnICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLnRab25lW2ldLnhUb3VjaGVkID8gJ3gnIDogJycpICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLnRab25lW2ldLnlUb3VjaGVkID8gJ3knIDogJycpXG5cdCAgICAgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUWicsIGRhKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChzdGF0ZS5zdGFjay5sZW5ndGggPiAxMCkge1xuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhY2subGVuZ3RoLFxuXHQgICAgICAgICAgICAgICAgICAgICcuLi4nLCBzdGF0ZS5zdGFjay5zbGljZShzdGF0ZS5zdGFjay5sZW5ndGggLSAxMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzdGF0ZS5zdGFjay5sZW5ndGgsIHN0YXRlLnN0YWNrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAqL1xuXHQgICAgfVxuXHR9O1xuXG5cdC8qXG5cdCogSW5pdGlhbGl6ZXMgdGhlIHR3aWxpZ2h0IHpvbmUuXG5cdCpcblx0KiBUaGlzIGlzIG9ubHkgZG9uZSBpZiBhIFNaUHggaW5zdHJ1Y3Rpb25cblx0KiByZWZlcnMgdG8gdGhlIHR3aWxpZ2h0IHpvbmUuXG5cdCovXG5cdGZ1bmN0aW9uIGluaXRUWm9uZShzdGF0ZSlcblx0e1xuXHQgICAgdmFyIHRab25lID0gc3RhdGUudFpvbmUgPSBuZXcgQXJyYXkoc3RhdGUuZ1pvbmUubGVuZ3RoKTtcblxuXHQgICAgLy8gbm8gaWRlYSBpZiB0aGlzIGlzIGFjdHVhbGx5IGNvcnJlY3QuLi5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdFpvbmUubGVuZ3RoOyBpKyspXG5cdCAgICB7XG5cdCAgICAgICAgdFpvbmVbaV0gPSBuZXcgSFBvaW50KDAsIDApO1xuXHQgICAgfVxuXHR9XG5cblx0Lypcblx0KiBTa2lwcyB0aGUgaW5zdHJ1Y3Rpb24gcG9pbnRlciBhaGVhZCBvdmVyIGFuIElGL0VMU0UgYmxvY2suXG5cdCogaGFuZGxlRWxzZSAuLiBpZiB0cnVlIGJyZWFrcyBvbiBtYXRjaGluZyBFTFNFXG5cdCovXG5cdGZ1bmN0aW9uIHNraXAoc3RhdGUsIGhhbmRsZUVsc2UpXG5cdHtcblx0ICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcblx0ICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuXHQgICAgdmFyIG5lc3RpbmcgPSAxO1xuXHQgICAgdmFyIGlucztcblxuXHQgICAgZG8ge1xuXHQgICAgICAgIGlucyA9IHByb2dbKytpcF07XG5cdCAgICAgICAgaWYgKGlucyA9PT0gMHg1OCkgLy8gSUZcblx0ICAgICAgICAgICAgeyBuZXN0aW5nKys7IH1cblx0ICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NTkpIC8vIEVJRlxuXHQgICAgICAgICAgICB7IG5lc3RpbmctLTsgfVxuXHQgICAgICAgIGVsc2UgaWYgKGlucyA9PT0gMHg0MCkgLy8gTlBVU0hCXG5cdCAgICAgICAgICAgIHsgaXAgKz0gcHJvZ1tpcCArIDFdICsgMTsgfVxuXHQgICAgICAgIGVsc2UgaWYgKGlucyA9PT0gMHg0MSkgLy8gTlBVU0hXXG5cdCAgICAgICAgICAgIHsgaXAgKz0gMiAqIHByb2dbaXAgKyAxXSArIDE7IH1cblx0ICAgICAgICBlbHNlIGlmIChpbnMgPj0gMHhCMCAmJiBpbnMgPD0gMHhCNykgLy8gUFVTSEJcblx0ICAgICAgICAgICAgeyBpcCArPSBpbnMgLSAweEIwICsgMTsgfVxuXHQgICAgICAgIGVsc2UgaWYgKGlucyA+PSAweEI4ICYmIGlucyA8PSAweEJGKSAvLyBQVVNIV1xuXHQgICAgICAgICAgICB7IGlwICs9IChpbnMgLSAweEI4ICsgMSkgKiAyOyB9XG5cdCAgICAgICAgZWxzZSBpZiAoaGFuZGxlRWxzZSAmJiBuZXN0aW5nID09PSAxICYmIGlucyA9PT0gMHgxQikgLy8gRUxTRVxuXHQgICAgICAgICAgICB7IGJyZWFrOyB9XG5cdCAgICB9IHdoaWxlIChuZXN0aW5nID4gMCk7XG5cblx0ICAgIHN0YXRlLmlwID0gaXA7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXG5cdCogICAgICAgICAgQW5kIHRoZW4gYSBsb3Qgb2YgaW5zdHJ1Y3Rpb25zLi4uICAgICAgICAgICAgICAgICpcblx0Ki0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8vIFNWVENBW2FdIFNldCBmcmVlZG9tIGFuZCBwcm9qZWN0aW9uIFZlY3RvcnMgVG8gQ29vcmRpbmF0ZSBBeGlzXG5cdC8vIDB4MDAtMHgwMVxuXHRmdW5jdGlvbiBTVlRDQSh2LCBzdGF0ZSkge1xuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NWVENBWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cblx0ICAgIHN0YXRlLmZ2ID0gc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSB2O1xuXHR9XG5cblx0Ly8gU1BWVENBW2FdIFNldCBQcm9qZWN0aW9uIFZlY3RvciB0byBDb29yZGluYXRlIEF4aXNcblx0Ly8gMHgwMi0weDAzXG5cdGZ1bmN0aW9uIFNQVlRDQSh2LCBzdGF0ZSkge1xuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVlRDQVsnICsgdi5heGlzICsgJ10nKTsgfVxuXG5cdCAgICBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IHY7XG5cdH1cblxuXHQvLyBTRlZUQ0FbYV0gU2V0IEZyZWVkb20gVmVjdG9yIHRvIENvb3JkaW5hdGUgQXhpc1xuXHQvLyAweDA0LTB4MDVcblx0ZnVuY3Rpb24gU0ZWVENBKHYsIHN0YXRlKSB7XG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0ZWVENBWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cblx0ICAgIHN0YXRlLmZ2ID0gdjtcblx0fVxuXG5cdC8vIFNQVlRMW2FdIFNldCBQcm9qZWN0aW9uIFZlY3RvciBUbyBMaW5lXG5cdC8vIDB4MDYtMHgwN1xuXHRmdW5jdGlvbiBTUFZUTChhLCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgcDJpID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcDFpID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcDIgPSBzdGF0ZS56MltwMmldO1xuXHQgICAgdmFyIHAxID0gc3RhdGUuejFbcDFpXTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coJ1NQVlRMWycgKyBhICsgJ10nLCBwMmksIHAxaSk7IH1cblxuXHQgICAgdmFyIGR4O1xuXHQgICAgdmFyIGR5O1xuXG5cdCAgICBpZiAoIWEpIHtcblx0ICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuXHQgICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG5cdCAgICAgICAgZHkgPSBwMS54IC0gcDIueDtcblx0ICAgIH1cblxuXHQgICAgc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG5cdH1cblxuXHQvLyBTRlZUTFthXSBTZXQgRnJlZWRvbSBWZWN0b3IgVG8gTGluZVxuXHQvLyAweDA4LTB4MDlcblx0ZnVuY3Rpb24gU0ZWVEwoYSwgc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIHAyaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHAyID0gc3RhdGUuejJbcDJpXTtcblx0ICAgIHZhciBwMSA9IHN0YXRlLnoxW3AxaV07XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCdTRlZUTFsnICsgYSArICddJywgcDJpLCBwMWkpOyB9XG5cblx0ICAgIHZhciBkeDtcblx0ICAgIHZhciBkeTtcblxuXHQgICAgaWYgKCFhKSB7XG5cdCAgICAgICAgZHggPSBwMS54IC0gcDIueDtcblx0ICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBkeCA9IHAyLnkgLSBwMS55O1xuXHQgICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLmZ2ID0gZ2V0VW5pdFZlY3RvcihkeCwgZHkpO1xuXHR9XG5cblx0Ly8gU1BWRlNbXSBTZXQgUHJvamVjdGlvbiBWZWN0b3IgRnJvbSBTdGFja1xuXHQvLyAweDBBXG5cdGZ1bmN0aW9uIFNQVkZTKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciB5ID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgeCA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1BWRlNbXScsIHksIHgpOyB9XG5cblx0ICAgIHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gZ2V0VW5pdFZlY3Rvcih4LCB5KTtcblx0fVxuXG5cdC8vIFNGVkZTW10gU2V0IEZyZWVkb20gVmVjdG9yIEZyb20gU3RhY2tcblx0Ly8gMHgwQlxuXHRmdW5jdGlvbiBTRlZGUyhzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgeSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHggPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVkZTW10nLCB5LCB4KTsgfVxuXG5cdCAgICBzdGF0ZS5mdiA9IGdldFVuaXRWZWN0b3IoeCwgeSk7XG5cdH1cblxuXHQvLyBHUFZbXSBHZXQgUHJvamVjdGlvbiBWZWN0b3Jcblx0Ly8gMHgwQ1xuXHRmdW5jdGlvbiBHUFYoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHUFZbXScpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2gocHYueCAqIDB4NDAwMCk7XG5cdCAgICBzdGFjay5wdXNoKHB2LnkgKiAweDQwMDApO1xuXHR9XG5cblx0Ly8gR0ZWW10gR2V0IEZyZWVkb20gVmVjdG9yXG5cdC8vIDB4MENcblx0ZnVuY3Rpb24gR0ZWKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR0ZWW10nKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKGZ2LnggKiAweDQwMDApO1xuXHQgICAgc3RhY2sucHVzaChmdi55ICogMHg0MDAwKTtcblx0fVxuXG5cdC8vIFNGVlRQVltdIFNldCBGcmVlZG9tIFZlY3RvciBUbyBQcm9qZWN0aW9uIFZlY3RvclxuXHQvLyAweDBFXG5cdGZ1bmN0aW9uIFNGVlRQVihzdGF0ZSkge1xuXHQgICAgc3RhdGUuZnYgPSBzdGF0ZS5wdjtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NGVlRQVltdJyk7IH1cblx0fVxuXG5cdC8vIElTRUNUW10gbW92ZXMgcG9pbnQgcCB0byB0aGUgSW50ZXJTRUNUaW9uIG9mIHR3byBsaW5lc1xuXHQvLyAweDBGXG5cdGZ1bmN0aW9uIElTRUNUKHN0YXRlKVxuXHR7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBwYTBpID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcGExaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHBiMGkgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBwYjFpID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciB6MCA9IHN0YXRlLnowO1xuXHQgICAgdmFyIHoxID0gc3RhdGUuejE7XG5cdCAgICB2YXIgcGEwID0gejBbcGEwaV07XG5cdCAgICB2YXIgcGExID0gejBbcGExaV07XG5cdCAgICB2YXIgcGIwID0gejFbcGIwaV07XG5cdCAgICB2YXIgcGIxID0gejFbcGIxaV07XG5cdCAgICB2YXIgcCA9IHN0YXRlLnoyW3BpXTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coJ0lTRUNUW10sICcsIHBhMGksIHBhMWksIHBiMGksIHBiMWksIHBpKTsgfVxuXG5cdCAgICAvLyBtYXRoIGZyb21cblx0ICAgIC8vIGVuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lJUUyJTgwJTkzbGluZV9pbnRlcnNlY3Rpb24jR2l2ZW5fdHdvX3BvaW50c19vbl9lYWNoX2xpbmVcblxuXHQgICAgdmFyIHgxID0gcGEwLng7XG5cdCAgICB2YXIgeTEgPSBwYTAueTtcblx0ICAgIHZhciB4MiA9IHBhMS54O1xuXHQgICAgdmFyIHkyID0gcGExLnk7XG5cdCAgICB2YXIgeDMgPSBwYjAueDtcblx0ICAgIHZhciB5MyA9IHBiMC55O1xuXHQgICAgdmFyIHg0ID0gcGIxLng7XG5cdCAgICB2YXIgeTQgPSBwYjEueTtcblxuXHQgICAgdmFyIGRpdiA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcblx0ICAgIHZhciBmMSA9IHgxICogeTIgLSB5MSAqIHgyO1xuXHQgICAgdmFyIGYyID0geDMgKiB5NCAtIHkzICogeDQ7XG5cblx0ICAgIHAueCA9IChmMSAqICh4MyAtIHg0KSAtIGYyICogKHgxIC0geDIpKSAvIGRpdjtcblx0ICAgIHAueSA9IChmMSAqICh5MyAtIHk0KSAtIGYyICogKHkxIC0geTIpKSAvIGRpdjtcblx0fVxuXG5cdC8vIFNSUDBbXSBTZXQgUmVmZXJlbmNlIFBvaW50IDBcblx0Ly8gMHgxMFxuXHRmdW5jdGlvbiBTUlAwKHN0YXRlKSB7XG5cdCAgICBzdGF0ZS5ycDAgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDBbXScsIHN0YXRlLnJwMCk7IH1cblx0fVxuXG5cdC8vIFNSUDFbXSBTZXQgUmVmZXJlbmNlIFBvaW50IDFcblx0Ly8gMHgxMVxuXHRmdW5jdGlvbiBTUlAxKHN0YXRlKSB7XG5cdCAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDFbXScsIHN0YXRlLnJwMSk7IH1cblx0fVxuXG5cdC8vIFNSUDFbXSBTZXQgUmVmZXJlbmNlIFBvaW50IDJcblx0Ly8gMHgxMlxuXHRmdW5jdGlvbiBTUlAyKHN0YXRlKSB7XG5cdCAgICBzdGF0ZS5ycDIgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDJbXScsIHN0YXRlLnJwMik7IH1cblx0fVxuXG5cdC8vIFNaUDBbXSBTZXQgWm9uZSBQb2ludGVyIDBcblx0Ly8gMHgxM1xuXHRmdW5jdGlvbiBTWlAwKHN0YXRlKSB7XG5cdCAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQMFtdJywgbik7IH1cblxuXHQgICAgc3RhdGUuenAwID0gbjtcblxuXHQgICAgc3dpdGNoIChuKSB7XG5cdCAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cblx0ICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS50Wm9uZTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAxIDpcblx0ICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS5nWm9uZTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdCA6XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lIHBvaW50ZXInKTtcblx0ICAgIH1cblx0fVxuXG5cdC8vIFNaUDFbXSBTZXQgWm9uZSBQb2ludGVyIDFcblx0Ly8gMHgxNFxuXHRmdW5jdGlvbiBTWlAxKHN0YXRlKSB7XG5cdCAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQMVtdJywgbik7IH1cblxuXHQgICAgc3RhdGUuenAxID0gbjtcblxuXHQgICAgc3dpdGNoIChuKSB7XG5cdCAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cblx0ICAgICAgICAgICAgc3RhdGUuejEgPSBzdGF0ZS50Wm9uZTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAxIDpcblx0ICAgICAgICAgICAgc3RhdGUuejEgPSBzdGF0ZS5nWm9uZTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdCA6XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lIHBvaW50ZXInKTtcblx0ICAgIH1cblx0fVxuXG5cdC8vIFNaUDJbXSBTZXQgWm9uZSBQb2ludGVyIDJcblx0Ly8gMHgxNVxuXHRmdW5jdGlvbiBTWlAyKHN0YXRlKSB7XG5cdCAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQMltdJywgbik7IH1cblxuXHQgICAgc3RhdGUuenAyID0gbjtcblxuXHQgICAgc3dpdGNoIChuKSB7XG5cdCAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cblx0ICAgICAgICAgICAgc3RhdGUuejIgPSBzdGF0ZS50Wm9uZTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAxIDpcblx0ICAgICAgICAgICAgc3RhdGUuejIgPSBzdGF0ZS5nWm9uZTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdCA6XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lIHBvaW50ZXInKTtcblx0ICAgIH1cblx0fVxuXG5cdC8vIFNaUFNbXSBTZXQgWm9uZSBQb2ludGVyU1xuXHQvLyAweDE2XG5cdGZ1bmN0aW9uIFNaUFMoc3RhdGUpIHtcblx0ICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlBTW10nLCBuKTsgfVxuXG5cdCAgICBzdGF0ZS56cDAgPSBzdGF0ZS56cDEgPSBzdGF0ZS56cDIgPSBuO1xuXG5cdCAgICBzd2l0Y2ggKG4pIHtcblx0ICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgIGlmICghc3RhdGUudFpvbmUpIHsgaW5pdFRab25lKHN0YXRlKTsgfVxuXHQgICAgICAgICAgICBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBzdGF0ZS50Wm9uZTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAxIDpcblx0ICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gc3RhdGUuZ1pvbmU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQgOlxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG5cdCAgICB9XG5cdH1cblxuXHQvLyBTTE9PUFtdIFNldCBMT09QIHZhcmlhYmxlXG5cdC8vIDB4MTdcblx0ZnVuY3Rpb24gU0xPT1Aoc3RhdGUpIHtcblx0ICAgIHN0YXRlLmxvb3AgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NMT09QW10nLCBzdGF0ZS5sb29wKTsgfVxuXHR9XG5cblx0Ly8gUlRHW10gUm91bmQgVG8gR3JpZFxuXHQvLyAweDE4XG5cdGZ1bmN0aW9uIFJURyhzdGF0ZSkge1xuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JUR1tdJyk7IH1cblxuXHQgICAgc3RhdGUucm91bmQgPSByb3VuZFRvR3JpZDtcblx0fVxuXG5cdC8vIFJUSEdbXSBSb3VuZCBUbyBIYWxmIEdyaWRcblx0Ly8gMHgxOVxuXHRmdW5jdGlvbiBSVEhHKHN0YXRlKSB7XG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlRIR1tdJyk7IH1cblxuXHQgICAgc3RhdGUucm91bmQgPSByb3VuZFRvSGFsZkdyaWQ7XG5cdH1cblxuXHQvLyBTTURbXSBTZXQgTWluaW11bSBEaXN0YW5jZVxuXHQvLyAweDFBXG5cdGZ1bmN0aW9uIFNNRChzdGF0ZSkge1xuXHQgICAgdmFyIGQgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NNRFtdJywgZCk7IH1cblxuXHQgICAgc3RhdGUubWluRGlzID0gZCAvIDB4NDA7XG5cdH1cblxuXHQvLyBFTFNFW10gRUxTRSBjbGF1c2Vcblx0Ly8gMHgxQlxuXHRmdW5jdGlvbiBFTFNFKHN0YXRlKSB7XG5cdCAgICAvLyBUaGlzIGluc3RydWN0aW9uIGhhcyBiZWVuIHJlYWNoZWQgYnkgZXhlY3V0aW5nIGEgdGhlbiBicmFuY2hcblx0ICAgIC8vIHNvIGl0IGp1c3Qgc2tpcHMgYWhlYWQgdW50aWwgbWF0Y2hpbmcgRUlGLlxuXHQgICAgLy9cblx0ICAgIC8vIEluIGNhc2UgdGhlIElGIHdhcyBuZWdhdGl2ZSB0aGUgSUZbXSBpbnN0cnVjdGlvbiBhbHJlYWR5XG5cdCAgICAvLyBza2lwcGVkIGZvcndhcmQgb3ZlciB0aGUgRUxTRVtdXG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFTFNFW10nKTsgfVxuXG5cdCAgICBza2lwKHN0YXRlLCBmYWxzZSk7XG5cdH1cblxuXHQvLyBKTVBSW10gSnVNUCBSZWxhdGl2ZVxuXHQvLyAweDFDXG5cdGZ1bmN0aW9uIEpNUFIoc3RhdGUpIHtcblx0ICAgIHZhciBvID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdKTVBSW10nLCBvKTsgfVxuXG5cdCAgICAvLyBBIGp1bXAgYnkgMSB3b3VsZCBkbyBub3RoaW5nLlxuXHQgICAgc3RhdGUuaXAgKz0gbyAtIDE7XG5cdH1cblxuXHQvLyBTQ1ZUQ0lbXSBTZXQgQ29udHJvbCBWYWx1ZSBUYWJsZSBDdXQtSW5cblx0Ly8gMHgxRFxuXHRmdW5jdGlvbiBTQ1ZUQ0koc3RhdGUpIHtcblx0ICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTQ1ZUQ0lbXScsIG4pOyB9XG5cblx0ICAgIHN0YXRlLmN2Q3V0SW4gPSBuIC8gMHg0MDtcblx0fVxuXG5cdC8vIERVUFtdIERVUGxpY2F0ZSB0b3Agc3RhY2sgZWxlbWVudFxuXHQvLyAweDIwXG5cdGZ1bmN0aW9uIERVUChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdEVVBbXScpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pO1xuXHR9XG5cblx0Ly8gUE9QW10gUE9QIHRvcCBzdGFjayBlbGVtZW50XG5cdC8vIDB4MjFcblx0ZnVuY3Rpb24gUE9QKHN0YXRlKSB7XG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUE9QW10nKTsgfVxuXG5cdCAgICBzdGF0ZS5zdGFjay5wb3AoKTtcblx0fVxuXG5cdC8vIENMRUFSW10gQ0xFQVIgdGhlIHN0YWNrXG5cdC8vIDB4MjJcblx0ZnVuY3Rpb24gQ0xFQVIoc3RhdGUpIHtcblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDTEVBUltdJyk7IH1cblxuXHQgICAgc3RhdGUuc3RhY2subGVuZ3RoID0gMDtcblx0fVxuXG5cdC8vIFNXQVBbXSBTV0FQIHRoZSB0b3AgdHdvIGVsZW1lbnRzIG9uIHRoZSBzdGFja1xuXHQvLyAweDIzXG5cdGZ1bmN0aW9uIFNXQVAoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG5cdCAgICB2YXIgYSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIGIgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NXQVBbXScpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goYSk7XG5cdCAgICBzdGFjay5wdXNoKGIpO1xuXHR9XG5cblx0Ly8gREVQVEhbXSBERVBUSCBvZiB0aGUgc3RhY2tcblx0Ly8gMHgyNFxuXHRmdW5jdGlvbiBERVBUSChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERVBUSFtdJyk7IH1cblxuXHQgICAgc3RhY2sucHVzaChzdGFjay5sZW5ndGgpO1xuXHR9XG5cblx0Ly8gTE9PUENBTExbXSBMT09QQ0FMTCBmdW5jdGlvblxuXHQvLyAweDJBXG5cdGZ1bmN0aW9uIExPT1BDQUxMKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBmbiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIGMgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0xPT1BDQUxMW10nLCBmbiwgYyk7IH1cblxuXHQgICAgLy8gc2F2ZXMgY2FsbGVycyBwcm9ncmFtXG5cdCAgICB2YXIgY2lwID0gc3RhdGUuaXA7XG5cdCAgICB2YXIgY3Byb2cgPSBzdGF0ZS5wcm9nO1xuXG5cdCAgICBzdGF0ZS5wcm9nID0gc3RhdGUuZnVuY3NbZm5dO1xuXG5cdCAgICAvLyBleGVjdXRlcyB0aGUgZnVuY3Rpb25cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYzsgaSsrKSB7XG5cdCAgICAgICAgZXhlYyhzdGF0ZSk7XG5cblx0ICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhcblx0ICAgICAgICAgICAgKytzdGF0ZS5zdGVwLFxuXHQgICAgICAgICAgICBpICsgMSA8IGMgPyAnbmV4dCBsb29wY2FsbCcgOiAnZG9uZSBsb29wY2FsbCcsXG5cdCAgICAgICAgICAgIGlcblx0ICAgICAgICApOyB9XG5cdCAgICB9XG5cblx0ICAgIC8vIHJlc3RvcmVzIHRoZSBjYWxsZXJzIHByb2dyYW1cblx0ICAgIHN0YXRlLmlwID0gY2lwO1xuXHQgICAgc3RhdGUucHJvZyA9IGNwcm9nO1xuXHR9XG5cblx0Ly8gQ0FMTFtdIENBTEwgZnVuY3Rpb25cblx0Ly8gMHgyQlxuXHRmdW5jdGlvbiBDQUxMKHN0YXRlKSB7XG5cdCAgICB2YXIgZm4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NBTExbXScsIGZuKTsgfVxuXG5cdCAgICAvLyBzYXZlcyBjYWxsZXJzIHByb2dyYW1cblx0ICAgIHZhciBjaXAgPSBzdGF0ZS5pcDtcblx0ICAgIHZhciBjcHJvZyA9IHN0YXRlLnByb2c7XG5cblx0ICAgIHN0YXRlLnByb2cgPSBzdGF0ZS5mdW5jc1tmbl07XG5cblx0ICAgIC8vIGV4ZWN1dGVzIHRoZSBmdW5jdGlvblxuXHQgICAgZXhlYyhzdGF0ZSk7XG5cblx0ICAgIC8vIHJlc3RvcmVzIHRoZSBjYWxsZXJzIHByb2dyYW1cblx0ICAgIHN0YXRlLmlwID0gY2lwO1xuXHQgICAgc3RhdGUucHJvZyA9IGNwcm9nO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygrK3N0YXRlLnN0ZXAsICdyZXR1cm5pbmcgZnJvbScsIGZuKTsgfVxuXHR9XG5cblx0Ly8gQ0lOREVYW10gQ29weSB0aGUgSU5ERVhlZCBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG5cdC8vIDB4MjVcblx0ZnVuY3Rpb24gQ0lOREVYKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBrID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDSU5ERVhbXScsIGspOyB9XG5cblx0ICAgIC8vIEluIGNhc2Ugb2YgayA9PSAxLCBpdCBjb3BpZXMgdGhlIGxhc3QgZWxlbWVudCBhZnRlciBwb3BwaW5nXG5cdCAgICAvLyB0aHVzIHN0YWNrLmxlbmd0aCAtIGsuXG5cdCAgICBzdGFjay5wdXNoKHN0YWNrW3N0YWNrLmxlbmd0aCAtIGtdKTtcblx0fVxuXG5cdC8vIE1JTkRFWFtdIE1vdmUgdGhlIElOREVYZWQgZWxlbWVudCB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuXHQvLyAweDI2XG5cdGZ1bmN0aW9uIE1JTkRFWChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgayA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTUlOREVYW10nLCBrKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSBrLCAxKVswXSk7XG5cdH1cblxuXHQvLyBGREVGW10gRnVuY3Rpb24gREVGaW5pdGlvblxuXHQvLyAweDJDXG5cdGZ1bmN0aW9uIEZERUYoc3RhdGUpIHtcblx0ICAgIGlmIChzdGF0ZS5lbnYgIT09ICdmcGdtJykgeyB0aHJvdyBuZXcgRXJyb3IoJ0ZERUYgbm90IGFsbG93ZWQgaGVyZScpOyB9XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcblx0ICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuXG5cdCAgICB2YXIgZm4gPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBpcEJlZ2luID0gaXA7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdGREVGW10nLCBmbik7IH1cblxuXHQgICAgd2hpbGUgKHByb2dbKytpcF0gIT09IDB4MkQpeyB9XG5cblx0ICAgIHN0YXRlLmlwID0gaXA7XG5cdCAgICBzdGF0ZS5mdW5jc1tmbl0gPSBwcm9nLnNsaWNlKGlwQmVnaW4gKyAxLCBpcCk7XG5cdH1cblxuXHQvLyBNREFQW2FdIE1vdmUgRGlyZWN0IEFic29sdXRlIFBvaW50XG5cdC8vIDB4MkUtMHgyRlxuXHRmdW5jdGlvbiBNREFQKHJvdW5kLCBzdGF0ZSkge1xuXHQgICAgdmFyIHBpID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcCA9IHN0YXRlLnowW3BpXTtcblx0ICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuXHQgICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNREFQWycgKyByb3VuZCArICddJywgcGkpOyB9XG5cblx0ICAgIHZhciBkID0gcHYuZGlzdGFuY2UocCwgSFBaZXJvKTtcblxuXHQgICAgaWYgKHJvdW5kKSB7IGQgPSBzdGF0ZS5yb3VuZChkKTsgfVxuXG5cdCAgICBmdi5zZXRSZWxhdGl2ZShwLCBIUFplcm8sIGQsIHB2KTtcblx0ICAgIGZ2LnRvdWNoKHApO1xuXG5cdCAgICBzdGF0ZS5ycDAgPSBzdGF0ZS5ycDEgPSBwaTtcblx0fVxuXG5cdC8vIElVUFthXSBJbnRlcnBvbGF0ZSBVbnRvdWNoZWQgUG9pbnRzIHRocm91Z2ggdGhlIG91dGxpbmVcblx0Ly8gMHgzMFxuXHRmdW5jdGlvbiBJVVAodiwgc3RhdGUpIHtcblx0ICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuXHQgICAgdmFyIHBMZW4gPSB6Mi5sZW5ndGggLSAyO1xuXHQgICAgdmFyIGNwO1xuXHQgICAgdmFyIHBwO1xuXHQgICAgdmFyIG5wO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnSVVQWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKSB7XG5cdCAgICAgICAgY3AgPSB6MltpXTsgLy8gY3VycmVudCBwb2ludFxuXG5cdCAgICAgICAgLy8gaWYgdGhpcyBwb2ludCBoYXMgYmVlbiB0b3VjaGVkIGdvIG9uXG5cdCAgICAgICAgaWYgKHYudG91Y2hlZChjcCkpIHsgY29udGludWU7IH1cblxuXHQgICAgICAgIHBwID0gY3AucHJldlRvdWNoZWQodik7XG5cblx0ICAgICAgICAvLyBubyBwb2ludCBvbiB0aGUgY29udG91ciBoYXMgYmVlbiB0b3VjaGVkP1xuXHQgICAgICAgIGlmIChwcCA9PT0gY3ApIHsgY29udGludWU7IH1cblxuXHQgICAgICAgIG5wID0gY3AubmV4dFRvdWNoZWQodik7XG5cblx0ICAgICAgICBpZiAocHAgPT09IG5wKSB7XG5cdCAgICAgICAgICAgIC8vIG9ubHkgb25lIHBvaW50IG9uIHRoZSBjb250b3VyIGhhcyBiZWVuIHRvdWNoZWRcblx0ICAgICAgICAgICAgLy8gc28gc2ltcGx5IG1vdmVzIHRoZSBwb2ludCBsaWtlIHRoYXRcblxuXHQgICAgICAgICAgICB2LnNldFJlbGF0aXZlKGNwLCBjcCwgdi5kaXN0YW5jZShwcCwgcHAsIGZhbHNlLCB0cnVlKSwgdiwgdHJ1ZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdi5pbnRlcnBvbGF0ZShjcCwgcHAsIG5wLCB2KTtcblx0ICAgIH1cblx0fVxuXG5cdC8vIFNIUFtdIFNIaWZ0IFBvaW50IHVzaW5nIHJlZmVyZW5jZSBwb2ludFxuXHQvLyAweDMyLTB4MzNcblx0ZnVuY3Rpb24gU0hQKGEsIHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBycGkgPSBhID8gc3RhdGUucnAxIDogc3RhdGUucnAyO1xuXHQgICAgdmFyIHJwID0gKGEgPyBzdGF0ZS56MCA6IHN0YXRlLnoxKVtycGldO1xuXHQgICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG5cdCAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblx0ICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcblx0ICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuXG5cdCAgICB3aGlsZSAobG9vcC0tKVxuXHQgICAge1xuXHQgICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgIHZhciBwID0gejJbcGldO1xuXG5cdCAgICAgICAgdmFyIGQgPSBwdi5kaXN0YW5jZShycCwgcnAsIGZhbHNlLCB0cnVlKTtcblx0ICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkLCBwdik7XG5cdCAgICAgICAgZnYudG91Y2gocCk7XG5cblx0ICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuXHQgICAgICAgICAgICBjb25zb2xlLmxvZyhcblx0ICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG5cdCAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgP1xuXHQgICAgICAgICAgICAgICAgICAgJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDpcblx0ICAgICAgICAgICAgICAgICAgICcnXG5cdCAgICAgICAgICAgICAgICApICtcblx0ICAgICAgICAgICAgICAgICdTSFBbJyArIChhID8gJ3JwMScgOiAncnAyJykgKyAnXScsIHBpXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBzdGF0ZS5sb29wID0gMTtcblx0fVxuXG5cdC8vIFNIQ1tdIFNIaWZ0IENvbnRvdXIgdXNpbmcgcmVmZXJlbmNlIHBvaW50XG5cdC8vIDB4MzYtMHgzN1xuXHRmdW5jdGlvbiBTSEMoYSwgc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIHJwaSA9IGEgPyBzdGF0ZS5ycDEgOiBzdGF0ZS5ycDI7XG5cdCAgICB2YXIgcnAgPSAoYSA/IHN0YXRlLnowIDogc3RhdGUuejEpW3JwaV07XG5cdCAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblx0ICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXHQgICAgdmFyIGNpID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgc3AgPSBzdGF0ZS56MltzdGF0ZS5jb250b3Vyc1tjaV1dO1xuXHQgICAgdmFyIHAgPSBzcDtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NIQ1snICsgYSArICddJywgY2kpOyB9XG5cblx0ICAgIHZhciBkID0gcHYuZGlzdGFuY2UocnAsIHJwLCBmYWxzZSwgdHJ1ZSk7XG5cblx0ICAgIGRvIHtcblx0ICAgICAgICBpZiAocCAhPT0gcnApIHsgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpOyB9XG5cdCAgICAgICAgcCA9IHAubmV4dFBvaW50T25Db250b3VyO1xuXHQgICAgfSB3aGlsZSAocCAhPT0gc3ApO1xuXHR9XG5cblx0Ly8gU0haW10gU0hpZnQgWm9uZSB1c2luZyByZWZlcmVuY2UgcG9pbnRcblx0Ly8gMHgzNi0weDM3XG5cdGZ1bmN0aW9uIFNIWihhLCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgcnBpID0gYSA/IHN0YXRlLnJwMSA6IHN0YXRlLnJwMjtcblx0ICAgIHZhciBycCA9IChhID8gc3RhdGUuejAgOiBzdGF0ZS56MSlbcnBpXTtcblx0ICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuXHQgICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cblx0ICAgIHZhciBlID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTSFpbJyArIGEgKyAnXScsIGUpOyB9XG5cblx0ICAgIHZhciB6O1xuXHQgICAgc3dpdGNoIChlKSB7XG5cdCAgICAgICAgY2FzZSAwIDogeiA9IHN0YXRlLnRab25lOyBicmVhaztcblx0ICAgICAgICBjYXNlIDEgOiB6ID0gc3RhdGUuZ1pvbmU7IGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQgOiB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZScpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcDtcblx0ICAgIHZhciBkID0gcHYuZGlzdGFuY2UocnAsIHJwLCBmYWxzZSwgdHJ1ZSk7XG5cdCAgICB2YXIgcExlbiA9IHoubGVuZ3RoIC0gMjtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKVxuXHQgICAge1xuXHQgICAgICAgIHAgPSB6W2ldO1xuXHQgICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTtcblx0ICAgICAgICAvL2lmIChwICE9PSBycCkgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuXHQgICAgfVxuXHR9XG5cblx0Ly8gU0hQSVhbXSBTSGlmdCBwb2ludCBieSBhIFBJWGVsIGFtb3VudFxuXHQvLyAweDM4XG5cdGZ1bmN0aW9uIFNIUElYKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcblx0ICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuXHQgICAgdmFyIGQgPSBzdGFjay5wb3AoKSAvIDB4NDA7XG5cdCAgICB2YXIgejIgPSBzdGF0ZS56MjtcblxuXHQgICAgd2hpbGUgKGxvb3AtLSkge1xuXHQgICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgIHZhciBwID0gejJbcGldO1xuXG5cdCAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcblx0ICAgICAgICAgICAgY29uc29sZS5sb2coXG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuXHQgICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcblx0ICAgICAgICAgICAgICAgICdTSFBJWFtdJywgcGksIGRcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkKTtcblx0ICAgICAgICBmdi50b3VjaChwKTtcblx0ICAgIH1cblxuXHQgICAgc3RhdGUubG9vcCA9IDE7XG5cdH1cblxuXHQvLyBJUFtdIEludGVycG9sYXRlIFBvaW50XG5cdC8vIDB4Mzlcblx0ZnVuY3Rpb24gSVAoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIHJwMWkgPSBzdGF0ZS5ycDE7XG5cdCAgICB2YXIgcnAyaSA9IHN0YXRlLnJwMjtcblx0ICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcblx0ICAgIHZhciBycDEgPSBzdGF0ZS56MFtycDFpXTtcblx0ICAgIHZhciBycDIgPSBzdGF0ZS56MVtycDJpXTtcblx0ICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuXHQgICAgdmFyIHB2ID0gc3RhdGUuZHB2O1xuXHQgICAgdmFyIHoyID0gc3RhdGUuejI7XG5cblx0ICAgIHdoaWxlIChsb29wLS0pIHtcblx0ICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICB2YXIgcCA9IHoyW3BpXTtcblxuXHQgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuXHQgICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcblx0ICAgICAgICAgICAgICAgIChzdGF0ZS5sb29wID4gMSA/ICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6ICcnKSArXG5cdCAgICAgICAgICAgICAgICAnSVBbXScsIHBpLCBycDFpLCAnPC0+JywgcnAyaVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ2LmludGVycG9sYXRlKHAsIHJwMSwgcnAyLCBwdik7XG5cblx0ICAgICAgICBmdi50b3VjaChwKTtcblx0ICAgIH1cblxuXHQgICAgc3RhdGUubG9vcCA9IDE7XG5cdH1cblxuXHQvLyBNU0lSUFthXSBNb3ZlIFN0YWNrIEluZGlyZWN0IFJlbGF0aXZlIFBvaW50XG5cdC8vIDB4M0EtMHgzQlxuXHRmdW5jdGlvbiBNU0lSUChhLCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgZCA9IHN0YWNrLnBvcCgpIC8gNjQ7XG5cdCAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBwID0gc3RhdGUuejFbcGldO1xuXHQgICAgdmFyIHJwMCA9IHN0YXRlLnowW3N0YXRlLnJwMF07XG5cdCAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblx0ICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG5cdCAgICBmdi5zZXRSZWxhdGl2ZShwLCBycDAsIGQsIHB2KTtcblx0ICAgIGZ2LnRvdWNoKHApO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTVNJUlBbJyArIGEgKyAnXScsIGQsIHBpKTsgfVxuXG5cdCAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5ycDA7XG5cdCAgICBzdGF0ZS5ycDIgPSBwaTtcblx0ICAgIGlmIChhKSB7IHN0YXRlLnJwMCA9IHBpOyB9XG5cdH1cblxuXHQvLyBBTElHTlJQW10gQWxpZ24gdG8gcmVmZXJlbmNlIHBvaW50LlxuXHQvLyAweDNDXG5cdGZ1bmN0aW9uIEFMSUdOUlAoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIHJwMGkgPSBzdGF0ZS5ycDA7XG5cdCAgICB2YXIgcnAwID0gc3RhdGUuejBbcnAwaV07XG5cdCAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG5cdCAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcblx0ICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXHQgICAgdmFyIHoxID0gc3RhdGUuejE7XG5cblx0ICAgIHdoaWxlIChsb29wLS0pIHtcblx0ICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICB2YXIgcCA9IHoxW3BpXTtcblxuXHQgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuXHQgICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcblx0ICAgICAgICAgICAgICAgIChzdGF0ZS5sb29wID4gMSA/ICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6ICcnKSArXG5cdCAgICAgICAgICAgICAgICAnQUxJR05SUFtdJywgcGlcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBycDAsIDAsIHB2KTtcblx0ICAgICAgICBmdi50b3VjaChwKTtcblx0ICAgIH1cblxuXHQgICAgc3RhdGUubG9vcCA9IDE7XG5cdH1cblxuXHQvLyBSVEdbXSBSb3VuZCBUbyBEb3VibGUgR3JpZFxuXHQvLyAweDNEXG5cdGZ1bmN0aW9uIFJUREcoc3RhdGUpIHtcblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVERHW10nKTsgfVxuXG5cdCAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9Eb3VibGVHcmlkO1xuXHR9XG5cblx0Ly8gTUlBUFthXSBNb3ZlIEluZGlyZWN0IEFic29sdXRlIFBvaW50XG5cdC8vIDB4M0UtMHgzRlxuXHRmdW5jdGlvbiBNSUFQKHJvdW5kLCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcCA9IHN0YXRlLnowW3BpXTtcblx0ICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuXHQgICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cdCAgICB2YXIgY3YgPSBzdGF0ZS5jdnRbbl07XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG5cdCAgICAgICAgY29uc29sZS5sb2coXG5cdCAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG5cdCAgICAgICAgICAgICdNSUFQWycgKyByb3VuZCArICddJyxcblx0ICAgICAgICAgICAgbiwgJygnLCBjdiwgJyknLCBwaVxuXHQgICAgICAgICk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBkID0gcHYuZGlzdGFuY2UocCwgSFBaZXJvKTtcblxuXHQgICAgaWYgKHJvdW5kKSB7XG5cdCAgICAgICAgaWYgKE1hdGguYWJzKGQgLSBjdikgPCBzdGF0ZS5jdkN1dEluKSB7IGQgPSBjdjsgfVxuXG5cdCAgICAgICAgZCA9IHN0YXRlLnJvdW5kKGQpO1xuXHQgICAgfVxuXG5cdCAgICBmdi5zZXRSZWxhdGl2ZShwLCBIUFplcm8sIGQsIHB2KTtcblxuXHQgICAgaWYgKHN0YXRlLnpwMCA9PT0gMCkge1xuXHQgICAgICAgIHAueG8gPSBwLng7XG5cdCAgICAgICAgcC55byA9IHAueTtcblx0ICAgIH1cblxuXHQgICAgZnYudG91Y2gocCk7XG5cblx0ICAgIHN0YXRlLnJwMCA9IHN0YXRlLnJwMSA9IHBpO1xuXHR9XG5cblx0Ly8gTlBVU0JbXSBQVVNIIE4gQnl0ZXNcblx0Ly8gMHg0MFxuXHRmdW5jdGlvbiBOUFVTSEIoc3RhdGUpIHtcblx0ICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcblx0ICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cblx0ICAgIHZhciBuID0gcHJvZ1srK2lwXTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05QVVNIQltdJywgbik7IH1cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHsgc3RhY2sucHVzaChwcm9nWysraXBdKTsgfVxuXG5cdCAgICBzdGF0ZS5pcCA9IGlwO1xuXHR9XG5cblx0Ly8gTlBVU0hXW10gUFVTSCBOIFdvcmRzXG5cdC8vIDB4NDFcblx0ZnVuY3Rpb24gTlBVU0hXKHN0YXRlKSB7XG5cdCAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcblx0ICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIG4gPSBwcm9nWysraXBdO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTlBVU0hXW10nLCBuKTsgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgIHZhciB3ID0gKHByb2dbKytpcF0gPDwgOCkgfCBwcm9nWysraXBdO1xuXHQgICAgICAgIGlmICh3ICYgMHg4MDAwKSB7IHcgPSAtKCh3IF4gMHhmZmZmKSArIDEpOyB9XG5cdCAgICAgICAgc3RhY2sucHVzaCh3KTtcblx0ICAgIH1cblxuXHQgICAgc3RhdGUuaXAgPSBpcDtcblx0fVxuXG5cdC8vIFdTW10gV3JpdGUgU3RvcmVcblx0Ly8gMHg0MlxuXHRmdW5jdGlvbiBXUyhzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgc3RvcmUgPSBzdGF0ZS5zdG9yZTtcblxuXHQgICAgaWYgKCFzdG9yZSkgeyBzdG9yZSA9IHN0YXRlLnN0b3JlID0gW107IH1cblxuXHQgICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdXUycsIHYsIGwpOyB9XG5cblx0ICAgIHN0b3JlW2xdID0gdjtcblx0fVxuXG5cdC8vIFJTW10gUmVhZCBTdG9yZVxuXHQvLyAweDQzXG5cdGZ1bmN0aW9uIFJTKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBzdG9yZSA9IHN0YXRlLnN0b3JlO1xuXG5cdCAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlMnLCBsKTsgfVxuXG5cdCAgICB2YXIgdiA9IChzdG9yZSAmJiBzdG9yZVtsXSkgfHwgMDtcblxuXHQgICAgc3RhY2sucHVzaCh2KTtcblx0fVxuXG5cdC8vIFdDVlRQW10gV3JpdGUgQ29udHJvbCBWYWx1ZSBUYWJsZSBpbiBQaXhlbCB1bml0c1xuXHQvLyAweDQ0XG5cdGZ1bmN0aW9uIFdDVlRQKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuXHQgICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdXQ1ZUUCcsIHYsIGwpOyB9XG5cblx0ICAgIHN0YXRlLmN2dFtsXSA9IHYgLyAweDQwO1xuXHR9XG5cblx0Ly8gUkNWVFtdIFJlYWQgQ29udHJvbCBWYWx1ZSBUYWJsZSBlbnRyeVxuXHQvLyAweDQ1XG5cdGZ1bmN0aW9uIFJDVlQoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGN2dGUgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JDVlQnLCBjdnRlKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKHN0YXRlLmN2dFtjdnRlXSAqIDB4NDApO1xuXHR9XG5cblx0Ly8gR0NbXSBHZXQgQ29vcmRpbmF0ZSBwcm9qZWN0ZWQgb250byB0aGUgcHJvamVjdGlvbiB2ZWN0b3Jcblx0Ly8gMHg0Ni0weDQ3XG5cdGZ1bmN0aW9uIEdDKGEsIHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHAgPSBzdGF0ZS56MltwaV07XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHQ1snICsgYSArICddJywgcGkpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goc3RhdGUuZHB2LmRpc3RhbmNlKHAsIEhQWmVybywgYSwgZmFsc2UpICogMHg0MCk7XG5cdH1cblxuXHQvLyBNRFthXSBNZWFzdXJlIERpc3RhbmNlXG5cdC8vIDB4NDktMHg0QVxuXHRmdW5jdGlvbiBNRChhLCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgcGkyID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcGkxID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcDIgPSBzdGF0ZS56MVtwaTJdO1xuXHQgICAgdmFyIHAxID0gc3RhdGUuejBbcGkxXTtcblx0ICAgIHZhciBkID0gc3RhdGUuZHB2LmRpc3RhbmNlKHAxLCBwMiwgYSwgYSk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNRFsnICsgYSArICddJywgcGkyLCBwaTEsICctPicsIGQpOyB9XG5cblx0ICAgIHN0YXRlLnN0YWNrLnB1c2goTWF0aC5yb3VuZChkICogNjQpKTtcblx0fVxuXG5cdC8vIE1QUEVNW10gTWVhc3VyZSBQaXhlbHMgUGVyIEVNXG5cdC8vIDB4NEJcblx0ZnVuY3Rpb24gTVBQRU0oc3RhdGUpIHtcblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNUFBFTVtdJyk7IH1cblx0ICAgIHN0YXRlLnN0YWNrLnB1c2goc3RhdGUucHBlbSk7XG5cdH1cblxuXHQvLyBGTElQT05bXSBzZXQgdGhlIGF1dG8gRkxJUCBCb29sZWFuIHRvIE9OXG5cdC8vIDB4NERcblx0ZnVuY3Rpb24gRkxJUE9OKHN0YXRlKSB7XG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkxJUE9OW10nKTsgfVxuXHQgICAgc3RhdGUuYXV0b0ZsaXAgPSB0cnVlO1xuXHR9XG5cblx0Ly8gTFRbXSBMZXNzIFRoYW5cblx0Ly8gMHg1MFxuXHRmdW5jdGlvbiBMVChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTFRbXScsIGUyLCBlMSk7IH1cblxuXHQgICAgc3RhY2sucHVzaChlMSA8IGUyID8gMSA6IDApO1xuXHR9XG5cblx0Ly8gTFRFUVtdIExlc3MgVGhhbiBvciBFUXVhbFxuXHQvLyAweDUzXG5cdGZ1bmN0aW9uIExURVEoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0xURVFbXScsIGUyLCBlMSk7IH1cblxuXHQgICAgc3RhY2sucHVzaChlMSA8PSBlMiA/IDEgOiAwKTtcblx0fVxuXG5cdC8vIEdURVFbXSBHcmVhdGVyIFRoYW5cblx0Ly8gMHg1MlxuXHRmdW5jdGlvbiBHVChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR1RbXScsIGUyLCBlMSk7IH1cblxuXHQgICAgc3RhY2sucHVzaChlMSA+IGUyID8gMSA6IDApO1xuXHR9XG5cblx0Ly8gR1RFUVtdIEdyZWF0ZXIgVGhhbiBvciBFUXVhbFxuXHQvLyAweDUzXG5cdGZ1bmN0aW9uIEdURVEoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dURVFbXScsIGUyLCBlMSk7IH1cblxuXHQgICAgc3RhY2sucHVzaChlMSA+PSBlMiA/IDEgOiAwKTtcblx0fVxuXG5cdC8vIEVRW10gRVF1YWxcblx0Ly8gMHg1NFxuXHRmdW5jdGlvbiBFUShzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRVFbXScsIGUyLCBlMSk7IH1cblxuXHQgICAgc3RhY2sucHVzaChlMiA9PT0gZTEgPyAxIDogMCk7XG5cdH1cblxuXHQvLyBORVFbXSBOb3QgRVF1YWxcblx0Ly8gMHg1NVxuXHRmdW5jdGlvbiBORVEoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05FUVtdJywgZTIsIGUxKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKGUyICE9PSBlMSA/IDEgOiAwKTtcblx0fVxuXG5cdC8vIE9ERFtdIE9ERFxuXHQvLyAweDU2XG5cdGZ1bmN0aW9uIE9ERChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnT0REW10nLCBuKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKE1hdGgudHJ1bmMobikgJSAyID8gMSA6IDApO1xuXHR9XG5cblx0Ly8gRVZFTltdIEVWRU5cblx0Ly8gMHg1N1xuXHRmdW5jdGlvbiBFVkVOKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFVkVOW10nLCBuKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKE1hdGgudHJ1bmMobikgJSAyID8gMCA6IDEpO1xuXHR9XG5cblx0Ly8gSUZbXSBJRiB0ZXN0XG5cdC8vIDB4NThcblx0ZnVuY3Rpb24gSUYoc3RhdGUpIHtcblx0ICAgIHZhciB0ZXN0ID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJRltdJywgdGVzdCk7IH1cblxuXHQgICAgLy8gaWYgdGVzdCBpcyB0cnVlIGl0IGp1c3QgY29udGludWVzXG5cdCAgICAvLyBpZiBub3QgdGhlIGlwIGlzIHNraXBwZWQgdW50aWwgbWF0Y2hpbmcgRUxTRSBvciBFSUZcblx0ICAgIGlmICghdGVzdCkge1xuXHQgICAgICAgIHNraXAoc3RhdGUsIHRydWUpO1xuXG5cdCAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0VJRltdJyk7IH1cblx0ICAgIH1cblx0fVxuXG5cdC8vIEVJRltdIEVuZCBJRlxuXHQvLyAweDU5XG5cdGZ1bmN0aW9uIEVJRihzdGF0ZSkge1xuXHQgICAgLy8gdGhpcyBjYW4gYmUgcmVhY2hlZCBub3JtYWxseSB3aGVuXG5cdCAgICAvLyBleGVjdXRpbmcgYW4gZWxzZSBicmFuY2guXG5cdCAgICAvLyAtPiBqdXN0IGlnbm9yZSBpdFxuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRUlGW10nKTsgfVxuXHR9XG5cblx0Ly8gQU5EW10gbG9naWNhbCBBTkRcblx0Ly8gMHg1QVxuXHRmdW5jdGlvbiBBTkQoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0FORFtdJywgZTIsIGUxKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKGUyICYmIGUxID8gMSA6IDApO1xuXHR9XG5cblx0Ly8gT1JbXSBsb2dpY2FsIE9SXG5cdC8vIDB4NUJcblx0ZnVuY3Rpb24gT1Ioc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ09SW10nLCBlMiwgZTEpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goZTIgfHwgZTEgPyAxIDogMCk7XG5cdH1cblxuXHQvLyBOT1RbXSBsb2dpY2FsIE5PVFxuXHQvLyAweDVDXG5cdGZ1bmN0aW9uIE5PVChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgZSA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTk9UW10nLCBlKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKGUgPyAwIDogMSk7XG5cdH1cblxuXHQvLyBERUxUQVAxW10gREVMVEEgZXhjZXB0aW9uIFAxXG5cdC8vIERFTFRBUDJbXSBERUxUQSBleGNlcHRpb24gUDJcblx0Ly8gREVMVEFQM1tdIERFTFRBIGV4Y2VwdGlvbiBQM1xuXHQvLyAweDVELCAweDcxLCAweDcyXG5cdGZ1bmN0aW9uIERFTFRBUDEyMyhiLCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG5cdCAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblx0ICAgIHZhciBwcGVtID0gc3RhdGUucHBlbTtcblx0ICAgIHZhciBiYXNlID0gc3RhdGUuZGVsdGFCYXNlICsgKGIgLSAxKSAqIDE2O1xuXHQgICAgdmFyIGRzID0gc3RhdGUuZGVsdGFTaGlmdDtcblx0ICAgIHZhciB6MCA9IHN0YXRlLnowO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFQWycgKyBiICsgJ10nLCBuLCBzdGFjayk7IH1cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICB2YXIgYXJnID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgdmFyIGFwcGVtID0gYmFzZSArICgoYXJnICYgMHhGMCkgPj4gNCk7XG5cdCAgICAgICAgaWYgKGFwcGVtICE9PSBwcGVtKSB7IGNvbnRpbnVlOyB9XG5cblx0ICAgICAgICB2YXIgbWFnID0gKGFyZyAmIDB4MEYpIC0gODtcblx0ICAgICAgICBpZiAobWFnID49IDApIHsgbWFnKys7IH1cblx0ICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFQRklYJywgcGksICdieScsIG1hZyAqIGRzKTsgfVxuXG5cdCAgICAgICAgdmFyIHAgPSB6MFtwaV07XG5cdCAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgbWFnICogZHMsIHB2KTtcblx0ICAgIH1cblx0fVxuXG5cdC8vIFNEQltdIFNldCBEZWx0YSBCYXNlIGluIHRoZSBncmFwaGljcyBzdGF0ZVxuXHQvLyAweDVFXG5cdGZ1bmN0aW9uIFNEQihzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0RCW10nLCBuKTsgfVxuXG5cdCAgICBzdGF0ZS5kZWx0YUJhc2UgPSBuO1xuXHR9XG5cblx0Ly8gU0RTW10gU2V0IERlbHRhIFNoaWZ0IGluIHRoZSBncmFwaGljcyBzdGF0ZVxuXHQvLyAweDVGXG5cdGZ1bmN0aW9uIFNEUyhzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0RTW10nLCBuKTsgfVxuXG5cdCAgICBzdGF0ZS5kZWx0YVNoaWZ0ID0gTWF0aC5wb3coMC41LCBuKTtcblx0fVxuXG5cdC8vIEFERFtdIEFERFxuXHQvLyAweDYwXG5cdGZ1bmN0aW9uIEFERChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBuMSA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQUREW10nLCBuMiwgbjEpOyB9XG5cblx0ICAgIHN0YWNrLnB1c2gobjEgKyBuMik7XG5cdH1cblxuXHQvLyBTVUJbXSBTVUJcblx0Ly8gMHg2MVxuXHRmdW5jdGlvbiBTVUIoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NVQltdJywgbjIsIG4xKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKG4xIC0gbjIpO1xuXHR9XG5cblx0Ly8gRElWW10gRElWXG5cdC8vIDB4NjJcblx0ZnVuY3Rpb24gRElWKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdESVZbXScsIG4yLCBuMSk7IH1cblxuXHQgICAgc3RhY2sucHVzaChuMSAqIDY0IC8gbjIpO1xuXHR9XG5cblx0Ly8gTVVMW10gTVVMXG5cdC8vIDB4NjNcblx0ZnVuY3Rpb24gTVVMKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNVUxbXScsIG4yLCBuMSk7IH1cblxuXHQgICAgc3RhY2sucHVzaChuMSAqIG4yIC8gNjQpO1xuXHR9XG5cblx0Ly8gQUJTW10gQUJTb2x1dGUgdmFsdWVcblx0Ly8gMHg2NFxuXHRmdW5jdGlvbiBBQlMoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0FCU1tdJywgbik7IH1cblxuXHQgICAgc3RhY2sucHVzaChNYXRoLmFicyhuKSk7XG5cdH1cblxuXHQvLyBORUdbXSBORUdhdGVcblx0Ly8gMHg2NVxuXHRmdW5jdGlvbiBORUcoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05FR1tdJywgbik7IH1cblxuXHQgICAgc3RhY2sucHVzaCgtbik7XG5cdH1cblxuXHQvLyBGTE9PUltdIEZMT09SXG5cdC8vIDB4NjZcblx0ZnVuY3Rpb24gRkxPT1Ioc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0ZMT09SW10nLCBuKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKE1hdGguZmxvb3IobiAvIDB4NDApICogMHg0MCk7XG5cdH1cblxuXHQvLyBDRUlMSU5HW10gQ0VJTElOR1xuXHQvLyAweDY3XG5cdGZ1bmN0aW9uIENFSUxJTkcoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NFSUxJTkdbXScsIG4pOyB9XG5cblx0ICAgIHN0YWNrLnB1c2goTWF0aC5jZWlsKG4gLyAweDQwKSAqIDB4NDApO1xuXHR9XG5cblx0Ly8gUk9VTkRbYWJdIFJPVU5EIHZhbHVlXG5cdC8vIDB4NjgtMHg2QlxuXHRmdW5jdGlvbiBST1VORChkdCwgc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JPVU5EW10nKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKHN0YXRlLnJvdW5kKG4gLyAweDQwKSAqIDB4NDApO1xuXHR9XG5cblx0Ly8gV0NWVEZbXSBXcml0ZSBDb250cm9sIFZhbHVlIFRhYmxlIGluIEZ1bml0c1xuXHQvLyAweDcwXG5cdGZ1bmN0aW9uIFdDVlRGKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnV0NWVEZbXScsIHYsIGwpOyB9XG5cblx0ICAgIHN0YXRlLmN2dFtsXSA9IHYgKiBzdGF0ZS5wcGVtIC8gc3RhdGUuZm9udC51bml0c1BlckVtO1xuXHR9XG5cblx0Ly8gREVMVEFDMVtdIERFTFRBIGV4Y2VwdGlvbiBDMVxuXHQvLyBERUxUQUMyW10gREVMVEEgZXhjZXB0aW9uIEMyXG5cdC8vIERFTFRBQzNbXSBERUxUQSBleGNlcHRpb24gQzNcblx0Ly8gMHg3MywgMHg3NCwgMHg3NVxuXHRmdW5jdGlvbiBERUxUQUMxMjMoYiwgc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBwcGVtID0gc3RhdGUucHBlbTtcblx0ICAgIHZhciBiYXNlID0gc3RhdGUuZGVsdGFCYXNlICsgKGIgLSAxKSAqIDE2O1xuXHQgICAgdmFyIGRzID0gc3RhdGUuZGVsdGFTaGlmdDtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBQ1snICsgYiArICddJywgbiwgc3RhY2spOyB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGMgPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICB2YXIgYXJnID0gc3RhY2sucG9wKCk7XG5cdCAgICAgICAgdmFyIGFwcGVtID0gYmFzZSArICgoYXJnICYgMHhGMCkgPj4gNCk7XG5cdCAgICAgICAgaWYgKGFwcGVtICE9PSBwcGVtKSB7IGNvbnRpbnVlOyB9XG5cblx0ICAgICAgICB2YXIgbWFnID0gKGFyZyAmIDB4MEYpIC0gODtcblx0ICAgICAgICBpZiAobWFnID49IDApIHsgbWFnKys7IH1cblxuXHQgICAgICAgIHZhciBkZWx0YSA9IG1hZyAqIGRzO1xuXG5cdCAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBQ0ZJWCcsIGMsICdieScsIGRlbHRhKTsgfVxuXG5cdCAgICAgICAgc3RhdGUuY3Z0W2NdICs9IGRlbHRhO1xuXHQgICAgfVxuXHR9XG5cblx0Ly8gU1JPVU5EW10gU3VwZXIgUk9VTkRcblx0Ly8gMHg3NlxuXHRmdW5jdGlvbiBTUk9VTkQoc3RhdGUpIHtcblx0ICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUk9VTkRbXScsIG4pOyB9XG5cblx0ICAgIHN0YXRlLnJvdW5kID0gcm91bmRTdXBlcjtcblxuXHQgICAgdmFyIHBlcmlvZDtcblxuXHQgICAgc3dpdGNoIChuICYgMHhDMCkge1xuXHQgICAgICAgIGNhc2UgMHgwMDpcblx0ICAgICAgICAgICAgcGVyaW9kID0gMC41O1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIDB4NDA6XG5cdCAgICAgICAgICAgIHBlcmlvZCA9IDE7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMHg4MDpcblx0ICAgICAgICAgICAgcGVyaW9kID0gMjtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFNST1VORCB2YWx1ZScpO1xuXHQgICAgfVxuXG5cdCAgICBzdGF0ZS5zclBlcmlvZCA9IHBlcmlvZDtcblxuXHQgICAgc3dpdGNoIChuICYgMHgzMCkge1xuXHQgICAgICAgIGNhc2UgMHgwMDpcblx0ICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDA7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMHgxMDpcblx0ICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuMjUgKiBwZXJpb2Q7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMHgyMDpcblx0ICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuNSAgKiBwZXJpb2Q7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMHgzMDpcblx0ICAgICAgICAgICAgc3RhdGUuc3JQaGFzZSA9IDAuNzUgKiBwZXJpb2Q7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTUk9VTkQgdmFsdWUnKTtcblx0ICAgIH1cblxuXHQgICAgbiAmPSAweDBGO1xuXG5cdCAgICBpZiAobiA9PT0gMCkgeyBzdGF0ZS5zclRocmVzaG9sZCA9IDA7IH1cblx0ICAgIGVsc2UgeyBzdGF0ZS5zclRocmVzaG9sZCA9IChuIC8gOCAtIDAuNSkgKiBwZXJpb2Q7IH1cblx0fVxuXG5cdC8vIFM0NVJPVU5EW10gU3VwZXIgUk9VTkQgNDUgZGVncmVlc1xuXHQvLyAweDc3XG5cdGZ1bmN0aW9uIFM0NVJPVU5EKHN0YXRlKSB7XG5cdCAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUzQ1Uk9VTkRbXScsIG4pOyB9XG5cblx0ICAgIHN0YXRlLnJvdW5kID0gcm91bmRTdXBlcjtcblxuXHQgICAgdmFyIHBlcmlvZDtcblxuXHQgICAgc3dpdGNoIChuICYgMHhDMCkge1xuXHQgICAgICAgIGNhc2UgMHgwMDpcblx0ICAgICAgICAgICAgcGVyaW9kID0gTWF0aC5zcXJ0KDIpIC8gMjtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAweDQwOlxuXHQgICAgICAgICAgICBwZXJpb2QgPSBNYXRoLnNxcnQoMik7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMHg4MDpcblx0ICAgICAgICAgICAgcGVyaW9kID0gMiAqIE1hdGguc3FydCgyKTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFM0NVJPVU5EIHZhbHVlJyk7XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLnNyUGVyaW9kID0gcGVyaW9kO1xuXG5cdCAgICBzd2l0Y2ggKG4gJiAweDMwKSB7XG5cdCAgICAgICAgY2FzZSAweDAwOlxuXHQgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMDtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAweDEwOlxuXHQgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC4yNSAqIHBlcmlvZDtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAweDIwOlxuXHQgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC41ICAqIHBlcmlvZDtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAweDMwOlxuXHQgICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC43NSAqIHBlcmlvZDtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFM0NVJPVU5EIHZhbHVlJyk7XG5cdCAgICB9XG5cblx0ICAgIG4gJj0gMHgwRjtcblxuXHQgICAgaWYgKG4gPT09IDApIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAwOyB9XG5cdCAgICBlbHNlIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAobiAvIDggLSAwLjUpICogcGVyaW9kOyB9XG5cdH1cblxuXHQvLyBST0ZGW10gUm91bmQgT2ZmXG5cdC8vIDB4N0Fcblx0ZnVuY3Rpb24gUk9GRihzdGF0ZSkge1xuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JPRkZbXScpOyB9XG5cblx0ICAgIHN0YXRlLnJvdW5kID0gcm91bmRPZmY7XG5cdH1cblxuXHQvLyBSVVRHW10gUm91bmQgVXAgVG8gR3JpZFxuXHQvLyAweDdDXG5cdGZ1bmN0aW9uIFJVVEcoc3RhdGUpIHtcblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVVRHW10nKTsgfVxuXG5cdCAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVXBUb0dyaWQ7XG5cdH1cblxuXHQvLyBSRFRHW10gUm91bmQgRG93biBUbyBHcmlkXG5cdC8vIDB4N0Rcblx0ZnVuY3Rpb24gUkRURyhzdGF0ZSkge1xuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JEVEdbXScpOyB9XG5cblx0ICAgIHN0YXRlLnJvdW5kID0gcm91bmREb3duVG9HcmlkO1xuXHR9XG5cblx0Ly8gU0NBTkNUUkxbXSBTQ0FOIGNvbnZlcnNpb24gQ29uVFJvTFxuXHQvLyAweDg1XG5cdGZ1bmN0aW9uIFNDQU5DVFJMKHN0YXRlKSB7XG5cdCAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG5cdCAgICAvLyBpZ25vcmVkIGJ5IG9wZW50eXBlLmpzXG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTQ0FOQ1RSTFtdJywgbik7IH1cblx0fVxuXG5cdC8vIFNEUFZUTFthXSBTZXQgRHVhbCBQcm9qZWN0aW9uIFZlY3RvciBUbyBMaW5lXG5cdC8vIDB4ODYtMHg4N1xuXHRmdW5jdGlvbiBTRFBWVEwoYSwgc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIHAyaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHAyID0gc3RhdGUuejJbcDJpXTtcblx0ICAgIHZhciBwMSA9IHN0YXRlLnoxW3AxaV07XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRFBWVExbJyArIGEgKyAnXScsIHAyaSwgcDFpKTsgfVxuXG5cdCAgICB2YXIgZHg7XG5cdCAgICB2YXIgZHk7XG5cblx0ICAgIGlmICghYSkge1xuXHQgICAgICAgIGR4ID0gcDEueCAtIHAyLng7XG5cdCAgICAgICAgZHkgPSBwMS55IC0gcDIueTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZHggPSBwMi55IC0gcDEueTtcblx0ICAgICAgICBkeSA9IHAxLnggLSBwMi54O1xuXHQgICAgfVxuXG5cdCAgICBzdGF0ZS5kcHYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG5cdH1cblxuXHQvLyBHRVRJTkZPW10gR0VUIElORk9ybWF0aW9uXG5cdC8vIDB4ODhcblx0ZnVuY3Rpb24gR0VUSU5GTyhzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgc2VsID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgciA9IDA7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHRVRJTkZPW10nLCBzZWwpOyB9XG5cblx0ICAgIC8vIHYzNSBhcyBpbiBubyBzdWJwaXhlbCBoaW50aW5nXG5cdCAgICBpZiAoc2VsICYgMHgwMSkgeyByID0gMzU7IH1cblxuXHQgICAgLy8gVE9ETyByb3RhdGlvbiBhbmQgc3RyZXRjaCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFxuXHQgICAgLy8gYW5kIHRodXMgdGhvc2UgR0VUSU5GTyBhcmUgYWx3YXlzIDAuXG5cblx0ICAgIC8vIG9wZW50eXBlLmpzIGlzIGFsd2F5cyBncmF5IHNjYWxpbmdcblx0ICAgIGlmIChzZWwgJiAweDIwKSB7IHIgfD0gMHgxMDAwOyB9XG5cblx0ICAgIHN0YWNrLnB1c2gocik7XG5cdH1cblxuXHQvLyBST0xMW10gUk9MTCB0aGUgdG9wIHRocmVlIHN0YWNrIGVsZW1lbnRzXG5cdC8vIDB4OEFcblx0ZnVuY3Rpb24gUk9MTChzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgYSA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIGIgPSBzdGFjay5wb3AoKTtcblx0ICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdST0xMW10nKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKGIpO1xuXHQgICAgc3RhY2sucHVzaChhKTtcblx0ICAgIHN0YWNrLnB1c2goYyk7XG5cdH1cblxuXHQvLyBNQVhbXSBNQVhpbXVtIG9mIHRvcCB0d28gc3RhY2sgZWxlbWVudHNcblx0Ly8gMHg4QlxuXHRmdW5jdGlvbiBNQVgoc3RhdGUpIHtcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXHQgICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01BWFtdJywgZTIsIGUxKTsgfVxuXG5cdCAgICBzdGFjay5wdXNoKE1hdGgubWF4KGUxLCBlMikpO1xuXHR9XG5cblx0Ly8gTUlOW10gTUlOaW11bSBvZiB0b3AgdHdvIHN0YWNrIGVsZW1lbnRzXG5cdC8vIDB4OENcblx0ZnVuY3Rpb24gTUlOKHN0YXRlKSB7XG5cdCAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblx0ICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNSU5bXScsIGUyLCBlMSk7IH1cblxuXHQgICAgc3RhY2sucHVzaChNYXRoLm1pbihlMSwgZTIpKTtcblx0fVxuXG5cdC8vIFNDQU5UWVBFW10gU0NBTlRZUEVcblx0Ly8gMHg4RFxuXHRmdW5jdGlvbiBTQ0FOVFlQRShzdGF0ZSkge1xuXHQgICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblx0ICAgIC8vIGlnbm9yZWQgYnkgb3BlbnR5cGUuanNcblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTQ0FOVFlQRVtdJywgbik7IH1cblx0fVxuXG5cdC8vIElOU1RDVFJMW10gSU5TVENUUkxcblx0Ly8gMHg4RFxuXHRmdW5jdGlvbiBJTlNUQ1RSTChzdGF0ZSkge1xuXHQgICAgdmFyIHMgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblx0ICAgIHZhciB2ID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cblx0ICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJTlNUQ1RSTFtdJywgcywgdik7IH1cblxuXHQgICAgc3dpdGNoIChzKSB7XG5cdCAgICAgICAgY2FzZSAxIDogc3RhdGUuaW5oaWJpdEdyaWRGaXQgPSAhIXY7IHJldHVybjtcblx0ICAgICAgICBjYXNlIDIgOiBzdGF0ZS5pZ25vcmVDdnQgPSAhIXY7IHJldHVybjtcblx0ICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgSU5TVENUUkxbXSBzZWxlY3RvcicpO1xuXHQgICAgfVxuXHR9XG5cblx0Ly8gUFVTSEJbYWJjXSBQVVNIIEJ5dGVzXG5cdC8vIDB4QjAtMHhCN1xuXHRmdW5jdGlvbiBQVVNIQihuLCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG5cdCAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1BVU0hCWycgKyBuICsgJ10nKTsgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgeyBzdGFjay5wdXNoKHByb2dbKytpcF0pOyB9XG5cblx0ICAgIHN0YXRlLmlwID0gaXA7XG5cdH1cblxuXHQvLyBQVVNIV1thYmNdIFBVU0ggV29yZHNcblx0Ly8gMHhCOC0weEJGXG5cdGZ1bmN0aW9uIFBVU0hXKG4sIHN0YXRlKSB7XG5cdCAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcblx0ICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcblx0ICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG5cdCAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5pcCwgJ1BVU0hXWycgKyBuICsgJ10nKTsgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgICAgIHZhciB3ID0gKHByb2dbKytpcF0gPDwgOCkgfCBwcm9nWysraXBdO1xuXHQgICAgICAgIGlmICh3ICYgMHg4MDAwKSB7IHcgPSAtKCh3IF4gMHhmZmZmKSArIDEpOyB9XG5cdCAgICAgICAgc3RhY2sucHVzaCh3KTtcblx0ICAgIH1cblxuXHQgICAgc3RhdGUuaXAgPSBpcDtcblx0fVxuXG5cdC8vIE1EUlBbYWJjZGVdIE1vdmUgRGlyZWN0IFJlbGF0aXZlIFBvaW50XG5cdC8vIDB4RDAtMHhFRlxuXHQvLyAoaWYgaW5kaXJlY3QgaXMgMClcblx0Ly9cblx0Ly8gYW5kXG5cdC8vXG5cdC8vIE1JUlBbYWJjZGVdIE1vdmUgSW5kaXJlY3QgUmVsYXRpdmUgUG9pbnRcblx0Ly8gMHhFMC0weEZGXG5cdC8vIChpZiBpbmRpcmVjdCBpcyAxKVxuXG5cdGZ1bmN0aW9uIE1EUlBfTUlSUChpbmRpcmVjdCwgc2V0UnAwLCBrZWVwRCwgcm8sIGR0LCBzdGF0ZSkge1xuXHQgICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cdCAgICB2YXIgY3Z0ZSA9IGluZGlyZWN0ICYmIHN0YWNrLnBvcCgpO1xuXHQgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG5cdCAgICB2YXIgcnAwaSA9IHN0YXRlLnJwMDtcblx0ICAgIHZhciBycCA9IHN0YXRlLnowW3JwMGldO1xuXHQgICAgdmFyIHAgPSBzdGF0ZS56MVtwaV07XG5cblx0ICAgIHZhciBtZCA9IHN0YXRlLm1pbkRpcztcblx0ICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuXHQgICAgdmFyIHB2ID0gc3RhdGUuZHB2O1xuXHQgICAgdmFyIG9kOyAvLyBvcmlnaW5hbCBkaXN0YW5jZVxuXHQgICAgdmFyIGQ7IC8vIG1vdmluZyBkaXN0YW5jZVxuXHQgICAgdmFyIHNpZ247IC8vIHNpZ24gb2YgZGlzdGFuY2Vcblx0ICAgIHZhciBjdjtcblxuXHQgICAgZCA9IG9kID0gcHYuZGlzdGFuY2UocCwgcnAsIHRydWUsIHRydWUpO1xuXHQgICAgc2lnbiA9IGQgPj0gMCA/IDEgOiAtMTsgLy8gTWF0aC5zaWduIHdvdWxkIGJlIDAgaW4gY2FzZSBvZiAwXG5cblx0ICAgIC8vIFRPRE8gY29uc2lkZXIgYXV0b0ZsaXBcblx0ICAgIGQgPSBNYXRoLmFicyhkKTtcblxuXHQgICAgaWYgKGluZGlyZWN0KSB7XG5cdCAgICAgICAgY3YgPSBzdGF0ZS5jdnRbY3Z0ZV07XG5cblx0ICAgICAgICBpZiAocm8gJiYgTWF0aC5hYnMoZCAtIGN2KSA8IHN0YXRlLmN2Q3V0SW4pIHsgZCA9IGN2OyB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChrZWVwRCAmJiBkIDwgbWQpIHsgZCA9IG1kOyB9XG5cblx0ICAgIGlmIChybykgeyBkID0gc3RhdGUucm91bmQoZCk7IH1cblxuXHQgICAgZnYuc2V0UmVsYXRpdmUocCwgcnAsIHNpZ24gKiBkLCBwdik7XG5cdCAgICBmdi50b3VjaChwKTtcblxuXHQgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcblx0ICAgICAgICBjb25zb2xlLmxvZyhcblx0ICAgICAgICAgICAgc3RhdGUuc3RlcCxcblx0ICAgICAgICAgICAgKGluZGlyZWN0ID8gJ01JUlBbJyA6ICdNRFJQWycpICtcblx0ICAgICAgICAgICAgKHNldFJwMCA/ICdNJyA6ICdtJykgK1xuXHQgICAgICAgICAgICAoa2VlcEQgPyAnPicgOiAnXycpICtcblx0ICAgICAgICAgICAgKHJvID8gJ1InIDogJ18nKSArXG5cdCAgICAgICAgICAgIChkdCA9PT0gMCA/ICdHcicgOiAoZHQgPT09IDEgPyAnQmwnIDogKGR0ID09PSAyID8gJ1doJyA6ICcnKSkpICtcblx0ICAgICAgICAgICAgJ10nLFxuXHQgICAgICAgICAgICBpbmRpcmVjdCA/XG5cdCAgICAgICAgICAgICAgICBjdnRlICsgJygnICsgc3RhdGUuY3Z0W2N2dGVdICsgJywnICsgIGN2ICsgJyknIDpcblx0ICAgICAgICAgICAgICAgICcnLFxuXHQgICAgICAgICAgICBwaSxcblx0ICAgICAgICAgICAgJyhkID0nLCBvZCwgJy0+Jywgc2lnbiAqIGQsICcpJ1xuXHQgICAgICAgICk7XG5cdCAgICB9XG5cblx0ICAgIHN0YXRlLnJwMSA9IHN0YXRlLnJwMDtcblx0ICAgIHN0YXRlLnJwMiA9IHBpO1xuXHQgICAgaWYgKHNldFJwMCkgeyBzdGF0ZS5ycDAgPSBwaTsgfVxuXHR9XG5cblx0Lypcblx0KiBUaGUgaW5zdHJ1Y3Rpb24gdGFibGUuXG5cdCovXG5cdGluc3RydWN0aW9uVGFibGUgPSBbXG5cdCAgICAvKiAweDAwICovIFNWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG5cdCAgICAvKiAweDAxICovIFNWVENBLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG5cdCAgICAvKiAweDAyICovIFNQVlRDQS5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuXHQgICAgLyogMHgwMyAqLyBTUFZUQ0EuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcblx0ICAgIC8qIDB4MDQgKi8gU0ZWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG5cdCAgICAvKiAweDA1ICovIFNGVlRDQS5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuXHQgICAgLyogMHgwNiAqLyBTUFZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG5cdCAgICAvKiAweDA3ICovIFNQVlRMLmJpbmQodW5kZWZpbmVkLCAxKSxcblx0ICAgIC8qIDB4MDggKi8gU0ZWVEwuYmluZCh1bmRlZmluZWQsIDApLFxuXHQgICAgLyogMHgwOSAqLyBTRlZUTC5iaW5kKHVuZGVmaW5lZCwgMSksXG5cdCAgICAvKiAweDBBICovIFNQVkZTLFxuXHQgICAgLyogMHgwQiAqLyBTRlZGUyxcblx0ICAgIC8qIDB4MEMgKi8gR1BWLFxuXHQgICAgLyogMHgwRCAqLyBHRlYsXG5cdCAgICAvKiAweDBFICovIFNGVlRQVixcblx0ICAgIC8qIDB4MEYgKi8gSVNFQ1QsXG5cdCAgICAvKiAweDEwICovIFNSUDAsXG5cdCAgICAvKiAweDExICovIFNSUDEsXG5cdCAgICAvKiAweDEyICovIFNSUDIsXG5cdCAgICAvKiAweDEzICovIFNaUDAsXG5cdCAgICAvKiAweDE0ICovIFNaUDEsXG5cdCAgICAvKiAweDE1ICovIFNaUDIsXG5cdCAgICAvKiAweDE2ICovIFNaUFMsXG5cdCAgICAvKiAweDE3ICovIFNMT09QLFxuXHQgICAgLyogMHgxOCAqLyBSVEcsXG5cdCAgICAvKiAweDE5ICovIFJUSEcsXG5cdCAgICAvKiAweDFBICovIFNNRCxcblx0ICAgIC8qIDB4MUIgKi8gRUxTRSxcblx0ICAgIC8qIDB4MUMgKi8gSk1QUixcblx0ICAgIC8qIDB4MUQgKi8gU0NWVENJLFxuXHQgICAgLyogMHgxRSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTU1dDSVxuXHQgICAgLyogMHgxRiAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTU1dcblx0ICAgIC8qIDB4MjAgKi8gRFVQLFxuXHQgICAgLyogMHgyMSAqLyBQT1AsXG5cdCAgICAvKiAweDIyICovIENMRUFSLFxuXHQgICAgLyogMHgyMyAqLyBTV0FQLFxuXHQgICAgLyogMHgyNCAqLyBERVBUSCxcblx0ICAgIC8qIDB4MjUgKi8gQ0lOREVYLFxuXHQgICAgLyogMHgyNiAqLyBNSU5ERVgsXG5cdCAgICAvKiAweDI3ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEFMSUdOUFRTXG5cdCAgICAvKiAweDI4ICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4MjkgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gVVRQXG5cdCAgICAvKiAweDJBICovIExPT1BDQUxMLFxuXHQgICAgLyogMHgyQiAqLyBDQUxMLFxuXHQgICAgLyogMHgyQyAqLyBGREVGLFxuXHQgICAgLyogMHgyRCAqLyB1bmRlZmluZWQsICAgLy8gRU5ERiAoZWF0ZW4gYnkgRkRFRilcblx0ICAgIC8qIDB4MkUgKi8gTURBUC5iaW5kKHVuZGVmaW5lZCwgMCksXG5cdCAgICAvKiAweDJGICovIE1EQVAuYmluZCh1bmRlZmluZWQsIDEpLFxuXHQgICAgLyogMHgzMCAqLyBJVVAuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcblx0ICAgIC8qIDB4MzEgKi8gSVVQLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG5cdCAgICAvKiAweDMyICovIFNIUC5iaW5kKHVuZGVmaW5lZCwgMCksXG5cdCAgICAvKiAweDMzICovIFNIUC5iaW5kKHVuZGVmaW5lZCwgMSksXG5cdCAgICAvKiAweDM0ICovIFNIQy5iaW5kKHVuZGVmaW5lZCwgMCksXG5cdCAgICAvKiAweDM1ICovIFNIQy5iaW5kKHVuZGVmaW5lZCwgMSksXG5cdCAgICAvKiAweDM2ICovIFNIWi5iaW5kKHVuZGVmaW5lZCwgMCksXG5cdCAgICAvKiAweDM3ICovIFNIWi5iaW5kKHVuZGVmaW5lZCwgMSksXG5cdCAgICAvKiAweDM4ICovIFNIUElYLFxuXHQgICAgLyogMHgzOSAqLyBJUCxcblx0ICAgIC8qIDB4M0EgKi8gTVNJUlAuYmluZCh1bmRlZmluZWQsIDApLFxuXHQgICAgLyogMHgzQiAqLyBNU0lSUC5iaW5kKHVuZGVmaW5lZCwgMSksXG5cdCAgICAvKiAweDNDICovIEFMSUdOUlAsXG5cdCAgICAvKiAweDNEICovIFJUREcsXG5cdCAgICAvKiAweDNFICovIE1JQVAuYmluZCh1bmRlZmluZWQsIDApLFxuXHQgICAgLyogMHgzRiAqLyBNSUFQLmJpbmQodW5kZWZpbmVkLCAxKSxcblx0ICAgIC8qIDB4NDAgKi8gTlBVU0hCLFxuXHQgICAgLyogMHg0MSAqLyBOUFVTSFcsXG5cdCAgICAvKiAweDQyICovIFdTLFxuXHQgICAgLyogMHg0MyAqLyBSUyxcblx0ICAgIC8qIDB4NDQgKi8gV0NWVFAsXG5cdCAgICAvKiAweDQ1ICovIFJDVlQsXG5cdCAgICAvKiAweDQ2ICovIEdDLmJpbmQodW5kZWZpbmVkLCAwKSxcblx0ICAgIC8qIDB4NDcgKi8gR0MuYmluZCh1bmRlZmluZWQsIDEpLFxuXHQgICAgLyogMHg0OCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTQ0ZTXG5cdCAgICAvKiAweDQ5ICovIE1ELmJpbmQodW5kZWZpbmVkLCAwKSxcblx0ICAgIC8qIDB4NEEgKi8gTUQuYmluZCh1bmRlZmluZWQsIDEpLFxuXHQgICAgLyogMHg0QiAqLyBNUFBFTSxcblx0ICAgIC8qIDB4NEMgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTVBTXG5cdCAgICAvKiAweDREICovIEZMSVBPTixcblx0ICAgIC8qIDB4NEUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUE9GRlxuXHQgICAgLyogMHg0RiAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBERUJVR1xuXHQgICAgLyogMHg1MCAqLyBMVCxcblx0ICAgIC8qIDB4NTEgKi8gTFRFUSxcblx0ICAgIC8qIDB4NTIgKi8gR1QsXG5cdCAgICAvKiAweDUzICovIEdURVEsXG5cdCAgICAvKiAweDU0ICovIEVRLFxuXHQgICAgLyogMHg1NSAqLyBORVEsXG5cdCAgICAvKiAweDU2ICovIE9ERCxcblx0ICAgIC8qIDB4NTcgKi8gRVZFTixcblx0ICAgIC8qIDB4NTggKi8gSUYsXG5cdCAgICAvKiAweDU5ICovIEVJRixcblx0ICAgIC8qIDB4NUEgKi8gQU5ELFxuXHQgICAgLyogMHg1QiAqLyBPUixcblx0ICAgIC8qIDB4NUMgKi8gTk9ULFxuXHQgICAgLyogMHg1RCAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDEpLFxuXHQgICAgLyogMHg1RSAqLyBTREIsXG5cdCAgICAvKiAweDVGICovIFNEUyxcblx0ICAgIC8qIDB4NjAgKi8gQURELFxuXHQgICAgLyogMHg2MSAqLyBTVUIsXG5cdCAgICAvKiAweDYyICovIERJVixcblx0ICAgIC8qIDB4NjMgKi8gTVVMLFxuXHQgICAgLyogMHg2NCAqLyBBQlMsXG5cdCAgICAvKiAweDY1ICovIE5FRyxcblx0ICAgIC8qIDB4NjYgKi8gRkxPT1IsXG5cdCAgICAvKiAweDY3ICovIENFSUxJTkcsXG5cdCAgICAvKiAweDY4ICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAwKSxcblx0ICAgIC8qIDB4NjkgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDEpLFxuXHQgICAgLyogMHg2QSAqLyBST1VORC5iaW5kKHVuZGVmaW5lZCwgMiksXG5cdCAgICAvKiAweDZCICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAzKSxcblx0ICAgIC8qIDB4NkMgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuXHQgICAgLyogMHg2RCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBOUk9VTkRbYWJdXG5cdCAgICAvKiAweDZFICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cblx0ICAgIC8qIDB4NkYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuXHQgICAgLyogMHg3MCAqLyBXQ1ZURixcblx0ICAgIC8qIDB4NzEgKi8gREVMVEFQMTIzLmJpbmQodW5kZWZpbmVkLCAyKSxcblx0ICAgIC8qIDB4NzIgKi8gREVMVEFQMTIzLmJpbmQodW5kZWZpbmVkLCAzKSxcblx0ICAgIC8qIDB4NzMgKi8gREVMVEFDMTIzLmJpbmQodW5kZWZpbmVkLCAxKSxcblx0ICAgIC8qIDB4NzQgKi8gREVMVEFDMTIzLmJpbmQodW5kZWZpbmVkLCAyKSxcblx0ICAgIC8qIDB4NzUgKi8gREVMVEFDMTIzLmJpbmQodW5kZWZpbmVkLCAzKSxcblx0ICAgIC8qIDB4NzYgKi8gU1JPVU5ELFxuXHQgICAgLyogMHg3NyAqLyBTNDVST1VORCxcblx0ICAgIC8qIDB4NzggKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gSlJPVFtdXG5cdCAgICAvKiAweDc5ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEpST0ZbXVxuXHQgICAgLyogMHg3QSAqLyBST0ZGLFxuXHQgICAgLyogMHg3QiAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDdDICovIFJVVEcsXG5cdCAgICAvKiAweDdEICovIFJEVEcsXG5cdCAgICAvKiAweDdFICovIFBPUCwgLy8gYWN0dWFsbHkgU0FOR1csIHN1cHBvc2VkIHRvIGRvIG9ubHkgYSBwb3AgdGhvdWdoXG5cdCAgICAvKiAweDdGICovIFBPUCwgLy8gYWN0dWFsbHkgQUEsIHN1cHBvc2VkIHRvIGRvIG9ubHkgYSBwb3AgdGhvdWdoXG5cdCAgICAvKiAweDgwICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBQVFxuXHQgICAgLyogMHg4MSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQUkdPTlxuXHQgICAgLyogMHg4MiAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQUkdPRkZcblx0ICAgIC8qIDB4ODMgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHg4NCAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDg1ICovIFNDQU5DVFJMLFxuXHQgICAgLyogMHg4NiAqLyBTRFBWVEwuYmluZCh1bmRlZmluZWQsIDApLFxuXHQgICAgLyogMHg4NyAqLyBTRFBWVEwuYmluZCh1bmRlZmluZWQsIDEpLFxuXHQgICAgLyogMHg4OCAqLyBHRVRJTkZPLFxuXHQgICAgLyogMHg4OSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBJREVGXG5cdCAgICAvKiAweDhBICovIFJPTEwsXG5cdCAgICAvKiAweDhCICovIE1BWCxcblx0ICAgIC8qIDB4OEMgKi8gTUlOLFxuXHQgICAgLyogMHg4RCAqLyBTQ0FOVFlQRSxcblx0ICAgIC8qIDB4OEUgKi8gSU5TVENUUkwsXG5cdCAgICAvKiAweDhGICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4OTAgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHg5MSAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDkyICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4OTMgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHg5NCAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDk1ICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4OTYgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHg5NyAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDk4ICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4OTkgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHg5QSAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDlCICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4OUMgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHg5RCAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweDlFICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4OUYgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHhBMCAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweEExICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4QTIgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHhBMyAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweEE0ICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4QTUgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHhBNiAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweEE3ICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4QTggKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHhBOSAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweEFBICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4QUIgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHhBQyAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweEFEICovIHVuZGVmaW5lZCxcblx0ICAgIC8qIDB4QUUgKi8gdW5kZWZpbmVkLFxuXHQgICAgLyogMHhBRiAqLyB1bmRlZmluZWQsXG5cdCAgICAvKiAweEIwICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCAxKSxcblx0ICAgIC8qIDB4QjEgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDIpLFxuXHQgICAgLyogMHhCMiAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgMyksXG5cdCAgICAvKiAweEIzICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA0KSxcblx0ICAgIC8qIDB4QjQgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDUpLFxuXHQgICAgLyogMHhCNSAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgNiksXG5cdCAgICAvKiAweEI2ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA3KSxcblx0ICAgIC8qIDB4QjcgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDgpLFxuXHQgICAgLyogMHhCOCAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgMSksXG5cdCAgICAvKiAweEI5ICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCAyKSxcblx0ICAgIC8qIDB4QkEgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDMpLFxuXHQgICAgLyogMHhCQiAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgNCksXG5cdCAgICAvKiAweEJDICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA1KSxcblx0ICAgIC8qIDB4QkQgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDYpLFxuXHQgICAgLyogMHhCRSAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgNyksXG5cdCAgICAvKiAweEJGICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA4KSxcblx0ICAgIC8qIDB4QzAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAwKSxcblx0ICAgIC8qIDB4QzEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAxKSxcblx0ICAgIC8qIDB4QzIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAyKSxcblx0ICAgIC8qIDB4QzMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAzKSxcblx0ICAgIC8qIDB4QzQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAwKSxcblx0ICAgIC8qIDB4QzUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAxKSxcblx0ICAgIC8qIDB4QzYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAyKSxcblx0ICAgIC8qIDB4QzcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAzKSxcblx0ICAgIC8qIDB4QzggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAwKSxcblx0ICAgIC8qIDB4QzkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAxKSxcblx0ICAgIC8qIDB4Q0EgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAyKSxcblx0ICAgIC8qIDB4Q0IgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAzKSxcblx0ICAgIC8qIDB4Q0MgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAwKSxcblx0ICAgIC8qIDB4Q0QgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAxKSxcblx0ICAgIC8qIDB4Q0UgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAyKSxcblx0ICAgIC8qIDB4Q0YgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAzKSxcblx0ICAgIC8qIDB4RDAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAwKSxcblx0ICAgIC8qIDB4RDEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAxKSxcblx0ICAgIC8qIDB4RDIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAyKSxcblx0ICAgIC8qIDB4RDMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAzKSxcblx0ICAgIC8qIDB4RDQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAwKSxcblx0ICAgIC8qIDB4RDUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAxKSxcblx0ICAgIC8qIDB4RDYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAyKSxcblx0ICAgIC8qIDB4RDcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAzKSxcblx0ICAgIC8qIDB4RDggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAwKSxcblx0ICAgIC8qIDB4RDkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAxKSxcblx0ICAgIC8qIDB4REEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAyKSxcblx0ICAgIC8qIDB4REIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAzKSxcblx0ICAgIC8qIDB4REMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAwKSxcblx0ICAgIC8qIDB4REQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAxKSxcblx0ICAgIC8qIDB4REUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAyKSxcblx0ICAgIC8qIDB4REYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAzKSxcblx0ICAgIC8qIDB4RTAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAwKSxcblx0ICAgIC8qIDB4RTEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAxKSxcblx0ICAgIC8qIDB4RTIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAyKSxcblx0ICAgIC8qIDB4RTMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAzKSxcblx0ICAgIC8qIDB4RTQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAwKSxcblx0ICAgIC8qIDB4RTUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAxKSxcblx0ICAgIC8qIDB4RTYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAyKSxcblx0ICAgIC8qIDB4RTcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAzKSxcblx0ICAgIC8qIDB4RTggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAwKSxcblx0ICAgIC8qIDB4RTkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAxKSxcblx0ICAgIC8qIDB4RUEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAyKSxcblx0ICAgIC8qIDB4RUIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAzKSxcblx0ICAgIC8qIDB4RUMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAwKSxcblx0ICAgIC8qIDB4RUQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAxKSxcblx0ICAgIC8qIDB4RUUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAyKSxcblx0ICAgIC8qIDB4RUYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAzKSxcblx0ICAgIC8qIDB4RjAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAwKSxcblx0ICAgIC8qIDB4RjEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAxKSxcblx0ICAgIC8qIDB4RjIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAyKSxcblx0ICAgIC8qIDB4RjMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAzKSxcblx0ICAgIC8qIDB4RjQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAwKSxcblx0ICAgIC8qIDB4RjUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAxKSxcblx0ICAgIC8qIDB4RjYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAyKSxcblx0ICAgIC8qIDB4RjcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAzKSxcblx0ICAgIC8qIDB4RjggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAwKSxcblx0ICAgIC8qIDB4RjkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAxKSxcblx0ICAgIC8qIDB4RkEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAyKSxcblx0ICAgIC8qIDB4RkIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAzKSxcblx0ICAgIC8qIDB4RkMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAwKSxcblx0ICAgIC8qIDB4RkQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAxKSxcblx0ICAgIC8qIDB4RkUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAyKSxcblx0ICAgIC8qIDB4RkYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAzKVxuXHRdO1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgIE1hdGhlbWF0aWNhbCBDb25zaWRlcmF0aW9uc1xuXHQqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuXHRmdiAuLi4gcmVmZXJzIHRvIGZyZWVkb20gdmVjdG9yXG5cdHB2IC4uLiByZWZlcnMgdG8gcHJvamVjdGlvbiB2ZWN0b3Jcblx0cnAgLi4uIHJlZmVycyB0byByZWZlcmVuY2UgcG9pbnRcblx0cCAgLi4uIHJlZmVycyB0byB0byBwb2ludCBiZWluZyBvcGVyYXRlZCBvblxuXHRkICAuLi4gcmVmZXJzIHRvIGRpc3RhbmNlXG5cblx0U0VUUkVMQVRJVkU6XG5cdD09PT09PT09PT09PVxuXG5cdGNhc2UgZnJlZWRvbSB2ZWN0b3IgPT0geC1heGlzOlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAocHYpXG5cdCAgICAgICAgICAgICAgICAgICAgIC4tJ1xuXHQgICAgICAgICAgICAgIHJwZCAuLSdcblx0ICAgICAgICAgICAgICAgLi0qXG5cdCAgICAgICAgICBkIC4tJzkwwrAnXG5cdCAgICAgICAgIC4tJyAgICAgICAnXG5cdCAgICAgIC4tJyAgICAgICAgICAgJ1xuXHQgICAqLScgICAgICAgICAgICAgICAnIGJcblx0ICBycCAgICAgICAgICAgICAgICAgICdcblx0ICAgICAgICAgICAgICAgICAgICAgICAnXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICdcblx0ICAgICAgICAgICAgcCAqLS0tLS0tLS0tLSotLS0tLS0tLS0tLS0tLSAoZnYpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgcG1cblxuXHQgIHJwZHggPSBycHggKyBkICogcHYueFxuXHQgIHJwZHkgPSBycHkgKyBkICogcHYueVxuXG5cdCAgZXF1YXRpb24gb2YgbGluZSBiXG5cblx0ICAgeSAtIHJwZHkgPSBwdm5zICogKHgtIHJwZHgpXG5cblx0ICAgeSA9IHAueVxuXG5cdCAgIHggPSBycGR4ICsgKCBwLnkgLSBycGR5ICkgLyBwdm5zXG5cblxuXHRjYXNlIGZyZWVkb20gdmVjdG9yID09IHktYXhpczpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0ICAgICogcG1cblx0ICAgIHxcXFxuXHQgICAgfCBcXFxuXHQgICAgfCAgXFxcblx0ICAgIHwgICBcXFxuXHQgICAgfCAgICBcXFxuXHQgICAgfCAgICAgXFxcblx0ICAgIHwgICAgICBcXFxuXHQgICAgfCAgICAgICBcXFxuXHQgICAgfCAgICAgICAgXFxcblx0ICAgIHwgICAgICAgICBcXCBiXG5cdCAgICB8ICAgICAgICAgIFxcXG5cdCAgICB8ICAgICAgICAgICBcXFxuXHQgICAgfCAgICAgICAgICAgIFxcICAgIC4tJyAocHYpXG5cdCAgICB8ICAgICAgICAgOTDCsCBcXC4tJ1xuXHQgICAgfCAgICAgICAgICAgLi0nKiBycGRcblx0ICAgIHwgICAgICAgIC4tJ1xuXHQgICAgKiAgICAgKi0nICBkXG5cdCAgICBwICAgICBycFxuXG5cdCAgcnBkeCA9IHJweCArIGQgKiBwdi54XG5cdCAgcnBkeSA9IHJweSArIGQgKiBwdi55XG5cblx0ICBlcXVhdGlvbiBvZiBsaW5lIGI6XG5cdCAgICAgICAgICAgcHZucyAuLi4gbm9ybWFsIHNsb3BlIHRvIHB2XG5cblx0ICAgeSAtIHJwZHkgPSBwdm5zICogKHggLSBycGR4KVxuXG5cdCAgIHggPSBwLnhcblxuXHQgICB5ID0gcnBkeSArICBwdm5zICogKHAueCAtIHJwZHgpXG5cblxuXG5cdGdlbmVyaWMgY2FzZTpcblx0LS0tLS0tLS0tLS0tLVxuXG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLicoZnYpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuJ1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIC4qIHBtXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC4nICFcblx0ICAgICAgICAgICAgICAgICAgICAgIC4nICAgIC5cblx0ICAgICAgICAgICAgICAgICAgICAuJyAgICAgICFcblx0ICAgICAgICAgICAgICAgICAgLicgICAgICAgICAuIGJcblx0ICAgICAgICAgICAgICAgIC4nICAgICAgICAgICAhXG5cdCAgICAgICAgICAgICAgICogICAgICAgICAgICAgIC5cblx0ICAgICAgICAgICAgICBwICAgICAgICAgICAgICAgIVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgOTDCsCAgIC4gICAgLi4uIChwdilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uLSotJycnXG5cdCAgICAgICAgICAgICAgICAgIC4uLi0tLScnJyAgICBycGRcblx0ICAgICAgICAgLi4uLS0tJycnICAgZFxuXHQgICAqLS0nJydcblx0ICBycFxuXG5cdCAgICBycGR4ID0gcnB4ICsgZCAqIHB2Lnhcblx0ICAgIHJwZHkgPSBycHkgKyBkICogcHYueVxuXG5cdCBlcXVhdGlvbiBvZiBsaW5lIGI6XG5cdCAgICBwdm5zLi4uIG5vcm1hbCBzbG9wZSB0byBwdlxuXG5cdCAgICB5IC0gcnBkeSA9IHB2bnMgKiAoeCAtIHJwZHgpXG5cblx0IGVxdWF0aW9uIG9mIGZyZWVkb20gdmVjdG9yIGxpbmU6XG5cdCAgICBmdnMgLi4uIHNsb3BlIG9mIGZyZWVkb20gdmVjdG9yICg9ZnkvZngpXG5cblx0ICAgIHkgLSBweSA9IGZ2cyAqICh4IC0gcHgpXG5cblxuXHQgIG9uIHBtIGJvdGggZXF1YXRpb25zIGFyZSB0cnVlIGZvciBzYW1lIHgveVxuXG5cdCAgICB5IC0gcnBkeSA9IHB2bnMgKiAoeCAtIHJwZHgpXG5cblx0ICAgIHkgLSBweSA9IGZ2cyAqICh4IC0gcHgpXG5cblx0ICBmb3JtIHRvIHkgYW5kIHNldCBlcXVhbDpcblxuXHQgICAgcHZucyAqICh4IC0gcnBkeCkgKyBycGR5ID0gZnZzICogKHggLSBweCkgKyBweVxuXG5cdCAgZXhwYW5kOlxuXG5cdCAgICBwdm5zICogeCAtIHB2bnMgKiBycGR4ICsgcnBkeSA9IGZ2cyAqIHggLSBmdnMgKiBweCArIHB5XG5cblx0ICBzd2l0Y2g6XG5cblx0ICAgIGZ2cyAqIHggLSBmdnMgKiBweCArIHB5ID0gcHZucyAqIHggLSBwdm5zICogcnBkeCArIHJwZHlcblxuXHQgIHNvbHZlIGZvciB4OlxuXG5cdCAgICBmdnMgKiB4IC0gcHZucyAqIHggPSBmdnMgKiBweCAtIHB2bnMgKiBycGR4IC0gcHkgKyBycGR5XG5cblxuXG5cdCAgICAgICAgICBmdnMgKiBweCAtIHB2bnMgKiBycGR4ICsgcnBkeSAtIHB5XG5cdCAgICB4ID0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdCAgICAgICAgICAgICAgICAgZnZzIC0gcHZuc1xuXG5cdCAgYW5kOlxuXG5cdCAgICB5ID0gZnZzICogKHggLSBweCkgKyBweVxuXG5cblxuXHRJTlRFUlBPTEFURTpcblx0PT09PT09PT09PT09XG5cblx0RXhhbXBsZXMgb2YgcG9pbnQgaW50ZXJwb2xhdGlvbi5cblxuXHRUaGUgd2VpZ2h0IG9mIHRoZSBtb3ZlbWVudCBvZiB0aGUgcmVmZXJlbmNlIHBvaW50IGdldHMgYmlnZ2VyXG5cdHRoZSBmdXJ0aGVyIHRoZSBvdGhlciByZWZlcmVuY2UgcG9pbnQgaXMgYXdheSwgdGh1cyB0aGUgc2FmZXN0XG5cdG9wdGlvbiAodGhhdCBpcyBhdm9pZGluZyAwLzAgZGl2aXNpb25zKSBpcyB0byB3ZWlnaHQgdGhlXG5cdG9yaWdpbmFsIGRpc3RhbmNlIG9mIHRoZSBvdGhlciBwb2ludCBieSB0aGUgc3VtIG9mIGJvdGggZGlzdGFuY2VzLlxuXG5cdElmIHRoZSBzdW0gb2YgYm90aCBkaXN0YW5jZXMgaXMgMCwgdGhlbiBtb3ZlIHRoZSBwb2ludCBieSB0aGVcblx0YXJpdGhtZXRpYyBhdmVyYWdlIG9mIHRoZSBtb3ZlbWVudCBvZiBib3RoIHJlZmVyZW5jZSBwb2ludHMuXG5cblxuXG5cblx0ICAgICAgICAgICAoKzYpXG5cdCAgICBycDFvICotLS0tPipycDFcblx0ICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICAgKCsxMilcblx0ICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgIHJwMm8gKi0tLS0tLS0tLS0+KiBycDJcblx0ICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgLlxuXHQgICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuICAgICAgICAgICAuXG5cdCAgICAgICAgIC4gICAgMTAgICAgICAgICAgMjAgICAgICAgICAgIC4gICAgICAgICAgIC5cblx0ICAgICAgICAgfC4uLi4uLi4uLnwuLi4uLi4uLi4uLi4uLi4uLi4ufCAgICAgICAgICAgLlxuXHQgICAgICAgICAgICAgICAuICAgLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuXG5cdCAgICAgICAgICAgICAgIC4gICAuICgrOCkgICAgICAgICAgICAgICAgICAgICAgICAgIC5cblx0ICAgICAgICAgICAgICAgIHBvICotLS0tLS0+KnAgICAgICAgICAgICAgICAgICAgICAgLlxuXHQgICAgICAgICAgICAgICAuICAgICAgICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuXG5cdCAgICAgICAgICAgICAgIC4gICAgMTIgICAgIC4gICAgICAgICAgMjQgICAgICAgICAgIC5cblx0ICAgICAgICAgICAgICAgfC4uLi4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4ufFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzZcblxuXG5cdC0tLS0tLS1cblxuXG5cblx0ICAgICAgICAgICAoKzEwKVxuXHQgICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuXHQgICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAgICAoLTEwKVxuXHQgICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgcnAyICo8LS0tLS0tLS0tKiBycG8yXG5cdCAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAuXG5cdCAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAuXG5cdCAgICAgICAgIC4gICAgMTAgICAuICAgICAgICAgIDMwICAgICAgIC4gICAgICAgICAuXG5cdCAgICAgICAgIHwuLi4uLi4uLi58Li4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi58XG5cdCAgICAgICAgICAgICAgICAgICAuICAgICAgICAgICAgICAgICAgIC5cblx0ICAgICAgICAgICAgICAgICAgIC4gKCs1KSAgICAgICAgICAgICAgLlxuXHQgICAgICAgICAgICAgICAgcG8gKi0tLT4qIHAgICAgICAgICAgICAuXG5cdCAgICAgICAgICAgICAgICAgICAuICAgIC4gICAgICAgICAgICAgIC5cblx0ICAgICAgICAgICAgICAgICAgIC4gICAgLiAgIDIwICAgICAgICAgLlxuXHQgICAgICAgICAgICAgICAgICAgfC4uLi58Li4uLi4uLi4uLi4uLi58XG5cdCAgICAgICAgICAgICAgICAgICAgIDUgICAgICAgIDE1XG5cblxuXHQtLS0tLS0tXG5cblxuXHQgICAgICAgICAgICgrMTApXG5cdCAgICBycDFvICotLS0tLS0tLT4qcnAxXG5cdCAgICAgICAgIC4gICAgICAgICAuXG5cdCAgICAgICAgIC4gICAgICAgICAuXG5cdCAgICBycDJvICotLS0tLS0tLT4qcnAyXG5cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCsxMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICBwbyAqLS0tLS0tLS0+KiBwXG5cblx0LS0tLS0tLVxuXG5cblx0ICAgICAgICAgICAoKzEwKVxuXHQgICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuXHQgICAgICAgICAuICAgICAgICAgLlxuXHQgICAgICAgICAuICAgICAgICAgLigrMzApXG5cdCAgICBycDJvICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPipycDJcblxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKzI1KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIHBvICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4qIHBcblxuXG5cblx0dmltOiBzZXQgdHM9NCBzdz00IGV4cGFuZHRhYjpcblx0KioqKiovXG5cblx0Ly8gVGhlIEZvbnQgb2JqZWN0XG5cblx0Ly8gVGhpcyBjb2RlIGlzIGJhc2VkIG9uIEFycmF5LmZyb20gaW1wbGVtZW50YXRpb24gZm9yIHN0cmluZ3MgaW4gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvQXJyYXkuZnJvbVxuXHR2YXIgYXJyYXlGcm9tU3RyaW5nID0gQXJyYXkuZnJvbSB8fCAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMubWF0Y2goL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0/fFteXFx1RDgwMC1cXHVERkZGXXwuL2cpIHx8IFtdOyB9KTtcblxuXHQvKipcblx0ICogQHR5cGVkZWYgRm9udE9wdGlvbnNcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZW1wdHkgLSB3aGV0aGVyIHRvIGNyZWF0ZSBhIG5ldyBlbXB0eSBmb250XG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmYW1pbHlOYW1lXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHlsZU5hbWVcblx0ICogQHByb3BlcnR5IHtzdHJpbmc9fSBmdWxsTmFtZVxuXHQgKiBAcHJvcGVydHkge3N0cmluZz19IHBvc3RTY3JpcHROYW1lXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzaWduZXJcblx0ICogQHByb3BlcnR5IHtzdHJpbmc9fSBkZXNpZ25lclVSTFxuXHQgKiBAcHJvcGVydHkge3N0cmluZz19IG1hbnVmYWN0dXJlclxuXHQgKiBAcHJvcGVydHkge3N0cmluZz19IG1hbnVmYWN0dXJlclVSTFxuXHQgKiBAcHJvcGVydHkge3N0cmluZz19IGxpY2Vuc2Vcblx0ICogQHByb3BlcnR5IHtzdHJpbmc9fSBsaWNlbnNlVVJMXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdmVyc2lvblxuXHQgKiBAcHJvcGVydHkge3N0cmluZz19IGRlc2NyaXB0aW9uXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gY29weXJpZ2h0XG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdHJhZGVtYXJrXG5cdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB1bml0c1BlckVtXG5cdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhc2NlbmRlclxuXHQgKiBAcHJvcGVydHkge051bWJlcn0gZGVzY2VuZGVyXG5cdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjcmVhdGVkVGltZXN0YW1wXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gd2VpZ2h0Q2xhc3Ncblx0ICogQHByb3BlcnR5IHtzdHJpbmc9fSB3aWR0aENsYXNzXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZnNTZWxlY3Rpb25cblx0ICovXG5cblx0LyoqXG5cdCAqIEEgRm9udCByZXByZXNlbnRzIGEgbG9hZGVkIE9wZW5UeXBlIGZvbnQgZmlsZS5cblx0ICogSXQgY29udGFpbnMgYSBzZXQgb2YgZ2x5cGhzIGFuZCBtZXRob2RzIHRvIGRyYXcgdGV4dCBvbiBhIGRyYXdpbmcgY29udGV4dCxcblx0ICogb3IgdG8gZ2V0IGEgcGF0aCByZXByZXNlbnRpbmcgdGhlIHRleHQuXG5cdCAqIEBleHBvcnRzIG9wZW50eXBlLkZvbnRcblx0ICogQGNsYXNzXG5cdCAqIEBwYXJhbSB7Rm9udE9wdGlvbnN9XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gRm9udChvcHRpb25zKSB7XG5cdCAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHQgICAgaWYgKCFvcHRpb25zLmVtcHR5KSB7XG5cdCAgICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSd2ZSBwcm92aWRlZCB0aGUgbWluaW11bSBzZXQgb2YgbmFtZXMuXG5cdCAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLmZhbWlseU5hbWUsICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBmYW1pbHlOYW1lIGlzIHJlcXVpcmVkLicpO1xuXHQgICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5zdHlsZU5hbWUsICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBzdHlsZU5hbWUgaXMgcmVxdWlyZWQuJyk7XG5cdCAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLnVuaXRzUGVyRW0sICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCB1bml0c1BlckVtIGlzIHJlcXVpcmVkLicpO1xuXHQgICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5hc2NlbmRlciwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIGFzY2VuZGVyIGlzIHJlcXVpcmVkLicpO1xuXHQgICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5kZXNjZW5kZXIsICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBkZXNjZW5kZXIgaXMgcmVxdWlyZWQuJyk7XG5cdCAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLmRlc2NlbmRlciA8IDAsICdEZXNjZW5kZXIgc2hvdWxkIGJlIG5lZ2F0aXZlIChlLmcuIC01MTIpLicpO1xuXG5cdCAgICAgICAgLy8gT1MgWCB3aWxsIGNvbXBsYWluIGlmIHRoZSBuYW1lcyBhcmUgZW1wdHksIHNvIHdlIHB1dCBhIHNpbmdsZSBzcGFjZSBldmVyeXdoZXJlIGJ5IGRlZmF1bHQuXG5cdCAgICAgICAgdGhpcy5uYW1lcyA9IHtcblx0ICAgICAgICAgICAgZm9udEZhbWlseToge2VuOiBvcHRpb25zLmZhbWlseU5hbWUgfHwgJyAnfSxcblx0ICAgICAgICAgICAgZm9udFN1YmZhbWlseToge2VuOiBvcHRpb25zLnN0eWxlTmFtZSB8fCAnICd9LFxuXHQgICAgICAgICAgICBmdWxsTmFtZToge2VuOiBvcHRpb25zLmZ1bGxOYW1lIHx8IG9wdGlvbnMuZmFtaWx5TmFtZSArICcgJyArIG9wdGlvbnMuc3R5bGVOYW1lfSxcblx0ICAgICAgICAgICAgLy8gcG9zdFNjcmlwdE5hbWUgbWF5IG5vdCBjb250YWluIGFueSB3aGl0ZXNwYWNlXG5cdCAgICAgICAgICAgIHBvc3RTY3JpcHROYW1lOiB7ZW46IG9wdGlvbnMucG9zdFNjcmlwdE5hbWUgfHwgKG9wdGlvbnMuZmFtaWx5TmFtZSArIG9wdGlvbnMuc3R5bGVOYW1lKS5yZXBsYWNlKC9cXHMvZywgJycpfSxcblx0ICAgICAgICAgICAgZGVzaWduZXI6IHtlbjogb3B0aW9ucy5kZXNpZ25lciB8fCAnICd9LFxuXHQgICAgICAgICAgICBkZXNpZ25lclVSTDoge2VuOiBvcHRpb25zLmRlc2lnbmVyVVJMIHx8ICcgJ30sXG5cdCAgICAgICAgICAgIG1hbnVmYWN0dXJlcjoge2VuOiBvcHRpb25zLm1hbnVmYWN0dXJlciB8fCAnICd9LFxuXHQgICAgICAgICAgICBtYW51ZmFjdHVyZXJVUkw6IHtlbjogb3B0aW9ucy5tYW51ZmFjdHVyZXJVUkwgfHwgJyAnfSxcblx0ICAgICAgICAgICAgbGljZW5zZToge2VuOiBvcHRpb25zLmxpY2Vuc2UgfHwgJyAnfSxcblx0ICAgICAgICAgICAgbGljZW5zZVVSTDoge2VuOiBvcHRpb25zLmxpY2Vuc2VVUkwgfHwgJyAnfSxcblx0ICAgICAgICAgICAgdmVyc2lvbjoge2VuOiBvcHRpb25zLnZlcnNpb24gfHwgJ1ZlcnNpb24gMC4xJ30sXG5cdCAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB7ZW46IG9wdGlvbnMuZGVzY3JpcHRpb24gfHwgJyAnfSxcblx0ICAgICAgICAgICAgY29weXJpZ2h0OiB7ZW46IG9wdGlvbnMuY29weXJpZ2h0IHx8ICcgJ30sXG5cdCAgICAgICAgICAgIHRyYWRlbWFyazoge2VuOiBvcHRpb25zLnRyYWRlbWFyayB8fCAnICd9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLnVuaXRzUGVyRW0gPSBvcHRpb25zLnVuaXRzUGVyRW0gfHwgMTAwMDtcblx0ICAgICAgICB0aGlzLmFzY2VuZGVyID0gb3B0aW9ucy5hc2NlbmRlcjtcblx0ICAgICAgICB0aGlzLmRlc2NlbmRlciA9IG9wdGlvbnMuZGVzY2VuZGVyO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlZFRpbWVzdGFtcCA9IG9wdGlvbnMuY3JlYXRlZFRpbWVzdGFtcDtcblx0ICAgICAgICB0aGlzLnRhYmxlcyA9IHsgb3MyOiB7XG5cdCAgICAgICAgICAgIHVzV2VpZ2h0Q2xhc3M6IG9wdGlvbnMud2VpZ2h0Q2xhc3MgfHwgdGhpcy51c1dlaWdodENsYXNzZXMuTUVESVVNLFxuXHQgICAgICAgICAgICB1c1dpZHRoQ2xhc3M6IG9wdGlvbnMud2lkdGhDbGFzcyB8fCB0aGlzLnVzV2lkdGhDbGFzc2VzLk1FRElVTSxcblx0ICAgICAgICAgICAgZnNTZWxlY3Rpb246IG9wdGlvbnMuZnNTZWxlY3Rpb24gfHwgdGhpcy5mc1NlbGVjdGlvblZhbHVlcy5SRUdVTEFSXG5cdCAgICAgICAgfSB9O1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnN1cHBvcnRlZCA9IHRydWU7IC8vIERlcHJlY2F0ZWQ6IHBhcnNlQnVmZmVyIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgZm9udCBpcyBub3Qgc3VwcG9ydGVkLlxuXHQgICAgdGhpcy5nbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQodGhpcywgb3B0aW9ucy5nbHlwaHMgfHwgW10pO1xuXHQgICAgdGhpcy5lbmNvZGluZyA9IG5ldyBEZWZhdWx0RW5jb2RpbmcodGhpcyk7XG5cdCAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKHRoaXMpO1xuXHQgICAgdGhpcy5zdWJzdGl0dXRpb24gPSBuZXcgU3Vic3RpdHV0aW9uKHRoaXMpO1xuXHQgICAgdGhpcy50YWJsZXMgPSB0aGlzLnRhYmxlcyB8fCB7fTtcblxuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdoaW50aW5nJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9oaW50aW5nKSB7IHJldHVybiB0aGlzLl9oaW50aW5nOyB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm91dGxpbmVzRm9ybWF0ID09PSAndHJ1ZXR5cGUnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2hpbnRpbmcgPSBuZXcgSGludGluZyh0aGlzKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgZm9udCBoYXMgYSBnbHlwaCBmb3IgdGhlIGdpdmVuIGNoYXJhY3Rlci5cblx0ICogQHBhcmFtICB7c3RyaW5nfVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUuaGFzQ2hhciA9IGZ1bmN0aW9uKGMpIHtcblx0ICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgoYykgIT09IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhlIGdpdmVuIGNoYXJhY3RlciB0byBhIHNpbmdsZSBnbHlwaCBpbmRleC5cblx0ICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW5cblx0ICogdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cblx0ICogQHBhcmFtICB7c3RyaW5nfVxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24ocykge1xuXHQgICAgcmV0dXJuIHRoaXMuZW5jb2RpbmcuY2hhclRvR2x5cGhJbmRleChzKTtcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydCB0aGUgZ2l2ZW4gY2hhcmFjdGVyIHRvIGEgc2luZ2xlIEdseXBoIG9iamVjdC5cblx0ICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW5cblx0ICogdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cblx0ICogQHBhcmFtICB7c3RyaW5nfVxuXHQgKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cblx0ICovXG5cdEZvbnQucHJvdG90eXBlLmNoYXJUb0dseXBoID0gZnVuY3Rpb24oYykge1xuXHQgICAgdmFyIGdseXBoSW5kZXggPSB0aGlzLmNoYXJUb0dseXBoSW5kZXgoYyk7XG5cdCAgICB2YXIgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG5cdCAgICBpZiAoIWdseXBoKSB7XG5cdCAgICAgICAgLy8gLm5vdGRlZlxuXHQgICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZ2x5cGg7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhlIGdpdmVuIHRleHQgdG8gYSBsaXN0IG9mIEdseXBoIG9iamVjdHMuXG5cdCAqIE5vdGUgdGhhdCB0aGVyZSBpcyBubyBzdHJpY3Qgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW4gY2hhcmFjdGVycyBhbmRcblx0ICogZ2x5cGhzLCBzbyB0aGUgbGlzdCBvZiByZXR1cm5lZCBnbHlwaHMgY2FuIGJlIGxhcmdlciBvciBzbWFsbGVyIHRoYW4gdGhlXG5cdCAqIGxlbmd0aCBvZiB0aGUgZ2l2ZW4gc3RyaW5nLlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9XG5cdCAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9uc30gW29wdGlvbnNdXG5cdCAqIEByZXR1cm4ge29wZW50eXBlLkdseXBoW119XG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5zdHJpbmdUb0dseXBocyA9IGZ1bmN0aW9uKHMsIG9wdGlvbnMpIHtcblx0ICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zO1xuXHQgICAgLy8gR2V0IGdseXBoIGluZGV4ZXNcblx0ICAgIHZhciBjaGFycyA9IGFycmF5RnJvbVN0cmluZyhzKTtcblx0ICAgIHZhciBpbmRleGVzID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGMgPSBjaGFyc1tpXTtcblx0ICAgICAgICBpbmRleGVzLnB1c2godGhpcyQxLmNoYXJUb0dseXBoSW5kZXgoYykpO1xuXHQgICAgfVxuXHQgICAgdmFyIGxlbmd0aCA9IGluZGV4ZXMubGVuZ3RoO1xuXG5cdCAgICAvLyBBcHBseSBzdWJzdGl0dXRpb25zIG9uIGdseXBoIGluZGV4ZXNcblx0ICAgIGlmIChvcHRpb25zLmZlYXR1cmVzKSB7XG5cdCAgICAgICAgdmFyIHNjcmlwdCA9IG9wdGlvbnMuc2NyaXB0IHx8IHRoaXMuc3Vic3RpdHV0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCk7XG5cdCAgICAgICAgdmFyIG1hbnlUb09uZSA9IFtdO1xuXHQgICAgICAgIGlmIChvcHRpb25zLmZlYXR1cmVzLmxpZ2EpIHsgbWFueVRvT25lID0gbWFueVRvT25lLmNvbmNhdCh0aGlzLnN1YnN0aXR1dGlvbi5nZXRGZWF0dXJlKCdsaWdhJywgc2NyaXB0LCBvcHRpb25zLmxhbmd1YWdlKSk7IH1cblx0ICAgICAgICBpZiAob3B0aW9ucy5mZWF0dXJlcy5ybGlnKSB7IG1hbnlUb09uZSA9IG1hbnlUb09uZS5jb25jYXQodGhpcy5zdWJzdGl0dXRpb24uZ2V0RmVhdHVyZSgncmxpZycsIHNjcmlwdCwgb3B0aW9ucy5sYW5ndWFnZSkpOyB9XG5cdCAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGVuZ3RoOyBpJDEgKz0gMSkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hbnlUb09uZS5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGxpZ2F0dXJlID0gbWFueVRvT25lW2pdO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBsaWdhdHVyZS5zdWI7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29tcENvdW50ID0gY29tcG9uZW50cy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB2YXIgayA9IDA7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoayA8IGNvbXBDb3VudCAmJiBjb21wb25lbnRzW2tdID09PSBpbmRleGVzW2kkMSArIGtdKSB7IGsrKzsgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGsgPT09IGNvbXBDb3VudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGluZGV4ZXMuc3BsaWNlKGkkMSwgY29tcENvdW50LCBsaWdhdHVyZS5ieSk7XG5cdCAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gbGVuZ3RoIC0gY29tcENvdW50ICsgMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gY29udmVydCBnbHlwaCBpbmRleGVzIHRvIGdseXBoIG9iamVjdHNcblx0ICAgIHZhciBnbHlwaHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblx0ICAgIHZhciBub3RkZWYgPSB0aGlzLmdseXBocy5nZXQoMCk7XG5cdCAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBsZW5ndGg7IGkkMiArPSAxKSB7XG5cdCAgICAgICAgZ2x5cGhzW2kkMl0gPSB0aGlzJDEuZ2x5cGhzLmdldChpbmRleGVzW2kkMl0pIHx8IG5vdGRlZjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBnbHlwaHM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSAge3N0cmluZ31cblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUubmFtZVRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0ICAgIHJldHVybiB0aGlzLmdseXBoTmFtZXMubmFtZVRvR2x5cGhJbmRleChuYW1lKTtcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtICB7c3RyaW5nfVxuXHQgKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cblx0ICovXG5cdEZvbnQucHJvdG90eXBlLm5hbWVUb0dseXBoID0gZnVuY3Rpb24obmFtZSkge1xuXHQgICAgdmFyIGdseXBoSW5kZXggPSB0aGlzLm5hbWVUb0dseXBoSW5kZXgobmFtZSk7XG5cdCAgICB2YXIgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG5cdCAgICBpZiAoIWdseXBoKSB7XG5cdCAgICAgICAgLy8gLm5vdGRlZlxuXHQgICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZ2x5cGg7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSAge051bWJlcn1cblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUuZ2x5cGhJbmRleFRvTmFtZSA9IGZ1bmN0aW9uKGdpZCkge1xuXHQgICAgaWYgKCF0aGlzLmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZSkge1xuXHQgICAgICAgIHJldHVybiAnJztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKGdpZCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUga2VybmluZyBwYWlyIGJldHdlZW4gdGhlIGxlZnQgZ2x5cGggKG9yIGl0cyBpbmRleClcblx0ICogYW5kIHRoZSByaWdodCBnbHlwaCAob3IgaXRzIGluZGV4KS4gSWYgbm8ga2VybmluZyBwYWlyIGlzIGZvdW5kLCByZXR1cm4gMC5cblx0ICogVGhlIGtlcm5pbmcgdmFsdWUgZ2V0cyBhZGRlZCB0byB0aGUgYWR2YW5jZSB3aWR0aCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBzcGFjaW5nXG5cdCAqIGJldHdlZW4gZ2x5cGhzLlxuXHQgKiBGb3IgR1BPUyBrZXJuaW5nLCB0aGlzIG1ldGhvZCB1c2VzIHRoZSBkZWZhdWx0IHNjcmlwdCBhbmQgbGFuZ3VhZ2UsIHdoaWNoIGNvdmVyc1xuXHQgKiBtb3N0IHVzZSBjYXNlcy4gVG8gaGF2ZSBncmVhdGVyIGNvbnRyb2wsIHVzZSBmb250LnBvc2l0aW9uLmdldEtlcm5pbmdWYWx1ZSAuXG5cdCAqIEBwYXJhbSAge29wZW50eXBlLkdseXBofSBsZWZ0R2x5cGhcblx0ICogQHBhcmFtICB7b3BlbnR5cGUuR2x5cGh9IHJpZ2h0R2x5cGhcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUuZ2V0S2VybmluZ1ZhbHVlID0gZnVuY3Rpb24obGVmdEdseXBoLCByaWdodEdseXBoKSB7XG5cdCAgICBsZWZ0R2x5cGggPSBsZWZ0R2x5cGguaW5kZXggfHwgbGVmdEdseXBoO1xuXHQgICAgcmlnaHRHbHlwaCA9IHJpZ2h0R2x5cGguaW5kZXggfHwgcmlnaHRHbHlwaDtcblx0ICAgIHZhciBncG9zS2VybmluZyA9IHRoaXMucG9zaXRpb24uZGVmYXVsdEtlcm5pbmdUYWJsZXM7XG5cdCAgICBpZiAoZ3Bvc0tlcm5pbmcpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5nZXRLZXJuaW5nVmFsdWUoZ3Bvc0tlcm5pbmcsIGxlZnRHbHlwaCwgcmlnaHRHbHlwaCk7XG5cdCAgICB9XG5cdCAgICAvLyBcImtlcm5cIiB0YWJsZVxuXHQgICAgcmV0dXJuIHRoaXMua2VybmluZ1BhaXJzW2xlZnRHbHlwaCArICcsJyArIHJpZ2h0R2x5cGhdIHx8IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIEB0eXBlZGVmIEdseXBoUmVuZGVyT3B0aW9uc1xuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtzY3JpcHRdIC0gc2NyaXB0IHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGZlYXR1cmVzIHRvIGFwcGx5LiBCeSBkZWZhdWx0LCAnREZMVCcgb3IgJ2xhdG4nIGlzIHVzZWQuXG5cdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL3NjcmlwdHRhZ3MuaHRtXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXSAtIGxhbmd1YWdlIHN5c3RlbSB1c2VkIHRvIGRldGVybWluZSB3aGljaCBmZWF0dXJlcyB0byBhcHBseS5cblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9kZXZlbG9wZXJzL29wZW50eXBlL2xhbmd1YWdldGFncy5hc3B4XG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tlcm5pbmc9dHJ1ZV0gLSB3aGV0aGVyIHRvIGluY2x1ZGUga2VybmluZyB2YWx1ZXNcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IFtmZWF0dXJlc10gLSBPcGVuVHlwZSBMYXlvdXQgZmVhdHVyZSB0YWdzLiBVc2VkIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBmZWF0dXJlcyBvZiB0aGUgZ2l2ZW4gc2NyaXB0L2xhbmd1YWdlIHN5c3RlbS5cblx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYy9mZWF0dXJldGFncy5odG1cblx0ICovXG5cdEZvbnQucHJvdG90eXBlLmRlZmF1bHRSZW5kZXJPcHRpb25zID0ge1xuXHQgICAga2VybmluZzogdHJ1ZSxcblx0ICAgIGZlYXR1cmVzOiB7XG5cdCAgICAgICAgbGlnYTogdHJ1ZSxcblx0ICAgICAgICBybGlnOiB0cnVlXG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBlYWNoIGdseXBoIGluIHRoZSBnaXZlbiB0ZXh0LlxuXHQgKiBUaGUgY2FsbGJhY2sgZ2V0cyBgKGdseXBoLCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucylgLiogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gYXBwbHkuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cblx0ICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuXHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICovXG5cdEZvbnQucHJvdG90eXBlLmZvckVhY2hHbHlwaCA9IGZ1bmN0aW9uKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHQgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcblx0ICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcblx0ICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG5cdCAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zO1xuXHQgICAgdmFyIGZvbnRTY2FsZSA9IDEgLyB0aGlzLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcblx0ICAgIHZhciBnbHlwaHMgPSB0aGlzLnN0cmluZ1RvR2x5cGhzKHRleHQsIG9wdGlvbnMpO1xuXHQgICAgdmFyIGtlcm5pbmdMb29rdXBzO1xuXHQgICAgaWYgKG9wdGlvbnMua2VybmluZykge1xuXHQgICAgICAgIHZhciBzY3JpcHQgPSBvcHRpb25zLnNjcmlwdCB8fCB0aGlzLnBvc2l0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCk7XG5cdCAgICAgICAga2VybmluZ0xvb2t1cHMgPSB0aGlzLnBvc2l0aW9uLmdldEtlcm5pbmdUYWJsZXMoc2NyaXB0LCBvcHRpb25zLmxhbmd1YWdlKTtcblx0ICAgIH1cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuXHQgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcyQxLCBnbHlwaCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpO1xuXHQgICAgICAgIGlmIChnbHlwaC5hZHZhbmNlV2lkdGgpIHtcblx0ICAgICAgICAgICAgeCArPSBnbHlwaC5hZHZhbmNlV2lkdGggKiBmb250U2NhbGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMua2VybmluZyAmJiBpIDwgZ2x5cGhzLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGFwcGx5IHBvc2l0aW9uIGFkanVzdG1lbnQgbG9va3VwcyBpbiBhIG1vcmUgZ2VuZXJpYyB3YXkuXG5cdCAgICAgICAgICAgIC8vIEhlcmUgd2Ugb25seSB1c2UgdGhlIHhBZHZhbmNlIHZhbHVlLlxuXHQgICAgICAgICAgICB2YXIga2VybmluZ1ZhbHVlID0ga2VybmluZ0xvb2t1cHMgP1xuXHQgICAgICAgICAgICAgICAgICB0aGlzJDEucG9zaXRpb24uZ2V0S2VybmluZ1ZhbHVlKGtlcm5pbmdMb29rdXBzLCBnbHlwaC5pbmRleCwgZ2x5cGhzW2kgKyAxXS5pbmRleCkgOlxuXHQgICAgICAgICAgICAgICAgICB0aGlzJDEuZ2V0S2VybmluZ1ZhbHVlKGdseXBoLCBnbHlwaHNbaSArIDFdKTtcblx0ICAgICAgICAgICAgeCArPSBrZXJuaW5nVmFsdWUgKiBmb250U2NhbGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMubGV0dGVyU3BhY2luZykge1xuXHQgICAgICAgICAgICB4ICs9IG9wdGlvbnMubGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuXHQgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50cmFja2luZykge1xuXHQgICAgICAgICAgICB4ICs9IChvcHRpb25zLnRyYWNraW5nIC8gMTAwMCkgKiBmb250U2l6ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4geDtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cblx0ICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuXHQgKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRofVxuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG5cdCAgICB2YXIgZnVsbFBhdGggPSBuZXcgUGF0aCgpO1xuXHQgICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuXHQgICAgICAgIHZhciBnbHlwaFBhdGggPSBnbHlwaC5nZXRQYXRoKGdYLCBnWSwgZ0ZvbnRTaXplLCBvcHRpb25zLCB0aGlzKTtcblx0ICAgICAgICBmdWxsUGF0aC5leHRlbmQoZ2x5cGhQYXRoKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIGZ1bGxQYXRoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gYXJyYXkgb2YgUGF0aCBvYmplY3RzIHRoYXQgcmVwcmVzZW50IHRoZSBnbHlwaHMgb2YgYSBnaXZlbiB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cblx0ICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cblx0ICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuXHQgKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRoW119XG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5nZXRQYXRocyA9IGZ1bmN0aW9uKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG5cdCAgICB2YXIgZ2x5cGhQYXRocyA9IFtdO1xuXHQgICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuXHQgICAgICAgIHZhciBnbHlwaFBhdGggPSBnbHlwaC5nZXRQYXRoKGdYLCBnWSwgZ0ZvbnRTaXplLCBvcHRpb25zLCB0aGlzKTtcblx0ICAgICAgICBnbHlwaFBhdGhzLnB1c2goZ2x5cGhQYXRoKTtcblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gZ2x5cGhQYXRocztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYWR2YW5jZSB3aWR0aCBvZiBhIHRleHQuXG5cdCAqXG5cdCAqIFRoaXMgaXMgc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIFBhdGguZ2V0Qm91bmRpbmdCb3goKSBhcyBmb3IgZXhhbXBsZSBhXG5cdCAqIHN1ZmZpeGVkIHdoaXRlc3BhY2UgaW5jcmVhc2VzIHRoZSBhZHZhbmNlV2lkdGggYnV0IG5vdCB0aGUgYm91bmRpbmcgYm94XG5cdCAqIG9yIGFuIG92ZXJoYW5naW5nIGxldHRlciBsaWtlIGEgY2FsbGlncmFwaGljICdmJyBtaWdodCBoYXZlIGEgcXVpdGUgbGFyZ2VyXG5cdCAqIGJvdW5kaW5nIGJveCB0aGFuIGl0cyBhZHZhbmNlIHdpZHRoLlxuXHQgKlxuXHQgKiBUaGlzIGNvcnJlc3BvbmRzIHRvIGNhbnZhczJkQ29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aFxuXHQgKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG5cdCAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcblx0ICogQHJldHVybiBhZHZhbmNlIHdpZHRoXG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5nZXRBZHZhbmNlV2lkdGggPSBmdW5jdGlvbih0ZXh0LCBmb250U2l6ZSwgb3B0aW9ucykge1xuXHQgICAgcmV0dXJuIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIDAsIDAsIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbigpIHt9KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhdyB0aGUgdGV4dCBvbiB0aGUgZ2l2ZW4gZHJhd2luZyBjb250ZXh0LlxuXHQgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cblx0ICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuXHQgKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG5cdCAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcblx0ICovXG5cdEZvbnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG5cdCAgICB0aGlzLmdldFBhdGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpLmRyYXcoY3R4KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhdyB0aGUgcG9pbnRzIG9mIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG5cdCAqIE9uLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIGJsdWUsIG9mZi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiByZWQuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG5cdCAqIEBwYXJhbSB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUuZHJhd1BvaW50cyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcblx0ICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbihnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcblx0ICAgICAgICBnbHlwaC5kcmF3UG9pbnRzKGN0eCwgZ1gsIGdZLCBnRm9udFNpemUpO1xuXHQgICAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXcgbGluZXMgaW5kaWNhdGluZyBpbXBvcnRhbnQgZm9udCBtZWFzdXJlbWVudHMgZm9yIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG5cdCAqIEJsYWNrIGxpbmVzIGluZGljYXRlIHRoZSBvcmlnaW4gb2YgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIChwb2ludCAwLDApLlxuXHQgKiBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG5cdCAqIEdyZWVuIGxpbmUgaW5kaWNhdGVzIHRoZSBhZHZhbmNlIHdpZHRoIG9mIHRoZSBnbHlwaC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cblx0ICogQHBhcmFtIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcblx0ICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbihnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcblx0ICAgICAgICBnbHlwaC5kcmF3TWV0cmljcyhjdHgsIGdYLCBnWSwgZ0ZvbnRTaXplKTtcblx0ICAgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9XG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdEZvbnQucHJvdG90eXBlLmdldEVuZ2xpc2hOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuXHQgICAgdmFyIHRyYW5zbGF0aW9ucyA9IHRoaXMubmFtZXNbbmFtZV07XG5cdCAgICBpZiAodHJhbnNsYXRpb25zKSB7XG5cdCAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9ucy5lbjtcblx0ICAgIH1cblx0fTtcblxuXHQvKipcblx0ICogVmFsaWRhdGVcblx0ICovXG5cdEZvbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdCAgICBmdW5jdGlvbiBhc3NlcnQocHJlZGljYXRlLCBtZXNzYWdlKSB7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGFzc2VydE5hbWVQcmVzZW50KG5hbWUpIHtcblx0ICAgICAgICB2YXIgZW5nbGlzaE5hbWUgPSBfdGhpcy5nZXRFbmdsaXNoTmFtZShuYW1lKTtcblx0ICAgICAgICBhc3NlcnQoZW5nbGlzaE5hbWUgJiYgZW5nbGlzaE5hbWUudHJpbSgpLmxlbmd0aCA+IDAsXG5cdCAgICAgICAgICAgICAgICdObyBFbmdsaXNoICcgKyBuYW1lICsgJyBzcGVjaWZpZWQuJyk7XG5cdCAgICB9XG5cblx0ICAgIC8vIElkZW50aWZpY2F0aW9uIGluZm9ybWF0aW9uXG5cdCAgICBhc3NlcnROYW1lUHJlc2VudCgnZm9udEZhbWlseScpO1xuXHQgICAgYXNzZXJ0TmFtZVByZXNlbnQoJ3dlaWdodE5hbWUnKTtcblx0ICAgIGFzc2VydE5hbWVQcmVzZW50KCdtYW51ZmFjdHVyZXInKTtcblx0ICAgIGFzc2VydE5hbWVQcmVzZW50KCdjb3B5cmlnaHQnKTtcblx0ICAgIGFzc2VydE5hbWVQcmVzZW50KCd2ZXJzaW9uJyk7XG5cblx0ICAgIC8vIERpbWVuc2lvbiBpbmZvcm1hdGlvblxuXHQgICAgYXNzZXJ0KHRoaXMudW5pdHNQZXJFbSA+IDAsICdObyB1bml0c1BlckVtIHNwZWNpZmllZC4nKTtcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydCB0aGUgZm9udCBvYmplY3QgdG8gYSBTRk5UIGRhdGEgc3RydWN0dXJlLlxuXHQgKiBUaGlzIHN0cnVjdHVyZSBjb250YWlucyBhbGwgdGhlIG5lY2Vzc2FyeSB0YWJsZXMgYW5kIG1ldGFkYXRhIHRvIGNyZWF0ZSBhIGJpbmFyeSBPVEYgZmlsZS5cblx0ICogQHJldHVybiB7b3BlbnR5cGUuVGFibGV9XG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS50b1RhYmxlcyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHNmbnQuZm9udFRvVGFibGUodGhpcyk7XG5cdH07XG5cdC8qKlxuXHQgKiBAZGVwcmVjYXRlZCBGb250LnRvQnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBGb250LnRvQXJyYXlCdWZmZXIgaW5zdGVhZC5cblx0ICovXG5cdEZvbnQucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oKSB7XG5cdCAgICBjb25zb2xlLndhcm4oJ0ZvbnQudG9CdWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIEZvbnQudG9BcnJheUJ1ZmZlciBpbnN0ZWFkLicpO1xuXHQgICAgcmV0dXJuIHRoaXMudG9BcnJheUJ1ZmZlcigpO1xuXHR9O1xuXHQvKipcblx0ICogQ29udmVydHMgYSBgb3BlbnR5cGUuRm9udGAgaW50byBhbiBgQXJyYXlCdWZmZXJgXG5cdCAqIEByZXR1cm4ge0FycmF5QnVmZmVyfVxuXHQgKi9cblx0Rm9udC5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHNmbnRUYWJsZSA9IHRoaXMudG9UYWJsZXMoKTtcblx0ICAgIHZhciBieXRlcyA9IHNmbnRUYWJsZS5lbmNvZGUoKTtcblx0ICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMubGVuZ3RoKTtcblx0ICAgIHZhciBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaW50QXJyYXlbaV0gPSBieXRlc1tpXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGJ1ZmZlcjtcblx0fTtcblxuXHQvKipcblx0ICogSW5pdGlhdGUgYSBkb3dubG9hZCBvZiB0aGUgT3BlblR5cGUgZm9udC5cblx0ICovXG5cdEZvbnQucHJvdG90eXBlLmRvd25sb2FkID0gZnVuY3Rpb24oZmlsZU5hbWUpIHtcblx0ICAgIHZhciBmYW1pbHlOYW1lID0gdGhpcy5nZXRFbmdsaXNoTmFtZSgnZm9udEZhbWlseScpO1xuXHQgICAgdmFyIHN0eWxlTmFtZSA9IHRoaXMuZ2V0RW5nbGlzaE5hbWUoJ2ZvbnRTdWJmYW1pbHknKTtcblx0ICAgIGZpbGVOYW1lID0gZmlsZU5hbWUgfHwgZmFtaWx5TmFtZS5yZXBsYWNlKC9cXHMvZywgJycpICsgJy0nICsgc3R5bGVOYW1lICsgJy5vdGYnO1xuXHQgICAgdmFyIGFycmF5QnVmZmVyID0gdGhpcy50b0FycmF5QnVmZmVyKCk7XG5cblx0ICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuXHQgICAgICAgIHdpbmRvdy5VUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG5cblx0ICAgICAgICBpZiAod2luZG93LlVSTCkge1xuXHQgICAgICAgICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuXHQgICAgICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtkYXRhVmlld10sIHt0eXBlOiAnZm9udC9vcGVudHlwZSd9KTtcblxuXHQgICAgICAgICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0ICAgICAgICAgICAgbGluay5ocmVmID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cdCAgICAgICAgICAgIGxpbmsuZG93bmxvYWQgPSBmaWxlTmFtZTtcblxuXHQgICAgICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcblx0ICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KCdjbGljaycsIHRydWUsIGZhbHNlKTtcblx0ICAgICAgICAgICAgbGluay5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZvbnQgZmlsZSBjb3VsZCBub3QgYmUgZG93bmxvYWRlZC4gVHJ5IHVzaW5nIGEgZGlmZmVyZW50IGJyb3dzZXIuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXHQgICAgICAgIHZhciBidWZmZXIgPSBhcnJheUJ1ZmZlclRvTm9kZUJ1ZmZlcihhcnJheUJ1ZmZlcik7XG5cdCAgICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlTmFtZSwgYnVmZmVyKTtcblx0ICAgIH1cblx0fTtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS5mc1NlbGVjdGlvblZhbHVlcyA9IHtcblx0ICAgIElUQUxJQzogICAgICAgICAgICAgIDB4MDAxLCAvLzFcblx0ICAgIFVOREVSU0NPUkU6ICAgICAgICAgIDB4MDAyLCAvLzJcblx0ICAgIE5FR0FUSVZFOiAgICAgICAgICAgIDB4MDA0LCAvLzRcblx0ICAgIE9VVExJTkVEOiAgICAgICAgICAgIDB4MDA4LCAvLzhcblx0ICAgIFNUUklLRU9VVDogICAgICAgICAgIDB4MDEwLCAvLzE2XG5cdCAgICBCT0xEOiAgICAgICAgICAgICAgICAweDAyMCwgLy8zMlxuXHQgICAgUkVHVUxBUjogICAgICAgICAgICAgMHgwNDAsIC8vNjRcblx0ICAgIFVTRVJfVFlQT19NRVRSSUNTOiAgIDB4MDgwLCAvLzEyOFxuXHQgICAgV1dTOiAgICAgICAgICAgICAgICAgMHgxMDAsIC8vMjU2XG5cdCAgICBPQkxJUVVFOiAgICAgICAgICAgICAweDIwMCAgLy81MTJcblx0fTtcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdEZvbnQucHJvdG90eXBlLnVzV2lkdGhDbGFzc2VzID0ge1xuXHQgICAgVUxUUkFfQ09OREVOU0VEOiAxLFxuXHQgICAgRVhUUkFfQ09OREVOU0VEOiAyLFxuXHQgICAgQ09OREVOU0VEOiAzLFxuXHQgICAgU0VNSV9DT05ERU5TRUQ6IDQsXG5cdCAgICBNRURJVU06IDUsXG5cdCAgICBTRU1JX0VYUEFOREVEOiA2LFxuXHQgICAgRVhQQU5ERUQ6IDcsXG5cdCAgICBFWFRSQV9FWFBBTkRFRDogOCxcblx0ICAgIFVMVFJBX0VYUEFOREVEOiA5XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRGb250LnByb3RvdHlwZS51c1dlaWdodENsYXNzZXMgPSB7XG5cdCAgICBUSElOOiAxMDAsXG5cdCAgICBFWFRSQV9MSUdIVDogMjAwLFxuXHQgICAgTElHSFQ6IDMwMCxcblx0ICAgIE5PUk1BTDogNDAwLFxuXHQgICAgTUVESVVNOiA1MDAsXG5cdCAgICBTRU1JX0JPTEQ6IDYwMCxcblx0ICAgIEJPTEQ6IDcwMCxcblx0ICAgIEVYVFJBX0JPTEQ6IDgwMCxcblx0ICAgIEJMQUNLOiAgICA5MDBcblx0fTtcblxuXHQvLyBUaGUgYGZ2YXJgIHRhYmxlIHN0b3JlcyBmb250IHZhcmlhdGlvbiBheGVzIGFuZCBpbnN0YW5jZXMuXG5cblx0ZnVuY3Rpb24gYWRkTmFtZShuYW1lLCBuYW1lcykge1xuXHQgICAgdmFyIG5hbWVTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShuYW1lKTtcblx0ICAgIHZhciBuYW1lSUQgPSAyNTY7XG5cdCAgICBmb3IgKHZhciBuYW1lS2V5IGluIG5hbWVzKSB7XG5cdCAgICAgICAgdmFyIG4gPSBwYXJzZUludChuYW1lS2V5KTtcblx0ICAgICAgICBpZiAoIW4gfHwgbiA8IDI1Nikge1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkobmFtZXNbbmFtZUtleV0pID09PSBuYW1lU3RyaW5nKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChuYW1lSUQgPD0gbikge1xuXHQgICAgICAgICAgICBuYW1lSUQgPSBuICsgMTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIG5hbWVzW25hbWVJRF0gPSBuYW1lO1xuXHQgICAgcmV0dXJuIG5hbWVJRDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VGdmFyQXhpcyhuLCBheGlzLCBuYW1lcykge1xuXHQgICAgdmFyIG5hbWVJRCA9IGFkZE5hbWUoYXhpcy5uYW1lLCBuYW1lcyk7XG5cdCAgICByZXR1cm4gW1xuXHQgICAgICAgIHtuYW1lOiAndGFnXycgKyBuLCB0eXBlOiAnVEFHJywgdmFsdWU6IGF4aXMudGFnfSxcblx0ICAgICAgICB7bmFtZTogJ21pblZhbHVlXycgKyBuLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogYXhpcy5taW5WYWx1ZSA8PCAxNn0sXG5cdCAgICAgICAge25hbWU6ICdkZWZhdWx0VmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLmRlZmF1bHRWYWx1ZSA8PCAxNn0sXG5cdCAgICAgICAge25hbWU6ICdtYXhWYWx1ZV8nICsgbiwgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IGF4aXMubWF4VmFsdWUgPDwgMTZ9LFxuXHQgICAgICAgIHtuYW1lOiAnZmxhZ3NfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG5cdCAgICAgICAge25hbWU6ICduYW1lSURfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfVxuXHQgICAgXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlRnZhckF4aXMoZGF0YSwgc3RhcnQsIG5hbWVzKSB7XG5cdCAgICB2YXIgYXhpcyA9IHt9O1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIGF4aXMudGFnID0gcC5wYXJzZVRhZygpO1xuXHQgICAgYXhpcy5taW5WYWx1ZSA9IHAucGFyc2VGaXhlZCgpO1xuXHQgICAgYXhpcy5kZWZhdWx0VmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcblx0ICAgIGF4aXMubWF4VmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcblx0ICAgIHAuc2tpcCgndVNob3J0JywgMSk7ICAvLyByZXNlcnZlZCBmb3IgZmxhZ3M7IG5vIHZhbHVlcyBkZWZpbmVkXG5cdCAgICBheGlzLm5hbWUgPSBuYW1lc1twLnBhcnNlVVNob3J0KCldIHx8IHt9O1xuXHQgICAgcmV0dXJuIGF4aXM7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlRnZhckluc3RhbmNlKG4sIGluc3QsIGF4ZXMsIG5hbWVzKSB7XG5cdCAgICB2YXIgbmFtZUlEID0gYWRkTmFtZShpbnN0Lm5hbWUsIG5hbWVzKTtcblx0ICAgIHZhciBmaWVsZHMgPSBbXG5cdCAgICAgICAge25hbWU6ICduYW1lSURfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfSxcblx0ICAgICAgICB7bmFtZTogJ2ZsYWdzXycgKyBuLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG5cdCAgICBdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICB2YXIgYXhpc1RhZyA9IGF4ZXNbaV0udGFnO1xuXHQgICAgICAgIGZpZWxkcy5wdXNoKHtcblx0ICAgICAgICAgICAgbmFtZTogJ2F4aXNfJyArIG4gKyAnICcgKyBheGlzVGFnLFxuXHQgICAgICAgICAgICB0eXBlOiAnRklYRUQnLFxuXHQgICAgICAgICAgICB2YWx1ZTogaW5zdC5jb29yZGluYXRlc1theGlzVGFnXSA8PCAxNlxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZmllbGRzO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VGdmFySW5zdGFuY2UoZGF0YSwgc3RhcnQsIGF4ZXMsIG5hbWVzKSB7XG5cdCAgICB2YXIgaW5zdCA9IHt9O1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIGluc3QubmFtZSA9IG5hbWVzW3AucGFyc2VVU2hvcnQoKV0gfHwge307XG5cdCAgICBwLnNraXAoJ3VTaG9ydCcsIDEpOyAgLy8gcmVzZXJ2ZWQgZm9yIGZsYWdzOyBubyB2YWx1ZXMgZGVmaW5lZFxuXG5cdCAgICBpbnN0LmNvb3JkaW5hdGVzID0ge307XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICBpbnN0LmNvb3JkaW5hdGVzW2F4ZXNbaV0udGFnXSA9IHAucGFyc2VGaXhlZCgpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gaW5zdDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VGdmFyVGFibGUoZnZhciwgbmFtZXMpIHtcblx0ICAgIHZhciByZXN1bHQgPSBuZXcgdGFibGUuVGFibGUoJ2Z2YXInLCBbXG5cdCAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4MTAwMDB9LFxuXHQgICAgICAgIHtuYW1lOiAnb2Zmc2V0VG9EYXRhJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcblx0ICAgICAgICB7bmFtZTogJ2NvdW50U2l6ZVBhaXJzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAyfSxcblx0ICAgICAgICB7bmFtZTogJ2F4aXNDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZnZhci5heGVzLmxlbmd0aH0sXG5cdCAgICAgICAge25hbWU6ICdheGlzU2l6ZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMjB9LFxuXHQgICAgICAgIHtuYW1lOiAnaW5zdGFuY2VDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZnZhci5pbnN0YW5jZXMubGVuZ3RofSxcblx0ICAgICAgICB7bmFtZTogJ2luc3RhbmNlU2l6ZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogNCArIGZ2YXIuYXhlcy5sZW5ndGggKiA0fVxuXHQgICAgXSk7XG5cdCAgICByZXN1bHQub2Zmc2V0VG9EYXRhID0gcmVzdWx0LnNpemVPZigpO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ2YXIuYXhlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHJlc3VsdC5maWVsZHMgPSByZXN1bHQuZmllbGRzLmNvbmNhdChtYWtlRnZhckF4aXMoaSwgZnZhci5heGVzW2ldLCBuYW1lcykpO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZ2YXIuaW5zdGFuY2VzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgcmVzdWx0LmZpZWxkcyA9IHJlc3VsdC5maWVsZHMuY29uY2F0KG1ha2VGdmFySW5zdGFuY2UoaiwgZnZhci5pbnN0YW5jZXNbal0sIGZ2YXIuYXhlcywgbmFtZXMpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlRnZhclRhYmxlKGRhdGEsIHN0YXJ0LCBuYW1lcykge1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcblx0ICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMHgwMDAxMDAwMCwgJ1Vuc3VwcG9ydGVkIGZ2YXIgdGFibGUgdmVyc2lvbi4nKTtcblx0ICAgIHZhciBvZmZzZXRUb0RhdGEgPSBwLnBhcnNlT2Zmc2V0MTYoKTtcblx0ICAgIC8vIFNraXAgY291bnRTaXplUGFpcnMuXG5cdCAgICBwLnNraXAoJ3VTaG9ydCcsIDEpO1xuXHQgICAgdmFyIGF4aXNDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIHZhciBheGlzU2l6ZSA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIHZhciBpbnN0YW5jZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgdmFyIGluc3RhbmNlU2l6ZSA9IHAucGFyc2VVU2hvcnQoKTtcblxuXHQgICAgdmFyIGF4ZXMgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpc0NvdW50OyBpKyspIHtcblx0ICAgICAgICBheGVzLnB1c2gocGFyc2VGdmFyQXhpcyhkYXRhLCBzdGFydCArIG9mZnNldFRvRGF0YSArIGkgKiBheGlzU2l6ZSwgbmFtZXMpKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuXHQgICAgdmFyIGluc3RhbmNlU3RhcnQgPSBzdGFydCArIG9mZnNldFRvRGF0YSArIGF4aXNDb3VudCAqIGF4aXNTaXplO1xuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnN0YW5jZUNvdW50OyBqKyspIHtcblx0ICAgICAgICBpbnN0YW5jZXMucHVzaChwYXJzZUZ2YXJJbnN0YW5jZShkYXRhLCBpbnN0YW5jZVN0YXJ0ICsgaiAqIGluc3RhbmNlU2l6ZSwgYXhlcywgbmFtZXMpKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtheGVzOiBheGVzLCBpbnN0YW5jZXM6IGluc3RhbmNlc307XG5cdH1cblxuXHR2YXIgZnZhciA9IHsgbWFrZTogbWFrZUZ2YXJUYWJsZSwgcGFyc2U6IHBhcnNlRnZhclRhYmxlIH07XG5cblx0Ly8gVGhlIGBHUE9TYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG5cblx0dmFyIHN1YnRhYmxlUGFyc2VycyQxID0gbmV3IEFycmF5KDEwKTsgICAgICAgICAvLyBzdWJ0YWJsZVBhcnNlcnNbMF0gaXMgdW51c2VkXG5cblx0Ly8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjbG9va3VwLXR5cGUtMS1zaW5nbGUtYWRqdXN0bWVudC1wb3NpdGlvbmluZy1zdWJ0YWJsZVxuXHQvLyB0aGlzID0gUGFyc2VyIGluc3RhbmNlXG5cdHN1YnRhYmxlUGFyc2VycyQxWzFdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAxKCkge1xuXHQgICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuXHQgICAgdmFyIHBvc2Zvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIGlmIChwb3Nmb3JtYXQgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBwb3NGb3JtYXQ6IDEsXG5cdCAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuXHQgICAgICAgICAgICB2YWx1ZTogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKClcblx0ICAgICAgICB9O1xuXHQgICAgfSBlbHNlIGlmIChwb3Nmb3JtYXQgPT09IDIpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBwb3NGb3JtYXQ6IDIsXG5cdCAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuXHQgICAgICAgICAgICB2YWx1ZXM6IHRoaXMucGFyc2VWYWx1ZVJlY29yZExpc3QoKVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICBjaGVjay5hc3NlcnQoZmFsc2UsICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBHUE9TIGxvb2t1cCB0eXBlIDEgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xuXHR9O1xuXG5cdC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI2xvb2t1cC10eXBlLTItcGFpci1hZGp1c3RtZW50LXBvc2l0aW9uaW5nLXN1YnRhYmxlXG5cdHN1YnRhYmxlUGFyc2VycyQxWzJdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAyKCkge1xuXHQgICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuXHQgICAgdmFyIHBvc0Zvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIGNoZWNrLmFzc2VydChwb3NGb3JtYXQgPT09IDEgfHwgcG9zRm9ybWF0ID09PSAyLCAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogR1BPUyBsb29rdXAgdHlwZSAyIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcblx0ICAgIHZhciBjb3ZlcmFnZSA9IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSk7XG5cdCAgICB2YXIgdmFsdWVGb3JtYXQxID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXHQgICAgdmFyIHZhbHVlRm9ybWF0MiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgIGlmIChwb3NGb3JtYXQgPT09IDEpIHtcblx0ICAgICAgICAvLyBBZGp1c3RtZW50cyBmb3IgR2x5cGggUGFpcnNcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBwb3NGb3JtYXQ6IHBvc0Zvcm1hdCxcblx0ICAgICAgICAgICAgY292ZXJhZ2U6IGNvdmVyYWdlLFxuXHQgICAgICAgICAgICB2YWx1ZUZvcm1hdDE6IHZhbHVlRm9ybWF0MSxcblx0ICAgICAgICAgICAgdmFsdWVGb3JtYXQyOiB2YWx1ZUZvcm1hdDIsXG5cdCAgICAgICAgICAgIHBhaXJTZXRzOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIubGlzdChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7ICAgICAgICAvLyBwYWlyVmFsdWVSZWNvcmRcblx0ICAgICAgICAgICAgICAgICAgICBzZWNvbmRHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlMTogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MSksXG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQyKVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSkpKVxuXHQgICAgICAgIH07XG5cdCAgICB9IGVsc2UgaWYgKHBvc0Zvcm1hdCA9PT0gMikge1xuXHQgICAgICAgIHZhciBjbGFzc0RlZjEgPSB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpO1xuXHQgICAgICAgIHZhciBjbGFzc0RlZjIgPSB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpO1xuXHQgICAgICAgIHZhciBjbGFzczFDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblx0ICAgICAgICB2YXIgY2xhc3MyQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgLy8gQ2xhc3MgUGFpciBBZGp1c3RtZW50XG5cdCAgICAgICAgICAgIHBvc0Zvcm1hdDogcG9zRm9ybWF0LFxuXHQgICAgICAgICAgICBjb3ZlcmFnZTogY292ZXJhZ2UsXG5cdCAgICAgICAgICAgIHZhbHVlRm9ybWF0MTogdmFsdWVGb3JtYXQxLFxuXHQgICAgICAgICAgICB2YWx1ZUZvcm1hdDI6IHZhbHVlRm9ybWF0Mixcblx0ICAgICAgICAgICAgY2xhc3NEZWYxOiBjbGFzc0RlZjEsXG5cdCAgICAgICAgICAgIGNsYXNzRGVmMjogY2xhc3NEZWYyLFxuXHQgICAgICAgICAgICBjbGFzczFDb3VudDogY2xhc3MxQ291bnQsXG5cdCAgICAgICAgICAgIGNsYXNzMkNvdW50OiBjbGFzczJDb3VudCxcblx0ICAgICAgICAgICAgY2xhc3NSZWNvcmRzOiB0aGlzLnBhcnNlTGlzdChjbGFzczFDb3VudCwgUGFyc2VyLmxpc3QoY2xhc3MyQ291bnQsIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTE6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdDEpLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlMjogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0Milcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pKVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdH07XG5cblx0c3VidGFibGVQYXJzZXJzJDFbM10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDMoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgMyBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuXHRzdWJ0YWJsZVBhcnNlcnMkMVs0XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNCgpIHsgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA0IG5vdCBzdXBwb3J0ZWQnIH07IH07XG5cdHN1YnRhYmxlUGFyc2VycyQxWzVdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA1KCkgeyByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDUgbm90IHN1cHBvcnRlZCcgfTsgfTtcblx0c3VidGFibGVQYXJzZXJzJDFbNl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDYoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNiBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuXHRzdWJ0YWJsZVBhcnNlcnMkMVs3XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNygpIHsgcmV0dXJuIHsgZXJyb3I6ICdHUE9TIExvb2t1cCA3IG5vdCBzdXBwb3J0ZWQnIH07IH07XG5cdHN1YnRhYmxlUGFyc2VycyQxWzhdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA4KCkgeyByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDggbm90IHN1cHBvcnRlZCcgfTsgfTtcblx0c3VidGFibGVQYXJzZXJzJDFbOV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDkoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgOSBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuXG5cdC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zXG5cdGZ1bmN0aW9uIHBhcnNlR3Bvc1RhYmxlKGRhdGEsIHN0YXJ0KSB7XG5cdCAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdCAgICB2YXIgcCA9IG5ldyBQYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKDEpO1xuXHQgICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4xLCAnVW5zdXBwb3J0ZWQgR1BPUyB0YWJsZSB2ZXJzaW9uICcgKyB0YWJsZVZlcnNpb24pO1xuXG5cdCAgICBpZiAodGFibGVWZXJzaW9uID09PSAxKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuXHQgICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuXHQgICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG5cdCAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycyQxKVxuXHQgICAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcblx0ICAgICAgICAgICAgc2NyaXB0czogcC5wYXJzZVNjcmlwdExpc3QoKSxcblx0ICAgICAgICAgICAgZmVhdHVyZXM6IHAucGFyc2VGZWF0dXJlTGlzdCgpLFxuXHQgICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMkMSksXG5cdCAgICAgICAgICAgIHZhcmlhdGlvbnM6IHAucGFyc2VGZWF0dXJlVmFyaWF0aW9uc0xpc3QoKVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cblx0fVxuXG5cdC8vIEdQT1MgV3JpdGluZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vIE5PVCBTVVBQT1JURURcblx0dmFyIHN1YnRhYmxlTWFrZXJzJDEgPSBuZXcgQXJyYXkoMTApO1xuXG5cdGZ1bmN0aW9uIG1ha2VHcG9zVGFibGUoZ3Bvcykge1xuXHQgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnR1BPUycsIFtcblx0ICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMHgxMDAwMH0sXG5cdCAgICAgICAge25hbWU6ICdzY3JpcHRzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5TY3JpcHRMaXN0KGdwb3Muc2NyaXB0cyl9LFxuXHQgICAgICAgIHtuYW1lOiAnZmVhdHVyZXMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkZlYXR1cmVMaXN0KGdwb3MuZmVhdHVyZXMpfSxcblx0ICAgICAgICB7bmFtZTogJ2xvb2t1cHMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkxvb2t1cExpc3QoZ3Bvcy5sb29rdXBzLCBzdWJ0YWJsZU1ha2VycyQxKX1cblx0ICAgIF0pO1xuXHR9XG5cblx0dmFyIGdwb3MgPSB7IHBhcnNlOiBwYXJzZUdwb3NUYWJsZSwgbWFrZTogbWFrZUdwb3NUYWJsZSB9O1xuXG5cdC8vIFRoZSBga2VybmAgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycy5cblxuXHRmdW5jdGlvbiBwYXJzZVdpbmRvd3NLZXJuVGFibGUocCkge1xuXHQgICAgdmFyIHBhaXJzID0ge307XG5cdCAgICAvLyBTa2lwIG5UYWJsZXMuXG5cdCAgICBwLnNraXAoJ3VTaG9ydCcpO1xuXHQgICAgdmFyIHN1YnRhYmxlVmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIGNoZWNrLmFyZ3VtZW50KHN1YnRhYmxlVmVyc2lvbiA9PT0gMCwgJ1Vuc3VwcG9ydGVkIGtlcm4gc3ViLXRhYmxlIHZlcnNpb24uJyk7XG5cdCAgICAvLyBTa2lwIHN1YnRhYmxlTGVuZ3RoLCBzdWJ0YWJsZUNvdmVyYWdlXG5cdCAgICBwLnNraXAoJ3VTaG9ydCcsIDIpO1xuXHQgICAgdmFyIG5QYWlycyA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG5cdCAgICBwLnNraXAoJ3VTaG9ydCcsIDMpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFpcnM7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gcC5wYXJzZVNob3J0KCk7XG5cdCAgICAgICAgcGFpcnNbbGVmdEluZGV4ICsgJywnICsgcmlnaHRJbmRleF0gPSB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBwYWlycztcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlTWFjS2VyblRhYmxlKHApIHtcblx0ICAgIHZhciBwYWlycyA9IHt9O1xuXHQgICAgLy8gVGhlIE1hYyBrZXJuIHRhYmxlIHN0b3JlcyB0aGUgdmVyc2lvbiBhcyBhIGZpeGVkICgzMiBiaXRzKSBidXQgd2Ugb25seSBsb2FkZWQgdGhlIGZpcnN0IDE2IGJpdHMuXG5cdCAgICAvLyBTa2lwIHRoZSByZXN0LlxuXHQgICAgcC5za2lwKCd1U2hvcnQnKTtcblx0ICAgIHZhciBuVGFibGVzID0gcC5wYXJzZVVMb25nKCk7XG5cdCAgICAvL2NoZWNrLmFyZ3VtZW50KG5UYWJsZXMgPT09IDEsICdPbmx5IDEgc3VidGFibGUgaXMgc3VwcG9ydGVkIChnb3QgJyArIG5UYWJsZXMgKyAnKS4nKTtcblx0ICAgIGlmIChuVGFibGVzID4gMSkge1xuXHQgICAgICAgIGNvbnNvbGUud2FybignT25seSB0aGUgZmlyc3Qga2VybiBzdWJ0YWJsZSBpcyBzdXBwb3J0ZWQuJyk7XG5cdCAgICB9XG5cdCAgICBwLnNraXAoJ3VMb25nJyk7XG5cdCAgICB2YXIgY292ZXJhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICB2YXIgc3VidGFibGVWZXJzaW9uID0gY292ZXJhZ2UgJiAweEZGO1xuXHQgICAgcC5za2lwKCd1U2hvcnQnKTtcblx0ICAgIGlmIChzdWJ0YWJsZVZlcnNpb24gPT09IDApIHtcblx0ICAgICAgICB2YXIgblBhaXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG5cdCAgICAgICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWlyczsgaSArPSAxKSB7XG5cdCAgICAgICAgICAgIHZhciBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG5cdCAgICAgICAgICAgIHZhciByaWdodEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSBwLnBhcnNlU2hvcnQoKTtcblx0ICAgICAgICAgICAgcGFpcnNbbGVmdEluZGV4ICsgJywnICsgcmlnaHRJbmRleF0gPSB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcGFpcnM7XG5cdH1cblxuXHQvLyBQYXJzZSB0aGUgYGtlcm5gIHRhYmxlIHdoaWNoIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMuXG5cdGZ1bmN0aW9uIHBhcnNlS2VyblRhYmxlKGRhdGEsIHN0YXJ0KSB7XG5cdCAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXHQgICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcblx0ICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gcGFyc2VXaW5kb3dzS2VyblRhYmxlKHApO1xuXHQgICAgfSBlbHNlIGlmICh0YWJsZVZlcnNpb24gPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4gcGFyc2VNYWNLZXJuVGFibGUocCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2VybiB0YWJsZSB2ZXJzaW9uICgnICsgdGFibGVWZXJzaW9uICsgJykuJyk7XG5cdCAgICB9XG5cdH1cblxuXHR2YXIga2VybiA9IHsgcGFyc2U6IHBhcnNlS2VyblRhYmxlIH07XG5cblx0Ly8gVGhlIGBsb2NhYCB0YWJsZSBzdG9yZXMgdGhlIG9mZnNldHMgdG8gdGhlIGxvY2F0aW9ucyBvZiB0aGUgZ2x5cGhzIGluIHRoZSBmb250LlxuXG5cdC8vIFBhcnNlIHRoZSBgbG9jYWAgdGFibGUuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBvZmZzZXRzIHRvIHRoZSBsb2NhdGlvbnMgb2YgdGhlIGdseXBocyBpbiB0aGUgZm9udCxcblx0Ly8gcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2x5cGhEYXRhIHRhYmxlLlxuXHQvLyBUaGUgbnVtYmVyIG9mIGdseXBocyBzdG9yZWQgaW4gdGhlIGBsb2NhYCB0YWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGBtYXhwYCB0YWJsZSAodW5kZXIgbnVtR2x5cGhzKVxuXHQvLyBUaGUgbG9jYSB0YWJsZSBoYXMgdHdvIHZlcnNpb25zOiBhIHNob3J0IHZlcnNpb24gd2hlcmUgb2Zmc2V0cyBhcmUgc3RvcmVkIGFzIHVTaG9ydHMsIGFuZCBhIGxvbmdcblx0Ly8gdmVyc2lvbiB3aGVyZSBvZmZzZXRzIGFyZSBzdG9yZWQgYXMgdUxvbmdzLiBUaGUgYGhlYWRgIHRhYmxlIHNwZWNpZmllcyB3aGljaCB2ZXJzaW9uIHRvIHVzZVxuXHQvLyAodW5kZXIgaW5kZXhUb0xvY0Zvcm1hdCkuXG5cdGZ1bmN0aW9uIHBhcnNlTG9jYVRhYmxlKGRhdGEsIHN0YXJ0LCBudW1HbHlwaHMsIHNob3J0VmVyc2lvbikge1xuXHQgICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblx0ICAgIHZhciBwYXJzZUZuID0gc2hvcnRWZXJzaW9uID8gcC5wYXJzZVVTaG9ydCA6IHAucGFyc2VVTG9uZztcblx0ICAgIC8vIFRoZXJlIGlzIGFuIGV4dHJhIGVudHJ5IGFmdGVyIHRoZSBsYXN0IGluZGV4IGVsZW1lbnQgdG8gY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBsYXN0IGdseXBoLlxuXHQgICAgLy8gVGhhdCdzIHdoeSB3ZSB1c2UgbnVtR2x5cGhzICsgMS5cblx0ICAgIHZhciBnbHlwaE9mZnNldHMgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtR2x5cGhzICsgMTsgaSArPSAxKSB7XG5cdCAgICAgICAgdmFyIGdseXBoT2Zmc2V0ID0gcGFyc2VGbi5jYWxsKHApO1xuXHQgICAgICAgIGlmIChzaG9ydFZlcnNpb24pIHtcblx0ICAgICAgICAgICAgLy8gVGhlIHNob3J0IHRhYmxlIHZlcnNpb24gc3RvcmVzIHRoZSBhY3R1YWwgb2Zmc2V0IGRpdmlkZWQgYnkgMi5cblx0ICAgICAgICAgICAgZ2x5cGhPZmZzZXQgKj0gMjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBnbHlwaE9mZnNldHMucHVzaChnbHlwaE9mZnNldCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBnbHlwaE9mZnNldHM7XG5cdH1cblxuXHR2YXIgbG9jYSA9IHsgcGFyc2U6IHBhcnNlTG9jYVRhYmxlIH07XG5cblx0Ly8gb3BlbnR5cGUuanNcblxuXHQvKipcblx0ICogVGhlIG9wZW50eXBlIGxpYnJhcnkuXG5cdCAqIEBuYW1lc3BhY2Ugb3BlbnR5cGVcblx0ICovXG5cblx0Ly8gRmlsZSBsb2FkZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvKipcblx0ICogTG9hZHMgYSBmb250IGZyb20gYSBmaWxlLiBUaGUgY2FsbGJhY2sgdGhyb3dzIGFuIGVycm9yIG1lc3NhZ2UgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciBpZiBpdCBmYWlsc1xuXHQgKiBhbmQgdGhlIGZvbnQgYXMgYW4gQXJyYXlCdWZmZXIgaW4gdGhlIHNlY29uZCBwYXJhbWV0ZXIgaWYgaXQgc3VjY2VlZHMuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBmaWxlXG5cdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGZvbnQgbG9hZCBjb21wbGV0ZXNcblx0ICovXG5cdGZ1bmN0aW9uIGxvYWRGcm9tRmlsZShwYXRoLCBjYWxsYmFjaykge1xuXHQgICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcblx0ICAgIGZzLnJlYWRGaWxlKHBhdGgsIGZ1bmN0aW9uKGVyciwgYnVmZmVyKSB7XG5cdCAgICAgICAgaWYgKGVycikge1xuXHQgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLm1lc3NhZ2UpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGNhbGxiYWNrKG51bGwsIG5vZGVCdWZmZXJUb0FycmF5QnVmZmVyKGJ1ZmZlcikpO1xuXHQgICAgfSk7XG5cdH1cblx0LyoqXG5cdCAqIExvYWRzIGEgZm9udCBmcm9tIGEgVVJMLiBUaGUgY2FsbGJhY2sgdGhyb3dzIGFuIGVycm9yIG1lc3NhZ2UgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciBpZiBpdCBmYWlsc1xuXHQgKiBhbmQgdGhlIGZvbnQgYXMgYW4gQXJyYXlCdWZmZXIgaW4gdGhlIHNlY29uZCBwYXJhbWV0ZXIgaWYgaXQgc3VjY2VlZHMuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gdXJsIC0gVGhlIFVSTCBvZiB0aGUgZm9udCBmaWxlLlxuXHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBmb250IGxvYWQgY29tcGxldGVzXG5cdCAqL1xuXHRmdW5jdGlvbiBsb2FkRnJvbVVybCh1cmwsIGNhbGxiYWNrKSB7XG5cdCAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHQgICAgcmVxdWVzdC5vcGVuKCdnZXQnLCB1cmwsIHRydWUpO1xuXHQgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHQgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICBpZiAocmVxdWVzdC5yZXNwb25zZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVxdWVzdC5yZXNwb25zZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCdGb250IGNvdWxkIG5vdCBiZSBsb2FkZWQ6ICcgKyByZXF1ZXN0LnN0YXR1c1RleHQpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBjYWxsYmFjaygnRm9udCBjb3VsZCBub3QgYmUgbG9hZGVkJyk7XG5cdCAgICB9O1xuXG5cdCAgICByZXF1ZXN0LnNlbmQoKTtcblx0fVxuXG5cdC8vIFRhYmxlIERpcmVjdG9yeSBFbnRyaWVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0LyoqXG5cdCAqIFBhcnNlcyBPcGVuVHlwZSB0YWJsZSBlbnRyaWVzLlxuXHQgKiBAcGFyYW0gIHtEYXRhVmlld31cblx0ICogQHBhcmFtICB7TnVtYmVyfVxuXHQgKiBAcmV0dXJuIHtPYmplY3RbXX1cblx0ICovXG5cdGZ1bmN0aW9uIHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKSB7XG5cdCAgICB2YXIgdGFibGVFbnRyaWVzID0gW107XG5cdCAgICB2YXIgcCA9IDEyO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciB0YWcgPSBwYXJzZS5nZXRUYWcoZGF0YSwgcCk7XG5cdCAgICAgICAgdmFyIGNoZWNrc3VtID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDQpO1xuXHQgICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgOCk7XG5cdCAgICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyAxMik7XG5cdCAgICAgICAgdGFibGVFbnRyaWVzLnB1c2goe3RhZzogdGFnLCBjaGVja3N1bTogY2hlY2tzdW0sIG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IGxlbmd0aCwgY29tcHJlc3Npb246IGZhbHNlfSk7XG5cdCAgICAgICAgcCArPSAxNjtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRhYmxlRW50cmllcztcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgV09GRiB0YWJsZSBlbnRyaWVzLlxuXHQgKiBAcGFyYW0gIHtEYXRhVmlld31cblx0ICogQHBhcmFtICB7TnVtYmVyfVxuXHQgKiBAcmV0dXJuIHtPYmplY3RbXX1cblx0ICovXG5cdGZ1bmN0aW9uIHBhcnNlV09GRlRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpIHtcblx0ICAgIHZhciB0YWJsZUVudHJpZXMgPSBbXTtcblx0ICAgIHZhciBwID0gNDQ7IC8vIG9mZnNldCB0byB0aGUgZmlyc3QgdGFibGUgZGlyZWN0b3J5IGVudHJ5LlxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciB0YWcgPSBwYXJzZS5nZXRUYWcoZGF0YSwgcCk7XG5cdCAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA0KTtcblx0ICAgICAgICB2YXIgY29tcExlbmd0aCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA4KTtcblx0ICAgICAgICB2YXIgb3JpZ0xlbmd0aCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyAxMik7XG5cdCAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gKHZvaWQgMCk7XG5cdCAgICAgICAgaWYgKGNvbXBMZW5ndGggPCBvcmlnTGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGNvbXByZXNzaW9uID0gJ1dPRkYnO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGNvbXByZXNzaW9uID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGFibGVFbnRyaWVzLnB1c2goe3RhZzogdGFnLCBvZmZzZXQ6IG9mZnNldCwgY29tcHJlc3Npb246IGNvbXByZXNzaW9uLFxuXHQgICAgICAgICAgICBjb21wcmVzc2VkTGVuZ3RoOiBjb21wTGVuZ3RoLCBsZW5ndGg6IG9yaWdMZW5ndGh9KTtcblx0ICAgICAgICBwICs9IDIwO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGFibGVFbnRyaWVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlZGVmIFRhYmxlRGF0YVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHByb3BlcnR5IHtEYXRhVmlld30gZGF0YSAtIFRoZSBEYXRhVmlld1xuXHQgKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0IC0gVGhlIGRhdGEgb2Zmc2V0LlxuXHQgKi9cblxuXHQvKipcblx0ICogQHBhcmFtICB7RGF0YVZpZXd9XG5cdCAqIEBwYXJhbSAge09iamVjdH1cblx0ICogQHJldHVybiB7VGFibGVEYXRhfVxuXHQgKi9cblx0ZnVuY3Rpb24gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpIHtcblx0ICAgIGlmICh0YWJsZUVudHJ5LmNvbXByZXNzaW9uID09PSAnV09GRicpIHtcblx0ICAgICAgICB2YXIgaW5CdWZmZXIgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgdGFibGVFbnRyeS5vZmZzZXQgKyAyLCB0YWJsZUVudHJ5LmNvbXByZXNzZWRMZW5ndGggLSAyKTtcblx0ICAgICAgICB2YXIgb3V0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGFibGVFbnRyeS5sZW5ndGgpO1xuXHQgICAgICAgIHRpbnlJbmZsYXRlKGluQnVmZmVyLCBvdXRCdWZmZXIpO1xuXHQgICAgICAgIGlmIChvdXRCdWZmZXIuYnl0ZUxlbmd0aCAhPT0gdGFibGVFbnRyeS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvbXByZXNzaW9uIGVycm9yOiAnICsgdGFibGVFbnRyeS50YWcgKyAnIGRlY29tcHJlc3NlZCBsZW5ndGggZG9lc25cXCd0IG1hdGNoIHJlY29yZGVkIGxlbmd0aCcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KG91dEJ1ZmZlci5idWZmZXIsIDApO1xuXHQgICAgICAgIHJldHVybiB7ZGF0YTogdmlldywgb2Zmc2V0OiAwfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHtkYXRhOiBkYXRhLCBvZmZzZXQ6IHRhYmxlRW50cnkub2Zmc2V0fTtcblx0ICAgIH1cblx0fVxuXG5cdC8vIFB1YmxpYyBBUEkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogUGFyc2UgdGhlIE9wZW5UeXBlIGZpbGUgZGF0YSAoYXMgYW4gQXJyYXlCdWZmZXIpIGFuZCByZXR1cm4gYSBGb250IG9iamVjdC5cblx0ICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBmb250IGNvdWxkIG5vdCBiZSBwYXJzZWQuXG5cdCAqIEBwYXJhbSAge0FycmF5QnVmZmVyfVxuXHQgKiBAcmV0dXJuIHtvcGVudHlwZS5Gb250fVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VCdWZmZXIoYnVmZmVyKSB7XG5cdCAgICB2YXIgaW5kZXhUb0xvY0Zvcm1hdDtcblx0ICAgIHZhciBsdGFnVGFibGU7XG5cblx0ICAgIC8vIFNpbmNlIHRoZSBjb25zdHJ1Y3RvciBjYW4gYWxzbyBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBmb250cyBmcm9tIHNjcmF0Y2gsIHdlIGluZGljYXRlIHRoaXNcblx0ICAgIC8vIHNob3VsZCBiZSBhbiBlbXB0eSBmb250IHRoYXQgd2UnbGwgZmlsbCB3aXRoIG91ciBvd24gZGF0YS5cblx0ICAgIHZhciBmb250ID0gbmV3IEZvbnQoe2VtcHR5OiB0cnVlfSk7XG5cblx0ICAgIC8vIE9wZW5UeXBlIGZvbnRzIHVzZSBiaWcgZW5kaWFuIGJ5dGUgb3JkZXJpbmcuXG5cdCAgICAvLyBXZSBjYW4ndCByZWx5IG9uIHR5cGVkIGFycmF5IHZpZXcgdHlwZXMsIGJlY2F1c2UgdGhleSBvcGVyYXRlIHdpdGggdGhlIGVuZGlhbm5lc3Mgb2YgdGhlIGhvc3QgY29tcHV0ZXIuXG5cdCAgICAvLyBJbnN0ZWFkIHdlIHVzZSBEYXRhVmlld3Mgd2hlcmUgd2UgY2FuIHNwZWNpZnkgZW5kaWFubmVzcy5cblx0ICAgIHZhciBkYXRhID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgMCk7XG5cdCAgICB2YXIgbnVtVGFibGVzO1xuXHQgICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuXHQgICAgdmFyIHNpZ25hdHVyZSA9IHBhcnNlLmdldFRhZyhkYXRhLCAwKTtcblx0ICAgIGlmIChzaWduYXR1cmUgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMSwgMCwgMCkgfHwgc2lnbmF0dXJlID09PSAndHJ1ZScgfHwgc2lnbmF0dXJlID09PSAndHlwMScpIHtcblx0ICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ3RydWV0eXBlJztcblx0ICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG5cdCAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuXHQgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09ICdPVFRPJykge1xuXHQgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcblx0ICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG5cdCAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuXHQgICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09ICd3T0ZGJykge1xuXHQgICAgICAgIHZhciBmbGF2b3IgPSBwYXJzZS5nZXRUYWcoZGF0YSwgNCk7XG5cdCAgICAgICAgaWYgKGZsYXZvciA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAxLCAwLCAwKSkge1xuXHQgICAgICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ3RydWV0eXBlJztcblx0ICAgICAgICB9IGVsc2UgaWYgKGZsYXZvciA9PT0gJ09UVE8nKSB7XG5cdCAgICAgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIGZsYXZvciAnICsgc2lnbmF0dXJlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgMTIpO1xuXHQgICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlV09GRlRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIHNpZ25hdHVyZSAnICsgc2lnbmF0dXJlKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNmZlRhYmxlRW50cnk7XG5cdCAgICB2YXIgZnZhclRhYmxlRW50cnk7XG5cdCAgICB2YXIgZ2x5ZlRhYmxlRW50cnk7XG5cdCAgICB2YXIgZ3Bvc1RhYmxlRW50cnk7XG5cdCAgICB2YXIgZ3N1YlRhYmxlRW50cnk7XG5cdCAgICB2YXIgaG10eFRhYmxlRW50cnk7XG5cdCAgICB2YXIga2VyblRhYmxlRW50cnk7XG5cdCAgICB2YXIgbG9jYVRhYmxlRW50cnk7XG5cdCAgICB2YXIgbmFtZVRhYmxlRW50cnk7XG5cdCAgICB2YXIgbWV0YVRhYmxlRW50cnk7XG5cdCAgICB2YXIgcDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuXHQgICAgICAgIHZhciB0YWJsZUVudHJ5ID0gdGFibGVFbnRyaWVzW2ldO1xuXHQgICAgICAgIHZhciB0YWJsZSA9ICh2b2lkIDApO1xuXHQgICAgICAgIHN3aXRjaCAodGFibGVFbnRyeS50YWcpIHtcblx0ICAgICAgICAgICAgY2FzZSAnY21hcCc6XG5cdCAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcblx0ICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmNtYXAgPSBjbWFwLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICBmb250LmVuY29kaW5nID0gbmV3IENtYXBFbmNvZGluZyhmb250LnRhYmxlcy5jbWFwKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlICdjdnQgJyA6XG5cdCAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcblx0ICAgICAgICAgICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5jdnQgPSBwLnBhcnNlU2hvcnRMaXN0KHRhYmxlRW50cnkubGVuZ3RoIC8gMik7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnZnZhcic6XG5cdCAgICAgICAgICAgICAgICBmdmFyVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnZnBnbScgOlxuXHQgICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG5cdCAgICAgICAgICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcih0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgZm9udC50YWJsZXMuZnBnbSA9IHAucGFyc2VCeXRlTGlzdCh0YWJsZUVudHJ5Lmxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnaGVhZCc6XG5cdCAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcblx0ICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmhlYWQgPSBoZWFkLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICBmb250LnVuaXRzUGVyRW0gPSBmb250LnRhYmxlcy5oZWFkLnVuaXRzUGVyRW07XG5cdCAgICAgICAgICAgICAgICBpbmRleFRvTG9jRm9ybWF0ID0gZm9udC50YWJsZXMuaGVhZC5pbmRleFRvTG9jRm9ybWF0O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2hoZWEnOlxuXHQgICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG5cdCAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5oaGVhID0gaGhlYS5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgZm9udC5hc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuYXNjZW5kZXI7XG5cdCAgICAgICAgICAgICAgICBmb250LmRlc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuZGVzY2VuZGVyO1xuXHQgICAgICAgICAgICAgICAgZm9udC5udW1iZXJPZkhNZXRyaWNzID0gZm9udC50YWJsZXMuaGhlYS5udW1iZXJPZkhNZXRyaWNzO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2htdHgnOlxuXHQgICAgICAgICAgICAgICAgaG10eFRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2x0YWcnOlxuXHQgICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG5cdCAgICAgICAgICAgICAgICBsdGFnVGFibGUgPSBsdGFnLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnbWF4cCc6XG5cdCAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcblx0ICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLm1heHAgPSBtYXhwLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICBmb250Lm51bUdseXBocyA9IGZvbnQudGFibGVzLm1heHAubnVtR2x5cGhzO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxuXHQgICAgICAgICAgICAgICAgbmFtZVRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ09TLzInOlxuXHQgICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG5cdCAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5vczIgPSBvczIucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlICdwb3N0Jzpcblx0ICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuXHQgICAgICAgICAgICAgICAgZm9udC50YWJsZXMucG9zdCA9IHBvc3QucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIGZvbnQuZ2x5cGhOYW1lcyA9IG5ldyBHbHlwaE5hbWVzKGZvbnQudGFibGVzLnBvc3QpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ3ByZXAnIDpcblx0ICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuXHQgICAgICAgICAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLnByZXAgPSBwLnBhcnNlQnl0ZUxpc3QodGFibGVFbnRyeS5sZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2dseWYnOlxuXHQgICAgICAgICAgICAgICAgZ2x5ZlRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ2xvY2EnOlxuXHQgICAgICAgICAgICAgICAgbG9jYVRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ0NGRiAnOlxuXHQgICAgICAgICAgICAgICAgY2ZmVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAna2Vybic6XG5cdCAgICAgICAgICAgICAgICBrZXJuVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnR1BPUyc6XG5cdCAgICAgICAgICAgICAgICBncG9zVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnR1NVQic6XG5cdCAgICAgICAgICAgICAgICBnc3ViVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnbWV0YSc6XG5cdCAgICAgICAgICAgICAgICBtZXRhVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciBuYW1lVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbmFtZVRhYmxlRW50cnkpO1xuXHQgICAgZm9udC50YWJsZXMubmFtZSA9IF9uYW1lLnBhcnNlKG5hbWVUYWJsZS5kYXRhLCBuYW1lVGFibGUub2Zmc2V0LCBsdGFnVGFibGUpO1xuXHQgICAgZm9udC5uYW1lcyA9IGZvbnQudGFibGVzLm5hbWU7XG5cblx0ICAgIGlmIChnbHlmVGFibGVFbnRyeSAmJiBsb2NhVGFibGVFbnRyeSkge1xuXHQgICAgICAgIHZhciBzaG9ydFZlcnNpb24gPSBpbmRleFRvTG9jRm9ybWF0ID09PSAwO1xuXHQgICAgICAgIHZhciBsb2NhVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbG9jYVRhYmxlRW50cnkpO1xuXHQgICAgICAgIHZhciBsb2NhT2Zmc2V0cyA9IGxvY2EucGFyc2UobG9jYVRhYmxlLmRhdGEsIGxvY2FUYWJsZS5vZmZzZXQsIGZvbnQubnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pO1xuXHQgICAgICAgIHZhciBnbHlmVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ2x5ZlRhYmxlRW50cnkpO1xuXHQgICAgICAgIGZvbnQuZ2x5cGhzID0gZ2x5Zi5wYXJzZShnbHlmVGFibGUuZGF0YSwgZ2x5ZlRhYmxlLm9mZnNldCwgbG9jYU9mZnNldHMsIGZvbnQpO1xuXHQgICAgfSBlbHNlIGlmIChjZmZUYWJsZUVudHJ5KSB7XG5cdCAgICAgICAgdmFyIGNmZlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGNmZlRhYmxlRW50cnkpO1xuXHQgICAgICAgIGNmZi5wYXJzZShjZmZUYWJsZS5kYXRhLCBjZmZUYWJsZS5vZmZzZXQsIGZvbnQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvbnQgZG9lc25cXCd0IGNvbnRhaW4gVHJ1ZVR5cGUgb3IgQ0ZGIG91dGxpbmVzLicpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaG10eFRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGhtdHhUYWJsZUVudHJ5KTtcblx0ICAgIGhtdHgucGFyc2UoaG10eFRhYmxlLmRhdGEsIGhtdHhUYWJsZS5vZmZzZXQsIGZvbnQubnVtYmVyT2ZITWV0cmljcywgZm9udC5udW1HbHlwaHMsIGZvbnQuZ2x5cGhzKTtcblx0ICAgIGFkZEdseXBoTmFtZXMoZm9udCk7XG5cblx0ICAgIGlmIChrZXJuVGFibGVFbnRyeSkge1xuXHQgICAgICAgIHZhciBrZXJuVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwga2VyblRhYmxlRW50cnkpO1xuXHQgICAgICAgIGZvbnQua2VybmluZ1BhaXJzID0ga2Vybi5wYXJzZShrZXJuVGFibGUuZGF0YSwga2VyblRhYmxlLm9mZnNldCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIGZvbnQua2VybmluZ1BhaXJzID0ge307XG5cdCAgICB9XG5cblx0ICAgIGlmIChncG9zVGFibGVFbnRyeSkge1xuXHQgICAgICAgIHZhciBncG9zVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ3Bvc1RhYmxlRW50cnkpO1xuXHQgICAgICAgIGZvbnQudGFibGVzLmdwb3MgPSBncG9zLnBhcnNlKGdwb3NUYWJsZS5kYXRhLCBncG9zVGFibGUub2Zmc2V0KTtcblx0ICAgICAgICBmb250LnBvc2l0aW9uLmluaXQoKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGdzdWJUYWJsZUVudHJ5KSB7XG5cdCAgICAgICAgdmFyIGdzdWJUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBnc3ViVGFibGVFbnRyeSk7XG5cdCAgICAgICAgZm9udC50YWJsZXMuZ3N1YiA9IGdzdWIucGFyc2UoZ3N1YlRhYmxlLmRhdGEsIGdzdWJUYWJsZS5vZmZzZXQpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZnZhclRhYmxlRW50cnkpIHtcblx0ICAgICAgICB2YXIgZnZhclRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGZ2YXJUYWJsZUVudHJ5KTtcblx0ICAgICAgICBmb250LnRhYmxlcy5mdmFyID0gZnZhci5wYXJzZShmdmFyVGFibGUuZGF0YSwgZnZhclRhYmxlLm9mZnNldCwgZm9udC5uYW1lcyk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChtZXRhVGFibGVFbnRyeSkge1xuXHQgICAgICAgIHZhciBtZXRhVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbWV0YVRhYmxlRW50cnkpO1xuXHQgICAgICAgIGZvbnQudGFibGVzLm1ldGEgPSBtZXRhLnBhcnNlKG1ldGFUYWJsZS5kYXRhLCBtZXRhVGFibGUub2Zmc2V0KTtcblx0ICAgICAgICBmb250Lm1ldGFzID0gZm9udC50YWJsZXMubWV0YTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZvbnQ7XG5cdH1cblxuXHQvKipcblx0ICogQXN5bmNocm9ub3VzbHkgbG9hZCB0aGUgZm9udCBmcm9tIGEgVVJMIG9yIGEgZmlsZXN5c3RlbS4gV2hlbiBkb25lLCBjYWxsIHRoZSBjYWxsYmFja1xuXHQgKiB3aXRoIHR3byBhcmd1bWVudHMgYChlcnIsIGZvbnQpYC4gVGhlIGBlcnJgIHdpbGwgYmUgbnVsbCBvbiBzdWNjZXNzLFxuXHQgKiB0aGUgYGZvbnRgIGlzIGEgRm9udCBvYmplY3QuXG5cdCAqIFdlIHVzZSB0aGUgbm9kZS5qcyBjYWxsYmFjayBjb252ZW50aW9uIHNvIHRoYXRcblx0ICogb3BlbnR5cGUuanMgY2FuIGludGVncmF0ZSB3aXRoIGZyYW1ld29ya3MgbGlrZSBhc3luYy5qcy5cblx0ICogQGFsaWFzIG9wZW50eXBlLmxvYWRcblx0ICogQHBhcmFtICB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmb250IHRvIGxvYWQuXG5cdCAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjay5cblx0ICovXG5cdGZ1bmN0aW9uIGxvYWQodXJsLCBjYWxsYmFjaykge1xuXHQgICAgdmFyIGlzTm9kZSQkMSA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuXHQgICAgdmFyIGxvYWRGbiA9IGlzTm9kZSQkMSA/IGxvYWRGcm9tRmlsZSA6IGxvYWRGcm9tVXJsO1xuXHQgICAgbG9hZEZuKHVybCwgZnVuY3Rpb24oZXJyLCBhcnJheUJ1ZmZlcikge1xuXHQgICAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBmb250O1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIGZvbnQgPSBwYXJzZUJ1ZmZlcihhcnJheUJ1ZmZlcik7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSwgbnVsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBmb250KTtcblx0ICAgIH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN5bmNocm9ub3VzbHkgbG9hZCB0aGUgZm9udCBmcm9tIGEgVVJMIG9yIGZpbGUuXG5cdCAqIFdoZW4gZG9uZSwgcmV0dXJucyB0aGUgZm9udCBvYmplY3Qgb3IgdGhyb3dzIGFuIGVycm9yLlxuXHQgKiBAYWxpYXMgb3BlbnR5cGUubG9hZFN5bmNcblx0ICogQHBhcmFtICB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmb250IHRvIGxvYWQuXG5cdCAqIEByZXR1cm4ge29wZW50eXBlLkZvbnR9XG5cdCAqL1xuXHRmdW5jdGlvbiBsb2FkU3luYyh1cmwpIHtcblx0ICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cdCAgICB2YXIgYnVmZmVyID0gZnMucmVhZEZpbGVTeW5jKHVybCk7XG5cdCAgICByZXR1cm4gcGFyc2VCdWZmZXIobm9kZUJ1ZmZlclRvQXJyYXlCdWZmZXIoYnVmZmVyKSk7XG5cdH1cblxuXHRleHBvcnRzLkZvbnQgPSBGb250O1xuXHRleHBvcnRzLkdseXBoID0gR2x5cGg7XG5cdGV4cG9ydHMuUGF0aCA9IFBhdGg7XG5cdGV4cG9ydHMuQm91bmRpbmdCb3ggPSBCb3VuZGluZ0JveDtcblx0ZXhwb3J0cy5fcGFyc2UgPSBwYXJzZTtcblx0ZXhwb3J0cy5wYXJzZSA9IHBhcnNlQnVmZmVyO1xuXHRleHBvcnRzLmxvYWQgPSBsb2FkO1xuXHRleHBvcnRzLmxvYWRTeW5jID0gbG9hZFN5bmM7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZW50eXBlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/opentype.js/dist/opentype.js\n");

/***/ }),

/***/ "./extensions/PDF/textlayer.css":
/*!**************************************!*\
  !*** ./extensions/PDF/textlayer.css ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_6_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_6_use_2_node_modules_css_unicode_loader_index_js_node_modules_sass_loader_dist_cjs_js_textlayer_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[6].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[6].use[2]!../../node_modules/css-unicode-loader/index.js!../../node_modules/sass-loader/dist/cjs.js!./textlayer.css */ \"./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[6].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[6].use[2]!./node_modules/css-unicode-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/PDF/textlayer.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_6_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_6_use_2_node_modules_css_unicode_loader_index_js_node_modules_sass_loader_dist_cjs_js_textlayer_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_6_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_6_use_2_node_modules_css_unicode_loader_index_js_node_modules_sass_loader_dist_cjs_js_textlayer_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_6_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_6_use_2_node_modules_css_unicode_loader_index_js_node_modules_sass_loader_dist_cjs_js_textlayer_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_6_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_6_use_2_node_modules_css_unicode_loader_index_js_node_modules_sass_loader_dist_cjs_js_textlayer_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1BERi90ZXh0bGF5ZXIuY3NzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLE1BQWtHO0FBQ2xHLE1BQXdGO0FBQ3hGLE1BQStGO0FBQy9GLE1BQWtIO0FBQ2xILE1BQTJHO0FBQzNHLE1BQTJHO0FBQzNHLE1BQTBTO0FBQzFTO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLHFHQUFtQjtBQUMvQyx3QkFBd0Isa0hBQWE7O0FBRXJDLHVCQUF1Qix1R0FBYTtBQUNwQztBQUNBLGlCQUFpQiwrRkFBTTtBQUN2Qiw2QkFBNkIsc0dBQWtCOztBQUUvQyxhQUFhLDBHQUFHLENBQUMsZ1FBQU87Ozs7QUFJb1A7QUFDNVEsT0FBTyxpRUFBZSxnUUFBTyxJQUFJLGdRQUFPLFVBQVUsZ1FBQU8sbUJBQW1CLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vZXh0ZW5zaW9ucy9QREYvdGV4dGxheWVyLmNzcz80YzE5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy11bmljb2RlLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi90ZXh0bGF5ZXIuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS51c2VbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy11bmljb2RlLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi90ZXh0bGF5ZXIuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./extensions/PDF/textlayer.css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzJkYmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0F1dG9kZXNrLkV4dGVuc2lvbnMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzP2IyMTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertBySelector.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0F1dG9kZXNrLkV4dGVuc2lvbnMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanM/ZGU2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/insertStyleElement.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWMsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzP2RkY2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0F1dG9kZXNrLkV4dGVuc2lvbnMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcz9lNDc5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBcIlwiO1xuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cbiAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBvYmoubGF5ZXIgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cbiAgY3NzICs9IG9iai5jc3M7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH1cblxuICAvLyBGb3Igb2xkIElFXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7fSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBvcHRpb25zLmluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmopIHtcbiAgICAgIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleDomAPI.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0F1dG9kZXNrLkV4dGVuc2lvbnMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcz8xZGRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/styleTagTransform.js\n");

/***/ }),

/***/ "./res/fonts/font-list.js":
/*!********************************!*\
  !*** ./res/fonts/font-list.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FONT_LIST: () => (/* binding */ FONT_LIST),\n/* harmony export */   ONDEMAND_FONT_LIST: () => (/* binding */ ONDEMAND_FONT_LIST)\n/* harmony export */ });\nlet FONT_LIST = [\n\n    //Metrically compatible to Arial\n    //https://fonts.google.com/specimen/Arimo\n    {\n        name: \"Arimo\",\n        url: \"res/fonts/arimo-v29-latin_latin-ext-regular.woff\",\n        subs: [\"arial\", \"arialmt\", \"helvetica\", \"sans serif\", \"sans-serif\"]\n    },\n\n    //Metrically compatible to Times\n    //https://fonts.google.com/specimen/Tinos\n    {\n        name: \"Tinos\",\n        url: \"res/fonts/tinos-v24-latin_latin-ext-regular.woff\",\n        subs: [\"times\", \"serif\"]\n    },\n\n    //Metrically compatible to Courier\n    //https://fonts.google.com/specimen/Cousine\n    {\n        name: \"Cousine\",\n        url: \"res/fonts/cousine-v27-latin_latin-ext-regular.woff\",\n        subs: [\"courier\", \"monospace\"]\n    },\n\n    // taken from pdf.js, which in turn got it from PDFium, and then converted from raw CFF to WOFF. I also fixed the missing cmap.\n    // https://github.com/mozilla/pdf.js/blob/4c1dd47e65ae66135c6d9a55774a99a8066fbf37/external/standard_fonts/FoxitDingbats.pfb\n    // The original licence file is \"res/fonts/LICENSE_FOXIT\"\n    {\n        name: \"FoxitDingbats\",\n        url: \"res/fonts/FoxitDingbats.woff\",\n        subs: [\"zapfdingbats\", \"dingbats\"]\n    },\n    // taken from pdf.js, which in turn got it from PDFium, and then converted from raw CFF to WOFF. I also fixed the missing cmap.\n    // https://github.com/mozilla/pdf.js/blob/4c1dd47e65ae66135c6d9a55774a99a8066fbf37/external/standard_fonts/FoxitSymbol.pfb\n    // The original licence file is \"res/fonts/LICENSE_FOXIT\"\n    {\n        name: \"FoxitSymbol\",\n        url: \"res/fonts/FoxitSymbol.woff\",\n        subs: [\"symbol\"]\n    }\n];\n\n// These are large font files that we do not want to load by default.\n// These will get loaded only if the font is required.\nlet ONDEMAND_FONT_LIST = [\n    // https://fonts.google.com/specimen/Noto+Sans+SC\n    // https://fonts.google.com/specimen/Noto+Sans+TC\n    // https://fonts.google.com/specimen/Noto+Sans+JP\n    // License: SIL Open Font License (OFL) https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=OFL\n    // The licenses for NotoSansSC, NotoSansTC, and NotoSansJP exist in the res/fonts folder in OFL.txt.\n    {\n        name: 'NotoSansSC',\n        url: 'res/fonts/NotoSansSC-Regular.otf',\n        subs: ['microsoftyahei', 'simsun'],\n    },\n    {\n        name: 'NotoSansTC',\n        url: 'res/fonts/NotoSansTC-Regular.otf',\n        subs: ['microsoftmingliu', 'mingliu', 'bcdeee+dfkaishu-sb-estd-bf', 'bcdeee+dfkaishu-sb-estd'],\n    },\n    // Japanese font replacements\n    // 'hirakakupron-w3', 'kozminpr6n-regular' have been seen in actual documents (BLMV-7717, BLMV-7846)\n    // 'kozgopr6n-medium', 'adobegothicstd-bold' are two Adobe standard fonts that are apparently used by default when using Japanese characters in text comments\n    // 'arialunicodems' is used by FoxIt Reader (simsun as well, but that is covered already)\n    // 'ms-gothic', 'ms-mincho', 'meiryo', 'yugo-bold' are popular fonts or have been seen otherwise and added here for completeness\n    {\n        name: 'NotoSansJP',\n        url: 'res/fonts/NotoSansJP-Regular.otf',\n        subs: ['hirakakupron-w3', 'kozminpr6n-regular', 'kozgopr6n-medium', 'adobegothicstd-bold', 'arialunicodems', 'ms-gothic', 'msgothic', 'ms-mincho', 'msmincho', 'meiryo', 'yugo-bold'],\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXMvZm9udHMvZm9udC1saXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BdXRvZGVzay5FeHRlbnNpb25zLy4vcmVzL2ZvbnRzL2ZvbnQtbGlzdC5qcz82YjJkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBsZXQgRk9OVF9MSVNUID0gW1xuXG4gICAgLy9NZXRyaWNhbGx5IGNvbXBhdGlibGUgdG8gQXJpYWxcbiAgICAvL2h0dHBzOi8vZm9udHMuZ29vZ2xlLmNvbS9zcGVjaW1lbi9Bcmltb1xuICAgIHtcbiAgICAgICAgbmFtZTogXCJBcmltb1wiLFxuICAgICAgICB1cmw6IFwicmVzL2ZvbnRzL2FyaW1vLXYyOS1sYXRpbl9sYXRpbi1leHQtcmVndWxhci53b2ZmXCIsXG4gICAgICAgIHN1YnM6IFtcImFyaWFsXCIsIFwiYXJpYWxtdFwiLCBcImhlbHZldGljYVwiLCBcInNhbnMgc2VyaWZcIiwgXCJzYW5zLXNlcmlmXCJdXG4gICAgfSxcblxuICAgIC8vTWV0cmljYWxseSBjb21wYXRpYmxlIHRvIFRpbWVzXG4gICAgLy9odHRwczovL2ZvbnRzLmdvb2dsZS5jb20vc3BlY2ltZW4vVGlub3NcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiVGlub3NcIixcbiAgICAgICAgdXJsOiBcInJlcy9mb250cy90aW5vcy12MjQtbGF0aW5fbGF0aW4tZXh0LXJlZ3VsYXIud29mZlwiLFxuICAgICAgICBzdWJzOiBbXCJ0aW1lc1wiLCBcInNlcmlmXCJdXG4gICAgfSxcblxuICAgIC8vTWV0cmljYWxseSBjb21wYXRpYmxlIHRvIENvdXJpZXJcbiAgICAvL2h0dHBzOi8vZm9udHMuZ29vZ2xlLmNvbS9zcGVjaW1lbi9Db3VzaW5lXG4gICAge1xuICAgICAgICBuYW1lOiBcIkNvdXNpbmVcIixcbiAgICAgICAgdXJsOiBcInJlcy9mb250cy9jb3VzaW5lLXYyNy1sYXRpbl9sYXRpbi1leHQtcmVndWxhci53b2ZmXCIsXG4gICAgICAgIHN1YnM6IFtcImNvdXJpZXJcIiwgXCJtb25vc3BhY2VcIl1cbiAgICB9LFxuXG4gICAgLy8gdGFrZW4gZnJvbSBwZGYuanMsIHdoaWNoIGluIHR1cm4gZ290IGl0IGZyb20gUERGaXVtLCBhbmQgdGhlbiBjb252ZXJ0ZWQgZnJvbSByYXcgQ0ZGIHRvIFdPRkYuIEkgYWxzbyBmaXhlZCB0aGUgbWlzc2luZyBjbWFwLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3BkZi5qcy9ibG9iLzRjMWRkNDdlNjVhZTY2MTM1YzZkOWE1NTc3NGE5OWE4MDY2ZmJmMzcvZXh0ZXJuYWwvc3RhbmRhcmRfZm9udHMvRm94aXREaW5nYmF0cy5wZmJcbiAgICAvLyBUaGUgb3JpZ2luYWwgbGljZW5jZSBmaWxlIGlzIFwicmVzL2ZvbnRzL0xJQ0VOU0VfRk9YSVRcIlxuICAgIHtcbiAgICAgICAgbmFtZTogXCJGb3hpdERpbmdiYXRzXCIsXG4gICAgICAgIHVybDogXCJyZXMvZm9udHMvRm94aXREaW5nYmF0cy53b2ZmXCIsXG4gICAgICAgIHN1YnM6IFtcInphcGZkaW5nYmF0c1wiLCBcImRpbmdiYXRzXCJdXG4gICAgfSxcbiAgICAvLyB0YWtlbiBmcm9tIHBkZi5qcywgd2hpY2ggaW4gdHVybiBnb3QgaXQgZnJvbSBQREZpdW0sIGFuZCB0aGVuIGNvbnZlcnRlZCBmcm9tIHJhdyBDRkYgdG8gV09GRi4gSSBhbHNvIGZpeGVkIHRoZSBtaXNzaW5nIGNtYXAuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcGRmLmpzL2Jsb2IvNGMxZGQ0N2U2NWFlNjYxMzVjNmQ5YTU1Nzc0YTk5YTgwNjZmYmYzNy9leHRlcm5hbC9zdGFuZGFyZF9mb250cy9Gb3hpdFN5bWJvbC5wZmJcbiAgICAvLyBUaGUgb3JpZ2luYWwgbGljZW5jZSBmaWxlIGlzIFwicmVzL2ZvbnRzL0xJQ0VOU0VfRk9YSVRcIlxuICAgIHtcbiAgICAgICAgbmFtZTogXCJGb3hpdFN5bWJvbFwiLFxuICAgICAgICB1cmw6IFwicmVzL2ZvbnRzL0ZveGl0U3ltYm9sLndvZmZcIixcbiAgICAgICAgc3ViczogW1wic3ltYm9sXCJdXG4gICAgfVxuXTtcblxuLy8gVGhlc2UgYXJlIGxhcmdlIGZvbnQgZmlsZXMgdGhhdCB3ZSBkbyBub3Qgd2FudCB0byBsb2FkIGJ5IGRlZmF1bHQuXG4vLyBUaGVzZSB3aWxsIGdldCBsb2FkZWQgb25seSBpZiB0aGUgZm9udCBpcyByZXF1aXJlZC5cbmV4cG9ydCBsZXQgT05ERU1BTkRfRk9OVF9MSVNUID0gW1xuICAgIC8vIGh0dHBzOi8vZm9udHMuZ29vZ2xlLmNvbS9zcGVjaW1lbi9Ob3RvK1NhbnMrU0NcbiAgICAvLyBodHRwczovL2ZvbnRzLmdvb2dsZS5jb20vc3BlY2ltZW4vTm90bytTYW5zK1RDXG4gICAgLy8gaHR0cHM6Ly9mb250cy5nb29nbGUuY29tL3NwZWNpbWVuL05vdG8rU2FucytKUFxuICAgIC8vIExpY2Vuc2U6IFNJTCBPcGVuIEZvbnQgTGljZW5zZSAoT0ZMKSBodHRwczovL3NjcmlwdHMuc2lsLm9yZy9jbXMvc2NyaXB0cy9wYWdlLnBocD9zaXRlX2lkPW5yc2kmaWQ9T0ZMXG4gICAgLy8gVGhlIGxpY2Vuc2VzIGZvciBOb3RvU2Fuc1NDLCBOb3RvU2Fuc1RDLCBhbmQgTm90b1NhbnNKUCBleGlzdCBpbiB0aGUgcmVzL2ZvbnRzIGZvbGRlciBpbiBPRkwudHh0LlxuICAgIHtcbiAgICAgICAgbmFtZTogJ05vdG9TYW5zU0MnLFxuICAgICAgICB1cmw6ICdyZXMvZm9udHMvTm90b1NhbnNTQy1SZWd1bGFyLm90ZicsXG4gICAgICAgIHN1YnM6IFsnbWljcm9zb2Z0eWFoZWknLCAnc2ltc3VuJ10sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOb3RvU2Fuc1RDJyxcbiAgICAgICAgdXJsOiAncmVzL2ZvbnRzL05vdG9TYW5zVEMtUmVndWxhci5vdGYnLFxuICAgICAgICBzdWJzOiBbJ21pY3Jvc29mdG1pbmdsaXUnLCAnbWluZ2xpdScsICdiY2RlZWUrZGZrYWlzaHUtc2ItZXN0ZC1iZicsICdiY2RlZWUrZGZrYWlzaHUtc2ItZXN0ZCddLFxuICAgIH0sXG4gICAgLy8gSmFwYW5lc2UgZm9udCByZXBsYWNlbWVudHNcbiAgICAvLyAnaGlyYWtha3Vwcm9uLXczJywgJ2tvem1pbnByNm4tcmVndWxhcicgaGF2ZSBiZWVuIHNlZW4gaW4gYWN0dWFsIGRvY3VtZW50cyAoQkxNVi03NzE3LCBCTE1WLTc4NDYpXG4gICAgLy8gJ2tvemdvcHI2bi1tZWRpdW0nLCAnYWRvYmVnb3RoaWNzdGQtYm9sZCcgYXJlIHR3byBBZG9iZSBzdGFuZGFyZCBmb250cyB0aGF0IGFyZSBhcHBhcmVudGx5IHVzZWQgYnkgZGVmYXVsdCB3aGVuIHVzaW5nIEphcGFuZXNlIGNoYXJhY3RlcnMgaW4gdGV4dCBjb21tZW50c1xuICAgIC8vICdhcmlhbHVuaWNvZGVtcycgaXMgdXNlZCBieSBGb3hJdCBSZWFkZXIgKHNpbXN1biBhcyB3ZWxsLCBidXQgdGhhdCBpcyBjb3ZlcmVkIGFscmVhZHkpXG4gICAgLy8gJ21zLWdvdGhpYycsICdtcy1taW5jaG8nLCAnbWVpcnlvJywgJ3l1Z28tYm9sZCcgYXJlIHBvcHVsYXIgZm9udHMgb3IgaGF2ZSBiZWVuIHNlZW4gb3RoZXJ3aXNlIGFuZCBhZGRlZCBoZXJlIGZvciBjb21wbGV0ZW5lc3NcbiAgICB7XG4gICAgICAgIG5hbWU6ICdOb3RvU2Fuc0pQJyxcbiAgICAgICAgdXJsOiAncmVzL2ZvbnRzL05vdG9TYW5zSlAtUmVndWxhci5vdGYnLFxuICAgICAgICBzdWJzOiBbJ2hpcmFrYWt1cHJvbi13MycsICdrb3ptaW5wcjZuLXJlZ3VsYXInLCAna296Z29wcjZuLW1lZGl1bScsICdhZG9iZWdvdGhpY3N0ZC1ib2xkJywgJ2FyaWFsdW5pY29kZW1zJywgJ21zLWdvdGhpYycsICdtc2dvdGhpYycsICdtcy1taW5jaG8nLCAnbXNtaW5jaG8nLCAnbWVpcnlvJywgJ3l1Z28tYm9sZCddLFxuICAgIH0sXG5dO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./res/fonts/font-list.js\n");

/***/ }),

/***/ "?97a1":
/*!************************!*\
  !*** canvas (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?6e49":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?0b3b":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?bfb0":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?a42f":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?331b":
/*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4db5":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./extensions/PDF/index.js");
/******/ 	Autodesk.Extensions.PDF = __webpack_exports__;
/******/ 	
/******/ })()
;