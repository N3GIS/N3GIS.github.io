{"version":3,"file":"GestureDocumentNavigation/GestureDocumentNavigation.min.js","mappings":"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","sources":["webpack://Autodesk.Extensions/webpack/bootstrap","webpack://Autodesk.Extensions/webpack/runtime/define property getters","webpack://Autodesk.Extensions/webpack/runtime/hasOwnProperty shorthand","webpack://Autodesk.Extensions/webpack/runtime/make namespace object","webpack://Autodesk.Extensions/./extensions/GestureDocumentNavigation/GeometryUtils.js","webpack://Autodesk.Extensions/./extensions/GestureDocumentNavigation/CameraUtils.js","webpack://Autodesk.Extensions/./extensions/GestureDocumentNavigation/ModelUtils.js","webpack://Autodesk.Extensions/./extensions/GestureDocumentNavigation/GestureDocumentNavigationTool.js","webpack://Autodesk.Extensions/./extensions/GestureDocumentNavigation/GestureDocumentNavigationConstants.js","webpack://Autodesk.Extensions/./extensions/GestureDocumentNavigation/GestureDocumentNavigation.js","webpack://Autodesk.Extensions/./extensions/GestureDocumentNavigation/BubbleUtils.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const GeometryUtils = {};\n\nGeometryUtils.radiansToDegrees = (radians) => {\n    return radians * (180 / Math.PI);\n};\n\nGeometryUtils.degreesToRadians = (degrees) => {\n    return degrees * (Math.PI / 180);\n};\n\nGeometryUtils.applyRotation = (points, angle, pivot, frontVector) => {\n    if (!(points instanceof Array)) {\n        points = [points];\n    }\n\n    points.forEach((point) => {\n        point.sub(pivot);\n        point.applyAxisAngle(frontVector, angle);\n        point.add(pivot);\n    });\n};\n\nGeometryUtils.getSignedAngle = (v1, v2, eyeVector) => {\n    const angle = v1.angleTo(v2);\n\n    const n = v1.clone().cross(v2).normalize();\n    const sign = eyeVector.dot(n) > 0 ? 1 : -1;\n\n    return angle * sign;\n};\n\nGeometryUtils.swapBoundingBoxY = (boundingBox) => {\n    [boundingBox.max.y, boundingBox.min.y] = [boundingBox.min.y, boundingBox.max.y];\n\n    return boundingBox;\n};\n\nexport default GeometryUtils;","import GeometryUtils from './GeometryUtils';\n\nconst CameraUtils = {};\n\n// Same as viewer.worldToClient, but with a camera as argument.\nCameraUtils.worldToClient = (viewer, point, camera) => {\n    var p = new THREE.Vector4(point.x, point.y, point.z, 1);\n    p.applyMatrix4(camera.matrixWorldInverse);\n    p.applyMatrix4(camera.projectionMatrix);\n\n    // Don't want to mirror values with negative z (behind camera)\n    if (p.w > 0) {\n        p.x /= p.w;\n        p.y /= p.w;\n        p.z /= p.w;\n    }\n\n    return viewer.impl.viewportToClient(p.x, p.y);\n};\n\nCameraUtils.getCameraEyeVector = (camera) => {\n    return camera.target.clone().sub(camera.position).normalize();\n};\n\nCameraUtils.getCameraRightVector = (camera) => {\n    const eye = CameraUtils.getCameraEyeVector(camera);\n    return new THREE.Vector3().crossVectors(eye, camera.up).normalize();\n};\n\nCameraUtils.getCameraUpVector = (camera) => {\n    const right = CameraUtils.getCameraRightVector(camera);\n    const eye = CameraUtils.getCameraEyeVector(camera);\n    return new THREE.Vector3().crossVectors(right, eye).normalize();\n};\n\nCameraUtils.getCameraRotation = (camera) => {\n    return GeometryUtils.getSignedAngle(CameraUtils.getCameraUpVector(camera), new THREE.Vector3(0, 1, 0), CameraUtils.getCameraEyeVector(camera));\n};\n\nexport default CameraUtils;","const ModelUtils = {};\n\nModelUtils.getModelExtension = (url) => {\n    const match = url && url.toLowerCase().match(/\\.([a-z0-9]+)(\\?|$)/);\n    const fileExtension = match ? match[1] : null;\n    return fileExtension;\n};\n\nexport default ModelUtils;","import GeometryUtils from './GeometryUtils';\nimport * as Constants from './GestureDocumentNavigationConstants';\n\nexport default class GestureDocumentNavigationTool {\n    constructor(extension) {\n        this.viewer = extension.viewer;\n        this.navigationDistance = this.viewer.impl.is2d ? Constants.NAVIGATION_DISTANCE_2D : Constants.NAVIGATION_DISTANCE_3D;\n        this.navigationVelocity = this.viewer.impl.is2d ? Constants.NAVIGATION_VELOCITY_2D : Constants.NAVIGATION_VELOCITY_3D;\n\n        this.documents = extension.documents;\n        this.sheets = extension.sheets;\n\n        this.extension = extension;\n\n        this.names = ['gesture-document-navigation'];\n\n        this.leftDirection = new THREE.Vector3(1, 0, 0);\n        this.rightDirection = new THREE.Vector3(-1, 0, 0);\n        this.upDirection = new THREE.Vector3(0, 1, 0);\n        this.downDirection = new THREE.Vector3(0, -1, 0);\n        this.eyeVector = new THREE.Vector3(0, 0, 1);\n\n        this.currentDirection = null;\n    }\n\n    getNames() {\n        return this.names;\n    }\n\n    getName() {\n        return this.names[0];\n    }\n\n    activate(name) {\n        if (name === this.getName()) {\n            this.isActive = true;\n        }\n    }\n\n    deactivate(name) {\n        if (name === this.getName()) {\n            this.isActive = false;\n        }\n    }\n\n    isActive() {\n        return this.isActive;\n    }\n\n    getPriority() {\n        return 100;\n    }\n\n    _isCanvasContainsViewport() {\n        const bounds = Autodesk.Viewing.ScreenShot.getSceneClientBounds(this.viewer, this.viewer.navigation.getCamera());\n        const containerBounds = this.viewer.impl.getCanvasBoundingClientRect();\n\n        return (bounds.min.x > containerBounds.left &&\n                bounds.max.x < containerBounds.right &&\n                bounds.min.y > containerBounds.height - containerBounds.bottom &&\n                bounds.max.y < containerBounds.height - containerBounds.top\n            );\n    }\n\n    /**\n     * On Drag event, gets the the right item to switch to, based on user gesture's direction,\n     * @returns {boolean} True if there is an item to move to.\n     * @param {boolean} event - Dragmove event.\n     * @private\n    */\n    onDrag(event) {\n        const v = new THREE.Vector3(event.canvasX, event.canvasY, 0).sub(this.startPoint);\n        const length = v.length();\n\n        let angle = GeometryUtils.getSignedAngle(v, this.leftDirection, this.eyeVector);\n\n        if (angle < 0) {\n            angle += 2 * Math.PI;\n        }\n\n        let indexToLoad = null;\n        let isSheet;\n        let isDocument;\n\n        if (angle > 5/4 * Math.PI && angle < 7/4 * Math.PI && this.sheets.length > 1) {\n            this.currentDirection = this.upDirection;\n\n            if (this.extension.currentSheetIndex === 0) {\n                if (this.extension.options.enableCyclicSwipe) {\n                    indexToLoad = this.sheets.length - 1;\n                }\n            } else {\n                indexToLoad = this.extension.currentSheetIndex - 1;\n            }\n\n            isSheet = true;\n        } else if (angle > 1/4 * Math.PI && angle <= 3/4 * Math.PI && this.sheets.length > 1) {\n            this.currentDirection = this.downDirection;\n\n            if (this.extension.currentSheetIndex === this.sheets.length - 1) {\n                if (this.extension.options.enableCyclicSwipe) {\n                    indexToLoad = 0;\n                }\n            } else {\n                indexToLoad = this.extension.currentSheetIndex + 1;\n            }\n\n            isSheet = true;\n        } else if (angle > 3/4 * Math.PI && angle <= 5/4 * Math.PI && this.documents.length > 1) {\n            this.currentDirection = this.leftDirection;\n\n            if (this.extension.currentDocumentIndex === this.documents.length - 1) {\n                if (this.extension.options.enableCyclicSwipe) {\n                    indexToLoad = 0;\n                }\n            } else {\n                indexToLoad = this.extension.currentDocumentIndex + 1;\n            }\n\n            isDocument = true;\n        } else if ((angle > 7/4 * Math.PI || angle <= 1/4 * Math.PI) && this.documents.length > 1) {\n            this.currentDirection = this.rightDirection;\n\n            if (this.extension.currentDocumentIndex === 0) {\n                if (this.extension.options.enableCyclicSwipe) {\n                    indexToLoad = this.documents.length - 1;\n                }\n            } else {\n                indexToLoad = this.extension.currentDocumentIndex - 1;\n            }\n\n            isDocument = true;\n        }\n\n        const hasItem = indexToLoad !== null && (isSheet || isDocument);\n\n        if (hasItem && length >= this.navigationDistance) {\n            if (isSheet) {\n                const { guid } = this.sheets[indexToLoad];\n                this.extension.changeSheetRequired(guid);\n            } else if (isDocument) {\n                const { urn, guid } = this.documents[indexToLoad];\n                this.extension.changeDocumentRequired(urn, guid);\n            }\n\n            this.changing = true;\n        }\n\n        return hasItem;\n    }\n\n    _isSwipeEnabled() {\n        return this.viewer.model.is3d() || this._isCanvasContainsViewport();\n    }\n\n    handleGesture(event) {\n        switch (event.type) {\n            case 'dragstart':\n                this.isSwipeEnabled = this._isSwipeEnabled();\n                if (this.isSwipeEnabled) {\n                    this.startPoint = new THREE.Vector3(event.canvasX, event.canvasY, 0);\n                }\n\n                this.swiping = false;\n                this.changing = false;\n\n                return false;\n            case 'dragmove':\n                if (this.changing) {\n                    return true;\n                } else if (this.swiping || (this.isSwipeEnabled && Math.abs(event.overallVelocity) > this.navigationVelocity)) {\n                    this.swiping = true;\n                    return this.onDrag(event);\n                }\n\n                return false;\n            case 'dragend':\n                // When finish swiping, prevent the camera from orbiting. Relevant for 3D only - there is no camera orbit for 2D.\n                // I limited this to 3D only, because of a bug I found when returning true when swiping from a 2D document to 3D document - It was blocking orbit.\n                return this.changing && this.viewer.model.is3d();\n\n            default:\n                break;\n        }\n\n        return false;\n    }\n}\n","export const NAVIGATION_DISTANCE_2D = 50;\nexport const NAVIGATION_DISTANCE_3D = 350; // In order to prevent unwanted navigation, the minimum navigation distance is pretty high.\nexport const NAVIGATION_VELOCITY_2D = 0.7;\nexport const NAVIGATION_VELOCITY_3D = 1.1;\n","import CameraUtils from './CameraUtils';\nimport GeometryUtils from './GeometryUtils';\nimport { parseBubble } from './BubbleUtils';\nimport GestureDocumentNavigationTool from './GestureDocumentNavigationTool';\n\n/**\n * Provide an option to switch sheets and documents, using gestures.\n *\n * The extension id is: `Autodesk.BIM360.GestureDocumentNavigation`\n *\n * @example\n *   viewer.loadExtension('Autodesk.BIM360.GestureDocumentNavigation')\n *\n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n */\nexport default class GestureDocumentNavigationExtension extends Autodesk.Viewing.Extension {\n    /**\n     * Load the GestureDocumentNavigation extension.\n     *\n     * @returns {boolean} True if measure extension is loaded successfully.\n     *\n     * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#load\n     */\n    async load() {\n        const documentNode = this.viewer.impl.model.getDocumentNode();\n        const viewerDoc = documentNode.getRootNode().lmvDocument;\n\n        this.currentGuid = documentNode.guid();\n        this.currentUrn = viewerDoc.myData.urn;\n\n        this.documents = [{ urn: this.currentUrn, guid: this.currentGuid }];\n\n        const items = parseBubble(viewerDoc);\n        const items2D = (items[0] && items[0].sheets) || [];\n        const items3D = (items[1] && items[1].sheets) || [];\n        this.sheets = [...items2D, ...items3D];\n\n        this.pivot = new THREE.Vector3();\n\n        this.currentSheetIndex = this.sheets.findIndex(sheet => sheet.guid === this.currentGuid);\n        this.updateCurrentDocumentIndex();\n\n        this.tool = new GestureDocumentNavigationTool(this);\n\n        this.viewer.toolController.registerTool(this.tool);\n\n        const prevLock = this.viewer.toolController.setIsLocked(false);\n        this.viewer.toolController.activateTool(this.tool.getName());\n        this.viewer.toolController.setIsLocked(prevLock);\n\n        const cache = this.getCache();\n\n        if (this.viewer.impl.is2d) {\n            this.viewer.fitToView(undefined, undefined, true);\n\n            if (cache.direction) {\n                const translation = this.getTranslation(cache.direction);\n                const negativeTranslation = translation.clone().negate();\n                await this.translateCamera(negativeTranslation, true);\n                this.viewer.addEventListener(Autodesk.Viewing.RENDER_PRESENTED_EVENT, async () => {\n                    await this.translateCamera(translation, false);\n                    cache.direction = undefined;\n                }, { once: true });\n            }\n        } else {\n            cache.direction = undefined;\n        }\n\n        return true;\n    }\n\n    /**\n     * Unload the measure extension.\n     *\n     * @returns {boolean} True if measure extension is unloaded successfully.\n     *\n     * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#unload\n     */\n    unload() {\n        if (this.tool) {\n            this.viewer.toolController.deregisterTool(this.tool);\n            this.tool = null;\n        }\n\n        this.viewer = null;\n        this.options = null;\n\n        return true;\n    }\n\n    updateNextDocument(urn, guid) {\n        this.documents.push({ urn, guid });\n        this.updateCurrentDocumentIndex();\n    }\n\n    updatePrevDocument(urn, guid) {\n        this.documents.unshift({ urn, guid });\n        this.updateCurrentDocumentIndex();\n    }\n\n    updateCurrentDocumentIndex() {\n        this.currentDocumentIndex = this.documents.findIndex(\n            (doc) => doc.urn === this.currentUrn && doc.guid === this.currentGuid\n        );\n    }\n\n    /**\n     * Prepare current document before switching sheet / document.\n     *\n     * @param {Function} cb - This callback is called after current document is ready to switch.\n     * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#prepareChange\n     */\n    async prepareChange(cb) {\n        const onDone = () => {\n            const cache = this.getCache();\n            cache.direction = this.tool.currentDirection;\n            cb();\n        };\n\n        if (this.viewer.model.is3d()) {\n            onDone();\n        } else {\n            const translation = this.getTranslation(this.tool.currentDirection);\n            await this.translateCamera(translation, false);\n            onDone();\n        }\n    }\n\n    /**\n     * Change a sheet.\n     *\n     * @param {number} guid - The guid of the desired sheet.\n     * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#changeSheetRequired\n     */\n    changeSheetRequired(guid) {\n        if (!this.options.enableSheetSwipe || !guid) {\n            return;\n        }\n\n        this.prepareChange(() => {\n            this.viewer.dispatchEvent({ type: Autodesk.Viewing.GestureDocumentNavigationEvents.CHANGE_SHEET_REQUIRED, guid });\n        });\n    }\n\n    /**\n     * Change a document.\n     *\n     * @param {number} urn - The urn of the desired document.\n     * @param {number} guid - The guid of the desired sheet.\n     * @alias Autodesk.Viewing.Extensions.GestureDocumentNavigationExtension#changeSheetRequired\n     */\n    changeDocumentRequired(urn, guid) {\n        if (!urn) {\n            return;\n        }\n\n        this.prepareChange(() => {\n            this.viewer.dispatchEvent({ type: Autodesk.Viewing.GestureDocumentNavigationEvents.CHANGE_DOCUMENT_REQUIRED, urn, guid });\n        });\n    }\n\n    getTranslation(direction) {\n        const camera = this.viewer.getCamera();\n        const size = Math.max(camera.top - camera.bottom, camera.right - camera.left);\n        const translation = direction.clone().multiplyScalar(size);\n\n        const cameraRotation = CameraUtils.getCameraRotation(camera);\n        const eyeVec = CameraUtils.getCameraEyeVector(camera);\n        GeometryUtils.applyRotation(translation, -cameraRotation, this.pivot, eyeVec);\n\n        return translation;\n    }\n\n    async translateCamera(translation, immediate) {\n        this.viewer.utilities.autocam.endInteraction();\n\n        const camera = this.viewer.getCamera();\n\n        const position = camera.position.clone().add(translation);\n        const target = camera.target.clone().add(translation);\n\n        if (immediate) {\n            this.viewer.navigation.setView(position, target);\n        } else {\n            this.viewer.navigation.setRequestTransitionWithUp(true, position, target, camera.fov, camera.up);\n            await Autodesk.Viewing.EventUtils.waitUntilTransitionEnded(this.viewer);\n        }\n    }\n}\n\nAutodesk.Viewing.GestureDocumentNavigationEvents = {};\nAutodesk.Viewing.GestureDocumentNavigationEvents.CHANGE_DOCUMENT_REQUIRED = 'change.document.required';\nAutodesk.Viewing.GestureDocumentNavigationEvents.CHANGE_SHEET_REQUIRED = 'change.sheet.required';\n\nGestureDocumentNavigationExtension.extensionName = 'Autodesk.BIM360.GestureDocumentNavigation';\n\nAutodesk.Viewing.theExtensionManager.registerExtension(GestureDocumentNavigationExtension.extensionName, GestureDocumentNavigationExtension);\n\n","import ModelUtils from './ModelUtils';\n\nexport const parseBubble = (viewerDoc) => {\n    const doc = viewerDoc;\n    const viewableItem = doc.getRoot().findAllViewables()[0];\n    const fileExtension = ModelUtils.getModelExtension(viewableItem.name());\n\n    function buildTree(node, role) {\n        // Don't save nodes with type other than 'folder' or 'view' or 'geometry'.\n        if (!(node.type() === 'folder' || node.type() === 'view' || node.type() === 'geometry')) {\n            return null;\n        }\n\n        // Don't save a geometry with a different role than the given one (2d or 3d).\n        if (node.type() === 'geometry' && node.data.role !== role) {\n            return null;\n        }\n\n        const outputNode = {\n            guid: node.guid(),\n            name: node.name(),\n            type: node.type()\n        };\n\n        if (node.type() === 'geometry') {\n            outputNode.order = node.data.order;\n            outputNode.status = node.data.status;\n            outputNode.role = node.data.role;\n            outputNode.hasThumbnail = node.data.hasThumbnail && node.data.hasThumbnail.toLowerCase() === 'true';\n        }\n\n        if (node.children) {\n            // build the subtree of the node's children.\n            const outputChildren = node.children.map(child => buildTree(child, role)).filter(child => !!child);\n\n            if (outputChildren.length > 0) {\n                outputNode.children = outputChildren;\n            }\n        }\n\n        // Don't save empty folders\n        if (node.type() === 'folder' && !outputNode.children) {\n            return null;\n        }\n\n        return outputNode;\n    }\n\n    const getGeometries = (tree) => {\n        if (!tree) {\n            return [];\n        }\n        const wrapper = new Autodesk.Viewing.BubbleNode(tree);\n        const geometries = wrapper.search({ type: 'geometry' });\n        if (geometries) {\n            return geometries.map(geometry => geometry.data);\n        }\n\n        return null;\n    };\n\n    const modifyGeometries = (geometries) => {\n        geometries.forEach((geometry) => {\n            // PDFs can have only one single view - so if there are more, remove them.\n            if (fileExtension === 'pdf' && geometry.children && geometry.children.length > 1) {\n                geometry.children = [geometry.children[0]];\n            }\n        });\n\n\n        // If current document is PDF, then sort geometries by 'order' property.\n        // Since pdf extractor will handle pdf by parallel process, the geometries list may out of order.\n        if (fileExtension === 'pdf') {\n            geometries.sort(function (a, b) {\n                return a.order - b.order;\n            });\n        } else {\n            geometries.sort(function (a, b) {\n                return a.name.localeCompare(b.name);\n            });\n        }\n\n        return geometries;\n    };\n\n    const filterGeometries = (geometries) => {\n        return geometries.filter(geometry =>\n            // NWD extractor doesn't support 2d files. If they do appear, ignore them.\n            !(fileExtension === 'nwd' && geometry.role === '2d')\n        );\n\n        // In case you want to add another filter here, just compose like this: a.filter(b => b>2).filter(c => c>3).\n    };\n\n    if (fileExtension === 'pdf') {\n        const pdfItems = filterGeometries(modifyGeometries(getGeometries(buildTree(viewableItem, '2d'))));\n\n        return [{ type: 'PDF', sheets: pdfItems }];\n    } else {\n        const geometries3D = filterGeometries(modifyGeometries(getGeometries(buildTree(viewableItem, '3d'))));\n        const geometries2D = filterGeometries(modifyGeometries(getGeometries(buildTree(viewableItem, '2d'))));\n\n        return [\n            { type: '2D', sheets: geometries2D },\n            { type: '3D', sheets: geometries3D }\n        ];\n    }\n};\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","GeometryUtils","radians","Math","PI","degrees","points","angle","pivot","frontVector","Array","forEach","point","sub","applyAxisAngle","add","v1","v2","eyeVector","angleTo","n","clone","cross","normalize","dot","boundingBox","max","y","min","CameraUtils","viewer","camera","p","THREE","Vector4","x","z","applyMatrix4","matrixWorldInverse","projectionMatrix","w","impl","viewportToClient","target","position","eye","getCameraEyeVector","Vector3","crossVectors","up","right","getCameraRightVector","getSignedAngle","getCameraUpVector","ModelUtils","url","match","toLowerCase","GestureDocumentNavigationTool","constructor","extension","this","navigationDistance","is2d","navigationVelocity","documents","sheets","names","leftDirection","rightDirection","upDirection","downDirection","currentDirection","getNames","getName","activate","name","isActive","deactivate","getPriority","_isCanvasContainsViewport","bounds","Autodesk","Viewing","ScreenShot","getSceneClientBounds","navigation","getCamera","containerBounds","getCanvasBoundingClientRect","left","height","bottom","top","onDrag","event","v","canvasX","canvasY","startPoint","length","isSheet","isDocument","indexToLoad","currentSheetIndex","options","enableCyclicSwipe","currentDocumentIndex","hasItem","guid","changeSheetRequired","urn","changeDocumentRequired","changing","_isSwipeEnabled","model","is3d","handleGesture","type","isSwipeEnabled","swiping","abs","overallVelocity","GestureDocumentNavigationExtension","Extension","load","documentNode","getDocumentNode","viewerDoc","getRootNode","lmvDocument","currentGuid","currentUrn","myData","items","parseBubble","viewableItem","getRoot","findAllViewables","fileExtension","getModelExtension","buildTree","node","role","data","outputNode","order","status","hasThumbnail","children","outputChildren","map","child","filter","getGeometries","tree","geometries","BubbleNode","search","geometry","modifyGeometries","sort","a","b","localeCompare","filterGeometries","geometries3D","items2D","items3D","findIndex","sheet","updateCurrentDocumentIndex","tool","toolController","registerTool","prevLock","setIsLocked","activateTool","cache","getCache","fitToView","undefined","direction","translation","getTranslation","negativeTranslation","negate","translateCamera","addEventListener","RENDER_PRESENTED_EVENT","async","once","unload","deregisterTool","updateNextDocument","push","updatePrevDocument","unshift","doc","prepareChange","cb","onDone","enableSheetSwipe","dispatchEvent","GestureDocumentNavigationEvents","CHANGE_SHEET_REQUIRED","CHANGE_DOCUMENT_REQUIRED","size","multiplyScalar","cameraRotation","getCameraRotation","eyeVec","applyRotation","immediate","utilities","autocam","endInteraction","setView","setRequestTransitionWithUp","fov","EventUtils","waitUntilTransitionEnded","extensionName","theExtensionManager","registerExtension"],"sourceRoot":""}