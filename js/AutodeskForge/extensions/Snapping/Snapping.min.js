/*!
 * LMV v7.105.0
 *
 * Copyright 2025 Autodesk, Inc.
 * All rights reserved.
 *
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 *
 * Autodesk Viewer SDK Usage Limitations:
 *
 * The Autodesk Viewer SDK JavaScript must be delivered from an
 * Autodesk-hosted URL.
 */(()=>{var e={5439:(e,t,i)=>{"use strict";i.r(t),i.d(t,{intersectLines:()=>n,nearestPointOnCircularArc:()=>r});const r=(e,t,i,r,n,s)=>{const o=(s=s||new THREE.Vector2).copy(e).sub(t).normalize(),a=Math.atan2(o.y,o.x);if(Autodesk.Extensions.CompGeom.angleInsideArc(a,r,n))return o.multiplyScalar(i).add(t);const c=Autodesk.Extensions.CompGeom.getEllipsePoint(r,t.x,t.y,i,i),l=Autodesk.Extensions.CompGeom.getEllipsePoint(n,t.x,t.y,i,i),d=c.distanceToSquared(e)<=l.distanceToSquared(e);return s.copy(d?c:l),s},n=function(e,t,i,r,n,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-5;const a=(r.y-i.y)*(t.x-e.x)-(r.x-i.x)*(t.y-e.y);if(Math.abs(a)<o)return null;let c=(r.x-i.x)*(e.y-i.y)-(r.y-i.y)*(e.x-i.x);if(c/=a,n){let r=(t.x-e.x)*(e.y-i.y)-(t.y-e.y)*(e.x-i.x);if(r/=a,c<0||c>1||r<0||r>1)return null}return(s=s||new THREE.Vector2).x=e.x+c*(t.x-e.x),s.y=e.y+c*(t.y-e.y),s}},6450:(e,t,i)=>{"use strict";i.r(t),i.d(t,{Snapper:()=>y});var r=i(4981),n=i(5439);const s=Autodesk.Viewing.MeasureCommon,o=s.EPSILON,a=s.SnapType,c=s.SnapResult;var l=.001;const d=Autodesk.Viewing,u=d.Private.VertexBufferReader;function h(e,t){return Math.abs(e-t)<=l}function p(e,t){return Math.abs(e.x-t.x)<=l&&Math.abs(e.y-t.y)<=l&&Math.abs(e.z-t.z)<=l}function g(e,t,i){if(t.equals(i))return e.distanceTo(t);var r,n,s=new THREE.Vector3,o=new THREE.Vector3;return s.subVectors(t,e),o.subVectors(i,t),n=s.dot(o),s.subVectors(i,t),(n=-n/s.dot(s))<0?r=e.distanceTo(t):n>1?r=e.distanceTo(i):(s.subVectors(e,t),o.subVectors(e,i),s.cross(o),o.subVectors(i,t),r=Math.sqrt(s.dot(s))/Math.sqrt(o.dot(o))),r}const E={Unknown:0,Line:1,CircularArc:2,EllipticalArc:3};class m{constructor(e){this.type=E.Unknown,this.viewportId=e,this.distance=0,this.lineStart=null,this.lineEnd=null,this.radius=0,this.radiusX=0,this.radiusY=0,this.center=null,this.startAngle=0,this.endAngle=0}fromLine(e,t){return this.type=E.Line,this.lineStart=e.clone(),this.lineEnd=t.clone(),this}fromCircularArc(e,t,i,r){return this.type=E.CircularArc,this.center=e.clone(),this.radius=t,this.start=i,this.end=r,this}fromEllipticalArc(e,t,i,r,n){return this.type=E.EllipticalArc,this.center=e.clone(),this.radiusX=t,this.radiusY=i,this.start=r,this.end=n,this}isLine(){return this.type===E.Line}isCircularArc(){return this.type===E.CirularArc}isEllipticalArc(){return this.type===E.EllipticalArc}getIntersection(e,t){if(this.isLine()&&e.isLine())return(0,n.intersectLines)(this.lineStart,this.lineEnd,e.lineStart,e.lineEnd,!1,t)}}const v=(e,t,i)=>{if(e.sort(((e,t)=>e.distance-t.distance)),e.length<2)return null;const r={viewportId:e[0].viewportId,snapPoint:new THREE.Vector3(0,0,t.z)},n=e[0];for(let s=1;s<e.length;s++){const o=e[s];if(!n.getIntersection(o,r.snapPoint))continue;if(THREE.Vector2.prototype.distanceTo.call(r.snapPoint,t)<i)return r}return null};function y(e,t){var i=new c,E=e;this.setGlobalManager(e.globalManager);var y,f=t||{};y=f.markupMode?["snapper-markup"]:f.toolName?[f.toolName]:["snapper"];var T=!1,w=Number.MAX_VALUE,V=null,R=!1,x=!1,S=!1,P=null,A=!1,M=null;this.indicator=new r.SnapperIndicator(e,this),this.markupMode=f.markupMode,this.renderSnappedGeometry=f.renderSnappedGeometry,this.renderSnappedTopology=f.renderSnappedTopology,this.detectRadiusInPixels=d.isMobileDevice()?50:10,this.isActive=function(){return T},this.getNames=function(){return y},this.getName=function(){return y[0]},this.getPriority=function(){return 60},this.activate=function(){T=!0,this.indicator.isNull()&&(this.indicator=new r.SnapperIndicator(e,this))},this.deactivate=function(){T=!1,this.indicator.isNull()||(this.indicator.destroy(),this.indicator=new r.NullSnapperIndicator)},this.copyResults=function(e){i.copyTo(e)},this.getEdge=function(){return i.geomEdge},this.getVertex=function(){return i.geomVertex},this.getGeometry=function(){return i.getGeometry()},this.getGeometryType=function(){return i.geomType},this.getIntersectPoint=function(){return i.intersectPoint},this.getSnapResult=function(){return i},this.isSnapped=function(){return S},this.clearSnapped=function(){i.clear(),S=!1},this.setViewportId=function(e){P=e},this.setSnapToPixel=function(e){A=e},this.getSnapToPixel=function(){return A},this.setSnapToArc=function(e){i.snapToArc=e},this.getSnapToArc=function(){return i.snapToArc},this.setArc=function(e){i.isArc=e},this.getArc=function(){return i.isArc},this.setSnapFilter=function(e){M=e},this.snapping3D=function(e){i.snapNode=e.dbId,i.intersectPoint=e.intersectPoint,i.modelId=e.model?e.model.id:null;var t=e.face;if(e.model&&void 0!==e.fragId){var r;if(r=void 0===e.fragId.length?[e.fragId]:e.fragId,i.hasTopology=e.model.hasTopology(),i.hasTopology)for(var n=0;n<r.length;++n){var s=r[n],o=e.model.getTopoIndex(s);if(null==e.model.getTopology(o)){i.hasTopology=!1;break}}i.hasTopology?this.snapping3DwithTopology(t,r,e.model):this.snapping3DtoMesh(t,r,e.model)}else e.object instanceof THREE.Mesh&&this.meshSnapping(t,e.object)},this.makeReadVertexFunc=function(e){const t=e.attributes;let i,r,n;if(e.vblayout){if(!e.vblayout.position)return function(){};n=e.vblayout.position.offset}else{if(!t.position)return function(){};n=t.position.offset||0}return i=e.vb?e.vb:e.attributes.position.array,r=e.vb?e.vbstride:3,function(e,t){const s=e*r+n;return(t=t||new THREE.Vector3).set(i[s],i[s+1],i[s+2]),t}},this.snapping3DwithTopology=function(e,t,r){i.snapNode&&(t=[],r.getData().instanceTree.enumNodeFragments(i.snapNode,(function(e){t.push(e)}),!0)),i.geomFace=i.geomEdge=i.geomVertex=null,w=Number.MAX_VALUE;for(var n=0;n<t.length;++n){var s,o,c=t[n];const a=new THREE.Matrix4;null===(s=r.getFragmentList())||void 0===s||s.getWorldMatrix(c,a);var l=null===(o=r.getFragmentList())||void 0===o?void 0:o.getGeometry(c),d=r.getTopoIndex(c),u=r.getTopology(d);if(null!=u){var h=u.faces,p=u.edges;if(!i.geomFace){i.geomFace=this.faceSnappingWithTopology(e,l,h,{matrixWorld:a}),i.geomFace&&(i.geomFace.fragId=c);var g=(new THREE.Matrix3).getNormalMatrix(a);i.faceNormal=e.normal.applyMatrix3(g).normalize()}this.edgeSnappingWithTopology(i.intersectPoint,l,p,{matrixWorld:a})}}if(i.geomVertex=this.vertexSnappingWithTopology(i.geomEdge,i.intersectPoint),i.geomFace){if(i.radius=this.setDetectRadius(i.intersectPoint),(f.forceSnapVertices||V<i.radius)&&i.geomVertex)i.geomType=a.SNAP_VERTEX;else if((f.forceSnapEdges||w<i.radius)&&i.geomEdge){var E=this.edgeIsCircle(i.geomEdge);E?(i.circularArcCenter=E,i.circularArcRadius=E.distanceTo(i.geomEdge.vertices[0]),i.geomEdge.center=i.circularArcCenter,i.geomEdge.radius=i.circularArcRadius,i.geomType=a.SNAP_CIRCULARARC):this.edgeIsCurved(i.geomEdge)?i.geomType=a.SNAP_CURVEDEDGE:i.geomType=a.SNAP_EDGE}else this.faceIsCurved(i.geomFace)?i.geomType=a.SNAP_CURVEDFACE:i.geomType=a.SNAP_FACE;S=!0}},this.meshSnapping=function(e,t){let{geometry:r,matrixWorld:n}=t;if((r.isLines||r.isWideLines)&&e)return i.geomEdge=this.extractLineGeometry(e,r),i.geomEdge.applyMatrix4(n),i.geomVertex=this.vertexSnapping(i.geomEdge,i.intersectPoint),i.radius=this.setDetectRadius(i.intersectPoint),f.forceSnapVertices||V<i.radius?i.geomType=a.SNAP_VERTEX:i.geomType=a.SNAP_EDGE,S=!0,!0;if(e instanceof THREE.Face3&&(i.geomFace=this.faceSnapping(e,r)),!i.geomFace)return!1;i.geomFace.applyMatrix4(n),i.geomEdge=this.edgeSnapping(i.geomFace,i.intersectPoint),i.geomVertex=this.vertexSnapping(i.geomEdge,i.intersectPoint);var s=(new THREE.Matrix3).getNormalMatrix(n);return i.faceNormal=e.normal.applyMatrix3(s).normalize(),i.radius=this.setDetectRadius(i.intersectPoint),f.forceSnapVertices||V<i.radius?i.geomType=a.SNAP_VERTEX:f.forceSnapEdges||w<i.radius?i.geomType=a.SNAP_EDGE:i.geomType=a.SNAP_FACE,S=!0,!0},this.snapping3DtoMesh=function(e,t,i){for(var r=0;r<t.length;++r){var n=t[r];const s=i.getFragmentList().getGeometry(n),o=new THREE.Matrix4;if(i.getFragmentList().getWorldMatrix(n,o),this.meshSnapping(e,{geometry:s,matrixWorld:o}))break}},this.faceSnappingWithTopology=function(e,t,i,r){let{matrixWorld:n}=r;var s=new THREE.Vector3,o=new THREE.Vector3,a=new THREE.Vector3;const c=new THREE.Geometry,l=[];if(void 0!==t.index){for(var d=0;d<i.length;d++){var u=i[d].indexList,h=i[d].id;let t=0;for(;t<u.length;t+=3)if(e.a===u[t]){if(e.b===u[t+1]&&e.c===u[t+2]||e.b===u[t+2]&&e.c===u[t+1])break}else if(e.a===u[t+1]){if(e.b===u[t]&&e.c===u[t+2]||e.b===u[t+2]&&e.c===u[t])break}else if(e.a===u[t+2]&&(e.b===u[t]&&e.c===u[t+1]||e.b===u[t+1]&&e.c===u[t]))break;if(t<u.length)break}if(d<i.length){const e=this.makeReadVertexFunc(t);for(let t=0;t<u.length;t+=3){e(u[t],s),e(u[t+1],o),e(u[t+2],a);const i=l.length;c.faces.push(new THREE.Face3(i,i+1,i+2)),l.push(s.clone()),l.push(o.clone()),l.push(a.clone())}c.vertices=l}}return l.length>0?(c.faceId=h,c.applyMatrix4(n),c):null},this.faceSnapping=function(e,t){var i=new THREE.Vector3,r=new THREE.Vector3,n=new THREE.Vector3;const s=new THREE.Geometry;let o;o=t.index&&(t.index.array||t.ib);var a=t.groups;if(!a||0===a.length){let e;e=t.vb??t.attributes.position.array,a=[{start:0,count:o?o.length:e.length,index:0}]}const c=this.makeReadVertexFunc(t),l=c(e.a);for(var d=0;d<a.length;++d){var u,g=a[d].start,E=a[d].count;u=a[d].index;for(var m=g;m<g+E;m+=3){var v=u+(o?o[m]:m),y=u+(o?o[m+1]:m+1),f=u+(o?o[m+2]:m+2);c(v,i),c(y,r),c(f,n);var T=new THREE.Vector3;if(THREE.Triangle.getNormal(i,r,n,T),p(T,e.normal)&&h(T.dot(i),e.normal.dot(l))){const e=s.vertices.length;s.faces.push(new THREE.Face3(e,e+1,e+2)),s.vertices.push(i.clone()),s.vertices.push(r.clone()),s.vertices.push(n.clone())}}}return s.vertices.length>0?this.getTrianglesOnSameFace(s,e,c):null},this.getTrianglesOnSameFace=function(e,t,i){const r=e.vertices,n=i(t.a),s=i(t.b),o=i(t.c),a=new THREE.Geometry,c=Math.pow(10,5),l=[],d={};let u=-1;for(let e=0;e<r.length;e+=3){const t=r[e],i=r[e+1],a=r[e+2];u<0&&n.equals(t)&&s.equals(i)&&o.equals(a)&&(u=e/3);const h=[Math.round(t.x*c)+"_"+Math.round(t.y*c)+"_"+Math.round(t.z*c),Math.round(i.x*c)+"_"+Math.round(i.y*c)+"_"+Math.round(i.z*c),Math.round(a.x*c)+"_"+Math.round(a.y*c)+"_"+Math.round(a.z*c)],p={edges:[]};for(let t=0;t<3;t++){const i=h[t],r=h[(t+1)%3],n=i+"_"+r;let s=d[n]||d[r+"_"+i];s||(s=d[n]={triangles:[]}),p.edges.push(s),s.triangles.push(e/3)}l.push(p)}if(u<0)return null;const h=[u],p=new Set,g=[];for(;h.length>0;){const e=h.shift();if(p.has(e))continue;p.add(e),g.push(e);const t=l[e];for(const i of t.edges)i.triangles.forEach((t=>t!==e&&h.push(t)))}const E=[];let m=0;return g.forEach((e=>{a.faces.push(new THREE.Face3(m++,m++,m++)),E.push(r[3*e]),E.push(r[3*e+1]),E.push(r[3*e+2])})),a.vertices=E,a},this.edgeSnappingWithTopology=function(e,t,r,n){let{matrixWorld:s}=n;const o=new THREE.Geometry;var a,c=Number.MAX_VALUE,l=new THREE.Vector3,d=new THREE.Vector3;if(void 0!==t.index&&null!=r){const i=this.makeReadVertexFunc(t);for(var u=0;u<r.length;u++)for(var h=r[u].indexList,p=0;p<h.length-1;p++){i(h[p],l),i(h[p+1],d),l.applyMatrix4(s),d.applyMatrix4(s);var E=g(e,l,d);E<c&&(c=E,a=u)}if(a){h=r[a].indexList;for(var m=0;m<h.length-1;m++){const e=i(h[m]),t=i(h[m+1]);o.vertices.push(e),o.vertices.push(t)}}}w>=c&&o.vertices.length>0&&(w=c,o.applyMatrix4(s),i.geomEdge=o)},this.extractLineGeometry=function(e,t){const i=this.makeReadVertexFunc(t),r=i(e.a),n=i(e.b),s=new THREE.Geometry;return s.vertices.push(r,n),s},this.edgeSnapping=function(e,t){const i=[],r=e.vertices.length;for(var n=!0,s=!0,o=!0,a=0;a<r;a+=3){const t=e.vertices[a],l=e.vertices[a+1],d=e.vertices[a+2];for(var c=0;c<r;c+=3)if(a!==c){const i=e.vertices[c],r=e.vertices[c+1],a=e.vertices[c+2];(t.equals(i)||t.equals(r)||t.equals(a))&&(l.equals(i)||l.equals(r)||l.equals(a))&&(n=!1),(t.equals(i)||t.equals(r)||t.equals(a))&&(d.equals(i)||d.equals(r)||d.equals(a))&&(s=!1),(l.equals(i)||l.equals(r)||l.equals(a))&&(d.equals(i)||d.equals(r)||d.equals(a))&&(o=!1)}n&&(i.push(t.clone()),i.push(l.clone())),s&&(i.push(t.clone()),i.push(d.clone())),o&&(i.push(l.clone()),i.push(d.clone())),n=!0,s=!0,o=!0}const l=[],d=new THREE.Geometry;for(var u,h=Number.MAX_VALUE,p=0;p<i.length;p+=2){var E=g(t,i[p],i[p+1]);E<h&&(h=E,u=p)}l.push(i[u].clone()),l.push(i[u+1].clone());const m=new THREE.Geometry;return m.vertices=i,d.vertices=this.getConnectedLineSegmentsOnSameLine(m,l),w=h,d},this.getConnectedLineSegmentsOnSameLine=function(e,t){const i=e.vertices.slice();var r,n,s=t[0],o=t[1],a=[];do{a=[];for(var c=0;c<i.length;c+=2)if(!i[c].equals(s)||!i[c+1].equals(o))for(var d=0;d<t.length;d+=2)if(i[c].equals(t[d])||i[c+1].equals(t[d])||i[c].equals(t[d+1])||i[c+1].equals(t[d+1])){var u=new THREE.Vector3,h=new THREE.Vector3;if(u.subVectors(t[d],t[d+1]),u.normalize(),h.subVectors(i[c],i[c+1]),h.normalize(),p(u,h)||(r=u,n=h,Math.abs(r.x+n.x)<=l&&Math.abs(r.y+n.y)<=l&&Math.abs(r.z+n.z)<=l)){a.push(c);break}}for(var g=a.length-1;g>=0;--g)t.push(i[a[g]]),t.push(i[a[g]+1]),i.splice(a[g],2)}while(a.length>0);return t},this.vertexSnappingWithTopology=function(e,t){var i=Number.MAX_VALUE,r=new THREE.Vector3;if(!e)return r;if(e.vertices.length>1){const o=e.vertices[0],a=e.vertices[e.vertices.length-1];var n=t.distanceTo(o),s=t.distanceTo(a);n<=s?(i=n,r=o.clone()):(i=s,r=a.clone())}return V=i,r},this.vertexSnapping=function(e,t){var i=Number.MAX_VALUE,r=new THREE.Vector3;const n=e.vertices.length;for(let s=0;s<n;++s){const n=e.vertices[s],o=t.distanceTo(n);o<i-l&&(i=o,r=n.clone())}return V=i,r},this.edgeIsCircle=function(e){const t=e.vertices;if(t.length<8)return!1;const i=t[0],r=t[t.length-1];if(i.equals(r)){var n=new THREE.Vector3(0,0,0);for(let e=0;e<t.length;e+=2)n.add(t[e]);n.divideScalar(t.length/2);var s=n.distanceTo(i);for(let e=0;e<t.length;e+=2)if(!(Math.abs(n.distanceTo(t[e])-s)<=l))return!1;return n}return!1},this.edgeIsCurved=function(e){const t=e.vertices,i=t[0],r=t[t.length-1];if(t.length<=2)return!1;if(i.equals(r))return!0;{var n=new THREE.Vector3;let e,r=t[1];n.subVectors(i,r);for(var s=new THREE.Vector3,o=2;o<t.length;o+=2)if(e=t[o],r=t[o+o],s.subVectors(e,r),!p(n,s))return!0;return!1}},this.faceIsCurved=function(e){const t=e.vertices,i=e.faces;if(i.length<=1)return!1;var r=new THREE.Vector3;const n=t[i[0].a];THREE.Triangle.getNormal(t[i[0].a],t[i[0].b],t[i[0].c],r);var s=new THREE.Vector3;for(let e=1;e<i.length;e++){const o=t[i[e].a];if(THREE.Triangle.getNormal(t[i[e].a],t[i[e].b],t[i[e].c],s),!p(r,s)||!h(r.dot(n),s.dot(o)))return!0}return!1},this.angleVector2=function(e){return e.x>0&&e.y>=0?Math.atan(e.y/e.x):e.x>=0&&e.y<0?Math.atan(e.y/e.x)+2*Math.PI:e.x<0&&e.y<=0||e.x<=0&&e.y>0?Math.atan(e.y/e.x)+Math.PI:null};function b(e,t,i){this.viewer=e,this.snapper=t,this.lineGeom=new THREE.Geometry,this.circularArc=null,this.circularArcCenter,this.circularArcRadius,this.ellipticalArc=null,this.ellipticalArcCenter,this.minDist=Number.MAX_VALUE,this.matrix=new THREE.Matrix4,this.vpIdLine=null,this.vpIdCircular=null,this.vpIdElliptical=null,this.detectRadius=i,this.snapCandidates=[]}b.prototype.onLineSegment=function(e,t,i,r,n){var s=this.snapper.getIntersectPoint(),o=new THREE.Vector3(e,t,s.z),a=new THREE.Vector3(i,r,s.z);this.matrix&&(o.applyMatrix4(this.matrix),a.applyMatrix4(this.matrix));var c=g(s,o,a);c>this.detectRadius||(this.snapCandidates.push(new m(n,c).fromLine(o,a)),c<this.minDist&&(this.lineGeom.vertices.splice(0,2,o,a),this.minDist=c,this.vpIdLine=n))},b.prototype.onCircularArc=function(e,t,i,r,s,o){var a=this.snapper.getIntersectPoint(),c=new THREE.Vector2(a.x,a.y),l=new THREE.Vector2(e,t);c.sub(l);const d=(0,n.nearestPointOnCircularArc)(a,l,s,i,r),u=d.distanceTo(a);if(this.snapCandidates.push(new m(o,u).fromCircularArc(l,s,i,r)),u>this.detectRadius)return;var h=this.snapper.angleVector2(c);let p;if(r>i&&h>=i&&h<=r)p=new THREE.CircleGeometry(s,100,i,r-i);else{if(!(r<i&&(h>=i||h<=r)))return;p=new THREE.CircleGeometry(s,100,i,2*Math.PI-i+r)}p.vertices.splice(0,1),p.applyMatrix4((new THREE.Matrix4).makeTranslation(e,t,a.z)),this.circularArc=p,this.circularArcCenter=new THREE.Vector3(e,t,a.z),this.circularArcRadius=s,this.snapPoint=new THREE.Vector3(d.x,d.y,a.z),this.vpIdCircular=o},b.prototype.onEllipticalArc=function(e,t,i,r,n,o,a,c){var l=this.snapper.getIntersectPoint(),d=new THREE.Vector2(l.x,l.y),u=n-this.detectRadius,p=o-this.detectRadius,g=n+this.detectRadius,E=o+this.detectRadius,v=(d.x-e)*(d.x-e)/(u*u)+(d.y-t)*(d.y-t)/(p*p),y=(d.x-e)*(d.x-e)/(g*g)+(d.y-t)*(d.y-t)/(E*E),f=new THREE.Vector2(e,t);d.sub(f),d.x*=o,d.y*=n;var T=this.snapper.angleVector2(d);if(r>2*Math.PI&&(r=2*Math.PI),v>=1&&y<=1&&(r>i&&T>=i&&T<=r||r<i&&(T>=i||T<=r))){var w=((e,t,i,r,n,s,o)=>{let a=new THREE.Geometry;for(let c=0;c<o;c++){const l=new THREE.Vector3(0,0,0),d=c/(o-1);Autodesk.Extensions.CompGeom.getEllipseArcPoint(d,e,t,i,r,n,s,0,l),a.vertices.push(l)}return a})(e,t,n,o,i,r,50);h(r-i,2*Math.PI)||w.vertices.pop(),w.applyMatrix4((new THREE.Matrix4).makeTranslation(0,0,l.z));const a=s.nearestVertexInVertexToEdge(l,w),d=THREE.Vector2.prototype.distanceTo.call(a,l),u=new THREE.Vector2(e,t);this.snapCandidates.push(new m(c,d).makeEllipticalArc(u,n,o,i,r)),this.ellipticalArc=w,this.ellipticalArcCenter=new THREE.Vector3(e,t,l.z),this.vpIdElliptical=c}},b.prototype.setMatrix=function(e){this.matrix=e||new THREE.Matrix4},this.snapping2D=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e)return;let{dbId:r,fragId:n,intersectPoint:s,model:o=E.model}=e;if(o.is3d())return;i.modelId=e.model?e.model.id:null,i.hasTopology=!1,i.intersectPoint=s;let c,l=1;if(E.impl.is2d||(c=o.getModelToViewerTransform(),c&&(l=c.getMaxScaleOnAxis(),i.intersectPoint=s.clone(),i.intersectPoint.applyMatrix4(o.getInverseModelToViewerTransform()))),i.radius=this.setDetectRadius(s)/l,!(null!=o.getFragmentList()))return S=!0,i.geomType=a.SNAP_VERTEX,i.geomVertex=s,void(c&&i.intersectPoint.applyMatrix4(c));var d=new b(E,this,i.radius);if(t.enumSegments){const e=i.intersectPoint.x-i.radius,r=i.intersectPoint.y-i.radius,n=i.intersectPoint.x+i.radius,s=i.intersectPoint.y+i.radius;t.enumSegments(e,r,n,s,d)}else{var h=n;if(void 0===h){if(!A)return;h=[]}else Array.isArray(h)||(h=[h]);for(var p=0;p<h.length;++p){const e=E.impl.getRenderProxy(o,h[p]);if(null!=e&&e.geometry){d.setMatrix(e.matrix);new u(e.geometry).enumGeomsForObject(o.reverseMapDbIdFor2D(r),d),d.setMatrix()}}}if(this.finishSnapping2D(d,i.intersectPoint),!S&&A&&(S=!0,i.geomType=a.RASTER_PIXEL,i.geomVertex=i.intersectPoint),c){var g,m;const e=null===(g=i.geomEdge)||void 0===g?void 0:g.vertices[0],t=null===(m=i.geomEdge)||void 0===m?void 0:m.vertices[1];let r=[i.snapPoint,i.geomVertex,i.intersectPoint,i.circularArcCenter,e,t];r=[...new Set(r.filter((e=>e)))],r.forEach((e=>e.applyMatrix4(c))),i.circularArcRadius&&(i.circularArcRadius*=l),i.radius*=l}},this.snapping2DOverlay=function(e,t,r,n){i.hasTopology=!1,i.intersectPoint=e,i.radius=n||this.setDetectRadius(e);for(var s=new b(E,this,i.radius),o=0;o<t.length;o++){var a=t[o];new u(a.geometry).enumGeoms(r,s)}this.finishSnapping2D(s,e)},this.finishSnapping2D=function(e,t){if(null!==P){const t=e=>e.viewportId===P;e.snapCandidates=e.snapCandidates.filter(t)}const r=v(e.snapCandidates,t,e.detectRadius);if(r)return i.viewportIndex2d=r.viewportId,i.snapPoint=r.snapPoint,i.geomType=a.SNAP_INTERSECTION,i.geomVertex=r.snapPoint,void(S=!0);if(e.circularArc){if(i.viewportIndex2d=e.vpIdCircular,i.snapPoint=e.snapPoint,null!==P&&P!==i.viewportIndex2d)return;const r=e.circularArc.vertices[0],n=e.circularArc.vertices[e.circularArc.vertices.length-1];t.distanceTo(r)<i.radius?(i.geomVertex=r,i.geomType=a.SNAP_VERTEX):t.distanceTo(n)<i.radius?(i.geomVertex=n,i.geomType=a.SNAP_VERTEX):(this.lineStripToPieces(e.circularArc),i.geomEdge=e.circularArc,i.circularArcCenter=e.circularArcCenter,i.circularArcRadius=e.circularArcRadius,i.geomType=a.SNAP_CIRCULARARC),S=!0}else if(e.ellipticalArc){if(i.viewportIndex2d=e.vpIdElliptical,null!==P&&P!==i.viewportIndex2d)return;const r=e.ellipticalArc.vertices[0],n=e.ellipticalArc.vertices[e.ellipticalArc.vertices.length-1];t.distanceTo(r)<i.radius?(i.geomVertex=r,i.geomType=a.SNAP_VERTEX):t.distanceTo(n)<i.radius?(i.geomVertex=n,i.geomType=a.SNAP_VERTEX):(this.lineStripToPieces(e.ellipticalArc),i.geomEdge=e.ellipticalArc,i.circularArcCenter=e.ellipticalArcCenter,i.circularArcRadius=null,i.geomType=a.SNAP_CIRCULARARC),S=!0}else if(e.lineGeom instanceof THREE.Geometry&&e.lineGeom.vertices.length||e.lineGeom.getAttribute&&e.lineGeom.getAttribute("position").count){if(i.viewportIndex2d=e.vpIdLine,null!==P&&P!==i.viewportIndex2d)return;i.geomEdge=e.lineGeom;const r=e.lineGeom.vertices[0],d=e.lineGeom.vertices[1];if(this.markupMode){var n=new THREE.Vector3;n.addVectors(r,d),n.divideScalar(2);var s=t.distanceTo(n),c=t.distanceTo(r),l=t.distanceTo(d);i.geomEdge=e.lineGeom,s<i.radius?(i.geomVertex=n,i.geomType=a.SNAP_VERTEX):c<i.radius?(i.geomVertex=r,i.geomType=a.SNAP_VERTEX):l<i.radius?(i.geomVertex=d,i.geomType=a.SNAP_VERTEX):i.geomType=a.SNAP_EDGE,r.distanceTo(d)<o&&(i.geomType=a.SNAP_CIRCLE_CENTER)}else t.distanceTo(r)<i.radius?(r.distanceTo(d)<o?i.geomType=a.SNAP_CIRCLE_CENTER:i.geomType=a.SNAP_VERTEX,i.geomVertex=r):f.forceSnapVertices||t.distanceTo(d)<i.radius?(i.geomVertex=d,i.geomType=a.SNAP_VERTEX):i.geomType=a.SNAP_EDGE;S=!0}},this.snappingRasterPixel=function(e){if(e){var t=e.intersectPoint;i.intersectPoint=t,i.hasTopology=!1,i.radius=this.setDetectRadius(t),i.geomType=a.RASTER_PIXEL,i.geomVertex=t,S=!0}},this.snapMidpoint=function(){if(i.isMidpoint=!1,S&&i.geomType===a.SNAP_EDGE){const r=i.geomEdge,n=r.vertices[0],s=r.vertices[1];var e=new THREE.Vector3((n.x+s.x)/2,(n.y+s.y)/2,(n.z+s.z)/2),t=E.impl.getAllCutPlanes();if(null!=t&&t.length)for(let i=0;i<t.length;++i){const r=t[i];if(e.x*r.x+e.y*r.y+e.z*r.z+r.w>1e-5)return}i.intersectPoint.distanceTo(e)<2*i.radius&&(i.geomVertex=e,i.geomType=a.SNAP_MIDPOINT)}},this.setPerpendicular=function(e){i.isPerpendicular=e},this.lineStripToPieces=function(e){const t=e.vertices;for(var i=t.length-2;i>0;i--)t.splice(i,0,t[i])},this.setDetectRadius=function(e){var t=E.navigation,i=t.getCamera(),r=t.getPosition(),n=e.clone(),s=i.isPerspective?n.sub(r).length():t.getEyeVector().length(),o=t.getVerticalFov(),a=2*s*Math.tan(THREE.Math.degToRad(.5*o)),c=t.getScreenViewport(),l=this.getWindow().devicePixelRatio||1;return this.detectRadiusInPixels*a/(c.height*l)},this.handleButtonDown=function(){return R=!0,!1},this.handleButtonUp=function(){return R=!1,!1},this.handleMouseMove=function(e){return R||this.onMouseMove({x:e.canvasX,y:e.canvasY}),!1},this.handleSingleTap=function(e){return this.handleMouseMove(e)},this.handlePressHold=function(e){if(d.isMobileDevice())switch(e.type){case"press":x=!0,this.onMouseMove({x:e.canvasX,y:e.canvasY});break;case"pressup":this.onMouseMove({x:e.canvasX,y:e.canvasY}),x=!1}return!1},this.handleGesture=function(e){if(d.isMobileDevice()&&x)switch(e.type){case"dragstart":case"dragmove":this.onMouseMove({x:e.canvasX,y:e.canvasY});break;case"dragend":this.onMouseMove({x:e.canvasX,y:e.canvasY}),x=!1}return!1},this.onMouseDown=function(e){return this.onMouseMove(e)},this.onMouseMove=function(e){var t,r;this.clearSnapped();var n=E.impl.snappingHitTest(e.x,e.y,!1);if(!n&&A){var s=E.impl.clientToViewport(e.x,e.y);n={intersectPoint:E.impl.intersectGroundViewport(s)}}if(!n||!n.intersectPoint)return!1;const o=(null===(t=n.model)||void 0===t?void 0:t.isLeaflet())||E.impl.is2d&&(null===(r=E.model)||void 0===r?void 0:r.isLeaflet());if(n.face)this.snapping3D(n);else if(!n.dbId&&0!==n.dbId||o){(A||o)&&this.snappingRasterPixel(n)}else this.snapping2D(n);return this.snapMidpoint(),!(M&&!M(i))||(this.clearSnapped(),!1)}}d.GlobalManagerMixin.call(y.prototype)},4981:(e,t,i)=>{"use strict";i.r(t),i.d(t,{NullSnapperIndicator:()=>g,SnapperIndicator:()=>E,getXYZFromPos:()=>p});const r=Autodesk.Viewing.MeasureCommon,n=r.isEqualVectors,s=r.EPSILON,o=r.SnapType,a="MeasureTool-snapper-geometries",c="MeasureTool-snapper-indicator",l=.2,d=1.2;let u=null;const h=new THREE.Vector3;function p(e,t){return h.x=e.getX(t),h.y=e.getY(t),h.z=e.getZ(t),h}class g{isNull(){return!0}render(){}removeOverlay(e){}clearOverlay(e){}clearOverlays(){}addOverlay(e,t){}drawFace(e,t,i){}cylinderMesh(e,t,i,r){return new THREE.Mesh}renderGeometry(e){}renderVertexIndicator(e){}renderMidpointIndicator(e){}renderEdgeIndicator(e){}renderCircleIndicator(e){}renderPerpendicular(e){}renderPixelIndicator(e){}renderIndicator(e){}drawLine(e,t,i,r){}drawPoint(e,t,i){}drawCircle(e,t,i){}setScale(e){return 1}setPointScale(e){}setCircleScale(e){}setEdgeScale(e){}updatePointScale(e){}updateEdgeScale(e){}onCameraChange(){}destroy(){}}class E extends g{constructor(e,t){super(),this.viewer=e,this.snapper=t,this.overlayType=0,this.previewsIntersectPoint=null,this.viewer.impl.createOverlayScene(a),this.viewer.impl.createOverlayScene(c),this.geometryMaterial=new THREE.MeshPhongMaterial({color:52224,opacity:.5,transparent:!0,depthTest:!1,depthWrite:!1,side:THREE.DoubleSide}),this.indicatorMaterial=new THREE.MeshBasicMaterial({color:16742144,opacity:1,transparent:!1,depthTest:!1,depthWrite:!1,side:THREE.DoubleSide})}isNull(){return!1}render(){const e=this.snapper.getSnapResult();n(this.previewsIntersectPoint,e.intersectPoint,s)||this.clearOverlay(a),this.clearOverlay(c),e.isEmpty()||((this.snapper.renderSnappedGeometry||e.hasTopology&&this.snapper.renderSnappedTopology)&&this.renderGeometry(e),this.renderIndicator(e),this.previewsIntersectPoint=e.intersectPoint.clone())}removeOverlay(e){this.viewer.impl.clearOverlay(e,!0),this.viewer.impl.removeOverlayScene(e)}clearOverlay(e){this.removeOverlay(e),this.viewer.impl.createOverlayScene(e)}clearOverlays(){this.removeOverlay(a),this.viewer.impl.createOverlayScene(a),this.removeOverlay(c),this.viewer.impl.createOverlayScene(c),this.previewsIntersectPoint=null}addOverlay(e,t){this.viewer.impl.addOverlay(e,t)}drawFace(e,t,i){const r=new THREE.Mesh(e,t,!0);i===a&&(this.overlayType=1),this.addOverlay(i,r)}cylinderMesh(e,t,i,r){const n=(new THREE.Vector3).subVectors(t,e),s=new THREE.Matrix4;s.lookAt(e,t,(new THREE.Object3D).up),s.multiply((new THREE.Matrix4).set(1,0,0,0,0,0,1,0,0,-n.length(),0,0,0,0,0,1)),r=r||.5;let o=new THREE.CylinderGeometry(r,r,1,8,1,!0);const a=new THREE.Mesh(o,i);return o=null,a.applyMatrix4(s),a.position.x=(t.x+e.x)/2,a.position.y=(t.y+e.y)/2,a.position.z=(t.z+e.z)/2,a}renderGeometry(e){if(!n(this.previewsIntersectPoint,e.intersectPoint,s))switch(e.geomType){case o.SNAP_VERTEX:o.RASTER_PIXEL,this.drawPoint(e.geomVertex,this.geometryMaterial,a);break;case o.SNAP_EDGE:case o.SNAP_CURVEDEDGE:case o.SNAP_CIRCULARARC:case o.SNAP_MIDPOINT:this.drawLine(e.geomEdge,this.geometryMaterial,.3,a);break;case o.SNAP_FACE:case o.SNAP_CURVEDFACE:this.drawFace(e.geomFace,this.geometryMaterial,a)}}renderVertexIndicator(e){const t=r.getSnapResultPosition(e,this.viewer),i=this.setScale(t),n=d*i,s=this.viewer.navigation.getCameraRightVector().multiplyScalar(n),o=this.viewer.navigation.getCameraUpVector().multiplyScalar(n),a=new THREE.BufferGeometry,u=[],h=new THREE.Vector3;h.addVectors(t,s),h.addVectors(h,o),u[0]=h.clone(),h.subVectors(t,s),h.addVectors(h,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.addVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),h.subVectors(t,s),h.subVectors(h,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.subVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),h.subVectors(t,s),h.addVectors(h,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.addVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),h.addVectors(t,s),h.addVectors(h,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c)}renderMidpointIndicator(e){const t=e.geomVertex,i=this.setScale(t),r=d*i,n=this.viewer.navigation.getCameraRightVector().multiplyScalar(r),s=this.viewer.navigation.getCameraUpVector().multiplyScalar(r),o=new THREE.BufferGeometry,a=[],u=new THREE.Vector3;u.addVectors(t,n),u.subVectors(u,s),a[0]=u.clone(),u.subVectors(t,n),u.subVectors(u,s),a[1]=u.clone(),o.setFromPoints(a),this.drawLine(o,this.indicatorMaterial,l,c),u.subVectors(t,n),u.subVectors(u,s),a[0]=u.clone(),u.addVectors(t,s),a[1]=u.clone(),o.setFromPoints(a),this.drawLine(o,this.indicatorMaterial,l,c),u.addVectors(t,n),u.subVectors(u,s),a[0]=u.clone(),u.addVectors(t,s),a[1]=u.clone(),o.setFromPoints(a),this.drawLine(o,this.indicatorMaterial,l,c)}renderEdgeIndicator(e){const t=r.getSnapResultPosition(e,this.viewer),i=this.setScale(t),n=d*i,s=this.viewer.navigation.getCameraRightVector().multiplyScalar(n),o=this.viewer.navigation.getCameraUpVector().multiplyScalar(n),a=new THREE.BufferGeometry,u=[],h=new THREE.Vector3;h.addVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.subVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.addVectors(t,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c)}renderCircleIndicator(e){const t=r.getSnapResultPosition(e,this.viewer);this.drawCircle(t,this.indicatorMaterial,c)}renderPerpendicular(e){const t=r.getSnapResultPosition(e,this.viewer),i=this.setScale(t),n=d*i,s=this.viewer.navigation.getCameraRightVector().multiplyScalar(n),o=this.viewer.navigation.getCameraUpVector().multiplyScalar(n),a=new THREE.BufferGeometry,u=[],h=new THREE.Vector3;u[0]=t.clone(),h.subVectors(t,s),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.addVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),h.subVectors(t,s),h.subVectors(h,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.subVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),h.subVectors(t,s),h.addVectors(h,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),u[0]=t.clone(),h.subVectors(t,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c)}renderPixelIndicator(e){const t=r.getSnapResultPosition(e,this.viewer),i=this.setScale(t),n=d*i,s=this.viewer.navigation.getCameraRightVector().multiplyScalar(n),o=this.viewer.navigation.getCameraUpVector().multiplyScalar(n),a=new THREE.BufferGeometry,u=[],h=new THREE.Vector3;h.subVectors(t,s),h.addVectors(h,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.addVectors(t,s),h.addVectors(h,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.addVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.subVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c)}renderIndicator(e){if(e.isPerpendicular)this.renderPerpendicular(e);else if(e.snapToArc)e.isArc&&e.geomType===o.SNAP_CIRCULARARC&&this.viewer.model.is2d()&&!this.viewer.model.isPdf()&&this.renderVertexIndicator(e);else switch(e.geomType){case o.SNAP_VERTEX:case o.SNAP_INTERSECTION:this.renderVertexIndicator(e);break;case o.SNAP_MIDPOINT:this.renderMidpointIndicator(e);break;case o.SNAP_CIRCLE_CENTER:this.renderCircleIndicator(e);break;case o.SNAP_EDGE:case o.SNAP_CURVEDEDGE:this.renderEdgeIndicator(e);break;case o.SNAP_CIRCULARARC:this.viewer.model.is2d()?this.renderVertexIndicator(e):this.renderCircleIndicator(e);break;case o.SNAP_FACE:case o.SNAP_CURVEDFACE:this.renderVertexIndicator(e);break;case o.RASTER_PIXEL:this.renderPixelIndicator(e)}}drawLine(e,t,i,r){let n,s;r===a&&(this.overlayType=2),e instanceof THREE.Geometry?(console.warn("SnapperIndicator.drawLine(geom, material, width, overlayName): THREE.Geometry has been depecrated and the geom argument should use a THREE.BufferGeometry instead"),n=e.vertices.length):(s=e.getAttribute("position"),n=s.count);for(let o=0;o<n;o+=2){let n;n=e instanceof THREE.Geometry?this.cylinderMesh(e.vertices[o],e.vertices[o+1],t,i):this.cylinderMesh(p(s,o).clone(),p(s,o+1).clone(),t,i),this.setEdgeScale(n),this.addOverlay(r,n)}}drawPoint(e,t,i){if(this.viewer.model.isLeaflet())return;u||(u=new THREE.SphereGeometry(1));const r=new THREE.Mesh(u,t);r.position.set(e.x,e.y,e.z),this.setPointScale(r),i===a&&(this.overlayType=3),this.addOverlay(i,r)}drawCircle(e,t,i){let r=new THREE.TorusGeometry(d,l,2,20);const n=new THREE.Mesh(r,t);n.lookAt(this.viewer.navigation.getEyeVector().normalize()),r=null,n.position.set(e.x,e.y,e.z),this.setCircleScale(n),this.addOverlay(i,n)}setScale(e){const t=this.viewer.navigation,i=t.getCamera(),r=t.getPosition(),n=e.clone(),s=i.isPerspective?n.sub(r).length():t.getEyeVector().length(),o=t.getVerticalFov();return 5*(2*s*Math.tan(THREE.Math.degToRad(.5*o)))/t.getScreenViewport().height}setPointScale(e){const t=this.setScale(e.position);e.scale.x=t,e.scale.y=t,e.scale.z=t}setCircleScale(e){const t=this.setScale(e.position);e.scale.x=t,e.scale.y=t}setEdgeScale(e){const t=this.setScale(e.position);e.scale.x=t,e.scale.z=t}updatePointScale(e){if(3!==this.overlayType)return;const t=this.viewer.impl.overlayScenes[e];if(t){const e=t.scene;for(let t=0;t<e.children.length;t++){const i=e.children[t];i&&this.setPointScale(i)}}}updateEdgeScale(e){if(2!==this.overlayType)return;const t=this.viewer.impl.overlayScenes[e];if(t){const e=t.scene;for(let t=0;t<e.children.length;t++){const i=e.children[t];i&&this.setEdgeScale(i)}}}onCameraChange(){this.updatePointScale(a),this.updateEdgeScale(a),this.render()}destroy(){this.removeOverlay(a),this.removeOverlay(c),u&&(u.dispose(),u=null)}}},2573:(e,t,i)=>{var r=Autodesk.Viewing,n=AutodeskNamespace("Autodesk.Viewing.Extensions.Snapping");function s(t,i){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e.exports[r]=t[r],i[r]=t[r])}s(i(5439),n),s(i(6450),n),s(i(4981),n);class o extends r.Extension{constructor(e,t){super(e,t)}load(){return this.viewer.loadExtension("Autodesk.CompGeom")}unload(){return!0}activate(){return!0}deactivate(){return!1}}r.theExtensionManager.registerExtension("Autodesk.Snapping",o)}},t={};function i(r){var n=t[r];if(void 0!==n)return n.exports;var s=t[r]={exports:{}};return e[r](s,s.exports,i),s.exports}i.d=(e,t)=>{for(var r in t)i.o(t,r)&&!i.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r=i(2573);Autodesk.Extensions.Snapping=r})();
//# sourceMappingURL=Snapping.min.js.map