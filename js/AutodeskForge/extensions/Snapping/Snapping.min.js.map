{"version":3,"file":"Snapping/Snapping.min.js","mappings":"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","sources":["webpack://Autodesk.Extensions/./extensions/Snapping/SnapMath.js","webpack://Autodesk.Extensions/./extensions/Snapping/Snapper.js","webpack://Autodesk.Extensions/./extensions/Snapping/SnapperIndicator.js","webpack://Autodesk.Extensions/./extensions/Snapping/index.js","webpack://Autodesk.Extensions/webpack/bootstrap","webpack://Autodesk.Extensions/webpack/runtime/define property getters","webpack://Autodesk.Extensions/webpack/runtime/hasOwnProperty shorthand","webpack://Autodesk.Extensions/webpack/runtime/make namespace object","webpack://Autodesk.Extensions/webpack/startup"],"sourcesContent":["\n// Collection of static math functions used for snapping implementation\n\n// Find closest point to p on a circular arc.\n//  @param {Vector2} center\n//  @param {number} radius\n//  @param {number} startAngle, endAngle - ccw angles in radians. 0 means direction x+\n//  @param {Vector2} [outPoint]\n//  @param {Vector2}\nexport const nearestPointOnCircularArc = (p, center, radius, startAngle, endAngle, outPoint) => {\n\n    outPoint = outPoint || new THREE.Vector2();\n\n    // get normalized direction from circle center to p.\n    // dir = (p-center).normalized()\n    const dir = outPoint.copy(p).sub(center).normalize();\n\n    // If the point is within the arc, we are done\n    const angle = Math.atan2(dir.y, dir.x);\n    const insideArc = Autodesk.Extensions.CompGeom.angleInsideArc(angle, startAngle, endAngle);\n    if (insideArc) {\n        // The ray from center towards p intersects the circle arc.\n        // So, we obtain the closest point by projecting p onto the circle.\n        //\n        // Since dir is the normalized direction from center to p, we obtain the circle projection by:\n        //  onCircleArc = center + dir * radius\n        return dir.multiplyScalar(radius).add(center);\n    }\n\n    // The closest point on the circle is not on the arc.\n    // Then the closest point must be one of the arc ends. Note that this conclusion\n    // can only be made for circles, but not for ellipses with different radii.\n    const pStart = Autodesk.Extensions.CompGeom.getEllipsePoint(startAngle, center.x, center.y, radius, radius);\n    const pEnd   = Autodesk.Extensions.CompGeom.getEllipsePoint(endAngle, center.x, center.y, radius, radius);\n\n    const d2Start = pStart.distanceToSquared(p);\n    const d2End   = pEnd.distanceToSquared(p);\n    const startIsCloser = d2Start <= d2End;\n\n    outPoint.copy(startIsCloser ? pStart : pEnd);\n    return outPoint;\n};\n\n// Compute intersection of two line segments\n// based on http://www.paulbourke.net/geometry/pointlineplane/\n//  @param {Vector2} p1, p2               - First line segment\n//  @param {Vector2} p3, p4               - Second line segment\n//  @param {bool}    [checkInsideSegment] - If true, we reject line intersections outside the segment ranges\n//  @param {Vector2} [outPoint]           - Optional target vector\n//  @param {number}  [epsilon]            - Nearly-zero threshold used to determine \"nearly-parallel\" resp. \"nearly-zero-length line\"\n//  @param {Vector2|null}\nexport const intersectLines = (p1, p2, p3, p4, checkInsideSegment, outPoint, epsilon = 0.00001) => {\n\n    const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n\n    // Reject if lines are parallel or one of them has zero-length\n    if (Math.abs(denom) < epsilon) {\n        return null;\n    }\n\n    // ua denotes where to find the intersection point p along segment (p1, p2):\n    //   For ua = 0, we have p = p1\n    //   For ua = 1, we have p = p2\n    let ua = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x);\n    ua /= denom;\n\n    // Apply segment check\n    if (checkInsideSegment) {\n\n        // ub denotes where to find the intersection point p along segment (p3, p4)\n        let ub = (p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x);\n        ub /= denom;\n\n        // Intersection is within the segments if ua and ub are both in [0,1]\n        if (ua < 0.0 || ua > 1.0 ||\n            ub < 0.0 || ub > 1.0) {\n            return null;\n        }\n    }\n\n    outPoint = outPoint || new THREE.Vector2();\n\n    outPoint.x = p1.x + ua * (p2.x - p1.x);\n    outPoint.y = p1.y + ua * (p2.y - p1.y);\n    return outPoint;\n};\n\n\n\n","\nimport { NullSnapperIndicator, SnapperIndicator } from \"./SnapperIndicator.js\";\nimport { nearestPointOnCircularArc, intersectLines } from \"./SnapMath.js\";\n\nconst MeasureCommon = Autodesk.Viewing.MeasureCommon;\nconst EPSILON = MeasureCommon.EPSILON;\nconst SnapType = MeasureCommon.SnapType;\nconst SnapResult = MeasureCommon.SnapResult;\n\nvar SNAP_PRECISION = 0.001;\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\nconst VertexBufferReader = avp.VertexBufferReader;\n\n/**\n * @param {number} a - First value to compare\n * @param {number} b - Second value to compare\n * @private\n */\nfunction isEqualWithPrecision(a, b) {\n    return Math.abs(a - b) <= SNAP_PRECISION;\n}\n\n/**\n * Are the vectors equal within SNAP_PRECISION?\n * @param {THREE.Vector3} v1 - vector\n * @param {THREE.Vector3} v2 - vector\n * @returns {boolean} - true when they are equal\n * @private\n */\nfunction isEqualVectorsWithPrecision(v1, v2) {\n    return Math.abs(v1.x - v2.x) <= SNAP_PRECISION\n        && Math.abs(v1.y - v2.y) <= SNAP_PRECISION\n        && Math.abs(v1.z - v2.z) <= SNAP_PRECISION;\n}\n\n/**\n * Are the vectors inverse of each other within SNAP_PRECISION?\n * @param {THREE.Vector3} v1 - vector\n * @param {THREE.Vector3} v2 - vector\n * @returns {boolean} - true when they are inverse of each other\n * @private\n */\nfunction isInverseVectorsWithPrecision(v1, v2) {\n    return Math.abs(v1.x + v2.x) <= SNAP_PRECISION\n        && Math.abs(v1.y + v2.y) <= SNAP_PRECISION\n        && Math.abs(v1.z + v2.z) <= SNAP_PRECISION;\n}\n\n/**\n * @param {THREE.Vector3} point - Point\n * @param {THREE.Vector3} lineStart - Start of the line\n * @param {THREE.Vector3} lineEnd - End of the line\n * @returns {number} - distance from point to the line\n * @private\n */\nfunction distancePointToLine(point, lineStart, lineEnd) {\n\n    if (lineStart.equals(lineEnd)) { // Degenerate line\n        return point.distanceTo(lineStart);\n    }\n\n    var X0 = new THREE.Vector3();\n    var X1 = new THREE.Vector3();\n    var distance;\n    var param;\n\n    X0.subVectors(lineStart, point);\n    X1.subVectors(lineEnd, lineStart);\n    param = X0.dot(X1);\n    X0.subVectors(lineEnd, lineStart);\n    param = -param / X0.dot(X0);\n\n    if (param < 0) {\n        distance = point.distanceTo(lineStart);\n    } else if (param > 1) {\n        distance = point.distanceTo(lineEnd);\n    } else {\n        X0.subVectors(point, lineStart);\n        X1.subVectors(point, lineEnd);\n        X0.cross(X1);\n        X1.subVectors(lineEnd, lineStart);\n\n        distance = Math.sqrt(X0.dot(X0)) / Math.sqrt(X1.dot(X1));\n    }\n\n    return distance;\n}\n\nconst SnapCandidateType = {\n    Unknown:       0,\n    Line:          1,\n    CircularArc:   2,\n    EllipticalArc: 3\n};\n\n// A SnapCandidate references a single segment (line or arc) that we could snap to.\nclass SnapCandidate {\n    constructor(viewportId) {\n\n        this.type = SnapCandidateType.Unknown;\n        this.viewportId = viewportId;\n\n        // 2d distance between original (unsnapped) position and the geometry of this candidate.\n        this.distance = 0;\n\n        // {Vector2} Start/Endpoint - only for line segments\n        this.lineStart = null;\n        this.lineEnd   = null;\n\n        // Fixed radius - only for CircularArcs\n        this.radius = 0;\n\n        // Separate radii - only for ellipse arcs\n        this.radiusX = 0; // = major radius - by convention\n        this.radiusY = 0;\n\n        // Center point as Vector2 (for arcs)\n        this.center = null;\n\n        // Start/end angle for arcs: Ccw angle in radians. Angle 0 corresponds to direction x+.\n        this.startAngle = 0;\n        this.endAngle   = 0;\n    }\n\n    fromLine(p1, p2) {\n        this.type = SnapCandidateType.Line;\n        this.lineStart = p1.clone();\n        this.lineEnd   = p2.clone();\n        return this;\n    }\n\n    fromCircularArc(center, radius, start, end) {\n        this.type   = SnapCandidateType.CircularArc;\n        this.center = center.clone();\n        this.radius = radius;\n        this.start  = start;\n        this.end    = end;\n        return this;\n    }\n\n    fromEllipticalArc(center, radiusX, radiusY, start, end) {\n        this.type = SnapCandidateType.EllipticalArc;\n        this.center = center.clone();\n        this.radiusX = radiusX;\n        this.radiusY = radiusY;\n        this.start = start;\n        this.end = end;\n        return this;\n    }\n\n    isLine()          { return this.type === SnapCandidateType.Line; }\n    isCircularArc()   { return this.type === SnapCandidateType.CirularArc; }\n    isEllipticalArc() { return this.type === SnapCandidateType.EllipticalArc; }\n\n    // Checks if the snapGeometry of this candidate intersects with another one.\n    //  @param {SnapCandidate} other\n    //  @param {Vector2} [optionalTarget]\n    //  @returns {THREE.Vector2|null} Returns intersection point if there is one.\n    getIntersection(other, optionalTarget) {\n\n        if (this.isLine() && other.isLine()) {\n            // Note: We do the intersections on the whole line - not just the intersections.\n            // Reason is:\n            //  a) Otherwise, it would not snap if you are slightly outline of one line segment\n            //  b) By definition, we get only very close segment candidates anyway\n            return intersectLines(this.lineStart, this.lineEnd, other.lineStart, other.lineEnd, false, optionalTarget);\n        }\n\n        // TODO: Currently, we only support snapping to line-line intersections\n    }\n}\n\n// Checks if we can snap to an intersection of two close segments (each can be a line or arcs).\n//  @param {SnapCandidate[]} candidates     - Snap candidate geometries collected in GeometryCallback. Assumed to be within snapRadius.\n//  @param {TREE.Vector3}    intersectPoint - Unsnapped original position\n//  @param {number}          snapRadius\n//  @returns {Object|null} If an intersection snap is found, the result contains:\n//                    {\n//                        viewportId  // number\n//                        snapPoint   // (THREE.Vector3)\n//                    }\nconst findIntersectionSnap = (candidates, intersectPoint, snapRadius) => {\n\n    // Sort snapping candidates by increasing distance\n    // Strictly speaking, we just need the best two ones. But the number of candidates within the snapping\n    // distance is generally small anyway - and working with a sorted array is more flexible to incrementally\n    // make the snapping smarter later.\n    const byDistance = (ca, cb) => ca.distance - cb.distance;\n    candidates.sort(byDistance);\n\n    // Stop here if we don't have enough candidates for an intersection\n    if (candidates.length < 2) {\n        return null;\n    }\n\n    // Init result object\n    const result = {\n        // Just use the one of the first candidate. There is no unique viewportId when using an intersection.\n        viewportId: candidates[0].viewportId,\n\n        // Snapping happens in 2d - so we set z in advance and just keep the original value.\n        // Note: Snapper generally needs some revision if we use it for planes that are not perpendicular to the viewing direction.\n        snapPoint:  new THREE.Vector3(0, 0, intersectPoint.z)\n    };\n\n    // Check for any candidate that intersects with the closest one we found\n    const first = candidates[0];\n    for (let i=1; i<candidates.length; i++) {\n        const second = candidates[i];\n\n        // Do intersection test. If found, write it to result.snapPoint\n        const found = first.getIntersection(second, result.snapPoint);\n        if (!found) {\n            continue;\n        }\n\n        // We found an intersection. Although we assume all candidates to be within\n        // snap radius already, the intersection may still be somewhere else.\n        // => Check if intersection is still within the snapRadius.\n        const dist = THREE.Vector2.prototype.distanceTo.call(result.snapPoint, intersectPoint);\n        if (dist < snapRadius) {\n            // We found a valid intersection snap\n            return result;\n        }\n    }\n    return null;\n};\n\n\n/**\n * A tool that lets users attach pointer events to vertices and edges. It supports 2D and 3D models.\n *\n * @param {Viewer3D} viewer - Viewer instance\n * @param {object} options - Configurations for the extension\n * @memberof Autodesk.Viewing.Extensions.Snapping\n * @alias Autodesk.Viewing.Extensions.Snapping.Snapper\n * @class\n */\nexport function Snapper(viewer, options) {\n\n    var _snapResult = new SnapResult();\n\n    var _viewer = viewer;\n    this.setGlobalManager(viewer.globalManager);\n\n    var _options = options || {};\n    var _names;\n\n    if (_options.markupMode) {\n        _names = [\"snapper-markup\"];\n    } else if (_options.toolName) {\n        // Allow tools to use their own snapper\n        _names = [_options.toolName];\n    } else {\n        _names = [\"snapper\"];\n    }\n\n    var _priority = 60;\n\n    var _active = false;\n\n    var _distanceToEdge = Number.MAX_VALUE;\n    var _distanceToVertex = null;\n\n    var _isDragging = false;\n    var _isPressing = false;\n    var _isSnapped = false;\n\n    var _forcedVpId = null; // the viewport index of the first selection for 2D\n\n    var _snapToPixel = false;\n\n    var _snapFilter = null; // Optional snapping filter, based on snapResult. (snapResult) => boolean.\n\n    this.indicator = new SnapperIndicator(viewer, this);\n\n    this.markupMode = _options.markupMode;\n    this.renderSnappedGeometry = _options.renderSnappedGeometry;\n    this.renderSnappedTopology = _options.renderSnappedTopology;\n\n    //Notice: The pixelSize should correspond to the amount of pixels per line in idAtPixels, the shape of\n    //detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.\n    this.detectRadiusInPixels = av.isMobileDevice() ? 50 : 10;\n\n    /**\n     * @returns {boolean} true when the tool is active\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isActive\n     */\n    this.isActive = function() {\n        return _active;\n    };\n\n    this.getNames = function() {\n        return _names;\n    };\n\n    this.getName = function() {\n        return _names[0];\n    };\n\n    this.getPriority = function() {\n        return _priority;\n    };\n\n    /**\n     * Starts intercepting pointer events.\n     * Invoked automatically by the {@link ToolController}.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#activate\n     */\n    this.activate = function() {\n        _active = true;\n\n        if (this.indicator.isNull()) {\n            this.indicator = new SnapperIndicator(viewer, this);\n        }\n    };\n\n\n    /**\n     * Stops intercepting pointer events.\n     * Invoked automatically by the {@link ToolController}.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#deactivate\n     */\n    this.deactivate = function() {\n        _active = false;\n\n        if (!this.indicator.isNull()) {\n            this.indicator.destroy();\n            this.indicator = new NullSnapperIndicator();\n        }\n    };\n\n    this.copyResults = function(destiny) {\n        _snapResult.copyTo(destiny);\n    };\n\n    this.getEdge = function() {\n        return _snapResult.geomEdge;\n    };\n\n    this.getVertex = function() {\n        return _snapResult.geomVertex;\n    };\n\n    this.getGeometry = function() {\n        return _snapResult.getGeometry();\n    };\n\n    this.getGeometryType = function() {\n        return _snapResult.geomType;\n    };\n\n    this.getIntersectPoint = function() {\n        return _snapResult.intersectPoint;\n    };\n\n\n    /**\n     * @returns {SnapResult} The snapping status of the last pointer event performed.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#getSnapResult\n     */\n    this.getSnapResult = function() {\n        return _snapResult;\n    };\n\n    /**\n     * Checks whether the tool's last update resulted on a snap.\n     *\n     * @returns {boolean} true when the last pointer event got snapped.\n     *\n     * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isSnapped\n     */\n    this.isSnapped = function() {\n        return _isSnapped;\n    };\n\n    this.clearSnapped = function() {\n        _snapResult.clear();\n        _isSnapped = false;\n    };\n\n    this.setViewportId = function(vpId) {\n        _forcedVpId = vpId;\n    };\n\n    this.setSnapToPixel = function(enable) {\n        _snapToPixel = enable;\n    };\n\n    this.getSnapToPixel = function() {\n        return _snapToPixel;\n    };\n\n    this.setSnapToArc = function(enable) {\n        _snapResult.snapToArc = enable;\n    };\n\n    this.getSnapToArc = function() {\n        return _snapResult.snapToArc;\n    };\n\n    this.setArc = function(isArc) {\n        _snapResult.isArc = isArc;\n    };\n\n    this.getArc = function() {\n        return _snapResult.isArc;\n    };\n\n    this.setSnapFilter = function (filter) {\n        _snapFilter = filter;\n    };\n\n    /**\n     * 3D Snapping\n     *\n     * @param result -Result of Hit Test.\n     */\n    this.snapping3D = function(result) {\n\n        _snapResult.snapNode = result.dbId;\n        _snapResult.intersectPoint = result.intersectPoint;\n        _snapResult.modelId = result.model ? result.model.id : null;\n\n        var face = result.face;\n\n        if (!result.model || result.fragId === undefined) {\n            // some non-model geometry was hit\n            if (result.object instanceof THREE.Mesh) {\n                // if it was a mesh, try to snap to it\n                this.meshSnapping(face, result.object);\n            }\n        } else {\n            var fragIds;\n\n            if (result.fragId.length === undefined) {\n                fragIds = [result.fragId];\n            } else {\n                fragIds = result.fragId;\n            }\n\n            // This is for Fusion & ATF model with topology data\n            _snapResult.hasTopology = result.model.hasTopology();\n            if(_snapResult.hasTopology)\n            {\n                // For mixed mode (some entities have topo, and some others don't),\n                // we should further check the selected fragId has valid topology before go with snapping3DwithTopology.\n                for (var fi = 0; fi < fragIds.length; ++fi) {\n\n                    var fragId = fragIds[fi];\n                    var topoIndex = result.model.getTopoIndex(fragId);\n                    var topology = result.model.getTopology(topoIndex);\n                    if(topology == undefined)\n                    {\n                        _snapResult.hasTopology = false;\n                        break;\n                    }\n                }\n            }\n\n\n            if (_snapResult.hasTopology) {\n                this.snapping3DwithTopology(face, fragIds, result.model);\n            } else {\n                this.snapping3DtoMesh(face, fragIds, result.model);\n            }\n        }\n    };\n\n\n    /**\n     * Returns a function that sets a vertex (Vector3 or LmvVector3) to the data read from a vertex buffer at idx\n     * Signature: func(idx, vertex) -> vertex\n     *            if vertex is null/undefined, a new THREE.Vector3 is created\n     *\n     * @param {BufferGeometry} geometry - the geometry of mesh\n     *\n     * @private\n     */\n\n    this.makeReadVertexFunc = function(geometry) {\n        const attributes = geometry.attributes;\n        let positions, stride;\n        // Get the offset to positions in the buffer. Be careful, 2D buffers\n        // don't use the 'position' attribute for positions. Reject those.\n        // meshes use vblayout for describing the buffer structure, BufferGeometry uses attributes.xx\n        let poffset;\n\n        if (geometry.vblayout) {\n            if (!geometry.vblayout.position) {\n                return function() {};     // No positions, what to do??\n            }\n            poffset = geometry.vblayout.position.offset;\n        } else if (!attributes.position) {\n            return function() {};     // No positions, what to do??\n        } else {\n            poffset = attributes.position.offset || 0;\n        }\n\n        positions = geometry.vb ? geometry.vb : geometry.attributes.position.array;\n        stride = geometry.vb ? geometry.vbstride : 3;\n\n        return function(idx, v) {\n            const p = idx * stride + poffset;\n            v = v || new THREE.Vector3();\n            v.set(\n                positions[p],\n                positions[p + 1],\n                positions[p + 2]\n            );\n            return v;\n        };\n    };\n\n    /**\n     * Snapping order is: 1st vertices, 2nd edges, 3rd and final faces.\n     *\n     * @param face\n     * @param fragIds\n     * @param model\n     * @private\n     */\n    this.snapping3DwithTopology = function(face, fragIds, model) {\n\n        // Because edge topology data may be in other fragments with same dbId, need to iterate all of them.\n        if (_snapResult.snapNode) {\n            fragIds = [];\n\n            model.getData().instanceTree.enumNodeFragments(_snapResult.snapNode, function(fragId) {\n                fragIds.push(fragId);\n            }, true);\n        }\n\n        _snapResult.geomFace = _snapResult.geomEdge = _snapResult.geomVertex = null;\n        _distanceToEdge = Number.MAX_VALUE;\n\n        for (var fi = 0; fi < fragIds.length; ++fi) {\n\n            var fragId = fragIds[fi];\n\n            const matrixWorld = new THREE.Matrix4();\n            model.getFragmentList()?.getWorldMatrix(fragId, matrixWorld);\n            var geometry = model.getFragmentList()?.getGeometry(fragId);\n\n            var topoIndex = model.getTopoIndex(fragId);\n            var topology = model.getTopology(topoIndex);\n            // For ATF merged DBID scenario, part of merged entities may have no topology.\n            // we should skip this case for face and edge topology measurement.\n            if(topology == undefined)\n                continue;\n\n            var facesTopology = topology.faces;\n            var edgesTopology = topology.edges;\n\n            if (!_snapResult.geomFace) {\n                _snapResult.geomFace = this.faceSnappingWithTopology(face, geometry, facesTopology, {matrixWorld});\n\n                if (_snapResult.geomFace) {\n                    _snapResult.geomFace.fragId = fragId;\n                }\n\n                var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrixWorld);\n                _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n            }\n\n            // Need to iterate all frags with same dbId, because when meshes are attached with each other,\n            // edge-topology data will only be on one mesh.\n            this.edgeSnappingWithTopology(_snapResult.intersectPoint, geometry, edgesTopology, {matrixWorld});\n\n        }\n\n        _snapResult.geomVertex = this.vertexSnappingWithTopology(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n        if (_snapResult.geomFace) {\n\n            // Determine which one should be drawn: face , edge or vertex\n            _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n            if ((_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) && _snapResult.geomVertex) {\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if ((_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) && _snapResult.geomEdge) {\n\n                var center = this.edgeIsCircle(_snapResult.geomEdge);\n                if (center) {\n                    _snapResult.circularArcCenter = center;\n                    _snapResult.circularArcRadius = center.distanceTo(_snapResult.geomEdge.vertices[0]);\n                    _snapResult.geomEdge.center = _snapResult.circularArcCenter;\n                    _snapResult.geomEdge.radius = _snapResult.circularArcRadius;\n                    _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n                }\n                else if (this.edgeIsCurved(_snapResult.geomEdge)) {\n                    _snapResult.geomType = SnapType.SNAP_CURVEDEDGE;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n\n            }\n            else {\n\n                if (this.faceIsCurved(_snapResult.geomFace)) {\n                    _snapResult.geomType = SnapType.SNAP_CURVEDFACE;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_FACE;\n                }\n\n            }\n\n            _isSnapped = true;\n        }\n    };\n\n    this.meshSnapping = function(face, {geometry, matrixWorld}) {\n\n        // Handle 3D line geometry\n        const isLine = geometry.isLines || geometry.isWideLines;\n        if (isLine && face) {\n\n            // For line meshes, face is a line {a, b} instead of a Face3 instance (see lineRayCast(..) in VBIntersector.js,\n            // where a, b are vertex indices into the line mesh vertex array.\n            //\n            // Note: Unlike edge intersection for faces, we just use the line segment itself and don't search for topology\n            //       of connected line segments to identify polylines as one item. If we need this, we have to add the corresponding code first.\n            _snapResult.geomEdge = this.extractLineGeometry(face, geometry);\n            _snapResult.geomEdge.applyMatrix4(matrixWorld);\n\n            _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n            _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n            // Determine which one should be drawn: edge or vertex\n            if ((_options.forceSnapVertices || (_distanceToVertex < _snapResult.radius))) {\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else {\n                // Note: Since we got the edge as hit result, we can already assume the intersection to be close to the line.\n                _snapResult.geomType = SnapType.SNAP_EDGE;\n            }\n\n            _isSnapped = true;\n            return true;\n        }\n\n        // Note that face may also be a line {a, b} (see lineRayCast(..) in VBIntersector.js\n        if (face instanceof THREE.Face3) {\n            _snapResult.geomFace = this.faceSnapping(face, geometry);\n        }\n\n        if (!_snapResult.geomFace)\n            return false;\n\n        _snapResult.geomFace.applyMatrix4(matrixWorld);\n        _snapResult.geomEdge = this.edgeSnapping(_snapResult.geomFace, _snapResult.intersectPoint);\n        _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n        var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrixWorld);\n        _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n\n        _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n        // Determine which one should be drawn: face, edge or vertex\n        if ((_options.forceSnapVertices || (_distanceToVertex < _snapResult.radius))) {\n            _snapResult.geomType = SnapType.SNAP_VERTEX;\n        }\n        else if (_options.forceSnapEdges || (_distanceToEdge < _snapResult.radius)) {\n            _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n        else {\n            _snapResult.geomType = SnapType.SNAP_FACE;\n        }\n\n        _isSnapped = true;\n        return true;\n    };\n\n    this.snapping3DtoMesh = function(face, fragIds, model) {\n        for (var fi = 0; fi < fragIds.length; ++fi) {\n\n            var fragId = fragIds[fi];\n\n\n            const geometry = model.getFragmentList().getGeometry(fragId);\n            const matrixWorld = new THREE.Matrix4();\n            model.getFragmentList().getWorldMatrix(fragId, matrixWorld);\n\n            if (this.meshSnapping(face, {geometry, matrixWorld})) {\n                break;\n            }\n        }\n    };\n\n    this.faceSnappingWithTopology = function(face, geometry, facesTopology, {matrixWorld}) {\n\n        var vA = new THREE.Vector3();\n        var vB = new THREE.Vector3();\n        var vC = new THREE.Vector3();\n\n        const geom = new THREE.Geometry();\n        const vertices = [];\n\n        if (geometry.index !== undefined) {\n\n            // Find the index of face topology list which includes the intersect face(triangle)\n            for (var i = 0; i < facesTopology.length; i++) {\n\n                var indexList = facesTopology[i].indexList;\n                var faceId = facesTopology[i].id;\n                let j = 0;\n                for (; j < indexList.length; j += 3) {\n\n                    if (face.a === indexList[j]) {\n                        if ((face.b === indexList[j + 1] && face.c === indexList[j + 2]) || (face.b === indexList[j + 2] && face.c === indexList[j + 1])) {\n                            break;\n                        }\n                    }\n                    else if (face.a === indexList[j + 1]) {\n                        if ((face.b === indexList[j] && face.c === indexList[j + 2]) || (face.b === indexList[j + 2] && face.c === indexList[j])) {\n                            break;\n                        }\n                    }\n                    else if (face.a === indexList[j + 2]) {\n                        if ((face.b === indexList[j] && face.c === indexList[j + 1]) || (face.b === indexList[j + 1] && face.c === indexList[j])) {\n                            break;\n                        }\n                    }\n                }\n\n                if (j < indexList.length) {\n                    break;\n                }\n            }\n\n            if (i < facesTopology.length) {\n\n                const readVertex = this.makeReadVertexFunc(geometry);\n\n                for (let j = 0; j < indexList.length; j += 3) {\n                    readVertex(indexList[j], vA);\n                    readVertex(indexList[j + 1], vB);\n                    readVertex(indexList[j + 2], vC);\n\n                    const vIndex = vertices.length;\n                    geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n                    vertices.push(vA.clone());\n                    vertices.push(vB.clone());\n                    vertices.push(vC.clone());\n                }\n                geom.vertices = vertices;\n\n            }\n        }\n\n        if (vertices.length > 0) {\n\n            geom.faceId = faceId;\n            geom.applyMatrix4(matrixWorld);\n            return geom;\n        }\n        else {\n\n            return null;\n        }\n\n    };\n\n    /**\n     * Find the closest face next to the cast ray\n     *\n     * @param {THREE.Face3} face - the intersect triangle of Hit Test.\n     * @param {BufferGeometry} geometry - the geometry of mesh\n     *\n     * @private\n     */\n    this.faceSnapping = function(face, geometry) {\n\n        var vA = new THREE.Vector3();\n        var vB = new THREE.Vector3();\n        var vC = new THREE.Vector3();\n\n        const geom = new THREE.Geometry(); //Geometry which includes all the triangles on the same plane.\n\n        let indices;\n        // @todo: .ib might not be there as expected, e.g., the section tool seems to create incomplete/non-conforming geometries.\n        indices = geometry.index && (geometry.index.array || geometry.ib);\n\n        var offsets = geometry.groups;\n\n        if ( !offsets || offsets.length === 0) {\n\n            let positions;\n            // @todo: .vb might not be there as expected, e.g., the section tool seems to create incomplete/non-conforming geometries.\n            positions = geometry.vb ?? geometry.attributes.position.array;\n            offsets = [{ start: 0, count: indices ? indices.length : positions.length, index: 0 }];\n        }\n\n        const readVertex = this.makeReadVertexFunc(geometry);\n\n        const va = readVertex(face.a);\n\n        for (var oi = 0; oi < offsets.length; ++oi) {\n\n            var start = offsets[oi].start;\n            var count = offsets[oi].count;\n            var index = 0;\n            index = offsets[oi].index;\n\n            for (var i = start; i < start + count; i += 3) {\n\n                var a = index + (indices ? indices[i] : i);\n                var b = index + (indices ? indices[i + 1] : i + 1);\n                var c = index + (indices ? indices[i + 2] : i + 2);\n\n                readVertex(a, vA);\n                readVertex(b, vB);\n                readVertex(c, vC);\n\n                var faceNormal = new THREE.Vector3();\n                THREE.Triangle.getNormal(vA, vB, vC, faceNormal);\n\n                if (isEqualVectorsWithPrecision(faceNormal, face.normal) && isEqualWithPrecision(faceNormal.dot(vA), face.normal.dot(va)))\n                {\n\n                    const vIndex = geom.vertices.length;\n                    geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n                    geom.vertices.push(vA.clone());\n                    geom.vertices.push(vB.clone());\n                    geom.vertices.push(vC.clone());\n                }\n            }\n        }\n\n        if (geom.vertices.length > 0) {\n\n            return this.getTrianglesOnSameFace(geom, face, readVertex);\n        }\n        else {\n\n            return null;\n        }\n    };\n\n    /**\n     * Find triangles on the same face with the triangle intersected with the cast ray\n     *\n     * @param geom -Geometry which includes all the triangles on the same plane.\n     * @param face -Triangle which intersects with the cast ray.\n     * @param readVertexCB -Accessor function to read vertex data (see makeReadVertexFunc)\n     *\n     * @private\n     */\n    this.getTrianglesOnSameFace = function(geom, face, readVertexCB) {\n        const vertices = geom.vertices;\n\n        const faceVertex1 = readVertexCB(face.a);\n        const faceVertex2 = readVertexCB(face.b);\n        const faceVertex3 = readVertexCB(face.c);\n\n        const intersectFace = new THREE.Geometry();\n\n        const precisionPoints = 5; // number of decimal points, eg. 4 for epsilon of 0.0001\n        const precision = Math.pow( 10, precisionPoints );\n\n        // Build triangle list\n        // Each triangle will contain a list of its 3 edges\n        // Also maintain an edge map, pointing to the triangles indices that contain it\n        const trianglesArr = [];\n        const edgesMap = {};\n        let firstTriangle = -1; // Will point to index of passed face parameter\n        for (let i = 0; i < vertices.length; i += 3) {\n            // for each triangle\n            const vA = vertices[i];\n            const vB = vertices[i + 1];\n            const vC = vertices[i + 2];\n\n            if (firstTriangle < 0 && faceVertex1.equals(vA) && faceVertex2.equals(vB) && faceVertex3.equals(vC)) {\n                firstTriangle = i / 3;\n            }\n\n            const keys = [\n                Math.round(vA.x * precision) + '_' + Math.round(vA.y * precision) + '_' + Math.round(vA.z * precision),\n                Math.round(vB.x * precision) + '_' + Math.round(vB.y * precision) + '_' + Math.round(vB.z * precision),\n                Math.round(vC.x * precision) + '_' + Math.round(vC.y * precision) + '_' + Math.round(vC.z * precision)\n            ];\n            const triangle = { edges: [] };\n\n            // Edge map update\n            for (let j = 0; j < 3; j++) {\n                const key1 = keys[j];\n                const key2 = keys[(j + 1) % 3];\n\n                const defaultEdge = key1 + '_' + key2;\n                let edge = edgesMap[defaultEdge] || edgesMap[key2 + '_' + key1];\n                if (!edge) {\n                    // If this edge hasn't been added before, add it now\n                    edge = edgesMap[defaultEdge] = { triangles: [] };\n                }\n\n                // Add edge to current triangle\n                triangle.edges.push(edge);\n                // Add current triangle to edge\n                edge.triangles.push(i / 3);\n            }\n\n            trianglesArr.push(triangle);\n        }\n\n        if (firstTriangle < 0) {\n            return null;\n        }\n\n        // BFS search for neighbouring triangles\n        const queue = [firstTriangle];\n        const visited = new Set();\n        const connectedFaces = [];\n\n        while (queue.length > 0) {\n            const currentFace = queue.shift();\n\n            if (visited.has(currentFace)) {\n                continue;\n            }\n\n            visited.add(currentFace);\n\n            // Add this face to the list of connected faces\n            connectedFaces.push(currentFace);\n\n            // Add all neighboring faces to the queue\n            const triangle = trianglesArr[currentFace];\n            for (const edge of triangle.edges) {\n                edge.triangles.forEach(t => t !== currentFace && queue.push(t));\n            }\n        }\n\n        // Copy results of the actual vertices in the connected faces\n        // Since vertices are already cloned in faceSnapping, there's no need to clone them again\n        const finalVertices = [];\n        let vIndex = 0;\n        connectedFaces.forEach(faceIdx => {\n            intersectFace.faces.push(new THREE.Face3(vIndex++, vIndex++, vIndex++));\n            finalVertices.push(vertices[faceIdx * 3]);\n            finalVertices.push(vertices[faceIdx * 3 + 1]);\n            finalVertices.push(vertices[faceIdx * 3 + 2]);\n        });\n\n        intersectFace.vertices = finalVertices;\n\n        return intersectFace;\n    };\n\n    this.edgeSnappingWithTopology = function(intersectPoint, geometry, edgesTopology, {matrixWorld}) {\n\n        const edgeGeom = new THREE.Geometry(); //Geometry which includes all the triangles on the same plane.\n        var minDistTopoIndex;\n        var minDist = Number.MAX_VALUE;\n\n        var vA = new THREE.Vector3();\n        var vB = new THREE.Vector3();\n\n        if (geometry.index !== undefined && edgesTopology != undefined) {\n\n            const readVertex = this.makeReadVertexFunc(geometry);\n            // Find the index of edge topology list which includes the nearest edge segment to the intersect point\n            for (var i = 0; i < edgesTopology.length; i++) {\n\n                var indexList = edgesTopology[i].indexList;\n                // In edges topology index list the type is LineStrip\n                for (var j = 0; j < indexList.length - 1; j++) {\n                    readVertex(indexList[j], vA);\n                    readVertex(indexList[j + 1], vB);\n\n                    vA.applyMatrix4(matrixWorld);\n                    vB.applyMatrix4(matrixWorld);\n\n                    var dist = distancePointToLine(intersectPoint, vA, vB);\n                    if (dist < minDist) {\n                        minDist = dist;\n                        minDistTopoIndex = i;\n                    }\n                }\n            }\n\n            if (minDistTopoIndex) {\n                indexList = edgesTopology[minDistTopoIndex].indexList;\n                for (var k = 0; k < indexList.length - 1; k++) {\n                    const vK0 = readVertex(indexList[k]);\n                    const vK1 = readVertex(indexList[k + 1]);\n\n                    edgeGeom.vertices.push(vK0);\n                    // To make the line's type to LinePieces which is used by drawLine function\n                    edgeGeom.vertices.push(vK1);\n                }\n            }\n        }\n\n        if (_distanceToEdge >= minDist && edgeGeom.vertices.length > 0) {\n\n            _distanceToEdge = minDist;\n            edgeGeom.applyMatrix4(matrixWorld);\n            _snapResult.geomEdge = edgeGeom;\n        }\n    };\n\n    /**\n     * Get Edge geometry for the case that the hittest result contained a 3D lines. For this case, we have no Face3, so\n     * that faceSnapping and edgeSnapping don't work.\n     *\n     *  @param {Object}         edge     - {a, b} with vertex indices a,b of lineStart/lineEnd vertex\n     *  @param {GeometryBuffer} geometry\n     *  @returns {THREE.Geometry|THREE.BufferGeometry} Geometry with simple line\n     */\n    this.extractLineGeometry = function(edge, geometry) {\n\n        const readVertex = this.makeReadVertexFunc(geometry);\n        const va = readVertex(edge.a);\n        const vb = readVertex(edge.b);\n\n        const edgeGeom = new THREE.Geometry();\n        edgeGeom.vertices.push(va, vb);\n        return edgeGeom;\n    };\n\n    /**\n     * Find the closest edge next to the intersect point\n     *\n     * @param face -Face which is found by faceSnapping.\n     * @param intersectPoint -IntersectPoint between cast ray and face.\n     *\n     * @private\n     */\n    this.edgeSnapping = function(face, intersectPoint) {\n\n        const vertices = [];\n        const verticesLength = face.vertices.length;\n        var isEdge_12 = true;\n        var isEdge_13 = true;\n        var isEdge_23 = true;\n\n        for (var i = 0; i < verticesLength; i += 3) {\n            const pi0 = face.vertices[i];\n            const pi1 = face.vertices[i + 1];\n            const pi2 = face.vertices[i + 2];\n\n            for (var j = 0; j < verticesLength; j += 3) {\n                if ( i !== j ) {\n                    const pj0 = face.vertices[j];\n                    const pj1 = face.vertices[j + 1];\n                    const pj2 = face.vertices[j + 2];\n                    // Check edge 12\n                    if ((pi0.equals(pj0) || pi0.equals(pj1) || pi0.equals(pj2))\n                        && (pi1.equals(pj0) || pi1.equals(pj1) || pi1.equals(pj2))) {\n                        isEdge_12 = false;\n                    }\n                    // Check edge 13\n                    // Check edge 12\n                    if ((pi0.equals(pj0) || pi0.equals(pj1) || pi0.equals(pj2))\n                        && (pi2.equals(pj0) || pi2.equals(pj1) || pi2.equals(pj2))) {\n                        isEdge_13 = false;\n                    }\n                    // Check edge 23\n                    // Check edge 12\n                    if ((pi1.equals(pj0) || pi1.equals(pj1) || pi1.equals(pj2))\n                        && (pi2.equals(pj0) || pi2.equals(pj1) || pi2.equals(pj2))) {\n                        isEdge_23 = false;\n                    }\n                }\n            }\n\n            if (isEdge_12) {\n                vertices.push(pi0.clone());\n                vertices.push(pi1.clone());\n            }\n            if (isEdge_13) {\n                vertices.push(pi0.clone());\n                vertices.push(pi2.clone());\n            }\n            if (isEdge_23) {\n                vertices.push(pi1.clone());\n                vertices.push(pi2.clone());\n            }\n\n            isEdge_12 = true;\n            isEdge_13 = true;\n            isEdge_23 = true;\n\n        }\n\n        //return lineGeom;\n\n        const edgeVertices = [];\n        const edgeGeom = new THREE.Geometry();\n        var minDistIndex;\n        var minDist = Number.MAX_VALUE;\n\n        for (var k = 0; k < vertices.length; k += 2) {\n\n            var dist = distancePointToLine(intersectPoint, vertices[k], vertices[k + 1]);\n\n            if (dist < minDist) {\n                minDist = dist;\n                minDistIndex = k;\n            }\n\n        }\n\n        edgeVertices.push(vertices[ minDistIndex ].clone());\n        edgeVertices.push(vertices[ minDistIndex + 1 ].clone());\n\n        const lineGeom = new THREE.Geometry();\n        lineGeom.vertices = vertices;\n        edgeGeom.vertices = this.getConnectedLineSegmentsOnSameLine(lineGeom, edgeVertices);\n\n        _distanceToEdge = minDist;\n\n        return edgeGeom;\n    };\n\n    this.getConnectedLineSegmentsOnSameLine = function(lineGeom, edgeVertices) {\n\n        const vertices = lineGeom.vertices.slice();\n        var va = edgeVertices[0];\n        var vb = edgeVertices[1];\n\n        var vCount = [];\n\n        do {\n\n            vCount = [];\n\n            for (var j = 0; j < vertices.length; j += 2) {\n\n                // The line which has min distance to intersection point\n                if (vertices[j].equals(va) && vertices[j + 1].equals(vb)) {\n\n                    continue;\n                }\n\n                for (var k = 0; k < edgeVertices.length; k += 2) {\n\n                    // The line segments which are connected on the same line\n                    if (vertices[j].equals(edgeVertices[k]) || vertices[j + 1].equals(edgeVertices[k]) ||\n                        vertices[j].equals(edgeVertices[k + 1]) || vertices[j + 1].equals(edgeVertices[k + 1])) {\n\n                        var V0 = new THREE.Vector3();\n                        var V1 = new THREE.Vector3();\n\n                        V0.subVectors(edgeVertices[k],  edgeVertices[k + 1]);\n                        V0.normalize();\n                        V1.subVectors(vertices[j],vertices[j + 1]);\n                        V1.normalize();\n\n                        //if (V0.equals(V1) || V0.equals(V1.negate())) {\n                        if (isEqualVectorsWithPrecision(V0, V1) || isInverseVectorsWithPrecision(V0, V1))\n                        {\n\n                            vCount.push(j);\n                            break;\n\n                        }\n                    }\n                }\n            }\n\n            for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n                edgeVertices.push(vertices[ vCount[ci] ]);\n                edgeVertices.push(vertices[ vCount[ci] + 1 ]);\n                vertices.splice(vCount[ci], 2);\n            }\n\n        } while (vCount.length > 0);\n\n        return edgeVertices;\n\n    };\n\n    this.vertexSnappingWithTopology = function(edge, intersectPoint) {\n\n        var minDist = Number.MAX_VALUE;\n        var point = new THREE.Vector3();\n        if (!edge) {\n            return point;\n        }\n\n        if (edge.vertices.length > 1) {\n            const start = edge.vertices[0];\n            const end = edge.vertices[edge.vertices.length - 1];\n            var dist1 = intersectPoint.distanceTo(start);\n            var dist2 = intersectPoint.distanceTo(end);\n\n            if (dist1 <= dist2) {\n                minDist = dist1;\n                point = start.clone();\n            }\n            else {\n                minDist = dist2;\n                point = end.clone();\n            }\n        }\n\n        _distanceToVertex = minDist;\n\n        return point;\n    };\n\n    /**\n     * Find the closest vertex next to the intersect point\n     *\n     * @param edge -Edge which is found by edgeSnapping.\n     * @param intersectPoint -IntersectPoint between cast ray and face.\n     *\n     * @private\n     */\n    this.vertexSnapping = function(edge, intersectPoint) {\n\n        var minDist = Number.MAX_VALUE;\n        var point = new THREE.Vector3();\n        const verticesLength = edge.vertices.length;\n\n        for (let i = 0; i < verticesLength; ++i) {\n            const pt = edge.vertices[i];\n            const dist = intersectPoint.distanceTo(pt);\n\n            if (dist < minDist - SNAP_PRECISION) {\n\n                minDist = dist;\n                point = pt.clone();\n\n            }\n        }\n\n        _distanceToVertex = minDist;\n\n        return point;\n    };\n\n    // This is only a workaround to detect if an edge is circle\n    this.edgeIsCircle = function(edge) {\n\n        const vertices = edge.vertices;\n\n        // Exclude squares and regular polygons\n        if (vertices.length < 8) {\n            return false;\n        }\n\n        const start = vertices[0];\n        const end = vertices[vertices.length - 1];\n\n        if (start.equals(end)) {\n\n            var center = new THREE.Vector3(0, 0, 0);\n            for (let i = 0; i < vertices.length; i += 2) {\n                center.add(vertices[i]);\n            }\n            center.divideScalar(vertices.length / 2.0);\n\n            var radius = center.distanceTo(start);\n            for (let i = 0; i < vertices.length; i += 2) {\n                if (Math.abs(center.distanceTo(vertices[i]) - radius) <= SNAP_PRECISION) {\n                    continue;\n                }\n                else {\n                    return false;\n                }\n            }\n            return center;\n        }\n        else {\n            return false;\n        }\n    };\n\n    this.edgeIsCurved = function (edge) {\n\n        const vertices = edge.vertices;\n        const start = vertices[0];\n        const end = vertices[vertices.length - 1];\n\n        if (vertices.length <= 2) {\n            return false;\n        }\n        else if (start.equals(end)) {\n            return true;\n        }\n        else {\n            var V1 = new THREE.Vector3();\n            let pi0;\n            let pi1 = vertices[1];\n\n            V1.subVectors(start, pi1);\n\n            var V2 = new THREE.Vector3();\n            for (var i = 2; i < vertices.length; i += 2) {\n                pi0 = vertices[i];\n                pi1 = vertices[i + i];\n                V2.subVectors(pi0, pi1);\n                if (!isEqualVectorsWithPrecision(V1, V2)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    };\n\n    /**\n     * Checks if the given geometry is curved\n     * @param {THREE.BufferGeometry} face The geometry\n     * @returns {boolean} True if the any of the faces composing the geometry is curved\n     */\n    this.faceIsCurved = function (face) {\n\n        const vertices = face.vertices;\n        const faces = face.faces;\n\n        if (faces.length <= 1) { return false; }\n\n        var fN1 = new THREE.Vector3();\n        const vA1 = vertices[faces[0].a];\n        THREE.Triangle.getNormal(vertices[faces[0].a], vertices[faces[0].b], vertices[faces[0].c], fN1);\n\n        var fN2 = new THREE.Vector3();\n        for (let i = 1; i < faces.length; i++) {\n            const vA2 = vertices[faces[i].a];\n            THREE.Triangle.getNormal(vertices[faces[i].a], vertices[faces[i].b], vertices[faces[i].c], fN2);\n            if (!isEqualVectorsWithPrecision(fN1, fN2) || !isEqualWithPrecision(fN1.dot(vA1), fN2.dot(vA2))) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    this.angleVector2 = function(vector) {\n\n        if (vector.x > 0 && vector.y >= 0) {\n            return Math.atan(vector.y / vector.x);\n        }\n        else if (vector.x >= 0 && vector.y < 0) {\n            return Math.atan(vector.y / vector.x) + Math.PI * 2;\n        }\n        else if (vector.x < 0 && vector.y <= 0) {\n            return Math.atan(vector.y / vector.x) + Math.PI;\n        }\n        else if (vector.x <= 0 && vector.y > 0) {\n            return Math.atan(vector.y / vector.x) + Math.PI;\n        }\n        else{ // x = 0, y = 0\n            return null;\n        }\n    };\n\n    // Creates a THREE.Geometry that represents an approximation of a given elliptical arc in {z=0} plane.\n    // Points are obtained by by uniform sampling of a given elliptical arc.\n    //  @param {number} numPoints - The length number of points that the output geometry will contain. segments in which we subdivide the arc. Resulting point count is numSegments+1.\n    // See getEllipseArcPoint() for param details.\n    const createEllipticalArcGeometry = (cx, cy, rx, ry, startAngle, endAngle, numPoints) => {\n        let geometry = new THREE.Geometry();\n        for (let i=0; i<numPoints; i++) {\n            const p = new THREE.Vector3(0,0,0);\n            const t = i/(numPoints-1);\n            Autodesk.Extensions.CompGeom.getEllipseArcPoint(t, cx, cy, rx, ry, startAngle, endAngle, 0.0, p);\n            geometry.vertices.push(p);\n        }\n        return geometry;\n    };\n\n    /**\n     * @param {Viewer3D} viewer - Viewer instance\n     * @param snapper\n     * @param aDetectRadius\n     * @private\n     */\n    function GeometryCallback(viewer, snapper, aDetectRadius) {\n        this.viewer = viewer;\n        this.snapper = snapper;\n\n        this.lineGeom = new THREE.Geometry();\n        this.circularArc = null;\n        this.circularArcCenter;\n        this.circularArcRadius;\n        this.ellipticalArc = null;\n        this.ellipticalArcCenter;\n\n        this.minDist = Number.MAX_VALUE;\n\n        this.matrix = new THREE.Matrix4();\n\n        this.vpIdLine = null;\n        this.vpIdCircular = null;\n        this.vpIdElliptical = null;\n\n        this.detectRadius = aDetectRadius;\n\n        // Collects candidate segments that we can snap to.\n        // This is used to allow snapping to segment intersections.\n        this.snapCandidates = []; // {SnappingCandidate[]}\n    }\n\n    GeometryCallback.prototype.onLineSegment = function(x1, y1, x2, y2, vpId) {\n        var intersectPoint = this.snapper.getIntersectPoint();\n        var v1 = new THREE.Vector3(x1, y1, intersectPoint.z);\n        var v2 = new THREE.Vector3(x2, y2, intersectPoint.z);\n\n        // LMV-5515: Apply the supplied matrix to the line vector's\n        if (this.matrix) {\n            v1.applyMatrix4(this.matrix);\n            v2.applyMatrix4(this.matrix);\n        }\n\n        // Skip segments outside detectRadius\n        var dist = distancePointToLine(intersectPoint, v1, v2);\n        if (dist > this.detectRadius) {\n            return;\n        }\n\n        // Collect snap candidate\n        this.snapCandidates.push(new SnapCandidate(vpId, dist).fromLine(v1, v2));\n\n        // Track minDist and lineGeometry for best hit so far\n        if (dist < this.minDist) {\n            this.lineGeom.vertices.splice(0, 2, v1, v2);\n            this.minDist = dist;\n\n            this.vpIdLine = vpId;\n        }\n    };\n\n    GeometryCallback.prototype.onCircularArc = function(cx, cy, start, end, radius, vpId) {\n        var intersectPoint = this.snapper.getIntersectPoint();\n        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n        var center = new THREE.Vector2(cx, cy);\n        point.sub(center);\n\n        // Compute closest point on arc\n        const pointOnArc = nearestPointOnCircularArc(intersectPoint, center, radius, start, end);\n        const dist       = pointOnArc.distanceTo(intersectPoint); // 2D distance\n\n        // Collect snap candidate\n        this.snapCandidates.push(new SnapCandidate(vpId, dist).fromCircularArc(center, radius, start, end));\n\n        // Skip arcs outside detectRadius\n        if (dist > this.detectRadius) {\n            return;\n        }\n\n        // TODO: get rid of the CircleGeometry stuff below, because we computed the snapPoint above already.\n        //       But this needs some refactoring, because the Geometry is passed around outside of snapper.\n\n        var angle = this.snapper.angleVector2(point);\n\n        let arc;\n        if (end > start && angle >= start && angle <= end) {\n            arc = new THREE.CircleGeometry(radius, 100, start, end - start);\n        }\n        else if (end < start && (angle >= start || angle <= end)) {\n            arc = new THREE.CircleGeometry(radius, 100, start, Math.PI * 2 - start + end);\n        }\n        else {\n            return;\n        }\n\n        arc.vertices.splice(0, 1);\n\n        arc.applyMatrix4(new THREE.Matrix4().makeTranslation(cx, cy, intersectPoint.z));\n        this.circularArc = arc;\n        this.circularArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n        this.circularArcRadius = radius;\n\n        this.snapPoint = new THREE.Vector3(pointOnArc.x, pointOnArc.y, intersectPoint.z);\n\n        this.vpIdCircular = vpId;\n    };\n\n    GeometryCallback.prototype.onEllipticalArc = function(cx, cy, start, end, major, minor, tilt, vpId) {\n        var intersectPoint = this.snapper.getIntersectPoint();\n        var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n        var major1 = major - this.detectRadius;\n        var minor1 = minor - this.detectRadius;\n        var major2 = major + this.detectRadius;\n        var minor2 = minor + this.detectRadius;\n\n        var equation1 = (point.x - cx) * (point.x - cx) / (major1 * major1) + (point.y - cy) * (point.y - cy) / (minor1 * minor1);\n        var equation2 = (point.x - cx) * (point.x - cx) / (major2 * major2) + (point.y - cy) * (point.y - cy) / (minor2 * minor2);\n\n        var center = new THREE.Vector2(cx, cy);\n        point.sub(center);\n        point.x *= minor;\n        point.y *= major;\n        var angle = this.snapper.angleVector2(point);\n\n        if (end > Math.PI * 2) {\n            end = Math.PI * 2;\n        }\n\n        if (equation1 >= 1 && equation2 <= 1) {\n\n            if ((end > start && angle >= start && angle <= end) || (end < start && (angle >= start || angle <= end))){\n                var arc = createEllipticalArcGeometry(cx, cy, major, minor, start, end, 50);\n                if (!isEqualWithPrecision(end - start, Math.PI * 2))\n                {\n                    arc.vertices.pop();\n                }\n                arc.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0, intersectPoint.z));\n\n                // Compute distance between geometry and snapped point.\n                // We use the same way here as in getSnapResultPosition(). This will be replaced later by a more accurate solution.\n                const nearestPoint = MeasureCommon.nearestVertexInVertexToEdge(intersectPoint, arc);\n                const dist = THREE.Vector2.prototype.distanceTo.call(nearestPoint, intersectPoint); // only in x/y\n\n                // Collect snap candidate\n                const center = new THREE.Vector2(cx, cy);\n                this.snapCandidates.push(new SnapCandidate(vpId, dist).makeEllipticalArc(center, major, minor, start, end));\n\n                // Todo: Unlike for line-segments, arcs are currently collected by \"last one wins\" rule by the code for single-snapping.\n                //       We should consider the distance here as well.\n                this.ellipticalArc = arc;\n                this.ellipticalArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n\n                this.vpIdElliptical = vpId;\n            }\n        }\n    };\n\n    /**\n     * This method sets the matrix to identity if matrix is not supplied;\n     *\n     * @param {THREE.Matrix4} matrix - Matrix to set\n     */\n    GeometryCallback.prototype.setMatrix = function (matrix) {\n        this.matrix = matrix || new THREE.Matrix4();\n    };\n\n    /**\n     * Snap to a 2D model.\n     *\n     * @param {object}      hitResult - a result of a ray intersection.\n     * @param {object}      [options] - Options object.\n     * @param {Function}    [options.enumSegments] - Enumerates all segments within a given bbox in model-space.\n     *\n     */\n    this.snapping2D = function (hitResult, options = {}) {\n\n        if (!hitResult) {\n            return;\n        }\n\n        // hitResult is a result of a ray intersection. it may contain the following:\n        let {\n            dbId,\n            fragId,\n            intersectPoint,\n            model = _viewer.model\n        } = hitResult;\n\n        if (model.is3d()) {\n            return;\n        }\n        _snapResult.modelId = hitResult.model ? hitResult.model.id : null;\n        _snapResult.hasTopology = false;\n        _snapResult.intersectPoint = intersectPoint;\n\n        let tr, scale = 1;\n\n        // The model that we are trying to snap is 2D, but the viewer is 3D. It means that we are in hypermodeling scenario!\n        // For that, we'll need to apply the inversed transform of the 2D model to the intersect point first, in order to get it in local model coords.\n        if (!_viewer.impl.is2d) {\n            tr = model.getModelToViewerTransform();\n            // If there's a transform, move point to original location in sheet (will be restored at the end)\n            if (tr) {\n                scale = tr.getMaxScaleOnAxis();\n                _snapResult.intersectPoint = intersectPoint.clone();\n                _snapResult.intersectPoint.applyMatrix4(model.getInverseModelToViewerTransform());\n            }\n        }\n\n        // Determine which one should be drawn: line, circular arc or elliptical arc\n        // Use the un-transformed point, but scale down the radius because we are comparing with the unscaled geometry\n        _snapResult.radius = this.setDetectRadius(intersectPoint) / scale;\n\n        // Geometry snapping is only possible if a fragment list is available to obtain geometry per fragment.\n        var supportsGeomSnapping = (model.getFragmentList()!=null);\n        if (!supportsGeomSnapping) {\n\n            // If no snapping is available, just accept the hitpoint as a vertex hit. This allows to measure\n            // distances between arbitrary points in rasters.\n            _isSnapped = true;\n            _snapResult.geomType = SnapType.SNAP_VERTEX;\n            _snapResult.geomVertex = intersectPoint; // Use the un-transformed point\n            tr &&_snapResult.intersectPoint.applyMatrix4(tr); // Restore to original location\n            return;\n        }\n\n\n        var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n        // Performs 2D snapping to segments based on an enumSegments() callback, which enumerates all segments\n        // within in a given bbox in model-space.\n        if (options.enumSegments) {\n            // enum all segments within the snapRadius around intersectPoint\n            const minx = _snapResult.intersectPoint.x - _snapResult.radius;\n            const miny = _snapResult.intersectPoint.y - _snapResult.radius;\n            const maxx = _snapResult.intersectPoint.x + _snapResult.radius;\n            const maxy = _snapResult.intersectPoint.y + _snapResult.radius;\n\n            options.enumSegments(minx, miny, maxx, maxy, gc);\n        } else {\n            // Regular snapping - snap to the 2D model's geometry.\n            var fragIds = fragId;\n\n            if (typeof fragIds === \"undefined\") {\n                // LMV-6082 Do not return out if the snap to pixel flag (free measure) is enabled.\n                if (!_snapToPixel) {\n                    return;\n                }\n                fragIds = [];\n            } else if (!Array.isArray(fragIds)) {\n                fragIds = [fragIds];\n            }\n\n            for (var fi = 0; fi < fragIds.length; ++fi) {\n                const mesh = _viewer.impl.getRenderProxy(model, fragIds[fi]);\n                if (mesh?.geometry) {\n                    gc.setMatrix(mesh.matrix);\n                    const vbr = new VertexBufferReader(mesh.geometry);\n                    vbr.enumGeomsForObject(model.reverseMapDbIdFor2D(dbId), gc);\n                    // Set the matrix back to identity after processing a mesh\n                    gc.setMatrix();\n                }\n            }\n        }\n\n        // _snapResult.intersectPoint contains the possibly transformed point\n        this.finishSnapping2D(gc, _snapResult.intersectPoint);\n\n        // Snap the unsnapped point only if the snapping fails\n        if(!_isSnapped && _snapToPixel) {\n            _isSnapped = true;\n            _snapResult.geomType = SnapType.RASTER_PIXEL;\n            _snapResult.geomVertex = _snapResult.intersectPoint;\n        }\n\n        // Now apply the transform matrix on the results, so we'll get the results in their final transformed position.\n        if (tr) {\n            const start = _snapResult.geomEdge?.vertices[0];\n            const end = _snapResult.geomEdge?.vertices[1];\n\n            let results = [_snapResult.snapPoint, _snapResult.geomVertex, _snapResult.intersectPoint, _snapResult.circularArcCenter,\n                start, end];\n            // Remove undefined and possibly shared vectors\n            results = [...new Set(results.filter(n => n))];\n            results.forEach(res => res.applyMatrix4(tr));\n            if (_snapResult.circularArcRadius) {\n                _snapResult.circularArcRadius *= scale;\n            }\n            _snapResult.radius *= scale;\n        }\n    };\n\n    // By default, snapper only considers model geometry that is written to ID buffer.\n    // This function performs the 2D snapping on a set of given 2D meshes instead. It works similar to snapping2D() but\n    // enumerates the given meshes instead of getting them from the fragment list.\n    //\n    //  @param {THREE.Vector3}                 intersectPoint - click position in world-coords\n    //  @param {function(dbId, layerId, vpId)} filter - Defines subset of primitives to be considered.\n    //  @param {THREE.Mesh[]}                  meshes - The triangulated 2D shapes to be checked for snapping\n    //  @param {number}                        [detectRadius] - Same coordinate system as the given geometry. Required if geometry is not in world-coords.\n\n    this.snapping2DOverlay = function(intersectPoint, meshes, filter, detectRadius) {\n        _snapResult.hasTopology = false;\n        _snapResult.intersectPoint = intersectPoint;\n        _snapResult.radius = detectRadius || this.setDetectRadius(intersectPoint);\n\n        var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n        for (var i=0; i<meshes.length; i++) {\n            var mesh = meshes[i];\n            var vbr = new VertexBufferReader(mesh.geometry);\n            vbr.enumGeoms(filter, gc);\n        }\n\n        this.finishSnapping2D(gc, intersectPoint);\n    };\n\n    // Finish 2D snapping operation - assuming that all candidate geometry for snapping has been processed by the geometryCallback gc already.\n    this.finishSnapping2D = function(gc, intersectPoint) {\n\n        // When restricting to a single viewport, exclude candidates of all other viewports\n        if (_forcedVpId !== null) {\n            const isSameViewport = c => (c.viewportId === _forcedVpId);\n            gc.snapCandidates = gc.snapCandidates.filter(isSameViewport);\n        }\n\n        // Check if we can snap to an intersection of two close segments\n        const intersectSnap = findIntersectionSnap(gc.snapCandidates, intersectPoint, gc.detectRadius);\n        if (intersectSnap) {\n            _snapResult.viewportIndex2d = intersectSnap.viewportId;\n            _snapResult.snapPoint = intersectSnap.snapPoint;\n            _snapResult.geomType = SnapType.SNAP_INTERSECTION;\n            _snapResult.geomVertex = intersectSnap.snapPoint;\n            _isSnapped = true;\n            return;\n        }\n\n        if (gc.circularArc) {\n\n            _snapResult.viewportIndex2d = gc.vpIdCircular;\n\n            _snapResult.snapPoint = gc.snapPoint;\n\n            // Only snap the geometries which belong to the same viewport as the first selection\n            if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n                return;\n\n            const start = gc.circularArc.vertices[0];\n            const end = gc.circularArc.vertices[gc.circularArc.vertices.length - 1];\n\n            if (intersectPoint.distanceTo(start) < _snapResult.radius) {\n\n                _snapResult.geomVertex = start;\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if (intersectPoint.distanceTo(end) < _snapResult.radius) {\n\n                _snapResult.geomVertex = end;\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else {\n\n                this.lineStripToPieces(gc.circularArc);\n                _snapResult.geomEdge = gc.circularArc;\n                _snapResult.circularArcCenter = gc.circularArcCenter;\n                _snapResult.circularArcRadius = gc.circularArcRadius;\n                _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n            }\n\n            _isSnapped = true;\n\n\n        }\n        else if (gc.ellipticalArc) {\n\n            _snapResult.viewportIndex2d = gc.vpIdElliptical;\n\n            // Only snap the geometries which belong to the same viewport as the first selection\n            if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n                return;\n\n            const start = gc.ellipticalArc.vertices[0];\n            const end = gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1];\n            if (intersectPoint.distanceTo(start) < _snapResult.radius) {\n\n                _snapResult.geomVertex = start;\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else if (intersectPoint.distanceTo(end) < _snapResult.radius) {\n\n                _snapResult.geomVertex = end;\n                _snapResult.geomType = SnapType.SNAP_VERTEX;\n            }\n            else {\n\n                this.lineStripToPieces(gc.ellipticalArc);\n                _snapResult.geomEdge = gc.ellipticalArc;\n                // Before we have measure design for elliptical arc, measure the center for now\n                _snapResult.circularArcCenter = gc.ellipticalArcCenter;\n                _snapResult.circularArcRadius = null;\n                _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n            }\n\n            _isSnapped = true;\n\n        }\n        else if ((gc.lineGeom instanceof THREE.Geometry && gc.lineGeom.vertices.length) ||\n            (gc.lineGeom.getAttribute && gc.lineGeom.getAttribute('position').count)) {\n\n            _snapResult.viewportIndex2d = gc.vpIdLine;\n\n            // Only snap the geometries which belong to the same viewport as the first selection\n            if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n                return;\n\n            // Always expose edge segment - no matter whether we snap to the edge or one of its vertices.\n            // This allows us to combine it with other snap constraints later - as done by Edit2D.\n            _snapResult.geomEdge = gc.lineGeom;\n            const start = gc.lineGeom.vertices[0];\n            const end = gc.lineGeom.vertices[1];\n\n            if (this.markupMode) {  // Markup mode\n                var mid = new THREE.Vector3();\n                mid.addVectors(start, end);\n                mid.divideScalar(2);\n                var md = intersectPoint.distanceTo(mid);\n                var sd = intersectPoint.distanceTo(start);\n                var ed = intersectPoint.distanceTo(end);\n\n                // Store it for snapping to parallel/perpendicular of underlying vectors\n                _snapResult.geomEdge = gc.lineGeom;\n\n                if (md < _snapResult.radius) {\n                    _snapResult.geomVertex = mid;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else if (sd < _snapResult.radius) {\n                    _snapResult.geomVertex = start;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else if (ed < _snapResult.radius) {\n                    _snapResult.geomVertex = end;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n\n                // Circle center\n                if (start.distanceTo(end) < EPSILON) {\n                    _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n                }\n            }\n            else {  // Measure mode\n                if (intersectPoint.distanceTo(start) < _snapResult.radius) {\n\n                    if (start.distanceTo(end) < EPSILON) {\n                        _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n                    } else {\n                        _snapResult.geomType = SnapType.SNAP_VERTEX;\n                    }\n\n                    _snapResult.geomVertex = start;\n                }\n                else if ((_options.forceSnapVertices || (intersectPoint.distanceTo(end) < _snapResult.radius))) {\n\n                    _snapResult.geomVertex = end;\n                    _snapResult.geomType = SnapType.SNAP_VERTEX;\n                }\n                else {\n                    _snapResult.geomType = SnapType.SNAP_EDGE;\n                }\n            }\n\n            _isSnapped = true;\n        }\n    };\n\n    this.snappingRasterPixel = function(result) {\n        if (!result) {\n            return;\n        }\n\n        var intersectPoint = result.intersectPoint;\n        _snapResult.intersectPoint = intersectPoint;\n        _snapResult.hasTopology = false;\n\n        // Determine which one should be drawn: line, circular arc or elliptical arc\n        _snapResult.radius = this.setDetectRadius(intersectPoint);\n        _snapResult.geomType = SnapType.RASTER_PIXEL;\n        _snapResult.geomVertex = intersectPoint;\n        _isSnapped = true;\n    };\n\n    this.snapMidpoint = function() {\n        _snapResult.isMidpoint = false;\n\n        // Snap midpoint for edge\n        if (_isSnapped) {\n            if (_snapResult.geomType === SnapType.SNAP_EDGE) {\n                const edge = _snapResult.geomEdge;\n                const p1 = edge.vertices[0];\n                const p2 = edge.vertices[1];\n\n                var midpoint = new THREE.Vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);\n\n                var cutPlanes = _viewer.impl.getAllCutPlanes();\n                if (cutPlanes?.length) {\n                    for (let i = 0; i<cutPlanes.length; ++i) {\n                        const p = cutPlanes[i];\n                        const dot = midpoint.x*p.x + midpoint.y*p.y + midpoint.z*p.z + p.w;\n                        if (dot>1e-5) {\n                            // discard midpoint if clipped\n                            return;\n                        }\n                    }\n                }\n\n                if (_snapResult.intersectPoint.distanceTo(midpoint) < 2 * _snapResult.radius) {\n                    _snapResult.geomVertex = midpoint;\n                    _snapResult.geomType = SnapType.SNAP_MIDPOINT;\n                }\n            }\n        }\n    };\n\n    this.setPerpendicular = function(isPerpendicular) {\n        _snapResult.isPerpendicular = isPerpendicular;\n    };\n\n    this.lineStripToPieces = function(geom) {\n        const vertices = geom.vertices;\n        for (var i = vertices.length - 2; i > 0; i--) {\n            vertices.splice(i, 0, vertices[i]);\n        }\n    };\n\n    this.setDetectRadius = function(point) {\n\n        var navapi = _viewer.navigation;\n        var camera = navapi.getCamera();\n        var position = navapi.getPosition();\n\n        var p = point.clone();\n\n        var distance = camera.isPerspective ? p.sub(position).length()\n            : navapi.getEyeVector().length();\n\n        var fov = navapi.getVerticalFov();\n        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n        var viewport = navapi.getScreenViewport();\n        var _window = this.getWindow();\n        var devicePixelRatio = _window.devicePixelRatio || 1;\n        var radius = this.detectRadiusInPixels * worldHeight / (viewport.height * devicePixelRatio);\n\n        return radius;\n    };\n\n    this.handleButtonDown = function () {\n        _isDragging = true;\n        return false;\n    };\n\n    this.handleButtonUp = function () {\n        _isDragging = false;\n        return false;\n    };\n\n    this.handleMouseMove = function (event) {\n\n        if (_isDragging)\n            return false;\n\n        this.onMouseMove({\n            x: event.canvasX,\n            y: event.canvasY\n        });\n\n        return false;\n    };\n\n    this.handleSingleTap = function(event) {\n\n        return this.handleMouseMove(event);\n    };\n\n    this.handlePressHold = function (event) {\n\n        if (av.isMobileDevice()) {\n            switch( event.type )\n            {\n                case \"press\":\n                    _isPressing = true;\n                    this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                    break;\n\n                case \"pressup\":\n                    this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                    _isPressing = false;\n                    break;\n            }\n        }\n        return false;\n\n    };\n\n    this.handleGesture = function( event )\n    {\n        if (av.isMobileDevice()) {\n            if (_isPressing) {\n                switch( event.type )\n                {\n                    case \"dragstart\":\n                    case \"dragmove\":\n                        this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                        break;\n\n                    case \"dragend\":\n                        this.onMouseMove({x: event.canvasX, y: event.canvasY});\n                        _isPressing = false;\n                        break;\n\n                    case \"pinchstart\":\n                    case \"pinchmove\":\n                    case \"pinchend\":\n                        break;\n                }\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * Handler to mouse move events, used to snap in markup edit mode.\n     *\n     * @param mousePosition\n     * @private\n     */\n    this.onMouseDown = function(mousePosition) {\n        return this.onMouseMove(mousePosition);\n    };\n\n    /**\n     * Handler to mouse move events, used to snap in markup edit mode.\n     *\n     * @param mousePosition\n     * @private\n     */\n    this.onMouseMove = function(mousePosition) {\n\n        this.clearSnapped();\n\n        var result = _viewer.impl.snappingHitTest(mousePosition.x, mousePosition.y, false);\n\n        if (!result && _snapToPixel) {\n            var vpVec = _viewer.impl.clientToViewport(mousePosition.x, mousePosition.y);\n            let point = _viewer.impl.intersectGroundViewport(vpVec);\n            result = { intersectPoint : point };\n        }\n\n        if (!result || !result.intersectPoint)\n            return false;\n\n        const isLeaflet = result.model?.isLeaflet() || (_viewer.impl.is2d && _viewer.model?.isLeaflet());\n        // 3D Snapping\n        if (result.face) {\n            this.snapping3D(result);\n        }\n        // 2D Snapping\n        else if ((result.dbId || result.dbId === 0) && !isLeaflet) {\n            this.snapping2D(result);\n        }\n        // Pixel Snapping\n        else {\n            const isPixelSnap = _snapToPixel || isLeaflet;\n            if (isPixelSnap) {\n                this.snappingRasterPixel(result);\n            }\n        }\n\n        this.snapMidpoint();\n\n        if (_snapFilter && !_snapFilter(_snapResult)) {\n            this.clearSnapped();\n            return false;\n        }\n\n        return true;\n    };\n}\n\nav.GlobalManagerMixin.call(Snapper.prototype);\n","const MeasureCommon = Autodesk.Viewing.MeasureCommon;\nconst isEqualVectors = MeasureCommon.isEqualVectors;\nconst EPSILON = MeasureCommon.EPSILON;\nconst SnapType = MeasureCommon.SnapType;\n\nconst NO_OVERLAY = 0;\nconst FACE_OVERLAY = 1;\nconst EDGE_OVERLAY = 2;\nconst POINT_OVERLAY = 3;\n\nconst GEOMETRIES_OVERLAY = 'MeasureTool-snapper-geometries';\nconst INDICATOR_OVERLAY = 'MeasureTool-snapper-indicator';\n\nconst _geometryLineWidth = 0.3;\nconst _indicatorLineWidth = 0.2;\nconst _indicatorSize = 1.2;\nconst _indicatorColor = 0xff7700;\nconst _geometryColor = 0x00CC00;\n\nlet _point = null;\n\nconst tmpVec3 = new THREE.Vector3();\n/**\n *\n * @param {BufferAttribute} positionAttribute\n * @param {number} idx\n * @returns {THREE.Vector3} Vector3 corresponding to the indicated index. The returned value will be overriden by\n * subsequent calls\n */\nexport function getXYZFromPos(positionAttribute, idx) {\n    tmpVec3.x = positionAttribute.getX(idx);\n    tmpVec3.y = positionAttribute.getY(idx);\n    tmpVec3.z = positionAttribute.getZ(idx);\n    return tmpVec3;\n}\n\nexport class NullSnapperIndicator {\n    isNull() {\n        return true;\n    }\n\n    render() {}\n    removeOverlay(overlayName) {}\n    clearOverlay(overlayName) {}\n    clearOverlays() {}\n    addOverlay(overlayName, mesh) {}\n    drawFace(geom, material, overlayName) {}\n    cylinderMesh(pointX, pointY, material, width) {\n        return new THREE.Mesh();\n    }\n    renderGeometry(snapResult) {}\n    renderVertexIndicator(snapResult) {}\n    renderMidpointIndicator(snapResult) {}\n    renderEdgeIndicator(snapResult) {}\n    renderCircleIndicator(snapResult) {}\n    renderPerpendicular(snapResult) {}\n    renderPixelIndicator(snapResult) {}\n    renderIndicator(snapResult) {}\n    drawLine(geom, material, width, overlayName) {}\n    drawPoint(point, material, overlayName) {}\n    drawCircle(point, material, overlayName) {}\n    setScale(point) {\n        return 1;\n    }\n    setPointScale(pointMesh) {}\n    setCircleScale(torusMesh) {}\n    setEdgeScale(cylinderMesh) {}\n    updatePointScale(overlayName) {}\n    updateEdgeScale(overlayName) {}\n    onCameraChange() {}\n    destroy() {}\n}\n\nexport class SnapperIndicator extends NullSnapperIndicator {\n    constructor(viewer, snapper) {\n        super();\n\n        this.viewer = viewer;\n        this.snapper = snapper;\n        this.overlayType = NO_OVERLAY;\n        this.previewsIntersectPoint = null;\n\n        this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n        this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n        this.geometryMaterial = new THREE.MeshPhongMaterial({\n            color: _geometryColor,\n            opacity: 0.5,\n            transparent: true,\n            depthTest: false,\n            depthWrite: false,\n            side: THREE.DoubleSide\n        });\n\n        this.indicatorMaterial = new THREE.MeshBasicMaterial({\n            color: _indicatorColor,\n            opacity: 1,\n            transparent: false,\n            depthTest: false,\n            depthWrite: false,\n            side: THREE.DoubleSide\n        });\n    }\n\n    isNull() {\n        return false;\n    }\n\n    render() {\n\n        const snapResult = this.snapper.getSnapResult();\n\n        if (!isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {\n            this.clearOverlay(GEOMETRIES_OVERLAY);\n        }\n\n        this.clearOverlay(INDICATOR_OVERLAY);\n\n        if (snapResult.isEmpty())\n            return;\n\n        if (this.snapper.renderSnappedGeometry ||\n            (snapResult.hasTopology && this.snapper.renderSnappedTopology)) {\n            this.renderGeometry(snapResult);\n        }\n        this.renderIndicator(snapResult);\n\n        this.previewsIntersectPoint = snapResult.intersectPoint.clone();\n    }\n\n    removeOverlay(overlayName) {\n\n        this.viewer.impl.clearOverlay(overlayName, true);\n        this.viewer.impl.removeOverlayScene(overlayName);\n\n    }\n\n    clearOverlay(overlayName) {\n\n        this.removeOverlay(overlayName);\n        this.viewer.impl.createOverlayScene(overlayName);\n\n    }\n\n    clearOverlays() {\n\n        this.removeOverlay(GEOMETRIES_OVERLAY);\n        this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n\n        this.removeOverlay(INDICATOR_OVERLAY);\n        this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n        this.previewsIntersectPoint = null;\n\n    }\n\n    addOverlay (overlayName, mesh) {\n\n        this.viewer.impl.addOverlay(overlayName, mesh);\n\n    }\n\n    /**\n     * Draw the planar face\n     * @param geom - Geometry which needs to be draw.\n     * @param material - Material for the geometry.\n     * @param overlayName - Name of the overlay.\n     */\n    drawFace(geom, material, overlayName) {\n\n        const snapperPlane = new THREE.Mesh(geom, material, true);\n\n        if (overlayName === GEOMETRIES_OVERLAY) {\n            this.overlayType = FACE_OVERLAY;\n        }\n\n        this.addOverlay(overlayName, snapperPlane);\n\n    }\n\n    cylinderMesh(pointX, pointY, material, width) {\n\n        const direction = new THREE.Vector3().subVectors(pointY, pointX);\n        const orientation = new THREE.Matrix4();\n        orientation.lookAt(pointX, pointY, new THREE.Object3D().up);\n        orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,\n            0, 0, 1, 0,\n            0, -direction.length(), 0, 0,\n            0, 0, 0, 1));\n\n        width = width || 0.5;\n        let cylinder = new THREE.CylinderGeometry(width, width, 1.0, 8, 1, true);\n        const edge = new THREE.Mesh(cylinder, material);\n        cylinder = null;\n\n        edge.applyMatrix4(orientation);\n        edge.position.x = (pointY.x + pointX.x) / 2;\n        edge.position.y = (pointY.y + pointX.y) / 2;\n        edge.position.z = (pointY.z + pointX.z) / 2;\n        return edge;\n    }\n\n    renderGeometry(snapResult) {\n\n        if (isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)){\n            return;\n        }\n\n        switch (snapResult.geomType) {\n            case SnapType.SNAP_VERTEX:\n                 SnapType.RASTER_PIXEL;\n                this.drawPoint(snapResult.geomVertex, this.geometryMaterial, GEOMETRIES_OVERLAY);\n                break;\n\n            case SnapType.SNAP_EDGE:\n            case SnapType.SNAP_CURVEDEDGE:\n            case SnapType.SNAP_CIRCULARARC:\n            case SnapType.SNAP_MIDPOINT:\n                this.drawLine(snapResult.geomEdge, this.geometryMaterial, _geometryLineWidth, GEOMETRIES_OVERLAY);\n                break;\n\n            case SnapType.SNAP_FACE:\n            case SnapType.SNAP_CURVEDFACE:\n                this.drawFace(snapResult.geomFace, this.geometryMaterial, GEOMETRIES_OVERLAY);\n                break;\n        }\n    }\n\n    /**\n     * Renders a square around the given snap result.\n     * Is used when youre snapping on a vertex, intersection, circular\n     * arc on a F2D sheet, and the curved face.\n     * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n     */\n    renderVertexIndicator(snapResult) {\n\n        const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        const scale = this.setScale(pos);\n        const length = _indicatorSize * scale;\n\n        const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        const geom = new THREE.BufferGeometry();\n\n        const vertices = [];\n        const p = new THREE.Vector3();\n\n        // Upper line\n        p.addVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        vertices[1] = p.clone();\n\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[1] = p.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        vertices[1] = p.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[0] = p.clone();\n        p.addVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        vertices[1] = p.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    }\n\n    /**\n     * Renders a triangle around the given snap result\n     * on a midpoint\n     * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n     */\n    renderMidpointIndicator(snapResult) {\n\n        const pos = snapResult.geomVertex;\n        const scale = this.setScale(pos);\n        const length = _indicatorSize * scale;\n\n        const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        const geom = new THREE.BufferGeometry();\n        const vertices = [];\n        const p = new THREE.Vector3();\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[1] = p.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[0] = p.clone();\n        p.addVectors(pos, upVec);\n        vertices[1] = p.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[0] = p.clone();\n        p.addVectors(pos, upVec);\n        vertices[1] = p.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    }\n\n    /**\n     * Renders an upside-down Y around the given snap result\n     * on an edge or a curved edge..\n     * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n     */\n    renderEdgeIndicator(snapResult) {\n\n        const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        const scale = this.setScale(pos);\n        const length = _indicatorSize * scale;\n\n        const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        const geom = new THREE.BufferGeometry();\n        const vertices = [];\n        const p = new THREE.Vector3();\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[0] = p.clone();\n        vertices[1] = pos.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[0] = p.clone();\n        vertices[1] = pos.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        p.addVectors(pos, upVec);\n        vertices[0] = p.clone();\n        vertices[1] = pos.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    }\n\n    /**\n     * Renders an circle on a center of a circle\n     * and circular arc for other than F2D sheets.\n     * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n     */\n    renderCircleIndicator(snapResult){\n\n        const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        this.drawCircle(pos, this.indicatorMaterial, INDICATOR_OVERLAY);\n\n    }\n\n    /**\n     * Renders an right-angle ( |_ ) indicator around the given snap result\n     * when the result is perpendicular.\n     * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n     */\n    renderPerpendicular(snapResult) {\n\n        const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        const scale = this.setScale(pos);\n        const length = _indicatorSize * scale;\n\n        const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        const geom = new THREE.BufferGeometry();\n        const vertices = [];\n        const p = new THREE.Vector3();\n\n        // Upper line\n        vertices[0] = pos.clone();\n        p.subVectors(pos, rightVec);\n        vertices[1] = p.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[1] = p.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[0] = p.clone();\n        p.subVectors(pos, rightVec);\n        p.addVectors(p, upVec);\n        vertices[1] = p.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Right line\n        vertices[0] = pos.clone();\n        p.subVectors(pos, upVec);\n        vertices[1] = p.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    }\n\n    /**\n     * Renders an X around the given snap result.\n     * Usually shown when using \"Free Measure\" mode is enabled.\n     * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n     */\n    renderPixelIndicator(snapResult) {\n\n        const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n        const scale = this.setScale(pos);\n        const length = _indicatorSize * scale;\n\n        const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n        const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n        const geom = new THREE.BufferGeometry();\n        const vertices = [];\n        const p = new THREE.Vector3();\n\n        // Top-left line\n        p.subVectors(pos, rightVec);\n        p.addVectors(p,upVec);\n        vertices[0] = p.clone();\n        vertices[1] = pos.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Top-right line\n        p.addVectors(pos, rightVec);\n        p.addVectors(p,upVec);\n        vertices[0] = p.clone();\n        vertices[1] = pos.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom-right line\n        p.addVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[0] = p.clone();\n        vertices[1] = pos.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n        // Bottom-left line\n        p.subVectors(pos, rightVec);\n        p.subVectors(p, upVec);\n        vertices[0] = p.clone();\n        vertices[1] = pos.clone();\n        geom.setFromPoints(vertices);\n        this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    }\n\n    renderIndicator(snapResult) {\n\n        if (snapResult.isPerpendicular) {\n            this.renderPerpendicular(snapResult);\n            return;\n        }\n\n        if(snapResult.snapToArc) {\n            if(snapResult.isArc && snapResult.geomType === SnapType.SNAP_CIRCULARARC && this.viewer.model.is2d() && !this.viewer.model.isPdf()) {\n                this.renderVertexIndicator(snapResult);\n            }\n            return;\n        }\n\n\n        switch (snapResult.geomType) {\n            case SnapType.SNAP_VERTEX:\n            case SnapType.SNAP_INTERSECTION:\n                this.renderVertexIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_MIDPOINT:\n                this.renderMidpointIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_CIRCLE_CENTER:\n                this.renderCircleIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_EDGE:\n            case SnapType.SNAP_CURVEDEDGE:\n                this.renderEdgeIndicator(snapResult);\n                break;\n\n            case SnapType.SNAP_CIRCULARARC:\n                if (this.viewer.model.is2d()) {\n                    this.renderVertexIndicator(snapResult);\n                } else {\n                    this.renderCircleIndicator(snapResult);\n                }\n                break;\n\n            case SnapType.SNAP_FACE:\n            case SnapType.SNAP_CURVEDFACE:\n                this.renderVertexIndicator(snapResult);\n                break;\n\n            case SnapType.RASTER_PIXEL:\n                this.renderPixelIndicator(snapResult);\n                break;\n        }\n    }\n\n    /**\n     * Draws a line in an overlyay\n     * @param {THREE.Geometry|THREE.BufferGeometry} geom\n     * @param {THREE.Material} material\n     * @param {number} width\n     * @param {string} overlayName\n     */\n    drawLine(geom, material, width, overlayName) {\n\n        // Line Pieces\n        if (overlayName === GEOMETRIES_OVERLAY) {\n            this.overlayType = EDGE_OVERLAY;\n        }\n\n        let verticesLength, geomPos;\n        if (geom instanceof THREE.Geometry) {\n            console.warn( 'SnapperIndicator.drawLine(geom, material, width, overlayName): THREE.Geometry has been depecrated and the geom argument should use a THREE.BufferGeometry instead' );\n            verticesLength = geom.vertices.length;\n        } else {\n            geomPos = geom.getAttribute('position');\n            verticesLength = geomPos.count;\n        }\n        for (let i = 0; i < verticesLength; i += 2) {\n            let cylinder;\n            if (geom instanceof THREE.Geometry) {\n                cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, width);\n            } else {\n                cylinder = this.cylinderMesh(getXYZFromPos(geomPos, i).clone(), getXYZFromPos(geomPos, i + 1).clone(), material, width);\n            }\n            this.setEdgeScale(cylinder);\n            this.addOverlay(overlayName, cylinder);\n        }\n    }\n\n    drawPoint(point, material, overlayName) {\n\n        // Because every point is snappable in PDFs, don't display the green dot for PDFs.\n        if (this.viewer.model.isLeaflet()) {\n            return;\n        }\n\n        if (!_point)\n            _point = new THREE.SphereGeometry(1.0);\n\n        const pointMesh = new THREE.Mesh(_point, material);\n        pointMesh.position.set(point.x, point.y, point.z);\n\n        this.setPointScale(pointMesh);\n\n        if (overlayName === GEOMETRIES_OVERLAY) {\n            this.overlayType = POINT_OVERLAY;\n        }\n\n        this.addOverlay(overlayName, pointMesh);\n\n    }\n\n    drawCircle(point, material, overlayName) {\n\n        let torus = new THREE.TorusGeometry(_indicatorSize, _indicatorLineWidth, 2, 20);\n        const torusMesh = new THREE.Mesh(torus, material);\n        torusMesh.lookAt(this.viewer.navigation.getEyeVector().normalize());\n        torus = null;\n\n        torusMesh.position.set(point.x, point.y, point.z);\n\n        this.setCircleScale(torusMesh);\n\n        this.addOverlay(overlayName, torusMesh);\n\n    }\n\n    setScale(point) {\n\n        const pixelSize = 5;\n\n        const navapi = this.viewer.navigation;\n        const camera = navapi.getCamera();\n        const position = navapi.getPosition();\n\n        const p = point.clone();\n\n        const distance = camera.isPerspective ? p.sub(position).length()\n            : navapi.getEyeVector().length();\n\n        const fov = navapi.getVerticalFov();\n        const worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n        const viewport = navapi.getScreenViewport();\n        const scale = pixelSize * worldHeight / viewport.height;\n\n        return scale;\n    }\n\n    setPointScale(pointMesh) {\n\n        const scale = this.setScale(pointMesh.position);\n        pointMesh.scale.x = scale;\n        pointMesh.scale.y = scale;\n        pointMesh.scale.z = scale;\n\n    }\n\n    setCircleScale(torusMesh) {\n\n        const scale = this.setScale(torusMesh.position);\n        torusMesh.scale.x = scale;\n        torusMesh.scale.y = scale;\n    }\n\n    setEdgeScale(cylinderMesh) {\n\n        const scale = this.setScale(cylinderMesh.position);\n        cylinderMesh.scale.x = scale;\n        cylinderMesh.scale.z = scale;\n    }\n\n    updatePointScale(overlayName) {\n\n        if (this.overlayType !== POINT_OVERLAY)\n            return;\n\n        const overlay = this.viewer.impl.overlayScenes[overlayName];\n        if (overlay) {\n            const scene = overlay.scene;\n\n            for (let i = 0; i < scene.children.length; i++) {\n                const pointMesh = scene.children[i];\n                if (pointMesh) {\n\n                    this.setPointScale(pointMesh);\n                }\n            }\n        }\n    }\n\n    updateEdgeScale(overlayName) {\n\n        if (this.overlayType !== EDGE_OVERLAY)\n            return;\n\n        const overlay = this.viewer.impl.overlayScenes[overlayName];\n        if (overlay) {\n            const scene = overlay.scene;\n\n            for (let i = 0; i < scene.children.length; i++) {\n                const cylinderMesh = scene.children[i];\n                if (cylinderMesh) {\n\n                    this.setEdgeScale(cylinderMesh);\n                }\n            }\n        }\n    }\n\n    onCameraChange() {\n\n        this.updatePointScale(GEOMETRIES_OVERLAY);\n        this.updateEdgeScale(GEOMETRIES_OVERLAY);\n\n        // if (!this.snapper.markupMode) {\n            this.render();\n        // }\n    }\n\n    destroy() {\n\n        this.removeOverlay(GEOMETRIES_OVERLAY);\n        this.removeOverlay(INDICATOR_OVERLAY);\n\n        if (_point) {\n            _point.dispose();\n            _point = null;\n        }\n    }\n}\n","\nvar av = Autodesk.Viewing;\n\n/**\n * @namespace Autodesk.Viewing.Extensions.Snapping\n */\nvar namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Snapping');\n\n/**\n * @param m\n * @param ns\n * @private\n */\nfunction _export(m, ns) {\n    for (var prop in m) {\n        if (Object.prototype.hasOwnProperty.call(m, prop)) {\n            //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)\n            module.exports[prop] = m[prop];\n\n            //Export into the desired viewer namespace\n            ns[prop] = m[prop];\n        }\n    }\n}\n\n_export(require(\"./SnapMath.js\"), namespace);\n_export(require(\"./Snapper.js\"), namespace);\n_export(require(\"./SnapperIndicator.js\"), namespace);\n\n\n/**\n * Utility extension that provides access to the {@link Autodesk.Viewing.Extensions.Snapping.Snapper} tool.\n *\n * The extension id is: `Autodesk.Snapping`\n *\n * @example\n *   viewer.loadExtension('Autodesk.Snapping')\n *\n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.SnappingExtension\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @class\n */\nclass SnappingExtension extends av.Extension {\n\n    /**\n     * @param {Viewer3D} viewer - Viewer instance\n     * @param {object} options - Configurations for the extension\n     * @alias Autodesk.Viewing.Extensions.SnappingExtension\n     * @class\n     */\n    constructor(viewer, options) {\n        super(viewer, options);\n    }\n\n    /**\n     * Load the extension.\n     *\n     * @returns {Promise} that resolves when dependent extension finishes loading.\n     *\n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#load\n     */\n    load() {\n        // Load the required dependency (and return the pending load as the load completion Promise)\n        return this.viewer.loadExtension('Autodesk.CompGeom');\n    }\n\n    /**\n     * Unloads the extension.\n     * It does not unload dependent extensions.\n     *\n     * @returns {boolean} Always returns true\n     *\n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#unload\n     */\n    unload() { return true; }\n\n\n    /**\n     * Unused method.\n     *\n     * @returns {boolean} Always returns true\n     *\n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#activate\n     */\n    activate() { return true; }\n\n    /**\n     * Unused method.\n     *\n     * @returns {boolean} Always returns false\n     *\n     * @alias Autodesk.Viewing.Extensions.SnappingExtension#deactivate\n     */\n    deactivate() { return false; }\n}\n\n// The ExtensionManager requires an extension to be registered.\nav.theExtensionManager.registerExtension('Autodesk.Snapping', SnappingExtension);\n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(2573);\n"],"names":["nearestPointOnCircularArc","p","center","radius","startAngle","endAngle","outPoint","dir","THREE","Vector2","copy","sub","normalize","angle","Math","atan2","y","x","Autodesk","Extensions","CompGeom","angleInsideArc","multiplyScalar","add","pStart","getEllipsePoint","pEnd","startIsCloser","distanceToSquared","intersectLines","p1","p2","p3","p4","checkInsideSegment","epsilon","arguments","length","undefined","denom","abs","ua","ub","MeasureCommon","Viewing","EPSILON","SnapType","SnapResult","SNAP_PRECISION","av","VertexBufferReader","Private","isEqualWithPrecision","a","b","isEqualVectorsWithPrecision","v1","v2","z","distancePointToLine","point","lineStart","lineEnd","equals","distanceTo","distance","param","X0","Vector3","X1","subVectors","dot","cross","sqrt","SnapCandidateType","Unknown","Line","CircularArc","EllipticalArc","SnapCandidate","constructor","viewportId","this","type","radiusX","radiusY","fromLine","clone","fromCircularArc","start","end","fromEllipticalArc","isLine","isCircularArc","CirularArc","isEllipticalArc","getIntersection","other","optionalTarget","findIntersectionSnap","candidates","intersectPoint","snapRadius","sort","byDistance","ca","cb","result","snapPoint","first","i","second","prototype","call","Snapper","viewer","options","_snapResult","_viewer","setGlobalManager","globalManager","_names","_options","markupMode","toolName","_active","_distanceToEdge","Number","MAX_VALUE","_distanceToVertex","_isDragging","_isPressing","_isSnapped","_forcedVpId","_snapToPixel","_snapFilter","indicator","SnapperIndicator","renderSnappedGeometry","renderSnappedTopology","detectRadiusInPixels","isMobileDevice","isActive","getNames","getName","getPriority","activate","isNull","deactivate","destroy","NullSnapperIndicator","copyResults","destiny","copyTo","getEdge","geomEdge","getVertex","geomVertex","getGeometry","getGeometryType","geomType","getIntersectPoint","getSnapResult","isSnapped","clearSnapped","clear","setViewportId","vpId","setSnapToPixel","enable","getSnapToPixel","setSnapToArc","snapToArc","getSnapToArc","setArc","isArc","getArc","setSnapFilter","filter","snapping3D","snapNode","dbId","modelId","model","id","face","fragId","fragIds","hasTopology","fi","topoIndex","getTopoIndex","getTopology","snapping3DwithTopology","snapping3DtoMesh","object","Mesh","meshSnapping","makeReadVertexFunc","geometry","attributes","positions","stride","poffset","vblayout","position","offset","vb","array","vbstride","idx","v","set","getData","instanceTree","enumNodeFragments","push","geomFace","_model$getFragmentLis","_model$getFragmentLis2","matrixWorld","Matrix4","getFragmentList","getWorldMatrix","topology","facesTopology","faces","edgesTopology","edges","faceSnappingWithTopology","normalMatrix","Matrix3","getNormalMatrix","faceNormal","normal","applyMatrix3","edgeSnappingWithTopology","vertexSnappingWithTopology","setDetectRadius","forceSnapVertices","SNAP_VERTEX","forceSnapEdges","edgeIsCircle","circularArcCenter","circularArcRadius","vertices","SNAP_CIRCULARARC","edgeIsCurved","SNAP_CURVEDEDGE","SNAP_EDGE","faceIsCurved","SNAP_CURVEDFACE","SNAP_FACE","_ref","isLines","isWideLines","extractLineGeometry","applyMatrix4","vertexSnapping","Face3","faceSnapping","edgeSnapping","_ref2","vA","vB","vC","geom","Geometry","index","indexList","faceId","j","c","readVertex","vIndex","indices","ib","offsets","groups","count","va","oi","Triangle","getNormal","getTrianglesOnSameFace","readVertexCB","faceVertex1","faceVertex2","faceVertex3","intersectFace","precision","pow","trianglesArr","edgesMap","firstTriangle","keys","round","triangle","key1","key2","defaultEdge","edge","triangles","queue","visited","Set","connectedFaces","currentFace","shift","has","forEach","t","finalVertices","faceIdx","_ref3","edgeGeom","minDistTopoIndex","minDist","dist","k","vK0","vK1","verticesLength","isEdge_12","isEdge_13","isEdge_23","pi0","pi1","pi2","pj0","pj1","pj2","edgeVertices","minDistIndex","lineGeom","getConnectedLineSegmentsOnSameLine","slice","vCount","V0","V1","ci","splice","dist1","dist2","pt","divideScalar","V2","fN1","vA1","fN2","vA2","angleVector2","vector","atan","PI","GeometryCallback","snapper","aDetectRadius","circularArc","ellipticalArc","ellipticalArcCenter","matrix","vpIdLine","vpIdCircular","vpIdElliptical","detectRadius","snapCandidates","onLineSegment","x1","y1","x2","y2","onCircularArc","cx","cy","pointOnArc","arc","CircleGeometry","makeTranslation","onEllipticalArc","major","minor","tilt","major1","minor1","major2","minor2","equation1","equation2","createEllipticalArcGeometry","rx","ry","numPoints","getEllipseArcPoint","pop","nearestPoint","nearestVertexInVertexToEdge","makeEllipticalArc","setMatrix","snapping2D","hitResult","is3d","tr","scale","impl","is2d","getModelToViewerTransform","getMaxScaleOnAxis","getInverseModelToViewerTransform","gc","enumSegments","minx","miny","maxx","maxy","Array","isArray","mesh","getRenderProxy","enumGeomsForObject","reverseMapDbIdFor2D","finishSnapping2D","RASTER_PIXEL","_snapResult$geomEdge","_snapResult$geomEdge2","results","n","res","snapping2DOverlay","meshes","enumGeoms","isSameViewport","intersectSnap","viewportIndex2d","SNAP_INTERSECTION","lineStripToPieces","getAttribute","mid","addVectors","md","sd","ed","SNAP_CIRCLE_CENTER","snappingRasterPixel","snapMidpoint","isMidpoint","midpoint","cutPlanes","getAllCutPlanes","w","SNAP_MIDPOINT","setPerpendicular","isPerpendicular","navapi","navigation","camera","getCamera","getPosition","isPerspective","getEyeVector","fov","getVerticalFov","worldHeight","tan","degToRad","viewport","getScreenViewport","devicePixelRatio","getWindow","height","handleButtonDown","handleButtonUp","handleMouseMove","event","onMouseMove","canvasX","canvasY","handleSingleTap","handlePressHold","handleGesture","onMouseDown","mousePosition","_result$model","_viewer$model","snappingHitTest","vpVec","clientToViewport","intersectGroundViewport","isLeaflet","GlobalManagerMixin","isEqualVectors","GEOMETRIES_OVERLAY","INDICATOR_OVERLAY","_indicatorLineWidth","_indicatorSize","_point","tmpVec3","getXYZFromPos","positionAttribute","getX","getY","getZ","render","removeOverlay","overlayName","clearOverlay","clearOverlays","addOverlay","drawFace","material","cylinderMesh","pointX","pointY","width","renderGeometry","snapResult","renderVertexIndicator","renderMidpointIndicator","renderEdgeIndicator","renderCircleIndicator","renderPerpendicular","renderPixelIndicator","renderIndicator","drawLine","drawPoint","drawCircle","setScale","setPointScale","pointMesh","setCircleScale","torusMesh","setEdgeScale","updatePointScale","updateEdgeScale","onCameraChange","super","overlayType","previewsIntersectPoint","createOverlayScene","geometryMaterial","MeshPhongMaterial","color","opacity","transparent","depthTest","depthWrite","side","DoubleSide","indicatorMaterial","MeshBasicMaterial","isEmpty","removeOverlayScene","snapperPlane","direction","orientation","lookAt","Object3D","up","multiply","cylinder","CylinderGeometry","pos","getSnapResultPosition","rightVec","getCameraRightVector","upVec","getCameraUpVector","BufferGeometry","setFromPoints","isPdf","geomPos","console","warn","SphereGeometry","torus","TorusGeometry","overlay","overlayScenes","scene","children","dispose","namespace","AutodeskNamespace","_export","m","ns","prop","Object","hasOwnProperty","module","exports","require","SnappingExtension","Extension","load","loadExtension","unload","theExtensionManager","registerExtension","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","key","o","defineProperty","enumerable","get","obj","r","Symbol","toStringTag","value","__webpack_exports__"],"sourceRoot":""}