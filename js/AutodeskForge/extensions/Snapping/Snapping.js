/*!
 * LMV v7.105.0
 *
 * Copyright 2025 Autodesk, Inc.
 * All rights reserved.
 *
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 *
 * Autodesk Viewer SDK Usage Limitations:
 *
 * The Autodesk Viewer SDK JavaScript must be delivered from an
 * Autodesk-hosted URL.
 */
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./extensions/Snapping/SnapMath.js":
/*!*****************************************!*\
  !*** ./extensions/Snapping/SnapMath.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectLines: () => (/* binding */ intersectLines),\n/* harmony export */   nearestPointOnCircularArc: () => (/* binding */ nearestPointOnCircularArc)\n/* harmony export */ });\n\n// Collection of static math functions used for snapping implementation\n\n// Find closest point to p on a circular arc.\n//  @param {Vector2} center\n//  @param {number} radius\n//  @param {number} startAngle, endAngle - ccw angles in radians. 0 means direction x+\n//  @param {Vector2} [outPoint]\n//  @param {Vector2}\nconst nearestPointOnCircularArc = (p, center, radius, startAngle, endAngle, outPoint) => {\n\n  outPoint = outPoint || new THREE.Vector2();\n\n  // get normalized direction from circle center to p.\n  // dir = (p-center).normalized()\n  const dir = outPoint.copy(p).sub(center).normalize();\n\n  // If the point is within the arc, we are done\n  const angle = Math.atan2(dir.y, dir.x);\n  const insideArc = Autodesk.Extensions.CompGeom.angleInsideArc(angle, startAngle, endAngle);\n  if (insideArc) {\n    // The ray from center towards p intersects the circle arc.\n    // So, we obtain the closest point by projecting p onto the circle.\n    //\n    // Since dir is the normalized direction from center to p, we obtain the circle projection by:\n    //  onCircleArc = center + dir * radius\n    return dir.multiplyScalar(radius).add(center);\n  }\n\n  // The closest point on the circle is not on the arc.\n  // Then the closest point must be one of the arc ends. Note that this conclusion\n  // can only be made for circles, but not for ellipses with different radii.\n  const pStart = Autodesk.Extensions.CompGeom.getEllipsePoint(startAngle, center.x, center.y, radius, radius);\n  const pEnd = Autodesk.Extensions.CompGeom.getEllipsePoint(endAngle, center.x, center.y, radius, radius);\n\n  const d2Start = pStart.distanceToSquared(p);\n  const d2End = pEnd.distanceToSquared(p);\n  const startIsCloser = d2Start <= d2End;\n\n  outPoint.copy(startIsCloser ? pStart : pEnd);\n  return outPoint;\n};\n\n// Compute intersection of two line segments\n// based on http://www.paulbourke.net/geometry/pointlineplane/\n//  @param {Vector2} p1, p2               - First line segment\n//  @param {Vector2} p3, p4               - Second line segment\n//  @param {bool}    [checkInsideSegment] - If true, we reject line intersections outside the segment ranges\n//  @param {Vector2} [outPoint]           - Optional target vector\n//  @param {number}  [epsilon]            - Nearly-zero threshold used to determine \"nearly-parallel\" resp. \"nearly-zero-length line\"\n//  @param {Vector2|null}\nconst intersectLines = function (p1, p2, p3, p4, checkInsideSegment, outPoint) {let epsilon = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.00001;\n\n  const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n\n  // Reject if lines are parallel or one of them has zero-length\n  if (Math.abs(denom) < epsilon) {\n    return null;\n  }\n\n  // ua denotes where to find the intersection point p along segment (p1, p2):\n  //   For ua = 0, we have p = p1\n  //   For ua = 1, we have p = p2\n  let ua = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x);\n  ua /= denom;\n\n  // Apply segment check\n  if (checkInsideSegment) {\n\n    // ub denotes where to find the intersection point p along segment (p3, p4)\n    let ub = (p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x);\n    ub /= denom;\n\n    // Intersection is within the segments if ua and ub are both in [0,1]\n    if (ua < 0.0 || ua > 1.0 ||\n    ub < 0.0 || ub > 1.0) {\n      return null;\n    }\n  }\n\n  outPoint = outPoint || new THREE.Vector2();\n\n  outPoint.x = p1.x + ua * (p2.x - p1.x);\n  outPoint.y = p1.y + ua * (p2.y - p1.y);\n  return outPoint;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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NEIsRUFBRSxJQUFJVixFQUFFLENBQUNsQixDQUFDLEdBQUdpQixFQUFFLENBQUNqQixDQUFDLENBQUM7RUFDdEMsT0FBT1YsUUFBUTtBQUNuQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQXV0b2Rlc2suRXh0ZW5zaW9ucy8uL2V4dGVuc2lvbnMvU25hcHBpbmcvU25hcE1hdGguanM/YmFkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIENvbGxlY3Rpb24gb2Ygc3RhdGljIG1hdGggZnVuY3Rpb25zIHVzZWQgZm9yIHNuYXBwaW5nIGltcGxlbWVudGF0aW9uXG5cbi8vIEZpbmQgY2xvc2VzdCBwb2ludCB0byBwIG9uIGEgY2lyY3VsYXIgYXJjLlxuLy8gIEBwYXJhbSB7VmVjdG9yMn0gY2VudGVyXG4vLyAgQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuLy8gIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlLCBlbmRBbmdsZSAtIGNjdyBhbmdsZXMgaW4gcmFkaWFucy4gMCBtZWFucyBkaXJlY3Rpb24geCtcbi8vICBAcGFyYW0ge1ZlY3RvcjJ9IFtvdXRQb2ludF1cbi8vICBAcGFyYW0ge1ZlY3RvcjJ9XG5leHBvcnQgY29uc3QgbmVhcmVzdFBvaW50T25DaXJjdWxhckFyYyA9IChwLCBjZW50ZXIsIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIG91dFBvaW50KSA9PiB7XG5cbiAgICBvdXRQb2ludCA9IG91dFBvaW50IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAvLyBnZXQgbm9ybWFsaXplZCBkaXJlY3Rpb24gZnJvbSBjaXJjbGUgY2VudGVyIHRvIHAuXG4gICAgLy8gZGlyID0gKHAtY2VudGVyKS5ub3JtYWxpemVkKClcbiAgICBjb25zdCBkaXIgPSBvdXRQb2ludC5jb3B5KHApLnN1YihjZW50ZXIpLm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gSWYgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgYXJjLCB3ZSBhcmUgZG9uZVxuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXIueSwgZGlyLngpO1xuICAgIGNvbnN0IGluc2lkZUFyYyA9IEF1dG9kZXNrLkV4dGVuc2lvbnMuQ29tcEdlb20uYW5nbGVJbnNpZGVBcmMoYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBpZiAoaW5zaWRlQXJjKSB7XG4gICAgICAgIC8vIFRoZSByYXkgZnJvbSBjZW50ZXIgdG93YXJkcyBwIGludGVyc2VjdHMgdGhlIGNpcmNsZSBhcmMuXG4gICAgICAgIC8vIFNvLCB3ZSBvYnRhaW4gdGhlIGNsb3Nlc3QgcG9pbnQgYnkgcHJvamVjdGluZyBwIG9udG8gdGhlIGNpcmNsZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2luY2UgZGlyIGlzIHRoZSBub3JtYWxpemVkIGRpcmVjdGlvbiBmcm9tIGNlbnRlciB0byBwLCB3ZSBvYnRhaW4gdGhlIGNpcmNsZSBwcm9qZWN0aW9uIGJ5OlxuICAgICAgICAvLyAgb25DaXJjbGVBcmMgPSBjZW50ZXIgKyBkaXIgKiByYWRpdXNcbiAgICAgICAgcmV0dXJuIGRpci5tdWx0aXBseVNjYWxhcihyYWRpdXMpLmFkZChjZW50ZXIpO1xuICAgIH1cblxuICAgIC8vIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBjaXJjbGUgaXMgbm90IG9uIHRoZSBhcmMuXG4gICAgLy8gVGhlbiB0aGUgY2xvc2VzdCBwb2ludCBtdXN0IGJlIG9uZSBvZiB0aGUgYXJjIGVuZHMuIE5vdGUgdGhhdCB0aGlzIGNvbmNsdXNpb25cbiAgICAvLyBjYW4gb25seSBiZSBtYWRlIGZvciBjaXJjbGVzLCBidXQgbm90IGZvciBlbGxpcHNlcyB3aXRoIGRpZmZlcmVudCByYWRpaS5cbiAgICBjb25zdCBwU3RhcnQgPSBBdXRvZGVzay5FeHRlbnNpb25zLkNvbXBHZW9tLmdldEVsbGlwc2VQb2ludChzdGFydEFuZ2xlLCBjZW50ZXIueCwgY2VudGVyLnksIHJhZGl1cywgcmFkaXVzKTtcbiAgICBjb25zdCBwRW5kICAgPSBBdXRvZGVzay5FeHRlbnNpb25zLkNvbXBHZW9tLmdldEVsbGlwc2VQb2ludChlbmRBbmdsZSwgY2VudGVyLngsIGNlbnRlci55LCByYWRpdXMsIHJhZGl1cyk7XG5cbiAgICBjb25zdCBkMlN0YXJ0ID0gcFN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKHApO1xuICAgIGNvbnN0IGQyRW5kICAgPSBwRW5kLmRpc3RhbmNlVG9TcXVhcmVkKHApO1xuICAgIGNvbnN0IHN0YXJ0SXNDbG9zZXIgPSBkMlN0YXJ0IDw9IGQyRW5kO1xuXG4gICAgb3V0UG9pbnQuY29weShzdGFydElzQ2xvc2VyID8gcFN0YXJ0IDogcEVuZCk7XG4gICAgcmV0dXJuIG91dFBvaW50O1xufTtcblxuLy8gQ29tcHV0ZSBpbnRlcnNlY3Rpb24gb2YgdHdvIGxpbmUgc2VnbWVudHNcbi8vIGJhc2VkIG9uIGh0dHA6Ly93d3cucGF1bGJvdXJrZS5uZXQvZ2VvbWV0cnkvcG9pbnRsaW5lcGxhbmUvXG4vLyAgQHBhcmFtIHtWZWN0b3IyfSBwMSwgcDIgICAgICAgICAgICAgICAtIEZpcnN0IGxpbmUgc2VnbWVudFxuLy8gIEBwYXJhbSB7VmVjdG9yMn0gcDMsIHA0ICAgICAgICAgICAgICAgLSBTZWNvbmQgbGluZSBzZWdtZW50XG4vLyAgQHBhcmFtIHtib29sfSAgICBbY2hlY2tJbnNpZGVTZWdtZW50XSAtIElmIHRydWUsIHdlIHJlamVjdCBsaW5lIGludGVyc2VjdGlvbnMgb3V0c2lkZSB0aGUgc2VnbWVudCByYW5nZXNcbi8vICBAcGFyYW0ge1ZlY3RvcjJ9IFtvdXRQb2ludF0gICAgICAgICAgIC0gT3B0aW9uYWwgdGFyZ2V0IHZlY3RvclxuLy8gIEBwYXJhbSB7bnVtYmVyfSAgW2Vwc2lsb25dICAgICAgICAgICAgLSBOZWFybHktemVybyB0aHJlc2hvbGQgdXNlZCB0byBkZXRlcm1pbmUgXCJuZWFybHktcGFyYWxsZWxcIiByZXNwLiBcIm5lYXJseS16ZXJvLWxlbmd0aCBsaW5lXCJcbi8vICBAcGFyYW0ge1ZlY3RvcjJ8bnVsbH1cbmV4cG9ydCBjb25zdCBpbnRlcnNlY3RMaW5lcyA9IChwMSwgcDIsIHAzLCBwNCwgY2hlY2tJbnNpZGVTZWdtZW50LCBvdXRQb2ludCwgZXBzaWxvbiA9IDAuMDAwMDEpID0+IHtcblxuICAgIGNvbnN0IGRlbm9tID0gKHA0LnkgLSBwMy55KSAqIChwMi54IC0gcDEueCkgLSAocDQueCAtIHAzLngpICogKHAyLnkgLSBwMS55KTtcblxuICAgIC8vIFJlamVjdCBpZiBsaW5lcyBhcmUgcGFyYWxsZWwgb3Igb25lIG9mIHRoZW0gaGFzIHplcm8tbGVuZ3RoXG4gICAgaWYgKE1hdGguYWJzKGRlbm9tKSA8IGVwc2lsb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gdWEgZGVub3RlcyB3aGVyZSB0byBmaW5kIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgcCBhbG9uZyBzZWdtZW50IChwMSwgcDIpOlxuICAgIC8vICAgRm9yIHVhID0gMCwgd2UgaGF2ZSBwID0gcDFcbiAgICAvLyAgIEZvciB1YSA9IDEsIHdlIGhhdmUgcCA9IHAyXG4gICAgbGV0IHVhID0gKHA0LnggLSBwMy54KSAqIChwMS55IC0gcDMueSkgLSAocDQueSAtIHAzLnkpICogKHAxLnggLSBwMy54KTtcbiAgICB1YSAvPSBkZW5vbTtcblxuICAgIC8vIEFwcGx5IHNlZ21lbnQgY2hlY2tcbiAgICBpZiAoY2hlY2tJbnNpZGVTZWdtZW50KSB7XG5cbiAgICAgICAgLy8gdWIgZGVub3RlcyB3aGVyZSB0byBmaW5kIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgcCBhbG9uZyBzZWdtZW50IChwMywgcDQpXG4gICAgICAgIGxldCB1YiA9IChwMi54IC0gcDEueCkgKiAocDEueSAtIHAzLnkpIC0gKHAyLnkgLSBwMS55KSAqIChwMS54IC0gcDMueCk7XG4gICAgICAgIHViIC89IGRlbm9tO1xuXG4gICAgICAgIC8vIEludGVyc2VjdGlvbiBpcyB3aXRoaW4gdGhlIHNlZ21lbnRzIGlmIHVhIGFuZCB1YiBhcmUgYm90aCBpbiBbMCwxXVxuICAgICAgICBpZiAodWEgPCAwLjAgfHwgdWEgPiAxLjAgfHxcbiAgICAgICAgICAgIHViIDwgMC4wIHx8IHViID4gMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG91dFBvaW50ID0gb3V0UG9pbnQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgIG91dFBvaW50LnggPSBwMS54ICsgdWEgKiAocDIueCAtIHAxLngpO1xuICAgIG91dFBvaW50LnkgPSBwMS55ICsgdWEgKiAocDIueSAtIHAxLnkpO1xuICAgIHJldHVybiBvdXRQb2ludDtcbn07XG5cblxuXG4iXSwibmFtZXMiOlsibmVhcmVzdFBvaW50T25DaXJjdWxhckFyYyIsInAiLCJjZW50ZXIiLCJyYWRpdXMiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJvdXRQb2ludCIsIlRIUkVFIiwiVmVjdG9yMiIsImRpciIsImNvcHkiLCJzdWIiLCJub3JtYWxpemUiLCJhbmdsZSIsIk1hdGgiLCJhdGFuMiIsInkiLCJ4IiwiaW5zaWRlQXJjIiwiQXV0b2Rlc2siLCJFeHRlbnNpb25zIiwiQ29tcEdlb20iLCJhbmdsZUluc2lkZUFyYyIsIm11bHRpcGx5U2NhbGFyIiwiYWRkIiwicFN0YXJ0IiwiZ2V0RWxsaXBzZVBvaW50IiwicEVuZCIsImQyU3RhcnQiLCJkaXN0YW5jZVRvU3F1YXJlZCIsImQyRW5kIiwic3RhcnRJc0Nsb3NlciIsImludGVyc2VjdExpbmVzIiwicDEiLCJwMiIsInAzIiwicDQiLCJjaGVja0luc2lkZVNlZ21lbnQiLCJlcHNpbG9uIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiZGVub20iLCJhYnMiLCJ1YSIsInViIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./extensions/Snapping/SnapMath.js\n");

/***/ }),

/***/ "./extensions/Snapping/Snapper.js":
/*!****************************************!*\
  !*** ./extensions/Snapping/Snapper.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Snapper: () => (/* binding */ Snapper)\n/* harmony export */ });\n/* harmony import */ var _SnapperIndicator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SnapperIndicator.js */ \"./extensions/Snapping/SnapperIndicator.js\");\n/* harmony import */ var _SnapMath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SnapMath.js */ \"./extensions/Snapping/SnapMath.js\");\n\n\n\n\nconst MeasureCommon = Autodesk.Viewing.MeasureCommon;\nconst EPSILON = MeasureCommon.EPSILON;\nconst SnapType = MeasureCommon.SnapType;\nconst SnapResult = MeasureCommon.SnapResult;\n\nvar SNAP_PRECISION = 0.001;\n\nconst av = Autodesk.Viewing;\nconst avp = av.Private;\nconst VertexBufferReader = avp.VertexBufferReader;\n\n/**\n * @param {number} a - First value to compare\n * @param {number} b - Second value to compare\n * @private\n */\nfunction isEqualWithPrecision(a, b) {\n  return Math.abs(a - b) <= SNAP_PRECISION;\n}\n\n/**\n * Are the vectors equal within SNAP_PRECISION?\n * @param {THREE.Vector3} v1 - vector\n * @param {THREE.Vector3} v2 - vector\n * @returns {boolean} - true when they are equal\n * @private\n */\nfunction isEqualVectorsWithPrecision(v1, v2) {\n  return Math.abs(v1.x - v2.x) <= SNAP_PRECISION &&\n  Math.abs(v1.y - v2.y) <= SNAP_PRECISION &&\n  Math.abs(v1.z - v2.z) <= SNAP_PRECISION;\n}\n\n/**\n * Are the vectors inverse of each other within SNAP_PRECISION?\n * @param {THREE.Vector3} v1 - vector\n * @param {THREE.Vector3} v2 - vector\n * @returns {boolean} - true when they are inverse of each other\n * @private\n */\nfunction isInverseVectorsWithPrecision(v1, v2) {\n  return Math.abs(v1.x + v2.x) <= SNAP_PRECISION &&\n  Math.abs(v1.y + v2.y) <= SNAP_PRECISION &&\n  Math.abs(v1.z + v2.z) <= SNAP_PRECISION;\n}\n\n/**\n * @param {THREE.Vector3} point - Point\n * @param {THREE.Vector3} lineStart - Start of the line\n * @param {THREE.Vector3} lineEnd - End of the line\n * @returns {number} - distance from point to the line\n * @private\n */\nfunction distancePointToLine(point, lineStart, lineEnd) {\n\n  if (lineStart.equals(lineEnd)) {// Degenerate line\n    return point.distanceTo(lineStart);\n  }\n\n  var X0 = new THREE.Vector3();\n  var X1 = new THREE.Vector3();\n  var distance;\n  var param;\n\n  X0.subVectors(lineStart, point);\n  X1.subVectors(lineEnd, lineStart);\n  param = X0.dot(X1);\n  X0.subVectors(lineEnd, lineStart);\n  param = -param / X0.dot(X0);\n\n  if (param < 0) {\n    distance = point.distanceTo(lineStart);\n  } else if (param > 1) {\n    distance = point.distanceTo(lineEnd);\n  } else {\n    X0.subVectors(point, lineStart);\n    X1.subVectors(point, lineEnd);\n    X0.cross(X1);\n    X1.subVectors(lineEnd, lineStart);\n\n    distance = Math.sqrt(X0.dot(X0)) / Math.sqrt(X1.dot(X1));\n  }\n\n  return distance;\n}\n\nconst SnapCandidateType = {\n  Unknown: 0,\n  Line: 1,\n  CircularArc: 2,\n  EllipticalArc: 3\n};\n\n// A SnapCandidate references a single segment (line or arc) that we could snap to.\nclass SnapCandidate {\n  constructor(viewportId) {\n\n    this.type = SnapCandidateType.Unknown;\n    this.viewportId = viewportId;\n\n    // 2d distance between original (unsnapped) position and the geometry of this candidate.\n    this.distance = 0;\n\n    // {Vector2} Start/Endpoint - only for line segments\n    this.lineStart = null;\n    this.lineEnd = null;\n\n    // Fixed radius - only for CircularArcs\n    this.radius = 0;\n\n    // Separate radii - only for ellipse arcs\n    this.radiusX = 0; // = major radius - by convention\n    this.radiusY = 0;\n\n    // Center point as Vector2 (for arcs)\n    this.center = null;\n\n    // Start/end angle for arcs: Ccw angle in radians. Angle 0 corresponds to direction x+.\n    this.startAngle = 0;\n    this.endAngle = 0;\n  }\n\n  fromLine(p1, p2) {\n    this.type = SnapCandidateType.Line;\n    this.lineStart = p1.clone();\n    this.lineEnd = p2.clone();\n    return this;\n  }\n\n  fromCircularArc(center, radius, start, end) {\n    this.type = SnapCandidateType.CircularArc;\n    this.center = center.clone();\n    this.radius = radius;\n    this.start = start;\n    this.end = end;\n    return this;\n  }\n\n  fromEllipticalArc(center, radiusX, radiusY, start, end) {\n    this.type = SnapCandidateType.EllipticalArc;\n    this.center = center.clone();\n    this.radiusX = radiusX;\n    this.radiusY = radiusY;\n    this.start = start;\n    this.end = end;\n    return this;\n  }\n\n  isLine() {return this.type === SnapCandidateType.Line;}\n  isCircularArc() {return this.type === SnapCandidateType.CirularArc;}\n  isEllipticalArc() {return this.type === SnapCandidateType.EllipticalArc;}\n\n  // Checks if the snapGeometry of this candidate intersects with another one.\n  //  @param {SnapCandidate} other\n  //  @param {Vector2} [optionalTarget]\n  //  @returns {THREE.Vector2|null} Returns intersection point if there is one.\n  getIntersection(other, optionalTarget) {\n\n    if (this.isLine() && other.isLine()) {\n      // Note: We do the intersections on the whole line - not just the intersections.\n      // Reason is:\n      //  a) Otherwise, it would not snap if you are slightly outline of one line segment\n      //  b) By definition, we get only very close segment candidates anyway\n      return (0,_SnapMath_js__WEBPACK_IMPORTED_MODULE_1__.intersectLines)(this.lineStart, this.lineEnd, other.lineStart, other.lineEnd, false, optionalTarget);\n    }\n\n    // TODO: Currently, we only support snapping to line-line intersections\n  }\n}\n\n// Checks if we can snap to an intersection of two close segments (each can be a line or arcs).\n//  @param {SnapCandidate[]} candidates     - Snap candidate geometries collected in GeometryCallback. Assumed to be within snapRadius.\n//  @param {TREE.Vector3}    intersectPoint - Unsnapped original position\n//  @param {number}          snapRadius\n//  @returns {Object|null} If an intersection snap is found, the result contains:\n//                    {\n//                        viewportId  // number\n//                        snapPoint   // (THREE.Vector3)\n//                    }\nconst findIntersectionSnap = (candidates, intersectPoint, snapRadius) => {\n\n  // Sort snapping candidates by increasing distance\n  // Strictly speaking, we just need the best two ones. But the number of candidates within the snapping\n  // distance is generally small anyway - and working with a sorted array is more flexible to incrementally\n  // make the snapping smarter later.\n  const byDistance = (ca, cb) => ca.distance - cb.distance;\n  candidates.sort(byDistance);\n\n  // Stop here if we don't have enough candidates for an intersection\n  if (candidates.length < 2) {\n    return null;\n  }\n\n  // Init result object\n  const result = {\n    // Just use the one of the first candidate. There is no unique viewportId when using an intersection.\n    viewportId: candidates[0].viewportId,\n\n    // Snapping happens in 2d - so we set z in advance and just keep the original value.\n    // Note: Snapper generally needs some revision if we use it for planes that are not perpendicular to the viewing direction.\n    snapPoint: new THREE.Vector3(0, 0, intersectPoint.z)\n  };\n\n  // Check for any candidate that intersects with the closest one we found\n  const first = candidates[0];\n  for (let i = 1; i < candidates.length; i++) {\n    const second = candidates[i];\n\n    // Do intersection test. If found, write it to result.snapPoint\n    const found = first.getIntersection(second, result.snapPoint);\n    if (!found) {\n      continue;\n    }\n\n    // We found an intersection. Although we assume all candidates to be within\n    // snap radius already, the intersection may still be somewhere else.\n    // => Check if intersection is still within the snapRadius.\n    const dist = THREE.Vector2.prototype.distanceTo.call(result.snapPoint, intersectPoint);\n    if (dist < snapRadius) {\n      // We found a valid intersection snap\n      return result;\n    }\n  }\n  return null;\n};\n\n\n/**\n * A tool that lets users attach pointer events to vertices and edges. It supports 2D and 3D models.\n *\n * @param {Viewer3D} viewer - Viewer instance\n * @param {object} options - Configurations for the extension\n * @memberof Autodesk.Viewing.Extensions.Snapping\n * @alias Autodesk.Viewing.Extensions.Snapping.Snapper\n * @class\n */\nfunction Snapper(viewer, options) {\n\n  var _snapResult = new SnapResult();\n\n  var _viewer = viewer;\n  this.setGlobalManager(viewer.globalManager);\n\n  var _options = options || {};\n  var _names;\n\n  if (_options.markupMode) {\n    _names = [\"snapper-markup\"];\n  } else if (_options.toolName) {\n    // Allow tools to use their own snapper\n    _names = [_options.toolName];\n  } else {\n    _names = [\"snapper\"];\n  }\n\n  var _priority = 60;\n\n  var _active = false;\n\n  var _distanceToEdge = Number.MAX_VALUE;\n  var _distanceToVertex = null;\n\n  var _isDragging = false;\n  var _isPressing = false;\n  var _isSnapped = false;\n\n  var _forcedVpId = null; // the viewport index of the first selection for 2D\n\n  var _snapToPixel = false;\n\n  var _snapFilter = null; // Optional snapping filter, based on snapResult. (snapResult) => boolean.\n\n  this.indicator = new _SnapperIndicator_js__WEBPACK_IMPORTED_MODULE_0__.SnapperIndicator(viewer, this);\n\n  this.markupMode = _options.markupMode;\n  this.renderSnappedGeometry = _options.renderSnappedGeometry;\n  this.renderSnappedTopology = _options.renderSnappedTopology;\n\n  //Notice: The pixelSize should correspond to the amount of pixels per line in idAtPixels, the shape of\n  //detection area is square in idAtPixels, but circle in snapper, should make their areas match roughly.\n  this.detectRadiusInPixels = av.isMobileDevice() ? 50 : 10;\n\n  /**\n   * @returns {boolean} true when the tool is active\n   *\n   * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isActive\n   */\n  this.isActive = function () {\n    return _active;\n  };\n\n  this.getNames = function () {\n    return _names;\n  };\n\n  this.getName = function () {\n    return _names[0];\n  };\n\n  this.getPriority = function () {\n    return _priority;\n  };\n\n  /**\n   * Starts intercepting pointer events.\n   * Invoked automatically by the {@link ToolController}.\n   *\n   * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#activate\n   */\n  this.activate = function () {\n    _active = true;\n\n    if (this.indicator.isNull()) {\n      this.indicator = new _SnapperIndicator_js__WEBPACK_IMPORTED_MODULE_0__.SnapperIndicator(viewer, this);\n    }\n  };\n\n\n  /**\n   * Stops intercepting pointer events.\n   * Invoked automatically by the {@link ToolController}.\n   *\n   * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#deactivate\n   */\n  this.deactivate = function () {\n    _active = false;\n\n    if (!this.indicator.isNull()) {\n      this.indicator.destroy();\n      this.indicator = new _SnapperIndicator_js__WEBPACK_IMPORTED_MODULE_0__.NullSnapperIndicator();\n    }\n  };\n\n  this.copyResults = function (destiny) {\n    _snapResult.copyTo(destiny);\n  };\n\n  this.getEdge = function () {\n    return _snapResult.geomEdge;\n  };\n\n  this.getVertex = function () {\n    return _snapResult.geomVertex;\n  };\n\n  this.getGeometry = function () {\n    return _snapResult.getGeometry();\n  };\n\n  this.getGeometryType = function () {\n    return _snapResult.geomType;\n  };\n\n  this.getIntersectPoint = function () {\n    return _snapResult.intersectPoint;\n  };\n\n\n  /**\n   * @returns {SnapResult} The snapping status of the last pointer event performed.\n   *\n   * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#getSnapResult\n   */\n  this.getSnapResult = function () {\n    return _snapResult;\n  };\n\n  /**\n   * Checks whether the tool's last update resulted on a snap.\n   *\n   * @returns {boolean} true when the last pointer event got snapped.\n   *\n   * @alias Autodesk.Viewing.Extensions.Snapping.Snapper#isSnapped\n   */\n  this.isSnapped = function () {\n    return _isSnapped;\n  };\n\n  this.clearSnapped = function () {\n    _snapResult.clear();\n    _isSnapped = false;\n  };\n\n  this.setViewportId = function (vpId) {\n    _forcedVpId = vpId;\n  };\n\n  this.setSnapToPixel = function (enable) {\n    _snapToPixel = enable;\n  };\n\n  this.getSnapToPixel = function () {\n    return _snapToPixel;\n  };\n\n  this.setSnapToArc = function (enable) {\n    _snapResult.snapToArc = enable;\n  };\n\n  this.getSnapToArc = function () {\n    return _snapResult.snapToArc;\n  };\n\n  this.setArc = function (isArc) {\n    _snapResult.isArc = isArc;\n  };\n\n  this.getArc = function () {\n    return _snapResult.isArc;\n  };\n\n  this.setSnapFilter = function (filter) {\n    _snapFilter = filter;\n  };\n\n  /**\n   * 3D Snapping\n   *\n   * @param result -Result of Hit Test.\n   */\n  this.snapping3D = function (result) {\n\n    _snapResult.snapNode = result.dbId;\n    _snapResult.intersectPoint = result.intersectPoint;\n    _snapResult.modelId = result.model ? result.model.id : null;\n\n    var face = result.face;\n\n    if (!result.model || result.fragId === undefined) {\n      // some non-model geometry was hit\n      if (result.object instanceof THREE.Mesh) {\n        // if it was a mesh, try to snap to it\n        this.meshSnapping(face, result.object);\n      }\n    } else {\n      var fragIds;\n\n      if (result.fragId.length === undefined) {\n        fragIds = [result.fragId];\n      } else {\n        fragIds = result.fragId;\n      }\n\n      // This is for Fusion & ATF model with topology data\n      _snapResult.hasTopology = result.model.hasTopology();\n      if (_snapResult.hasTopology)\n      {\n        // For mixed mode (some entities have topo, and some others don't),\n        // we should further check the selected fragId has valid topology before go with snapping3DwithTopology.\n        for (var fi = 0; fi < fragIds.length; ++fi) {\n\n          var fragId = fragIds[fi];\n          var topoIndex = result.model.getTopoIndex(fragId);\n          var topology = result.model.getTopology(topoIndex);\n          if (topology == undefined)\n          {\n            _snapResult.hasTopology = false;\n            break;\n          }\n        }\n      }\n\n\n      if (_snapResult.hasTopology) {\n        this.snapping3DwithTopology(face, fragIds, result.model);\n      } else {\n        this.snapping3DtoMesh(face, fragIds, result.model);\n      }\n    }\n  };\n\n\n  /**\n   * Returns a function that sets a vertex (Vector3 or LmvVector3) to the data read from a vertex buffer at idx\n   * Signature: func(idx, vertex) -> vertex\n   *            if vertex is null/undefined, a new THREE.Vector3 is created\n   *\n   * @param {BufferGeometry} geometry - the geometry of mesh\n   *\n   * @private\n   */\n\n  this.makeReadVertexFunc = function (geometry) {\n    const attributes = geometry.attributes;\n    let positions, stride;\n    // Get the offset to positions in the buffer. Be careful, 2D buffers\n    // don't use the 'position' attribute for positions. Reject those.\n    // meshes use vblayout for describing the buffer structure, BufferGeometry uses attributes.xx\n    let poffset;\n\n    if (geometry.vblayout) {\n      if (!geometry.vblayout.position) {\n        return function () {}; // No positions, what to do??\n      }\n      poffset = geometry.vblayout.position.offset;\n    } else if (!attributes.position) {\n      return function () {}; // No positions, what to do??\n    } else {\n      poffset = attributes.position.offset || 0;\n    }\n\n    positions = geometry.vb ? geometry.vb : geometry.attributes.position.array;\n    stride = geometry.vb ? geometry.vbstride : 3;\n\n    return function (idx, v) {\n      const p = idx * stride + poffset;\n      v = v || new THREE.Vector3();\n      v.set(\n        positions[p],\n        positions[p + 1],\n        positions[p + 2]\n      );\n      return v;\n    };\n  };\n\n  /**\n   * Snapping order is: 1st vertices, 2nd edges, 3rd and final faces.\n   *\n   * @param face\n   * @param fragIds\n   * @param model\n   * @private\n   */\n  this.snapping3DwithTopology = function (face, fragIds, model) {\n\n    // Because edge topology data may be in other fragments with same dbId, need to iterate all of them.\n    if (_snapResult.snapNode) {\n      fragIds = [];\n\n      model.getData().instanceTree.enumNodeFragments(_snapResult.snapNode, function (fragId) {\n        fragIds.push(fragId);\n      }, true);\n    }\n\n    _snapResult.geomFace = _snapResult.geomEdge = _snapResult.geomVertex = null;\n    _distanceToEdge = Number.MAX_VALUE;\n\n    for (var fi = 0; fi < fragIds.length; ++fi) {var _model$getFragmentLis, _model$getFragmentLis2;\n\n      var fragId = fragIds[fi];\n\n      const matrixWorld = new THREE.Matrix4();\n      (_model$getFragmentLis = model.getFragmentList()) === null || _model$getFragmentLis === void 0 || _model$getFragmentLis.getWorldMatrix(fragId, matrixWorld);\n      var geometry = (_model$getFragmentLis2 = model.getFragmentList()) === null || _model$getFragmentLis2 === void 0 ? void 0 : _model$getFragmentLis2.getGeometry(fragId);\n\n      var topoIndex = model.getTopoIndex(fragId);\n      var topology = model.getTopology(topoIndex);\n      // For ATF merged DBID scenario, part of merged entities may have no topology.\n      // we should skip this case for face and edge topology measurement.\n      if (topology == undefined)\n      continue;\n\n      var facesTopology = topology.faces;\n      var edgesTopology = topology.edges;\n\n      if (!_snapResult.geomFace) {\n        _snapResult.geomFace = this.faceSnappingWithTopology(face, geometry, facesTopology, { matrixWorld });\n\n        if (_snapResult.geomFace) {\n          _snapResult.geomFace.fragId = fragId;\n        }\n\n        var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrixWorld);\n        _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n      }\n\n      // Need to iterate all frags with same dbId, because when meshes are attached with each other,\n      // edge-topology data will only be on one mesh.\n      this.edgeSnappingWithTopology(_snapResult.intersectPoint, geometry, edgesTopology, { matrixWorld });\n\n    }\n\n    _snapResult.geomVertex = this.vertexSnappingWithTopology(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n    if (_snapResult.geomFace) {\n\n      // Determine which one should be drawn: face , edge or vertex\n      _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n      if ((_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) && _snapResult.geomVertex) {\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if ((_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) && _snapResult.geomEdge) {\n\n        var center = this.edgeIsCircle(_snapResult.geomEdge);\n        if (center) {\n          _snapResult.circularArcCenter = center;\n          _snapResult.circularArcRadius = center.distanceTo(_snapResult.geomEdge.vertices[0]);\n          _snapResult.geomEdge.center = _snapResult.circularArcCenter;\n          _snapResult.geomEdge.radius = _snapResult.circularArcRadius;\n          _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n        } else\n        if (this.edgeIsCurved(_snapResult.geomEdge)) {\n          _snapResult.geomType = SnapType.SNAP_CURVEDEDGE;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n\n      } else\n      {\n\n        if (this.faceIsCurved(_snapResult.geomFace)) {\n          _snapResult.geomType = SnapType.SNAP_CURVEDFACE;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_FACE;\n        }\n\n      }\n\n      _isSnapped = true;\n    }\n  };\n\n  this.meshSnapping = function (face, _ref) {let { geometry, matrixWorld } = _ref;\n\n    // Handle 3D line geometry\n    const isLine = geometry.isLines || geometry.isWideLines;\n    if (isLine && face) {\n\n      // For line meshes, face is a line {a, b} instead of a Face3 instance (see lineRayCast(..) in VBIntersector.js,\n      // where a, b are vertex indices into the line mesh vertex array.\n      //\n      // Note: Unlike edge intersection for faces, we just use the line segment itself and don't search for topology\n      //       of connected line segments to identify polylines as one item. If we need this, we have to add the corresponding code first.\n      _snapResult.geomEdge = this.extractLineGeometry(face, geometry);\n      _snapResult.geomEdge.applyMatrix4(matrixWorld);\n\n      _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n      _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n      // Determine which one should be drawn: edge or vertex\n      if (_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) {\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      {\n        // Note: Since we got the edge as hit result, we can already assume the intersection to be close to the line.\n        _snapResult.geomType = SnapType.SNAP_EDGE;\n      }\n\n      _isSnapped = true;\n      return true;\n    }\n\n    // Note that face may also be a line {a, b} (see lineRayCast(..) in VBIntersector.js\n    if (face instanceof THREE.Face3) {\n      _snapResult.geomFace = this.faceSnapping(face, geometry);\n    }\n\n    if (!_snapResult.geomFace)\n    return false;\n\n    _snapResult.geomFace.applyMatrix4(matrixWorld);\n    _snapResult.geomEdge = this.edgeSnapping(_snapResult.geomFace, _snapResult.intersectPoint);\n    _snapResult.geomVertex = this.vertexSnapping(_snapResult.geomEdge, _snapResult.intersectPoint);\n\n    var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrixWorld);\n    _snapResult.faceNormal = face.normal.applyMatrix3(normalMatrix).normalize();\n\n    _snapResult.radius = this.setDetectRadius(_snapResult.intersectPoint);\n\n    // Determine which one should be drawn: face, edge or vertex\n    if (_options.forceSnapVertices || _distanceToVertex < _snapResult.radius) {\n      _snapResult.geomType = SnapType.SNAP_VERTEX;\n    } else\n    if (_options.forceSnapEdges || _distanceToEdge < _snapResult.radius) {\n      _snapResult.geomType = SnapType.SNAP_EDGE;\n    } else\n    {\n      _snapResult.geomType = SnapType.SNAP_FACE;\n    }\n\n    _isSnapped = true;\n    return true;\n  };\n\n  this.snapping3DtoMesh = function (face, fragIds, model) {\n    for (var fi = 0; fi < fragIds.length; ++fi) {\n\n      var fragId = fragIds[fi];\n\n\n      const geometry = model.getFragmentList().getGeometry(fragId);\n      const matrixWorld = new THREE.Matrix4();\n      model.getFragmentList().getWorldMatrix(fragId, matrixWorld);\n\n      if (this.meshSnapping(face, { geometry, matrixWorld })) {\n        break;\n      }\n    }\n  };\n\n  this.faceSnappingWithTopology = function (face, geometry, facesTopology, _ref2) {let { matrixWorld } = _ref2;\n\n    var vA = new THREE.Vector3();\n    var vB = new THREE.Vector3();\n    var vC = new THREE.Vector3();\n\n    const geom = new THREE.Geometry();\n    const vertices = [];\n\n    if (geometry.index !== undefined) {\n\n      // Find the index of face topology list which includes the intersect face(triangle)\n      for (var i = 0; i < facesTopology.length; i++) {\n\n        var indexList = facesTopology[i].indexList;\n        var faceId = facesTopology[i].id;\n        let j = 0;\n        for (; j < indexList.length; j += 3) {\n\n          if (face.a === indexList[j]) {\n            if (face.b === indexList[j + 1] && face.c === indexList[j + 2] || face.b === indexList[j + 2] && face.c === indexList[j + 1]) {\n              break;\n            }\n          } else\n          if (face.a === indexList[j + 1]) {\n            if (face.b === indexList[j] && face.c === indexList[j + 2] || face.b === indexList[j + 2] && face.c === indexList[j]) {\n              break;\n            }\n          } else\n          if (face.a === indexList[j + 2]) {\n            if (face.b === indexList[j] && face.c === indexList[j + 1] || face.b === indexList[j + 1] && face.c === indexList[j]) {\n              break;\n            }\n          }\n        }\n\n        if (j < indexList.length) {\n          break;\n        }\n      }\n\n      if (i < facesTopology.length) {\n\n        const readVertex = this.makeReadVertexFunc(geometry);\n\n        for (let j = 0; j < indexList.length; j += 3) {\n          readVertex(indexList[j], vA);\n          readVertex(indexList[j + 1], vB);\n          readVertex(indexList[j + 2], vC);\n\n          const vIndex = vertices.length;\n          geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n          vertices.push(vA.clone());\n          vertices.push(vB.clone());\n          vertices.push(vC.clone());\n        }\n        geom.vertices = vertices;\n\n      }\n    }\n\n    if (vertices.length > 0) {\n\n      geom.faceId = faceId;\n      geom.applyMatrix4(matrixWorld);\n      return geom;\n    } else\n    {\n\n      return null;\n    }\n\n  };\n\n  /**\n   * Find the closest face next to the cast ray\n   *\n   * @param {THREE.Face3} face - the intersect triangle of Hit Test.\n   * @param {BufferGeometry} geometry - the geometry of mesh\n   *\n   * @private\n   */\n  this.faceSnapping = function (face, geometry) {\n\n    var vA = new THREE.Vector3();\n    var vB = new THREE.Vector3();\n    var vC = new THREE.Vector3();\n\n    const geom = new THREE.Geometry(); //Geometry which includes all the triangles on the same plane.\n\n    let indices;\n    // @todo: .ib might not be there as expected, e.g., the section tool seems to create incomplete/non-conforming geometries.\n    indices = geometry.index && (geometry.index.array || geometry.ib);\n\n    var offsets = geometry.groups;\n\n    if (!offsets || offsets.length === 0) {\n\n      let positions;\n      // @todo: .vb might not be there as expected, e.g., the section tool seems to create incomplete/non-conforming geometries.\n      positions = geometry.vb ?? geometry.attributes.position.array;\n      offsets = [{ start: 0, count: indices ? indices.length : positions.length, index: 0 }];\n    }\n\n    const readVertex = this.makeReadVertexFunc(geometry);\n\n    const va = readVertex(face.a);\n\n    for (var oi = 0; oi < offsets.length; ++oi) {\n\n      var start = offsets[oi].start;\n      var count = offsets[oi].count;\n      var index = 0;\n      index = offsets[oi].index;\n\n      for (var i = start; i < start + count; i += 3) {\n\n        var a = index + (indices ? indices[i] : i);\n        var b = index + (indices ? indices[i + 1] : i + 1);\n        var c = index + (indices ? indices[i + 2] : i + 2);\n\n        readVertex(a, vA);\n        readVertex(b, vB);\n        readVertex(c, vC);\n\n        var faceNormal = new THREE.Vector3();\n        THREE.Triangle.getNormal(vA, vB, vC, faceNormal);\n\n        if (isEqualVectorsWithPrecision(faceNormal, face.normal) && isEqualWithPrecision(faceNormal.dot(vA), face.normal.dot(va)))\n        {\n\n          const vIndex = geom.vertices.length;\n          geom.faces.push(new THREE.Face3(vIndex, vIndex + 1, vIndex + 2));\n          geom.vertices.push(vA.clone());\n          geom.vertices.push(vB.clone());\n          geom.vertices.push(vC.clone());\n        }\n      }\n    }\n\n    if (geom.vertices.length > 0) {\n\n      return this.getTrianglesOnSameFace(geom, face, readVertex);\n    } else\n    {\n\n      return null;\n    }\n  };\n\n  /**\n   * Find triangles on the same face with the triangle intersected with the cast ray\n   *\n   * @param geom -Geometry which includes all the triangles on the same plane.\n   * @param face -Triangle which intersects with the cast ray.\n   * @param readVertexCB -Accessor function to read vertex data (see makeReadVertexFunc)\n   *\n   * @private\n   */\n  this.getTrianglesOnSameFace = function (geom, face, readVertexCB) {\n    const vertices = geom.vertices;\n\n    const faceVertex1 = readVertexCB(face.a);\n    const faceVertex2 = readVertexCB(face.b);\n    const faceVertex3 = readVertexCB(face.c);\n\n    const intersectFace = new THREE.Geometry();\n\n    const precisionPoints = 5; // number of decimal points, eg. 4 for epsilon of 0.0001\n    const precision = Math.pow(10, precisionPoints);\n\n    // Build triangle list\n    // Each triangle will contain a list of its 3 edges\n    // Also maintain an edge map, pointing to the triangles indices that contain it\n    const trianglesArr = [];\n    const edgesMap = {};\n    let firstTriangle = -1; // Will point to index of passed face parameter\n    for (let i = 0; i < vertices.length; i += 3) {\n      // for each triangle\n      const vA = vertices[i];\n      const vB = vertices[i + 1];\n      const vC = vertices[i + 2];\n\n      if (firstTriangle < 0 && faceVertex1.equals(vA) && faceVertex2.equals(vB) && faceVertex3.equals(vC)) {\n        firstTriangle = i / 3;\n      }\n\n      const keys = [\n      Math.round(vA.x * precision) + '_' + Math.round(vA.y * precision) + '_' + Math.round(vA.z * precision),\n      Math.round(vB.x * precision) + '_' + Math.round(vB.y * precision) + '_' + Math.round(vB.z * precision),\n      Math.round(vC.x * precision) + '_' + Math.round(vC.y * precision) + '_' + Math.round(vC.z * precision)];\n\n      const triangle = { edges: [] };\n\n      // Edge map update\n      for (let j = 0; j < 3; j++) {\n        const key1 = keys[j];\n        const key2 = keys[(j + 1) % 3];\n\n        const defaultEdge = key1 + '_' + key2;\n        let edge = edgesMap[defaultEdge] || edgesMap[key2 + '_' + key1];\n        if (!edge) {\n          // If this edge hasn't been added before, add it now\n          edge = edgesMap[defaultEdge] = { triangles: [] };\n        }\n\n        // Add edge to current triangle\n        triangle.edges.push(edge);\n        // Add current triangle to edge\n        edge.triangles.push(i / 3);\n      }\n\n      trianglesArr.push(triangle);\n    }\n\n    if (firstTriangle < 0) {\n      return null;\n    }\n\n    // BFS search for neighbouring triangles\n    const queue = [firstTriangle];\n    const visited = new Set();\n    const connectedFaces = [];\n\n    while (queue.length > 0) {\n      const currentFace = queue.shift();\n\n      if (visited.has(currentFace)) {\n        continue;\n      }\n\n      visited.add(currentFace);\n\n      // Add this face to the list of connected faces\n      connectedFaces.push(currentFace);\n\n      // Add all neighboring faces to the queue\n      const triangle = trianglesArr[currentFace];\n      for (const edge of triangle.edges) {\n        edge.triangles.forEach((t) => t !== currentFace && queue.push(t));\n      }\n    }\n\n    // Copy results of the actual vertices in the connected faces\n    // Since vertices are already cloned in faceSnapping, there's no need to clone them again\n    const finalVertices = [];\n    let vIndex = 0;\n    connectedFaces.forEach((faceIdx) => {\n      intersectFace.faces.push(new THREE.Face3(vIndex++, vIndex++, vIndex++));\n      finalVertices.push(vertices[faceIdx * 3]);\n      finalVertices.push(vertices[faceIdx * 3 + 1]);\n      finalVertices.push(vertices[faceIdx * 3 + 2]);\n    });\n\n    intersectFace.vertices = finalVertices;\n\n    return intersectFace;\n  };\n\n  this.edgeSnappingWithTopology = function (intersectPoint, geometry, edgesTopology, _ref3) {let { matrixWorld } = _ref3;\n\n    const edgeGeom = new THREE.Geometry(); //Geometry which includes all the triangles on the same plane.\n    var minDistTopoIndex;\n    var minDist = Number.MAX_VALUE;\n\n    var vA = new THREE.Vector3();\n    var vB = new THREE.Vector3();\n\n    if (geometry.index !== undefined && edgesTopology != undefined) {\n\n      const readVertex = this.makeReadVertexFunc(geometry);\n      // Find the index of edge topology list which includes the nearest edge segment to the intersect point\n      for (var i = 0; i < edgesTopology.length; i++) {\n\n        var indexList = edgesTopology[i].indexList;\n        // In edges topology index list the type is LineStrip\n        for (var j = 0; j < indexList.length - 1; j++) {\n          readVertex(indexList[j], vA);\n          readVertex(indexList[j + 1], vB);\n\n          vA.applyMatrix4(matrixWorld);\n          vB.applyMatrix4(matrixWorld);\n\n          var dist = distancePointToLine(intersectPoint, vA, vB);\n          if (dist < minDist) {\n            minDist = dist;\n            minDistTopoIndex = i;\n          }\n        }\n      }\n\n      if (minDistTopoIndex) {\n        indexList = edgesTopology[minDistTopoIndex].indexList;\n        for (var k = 0; k < indexList.length - 1; k++) {\n          const vK0 = readVertex(indexList[k]);\n          const vK1 = readVertex(indexList[k + 1]);\n\n          edgeGeom.vertices.push(vK0);\n          // To make the line's type to LinePieces which is used by drawLine function\n          edgeGeom.vertices.push(vK1);\n        }\n      }\n    }\n\n    if (_distanceToEdge >= minDist && edgeGeom.vertices.length > 0) {\n\n      _distanceToEdge = minDist;\n      edgeGeom.applyMatrix4(matrixWorld);\n      _snapResult.geomEdge = edgeGeom;\n    }\n  };\n\n  /**\n   * Get Edge geometry for the case that the hittest result contained a 3D lines. For this case, we have no Face3, so\n   * that faceSnapping and edgeSnapping don't work.\n   *\n   *  @param {Object}         edge     - {a, b} with vertex indices a,b of lineStart/lineEnd vertex\n   *  @param {GeometryBuffer} geometry\n   *  @returns {THREE.Geometry|THREE.BufferGeometry} Geometry with simple line\n   */\n  this.extractLineGeometry = function (edge, geometry) {\n\n    const readVertex = this.makeReadVertexFunc(geometry);\n    const va = readVertex(edge.a);\n    const vb = readVertex(edge.b);\n\n    const edgeGeom = new THREE.Geometry();\n    edgeGeom.vertices.push(va, vb);\n    return edgeGeom;\n  };\n\n  /**\n   * Find the closest edge next to the intersect point\n   *\n   * @param face -Face which is found by faceSnapping.\n   * @param intersectPoint -IntersectPoint between cast ray and face.\n   *\n   * @private\n   */\n  this.edgeSnapping = function (face, intersectPoint) {\n\n    const vertices = [];\n    const verticesLength = face.vertices.length;\n    var isEdge_12 = true;\n    var isEdge_13 = true;\n    var isEdge_23 = true;\n\n    for (var i = 0; i < verticesLength; i += 3) {\n      const pi0 = face.vertices[i];\n      const pi1 = face.vertices[i + 1];\n      const pi2 = face.vertices[i + 2];\n\n      for (var j = 0; j < verticesLength; j += 3) {\n        if (i !== j) {\n          const pj0 = face.vertices[j];\n          const pj1 = face.vertices[j + 1];\n          const pj2 = face.vertices[j + 2];\n          // Check edge 12\n          if ((pi0.equals(pj0) || pi0.equals(pj1) || pi0.equals(pj2)) && (\n          pi1.equals(pj0) || pi1.equals(pj1) || pi1.equals(pj2))) {\n            isEdge_12 = false;\n          }\n          // Check edge 13\n          // Check edge 12\n          if ((pi0.equals(pj0) || pi0.equals(pj1) || pi0.equals(pj2)) && (\n          pi2.equals(pj0) || pi2.equals(pj1) || pi2.equals(pj2))) {\n            isEdge_13 = false;\n          }\n          // Check edge 23\n          // Check edge 12\n          if ((pi1.equals(pj0) || pi1.equals(pj1) || pi1.equals(pj2)) && (\n          pi2.equals(pj0) || pi2.equals(pj1) || pi2.equals(pj2))) {\n            isEdge_23 = false;\n          }\n        }\n      }\n\n      if (isEdge_12) {\n        vertices.push(pi0.clone());\n        vertices.push(pi1.clone());\n      }\n      if (isEdge_13) {\n        vertices.push(pi0.clone());\n        vertices.push(pi2.clone());\n      }\n      if (isEdge_23) {\n        vertices.push(pi1.clone());\n        vertices.push(pi2.clone());\n      }\n\n      isEdge_12 = true;\n      isEdge_13 = true;\n      isEdge_23 = true;\n\n    }\n\n    //return lineGeom;\n\n    const edgeVertices = [];\n    const edgeGeom = new THREE.Geometry();\n    var minDistIndex;\n    var minDist = Number.MAX_VALUE;\n\n    for (var k = 0; k < vertices.length; k += 2) {\n\n      var dist = distancePointToLine(intersectPoint, vertices[k], vertices[k + 1]);\n\n      if (dist < minDist) {\n        minDist = dist;\n        minDistIndex = k;\n      }\n\n    }\n\n    edgeVertices.push(vertices[minDistIndex].clone());\n    edgeVertices.push(vertices[minDistIndex + 1].clone());\n\n    const lineGeom = new THREE.Geometry();\n    lineGeom.vertices = vertices;\n    edgeGeom.vertices = this.getConnectedLineSegmentsOnSameLine(lineGeom, edgeVertices);\n\n    _distanceToEdge = minDist;\n\n    return edgeGeom;\n  };\n\n  this.getConnectedLineSegmentsOnSameLine = function (lineGeom, edgeVertices) {\n\n    const vertices = lineGeom.vertices.slice();\n    var va = edgeVertices[0];\n    var vb = edgeVertices[1];\n\n    var vCount = [];\n\n    do {\n\n      vCount = [];\n\n      for (var j = 0; j < vertices.length; j += 2) {\n\n        // The line which has min distance to intersection point\n        if (vertices[j].equals(va) && vertices[j + 1].equals(vb)) {\n\n          continue;\n        }\n\n        for (var k = 0; k < edgeVertices.length; k += 2) {\n\n          // The line segments which are connected on the same line\n          if (vertices[j].equals(edgeVertices[k]) || vertices[j + 1].equals(edgeVertices[k]) ||\n          vertices[j].equals(edgeVertices[k + 1]) || vertices[j + 1].equals(edgeVertices[k + 1])) {\n\n            var V0 = new THREE.Vector3();\n            var V1 = new THREE.Vector3();\n\n            V0.subVectors(edgeVertices[k], edgeVertices[k + 1]);\n            V0.normalize();\n            V1.subVectors(vertices[j], vertices[j + 1]);\n            V1.normalize();\n\n            //if (V0.equals(V1) || V0.equals(V1.negate())) {\n            if (isEqualVectorsWithPrecision(V0, V1) || isInverseVectorsWithPrecision(V0, V1))\n            {\n\n              vCount.push(j);\n              break;\n\n            }\n          }\n        }\n      }\n\n      for (var ci = vCount.length - 1; ci >= 0; --ci) {\n\n        edgeVertices.push(vertices[vCount[ci]]);\n        edgeVertices.push(vertices[vCount[ci] + 1]);\n        vertices.splice(vCount[ci], 2);\n      }\n\n    } while (vCount.length > 0);\n\n    return edgeVertices;\n\n  };\n\n  this.vertexSnappingWithTopology = function (edge, intersectPoint) {\n\n    var minDist = Number.MAX_VALUE;\n    var point = new THREE.Vector3();\n    if (!edge) {\n      return point;\n    }\n\n    if (edge.vertices.length > 1) {\n      const start = edge.vertices[0];\n      const end = edge.vertices[edge.vertices.length - 1];\n      var dist1 = intersectPoint.distanceTo(start);\n      var dist2 = intersectPoint.distanceTo(end);\n\n      if (dist1 <= dist2) {\n        minDist = dist1;\n        point = start.clone();\n      } else\n      {\n        minDist = dist2;\n        point = end.clone();\n      }\n    }\n\n    _distanceToVertex = minDist;\n\n    return point;\n  };\n\n  /**\n   * Find the closest vertex next to the intersect point\n   *\n   * @param edge -Edge which is found by edgeSnapping.\n   * @param intersectPoint -IntersectPoint between cast ray and face.\n   *\n   * @private\n   */\n  this.vertexSnapping = function (edge, intersectPoint) {\n\n    var minDist = Number.MAX_VALUE;\n    var point = new THREE.Vector3();\n    const verticesLength = edge.vertices.length;\n\n    for (let i = 0; i < verticesLength; ++i) {\n      const pt = edge.vertices[i];\n      const dist = intersectPoint.distanceTo(pt);\n\n      if (dist < minDist - SNAP_PRECISION) {\n\n        minDist = dist;\n        point = pt.clone();\n\n      }\n    }\n\n    _distanceToVertex = minDist;\n\n    return point;\n  };\n\n  // This is only a workaround to detect if an edge is circle\n  this.edgeIsCircle = function (edge) {\n\n    const vertices = edge.vertices;\n\n    // Exclude squares and regular polygons\n    if (vertices.length < 8) {\n      return false;\n    }\n\n    const start = vertices[0];\n    const end = vertices[vertices.length - 1];\n\n    if (start.equals(end)) {\n\n      var center = new THREE.Vector3(0, 0, 0);\n      for (let i = 0; i < vertices.length; i += 2) {\n        center.add(vertices[i]);\n      }\n      center.divideScalar(vertices.length / 2.0);\n\n      var radius = center.distanceTo(start);\n      for (let i = 0; i < vertices.length; i += 2) {\n        if (Math.abs(center.distanceTo(vertices[i]) - radius) <= SNAP_PRECISION) {\n          continue;\n        } else\n        {\n          return false;\n        }\n      }\n      return center;\n    } else\n    {\n      return false;\n    }\n  };\n\n  this.edgeIsCurved = function (edge) {\n\n    const vertices = edge.vertices;\n    const start = vertices[0];\n    const end = vertices[vertices.length - 1];\n\n    if (vertices.length <= 2) {\n      return false;\n    } else\n    if (start.equals(end)) {\n      return true;\n    } else\n    {\n      var V1 = new THREE.Vector3();\n      let pi0;\n      let pi1 = vertices[1];\n\n      V1.subVectors(start, pi1);\n\n      var V2 = new THREE.Vector3();\n      for (var i = 2; i < vertices.length; i += 2) {\n        pi0 = vertices[i];\n        pi1 = vertices[i + i];\n        V2.subVectors(pi0, pi1);\n        if (!isEqualVectorsWithPrecision(V1, V2)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  };\n\n  /**\n   * Checks if the given geometry is curved\n   * @param {THREE.BufferGeometry} face The geometry\n   * @returns {boolean} True if the any of the faces composing the geometry is curved\n   */\n  this.faceIsCurved = function (face) {\n\n    const vertices = face.vertices;\n    const faces = face.faces;\n\n    if (faces.length <= 1) {return false;}\n\n    var fN1 = new THREE.Vector3();\n    const vA1 = vertices[faces[0].a];\n    THREE.Triangle.getNormal(vertices[faces[0].a], vertices[faces[0].b], vertices[faces[0].c], fN1);\n\n    var fN2 = new THREE.Vector3();\n    for (let i = 1; i < faces.length; i++) {\n      const vA2 = vertices[faces[i].a];\n      THREE.Triangle.getNormal(vertices[faces[i].a], vertices[faces[i].b], vertices[faces[i].c], fN2);\n      if (!isEqualVectorsWithPrecision(fN1, fN2) || !isEqualWithPrecision(fN1.dot(vA1), fN2.dot(vA2))) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  this.angleVector2 = function (vector) {\n\n    if (vector.x > 0 && vector.y >= 0) {\n      return Math.atan(vector.y / vector.x);\n    } else\n    if (vector.x >= 0 && vector.y < 0) {\n      return Math.atan(vector.y / vector.x) + Math.PI * 2;\n    } else\n    if (vector.x < 0 && vector.y <= 0) {\n      return Math.atan(vector.y / vector.x) + Math.PI;\n    } else\n    if (vector.x <= 0 && vector.y > 0) {\n      return Math.atan(vector.y / vector.x) + Math.PI;\n    } else\n    {// x = 0, y = 0\n      return null;\n    }\n  };\n\n  // Creates a THREE.Geometry that represents an approximation of a given elliptical arc in {z=0} plane.\n  // Points are obtained by by uniform sampling of a given elliptical arc.\n  //  @param {number} numPoints - The length number of points that the output geometry will contain. segments in which we subdivide the arc. Resulting point count is numSegments+1.\n  // See getEllipseArcPoint() for param details.\n  const createEllipticalArcGeometry = (cx, cy, rx, ry, startAngle, endAngle, numPoints) => {\n    let geometry = new THREE.Geometry();\n    for (let i = 0; i < numPoints; i++) {\n      const p = new THREE.Vector3(0, 0, 0);\n      const t = i / (numPoints - 1);\n      Autodesk.Extensions.CompGeom.getEllipseArcPoint(t, cx, cy, rx, ry, startAngle, endAngle, 0.0, p);\n      geometry.vertices.push(p);\n    }\n    return geometry;\n  };\n\n  /**\n   * @param {Viewer3D} viewer - Viewer instance\n   * @param snapper\n   * @param aDetectRadius\n   * @private\n   */\n  function GeometryCallback(viewer, snapper, aDetectRadius) {\n    this.viewer = viewer;\n    this.snapper = snapper;\n\n    this.lineGeom = new THREE.Geometry();\n    this.circularArc = null;\n    this.circularArcCenter;\n    this.circularArcRadius;\n    this.ellipticalArc = null;\n    this.ellipticalArcCenter;\n\n    this.minDist = Number.MAX_VALUE;\n\n    this.matrix = new THREE.Matrix4();\n\n    this.vpIdLine = null;\n    this.vpIdCircular = null;\n    this.vpIdElliptical = null;\n\n    this.detectRadius = aDetectRadius;\n\n    // Collects candidate segments that we can snap to.\n    // This is used to allow snapping to segment intersections.\n    this.snapCandidates = []; // {SnappingCandidate[]}\n  }\n\n  GeometryCallback.prototype.onLineSegment = function (x1, y1, x2, y2, vpId) {\n    var intersectPoint = this.snapper.getIntersectPoint();\n    var v1 = new THREE.Vector3(x1, y1, intersectPoint.z);\n    var v2 = new THREE.Vector3(x2, y2, intersectPoint.z);\n\n    // LMV-5515: Apply the supplied matrix to the line vector's\n    if (this.matrix) {\n      v1.applyMatrix4(this.matrix);\n      v2.applyMatrix4(this.matrix);\n    }\n\n    // Skip segments outside detectRadius\n    var dist = distancePointToLine(intersectPoint, v1, v2);\n    if (dist > this.detectRadius) {\n      return;\n    }\n\n    // Collect snap candidate\n    this.snapCandidates.push(new SnapCandidate(vpId, dist).fromLine(v1, v2));\n\n    // Track minDist and lineGeometry for best hit so far\n    if (dist < this.minDist) {\n      this.lineGeom.vertices.splice(0, 2, v1, v2);\n      this.minDist = dist;\n\n      this.vpIdLine = vpId;\n    }\n  };\n\n  GeometryCallback.prototype.onCircularArc = function (cx, cy, start, end, radius, vpId) {\n    var intersectPoint = this.snapper.getIntersectPoint();\n    var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n    var center = new THREE.Vector2(cx, cy);\n    point.sub(center);\n\n    // Compute closest point on arc\n    const pointOnArc = (0,_SnapMath_js__WEBPACK_IMPORTED_MODULE_1__.nearestPointOnCircularArc)(intersectPoint, center, radius, start, end);\n    const dist = pointOnArc.distanceTo(intersectPoint); // 2D distance\n\n    // Collect snap candidate\n    this.snapCandidates.push(new SnapCandidate(vpId, dist).fromCircularArc(center, radius, start, end));\n\n    // Skip arcs outside detectRadius\n    if (dist > this.detectRadius) {\n      return;\n    }\n\n    // TODO: get rid of the CircleGeometry stuff below, because we computed the snapPoint above already.\n    //       But this needs some refactoring, because the Geometry is passed around outside of snapper.\n\n    var angle = this.snapper.angleVector2(point);\n\n    let arc;\n    if (end > start && angle >= start && angle <= end) {\n      arc = new THREE.CircleGeometry(radius, 100, start, end - start);\n    } else\n    if (end < start && (angle >= start || angle <= end)) {\n      arc = new THREE.CircleGeometry(radius, 100, start, Math.PI * 2 - start + end);\n    } else\n    {\n      return;\n    }\n\n    arc.vertices.splice(0, 1);\n\n    arc.applyMatrix4(new THREE.Matrix4().makeTranslation(cx, cy, intersectPoint.z));\n    this.circularArc = arc;\n    this.circularArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n    this.circularArcRadius = radius;\n\n    this.snapPoint = new THREE.Vector3(pointOnArc.x, pointOnArc.y, intersectPoint.z);\n\n    this.vpIdCircular = vpId;\n  };\n\n  GeometryCallback.prototype.onEllipticalArc = function (cx, cy, start, end, major, minor, tilt, vpId) {\n    var intersectPoint = this.snapper.getIntersectPoint();\n    var point = new THREE.Vector2(intersectPoint.x, intersectPoint.y);\n\n    var major1 = major - this.detectRadius;\n    var minor1 = minor - this.detectRadius;\n    var major2 = major + this.detectRadius;\n    var minor2 = minor + this.detectRadius;\n\n    var equation1 = (point.x - cx) * (point.x - cx) / (major1 * major1) + (point.y - cy) * (point.y - cy) / (minor1 * minor1);\n    var equation2 = (point.x - cx) * (point.x - cx) / (major2 * major2) + (point.y - cy) * (point.y - cy) / (minor2 * minor2);\n\n    var center = new THREE.Vector2(cx, cy);\n    point.sub(center);\n    point.x *= minor;\n    point.y *= major;\n    var angle = this.snapper.angleVector2(point);\n\n    if (end > Math.PI * 2) {\n      end = Math.PI * 2;\n    }\n\n    if (equation1 >= 1 && equation2 <= 1) {\n\n      if (end > start && angle >= start && angle <= end || end < start && (angle >= start || angle <= end)) {\n        var arc = createEllipticalArcGeometry(cx, cy, major, minor, start, end, 50);\n        if (!isEqualWithPrecision(end - start, Math.PI * 2))\n        {\n          arc.vertices.pop();\n        }\n        arc.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0, intersectPoint.z));\n\n        // Compute distance between geometry and snapped point.\n        // We use the same way here as in getSnapResultPosition(). This will be replaced later by a more accurate solution.\n        const nearestPoint = MeasureCommon.nearestVertexInVertexToEdge(intersectPoint, arc);\n        const dist = THREE.Vector2.prototype.distanceTo.call(nearestPoint, intersectPoint); // only in x/y\n\n        // Collect snap candidate\n        const center = new THREE.Vector2(cx, cy);\n        this.snapCandidates.push(new SnapCandidate(vpId, dist).makeEllipticalArc(center, major, minor, start, end));\n\n        // Todo: Unlike for line-segments, arcs are currently collected by \"last one wins\" rule by the code for single-snapping.\n        //       We should consider the distance here as well.\n        this.ellipticalArc = arc;\n        this.ellipticalArcCenter = new THREE.Vector3(cx, cy, intersectPoint.z);\n\n        this.vpIdElliptical = vpId;\n      }\n    }\n  };\n\n  /**\n   * This method sets the matrix to identity if matrix is not supplied;\n   *\n   * @param {THREE.Matrix4} matrix - Matrix to set\n   */\n  GeometryCallback.prototype.setMatrix = function (matrix) {\n    this.matrix = matrix || new THREE.Matrix4();\n  };\n\n  /**\n   * Snap to a 2D model.\n   *\n   * @param {object}      hitResult - a result of a ray intersection.\n   * @param {object}      [options] - Options object.\n   * @param {Function}    [options.enumSegments] - Enumerates all segments within a given bbox in model-space.\n   *\n   */\n  this.snapping2D = function (hitResult) {let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!hitResult) {\n      return;\n    }\n\n    // hitResult is a result of a ray intersection. it may contain the following:\n    let {\n      dbId,\n      fragId,\n      intersectPoint,\n      model = _viewer.model\n    } = hitResult;\n\n    if (model.is3d()) {\n      return;\n    }\n    _snapResult.modelId = hitResult.model ? hitResult.model.id : null;\n    _snapResult.hasTopology = false;\n    _snapResult.intersectPoint = intersectPoint;\n\n    let tr,scale = 1;\n\n    // The model that we are trying to snap is 2D, but the viewer is 3D. It means that we are in hypermodeling scenario!\n    // For that, we'll need to apply the inversed transform of the 2D model to the intersect point first, in order to get it in local model coords.\n    if (!_viewer.impl.is2d) {\n      tr = model.getModelToViewerTransform();\n      // If there's a transform, move point to original location in sheet (will be restored at the end)\n      if (tr) {\n        scale = tr.getMaxScaleOnAxis();\n        _snapResult.intersectPoint = intersectPoint.clone();\n        _snapResult.intersectPoint.applyMatrix4(model.getInverseModelToViewerTransform());\n      }\n    }\n\n    // Determine which one should be drawn: line, circular arc or elliptical arc\n    // Use the un-transformed point, but scale down the radius because we are comparing with the unscaled geometry\n    _snapResult.radius = this.setDetectRadius(intersectPoint) / scale;\n\n    // Geometry snapping is only possible if a fragment list is available to obtain geometry per fragment.\n    var supportsGeomSnapping = model.getFragmentList() != null;\n    if (!supportsGeomSnapping) {\n\n      // If no snapping is available, just accept the hitpoint as a vertex hit. This allows to measure\n      // distances between arbitrary points in rasters.\n      _isSnapped = true;\n      _snapResult.geomType = SnapType.SNAP_VERTEX;\n      _snapResult.geomVertex = intersectPoint; // Use the un-transformed point\n      tr && _snapResult.intersectPoint.applyMatrix4(tr); // Restore to original location\n      return;\n    }\n\n\n    var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n    // Performs 2D snapping to segments based on an enumSegments() callback, which enumerates all segments\n    // within in a given bbox in model-space.\n    if (options.enumSegments) {\n      // enum all segments within the snapRadius around intersectPoint\n      const minx = _snapResult.intersectPoint.x - _snapResult.radius;\n      const miny = _snapResult.intersectPoint.y - _snapResult.radius;\n      const maxx = _snapResult.intersectPoint.x + _snapResult.radius;\n      const maxy = _snapResult.intersectPoint.y + _snapResult.radius;\n\n      options.enumSegments(minx, miny, maxx, maxy, gc);\n    } else {\n      // Regular snapping - snap to the 2D model's geometry.\n      var fragIds = fragId;\n\n      if (typeof fragIds === \"undefined\") {\n        // LMV-6082 Do not return out if the snap to pixel flag (free measure) is enabled.\n        if (!_snapToPixel) {\n          return;\n        }\n        fragIds = [];\n      } else if (!Array.isArray(fragIds)) {\n        fragIds = [fragIds];\n      }\n\n      for (var fi = 0; fi < fragIds.length; ++fi) {\n        const mesh = _viewer.impl.getRenderProxy(model, fragIds[fi]);\n        if (mesh !== null && mesh !== void 0 && mesh.geometry) {\n          gc.setMatrix(mesh.matrix);\n          const vbr = new VertexBufferReader(mesh.geometry);\n          vbr.enumGeomsForObject(model.reverseMapDbIdFor2D(dbId), gc);\n          // Set the matrix back to identity after processing a mesh\n          gc.setMatrix();\n        }\n      }\n    }\n\n    // _snapResult.intersectPoint contains the possibly transformed point\n    this.finishSnapping2D(gc, _snapResult.intersectPoint);\n\n    // Snap the unsnapped point only if the snapping fails\n    if (!_isSnapped && _snapToPixel) {\n      _isSnapped = true;\n      _snapResult.geomType = SnapType.RASTER_PIXEL;\n      _snapResult.geomVertex = _snapResult.intersectPoint;\n    }\n\n    // Now apply the transform matrix on the results, so we'll get the results in their final transformed position.\n    if (tr) {var _snapResult$geomEdge, _snapResult$geomEdge2;\n      const start = (_snapResult$geomEdge = _snapResult.geomEdge) === null || _snapResult$geomEdge === void 0 ? void 0 : _snapResult$geomEdge.vertices[0];\n      const end = (_snapResult$geomEdge2 = _snapResult.geomEdge) === null || _snapResult$geomEdge2 === void 0 ? void 0 : _snapResult$geomEdge2.vertices[1];\n\n      let results = [_snapResult.snapPoint, _snapResult.geomVertex, _snapResult.intersectPoint, _snapResult.circularArcCenter,\n      start, end];\n      // Remove undefined and possibly shared vectors\n      results = [...new Set(results.filter((n) => n))];\n      results.forEach((res) => res.applyMatrix4(tr));\n      if (_snapResult.circularArcRadius) {\n        _snapResult.circularArcRadius *= scale;\n      }\n      _snapResult.radius *= scale;\n    }\n  };\n\n  // By default, snapper only considers model geometry that is written to ID buffer.\n  // This function performs the 2D snapping on a set of given 2D meshes instead. It works similar to snapping2D() but\n  // enumerates the given meshes instead of getting them from the fragment list.\n  //\n  //  @param {THREE.Vector3}                 intersectPoint - click position in world-coords\n  //  @param {function(dbId, layerId, vpId)} filter - Defines subset of primitives to be considered.\n  //  @param {THREE.Mesh[]}                  meshes - The triangulated 2D shapes to be checked for snapping\n  //  @param {number}                        [detectRadius] - Same coordinate system as the given geometry. Required if geometry is not in world-coords.\n\n  this.snapping2DOverlay = function (intersectPoint, meshes, filter, detectRadius) {\n    _snapResult.hasTopology = false;\n    _snapResult.intersectPoint = intersectPoint;\n    _snapResult.radius = detectRadius || this.setDetectRadius(intersectPoint);\n\n    var gc = new GeometryCallback(_viewer, this, _snapResult.radius);\n\n    for (var i = 0; i < meshes.length; i++) {\n      var mesh = meshes[i];\n      var vbr = new VertexBufferReader(mesh.geometry);\n      vbr.enumGeoms(filter, gc);\n    }\n\n    this.finishSnapping2D(gc, intersectPoint);\n  };\n\n  // Finish 2D snapping operation - assuming that all candidate geometry for snapping has been processed by the geometryCallback gc already.\n  this.finishSnapping2D = function (gc, intersectPoint) {\n\n    // When restricting to a single viewport, exclude candidates of all other viewports\n    if (_forcedVpId !== null) {\n      const isSameViewport = (c) => c.viewportId === _forcedVpId;\n      gc.snapCandidates = gc.snapCandidates.filter(isSameViewport);\n    }\n\n    // Check if we can snap to an intersection of two close segments\n    const intersectSnap = findIntersectionSnap(gc.snapCandidates, intersectPoint, gc.detectRadius);\n    if (intersectSnap) {\n      _snapResult.viewportIndex2d = intersectSnap.viewportId;\n      _snapResult.snapPoint = intersectSnap.snapPoint;\n      _snapResult.geomType = SnapType.SNAP_INTERSECTION;\n      _snapResult.geomVertex = intersectSnap.snapPoint;\n      _isSnapped = true;\n      return;\n    }\n\n    if (gc.circularArc) {\n\n      _snapResult.viewportIndex2d = gc.vpIdCircular;\n\n      _snapResult.snapPoint = gc.snapPoint;\n\n      // Only snap the geometries which belong to the same viewport as the first selection\n      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n      return;\n\n      const start = gc.circularArc.vertices[0];\n      const end = gc.circularArc.vertices[gc.circularArc.vertices.length - 1];\n\n      if (intersectPoint.distanceTo(start) < _snapResult.radius) {\n\n        _snapResult.geomVertex = start;\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if (intersectPoint.distanceTo(end) < _snapResult.radius) {\n\n        _snapResult.geomVertex = end;\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      {\n\n        this.lineStripToPieces(gc.circularArc);\n        _snapResult.geomEdge = gc.circularArc;\n        _snapResult.circularArcCenter = gc.circularArcCenter;\n        _snapResult.circularArcRadius = gc.circularArcRadius;\n        _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n      }\n\n      _isSnapped = true;\n\n\n    } else\n    if (gc.ellipticalArc) {\n\n      _snapResult.viewportIndex2d = gc.vpIdElliptical;\n\n      // Only snap the geometries which belong to the same viewport as the first selection\n      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n      return;\n\n      const start = gc.ellipticalArc.vertices[0];\n      const end = gc.ellipticalArc.vertices[gc.ellipticalArc.vertices.length - 1];\n      if (intersectPoint.distanceTo(start) < _snapResult.radius) {\n\n        _snapResult.geomVertex = start;\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      if (intersectPoint.distanceTo(end) < _snapResult.radius) {\n\n        _snapResult.geomVertex = end;\n        _snapResult.geomType = SnapType.SNAP_VERTEX;\n      } else\n      {\n\n        this.lineStripToPieces(gc.ellipticalArc);\n        _snapResult.geomEdge = gc.ellipticalArc;\n        // Before we have measure design for elliptical arc, measure the center for now\n        _snapResult.circularArcCenter = gc.ellipticalArcCenter;\n        _snapResult.circularArcRadius = null;\n        _snapResult.geomType = SnapType.SNAP_CIRCULARARC;\n      }\n\n      _isSnapped = true;\n\n    } else\n    if (gc.lineGeom instanceof THREE.Geometry && gc.lineGeom.vertices.length ||\n    gc.lineGeom.getAttribute && gc.lineGeom.getAttribute('position').count) {\n\n      _snapResult.viewportIndex2d = gc.vpIdLine;\n\n      // Only snap the geometries which belong to the same viewport as the first selection\n      if (_forcedVpId !== null && _forcedVpId !== _snapResult.viewportIndex2d)\n      return;\n\n      // Always expose edge segment - no matter whether we snap to the edge or one of its vertices.\n      // This allows us to combine it with other snap constraints later - as done by Edit2D.\n      _snapResult.geomEdge = gc.lineGeom;\n      const start = gc.lineGeom.vertices[0];\n      const end = gc.lineGeom.vertices[1];\n\n      if (this.markupMode) {// Markup mode\n        var mid = new THREE.Vector3();\n        mid.addVectors(start, end);\n        mid.divideScalar(2);\n        var md = intersectPoint.distanceTo(mid);\n        var sd = intersectPoint.distanceTo(start);\n        var ed = intersectPoint.distanceTo(end);\n\n        // Store it for snapping to parallel/perpendicular of underlying vectors\n        _snapResult.geomEdge = gc.lineGeom;\n\n        if (md < _snapResult.radius) {\n          _snapResult.geomVertex = mid;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        if (sd < _snapResult.radius) {\n          _snapResult.geomVertex = start;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        if (ed < _snapResult.radius) {\n          _snapResult.geomVertex = end;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n\n        // Circle center\n        if (start.distanceTo(end) < EPSILON) {\n          _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n        }\n      } else\n      {// Measure mode\n        if (intersectPoint.distanceTo(start) < _snapResult.radius) {\n\n          if (start.distanceTo(end) < EPSILON) {\n            _snapResult.geomType = SnapType.SNAP_CIRCLE_CENTER;\n          } else {\n            _snapResult.geomType = SnapType.SNAP_VERTEX;\n          }\n\n          _snapResult.geomVertex = start;\n        } else\n        if (_options.forceSnapVertices || intersectPoint.distanceTo(end) < _snapResult.radius) {\n\n          _snapResult.geomVertex = end;\n          _snapResult.geomType = SnapType.SNAP_VERTEX;\n        } else\n        {\n          _snapResult.geomType = SnapType.SNAP_EDGE;\n        }\n      }\n\n      _isSnapped = true;\n    }\n  };\n\n  this.snappingRasterPixel = function (result) {\n    if (!result) {\n      return;\n    }\n\n    var intersectPoint = result.intersectPoint;\n    _snapResult.intersectPoint = intersectPoint;\n    _snapResult.hasTopology = false;\n\n    // Determine which one should be drawn: line, circular arc or elliptical arc\n    _snapResult.radius = this.setDetectRadius(intersectPoint);\n    _snapResult.geomType = SnapType.RASTER_PIXEL;\n    _snapResult.geomVertex = intersectPoint;\n    _isSnapped = true;\n  };\n\n  this.snapMidpoint = function () {\n    _snapResult.isMidpoint = false;\n\n    // Snap midpoint for edge\n    if (_isSnapped) {\n      if (_snapResult.geomType === SnapType.SNAP_EDGE) {\n        const edge = _snapResult.geomEdge;\n        const p1 = edge.vertices[0];\n        const p2 = edge.vertices[1];\n\n        var midpoint = new THREE.Vector3((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2);\n\n        var cutPlanes = _viewer.impl.getAllCutPlanes();\n        if (cutPlanes !== null && cutPlanes !== void 0 && cutPlanes.length) {\n          for (let i = 0; i < cutPlanes.length; ++i) {\n            const p = cutPlanes[i];\n            const dot = midpoint.x * p.x + midpoint.y * p.y + midpoint.z * p.z + p.w;\n            if (dot > 1e-5) {\n              // discard midpoint if clipped\n              return;\n            }\n          }\n        }\n\n        if (_snapResult.intersectPoint.distanceTo(midpoint) < 2 * _snapResult.radius) {\n          _snapResult.geomVertex = midpoint;\n          _snapResult.geomType = SnapType.SNAP_MIDPOINT;\n        }\n      }\n    }\n  };\n\n  this.setPerpendicular = function (isPerpendicular) {\n    _snapResult.isPerpendicular = isPerpendicular;\n  };\n\n  this.lineStripToPieces = function (geom) {\n    const vertices = geom.vertices;\n    for (var i = vertices.length - 2; i > 0; i--) {\n      vertices.splice(i, 0, vertices[i]);\n    }\n  };\n\n  this.setDetectRadius = function (point) {\n\n    var navapi = _viewer.navigation;\n    var camera = navapi.getCamera();\n    var position = navapi.getPosition();\n\n    var p = point.clone();\n\n    var distance = camera.isPerspective ? p.sub(position).length() :\n    navapi.getEyeVector().length();\n\n    var fov = navapi.getVerticalFov();\n    var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n    var viewport = navapi.getScreenViewport();\n    var _window = this.getWindow();\n    var devicePixelRatio = _window.devicePixelRatio || 1;\n    var radius = this.detectRadiusInPixels * worldHeight / (viewport.height * devicePixelRatio);\n\n    return radius;\n  };\n\n  this.handleButtonDown = function () {\n    _isDragging = true;\n    return false;\n  };\n\n  this.handleButtonUp = function () {\n    _isDragging = false;\n    return false;\n  };\n\n  this.handleMouseMove = function (event) {\n\n    if (_isDragging)\n    return false;\n\n    this.onMouseMove({\n      x: event.canvasX,\n      y: event.canvasY\n    });\n\n    return false;\n  };\n\n  this.handleSingleTap = function (event) {\n\n    return this.handleMouseMove(event);\n  };\n\n  this.handlePressHold = function (event) {\n\n    if (av.isMobileDevice()) {\n      switch (event.type) {\n\n        case \"press\":\n          _isPressing = true;\n          this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n          break;\n\n        case \"pressup\":\n          this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n          _isPressing = false;\n          break;\n      }\n    }\n    return false;\n\n  };\n\n  this.handleGesture = function (event)\n  {\n    if (av.isMobileDevice()) {\n      if (_isPressing) {\n        switch (event.type) {\n\n          case \"dragstart\":\n          case \"dragmove\":\n            this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n            break;\n\n          case \"dragend\":\n            this.onMouseMove({ x: event.canvasX, y: event.canvasY });\n            _isPressing = false;\n            break;\n\n          case \"pinchstart\":\n          case \"pinchmove\":\n          case \"pinchend\":\n            break;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  /**\n   * Handler to mouse move events, used to snap in markup edit mode.\n   *\n   * @param mousePosition\n   * @private\n   */\n  this.onMouseDown = function (mousePosition) {\n    return this.onMouseMove(mousePosition);\n  };\n\n  /**\n   * Handler to mouse move events, used to snap in markup edit mode.\n   *\n   * @param mousePosition\n   * @private\n   */\n  this.onMouseMove = function (mousePosition) {var _result$model, _viewer$model;\n\n    this.clearSnapped();\n\n    var result = _viewer.impl.snappingHitTest(mousePosition.x, mousePosition.y, false);\n\n    if (!result && _snapToPixel) {\n      var vpVec = _viewer.impl.clientToViewport(mousePosition.x, mousePosition.y);\n      let point = _viewer.impl.intersectGroundViewport(vpVec);\n      result = { intersectPoint: point };\n    }\n\n    if (!result || !result.intersectPoint)\n    return false;\n\n    const isLeaflet = ((_result$model = result.model) === null || _result$model === void 0 ? void 0 : _result$model.isLeaflet()) || _viewer.impl.is2d && ((_viewer$model = _viewer.model) === null || _viewer$model === void 0 ? void 0 : _viewer$model.isLeaflet());\n    // 3D Snapping\n    if (result.face) {\n      this.snapping3D(result);\n    }\n    // 2D Snapping\n    else if ((result.dbId || result.dbId === 0) && !isLeaflet) {\n      this.snapping2D(result);\n    }\n    // Pixel Snapping\n    else {\n      const isPixelSnap = _snapToPixel || isLeaflet;\n      if (isPixelSnap) {\n        this.snappingRasterPixel(result);\n      }\n    }\n\n    this.snapMidpoint();\n\n    if (_snapFilter && !_snapFilter(_snapResult)) {\n      this.clearSnapped();\n      return false;\n    }\n\n    return true;\n  };\n}\n\nav.GlobalManagerMixin.call(Snapper.prototype);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1NuYXBwaW5nL1NuYXBwZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUMrRTtBQUNMOztBQUUxRSxNQUFNSSxhQUFhLEdBQUdDLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDRixhQUFhO0FBQ3BELE1BQU1HLE9BQU8sR0FBR0gsYUFBYSxDQUFDRyxPQUFPO0FBQ3JDLE1BQU1DLFFBQVEsR0FBR0osYUFBYSxDQUFDSSxRQUFRO0FBQ3ZDLE1BQU1DLFVBQVUsR0FBR0wsYUFBYSxDQUFDSyxVQUFVOztBQUUzQyxJQUFJQyxjQUFjLEdBQUcsS0FBSzs7QUFFMUIsTUFBTUMsRUFBRSxHQUFHTixRQUFRLENBQUNDLE9BQU87QUFDM0IsTUFBTU0sR0FBRyxHQUFHRCxFQUFFLENBQUNFLE9BQU87QUFDdEIsTUFBTUMsa0JBQWtCLEdBQUdGLEdBQUcsQ0FBQ0Usa0JBQWtCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0Msb0JBQW9CQSxDQUFDQyxDQUFDLEVBQUVDLENBQUMsRUFBRTtFQUNoQyxPQUFPQyxJQUFJLENBQUNDLEdBQUcsQ0FBQ0gsQ0FBQyxHQUFHQyxDQUFDLENBQUMsSUFBSVAsY0FBYztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNVLDJCQUEyQkEsQ0FBQ0MsRUFBRSxFQUFFQyxFQUFFLEVBQUU7RUFDekMsT0FBT0osSUFBSSxDQUFDQyxHQUFHLENBQUNFLEVBQUUsQ0FBQ0UsQ0FBQyxHQUFHRCxFQUFFLENBQUNDLENBQUMsQ0FBQyxJQUFJYixjQUFjO0VBQ3ZDUSxJQUFJLENBQUNDLEdBQUcsQ0FBQ0UsRUFBRSxDQUFDRyxDQUFDLEdBQUdGLEVBQUUsQ0FBQ0UsQ0FBQyxDQUFDLElBQUlkLGNBQWM7RUFDdkNRLElBQUksQ0FBQ0MsR0FBRyxDQUFDRSxFQUFFLENBQUNJLENBQUMsR0FBR0gsRUFBRSxDQUFDRyxDQUFDLENBQUMsSUFBSWYsY0FBYztBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNnQiw2QkFBNkJBLENBQUNMLEVBQUUsRUFBRUMsRUFBRSxFQUFFO0VBQzNDLE9BQU9KLElBQUksQ0FBQ0MsR0FBRyxDQUFDRSxFQUFFLENBQUNFLENBQUMsR0FBR0QsRUFBRSxDQUFDQyxDQUFDLENBQUMsSUFBSWIsY0FBYztFQUN2Q1EsSUFBSSxDQUFDQyxHQUFHLENBQUNFLEVBQUUsQ0FBQ0csQ0FBQyxHQUFHRixFQUFFLENBQUNFLENBQUMsQ0FBQyxJQUFJZCxjQUFjO0VBQ3ZDUSxJQUFJLENBQUNDLEdBQUcsQ0FBQ0UsRUFBRSxDQUFDSSxDQUFDLEdBQUdILEVBQUUsQ0FBQ0csQ0FBQyxDQUFDLElBQUlmLGNBQWM7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTaUIsbUJBQW1CQSxDQUFDQyxLQUFLLEVBQUVDLFNBQVMsRUFBRUMsT0FBTyxFQUFFOztFQUVwRCxJQUFJRCxTQUFTLENBQUNFLE1BQU0sQ0FBQ0QsT0FBTyxDQUFDLEVBQUUsQ0FBRTtJQUM3QixPQUFPRixLQUFLLENBQUNJLFVBQVUsQ0FBQ0gsU0FBUyxDQUFDO0VBQ3RDOztFQUVBLElBQUlJLEVBQUUsR0FBRyxJQUFJQyxLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDO0VBQzVCLElBQUlDLEVBQUUsR0FBRyxJQUFJRixLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDO0VBQzVCLElBQUlFLFFBQVE7RUFDWixJQUFJQyxLQUFLOztFQUVUTCxFQUFFLENBQUNNLFVBQVUsQ0FBQ1YsU0FBUyxFQUFFRCxLQUFLLENBQUM7RUFDL0JRLEVBQUUsQ0FBQ0csVUFBVSxDQUFDVCxPQUFPLEVBQUVELFNBQVMsQ0FBQztFQUNqQ1MsS0FBSyxHQUFHTCxFQUFFLENBQUNPLEdBQUcsQ0FBQ0osRUFBRSxDQUFDO0VBQ2xCSCxFQUFFLENBQUNNLFVBQVUsQ0FBQ1QsT0FBTyxFQUFFRCxTQUFTLENBQUM7RUFDakNTLEtBQUssR0FBRyxDQUFDQSxLQUFLLEdBQUdMLEVBQUUsQ0FBQ08sR0FBRyxDQUFDUCxFQUFFLENBQUM7O0VBRTNCLElBQUlLLEtBQUssR0FBRyxDQUFDLEVBQUU7SUFDWEQsUUFBUSxHQUFHVCxLQUFLLENBQUNJLFVBQVUsQ0FBQ0gsU0FBUyxDQUFDO0VBQzFDLENBQUMsTUFBTSxJQUFJUyxLQUFLLEdBQUcsQ0FBQyxFQUFFO0lBQ2xCRCxRQUFRLEdBQUdULEtBQUssQ0FBQ0ksVUFBVSxDQUFDRixPQUFPLENBQUM7RUFDeEMsQ0FBQyxNQUFNO0lBQ0hHLEVBQUUsQ0FBQ00sVUFBVSxDQUFDWCxLQUFLLEVBQUVDLFNBQVMsQ0FBQztJQUMvQk8sRUFBRSxDQUFDRyxVQUFVLENBQUNYLEtBQUssRUFBRUUsT0FBTyxDQUFDO0lBQzdCRyxFQUFFLENBQUNRLEtBQUssQ0FBQ0wsRUFBRSxDQUFDO0lBQ1pBLEVBQUUsQ0FBQ0csVUFBVSxDQUFDVCxPQUFPLEVBQUVELFNBQVMsQ0FBQzs7SUFFakNRLFFBQVEsR0FBR25CLElBQUksQ0FBQ3dCLElBQUksQ0FBQ1QsRUFBRSxDQUFDTyxHQUFHLENBQUNQLEVBQUUsQ0FBQyxDQUFDLEdBQUdmLElBQUksQ0FBQ3dCLElBQUksQ0FBQ04sRUFBRSxDQUFDSSxHQUFHLENBQUNKLEVBQUUsQ0FBQyxDQUFDO0VBQzVEOztFQUVBLE9BQU9DLFFBQVE7QUFDbkI7O0FBRUEsTUFBTU0saUJBQWlCLEdBQUc7RUFDdEJDLE9BQU8sRUFBUSxDQUFDO0VBQ2hCQyxJQUFJLEVBQVcsQ0FBQztFQUNoQkMsV0FBVyxFQUFJLENBQUM7RUFDaEJDLGFBQWEsRUFBRTtBQUNuQixDQUFDOztBQUVEO0FBQ0EsTUFBTUMsYUFBYSxDQUFDO0VBQ2hCQyxXQUFXQSxDQUFDQyxVQUFVLEVBQUU7O0lBRXBCLElBQUksQ0FBQ0MsSUFBSSxHQUFHUixpQkFBaUIsQ0FBQ0MsT0FBTztJQUNyQyxJQUFJLENBQUNNLFVBQVUsR0FBR0EsVUFBVTs7SUFFNUI7SUFDQSxJQUFJLENBQUNiLFFBQVEsR0FBRyxDQUFDOztJQUVqQjtJQUNBLElBQUksQ0FBQ1IsU0FBUyxHQUFHLElBQUk7SUFDckIsSUFBSSxDQUFDQyxPQUFPLEdBQUssSUFBSTs7SUFFckI7SUFDQSxJQUFJLENBQUNzQixNQUFNLEdBQUcsQ0FBQzs7SUFFZjtJQUNBLElBQUksQ0FBQ0MsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2xCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLENBQUM7O0lBRWhCO0lBQ0EsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSTs7SUFFbEI7SUFDQSxJQUFJLENBQUNDLFVBQVUsR0FBRyxDQUFDO0lBQ25CLElBQUksQ0FBQ0MsUUFBUSxHQUFLLENBQUM7RUFDdkI7O0VBRUFDLFFBQVFBLENBQUNDLEVBQUUsRUFBRUMsRUFBRSxFQUFFO0lBQ2IsSUFBSSxDQUFDVCxJQUFJLEdBQUdSLGlCQUFpQixDQUFDRSxJQUFJO0lBQ2xDLElBQUksQ0FBQ2hCLFNBQVMsR0FBRzhCLEVBQUUsQ0FBQ0UsS0FBSyxDQUFDLENBQUM7SUFDM0IsSUFBSSxDQUFDL0IsT0FBTyxHQUFLOEIsRUFBRSxDQUFDQyxLQUFLLENBQUMsQ0FBQztJQUMzQixPQUFPLElBQUk7RUFDZjs7RUFFQUMsZUFBZUEsQ0FBQ1AsTUFBTSxFQUFFSCxNQUFNLEVBQUVXLEtBQUssRUFBRUMsR0FBRyxFQUFFO0lBQ3hDLElBQUksQ0FBQ2IsSUFBSSxHQUFLUixpQkFBaUIsQ0FBQ0csV0FBVztJQUMzQyxJQUFJLENBQUNTLE1BQU0sR0FBR0EsTUFBTSxDQUFDTSxLQUFLLENBQUMsQ0FBQztJQUM1QixJQUFJLENBQUNULE1BQU0sR0FBR0EsTUFBTTtJQUNwQixJQUFJLENBQUNXLEtBQUssR0FBSUEsS0FBSztJQUNuQixJQUFJLENBQUNDLEdBQUcsR0FBTUEsR0FBRztJQUNqQixPQUFPLElBQUk7RUFDZjs7RUFFQUMsaUJBQWlCQSxDQUFDVixNQUFNLEVBQUVGLE9BQU8sRUFBRUMsT0FBTyxFQUFFUyxLQUFLLEVBQUVDLEdBQUcsRUFBRTtJQUNwRCxJQUFJLENBQUNiLElBQUksR0FBR1IsaUJBQWlCLENBQUNJLGFBQWE7SUFDM0MsSUFBSSxDQUFDUSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ00sS0FBSyxDQUFDLENBQUM7SUFDNUIsSUFBSSxDQUFDUixPQUFPLEdBQUdBLE9BQU87SUFDdEIsSUFBSSxDQUFDQyxPQUFPLEdBQUdBLE9BQU87SUFDdEIsSUFBSSxDQUFDUyxLQUFLLEdBQUdBLEtBQUs7SUFDbEIsSUFBSSxDQUFDQyxHQUFHLEdBQUdBLEdBQUc7SUFDZCxPQUFPLElBQUk7RUFDZjs7RUFFQUUsTUFBTUEsQ0FBQSxFQUFZLENBQUUsT0FBTyxJQUFJLENBQUNmLElBQUksS0FBS1IsaUJBQWlCLENBQUNFLElBQUksQ0FBRTtFQUNqRXNCLGFBQWFBLENBQUEsRUFBSyxDQUFFLE9BQU8sSUFBSSxDQUFDaEIsSUFBSSxLQUFLUixpQkFBaUIsQ0FBQ3lCLFVBQVUsQ0FBRTtFQUN2RUMsZUFBZUEsQ0FBQSxFQUFHLENBQUUsT0FBTyxJQUFJLENBQUNsQixJQUFJLEtBQUtSLGlCQUFpQixDQUFDSSxhQUFhLENBQUU7O0VBRTFFO0VBQ0E7RUFDQTtFQUNBO0VBQ0F1QixlQUFlQSxDQUFDQyxLQUFLLEVBQUVDLGNBQWMsRUFBRTs7SUFFbkMsSUFBSSxJQUFJLENBQUNOLE1BQU0sQ0FBQyxDQUFDLElBQUlLLEtBQUssQ0FBQ0wsTUFBTSxDQUFDLENBQUMsRUFBRTtNQUNqQztNQUNBO01BQ0E7TUFDQTtNQUNBLE9BQU8vRCw0REFBYyxDQUFDLElBQUksQ0FBQzBCLFNBQVMsRUFBRSxJQUFJLENBQUNDLE9BQU8sRUFBRXlDLEtBQUssQ0FBQzFDLFNBQVMsRUFBRTBDLEtBQUssQ0FBQ3pDLE9BQU8sRUFBRSxLQUFLLEVBQUUwQyxjQUFjLENBQUM7SUFDOUc7O0lBRUE7RUFDSjtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLG9CQUFvQixHQUFHQSxDQUFDQyxVQUFVLEVBQUVDLGNBQWMsRUFBRUMsVUFBVSxLQUFLOztFQUVyRTtFQUNBO0VBQ0E7RUFDQTtFQUNBLE1BQU1DLFVBQVUsR0FBR0EsQ0FBQ0MsRUFBRSxFQUFFQyxFQUFFLEtBQUtELEVBQUUsQ0FBQ3pDLFFBQVEsR0FBRzBDLEVBQUUsQ0FBQzFDLFFBQVE7RUFDeERxQyxVQUFVLENBQUNNLElBQUksQ0FBQ0gsVUFBVSxDQUFDOztFQUUzQjtFQUNBLElBQUlILFVBQVUsQ0FBQ08sTUFBTSxHQUFHLENBQUMsRUFBRTtJQUN2QixPQUFPLElBQUk7RUFDZjs7RUFFQTtFQUNBLE1BQU1DLE1BQU0sR0FBRztJQUNYO0lBQ0FoQyxVQUFVLEVBQUV3QixVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUN4QixVQUFVOztJQUVwQztJQUNBO0lBQ0FpQyxTQUFTLEVBQUcsSUFBSWpELEtBQUssQ0FBQ0MsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUV3QyxjQUFjLENBQUNsRCxDQUFDO0VBQ3hELENBQUM7O0VBRUQ7RUFDQSxNQUFNMkQsS0FBSyxHQUFHVixVQUFVLENBQUMsQ0FBQyxDQUFDO0VBQzNCLEtBQUssSUFBSVcsQ0FBQyxHQUFDLENBQUMsRUFBRUEsQ0FBQyxHQUFDWCxVQUFVLENBQUNPLE1BQU0sRUFBRUksQ0FBQyxFQUFFLEVBQUU7SUFDcEMsTUFBTUMsTUFBTSxHQUFHWixVQUFVLENBQUNXLENBQUMsQ0FBQzs7SUFFNUI7SUFDQSxNQUFNRSxLQUFLLEdBQUdILEtBQUssQ0FBQ2QsZUFBZSxDQUFDZ0IsTUFBTSxFQUFFSixNQUFNLENBQUNDLFNBQVMsQ0FBQztJQUM3RCxJQUFJLENBQUNJLEtBQUssRUFBRTtNQUNSO0lBQ0o7O0lBRUE7SUFDQTtJQUNBO0lBQ0EsTUFBTUMsSUFBSSxHQUFHdEQsS0FBSyxDQUFDdUQsT0FBTyxDQUFDQyxTQUFTLENBQUMxRCxVQUFVLENBQUMyRCxJQUFJLENBQUNULE1BQU0sQ0FBQ0MsU0FBUyxFQUFFUixjQUFjLENBQUM7SUFDdEYsSUFBSWEsSUFBSSxHQUFHWixVQUFVLEVBQUU7TUFDbkI7TUFDQSxPQUFPTSxNQUFNO0lBQ2pCO0VBQ0o7RUFDQSxPQUFPLElBQUk7QUFDZixDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTVSxPQUFPQSxDQUFDQyxNQUFNLEVBQUVDLE9BQU8sRUFBRTs7RUFFckMsSUFBSUMsV0FBVyxHQUFHLElBQUl0RixVQUFVLENBQUMsQ0FBQzs7RUFFbEMsSUFBSXVGLE9BQU8sR0FBR0gsTUFBTTtFQUNwQixJQUFJLENBQUNJLGdCQUFnQixDQUFDSixNQUFNLENBQUNLLGFBQWEsQ0FBQzs7RUFFM0MsSUFBSUMsUUFBUSxHQUFHTCxPQUFPLElBQUksQ0FBQyxDQUFDO0VBQzVCLElBQUlNLE1BQU07O0VBRVYsSUFBSUQsUUFBUSxDQUFDRSxVQUFVLEVBQUU7SUFDckJELE1BQU0sR0FBRyxDQUFDLGdCQUFnQixDQUFDO0VBQy9CLENBQUMsTUFBTSxJQUFJRCxRQUFRLENBQUNHLFFBQVEsRUFBRTtJQUMxQjtJQUNBRixNQUFNLEdBQUcsQ0FBQ0QsUUFBUSxDQUFDRyxRQUFRLENBQUM7RUFDaEMsQ0FBQyxNQUFNO0lBQ0hGLE1BQU0sR0FBRyxDQUFDLFNBQVMsQ0FBQztFQUN4Qjs7RUFFQSxJQUFJRyxTQUFTLEdBQUcsRUFBRTs7RUFFbEIsSUFBSUMsT0FBTyxHQUFHLEtBQUs7O0VBRW5CLElBQUlDLGVBQWUsR0FBR0MsTUFBTSxDQUFDQyxTQUFTO0VBQ3RDLElBQUlDLGlCQUFpQixHQUFHLElBQUk7O0VBRTVCLElBQUlDLFdBQVcsR0FBRyxLQUFLO0VBQ3ZCLElBQUlDLFdBQVcsR0FBRyxLQUFLO0VBQ3ZCLElBQUlDLFVBQVUsR0FBRyxLQUFLOztFQUV0QixJQUFJQyxXQUFXLEdBQUcsSUFBSSxDQUFDLENBQUM7O0VBRXhCLElBQUlDLFlBQVksR0FBRyxLQUFLOztFQUV4QixJQUFJQyxXQUFXLEdBQUcsSUFBSSxDQUFDLENBQUM7O0VBRXhCLElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUlsSCxrRUFBZ0IsQ0FBQzRGLE1BQU0sRUFBRSxJQUFJLENBQUM7O0VBRW5ELElBQUksQ0FBQ1EsVUFBVSxHQUFHRixRQUFRLENBQUNFLFVBQVU7RUFDckMsSUFBSSxDQUFDZSxxQkFBcUIsR0FBR2pCLFFBQVEsQ0FBQ2lCLHFCQUFxQjtFQUMzRCxJQUFJLENBQUNDLHFCQUFxQixHQUFHbEIsUUFBUSxDQUFDa0IscUJBQXFCOztFQUUzRDtFQUNBO0VBQ0EsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRzNHLEVBQUUsQ0FBQzRHLGNBQWMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUU7O0VBRXpEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7RUFDSSxJQUFJLENBQUNDLFFBQVEsR0FBRyxZQUFXO0lBQ3ZCLE9BQU9oQixPQUFPO0VBQ2xCLENBQUM7O0VBRUQsSUFBSSxDQUFDaUIsUUFBUSxHQUFHLFlBQVc7SUFDdkIsT0FBT3JCLE1BQU07RUFDakIsQ0FBQzs7RUFFRCxJQUFJLENBQUNzQixPQUFPLEdBQUcsWUFBVztJQUN0QixPQUFPdEIsTUFBTSxDQUFDLENBQUMsQ0FBQztFQUNwQixDQUFDOztFQUVELElBQUksQ0FBQ3VCLFdBQVcsR0FBRyxZQUFXO0lBQzFCLE9BQU9wQixTQUFTO0VBQ3BCLENBQUM7O0VBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksSUFBSSxDQUFDcUIsUUFBUSxHQUFHLFlBQVc7SUFDdkJwQixPQUFPLEdBQUcsSUFBSTs7SUFFZCxJQUFJLElBQUksQ0FBQ1csU0FBUyxDQUFDVSxNQUFNLENBQUMsQ0FBQyxFQUFFO01BQ3pCLElBQUksQ0FBQ1YsU0FBUyxHQUFHLElBQUlsSCxrRUFBZ0IsQ0FBQzRGLE1BQU0sRUFBRSxJQUFJLENBQUM7SUFDdkQ7RUFDSixDQUFDOzs7RUFHRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSSxJQUFJLENBQUNpQyxVQUFVLEdBQUcsWUFBVztJQUN6QnRCLE9BQU8sR0FBRyxLQUFLOztJQUVmLElBQUksQ0FBQyxJQUFJLENBQUNXLFNBQVMsQ0FBQ1UsTUFBTSxDQUFDLENBQUMsRUFBRTtNQUMxQixJQUFJLENBQUNWLFNBQVMsQ0FBQ1ksT0FBTyxDQUFDLENBQUM7TUFDeEIsSUFBSSxDQUFDWixTQUFTLEdBQUcsSUFBSW5ILHNFQUFvQixDQUFDLENBQUM7SUFDL0M7RUFDSixDQUFDOztFQUVELElBQUksQ0FBQ2dJLFdBQVcsR0FBRyxVQUFTQyxPQUFPLEVBQUU7SUFDakNsQyxXQUFXLENBQUNtQyxNQUFNLENBQUNELE9BQU8sQ0FBQztFQUMvQixDQUFDOztFQUVELElBQUksQ0FBQ0UsT0FBTyxHQUFHLFlBQVc7SUFDdEIsT0FBT3BDLFdBQVcsQ0FBQ3FDLFFBQVE7RUFDL0IsQ0FBQzs7RUFFRCxJQUFJLENBQUNDLFNBQVMsR0FBRyxZQUFXO0lBQ3hCLE9BQU90QyxXQUFXLENBQUN1QyxVQUFVO0VBQ2pDLENBQUM7O0VBRUQsSUFBSSxDQUFDQyxXQUFXLEdBQUcsWUFBVztJQUMxQixPQUFPeEMsV0FBVyxDQUFDd0MsV0FBVyxDQUFDLENBQUM7RUFDcEMsQ0FBQzs7RUFFRCxJQUFJLENBQUNDLGVBQWUsR0FBRyxZQUFXO0lBQzlCLE9BQU96QyxXQUFXLENBQUMwQyxRQUFRO0VBQy9CLENBQUM7O0VBRUQsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRyxZQUFXO0lBQ2hDLE9BQU8zQyxXQUFXLENBQUNwQixjQUFjO0VBQ3JDLENBQUM7OztFQUdEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7RUFDSSxJQUFJLENBQUNnRSxhQUFhLEdBQUcsWUFBVztJQUM1QixPQUFPNUMsV0FBVztFQUN0QixDQUFDOztFQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksSUFBSSxDQUFDNkMsU0FBUyxHQUFHLFlBQVc7SUFDeEIsT0FBTzdCLFVBQVU7RUFDckIsQ0FBQzs7RUFFRCxJQUFJLENBQUM4QixZQUFZLEdBQUcsWUFBVztJQUMzQjlDLFdBQVcsQ0FBQytDLEtBQUssQ0FBQyxDQUFDO0lBQ25CL0IsVUFBVSxHQUFHLEtBQUs7RUFDdEIsQ0FBQzs7RUFFRCxJQUFJLENBQUNnQyxhQUFhLEdBQUcsVUFBU0MsSUFBSSxFQUFFO0lBQ2hDaEMsV0FBVyxHQUFHZ0MsSUFBSTtFQUN0QixDQUFDOztFQUVELElBQUksQ0FBQ0MsY0FBYyxHQUFHLFVBQVNDLE1BQU0sRUFBRTtJQUNuQ2pDLFlBQVksR0FBR2lDLE1BQU07RUFDekIsQ0FBQzs7RUFFRCxJQUFJLENBQUNDLGNBQWMsR0FBRyxZQUFXO0lBQzdCLE9BQU9sQyxZQUFZO0VBQ3ZCLENBQUM7O0VBRUQsSUFBSSxDQUFDbUMsWUFBWSxHQUFHLFVBQVNGLE1BQU0sRUFBRTtJQUNqQ25ELFdBQVcsQ0FBQ3NELFNBQVMsR0FBR0gsTUFBTTtFQUNsQyxDQUFDOztFQUVELElBQUksQ0FBQ0ksWUFBWSxHQUFHLFlBQVc7SUFDM0IsT0FBT3ZELFdBQVcsQ0FBQ3NELFNBQVM7RUFDaEMsQ0FBQzs7RUFFRCxJQUFJLENBQUNFLE1BQU0sR0FBRyxVQUFTQyxLQUFLLEVBQUU7SUFDMUJ6RCxXQUFXLENBQUN5RCxLQUFLLEdBQUdBLEtBQUs7RUFDN0IsQ0FBQzs7RUFFRCxJQUFJLENBQUNDLE1BQU0sR0FBRyxZQUFXO0lBQ3JCLE9BQU8xRCxXQUFXLENBQUN5RCxLQUFLO0VBQzVCLENBQUM7O0VBRUQsSUFBSSxDQUFDRSxhQUFhLEdBQUcsVUFBVUMsTUFBTSxFQUFFO0lBQ25DekMsV0FBVyxHQUFHeUMsTUFBTTtFQUN4QixDQUFDOztFQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7RUFDSSxJQUFJLENBQUNDLFVBQVUsR0FBRyxVQUFTMUUsTUFBTSxFQUFFOztJQUUvQmEsV0FBVyxDQUFDOEQsUUFBUSxHQUFHM0UsTUFBTSxDQUFDNEUsSUFBSTtJQUNsQy9ELFdBQVcsQ0FBQ3BCLGNBQWMsR0FBR08sTUFBTSxDQUFDUCxjQUFjO0lBQ2xEb0IsV0FBVyxDQUFDZ0UsT0FBTyxHQUFHN0UsTUFBTSxDQUFDOEUsS0FBSyxHQUFHOUUsTUFBTSxDQUFDOEUsS0FBSyxDQUFDQyxFQUFFLEdBQUcsSUFBSTs7SUFFM0QsSUFBSUMsSUFBSSxHQUFHaEYsTUFBTSxDQUFDZ0YsSUFBSTs7SUFFdEIsSUFBSSxDQUFDaEYsTUFBTSxDQUFDOEUsS0FBSyxJQUFJOUUsTUFBTSxDQUFDaUYsTUFBTSxLQUFLQyxTQUFTLEVBQUU7TUFDOUM7TUFDQSxJQUFJbEYsTUFBTSxDQUFDbUYsTUFBTSxZQUFZbkksS0FBSyxDQUFDb0ksSUFBSSxFQUFFO1FBQ3JDO1FBQ0EsSUFBSSxDQUFDQyxZQUFZLENBQUNMLElBQUksRUFBRWhGLE1BQU0sQ0FBQ21GLE1BQU0sQ0FBQztNQUMxQztJQUNKLENBQUMsTUFBTTtNQUNILElBQUlHLE9BQU87O01BRVgsSUFBSXRGLE1BQU0sQ0FBQ2lGLE1BQU0sQ0FBQ2xGLE1BQU0sS0FBS21GLFNBQVMsRUFBRTtRQUNwQ0ksT0FBTyxHQUFHLENBQUN0RixNQUFNLENBQUNpRixNQUFNLENBQUM7TUFDN0IsQ0FBQyxNQUFNO1FBQ0hLLE9BQU8sR0FBR3RGLE1BQU0sQ0FBQ2lGLE1BQU07TUFDM0I7O01BRUE7TUFDQXBFLFdBQVcsQ0FBQzBFLFdBQVcsR0FBR3ZGLE1BQU0sQ0FBQzhFLEtBQUssQ0FBQ1MsV0FBVyxDQUFDLENBQUM7TUFDcEQsSUFBRzFFLFdBQVcsQ0FBQzBFLFdBQVc7TUFDMUI7UUFDSTtRQUNBO1FBQ0EsS0FBSyxJQUFJQyxFQUFFLEdBQUcsQ0FBQyxFQUFFQSxFQUFFLEdBQUdGLE9BQU8sQ0FBQ3ZGLE1BQU0sRUFBRSxFQUFFeUYsRUFBRSxFQUFFOztVQUV4QyxJQUFJUCxNQUFNLEdBQUdLLE9BQU8sQ0FBQ0UsRUFBRSxDQUFDO1VBQ3hCLElBQUlDLFNBQVMsR0FBR3pGLE1BQU0sQ0FBQzhFLEtBQUssQ0FBQ1ksWUFBWSxDQUFDVCxNQUFNLENBQUM7VUFDakQsSUFBSVUsUUFBUSxHQUFHM0YsTUFBTSxDQUFDOEUsS0FBSyxDQUFDYyxXQUFXLENBQUNILFNBQVMsQ0FBQztVQUNsRCxJQUFHRSxRQUFRLElBQUlULFNBQVM7VUFDeEI7WUFDSXJFLFdBQVcsQ0FBQzBFLFdBQVcsR0FBRyxLQUFLO1lBQy9CO1VBQ0o7UUFDSjtNQUNKOzs7TUFHQSxJQUFJMUUsV0FBVyxDQUFDMEUsV0FBVyxFQUFFO1FBQ3pCLElBQUksQ0FBQ00sc0JBQXNCLENBQUNiLElBQUksRUFBRU0sT0FBTyxFQUFFdEYsTUFBTSxDQUFDOEUsS0FBSyxDQUFDO01BQzVELENBQUMsTUFBTTtRQUNILElBQUksQ0FBQ2dCLGdCQUFnQixDQUFDZCxJQUFJLEVBQUVNLE9BQU8sRUFBRXRGLE1BQU0sQ0FBQzhFLEtBQUssQ0FBQztNQUN0RDtJQUNKO0VBQ0osQ0FBQzs7O0VBR0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztFQUVJLElBQUksQ0FBQ2lCLGtCQUFrQixHQUFHLFVBQVNDLFFBQVEsRUFBRTtJQUN6QyxNQUFNQyxVQUFVLEdBQUdELFFBQVEsQ0FBQ0MsVUFBVTtJQUN0QyxJQUFJQyxTQUFTLEVBQUVDLE1BQU07SUFDckI7SUFDQTtJQUNBO0lBQ0EsSUFBSUMsT0FBTzs7SUFFWCxJQUFJSixRQUFRLENBQUNLLFFBQVEsRUFBRTtNQUNuQixJQUFJLENBQUNMLFFBQVEsQ0FBQ0ssUUFBUSxDQUFDQyxRQUFRLEVBQUU7UUFDN0IsT0FBTyxZQUFXLENBQUMsQ0FBQyxDQUFDLENBQUs7TUFDOUI7TUFDQUYsT0FBTyxHQUFHSixRQUFRLENBQUNLLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDQyxNQUFNO0lBQy9DLENBQUMsTUFBTSxJQUFJLENBQUNOLFVBQVUsQ0FBQ0ssUUFBUSxFQUFFO01BQzdCLE9BQU8sWUFBVyxDQUFDLENBQUMsQ0FBQyxDQUFLO0lBQzlCLENBQUMsTUFBTTtNQUNIRixPQUFPLEdBQUdILFVBQVUsQ0FBQ0ssUUFBUSxDQUFDQyxNQUFNLElBQUksQ0FBQztJQUM3Qzs7SUFFQUwsU0FBUyxHQUFHRixRQUFRLENBQUNRLEVBQUUsR0FBR1IsUUFBUSxDQUFDUSxFQUFFLEdBQUdSLFFBQVEsQ0FBQ0MsVUFBVSxDQUFDSyxRQUFRLENBQUNHLEtBQUs7SUFDMUVOLE1BQU0sR0FBR0gsUUFBUSxDQUFDUSxFQUFFLEdBQUdSLFFBQVEsQ0FBQ1UsUUFBUSxHQUFHLENBQUM7O0lBRTVDLE9BQU8sVUFBU0MsR0FBRyxFQUFFQyxDQUFDLEVBQUU7TUFDcEIsTUFBTUMsQ0FBQyxHQUFHRixHQUFHLEdBQUdSLE1BQU0sR0FBR0MsT0FBTztNQUNoQ1EsQ0FBQyxHQUFHQSxDQUFDLElBQUksSUFBSTVKLEtBQUssQ0FBQ0MsT0FBTyxDQUFDLENBQUM7TUFDNUIySixDQUFDLENBQUNFLEdBQUc7UUFDRFosU0FBUyxDQUFDVyxDQUFDLENBQUM7UUFDWlgsU0FBUyxDQUFDVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCWCxTQUFTLENBQUNXLENBQUMsR0FBRyxDQUFDO01BQ25CLENBQUM7TUFDRCxPQUFPRCxDQUFDO0lBQ1osQ0FBQztFQUNMLENBQUM7O0VBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJLElBQUksQ0FBQ2Ysc0JBQXNCLEdBQUcsVUFBU2IsSUFBSSxFQUFFTSxPQUFPLEVBQUVSLEtBQUssRUFBRTs7SUFFekQ7SUFDQSxJQUFJakUsV0FBVyxDQUFDOEQsUUFBUSxFQUFFO01BQ3RCVyxPQUFPLEdBQUcsRUFBRTs7TUFFWlIsS0FBSyxDQUFDaUMsT0FBTyxDQUFDLENBQUMsQ0FBQ0MsWUFBWSxDQUFDQyxpQkFBaUIsQ0FBQ3BHLFdBQVcsQ0FBQzhELFFBQVEsRUFBRSxVQUFTTSxNQUFNLEVBQUU7UUFDbEZLLE9BQU8sQ0FBQzRCLElBQUksQ0FBQ2pDLE1BQU0sQ0FBQztNQUN4QixDQUFDLEVBQUUsSUFBSSxDQUFDO0lBQ1o7O0lBRUFwRSxXQUFXLENBQUNzRyxRQUFRLEdBQUd0RyxXQUFXLENBQUNxQyxRQUFRLEdBQUdyQyxXQUFXLENBQUN1QyxVQUFVLEdBQUcsSUFBSTtJQUMzRTdCLGVBQWUsR0FBR0MsTUFBTSxDQUFDQyxTQUFTOztJQUVsQyxLQUFLLElBQUkrRCxFQUFFLEdBQUcsQ0FBQyxFQUFFQSxFQUFFLEdBQUdGLE9BQU8sQ0FBQ3ZGLE1BQU0sRUFBRSxFQUFFeUYsRUFBRSxFQUFFLEtBQUE0QixxQkFBQSxFQUFBQyxzQkFBQTs7TUFFeEMsSUFBSXBDLE1BQU0sR0FBR0ssT0FBTyxDQUFDRSxFQUFFLENBQUM7O01BRXhCLE1BQU04QixXQUFXLEdBQUcsSUFBSXRLLEtBQUssQ0FBQ3VLLE9BQU8sQ0FBQyxDQUFDO01BQ3ZDLENBQUFILHFCQUFBLEdBQUF0QyxLQUFLLENBQUMwQyxlQUFlLENBQUMsQ0FBQyxjQUFBSixxQkFBQSxlQUF2QkEscUJBQUEsQ0FBeUJLLGNBQWMsQ0FBQ3hDLE1BQU0sRUFBRXFDLFdBQVcsQ0FBQztNQUM1RCxJQUFJdEIsUUFBUSxJQUFBcUIsc0JBQUEsR0FBR3ZDLEtBQUssQ0FBQzBDLGVBQWUsQ0FBQyxDQUFDLGNBQUFILHNCQUFBLHVCQUF2QkEsc0JBQUEsQ0FBeUJoRSxXQUFXLENBQUM0QixNQUFNLENBQUM7O01BRTNELElBQUlRLFNBQVMsR0FBR1gsS0FBSyxDQUFDWSxZQUFZLENBQUNULE1BQU0sQ0FBQztNQUMxQyxJQUFJVSxRQUFRLEdBQUdiLEtBQUssQ0FBQ2MsV0FBVyxDQUFDSCxTQUFTLENBQUM7TUFDM0M7TUFDQTtNQUNBLElBQUdFLFFBQVEsSUFBSVQsU0FBUztNQUNwQjs7TUFFSixJQUFJd0MsYUFBYSxHQUFHL0IsUUFBUSxDQUFDZ0MsS0FBSztNQUNsQyxJQUFJQyxhQUFhLEdBQUdqQyxRQUFRLENBQUNrQyxLQUFLOztNQUVsQyxJQUFJLENBQUNoSCxXQUFXLENBQUNzRyxRQUFRLEVBQUU7UUFDdkJ0RyxXQUFXLENBQUNzRyxRQUFRLEdBQUcsSUFBSSxDQUFDVyx3QkFBd0IsQ0FBQzlDLElBQUksRUFBRWdCLFFBQVEsRUFBRTBCLGFBQWEsRUFBRSxFQUFDSixXQUFXLEVBQUMsQ0FBQzs7UUFFbEcsSUFBSXpHLFdBQVcsQ0FBQ3NHLFFBQVEsRUFBRTtVQUN0QnRHLFdBQVcsQ0FBQ3NHLFFBQVEsQ0FBQ2xDLE1BQU0sR0FBR0EsTUFBTTtRQUN4Qzs7UUFFQSxJQUFJOEMsWUFBWSxHQUFHLElBQUkvSyxLQUFLLENBQUNnTCxPQUFPLENBQUMsQ0FBQyxDQUFDQyxlQUFlLENBQUNYLFdBQVcsQ0FBQztRQUNuRXpHLFdBQVcsQ0FBQ3FILFVBQVUsR0FBR2xELElBQUksQ0FBQ21ELE1BQU0sQ0FBQ0MsWUFBWSxDQUFDTCxZQUFZLENBQUMsQ0FBQ00sU0FBUyxDQUFDLENBQUM7TUFDL0U7O01BRUE7TUFDQTtNQUNBLElBQUksQ0FBQ0Msd0JBQXdCLENBQUN6SCxXQUFXLENBQUNwQixjQUFjLEVBQUV1RyxRQUFRLEVBQUU0QixhQUFhLEVBQUUsRUFBQ04sV0FBVyxFQUFDLENBQUM7O0lBRXJHOztJQUVBekcsV0FBVyxDQUFDdUMsVUFBVSxHQUFHLElBQUksQ0FBQ21GLDBCQUEwQixDQUFDMUgsV0FBVyxDQUFDcUMsUUFBUSxFQUFFckMsV0FBVyxDQUFDcEIsY0FBYyxDQUFDOztJQUUxRyxJQUFJb0IsV0FBVyxDQUFDc0csUUFBUSxFQUFFOztNQUV0QjtNQUNBdEcsV0FBVyxDQUFDM0MsTUFBTSxHQUFHLElBQUksQ0FBQ3NLLGVBQWUsQ0FBQzNILFdBQVcsQ0FBQ3BCLGNBQWMsQ0FBQzs7TUFFckUsSUFBSSxDQUFDd0IsUUFBUSxDQUFDd0gsaUJBQWlCLElBQUkvRyxpQkFBaUIsR0FBR2IsV0FBVyxDQUFDM0MsTUFBTSxLQUFLMkMsV0FBVyxDQUFDdUMsVUFBVSxFQUFFO1FBQ2xHdkMsV0FBVyxDQUFDMEMsUUFBUSxHQUFHakksUUFBUSxDQUFDb04sV0FBVztNQUMvQyxDQUFDO01BQ0ksSUFBSSxDQUFDekgsUUFBUSxDQUFDMEgsY0FBYyxJQUFJcEgsZUFBZSxHQUFHVixXQUFXLENBQUMzQyxNQUFNLEtBQUsyQyxXQUFXLENBQUNxQyxRQUFRLEVBQUU7O1FBRWhHLElBQUk3RSxNQUFNLEdBQUcsSUFBSSxDQUFDdUssWUFBWSxDQUFDL0gsV0FBVyxDQUFDcUMsUUFBUSxDQUFDO1FBQ3BELElBQUk3RSxNQUFNLEVBQUU7VUFDUndDLFdBQVcsQ0FBQ2dJLGlCQUFpQixHQUFHeEssTUFBTTtVQUN0Q3dDLFdBQVcsQ0FBQ2lJLGlCQUFpQixHQUFHekssTUFBTSxDQUFDdkIsVUFBVSxDQUFDK0QsV0FBVyxDQUFDcUMsUUFBUSxDQUFDNkYsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1VBQ25GbEksV0FBVyxDQUFDcUMsUUFBUSxDQUFDN0UsTUFBTSxHQUFHd0MsV0FBVyxDQUFDZ0ksaUJBQWlCO1VBQzNEaEksV0FBVyxDQUFDcUMsUUFBUSxDQUFDaEYsTUFBTSxHQUFHMkMsV0FBVyxDQUFDaUksaUJBQWlCO1VBQzNEakksV0FBVyxDQUFDMEMsUUFBUSxHQUFHakksUUFBUSxDQUFDME4sZ0JBQWdCO1FBQ3BELENBQUM7UUFDSSxJQUFJLElBQUksQ0FBQ0MsWUFBWSxDQUFDcEksV0FBVyxDQUFDcUMsUUFBUSxDQUFDLEVBQUU7VUFDOUNyQyxXQUFXLENBQUMwQyxRQUFRLEdBQUdqSSxRQUFRLENBQUM0TixlQUFlO1FBQ25ELENBQUM7UUFDSTtVQUNEckksV0FBVyxDQUFDMEMsUUFBUSxHQUFHakksUUFBUSxDQUFDNk4sU0FBUztRQUM3Qzs7TUFFSixDQUFDO01BQ0k7O1FBRUQsSUFBSSxJQUFJLENBQUNDLFlBQVksQ0FBQ3ZJLFdBQVcsQ0FBQ3NHLFFBQVEsQ0FBQyxFQUFFO1VBQ3pDdEcsV0FBVyxDQUFDMEMsUUFBUSxHQUFHakksUUFBUSxDQUFDK04sZUFBZTtRQUNuRCxDQUFDO1FBQ0k7VUFDRHhJLFdBQVcsQ0FBQzBDLFFBQVEsR0FBR2pJLFFBQVEsQ0FBQ2dPLFNBQVM7UUFDN0M7O01BRUo7O01BRUF6SCxVQUFVLEdBQUcsSUFBSTtJQUNyQjtFQUNKLENBQUM7O0VBRUQsSUFBSSxDQUFDd0QsWUFBWSxHQUFHLFVBQVNMLElBQUksRUFBQXVFLElBQUEsRUFBMkIsS0FBekIsRUFBQ3ZELFFBQVEsRUFBRXNCLFdBQVcsRUFBQyxHQUFBaUMsSUFBQTs7SUFFdEQ7SUFDQSxNQUFNdkssTUFBTSxHQUFHZ0gsUUFBUSxDQUFDd0QsT0FBTyxJQUFJeEQsUUFBUSxDQUFDeUQsV0FBVztJQUN2RCxJQUFJekssTUFBTSxJQUFJZ0csSUFBSSxFQUFFOztNQUVoQjtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0FuRSxXQUFXLENBQUNxQyxRQUFRLEdBQUcsSUFBSSxDQUFDd0csbUJBQW1CLENBQUMxRSxJQUFJLEVBQUVnQixRQUFRLENBQUM7TUFDL0RuRixXQUFXLENBQUNxQyxRQUFRLENBQUN5RyxZQUFZLENBQUNyQyxXQUFXLENBQUM7O01BRTlDekcsV0FBVyxDQUFDdUMsVUFBVSxHQUFHLElBQUksQ0FBQ3dHLGNBQWMsQ0FBQy9JLFdBQVcsQ0FBQ3FDLFFBQVEsRUFBRXJDLFdBQVcsQ0FBQ3BCLGNBQWMsQ0FBQzs7TUFFOUZvQixXQUFXLENBQUMzQyxNQUFNLEdBQUcsSUFBSSxDQUFDc0ssZUFBZSxDQUFDM0gsV0FBVyxDQUFDcEIsY0FBYyxDQUFDOztNQUVyRTtNQUNBLElBQUt3QixRQUFRLENBQUN3SCxpQkFBaUIsSUFBSy9HLGlCQUFpQixHQUFHYixXQUFXLENBQUMzQyxNQUFPLEVBQUc7UUFDMUUyQyxXQUFXLENBQUMwQyxRQUFRLEdBQUdqSSxRQUFRLENBQUNvTixXQUFXO01BQy9DLENBQUM7TUFDSTtRQUNEO1FBQ0E3SCxXQUFXLENBQUMwQyxRQUFRLEdBQUdqSSxRQUFRLENBQUM2TixTQUFTO01BQzdDOztNQUVBdEgsVUFBVSxHQUFHLElBQUk7TUFDakIsT0FBTyxJQUFJO0lBQ2Y7O0lBRUE7SUFDQSxJQUFJbUQsSUFBSSxZQUFZaEksS0FBSyxDQUFDNk0sS0FBSyxFQUFFO01BQzdCaEosV0FBVyxDQUFDc0csUUFBUSxHQUFHLElBQUksQ0FBQzJDLFlBQVksQ0FBQzlFLElBQUksRUFBRWdCLFFBQVEsQ0FBQztJQUM1RDs7SUFFQSxJQUFJLENBQUNuRixXQUFXLENBQUNzRyxRQUFRO0lBQ3JCLE9BQU8sS0FBSzs7SUFFaEJ0RyxXQUFXLENBQUNzRyxRQUFRLENBQUN3QyxZQUFZLENBQUNyQyxXQUFXLENBQUM7SUFDOUN6RyxXQUFXLENBQUNxQyxRQUFRLEdBQUcsSUFBSSxDQUFDNkcsWUFBWSxDQUFDbEosV0FBVyxDQUFDc0csUUFBUSxFQUFFdEcsV0FBVyxDQUFDcEIsY0FBYyxDQUFDO0lBQzFGb0IsV0FBVyxDQUFDdUMsVUFBVSxHQUFHLElBQUksQ0FBQ3dHLGNBQWMsQ0FBQy9JLFdBQVcsQ0FBQ3FDLFFBQVEsRUFBRXJDLFdBQVcsQ0FBQ3BCLGNBQWMsQ0FBQzs7SUFFOUYsSUFBSXNJLFlBQVksR0FBRyxJQUFJL0ssS0FBSyxDQUFDZ0wsT0FBTyxDQUFDLENBQUMsQ0FBQ0MsZUFBZSxDQUFDWCxXQUFXLENBQUM7SUFDbkV6RyxXQUFXLENBQUNxSCxVQUFVLEdBQUdsRCxJQUFJLENBQUNtRCxNQUFNLENBQUNDLFlBQVksQ0FBQ0wsWUFBWSxDQUFDLENBQUNNLFNBQVMsQ0FBQyxDQUFDOztJQUUzRXhILFdBQVcsQ0FBQzNDLE1BQU0sR0FBRyxJQUFJLENBQUNzSyxlQUFlLENBQUMzSCxXQUFXLENBQUNwQixjQUFjLENBQUM7O0lBRXJFO0lBQ0EsSUFBS3dCLFFBQVEsQ0FBQ3dILGlCQUFpQixJQUFLL0csaUJBQWlCLEdBQUdiLFdBQVcsQ0FBQzNDLE1BQU8sRUFBRztNQUMxRTJDLFdBQVcsQ0FBQzBDLFFBQVEsR0FBR2pJLFFBQVEsQ0FBQ29OLFdBQVc7SUFDL0MsQ0FBQztJQUNJLElBQUl6SCxRQUFRLENBQUMwSCxjQUFjLElBQUtwSCxlQUFlLEdBQUdWLFdBQVcsQ0FBQzNDLE1BQU8sRUFBRTtNQUN4RTJDLFdBQVcsQ0FBQzBDLFFBQVEsR0FBR2pJLFFBQVEsQ0FBQzZOLFNBQVM7SUFDN0MsQ0FBQztJQUNJO01BQ0R0SSxXQUFXLENBQUMwQyxRQUFRLEdBQUdqSSxRQUFRLENBQUNnTyxTQUFTO0lBQzdDOztJQUVBekgsVUFBVSxHQUFHLElBQUk7SUFDakIsT0FBTyxJQUFJO0VBQ2YsQ0FBQzs7RUFFRCxJQUFJLENBQUNpRSxnQkFBZ0IsR0FBRyxVQUFTZCxJQUFJLEVBQUVNLE9BQU8sRUFBRVIsS0FBSyxFQUFFO0lBQ25ELEtBQUssSUFBSVUsRUFBRSxHQUFHLENBQUMsRUFBRUEsRUFBRSxHQUFHRixPQUFPLENBQUN2RixNQUFNLEVBQUUsRUFBRXlGLEVBQUUsRUFBRTs7TUFFeEMsSUFBSVAsTUFBTSxHQUFHSyxPQUFPLENBQUNFLEVBQUUsQ0FBQzs7O01BR3hCLE1BQU1RLFFBQVEsR0FBR2xCLEtBQUssQ0FBQzBDLGVBQWUsQ0FBQyxDQUFDLENBQUNuRSxXQUFXLENBQUM0QixNQUFNLENBQUM7TUFDNUQsTUFBTXFDLFdBQVcsR0FBRyxJQUFJdEssS0FBSyxDQUFDdUssT0FBTyxDQUFDLENBQUM7TUFDdkN6QyxLQUFLLENBQUMwQyxlQUFlLENBQUMsQ0FBQyxDQUFDQyxjQUFjLENBQUN4QyxNQUFNLEVBQUVxQyxXQUFXLENBQUM7O01BRTNELElBQUksSUFBSSxDQUFDakMsWUFBWSxDQUFDTCxJQUFJLEVBQUUsRUFBQ2dCLFFBQVEsRUFBRXNCLFdBQVcsRUFBQyxDQUFDLEVBQUU7UUFDbEQ7TUFDSjtJQUNKO0VBQ0osQ0FBQzs7RUFFRCxJQUFJLENBQUNRLHdCQUF3QixHQUFHLFVBQVM5QyxJQUFJLEVBQUVnQixRQUFRLEVBQUUwQixhQUFhLEVBQUFzQyxLQUFBLEVBQWlCLEtBQWYsRUFBQzFDLFdBQVcsRUFBQyxHQUFBMEMsS0FBQTs7SUFFakYsSUFBSUMsRUFBRSxHQUFHLElBQUlqTixLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDO0lBQzVCLElBQUlpTixFQUFFLEdBQUcsSUFBSWxOLEtBQUssQ0FBQ0MsT0FBTyxDQUFDLENBQUM7SUFDNUIsSUFBSWtOLEVBQUUsR0FBRyxJQUFJbk4sS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQzs7SUFFNUIsTUFBTW1OLElBQUksR0FBRyxJQUFJcE4sS0FBSyxDQUFDcU4sUUFBUSxDQUFDLENBQUM7SUFDakMsTUFBTXRCLFFBQVEsR0FBRyxFQUFFOztJQUVuQixJQUFJL0MsUUFBUSxDQUFDc0UsS0FBSyxLQUFLcEYsU0FBUyxFQUFFOztNQUU5QjtNQUNBLEtBQUssSUFBSS9FLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR3VILGFBQWEsQ0FBQzNILE1BQU0sRUFBRUksQ0FBQyxFQUFFLEVBQUU7O1FBRTNDLElBQUlvSyxTQUFTLEdBQUc3QyxhQUFhLENBQUN2SCxDQUFDLENBQUMsQ0FBQ29LLFNBQVM7UUFDMUMsSUFBSUMsTUFBTSxHQUFHOUMsYUFBYSxDQUFDdkgsQ0FBQyxDQUFDLENBQUM0RSxFQUFFO1FBQ2hDLElBQUkwRixDQUFDLEdBQUcsQ0FBQztRQUNULE9BQU9BLENBQUMsR0FBR0YsU0FBUyxDQUFDeEssTUFBTSxFQUFFMEssQ0FBQyxJQUFJLENBQUMsRUFBRTs7VUFFakMsSUFBSXpGLElBQUksQ0FBQ2xKLENBQUMsS0FBS3lPLFNBQVMsQ0FBQ0UsQ0FBQyxDQUFDLEVBQUU7WUFDekIsSUFBS3pGLElBQUksQ0FBQ2pKLENBQUMsS0FBS3dPLFNBQVMsQ0FBQ0UsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJekYsSUFBSSxDQUFDMEYsQ0FBQyxLQUFLSCxTQUFTLENBQUNFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBTXpGLElBQUksQ0FBQ2pKLENBQUMsS0FBS3dPLFNBQVMsQ0FBQ0UsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJekYsSUFBSSxDQUFDMEYsQ0FBQyxLQUFLSCxTQUFTLENBQUNFLENBQUMsR0FBRyxDQUFDLENBQUUsRUFBRTtjQUM5SDtZQUNKO1VBQ0osQ0FBQztVQUNJLElBQUl6RixJQUFJLENBQUNsSixDQUFDLEtBQUt5TyxTQUFTLENBQUNFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtZQUNsQyxJQUFLekYsSUFBSSxDQUFDakosQ0FBQyxLQUFLd08sU0FBUyxDQUFDRSxDQUFDLENBQUMsSUFBSXpGLElBQUksQ0FBQzBGLENBQUMsS0FBS0gsU0FBUyxDQUFDRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQU16RixJQUFJLENBQUNqSixDQUFDLEtBQUt3TyxTQUFTLENBQUNFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSXpGLElBQUksQ0FBQzBGLENBQUMsS0FBS0gsU0FBUyxDQUFDRSxDQUFDLENBQUUsRUFBRTtjQUN0SDtZQUNKO1VBQ0osQ0FBQztVQUNJLElBQUl6RixJQUFJLENBQUNsSixDQUFDLEtBQUt5TyxTQUFTLENBQUNFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtZQUNsQyxJQUFLekYsSUFBSSxDQUFDakosQ0FBQyxLQUFLd08sU0FBUyxDQUFDRSxDQUFDLENBQUMsSUFBSXpGLElBQUksQ0FBQzBGLENBQUMsS0FBS0gsU0FBUyxDQUFDRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQU16RixJQUFJLENBQUNqSixDQUFDLEtBQUt3TyxTQUFTLENBQUNFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSXpGLElBQUksQ0FBQzBGLENBQUMsS0FBS0gsU0FBUyxDQUFDRSxDQUFDLENBQUUsRUFBRTtjQUN0SDtZQUNKO1VBQ0o7UUFDSjs7UUFFQSxJQUFJQSxDQUFDLEdBQUdGLFNBQVMsQ0FBQ3hLLE1BQU0sRUFBRTtVQUN0QjtRQUNKO01BQ0o7O01BRUEsSUFBSUksQ0FBQyxHQUFHdUgsYUFBYSxDQUFDM0gsTUFBTSxFQUFFOztRQUUxQixNQUFNNEssVUFBVSxHQUFHLElBQUksQ0FBQzVFLGtCQUFrQixDQUFDQyxRQUFRLENBQUM7O1FBRXBELEtBQUssSUFBSXlFLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0YsU0FBUyxDQUFDeEssTUFBTSxFQUFFMEssQ0FBQyxJQUFJLENBQUMsRUFBRTtVQUMxQ0UsVUFBVSxDQUFDSixTQUFTLENBQUNFLENBQUMsQ0FBQyxFQUFFUixFQUFFLENBQUM7VUFDNUJVLFVBQVUsQ0FBQ0osU0FBUyxDQUFDRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUVQLEVBQUUsQ0FBQztVQUNoQ1MsVUFBVSxDQUFDSixTQUFTLENBQUNFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRU4sRUFBRSxDQUFDOztVQUVoQyxNQUFNUyxNQUFNLEdBQUc3QixRQUFRLENBQUNoSixNQUFNO1VBQzlCcUssSUFBSSxDQUFDekMsS0FBSyxDQUFDVCxJQUFJLENBQUMsSUFBSWxLLEtBQUssQ0FBQzZNLEtBQUssQ0FBQ2UsTUFBTSxFQUFFQSxNQUFNLEdBQUcsQ0FBQyxFQUFFQSxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7VUFDaEU3QixRQUFRLENBQUM3QixJQUFJLENBQUMrQyxFQUFFLENBQUN0TCxLQUFLLENBQUMsQ0FBQyxDQUFDO1VBQ3pCb0ssUUFBUSxDQUFDN0IsSUFBSSxDQUFDZ0QsRUFBRSxDQUFDdkwsS0FBSyxDQUFDLENBQUMsQ0FBQztVQUN6Qm9LLFFBQVEsQ0FBQzdCLElBQUksQ0FBQ2lELEVBQUUsQ0FBQ3hMLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDN0I7UUFDQXlMLElBQUksQ0FBQ3JCLFFBQVEsR0FBR0EsUUFBUTs7TUFFNUI7SUFDSjs7SUFFQSxJQUFJQSxRQUFRLENBQUNoSixNQUFNLEdBQUcsQ0FBQyxFQUFFOztNQUVyQnFLLElBQUksQ0FBQ0ksTUFBTSxHQUFHQSxNQUFNO01BQ3BCSixJQUFJLENBQUNULFlBQVksQ0FBQ3JDLFdBQVcsQ0FBQztNQUM5QixPQUFPOEMsSUFBSTtJQUNmLENBQUM7SUFDSTs7TUFFRCxPQUFPLElBQUk7SUFDZjs7RUFFSixDQUFDOztFQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSSxJQUFJLENBQUNOLFlBQVksR0FBRyxVQUFTOUUsSUFBSSxFQUFFZ0IsUUFBUSxFQUFFOztJQUV6QyxJQUFJaUUsRUFBRSxHQUFHLElBQUlqTixLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDO0lBQzVCLElBQUlpTixFQUFFLEdBQUcsSUFBSWxOLEtBQUssQ0FBQ0MsT0FBTyxDQUFDLENBQUM7SUFDNUIsSUFBSWtOLEVBQUUsR0FBRyxJQUFJbk4sS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQzs7SUFFNUIsTUFBTW1OLElBQUksR0FBRyxJQUFJcE4sS0FBSyxDQUFDcU4sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDOztJQUVuQyxJQUFJUSxPQUFPO0lBQ1g7SUFDQUEsT0FBTyxHQUFHN0UsUUFBUSxDQUFDc0UsS0FBSyxLQUFLdEUsUUFBUSxDQUFDc0UsS0FBSyxDQUFDN0QsS0FBSyxJQUFJVCxRQUFRLENBQUM4RSxFQUFFLENBQUM7O0lBRWpFLElBQUlDLE9BQU8sR0FBRy9FLFFBQVEsQ0FBQ2dGLE1BQU07O0lBRTdCLElBQUssQ0FBQ0QsT0FBTyxJQUFJQSxPQUFPLENBQUNoTCxNQUFNLEtBQUssQ0FBQyxFQUFFOztNQUVuQyxJQUFJbUcsU0FBUztNQUNiO01BQ0FBLFNBQVMsR0FBR0YsUUFBUSxDQUFDUSxFQUFFLElBQUlSLFFBQVEsQ0FBQ0MsVUFBVSxDQUFDSyxRQUFRLENBQUNHLEtBQUs7TUFDN0RzRSxPQUFPLEdBQUcsQ0FBQyxFQUFFbE0sS0FBSyxFQUFFLENBQUMsRUFBRW9NLEtBQUssRUFBRUosT0FBTyxHQUFHQSxPQUFPLENBQUM5SyxNQUFNLEdBQUdtRyxTQUFTLENBQUNuRyxNQUFNLEVBQUV1SyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxRjs7SUFFQSxNQUFNSyxVQUFVLEdBQUcsSUFBSSxDQUFDNUUsa0JBQWtCLENBQUNDLFFBQVEsQ0FBQzs7SUFFcEQsTUFBTWtGLEVBQUUsR0FBR1AsVUFBVSxDQUFDM0YsSUFBSSxDQUFDbEosQ0FBQyxDQUFDOztJQUU3QixLQUFLLElBQUlxUCxFQUFFLEdBQUcsQ0FBQyxFQUFFQSxFQUFFLEdBQUdKLE9BQU8sQ0FBQ2hMLE1BQU0sRUFBRSxFQUFFb0wsRUFBRSxFQUFFOztNQUV4QyxJQUFJdE0sS0FBSyxHQUFHa00sT0FBTyxDQUFDSSxFQUFFLENBQUMsQ0FBQ3RNLEtBQUs7TUFDN0IsSUFBSW9NLEtBQUssR0FBR0YsT0FBTyxDQUFDSSxFQUFFLENBQUMsQ0FBQ0YsS0FBSztNQUM3QixJQUFJWCxLQUFLLEdBQUcsQ0FBQztNQUNiQSxLQUFLLEdBQUdTLE9BQU8sQ0FBQ0ksRUFBRSxDQUFDLENBQUNiLEtBQUs7O01BRXpCLEtBQUssSUFBSW5LLENBQUMsR0FBR3RCLEtBQUssRUFBRXNCLENBQUMsR0FBR3RCLEtBQUssR0FBR29NLEtBQUssRUFBRTlLLENBQUMsSUFBSSxDQUFDLEVBQUU7O1FBRTNDLElBQUlyRSxDQUFDLEdBQUd3TyxLQUFLLElBQUlPLE9BQU8sR0FBR0EsT0FBTyxDQUFDMUssQ0FBQyxDQUFDLEdBQUdBLENBQUMsQ0FBQztRQUMxQyxJQUFJcEUsQ0FBQyxHQUFHdU8sS0FBSyxJQUFJTyxPQUFPLEdBQUdBLE9BQU8sQ0FBQzFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBR0EsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNsRCxJQUFJdUssQ0FBQyxHQUFHSixLQUFLLElBQUlPLE9BQU8sR0FBR0EsT0FBTyxDQUFDMUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHQSxDQUFDLEdBQUcsQ0FBQyxDQUFDOztRQUVsRHdLLFVBQVUsQ0FBQzdPLENBQUMsRUFBRW1PLEVBQUUsQ0FBQztRQUNqQlUsVUFBVSxDQUFDNU8sQ0FBQyxFQUFFbU8sRUFBRSxDQUFDO1FBQ2pCUyxVQUFVLENBQUNELENBQUMsRUFBRVAsRUFBRSxDQUFDOztRQUVqQixJQUFJakMsVUFBVSxHQUFHLElBQUlsTCxLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDO1FBQ3BDRCxLQUFLLENBQUNvTyxRQUFRLENBQUNDLFNBQVMsQ0FBQ3BCLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVqQyxVQUFVLENBQUM7O1FBRWhELElBQUloTSwyQkFBMkIsQ0FBQ2dNLFVBQVUsRUFBRWxELElBQUksQ0FBQ21ELE1BQU0sQ0FBQyxJQUFJdE0sb0JBQW9CLENBQUNxTSxVQUFVLENBQUM1SyxHQUFHLENBQUMyTSxFQUFFLENBQUMsRUFBRWpGLElBQUksQ0FBQ21ELE1BQU0sQ0FBQzdLLEdBQUcsQ0FBQzROLEVBQUUsQ0FBQyxDQUFDO1FBQ3pIOztVQUVJLE1BQU1OLE1BQU0sR0FBR1IsSUFBSSxDQUFDckIsUUFBUSxDQUFDaEosTUFBTTtVQUNuQ3FLLElBQUksQ0FBQ3pDLEtBQUssQ0FBQ1QsSUFBSSxDQUFDLElBQUlsSyxLQUFLLENBQUM2TSxLQUFLLENBQUNlLE1BQU0sRUFBRUEsTUFBTSxHQUFHLENBQUMsRUFBRUEsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1VBQ2hFUixJQUFJLENBQUNyQixRQUFRLENBQUM3QixJQUFJLENBQUMrQyxFQUFFLENBQUN0TCxLQUFLLENBQUMsQ0FBQyxDQUFDO1VBQzlCeUwsSUFBSSxDQUFDckIsUUFBUSxDQUFDN0IsSUFBSSxDQUFDZ0QsRUFBRSxDQUFDdkwsS0FBSyxDQUFDLENBQUMsQ0FBQztVQUM5QnlMLElBQUksQ0FBQ3JCLFFBQVEsQ0FBQzdCLElBQUksQ0FBQ2lELEVBQUUsQ0FBQ3hMLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDbEM7TUFDSjtJQUNKOztJQUVBLElBQUl5TCxJQUFJLENBQUNyQixRQUFRLENBQUNoSixNQUFNLEdBQUcsQ0FBQyxFQUFFOztNQUUxQixPQUFPLElBQUksQ0FBQ3VMLHNCQUFzQixDQUFDbEIsSUFBSSxFQUFFcEYsSUFBSSxFQUFFMkYsVUFBVSxDQUFDO0lBQzlELENBQUM7SUFDSTs7TUFFRCxPQUFPLElBQUk7SUFDZjtFQUNKLENBQUM7O0VBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksSUFBSSxDQUFDVyxzQkFBc0IsR0FBRyxVQUFTbEIsSUFBSSxFQUFFcEYsSUFBSSxFQUFFdUcsWUFBWSxFQUFFO0lBQzdELE1BQU14QyxRQUFRLEdBQUdxQixJQUFJLENBQUNyQixRQUFROztJQUU5QixNQUFNeUMsV0FBVyxHQUFHRCxZQUFZLENBQUN2RyxJQUFJLENBQUNsSixDQUFDLENBQUM7SUFDeEMsTUFBTTJQLFdBQVcsR0FBR0YsWUFBWSxDQUFDdkcsSUFBSSxDQUFDakosQ0FBQyxDQUFDO0lBQ3hDLE1BQU0yUCxXQUFXLEdBQUdILFlBQVksQ0FBQ3ZHLElBQUksQ0FBQzBGLENBQUMsQ0FBQzs7SUFFeEMsTUFBTWlCLGFBQWEsR0FBRyxJQUFJM08sS0FBSyxDQUFDcU4sUUFBUSxDQUFDLENBQUM7O0lBRTFDLE1BQU11QixlQUFlLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDM0IsTUFBTUMsU0FBUyxHQUFHN1AsSUFBSSxDQUFDOFAsR0FBRyxDQUFFLEVBQUUsRUFBRUYsZUFBZ0IsQ0FBQzs7SUFFakQ7SUFDQTtJQUNBO0lBQ0EsTUFBTUcsWUFBWSxHQUFHLEVBQUU7SUFDdkIsTUFBTUMsUUFBUSxHQUFHLENBQUMsQ0FBQztJQUNuQixJQUFJQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4QixLQUFLLElBQUk5TCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUc0SSxRQUFRLENBQUNoSixNQUFNLEVBQUVJLENBQUMsSUFBSSxDQUFDLEVBQUU7TUFDekM7TUFDQSxNQUFNOEosRUFBRSxHQUFHbEIsUUFBUSxDQUFDNUksQ0FBQyxDQUFDO01BQ3RCLE1BQU0rSixFQUFFLEdBQUduQixRQUFRLENBQUM1SSxDQUFDLEdBQUcsQ0FBQyxDQUFDO01BQzFCLE1BQU1nSyxFQUFFLEdBQUdwQixRQUFRLENBQUM1SSxDQUFDLEdBQUcsQ0FBQyxDQUFDOztNQUUxQixJQUFJOEwsYUFBYSxHQUFHLENBQUMsSUFBSVQsV0FBVyxDQUFDM08sTUFBTSxDQUFDb04sRUFBRSxDQUFDLElBQUl3QixXQUFXLENBQUM1TyxNQUFNLENBQUNxTixFQUFFLENBQUMsSUFBSXdCLFdBQVcsQ0FBQzdPLE1BQU0sQ0FBQ3NOLEVBQUUsQ0FBQyxFQUFFO1FBQ2pHOEIsYUFBYSxHQUFHOUwsQ0FBQyxHQUFHLENBQUM7TUFDekI7O01BRUEsTUFBTStMLElBQUksR0FBRztNQUNUbFEsSUFBSSxDQUFDbVEsS0FBSyxDQUFDbEMsRUFBRSxDQUFDNU4sQ0FBQyxHQUFHd1AsU0FBUyxDQUFDLEdBQUcsR0FBRyxHQUFHN1AsSUFBSSxDQUFDbVEsS0FBSyxDQUFDbEMsRUFBRSxDQUFDM04sQ0FBQyxHQUFHdVAsU0FBUyxDQUFDLEdBQUcsR0FBRyxHQUFHN1AsSUFBSSxDQUFDbVEsS0FBSyxDQUFDbEMsRUFBRSxDQUFDMU4sQ0FBQyxHQUFHc1AsU0FBUyxDQUFDO01BQ3RHN1AsSUFBSSxDQUFDbVEsS0FBSyxDQUFDakMsRUFBRSxDQUFDN04sQ0FBQyxHQUFHd1AsU0FBUyxDQUFDLEdBQUcsR0FBRyxHQUFHN1AsSUFBSSxDQUFDbVEsS0FBSyxDQUFDakMsRUFBRSxDQUFDNU4sQ0FBQyxHQUFHdVAsU0FBUyxDQUFDLEdBQUcsR0FBRyxHQUFHN1AsSUFBSSxDQUFDbVEsS0FBSyxDQUFDakMsRUFBRSxDQUFDM04sQ0FBQyxHQUFHc1AsU0FBUyxDQUFDO01BQ3RHN1AsSUFBSSxDQUFDbVEsS0FBSyxDQUFDaEMsRUFBRSxDQUFDOU4sQ0FBQyxHQUFHd1AsU0FBUyxDQUFDLEdBQUcsR0FBRyxHQUFHN1AsSUFBSSxDQUFDbVEsS0FBSyxDQUFDaEMsRUFBRSxDQUFDN04sQ0FBQyxHQUFHdVAsU0FBUyxDQUFDLEdBQUcsR0FBRyxHQUFHN1AsSUFBSSxDQUFDbVEsS0FBSyxDQUFDaEMsRUFBRSxDQUFDNU4sQ0FBQyxHQUFHc1AsU0FBUyxDQUFDLENBQ3pHOztNQUNELE1BQU1PLFFBQVEsR0FBRyxFQUFFdkUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDOztNQUU5QjtNQUNBLEtBQUssSUFBSTRDLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsRUFBRSxFQUFFO1FBQ3hCLE1BQU00QixJQUFJLEdBQUdILElBQUksQ0FBQ3pCLENBQUMsQ0FBQztRQUNwQixNQUFNNkIsSUFBSSxHQUFHSixJQUFJLENBQUMsQ0FBQ3pCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDOztRQUU5QixNQUFNOEIsV0FBVyxHQUFHRixJQUFJLEdBQUcsR0FBRyxHQUFHQyxJQUFJO1FBQ3JDLElBQUlFLElBQUksR0FBR1IsUUFBUSxDQUFDTyxXQUFXLENBQUMsSUFBSVAsUUFBUSxDQUFDTSxJQUFJLEdBQUcsR0FBRyxHQUFHRCxJQUFJLENBQUM7UUFDL0QsSUFBSSxDQUFDRyxJQUFJLEVBQUU7VUFDUDtVQUNBQSxJQUFJLEdBQUdSLFFBQVEsQ0FBQ08sV0FBVyxDQUFDLEdBQUcsRUFBRUUsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3BEOztRQUVBO1FBQ0FMLFFBQVEsQ0FBQ3ZFLEtBQUssQ0FBQ1gsSUFBSSxDQUFDc0YsSUFBSSxDQUFDO1FBQ3pCO1FBQ0FBLElBQUksQ0FBQ0MsU0FBUyxDQUFDdkYsSUFBSSxDQUFDL0csQ0FBQyxHQUFHLENBQUMsQ0FBQztNQUM5Qjs7TUFFQTRMLFlBQVksQ0FBQzdFLElBQUksQ0FBQ2tGLFFBQVEsQ0FBQztJQUMvQjs7SUFFQSxJQUFJSCxhQUFhLEdBQUcsQ0FBQyxFQUFFO01BQ25CLE9BQU8sSUFBSTtJQUNmOztJQUVBO0lBQ0EsTUFBTVMsS0FBSyxHQUFHLENBQUNULGFBQWEsQ0FBQztJQUM3QixNQUFNVSxPQUFPLEdBQUcsSUFBSUMsR0FBRyxDQUFDLENBQUM7SUFDekIsTUFBTUMsY0FBYyxHQUFHLEVBQUU7O0lBRXpCLE9BQU9ILEtBQUssQ0FBQzNNLE1BQU0sR0FBRyxDQUFDLEVBQUU7TUFDckIsTUFBTStNLFdBQVcsR0FBR0osS0FBSyxDQUFDSyxLQUFLLENBQUMsQ0FBQzs7TUFFakMsSUFBSUosT0FBTyxDQUFDSyxHQUFHLENBQUNGLFdBQVcsQ0FBQyxFQUFFO1FBQzFCO01BQ0o7O01BRUFILE9BQU8sQ0FBQ00sR0FBRyxDQUFDSCxXQUFXLENBQUM7O01BRXhCO01BQ0FELGNBQWMsQ0FBQzNGLElBQUksQ0FBQzRGLFdBQVcsQ0FBQzs7TUFFaEM7TUFDQSxNQUFNVixRQUFRLEdBQUdMLFlBQVksQ0FBQ2UsV0FBVyxDQUFDO01BQzFDLEtBQUssTUFBTU4sSUFBSSxJQUFJSixRQUFRLENBQUN2RSxLQUFLLEVBQUU7UUFDL0IyRSxJQUFJLENBQUNDLFNBQVMsQ0FBQ1MsT0FBTyxDQUFDLENBQUFDLENBQUMsS0FBSUEsQ0FBQyxLQUFLTCxXQUFXLElBQUlKLEtBQUssQ0FBQ3hGLElBQUksQ0FBQ2lHLENBQUMsQ0FBQyxDQUFDO01BQ25FO0lBQ0o7O0lBRUE7SUFDQTtJQUNBLE1BQU1DLGFBQWEsR0FBRyxFQUFFO0lBQ3hCLElBQUl4QyxNQUFNLEdBQUcsQ0FBQztJQUNkaUMsY0FBYyxDQUFDSyxPQUFPLENBQUMsQ0FBQUcsT0FBTyxLQUFJO01BQzlCMUIsYUFBYSxDQUFDaEUsS0FBSyxDQUFDVCxJQUFJLENBQUMsSUFBSWxLLEtBQUssQ0FBQzZNLEtBQUssQ0FBQ2UsTUFBTSxFQUFFLEVBQUVBLE1BQU0sRUFBRSxFQUFFQSxNQUFNLEVBQUUsQ0FBQyxDQUFDO01BQ3ZFd0MsYUFBYSxDQUFDbEcsSUFBSSxDQUFDNkIsUUFBUSxDQUFDc0UsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDO01BQ3pDRCxhQUFhLENBQUNsRyxJQUFJLENBQUM2QixRQUFRLENBQUNzRSxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO01BQzdDRCxhQUFhLENBQUNsRyxJQUFJLENBQUM2QixRQUFRLENBQUNzRSxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2pELENBQUMsQ0FBQzs7SUFFRjFCLGFBQWEsQ0FBQzVDLFFBQVEsR0FBR3FFLGFBQWE7O0lBRXRDLE9BQU96QixhQUFhO0VBQ3hCLENBQUM7O0VBRUQsSUFBSSxDQUFDckQsd0JBQXdCLEdBQUcsVUFBUzdJLGNBQWMsRUFBRXVHLFFBQVEsRUFBRTRCLGFBQWEsRUFBQTBGLEtBQUEsRUFBaUIsS0FBZixFQUFDaEcsV0FBVyxFQUFDLEdBQUFnRyxLQUFBOztJQUUzRixNQUFNQyxRQUFRLEdBQUcsSUFBSXZRLEtBQUssQ0FBQ3FOLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2QyxJQUFJbUQsZ0JBQWdCO0lBQ3BCLElBQUlDLE9BQU8sR0FBR2pNLE1BQU0sQ0FBQ0MsU0FBUzs7SUFFOUIsSUFBSXdJLEVBQUUsR0FBRyxJQUFJak4sS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQztJQUM1QixJQUFJaU4sRUFBRSxHQUFHLElBQUlsTixLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDOztJQUU1QixJQUFJK0ksUUFBUSxDQUFDc0UsS0FBSyxLQUFLcEYsU0FBUyxJQUFJMEMsYUFBYSxJQUFJMUMsU0FBUyxFQUFFOztNQUU1RCxNQUFNeUYsVUFBVSxHQUFHLElBQUksQ0FBQzVFLGtCQUFrQixDQUFDQyxRQUFRLENBQUM7TUFDcEQ7TUFDQSxLQUFLLElBQUk3RixDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUd5SCxhQUFhLENBQUM3SCxNQUFNLEVBQUVJLENBQUMsRUFBRSxFQUFFOztRQUUzQyxJQUFJb0ssU0FBUyxHQUFHM0MsYUFBYSxDQUFDekgsQ0FBQyxDQUFDLENBQUNvSyxTQUFTO1FBQzFDO1FBQ0EsS0FBSyxJQUFJRSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdGLFNBQVMsQ0FBQ3hLLE1BQU0sR0FBRyxDQUFDLEVBQUUwSyxDQUFDLEVBQUUsRUFBRTtVQUMzQ0UsVUFBVSxDQUFDSixTQUFTLENBQUNFLENBQUMsQ0FBQyxFQUFFUixFQUFFLENBQUM7VUFDNUJVLFVBQVUsQ0FBQ0osU0FBUyxDQUFDRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUVQLEVBQUUsQ0FBQzs7VUFFaENELEVBQUUsQ0FBQ04sWUFBWSxDQUFDckMsV0FBVyxDQUFDO1VBQzVCNEMsRUFBRSxDQUFDUCxZQUFZLENBQUNyQyxXQUFXLENBQUM7O1VBRTVCLElBQUloSCxJQUFJLEdBQUc3RCxtQkFBbUIsQ0FBQ2dELGNBQWMsRUFBRXdLLEVBQUUsRUFBRUMsRUFBRSxDQUFDO1VBQ3RELElBQUk1SixJQUFJLEdBQUdtTixPQUFPLEVBQUU7WUFDaEJBLE9BQU8sR0FBR25OLElBQUk7WUFDZGtOLGdCQUFnQixHQUFHck4sQ0FBQztVQUN4QjtRQUNKO01BQ0o7O01BRUEsSUFBSXFOLGdCQUFnQixFQUFFO1FBQ2xCakQsU0FBUyxHQUFHM0MsYUFBYSxDQUFDNEYsZ0JBQWdCLENBQUMsQ0FBQ2pELFNBQVM7UUFDckQsS0FBSyxJQUFJbUQsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHbkQsU0FBUyxDQUFDeEssTUFBTSxHQUFHLENBQUMsRUFBRTJOLENBQUMsRUFBRSxFQUFFO1VBQzNDLE1BQU1DLEdBQUcsR0FBR2hELFVBQVUsQ0FBQ0osU0FBUyxDQUFDbUQsQ0FBQyxDQUFDLENBQUM7VUFDcEMsTUFBTUUsR0FBRyxHQUFHakQsVUFBVSxDQUFDSixTQUFTLENBQUNtRCxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7O1VBRXhDSCxRQUFRLENBQUN4RSxRQUFRLENBQUM3QixJQUFJLENBQUN5RyxHQUFHLENBQUM7VUFDM0I7VUFDQUosUUFBUSxDQUFDeEUsUUFBUSxDQUFDN0IsSUFBSSxDQUFDMEcsR0FBRyxDQUFDO1FBQy9CO01BQ0o7SUFDSjs7SUFFQSxJQUFJck0sZUFBZSxJQUFJa00sT0FBTyxJQUFJRixRQUFRLENBQUN4RSxRQUFRLENBQUNoSixNQUFNLEdBQUcsQ0FBQyxFQUFFOztNQUU1RHdCLGVBQWUsR0FBR2tNLE9BQU87TUFDekJGLFFBQVEsQ0FBQzVELFlBQVksQ0FBQ3JDLFdBQVcsQ0FBQztNQUNsQ3pHLFdBQVcsQ0FBQ3FDLFFBQVEsR0FBR3FLLFFBQVE7SUFDbkM7RUFDSixDQUFDOztFQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSSxJQUFJLENBQUM3RCxtQkFBbUIsR0FBRyxVQUFTOEMsSUFBSSxFQUFFeEcsUUFBUSxFQUFFOztJQUVoRCxNQUFNMkUsVUFBVSxHQUFHLElBQUksQ0FBQzVFLGtCQUFrQixDQUFDQyxRQUFRLENBQUM7SUFDcEQsTUFBTWtGLEVBQUUsR0FBR1AsVUFBVSxDQUFDNkIsSUFBSSxDQUFDMVEsQ0FBQyxDQUFDO0lBQzdCLE1BQU0wSyxFQUFFLEdBQUdtRSxVQUFVLENBQUM2QixJQUFJLENBQUN6USxDQUFDLENBQUM7O0lBRTdCLE1BQU13UixRQUFRLEdBQUcsSUFBSXZRLEtBQUssQ0FBQ3FOLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDa0QsUUFBUSxDQUFDeEUsUUFBUSxDQUFDN0IsSUFBSSxDQUFDZ0UsRUFBRSxFQUFFMUUsRUFBRSxDQUFDO0lBQzlCLE9BQU8rRyxRQUFRO0VBQ25CLENBQUM7O0VBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJLElBQUksQ0FBQ3hELFlBQVksR0FBRyxVQUFTL0UsSUFBSSxFQUFFdkYsY0FBYyxFQUFFOztJQUUvQyxNQUFNc0osUUFBUSxHQUFHLEVBQUU7SUFDbkIsTUFBTThFLGNBQWMsR0FBRzdJLElBQUksQ0FBQytELFFBQVEsQ0FBQ2hKLE1BQU07SUFDM0MsSUFBSStOLFNBQVMsR0FBRyxJQUFJO0lBQ3BCLElBQUlDLFNBQVMsR0FBRyxJQUFJO0lBQ3BCLElBQUlDLFNBQVMsR0FBRyxJQUFJOztJQUVwQixLQUFLLElBQUk3TixDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUcwTixjQUFjLEVBQUUxTixDQUFDLElBQUksQ0FBQyxFQUFFO01BQ3hDLE1BQU04TixHQUFHLEdBQUdqSixJQUFJLENBQUMrRCxRQUFRLENBQUM1SSxDQUFDLENBQUM7TUFDNUIsTUFBTStOLEdBQUcsR0FBR2xKLElBQUksQ0FBQytELFFBQVEsQ0FBQzVJLENBQUMsR0FBRyxDQUFDLENBQUM7TUFDaEMsTUFBTWdPLEdBQUcsR0FBR25KLElBQUksQ0FBQytELFFBQVEsQ0FBQzVJLENBQUMsR0FBRyxDQUFDLENBQUM7O01BRWhDLEtBQUssSUFBSXNLLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR29ELGNBQWMsRUFBRXBELENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDeEMsSUFBS3RLLENBQUMsS0FBS3NLLENBQUMsRUFBRztVQUNYLE1BQU0yRCxHQUFHLEdBQUdwSixJQUFJLENBQUMrRCxRQUFRLENBQUMwQixDQUFDLENBQUM7VUFDNUIsTUFBTTRELEdBQUcsR0FBR3JKLElBQUksQ0FBQytELFFBQVEsQ0FBQzBCLENBQUMsR0FBRyxDQUFDLENBQUM7VUFDaEMsTUFBTTZELEdBQUcsR0FBR3RKLElBQUksQ0FBQytELFFBQVEsQ0FBQzBCLENBQUMsR0FBRyxDQUFDLENBQUM7VUFDaEM7VUFDQSxJQUFJLENBQUN3RCxHQUFHLENBQUNwUixNQUFNLENBQUN1UixHQUFHLENBQUMsSUFBSUgsR0FBRyxDQUFDcFIsTUFBTSxDQUFDd1IsR0FBRyxDQUFDLElBQUlKLEdBQUcsQ0FBQ3BSLE1BQU0sQ0FBQ3lSLEdBQUcsQ0FBQztVQUNsREosR0FBRyxDQUFDclIsTUFBTSxDQUFDdVIsR0FBRyxDQUFDLElBQUlGLEdBQUcsQ0FBQ3JSLE1BQU0sQ0FBQ3dSLEdBQUcsQ0FBQyxJQUFJSCxHQUFHLENBQUNyUixNQUFNLENBQUN5UixHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQzVEUixTQUFTLEdBQUcsS0FBSztVQUNyQjtVQUNBO1VBQ0E7VUFDQSxJQUFJLENBQUNHLEdBQUcsQ0FBQ3BSLE1BQU0sQ0FBQ3VSLEdBQUcsQ0FBQyxJQUFJSCxHQUFHLENBQUNwUixNQUFNLENBQUN3UixHQUFHLENBQUMsSUFBSUosR0FBRyxDQUFDcFIsTUFBTSxDQUFDeVIsR0FBRyxDQUFDO1VBQ2xESCxHQUFHLENBQUN0UixNQUFNLENBQUN1UixHQUFHLENBQUMsSUFBSUQsR0FBRyxDQUFDdFIsTUFBTSxDQUFDd1IsR0FBRyxDQUFDLElBQUlGLEdBQUcsQ0FBQ3RSLE1BQU0sQ0FBQ3lSLEdBQUcsQ0FBQyxDQUFDLEVBQUU7WUFDNURQLFNBQVMsR0FBRyxLQUFLO1VBQ3JCO1VBQ0E7VUFDQTtVQUNBLElBQUksQ0FBQ0csR0FBRyxDQUFDclIsTUFBTSxDQUFDdVIsR0FBRyxDQUFDLElBQUlGLEdBQUcsQ0FBQ3JSLE1BQU0sQ0FBQ3dSLEdBQUcsQ0FBQyxJQUFJSCxHQUFHLENBQUNyUixNQUFNLENBQUN5UixHQUFHLENBQUM7VUFDbERILEdBQUcsQ0FBQ3RSLE1BQU0sQ0FBQ3VSLEdBQUcsQ0FBQyxJQUFJRCxHQUFHLENBQUN0UixNQUFNLENBQUN3UixHQUFHLENBQUMsSUFBSUYsR0FBRyxDQUFDdFIsTUFBTSxDQUFDeVIsR0FBRyxDQUFDLENBQUMsRUFBRTtZQUM1RE4sU0FBUyxHQUFHLEtBQUs7VUFDckI7UUFDSjtNQUNKOztNQUVBLElBQUlGLFNBQVMsRUFBRTtRQUNYL0UsUUFBUSxDQUFDN0IsSUFBSSxDQUFDK0csR0FBRyxDQUFDdFAsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUMxQm9LLFFBQVEsQ0FBQzdCLElBQUksQ0FBQ2dILEdBQUcsQ0FBQ3ZQLEtBQUssQ0FBQyxDQUFDLENBQUM7TUFDOUI7TUFDQSxJQUFJb1AsU0FBUyxFQUFFO1FBQ1hoRixRQUFRLENBQUM3QixJQUFJLENBQUMrRyxHQUFHLENBQUN0UCxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzFCb0ssUUFBUSxDQUFDN0IsSUFBSSxDQUFDaUgsR0FBRyxDQUFDeFAsS0FBSyxDQUFDLENBQUMsQ0FBQztNQUM5QjtNQUNBLElBQUlxUCxTQUFTLEVBQUU7UUFDWGpGLFFBQVEsQ0FBQzdCLElBQUksQ0FBQ2dILEdBQUcsQ0FBQ3ZQLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDMUJvSyxRQUFRLENBQUM3QixJQUFJLENBQUNpSCxHQUFHLENBQUN4UCxLQUFLLENBQUMsQ0FBQyxDQUFDO01BQzlCOztNQUVBbVAsU0FBUyxHQUFHLElBQUk7TUFDaEJDLFNBQVMsR0FBRyxJQUFJO01BQ2hCQyxTQUFTLEdBQUcsSUFBSTs7SUFFcEI7O0lBRUE7O0lBRUEsTUFBTU8sWUFBWSxHQUFHLEVBQUU7SUFDdkIsTUFBTWhCLFFBQVEsR0FBRyxJQUFJdlEsS0FBSyxDQUFDcU4sUUFBUSxDQUFDLENBQUM7SUFDckMsSUFBSW1FLFlBQVk7SUFDaEIsSUFBSWYsT0FBTyxHQUFHak0sTUFBTSxDQUFDQyxTQUFTOztJQUU5QixLQUFLLElBQUlpTSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUczRSxRQUFRLENBQUNoSixNQUFNLEVBQUUyTixDQUFDLElBQUksQ0FBQyxFQUFFOztNQUV6QyxJQUFJcE4sSUFBSSxHQUFHN0QsbUJBQW1CLENBQUNnRCxjQUFjLEVBQUVzSixRQUFRLENBQUMyRSxDQUFDLENBQUMsRUFBRTNFLFFBQVEsQ0FBQzJFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzs7TUFFNUUsSUFBSXBOLElBQUksR0FBR21OLE9BQU8sRUFBRTtRQUNoQkEsT0FBTyxHQUFHbk4sSUFBSTtRQUNka08sWUFBWSxHQUFHZCxDQUFDO01BQ3BCOztJQUVKOztJQUVBYSxZQUFZLENBQUNySCxJQUFJLENBQUM2QixRQUFRLENBQUV5RixZQUFZLENBQUUsQ0FBQzdQLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDbkQ0UCxZQUFZLENBQUNySCxJQUFJLENBQUM2QixRQUFRLENBQUV5RixZQUFZLEdBQUcsQ0FBQyxDQUFFLENBQUM3UCxLQUFLLENBQUMsQ0FBQyxDQUFDOztJQUV2RCxNQUFNOFAsUUFBUSxHQUFHLElBQUl6UixLQUFLLENBQUNxTixRQUFRLENBQUMsQ0FBQztJQUNyQ29FLFFBQVEsQ0FBQzFGLFFBQVEsR0FBR0EsUUFBUTtJQUM1QndFLFFBQVEsQ0FBQ3hFLFFBQVEsR0FBRyxJQUFJLENBQUMyRixrQ0FBa0MsQ0FBQ0QsUUFBUSxFQUFFRixZQUFZLENBQUM7O0lBRW5GaE4sZUFBZSxHQUFHa00sT0FBTzs7SUFFekIsT0FBT0YsUUFBUTtFQUNuQixDQUFDOztFQUVELElBQUksQ0FBQ21CLGtDQUFrQyxHQUFHLFVBQVNELFFBQVEsRUFBRUYsWUFBWSxFQUFFOztJQUV2RSxNQUFNeEYsUUFBUSxHQUFHMEYsUUFBUSxDQUFDMUYsUUFBUSxDQUFDNEYsS0FBSyxDQUFDLENBQUM7SUFDMUMsSUFBSXpELEVBQUUsR0FBR3FELFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDeEIsSUFBSS9ILEVBQUUsR0FBRytILFlBQVksQ0FBQyxDQUFDLENBQUM7O0lBRXhCLElBQUlLLE1BQU0sR0FBRyxFQUFFOztJQUVmLEdBQUc7O01BRUNBLE1BQU0sR0FBRyxFQUFFOztNQUVYLEtBQUssSUFBSW5FLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRzFCLFFBQVEsQ0FBQ2hKLE1BQU0sRUFBRTBLLENBQUMsSUFBSSxDQUFDLEVBQUU7O1FBRXpDO1FBQ0EsSUFBSTFCLFFBQVEsQ0FBQzBCLENBQUMsQ0FBQyxDQUFDNU4sTUFBTSxDQUFDcU8sRUFBRSxDQUFDLElBQUluQyxRQUFRLENBQUMwQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM1TixNQUFNLENBQUMySixFQUFFLENBQUMsRUFBRTs7VUFFdEQ7UUFDSjs7UUFFQSxLQUFLLElBQUlrSCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUdhLFlBQVksQ0FBQ3hPLE1BQU0sRUFBRTJOLENBQUMsSUFBSSxDQUFDLEVBQUU7O1VBRTdDO1VBQ0EsSUFBSTNFLFFBQVEsQ0FBQzBCLENBQUMsQ0FBQyxDQUFDNU4sTUFBTSxDQUFDMFIsWUFBWSxDQUFDYixDQUFDLENBQUMsQ0FBQyxJQUFJM0UsUUFBUSxDQUFDMEIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDNU4sTUFBTSxDQUFDMFIsWUFBWSxDQUFDYixDQUFDLENBQUMsQ0FBQztVQUM5RTNFLFFBQVEsQ0FBQzBCLENBQUMsQ0FBQyxDQUFDNU4sTUFBTSxDQUFDMFIsWUFBWSxDQUFDYixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSTNFLFFBQVEsQ0FBQzBCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzVOLE1BQU0sQ0FBQzBSLFlBQVksQ0FBQ2IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU7O1lBRXhGLElBQUltQixFQUFFLEdBQUcsSUFBSTdSLEtBQUssQ0FBQ0MsT0FBTyxDQUFDLENBQUM7WUFDNUIsSUFBSTZSLEVBQUUsR0FBRyxJQUFJOVIsS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQzs7WUFFNUI0UixFQUFFLENBQUN4UixVQUFVLENBQUNrUixZQUFZLENBQUNiLENBQUMsQ0FBQyxFQUFHYSxZQUFZLENBQUNiLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNwRG1CLEVBQUUsQ0FBQ3hHLFNBQVMsQ0FBQyxDQUFDO1lBQ2R5RyxFQUFFLENBQUN6UixVQUFVLENBQUMwTCxRQUFRLENBQUMwQixDQUFDLENBQUMsRUFBQzFCLFFBQVEsQ0FBQzBCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMxQ3FFLEVBQUUsQ0FBQ3pHLFNBQVMsQ0FBQyxDQUFDOztZQUVkO1lBQ0EsSUFBSW5NLDJCQUEyQixDQUFDMlMsRUFBRSxFQUFFQyxFQUFFLENBQUMsSUFBSXRTLDZCQUE2QixDQUFDcVMsRUFBRSxFQUFFQyxFQUFFLENBQUM7WUFDaEY7O2NBRUlGLE1BQU0sQ0FBQzFILElBQUksQ0FBQ3VELENBQUMsQ0FBQztjQUNkOztZQUVKO1VBQ0o7UUFDSjtNQUNKOztNQUVBLEtBQUssSUFBSXNFLEVBQUUsR0FBR0gsTUFBTSxDQUFDN08sTUFBTSxHQUFHLENBQUMsRUFBRWdQLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRUEsRUFBRSxFQUFFOztRQUU1Q1IsWUFBWSxDQUFDckgsSUFBSSxDQUFDNkIsUUFBUSxDQUFFNkYsTUFBTSxDQUFDRyxFQUFFLENBQUMsQ0FBRSxDQUFDO1FBQ3pDUixZQUFZLENBQUNySCxJQUFJLENBQUM2QixRQUFRLENBQUU2RixNQUFNLENBQUNHLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBRSxDQUFDO1FBQzdDaEcsUUFBUSxDQUFDaUcsTUFBTSxDQUFDSixNQUFNLENBQUNHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztNQUNsQzs7SUFFSixDQUFDLFFBQVFILE1BQU0sQ0FBQzdPLE1BQU0sR0FBRyxDQUFDOztJQUUxQixPQUFPd08sWUFBWTs7RUFFdkIsQ0FBQzs7RUFFRCxJQUFJLENBQUNoRywwQkFBMEIsR0FBRyxVQUFTaUUsSUFBSSxFQUFFL00sY0FBYyxFQUFFOztJQUU3RCxJQUFJZ08sT0FBTyxHQUFHak0sTUFBTSxDQUFDQyxTQUFTO0lBQzlCLElBQUkvRSxLQUFLLEdBQUcsSUFBSU0sS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQztJQUMvQixJQUFJLENBQUN1UCxJQUFJLEVBQUU7TUFDUCxPQUFPOVAsS0FBSztJQUNoQjs7SUFFQSxJQUFJOFAsSUFBSSxDQUFDekQsUUFBUSxDQUFDaEosTUFBTSxHQUFHLENBQUMsRUFBRTtNQUMxQixNQUFNbEIsS0FBSyxHQUFHMk4sSUFBSSxDQUFDekQsUUFBUSxDQUFDLENBQUMsQ0FBQztNQUM5QixNQUFNakssR0FBRyxHQUFHME4sSUFBSSxDQUFDekQsUUFBUSxDQUFDeUQsSUFBSSxDQUFDekQsUUFBUSxDQUFDaEosTUFBTSxHQUFHLENBQUMsQ0FBQztNQUNuRCxJQUFJa1AsS0FBSyxHQUFHeFAsY0FBYyxDQUFDM0MsVUFBVSxDQUFDK0IsS0FBSyxDQUFDO01BQzVDLElBQUlxUSxLQUFLLEdBQUd6UCxjQUFjLENBQUMzQyxVQUFVLENBQUNnQyxHQUFHLENBQUM7O01BRTFDLElBQUltUSxLQUFLLElBQUlDLEtBQUssRUFBRTtRQUNoQnpCLE9BQU8sR0FBR3dCLEtBQUs7UUFDZnZTLEtBQUssR0FBR21DLEtBQUssQ0FBQ0YsS0FBSyxDQUFDLENBQUM7TUFDekIsQ0FBQztNQUNJO1FBQ0Q4TyxPQUFPLEdBQUd5QixLQUFLO1FBQ2Z4UyxLQUFLLEdBQUdvQyxHQUFHLENBQUNILEtBQUssQ0FBQyxDQUFDO01BQ3ZCO0lBQ0o7O0lBRUErQyxpQkFBaUIsR0FBRytMLE9BQU87O0lBRTNCLE9BQU8vUSxLQUFLO0VBQ2hCLENBQUM7O0VBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJLElBQUksQ0FBQ2tOLGNBQWMsR0FBRyxVQUFTNEMsSUFBSSxFQUFFL00sY0FBYyxFQUFFOztJQUVqRCxJQUFJZ08sT0FBTyxHQUFHak0sTUFBTSxDQUFDQyxTQUFTO0lBQzlCLElBQUkvRSxLQUFLLEdBQUcsSUFBSU0sS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQztJQUMvQixNQUFNNFEsY0FBYyxHQUFHckIsSUFBSSxDQUFDekQsUUFBUSxDQUFDaEosTUFBTTs7SUFFM0MsS0FBSyxJQUFJSSxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUcwTixjQUFjLEVBQUUsRUFBRTFOLENBQUMsRUFBRTtNQUNyQyxNQUFNZ1AsRUFBRSxHQUFHM0MsSUFBSSxDQUFDekQsUUFBUSxDQUFDNUksQ0FBQyxDQUFDO01BQzNCLE1BQU1HLElBQUksR0FBR2IsY0FBYyxDQUFDM0MsVUFBVSxDQUFDcVMsRUFBRSxDQUFDOztNQUUxQyxJQUFJN08sSUFBSSxHQUFHbU4sT0FBTyxHQUFHalMsY0FBYyxFQUFFOztRQUVqQ2lTLE9BQU8sR0FBR25OLElBQUk7UUFDZDVELEtBQUssR0FBR3lTLEVBQUUsQ0FBQ3hRLEtBQUssQ0FBQyxDQUFDOztNQUV0QjtJQUNKOztJQUVBK0MsaUJBQWlCLEdBQUcrTCxPQUFPOztJQUUzQixPQUFPL1EsS0FBSztFQUNoQixDQUFDOztFQUVEO0VBQ0EsSUFBSSxDQUFDa00sWUFBWSxHQUFHLFVBQVM0RCxJQUFJLEVBQUU7O0lBRS9CLE1BQU16RCxRQUFRLEdBQUd5RCxJQUFJLENBQUN6RCxRQUFROztJQUU5QjtJQUNBLElBQUlBLFFBQVEsQ0FBQ2hKLE1BQU0sR0FBRyxDQUFDLEVBQUU7TUFDckIsT0FBTyxLQUFLO0lBQ2hCOztJQUVBLE1BQU1sQixLQUFLLEdBQUdrSyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQ3pCLE1BQU1qSyxHQUFHLEdBQUdpSyxRQUFRLENBQUNBLFFBQVEsQ0FBQ2hKLE1BQU0sR0FBRyxDQUFDLENBQUM7O0lBRXpDLElBQUlsQixLQUFLLENBQUNoQyxNQUFNLENBQUNpQyxHQUFHLENBQUMsRUFBRTs7TUFFbkIsSUFBSVQsTUFBTSxHQUFHLElBQUlyQixLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztNQUN2QyxLQUFLLElBQUlrRCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUc0SSxRQUFRLENBQUNoSixNQUFNLEVBQUVJLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDekM5QixNQUFNLENBQUM0TyxHQUFHLENBQUNsRSxRQUFRLENBQUM1SSxDQUFDLENBQUMsQ0FBQztNQUMzQjtNQUNBOUIsTUFBTSxDQUFDK1EsWUFBWSxDQUFDckcsUUFBUSxDQUFDaEosTUFBTSxHQUFHLEdBQUcsQ0FBQzs7TUFFMUMsSUFBSTdCLE1BQU0sR0FBR0csTUFBTSxDQUFDdkIsVUFBVSxDQUFDK0IsS0FBSyxDQUFDO01BQ3JDLEtBQUssSUFBSXNCLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRzRJLFFBQVEsQ0FBQ2hKLE1BQU0sRUFBRUksQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUN6QyxJQUFJbkUsSUFBSSxDQUFDQyxHQUFHLENBQUNvQyxNQUFNLENBQUN2QixVQUFVLENBQUNpTSxRQUFRLENBQUM1SSxDQUFDLENBQUMsQ0FBQyxHQUFHakMsTUFBTSxDQUFDLElBQUkxQyxjQUFjLEVBQUU7VUFDckU7UUFDSixDQUFDO1FBQ0k7VUFDRCxPQUFPLEtBQUs7UUFDaEI7TUFDSjtNQUNBLE9BQU82QyxNQUFNO0lBQ2pCLENBQUM7SUFDSTtNQUNELE9BQU8sS0FBSztJQUNoQjtFQUNKLENBQUM7O0VBRUQsSUFBSSxDQUFDNEssWUFBWSxHQUFHLFVBQVV1RCxJQUFJLEVBQUU7O0lBRWhDLE1BQU16RCxRQUFRLEdBQUd5RCxJQUFJLENBQUN6RCxRQUFRO0lBQzlCLE1BQU1sSyxLQUFLLEdBQUdrSyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQ3pCLE1BQU1qSyxHQUFHLEdBQUdpSyxRQUFRLENBQUNBLFFBQVEsQ0FBQ2hKLE1BQU0sR0FBRyxDQUFDLENBQUM7O0lBRXpDLElBQUlnSixRQUFRLENBQUNoSixNQUFNLElBQUksQ0FBQyxFQUFFO01BQ3RCLE9BQU8sS0FBSztJQUNoQixDQUFDO0lBQ0ksSUFBSWxCLEtBQUssQ0FBQ2hDLE1BQU0sQ0FBQ2lDLEdBQUcsQ0FBQyxFQUFFO01BQ3hCLE9BQU8sSUFBSTtJQUNmLENBQUM7SUFDSTtNQUNELElBQUlnUSxFQUFFLEdBQUcsSUFBSTlSLEtBQUssQ0FBQ0MsT0FBTyxDQUFDLENBQUM7TUFDNUIsSUFBSWdSLEdBQUc7TUFDUCxJQUFJQyxHQUFHLEdBQUduRixRQUFRLENBQUMsQ0FBQyxDQUFDOztNQUVyQitGLEVBQUUsQ0FBQ3pSLFVBQVUsQ0FBQ3dCLEtBQUssRUFBRXFQLEdBQUcsQ0FBQzs7TUFFekIsSUFBSW1CLEVBQUUsR0FBRyxJQUFJclMsS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQztNQUM1QixLQUFLLElBQUlrRCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUc0SSxRQUFRLENBQUNoSixNQUFNLEVBQUVJLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDekM4TixHQUFHLEdBQUdsRixRQUFRLENBQUM1SSxDQUFDLENBQUM7UUFDakIrTixHQUFHLEdBQUduRixRQUFRLENBQUM1SSxDQUFDLEdBQUdBLENBQUMsQ0FBQztRQUNyQmtQLEVBQUUsQ0FBQ2hTLFVBQVUsQ0FBQzRRLEdBQUcsRUFBRUMsR0FBRyxDQUFDO1FBQ3ZCLElBQUksQ0FBQ2hTLDJCQUEyQixDQUFDNFMsRUFBRSxFQUFFTyxFQUFFLENBQUMsRUFBRTtVQUN0QyxPQUFPLElBQUk7UUFDZjtNQUNKOztNQUVBLE9BQU8sS0FBSztJQUNoQjtFQUNKLENBQUM7O0VBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtFQUNJLElBQUksQ0FBQ2pHLFlBQVksR0FBRyxVQUFVcEUsSUFBSSxFQUFFOztJQUVoQyxNQUFNK0QsUUFBUSxHQUFHL0QsSUFBSSxDQUFDK0QsUUFBUTtJQUM5QixNQUFNcEIsS0FBSyxHQUFHM0MsSUFBSSxDQUFDMkMsS0FBSzs7SUFFeEIsSUFBSUEsS0FBSyxDQUFDNUgsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFFLE9BQU8sS0FBSyxDQUFFOztJQUV2QyxJQUFJdVAsR0FBRyxHQUFHLElBQUl0UyxLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDO0lBQzdCLE1BQU1zUyxHQUFHLEdBQUd4RyxRQUFRLENBQUNwQixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM3TCxDQUFDLENBQUM7SUFDaENrQixLQUFLLENBQUNvTyxRQUFRLENBQUNDLFNBQVMsQ0FBQ3RDLFFBQVEsQ0FBQ3BCLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzdMLENBQUMsQ0FBQyxFQUFFaU4sUUFBUSxDQUFDcEIsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDNUwsQ0FBQyxDQUFDLEVBQUVnTixRQUFRLENBQUNwQixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMrQyxDQUFDLENBQUMsRUFBRTRFLEdBQUcsQ0FBQzs7SUFFL0YsSUFBSUUsR0FBRyxHQUFHLElBQUl4UyxLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDO0lBQzdCLEtBQUssSUFBSWtELENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR3dILEtBQUssQ0FBQzVILE1BQU0sRUFBRUksQ0FBQyxFQUFFLEVBQUU7TUFDbkMsTUFBTXNQLEdBQUcsR0FBRzFHLFFBQVEsQ0FBQ3BCLEtBQUssQ0FBQ3hILENBQUMsQ0FBQyxDQUFDckUsQ0FBQyxDQUFDO01BQ2hDa0IsS0FBSyxDQUFDb08sUUFBUSxDQUFDQyxTQUFTLENBQUN0QyxRQUFRLENBQUNwQixLQUFLLENBQUN4SCxDQUFDLENBQUMsQ0FBQ3JFLENBQUMsQ0FBQyxFQUFFaU4sUUFBUSxDQUFDcEIsS0FBSyxDQUFDeEgsQ0FBQyxDQUFDLENBQUNwRSxDQUFDLENBQUMsRUFBRWdOLFFBQVEsQ0FBQ3BCLEtBQUssQ0FBQ3hILENBQUMsQ0FBQyxDQUFDdUssQ0FBQyxDQUFDLEVBQUU4RSxHQUFHLENBQUM7TUFDL0YsSUFBSSxDQUFDdFQsMkJBQTJCLENBQUNvVCxHQUFHLEVBQUVFLEdBQUcsQ0FBQyxJQUFJLENBQUMzVCxvQkFBb0IsQ0FBQ3lULEdBQUcsQ0FBQ2hTLEdBQUcsQ0FBQ2lTLEdBQUcsQ0FBQyxFQUFFQyxHQUFHLENBQUNsUyxHQUFHLENBQUNtUyxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQzdGLE9BQU8sSUFBSTtNQUNmO0lBQ0o7O0lBRUEsT0FBTyxLQUFLO0VBQ2hCLENBQUM7O0VBRUQsSUFBSSxDQUFDQyxZQUFZLEdBQUcsVUFBU0MsTUFBTSxFQUFFOztJQUVqQyxJQUFJQSxNQUFNLENBQUN0VCxDQUFDLEdBQUcsQ0FBQyxJQUFJc1QsTUFBTSxDQUFDclQsQ0FBQyxJQUFJLENBQUMsRUFBRTtNQUMvQixPQUFPTixJQUFJLENBQUM0VCxJQUFJLENBQUNELE1BQU0sQ0FBQ3JULENBQUMsR0FBR3FULE1BQU0sQ0FBQ3RULENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBQ0ksSUFBSXNULE1BQU0sQ0FBQ3RULENBQUMsSUFBSSxDQUFDLElBQUlzVCxNQUFNLENBQUNyVCxDQUFDLEdBQUcsQ0FBQyxFQUFFO01BQ3BDLE9BQU9OLElBQUksQ0FBQzRULElBQUksQ0FBQ0QsTUFBTSxDQUFDclQsQ0FBQyxHQUFHcVQsTUFBTSxDQUFDdFQsQ0FBQyxDQUFDLEdBQUdMLElBQUksQ0FBQzZULEVBQUUsR0FBRyxDQUFDO0lBQ3ZELENBQUM7SUFDSSxJQUFJRixNQUFNLENBQUN0VCxDQUFDLEdBQUcsQ0FBQyxJQUFJc1QsTUFBTSxDQUFDclQsQ0FBQyxJQUFJLENBQUMsRUFBRTtNQUNwQyxPQUFPTixJQUFJLENBQUM0VCxJQUFJLENBQUNELE1BQU0sQ0FBQ3JULENBQUMsR0FBR3FULE1BQU0sQ0FBQ3RULENBQUMsQ0FBQyxHQUFHTCxJQUFJLENBQUM2VCxFQUFFO0lBQ25ELENBQUM7SUFDSSxJQUFJRixNQUFNLENBQUN0VCxDQUFDLElBQUksQ0FBQyxJQUFJc1QsTUFBTSxDQUFDclQsQ0FBQyxHQUFHLENBQUMsRUFBRTtNQUNwQyxPQUFPTixJQUFJLENBQUM0VCxJQUFJLENBQUNELE1BQU0sQ0FBQ3JULENBQUMsR0FBR3FULE1BQU0sQ0FBQ3RULENBQUMsQ0FBQyxHQUFHTCxJQUFJLENBQUM2VCxFQUFFO0lBQ25ELENBQUM7SUFDRyxDQUFFO01BQ0YsT0FBTyxJQUFJO0lBQ2Y7RUFDSixDQUFDOztFQUVEO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsTUFBTUMsMkJBQTJCLEdBQUdBLENBQUNDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRTVSLFVBQVUsRUFBRUMsUUFBUSxFQUFFNFIsU0FBUyxLQUFLO0lBQ3JGLElBQUluSyxRQUFRLEdBQUcsSUFBSWhKLEtBQUssQ0FBQ3FOLFFBQVEsQ0FBQyxDQUFDO0lBQ25DLEtBQUssSUFBSWxLLENBQUMsR0FBQyxDQUFDLEVBQUVBLENBQUMsR0FBQ2dRLFNBQVMsRUFBRWhRLENBQUMsRUFBRSxFQUFFO01BQzVCLE1BQU0wRyxDQUFDLEdBQUcsSUFBSTdKLEtBQUssQ0FBQ0MsT0FBTyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDO01BQ2xDLE1BQU1rUSxDQUFDLEdBQUdoTixDQUFDLElBQUVnUSxTQUFTLEdBQUMsQ0FBQyxDQUFDO01BQ3pCaFYsUUFBUSxDQUFDaVYsVUFBVSxDQUFDQyxRQUFRLENBQUNDLGtCQUFrQixDQUFDbkQsQ0FBQyxFQUFFNEMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFNVIsVUFBVSxFQUFFQyxRQUFRLEVBQUUsR0FBRyxFQUFFc0ksQ0FBQyxDQUFDO01BQ2hHYixRQUFRLENBQUMrQyxRQUFRLENBQUM3QixJQUFJLENBQUNMLENBQUMsQ0FBQztJQUM3QjtJQUNBLE9BQU9iLFFBQVE7RUFDbkIsQ0FBQzs7RUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSSxTQUFTdUssZ0JBQWdCQSxDQUFDNVAsTUFBTSxFQUFFNlAsT0FBTyxFQUFFQyxhQUFhLEVBQUU7SUFDdEQsSUFBSSxDQUFDOVAsTUFBTSxHQUFHQSxNQUFNO0lBQ3BCLElBQUksQ0FBQzZQLE9BQU8sR0FBR0EsT0FBTzs7SUFFdEIsSUFBSSxDQUFDL0IsUUFBUSxHQUFHLElBQUl6UixLQUFLLENBQUNxTixRQUFRLENBQUMsQ0FBQztJQUNwQyxJQUFJLENBQUNxRyxXQUFXLEdBQUcsSUFBSTtJQUN2QixJQUFJLENBQUM3SCxpQkFBaUI7SUFDdEIsSUFBSSxDQUFDQyxpQkFBaUI7SUFDdEIsSUFBSSxDQUFDNkgsYUFBYSxHQUFHLElBQUk7SUFDekIsSUFBSSxDQUFDQyxtQkFBbUI7O0lBRXhCLElBQUksQ0FBQ25ELE9BQU8sR0FBR2pNLE1BQU0sQ0FBQ0MsU0FBUzs7SUFFL0IsSUFBSSxDQUFDb1AsTUFBTSxHQUFHLElBQUk3VCxLQUFLLENBQUN1SyxPQUFPLENBQUMsQ0FBQzs7SUFFakMsSUFBSSxDQUFDdUosUUFBUSxHQUFHLElBQUk7SUFDcEIsSUFBSSxDQUFDQyxZQUFZLEdBQUcsSUFBSTtJQUN4QixJQUFJLENBQUNDLGNBQWMsR0FBRyxJQUFJOztJQUUxQixJQUFJLENBQUNDLFlBQVksR0FBR1IsYUFBYTs7SUFFakM7SUFDQTtJQUNBLElBQUksQ0FBQ1MsY0FBYyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0VBQzlCOztFQUVBWCxnQkFBZ0IsQ0FBQy9QLFNBQVMsQ0FBQzJRLGFBQWEsR0FBRyxVQUFTQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUV6TixJQUFJLEVBQUU7SUFDdEUsSUFBSXJFLGNBQWMsR0FBRyxJQUFJLENBQUMrUSxPQUFPLENBQUNoTixpQkFBaUIsQ0FBQyxDQUFDO0lBQ3JELElBQUlySCxFQUFFLEdBQUcsSUFBSWEsS0FBSyxDQUFDQyxPQUFPLENBQUNtVSxFQUFFLEVBQUVDLEVBQUUsRUFBRTVSLGNBQWMsQ0FBQ2xELENBQUMsQ0FBQztJQUNwRCxJQUFJSCxFQUFFLEdBQUcsSUFBSVksS0FBSyxDQUFDQyxPQUFPLENBQUNxVSxFQUFFLEVBQUVDLEVBQUUsRUFBRTlSLGNBQWMsQ0FBQ2xELENBQUMsQ0FBQzs7SUFFcEQ7SUFDQSxJQUFJLElBQUksQ0FBQ3NVLE1BQU0sRUFBRTtNQUNiMVUsRUFBRSxDQUFDd04sWUFBWSxDQUFDLElBQUksQ0FBQ2tILE1BQU0sQ0FBQztNQUM1QnpVLEVBQUUsQ0FBQ3VOLFlBQVksQ0FBQyxJQUFJLENBQUNrSCxNQUFNLENBQUM7SUFDaEM7O0lBRUE7SUFDQSxJQUFJdlEsSUFBSSxHQUFHN0QsbUJBQW1CLENBQUNnRCxjQUFjLEVBQUV0RCxFQUFFLEVBQUVDLEVBQUUsQ0FBQztJQUN0RCxJQUFJa0UsSUFBSSxHQUFHLElBQUksQ0FBQzJRLFlBQVksRUFBRTtNQUMxQjtJQUNKOztJQUVBO0lBQ0EsSUFBSSxDQUFDQyxjQUFjLENBQUNoSyxJQUFJLENBQUMsSUFBSXBKLGFBQWEsQ0FBQ2dHLElBQUksRUFBRXhELElBQUksQ0FBQyxDQUFDOUIsUUFBUSxDQUFDckMsRUFBRSxFQUFFQyxFQUFFLENBQUMsQ0FBQzs7SUFFeEU7SUFDQSxJQUFJa0UsSUFBSSxHQUFHLElBQUksQ0FBQ21OLE9BQU8sRUFBRTtNQUNyQixJQUFJLENBQUNnQixRQUFRLENBQUMxRixRQUFRLENBQUNpRyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTdTLEVBQUUsRUFBRUMsRUFBRSxDQUFDO01BQzNDLElBQUksQ0FBQ3FSLE9BQU8sR0FBR25OLElBQUk7O01BRW5CLElBQUksQ0FBQ3dRLFFBQVEsR0FBR2hOLElBQUk7SUFDeEI7RUFDSixDQUFDOztFQUVEeU0sZ0JBQWdCLENBQUMvUCxTQUFTLENBQUNnUixhQUFhLEdBQUcsVUFBU3pCLEVBQUUsRUFBRUMsRUFBRSxFQUFFblIsS0FBSyxFQUFFQyxHQUFHLEVBQUVaLE1BQU0sRUFBRTRGLElBQUksRUFBRTtJQUNsRixJQUFJckUsY0FBYyxHQUFHLElBQUksQ0FBQytRLE9BQU8sQ0FBQ2hOLGlCQUFpQixDQUFDLENBQUM7SUFDckQsSUFBSTlHLEtBQUssR0FBRyxJQUFJTSxLQUFLLENBQUN1RCxPQUFPLENBQUNkLGNBQWMsQ0FBQ3BELENBQUMsRUFBRW9ELGNBQWMsQ0FBQ25ELENBQUMsQ0FBQzs7SUFFakUsSUFBSStCLE1BQU0sR0FBRyxJQUFJckIsS0FBSyxDQUFDdUQsT0FBTyxDQUFDd1AsRUFBRSxFQUFFQyxFQUFFLENBQUM7SUFDdEN0VCxLQUFLLENBQUMrVSxHQUFHLENBQUNwVCxNQUFNLENBQUM7O0lBRWpCO0lBQ0EsTUFBTXFULFVBQVUsR0FBRzFXLHVFQUF5QixDQUFDeUUsY0FBYyxFQUFFcEIsTUFBTSxFQUFFSCxNQUFNLEVBQUVXLEtBQUssRUFBRUMsR0FBRyxDQUFDO0lBQ3hGLE1BQU13QixJQUFJLEdBQVNvUixVQUFVLENBQUM1VSxVQUFVLENBQUMyQyxjQUFjLENBQUMsQ0FBQyxDQUFDOztJQUUxRDtJQUNBLElBQUksQ0FBQ3lSLGNBQWMsQ0FBQ2hLLElBQUksQ0FBQyxJQUFJcEosYUFBYSxDQUFDZ0csSUFBSSxFQUFFeEQsSUFBSSxDQUFDLENBQUMxQixlQUFlLENBQUNQLE1BQU0sRUFBRUgsTUFBTSxFQUFFVyxLQUFLLEVBQUVDLEdBQUcsQ0FBQyxDQUFDOztJQUVuRztJQUNBLElBQUl3QixJQUFJLEdBQUcsSUFBSSxDQUFDMlEsWUFBWSxFQUFFO01BQzFCO0lBQ0o7O0lBRUE7SUFDQTs7SUFFQSxJQUFJVSxLQUFLLEdBQUcsSUFBSSxDQUFDbkIsT0FBTyxDQUFDZCxZQUFZLENBQUNoVCxLQUFLLENBQUM7O0lBRTVDLElBQUlrVixHQUFHO0lBQ1AsSUFBSTlTLEdBQUcsR0FBR0QsS0FBSyxJQUFJOFMsS0FBSyxJQUFJOVMsS0FBSyxJQUFJOFMsS0FBSyxJQUFJN1MsR0FBRyxFQUFFO01BQy9DOFMsR0FBRyxHQUFHLElBQUk1VSxLQUFLLENBQUM2VSxjQUFjLENBQUMzVCxNQUFNLEVBQUUsR0FBRyxFQUFFVyxLQUFLLEVBQUVDLEdBQUcsR0FBR0QsS0FBSyxDQUFDO0lBQ25FLENBQUM7SUFDSSxJQUFJQyxHQUFHLEdBQUdELEtBQUssS0FBSzhTLEtBQUssSUFBSTlTLEtBQUssSUFBSThTLEtBQUssSUFBSTdTLEdBQUcsQ0FBQyxFQUFFO01BQ3REOFMsR0FBRyxHQUFHLElBQUk1VSxLQUFLLENBQUM2VSxjQUFjLENBQUMzVCxNQUFNLEVBQUUsR0FBRyxFQUFFVyxLQUFLLEVBQUU3QyxJQUFJLENBQUM2VCxFQUFFLEdBQUcsQ0FBQyxHQUFHaFIsS0FBSyxHQUFHQyxHQUFHLENBQUM7SUFDakYsQ0FBQztJQUNJO01BQ0Q7SUFDSjs7SUFFQThTLEdBQUcsQ0FBQzdJLFFBQVEsQ0FBQ2lHLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDOztJQUV6QjRDLEdBQUcsQ0FBQ2pJLFlBQVksQ0FBQyxJQUFJM00sS0FBSyxDQUFDdUssT0FBTyxDQUFDLENBQUMsQ0FBQ3VLLGVBQWUsQ0FBQy9CLEVBQUUsRUFBRUMsRUFBRSxFQUFFdlEsY0FBYyxDQUFDbEQsQ0FBQyxDQUFDLENBQUM7SUFDL0UsSUFBSSxDQUFDbVUsV0FBVyxHQUFHa0IsR0FBRztJQUN0QixJQUFJLENBQUMvSSxpQkFBaUIsR0FBRyxJQUFJN0wsS0FBSyxDQUFDQyxPQUFPLENBQUM4UyxFQUFFLEVBQUVDLEVBQUUsRUFBRXZRLGNBQWMsQ0FBQ2xELENBQUMsQ0FBQztJQUNwRSxJQUFJLENBQUN1TSxpQkFBaUIsR0FBRzVLLE1BQU07O0lBRS9CLElBQUksQ0FBQytCLFNBQVMsR0FBRyxJQUFJakQsS0FBSyxDQUFDQyxPQUFPLENBQUN5VSxVQUFVLENBQUNyVixDQUFDLEVBQUVxVixVQUFVLENBQUNwVixDQUFDLEVBQUVtRCxjQUFjLENBQUNsRCxDQUFDLENBQUM7O0lBRWhGLElBQUksQ0FBQ3dVLFlBQVksR0FBR2pOLElBQUk7RUFDNUIsQ0FBQzs7RUFFRHlNLGdCQUFnQixDQUFDL1AsU0FBUyxDQUFDdVIsZUFBZSxHQUFHLFVBQVNoQyxFQUFFLEVBQUVDLEVBQUUsRUFBRW5SLEtBQUssRUFBRUMsR0FBRyxFQUFFa1QsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRXBPLElBQUksRUFBRTtJQUNoRyxJQUFJckUsY0FBYyxHQUFHLElBQUksQ0FBQytRLE9BQU8sQ0FBQ2hOLGlCQUFpQixDQUFDLENBQUM7SUFDckQsSUFBSTlHLEtBQUssR0FBRyxJQUFJTSxLQUFLLENBQUN1RCxPQUFPLENBQUNkLGNBQWMsQ0FBQ3BELENBQUMsRUFBRW9ELGNBQWMsQ0FBQ25ELENBQUMsQ0FBQzs7SUFFakUsSUFBSTZWLE1BQU0sR0FBR0gsS0FBSyxHQUFHLElBQUksQ0FBQ2YsWUFBWTtJQUN0QyxJQUFJbUIsTUFBTSxHQUFHSCxLQUFLLEdBQUcsSUFBSSxDQUFDaEIsWUFBWTtJQUN0QyxJQUFJb0IsTUFBTSxHQUFHTCxLQUFLLEdBQUcsSUFBSSxDQUFDZixZQUFZO0lBQ3RDLElBQUlxQixNQUFNLEdBQUdMLEtBQUssR0FBRyxJQUFJLENBQUNoQixZQUFZOztJQUV0QyxJQUFJc0IsU0FBUyxHQUFHLENBQUM3VixLQUFLLENBQUNMLENBQUMsR0FBRzBULEVBQUUsS0FBS3JULEtBQUssQ0FBQ0wsQ0FBQyxHQUFHMFQsRUFBRSxDQUFDLElBQUlvQyxNQUFNLEdBQUdBLE1BQU0sQ0FBQyxHQUFHLENBQUN6VixLQUFLLENBQUNKLENBQUMsR0FBRzBULEVBQUUsS0FBS3RULEtBQUssQ0FBQ0osQ0FBQyxHQUFHMFQsRUFBRSxDQUFDLElBQUlvQyxNQUFNLEdBQUdBLE1BQU0sQ0FBQztJQUN6SCxJQUFJSSxTQUFTLEdBQUcsQ0FBQzlWLEtBQUssQ0FBQ0wsQ0FBQyxHQUFHMFQsRUFBRSxLQUFLclQsS0FBSyxDQUFDTCxDQUFDLEdBQUcwVCxFQUFFLENBQUMsSUFBSXNDLE1BQU0sR0FBR0EsTUFBTSxDQUFDLEdBQUcsQ0FBQzNWLEtBQUssQ0FBQ0osQ0FBQyxHQUFHMFQsRUFBRSxLQUFLdFQsS0FBSyxDQUFDSixDQUFDLEdBQUcwVCxFQUFFLENBQUMsSUFBSXNDLE1BQU0sR0FBR0EsTUFBTSxDQUFDOztJQUV6SCxJQUFJalUsTUFBTSxHQUFHLElBQUlyQixLQUFLLENBQUN1RCxPQUFPLENBQUN3UCxFQUFFLEVBQUVDLEVBQUUsQ0FBQztJQUN0Q3RULEtBQUssQ0FBQytVLEdBQUcsQ0FBQ3BULE1BQU0sQ0FBQztJQUNqQjNCLEtBQUssQ0FBQ0wsQ0FBQyxJQUFJNFYsS0FBSztJQUNoQnZWLEtBQUssQ0FBQ0osQ0FBQyxJQUFJMFYsS0FBSztJQUNoQixJQUFJTCxLQUFLLEdBQUcsSUFBSSxDQUFDbkIsT0FBTyxDQUFDZCxZQUFZLENBQUNoVCxLQUFLLENBQUM7O0lBRTVDLElBQUlvQyxHQUFHLEdBQUc5QyxJQUFJLENBQUM2VCxFQUFFLEdBQUcsQ0FBQyxFQUFFO01BQ25CL1EsR0FBRyxHQUFHOUMsSUFBSSxDQUFDNlQsRUFBRSxHQUFHLENBQUM7SUFDckI7O0lBRUEsSUFBSTBDLFNBQVMsSUFBSSxDQUFDLElBQUlDLFNBQVMsSUFBSSxDQUFDLEVBQUU7O01BRWxDLElBQUsxVCxHQUFHLEdBQUdELEtBQUssSUFBSThTLEtBQUssSUFBSTlTLEtBQUssSUFBSThTLEtBQUssSUFBSTdTLEdBQUcsSUFBTUEsR0FBRyxHQUFHRCxLQUFLLEtBQUs4UyxLQUFLLElBQUk5UyxLQUFLLElBQUk4UyxLQUFLLElBQUk3UyxHQUFHLENBQUUsRUFBQztRQUNyRyxJQUFJOFMsR0FBRyxHQUFHOUIsMkJBQTJCLENBQUNDLEVBQUUsRUFBRUMsRUFBRSxFQUFFZ0MsS0FBSyxFQUFFQyxLQUFLLEVBQUVwVCxLQUFLLEVBQUVDLEdBQUcsRUFBRSxFQUFFLENBQUM7UUFDM0UsSUFBSSxDQUFDakQsb0JBQW9CLENBQUNpRCxHQUFHLEdBQUdELEtBQUssRUFBRTdDLElBQUksQ0FBQzZULEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDbkQ7VUFDSStCLEdBQUcsQ0FBQzdJLFFBQVEsQ0FBQzBKLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCO1FBQ0FiLEdBQUcsQ0FBQ2pJLFlBQVksQ0FBQyxJQUFJM00sS0FBSyxDQUFDdUssT0FBTyxDQUFDLENBQUMsQ0FBQ3VLLGVBQWUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFclMsY0FBYyxDQUFDbEQsQ0FBQyxDQUFDLENBQUM7O1FBRTdFO1FBQ0E7UUFDQSxNQUFNbVcsWUFBWSxHQUFHeFgsYUFBYSxDQUFDeVgsMkJBQTJCLENBQUNsVCxjQUFjLEVBQUVtUyxHQUFHLENBQUM7UUFDbkYsTUFBTXRSLElBQUksR0FBR3RELEtBQUssQ0FBQ3VELE9BQU8sQ0FBQ0MsU0FBUyxDQUFDMUQsVUFBVSxDQUFDMkQsSUFBSSxDQUFDaVMsWUFBWSxFQUFFalQsY0FBYyxDQUFDLENBQUMsQ0FBQzs7UUFFcEY7UUFDQSxNQUFNcEIsTUFBTSxHQUFHLElBQUlyQixLQUFLLENBQUN1RCxPQUFPLENBQUN3UCxFQUFFLEVBQUVDLEVBQUUsQ0FBQztRQUN4QyxJQUFJLENBQUNrQixjQUFjLENBQUNoSyxJQUFJLENBQUMsSUFBSXBKLGFBQWEsQ0FBQ2dHLElBQUksRUFBRXhELElBQUksQ0FBQyxDQUFDc1MsaUJBQWlCLENBQUN2VSxNQUFNLEVBQUUyVCxLQUFLLEVBQUVDLEtBQUssRUFBRXBULEtBQUssRUFBRUMsR0FBRyxDQUFDLENBQUM7O1FBRTNHO1FBQ0E7UUFDQSxJQUFJLENBQUM2UixhQUFhLEdBQUdpQixHQUFHO1FBQ3hCLElBQUksQ0FBQ2hCLG1CQUFtQixHQUFHLElBQUk1VCxLQUFLLENBQUNDLE9BQU8sQ0FBQzhTLEVBQUUsRUFBRUMsRUFBRSxFQUFFdlEsY0FBYyxDQUFDbEQsQ0FBQyxDQUFDOztRQUV0RSxJQUFJLENBQUN5VSxjQUFjLEdBQUdsTixJQUFJO01BQzlCO0lBQ0o7RUFDSixDQUFDOztFQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7RUFDSXlNLGdCQUFnQixDQUFDL1AsU0FBUyxDQUFDcVMsU0FBUyxHQUFHLFVBQVVoQyxNQUFNLEVBQUU7SUFDckQsSUFBSSxDQUFDQSxNQUFNLEdBQUdBLE1BQU0sSUFBSSxJQUFJN1QsS0FBSyxDQUFDdUssT0FBTyxDQUFDLENBQUM7RUFDL0MsQ0FBQzs7RUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksSUFBSSxDQUFDdUwsVUFBVSxHQUFHLFVBQVVDLFNBQVMsRUFBZ0IsS0FBZG5TLE9BQU8sR0FBQW9TLFNBQUEsQ0FBQWpULE1BQUEsUUFBQWlULFNBQUEsUUFBQTlOLFNBQUEsR0FBQThOLFNBQUEsTUFBRyxDQUFDLENBQUM7O0lBRS9DLElBQUksQ0FBQ0QsU0FBUyxFQUFFO01BQ1o7SUFDSjs7SUFFQTtJQUNBLElBQUk7TUFDQW5PLElBQUk7TUFDSkssTUFBTTtNQUNOeEYsY0FBYztNQUNkcUYsS0FBSyxHQUFHaEUsT0FBTyxDQUFDZ0U7SUFDcEIsQ0FBQyxHQUFHaU8sU0FBUzs7SUFFYixJQUFJak8sS0FBSyxDQUFDbU8sSUFBSSxDQUFDLENBQUMsRUFBRTtNQUNkO0lBQ0o7SUFDQXBTLFdBQVcsQ0FBQ2dFLE9BQU8sR0FBR2tPLFNBQVMsQ0FBQ2pPLEtBQUssR0FBR2lPLFNBQVMsQ0FBQ2pPLEtBQUssQ0FBQ0MsRUFBRSxHQUFHLElBQUk7SUFDakVsRSxXQUFXLENBQUMwRSxXQUFXLEdBQUcsS0FBSztJQUMvQjFFLFdBQVcsQ0FBQ3BCLGNBQWMsR0FBR0EsY0FBYzs7SUFFM0MsSUFBSXlULEVBQUUsQ0FBRUMsS0FBSyxHQUFHLENBQUM7O0lBRWpCO0lBQ0E7SUFDQSxJQUFJLENBQUNyUyxPQUFPLENBQUNzUyxJQUFJLENBQUNDLElBQUksRUFBRTtNQUNwQkgsRUFBRSxHQUFHcE8sS0FBSyxDQUFDd08seUJBQXlCLENBQUMsQ0FBQztNQUN0QztNQUNBLElBQUlKLEVBQUUsRUFBRTtRQUNKQyxLQUFLLEdBQUdELEVBQUUsQ0FBQ0ssaUJBQWlCLENBQUMsQ0FBQztRQUM5QjFTLFdBQVcsQ0FBQ3BCLGNBQWMsR0FBR0EsY0FBYyxDQUFDZCxLQUFLLENBQUMsQ0FBQztRQUNuRGtDLFdBQVcsQ0FBQ3BCLGNBQWMsQ0FBQ2tLLFlBQVksQ0FBQzdFLEtBQUssQ0FBQzBPLGdDQUFnQyxDQUFDLENBQUMsQ0FBQztNQUNyRjtJQUNKOztJQUVBO0lBQ0E7SUFDQTNTLFdBQVcsQ0FBQzNDLE1BQU0sR0FBRyxJQUFJLENBQUNzSyxlQUFlLENBQUMvSSxjQUFjLENBQUMsR0FBRzBULEtBQUs7O0lBRWpFO0lBQ0EsSUFBSU0sb0JBQW9CLEdBQUkzTyxLQUFLLENBQUMwQyxlQUFlLENBQUMsQ0FBQyxJQUFFLElBQUs7SUFDMUQsSUFBSSxDQUFDaU0sb0JBQW9CLEVBQUU7O01BRXZCO01BQ0E7TUFDQTVSLFVBQVUsR0FBRyxJQUFJO01BQ2pCaEIsV0FBVyxDQUFDMEMsUUFBUSxHQUFHakksUUFBUSxDQUFDb04sV0FBVztNQUMzQzdILFdBQVcsQ0FBQ3VDLFVBQVUsR0FBRzNELGNBQWMsQ0FBQyxDQUFDO01BQ3pDeVQsRUFBRSxJQUFHclMsV0FBVyxDQUFDcEIsY0FBYyxDQUFDa0ssWUFBWSxDQUFDdUosRUFBRSxDQUFDLENBQUMsQ0FBQztNQUNsRDtJQUNKOzs7SUFHQSxJQUFJUSxFQUFFLEdBQUcsSUFBSW5ELGdCQUFnQixDQUFDelAsT0FBTyxFQUFFLElBQUksRUFBRUQsV0FBVyxDQUFDM0MsTUFBTSxDQUFDOztJQUVoRTtJQUNBO0lBQ0EsSUFBSTBDLE9BQU8sQ0FBQytTLFlBQVksRUFBRTtNQUN0QjtNQUNBLE1BQU1DLElBQUksR0FBRy9TLFdBQVcsQ0FBQ3BCLGNBQWMsQ0FBQ3BELENBQUMsR0FBR3dFLFdBQVcsQ0FBQzNDLE1BQU07TUFDOUQsTUFBTTJWLElBQUksR0FBR2hULFdBQVcsQ0FBQ3BCLGNBQWMsQ0FBQ25ELENBQUMsR0FBR3VFLFdBQVcsQ0FBQzNDLE1BQU07TUFDOUQsTUFBTTRWLElBQUksR0FBR2pULFdBQVcsQ0FBQ3BCLGNBQWMsQ0FBQ3BELENBQUMsR0FBR3dFLFdBQVcsQ0FBQzNDLE1BQU07TUFDOUQsTUFBTTZWLElBQUksR0FBR2xULFdBQVcsQ0FBQ3BCLGNBQWMsQ0FBQ25ELENBQUMsR0FBR3VFLFdBQVcsQ0FBQzNDLE1BQU07O01BRTlEMEMsT0FBTyxDQUFDK1MsWUFBWSxDQUFDQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVMLEVBQUUsQ0FBQztJQUNwRCxDQUFDLE1BQU07TUFDSDtNQUNBLElBQUlwTyxPQUFPLEdBQUdMLE1BQU07O01BRXBCLElBQUksT0FBT0ssT0FBTyxLQUFLLFdBQVcsRUFBRTtRQUNoQztRQUNBLElBQUksQ0FBQ3ZELFlBQVksRUFBRTtVQUNmO1FBQ0o7UUFDQXVELE9BQU8sR0FBRyxFQUFFO01BQ2hCLENBQUMsTUFBTSxJQUFJLENBQUMwTyxLQUFLLENBQUNDLE9BQU8sQ0FBQzNPLE9BQU8sQ0FBQyxFQUFFO1FBQ2hDQSxPQUFPLEdBQUcsQ0FBQ0EsT0FBTyxDQUFDO01BQ3ZCOztNQUVBLEtBQUssSUFBSUUsRUFBRSxHQUFHLENBQUMsRUFBRUEsRUFBRSxHQUFHRixPQUFPLENBQUN2RixNQUFNLEVBQUUsRUFBRXlGLEVBQUUsRUFBRTtRQUN4QyxNQUFNME8sSUFBSSxHQUFHcFQsT0FBTyxDQUFDc1MsSUFBSSxDQUFDZSxjQUFjLENBQUNyUCxLQUFLLEVBQUVRLE9BQU8sQ0FBQ0UsRUFBRSxDQUFDLENBQUM7UUFDNUQsSUFBSTBPLElBQUksYUFBSkEsSUFBSSxlQUFKQSxJQUFJLENBQUVsTyxRQUFRLEVBQUU7VUFDaEIwTixFQUFFLENBQUNiLFNBQVMsQ0FBQ3FCLElBQUksQ0FBQ3JELE1BQU0sQ0FBQztVQUN6QixNQUFNdUQsR0FBRyxHQUFHLElBQUl4WSxrQkFBa0IsQ0FBQ3NZLElBQUksQ0FBQ2xPLFFBQVEsQ0FBQztVQUNqRG9PLEdBQUcsQ0FBQ0Msa0JBQWtCLENBQUN2UCxLQUFLLENBQUN3UCxtQkFBbUIsQ0FBQzFQLElBQUksQ0FBQyxFQUFFOE8sRUFBRSxDQUFDO1VBQzNEO1VBQ0FBLEVBQUUsQ0FBQ2IsU0FBUyxDQUFDLENBQUM7UUFDbEI7TUFDSjtJQUNKOztJQUVBO0lBQ0EsSUFBSSxDQUFDMEIsZ0JBQWdCLENBQUNiLEVBQUUsRUFBRTdTLFdBQVcsQ0FBQ3BCLGNBQWMsQ0FBQzs7SUFFckQ7SUFDQSxJQUFHLENBQUNvQyxVQUFVLElBQUlFLFlBQVksRUFBRTtNQUM1QkYsVUFBVSxHQUFHLElBQUk7TUFDakJoQixXQUFXLENBQUMwQyxRQUFRLEdBQUdqSSxRQUFRLENBQUNrWixZQUFZO01BQzVDM1QsV0FBVyxDQUFDdUMsVUFBVSxHQUFHdkMsV0FBVyxDQUFDcEIsY0FBYztJQUN2RDs7SUFFQTtJQUNBLElBQUl5VCxFQUFFLEVBQUUsS0FBQXVCLG9CQUFBLEVBQUFDLHFCQUFBO01BQ0osTUFBTTdWLEtBQUssSUFBQTRWLG9CQUFBLEdBQUc1VCxXQUFXLENBQUNxQyxRQUFRLGNBQUF1UixvQkFBQSx1QkFBcEJBLG9CQUFBLENBQXNCMUwsUUFBUSxDQUFDLENBQUMsQ0FBQztNQUMvQyxNQUFNakssR0FBRyxJQUFBNFYscUJBQUEsR0FBRzdULFdBQVcsQ0FBQ3FDLFFBQVEsY0FBQXdSLHFCQUFBLHVCQUFwQkEscUJBQUEsQ0FBc0IzTCxRQUFRLENBQUMsQ0FBQyxDQUFDOztNQUU3QyxJQUFJNEwsT0FBTyxHQUFHLENBQUM5VCxXQUFXLENBQUNaLFNBQVMsRUFBRVksV0FBVyxDQUFDdUMsVUFBVSxFQUFFdkMsV0FBVyxDQUFDcEIsY0FBYyxFQUFFb0IsV0FBVyxDQUFDZ0ksaUJBQWlCO01BQ25IaEssS0FBSyxFQUFFQyxHQUFHLENBQUM7TUFDZjtNQUNBNlYsT0FBTyxHQUFHLENBQUMsR0FBRyxJQUFJL0gsR0FBRyxDQUFDK0gsT0FBTyxDQUFDbFEsTUFBTSxDQUFDLENBQUFtUSxDQUFDLEtBQUlBLENBQUMsQ0FBQyxDQUFDLENBQUM7TUFDOUNELE9BQU8sQ0FBQ3pILE9BQU8sQ0FBQyxDQUFBMkgsR0FBRyxLQUFJQSxHQUFHLENBQUNsTCxZQUFZLENBQUN1SixFQUFFLENBQUMsQ0FBQztNQUM1QyxJQUFJclMsV0FBVyxDQUFDaUksaUJBQWlCLEVBQUU7UUFDL0JqSSxXQUFXLENBQUNpSSxpQkFBaUIsSUFBSXFLLEtBQUs7TUFDMUM7TUFDQXRTLFdBQVcsQ0FBQzNDLE1BQU0sSUFBSWlWLEtBQUs7SUFDL0I7RUFDSixDQUFDOztFQUVEO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0VBRUEsSUFBSSxDQUFDMkIsaUJBQWlCLEdBQUcsVUFBU3JWLGNBQWMsRUFBRXNWLE1BQU0sRUFBRXRRLE1BQU0sRUFBRXdNLFlBQVksRUFBRTtJQUM1RXBRLFdBQVcsQ0FBQzBFLFdBQVcsR0FBRyxLQUFLO0lBQy9CMUUsV0FBVyxDQUFDcEIsY0FBYyxHQUFHQSxjQUFjO0lBQzNDb0IsV0FBVyxDQUFDM0MsTUFBTSxHQUFHK1MsWUFBWSxJQUFJLElBQUksQ0FBQ3pJLGVBQWUsQ0FBQy9JLGNBQWMsQ0FBQzs7SUFFekUsSUFBSWlVLEVBQUUsR0FBRyxJQUFJbkQsZ0JBQWdCLENBQUN6UCxPQUFPLEVBQUUsSUFBSSxFQUFFRCxXQUFXLENBQUMzQyxNQUFNLENBQUM7O0lBRWhFLEtBQUssSUFBSWlDLENBQUMsR0FBQyxDQUFDLEVBQUVBLENBQUMsR0FBQzRVLE1BQU0sQ0FBQ2hWLE1BQU0sRUFBRUksQ0FBQyxFQUFFLEVBQUU7TUFDaEMsSUFBSStULElBQUksR0FBR2EsTUFBTSxDQUFDNVUsQ0FBQyxDQUFDO01BQ3BCLElBQUlpVSxHQUFHLEdBQUcsSUFBSXhZLGtCQUFrQixDQUFDc1ksSUFBSSxDQUFDbE8sUUFBUSxDQUFDO01BQy9Db08sR0FBRyxDQUFDWSxTQUFTLENBQUN2USxNQUFNLEVBQUVpUCxFQUFFLENBQUM7SUFDN0I7O0lBRUEsSUFBSSxDQUFDYSxnQkFBZ0IsQ0FBQ2IsRUFBRSxFQUFFalUsY0FBYyxDQUFDO0VBQzdDLENBQUM7O0VBRUQ7RUFDQSxJQUFJLENBQUM4VSxnQkFBZ0IsR0FBRyxVQUFTYixFQUFFLEVBQUVqVSxjQUFjLEVBQUU7O0lBRWpEO0lBQ0EsSUFBSXFDLFdBQVcsS0FBSyxJQUFJLEVBQUU7TUFDdEIsTUFBTW1ULGNBQWMsR0FBR0EsQ0FBQXZLLENBQUMsS0FBS0EsQ0FBQyxDQUFDMU0sVUFBVSxLQUFLOEQsV0FBWTtNQUMxRDRSLEVBQUUsQ0FBQ3hDLGNBQWMsR0FBR3dDLEVBQUUsQ0FBQ3hDLGNBQWMsQ0FBQ3pNLE1BQU0sQ0FBQ3dRLGNBQWMsQ0FBQztJQUNoRTs7SUFFQTtJQUNBLE1BQU1DLGFBQWEsR0FBRzNWLG9CQUFvQixDQUFDbVUsRUFBRSxDQUFDeEMsY0FBYyxFQUFFelIsY0FBYyxFQUFFaVUsRUFBRSxDQUFDekMsWUFBWSxDQUFDO0lBQzlGLElBQUlpRSxhQUFhLEVBQUU7TUFDZnJVLFdBQVcsQ0FBQ3NVLGVBQWUsR0FBR0QsYUFBYSxDQUFDbFgsVUFBVTtNQUN0RDZDLFdBQVcsQ0FBQ1osU0FBUyxHQUFHaVYsYUFBYSxDQUFDalYsU0FBUztNQUMvQ1ksV0FBVyxDQUFDMEMsUUFBUSxHQUFHakksUUFBUSxDQUFDOFosaUJBQWlCO01BQ2pEdlUsV0FBVyxDQUFDdUMsVUFBVSxHQUFHOFIsYUFBYSxDQUFDalYsU0FBUztNQUNoRDRCLFVBQVUsR0FBRyxJQUFJO01BQ2pCO0lBQ0o7O0lBRUEsSUFBSTZSLEVBQUUsQ0FBQ2hELFdBQVcsRUFBRTs7TUFFaEI3UCxXQUFXLENBQUNzVSxlQUFlLEdBQUd6QixFQUFFLENBQUMzQyxZQUFZOztNQUU3Q2xRLFdBQVcsQ0FBQ1osU0FBUyxHQUFHeVQsRUFBRSxDQUFDelQsU0FBUzs7TUFFcEM7TUFDQSxJQUFJNkIsV0FBVyxLQUFLLElBQUksSUFBSUEsV0FBVyxLQUFLakIsV0FBVyxDQUFDc1UsZUFBZTtNQUNuRTs7TUFFSixNQUFNdFcsS0FBSyxHQUFHNlUsRUFBRSxDQUFDaEQsV0FBVyxDQUFDM0gsUUFBUSxDQUFDLENBQUMsQ0FBQztNQUN4QyxNQUFNakssR0FBRyxHQUFHNFUsRUFBRSxDQUFDaEQsV0FBVyxDQUFDM0gsUUFBUSxDQUFDMkssRUFBRSxDQUFDaEQsV0FBVyxDQUFDM0gsUUFBUSxDQUFDaEosTUFBTSxHQUFHLENBQUMsQ0FBQzs7TUFFdkUsSUFBSU4sY0FBYyxDQUFDM0MsVUFBVSxDQUFDK0IsS0FBSyxDQUFDLEdBQUdnQyxXQUFXLENBQUMzQyxNQUFNLEVBQUU7O1FBRXZEMkMsV0FBVyxDQUFDdUMsVUFBVSxHQUFHdkUsS0FBSztRQUM5QmdDLFdBQVcsQ0FBQzBDLFFBQVEsR0FBR2pJLFFBQVEsQ0FBQ29OLFdBQVc7TUFDL0MsQ0FBQztNQUNJLElBQUlqSixjQUFjLENBQUMzQyxVQUFVLENBQUNnQyxHQUFHLENBQUMsR0FBRytCLFdBQVcsQ0FBQzNDLE1BQU0sRUFBRTs7UUFFMUQyQyxXQUFXLENBQUN1QyxVQUFVLEdBQUd0RSxHQUFHO1FBQzVCK0IsV0FBVyxDQUFDMEMsUUFBUSxHQUFHakksUUFBUSxDQUFDb04sV0FBVztNQUMvQyxDQUFDO01BQ0k7O1FBRUQsSUFBSSxDQUFDMk0saUJBQWlCLENBQUMzQixFQUFFLENBQUNoRCxXQUFXLENBQUM7UUFDdEM3UCxXQUFXLENBQUNxQyxRQUFRLEdBQUd3USxFQUFFLENBQUNoRCxXQUFXO1FBQ3JDN1AsV0FBVyxDQUFDZ0ksaUJBQWlCLEdBQUc2SyxFQUFFLENBQUM3SyxpQkFBaUI7UUFDcERoSSxXQUFXLENBQUNpSSxpQkFBaUIsR0FBRzRLLEVBQUUsQ0FBQzVLLGlCQUFpQjtRQUNwRGpJLFdBQVcsQ0FBQzBDLFFBQVEsR0FBR2pJLFFBQVEsQ0FBQzBOLGdCQUFnQjtNQUNwRDs7TUFFQW5ILFVBQVUsR0FBRyxJQUFJOzs7SUFHckIsQ0FBQztJQUNJLElBQUk2UixFQUFFLENBQUMvQyxhQUFhLEVBQUU7O01BRXZCOVAsV0FBVyxDQUFDc1UsZUFBZSxHQUFHekIsRUFBRSxDQUFDMUMsY0FBYzs7TUFFL0M7TUFDQSxJQUFJbFAsV0FBVyxLQUFLLElBQUksSUFBSUEsV0FBVyxLQUFLakIsV0FBVyxDQUFDc1UsZUFBZTtNQUNuRTs7TUFFSixNQUFNdFcsS0FBSyxHQUFHNlUsRUFBRSxDQUFDL0MsYUFBYSxDQUFDNUgsUUFBUSxDQUFDLENBQUMsQ0FBQztNQUMxQyxNQUFNakssR0FBRyxHQUFHNFUsRUFBRSxDQUFDL0MsYUFBYSxDQUFDNUgsUUFBUSxDQUFDMkssRUFBRSxDQUFDL0MsYUFBYSxDQUFDNUgsUUFBUSxDQUFDaEosTUFBTSxHQUFHLENBQUMsQ0FBQztNQUMzRSxJQUFJTixjQUFjLENBQUMzQyxVQUFVLENBQUMrQixLQUFLLENBQUMsR0FBR2dDLFdBQVcsQ0FBQzNDLE1BQU0sRUFBRTs7UUFFdkQyQyxXQUFXLENBQUN1QyxVQUFVLEdBQUd2RSxLQUFLO1FBQzlCZ0MsV0FBVyxDQUFDMEMsUUFBUSxHQUFHakksUUFBUSxDQUFDb04sV0FBVztNQUMvQyxDQUFDO01BQ0ksSUFBSWpKLGNBQWMsQ0FBQzNDLFVBQVUsQ0FBQ2dDLEdBQUcsQ0FBQyxHQUFHK0IsV0FBVyxDQUFDM0MsTUFBTSxFQUFFOztRQUUxRDJDLFdBQVcsQ0FBQ3VDLFVBQVUsR0FBR3RFLEdBQUc7UUFDNUIrQixXQUFXLENBQUMwQyxRQUFRLEdBQUdqSSxRQUFRLENBQUNvTixXQUFXO01BQy9DLENBQUM7TUFDSTs7UUFFRCxJQUFJLENBQUMyTSxpQkFBaUIsQ0FBQzNCLEVBQUUsQ0FBQy9DLGFBQWEsQ0FBQztRQUN4QzlQLFdBQVcsQ0FBQ3FDLFFBQVEsR0FBR3dRLEVBQUUsQ0FBQy9DLGFBQWE7UUFDdkM7UUFDQTlQLFdBQVcsQ0FBQ2dJLGlCQUFpQixHQUFHNkssRUFBRSxDQUFDOUMsbUJBQW1CO1FBQ3REL1AsV0FBVyxDQUFDaUksaUJBQWlCLEdBQUcsSUFBSTtRQUNwQ2pJLFdBQVcsQ0FBQzBDLFFBQVEsR0FBR2pJLFFBQVEsQ0FBQzBOLGdCQUFnQjtNQUNwRDs7TUFFQW5ILFVBQVUsR0FBRyxJQUFJOztJQUVyQixDQUFDO0lBQ0ksSUFBSzZSLEVBQUUsQ0FBQ2pGLFFBQVEsWUFBWXpSLEtBQUssQ0FBQ3FOLFFBQVEsSUFBSXFKLEVBQUUsQ0FBQ2pGLFFBQVEsQ0FBQzFGLFFBQVEsQ0FBQ2hKLE1BQU07SUFDekUyVCxFQUFFLENBQUNqRixRQUFRLENBQUM2RyxZQUFZLElBQUk1QixFQUFFLENBQUNqRixRQUFRLENBQUM2RyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUNySyxLQUFNLEVBQUU7O01BRTFFcEssV0FBVyxDQUFDc1UsZUFBZSxHQUFHekIsRUFBRSxDQUFDNUMsUUFBUTs7TUFFekM7TUFDQSxJQUFJaFAsV0FBVyxLQUFLLElBQUksSUFBSUEsV0FBVyxLQUFLakIsV0FBVyxDQUFDc1UsZUFBZTtNQUNuRTs7TUFFSjtNQUNBO01BQ0F0VSxXQUFXLENBQUNxQyxRQUFRLEdBQUd3USxFQUFFLENBQUNqRixRQUFRO01BQ2xDLE1BQU01UCxLQUFLLEdBQUc2VSxFQUFFLENBQUNqRixRQUFRLENBQUMxRixRQUFRLENBQUMsQ0FBQyxDQUFDO01BQ3JDLE1BQU1qSyxHQUFHLEdBQUc0VSxFQUFFLENBQUNqRixRQUFRLENBQUMxRixRQUFRLENBQUMsQ0FBQyxDQUFDOztNQUVuQyxJQUFJLElBQUksQ0FBQzVILFVBQVUsRUFBRSxDQUFHO1FBQ3BCLElBQUlvVSxHQUFHLEdBQUcsSUFBSXZZLEtBQUssQ0FBQ0MsT0FBTyxDQUFDLENBQUM7UUFDN0JzWSxHQUFHLENBQUNDLFVBQVUsQ0FBQzNXLEtBQUssRUFBRUMsR0FBRyxDQUFDO1FBQzFCeVcsR0FBRyxDQUFDbkcsWUFBWSxDQUFDLENBQUMsQ0FBQztRQUNuQixJQUFJcUcsRUFBRSxHQUFHaFcsY0FBYyxDQUFDM0MsVUFBVSxDQUFDeVksR0FBRyxDQUFDO1FBQ3ZDLElBQUlHLEVBQUUsR0FBR2pXLGNBQWMsQ0FBQzNDLFVBQVUsQ0FBQytCLEtBQUssQ0FBQztRQUN6QyxJQUFJOFcsRUFBRSxHQUFHbFcsY0FBYyxDQUFDM0MsVUFBVSxDQUFDZ0MsR0FBRyxDQUFDOztRQUV2QztRQUNBK0IsV0FBVyxDQUFDcUMsUUFBUSxHQUFHd1EsRUFBRSxDQUFDakYsUUFBUTs7UUFFbEMsSUFBSWdILEVBQUUsR0FBRzVVLFdBQVcsQ0FBQzNDLE1BQU0sRUFBRTtVQUN6QjJDLFdBQVcsQ0FBQ3VDLFVBQVUsR0FBR21TLEdBQUc7VUFDNUIxVSxXQUFXLENBQUMwQyxRQUFRLEdBQUdqSSxRQUFRLENBQUNvTixXQUFXO1FBQy9DLENBQUM7UUFDSSxJQUFJZ04sRUFBRSxHQUFHN1UsV0FBVyxDQUFDM0MsTUFBTSxFQUFFO1VBQzlCMkMsV0FBVyxDQUFDdUMsVUFBVSxHQUFHdkUsS0FBSztVQUM5QmdDLFdBQVcsQ0FBQzBDLFFBQVEsR0FBR2pJLFFBQVEsQ0FBQ29OLFdBQVc7UUFDL0MsQ0FBQztRQUNJLElBQUlpTixFQUFFLEdBQUc5VSxXQUFXLENBQUMzQyxNQUFNLEVBQUU7VUFDOUIyQyxXQUFXLENBQUN1QyxVQUFVLEdBQUd0RSxHQUFHO1VBQzVCK0IsV0FBVyxDQUFDMEMsUUFBUSxHQUFHakksUUFBUSxDQUFDb04sV0FBVztRQUMvQyxDQUFDO1FBQ0k7VUFDRDdILFdBQVcsQ0FBQzBDLFFBQVEsR0FBR2pJLFFBQVEsQ0FBQzZOLFNBQVM7UUFDN0M7O1FBRUE7UUFDQSxJQUFJdEssS0FBSyxDQUFDL0IsVUFBVSxDQUFDZ0MsR0FBRyxDQUFDLEdBQUd6RCxPQUFPLEVBQUU7VUFDakN3RixXQUFXLENBQUMwQyxRQUFRLEdBQUdqSSxRQUFRLENBQUNzYSxrQkFBa0I7UUFDdEQ7TUFDSixDQUFDO01BQ0ksQ0FBRztRQUNKLElBQUluVyxjQUFjLENBQUMzQyxVQUFVLENBQUMrQixLQUFLLENBQUMsR0FBR2dDLFdBQVcsQ0FBQzNDLE1BQU0sRUFBRTs7VUFFdkQsSUFBSVcsS0FBSyxDQUFDL0IsVUFBVSxDQUFDZ0MsR0FBRyxDQUFDLEdBQUd6RCxPQUFPLEVBQUU7WUFDakN3RixXQUFXLENBQUMwQyxRQUFRLEdBQUdqSSxRQUFRLENBQUNzYSxrQkFBa0I7VUFDdEQsQ0FBQyxNQUFNO1lBQ0gvVSxXQUFXLENBQUMwQyxRQUFRLEdBQUdqSSxRQUFRLENBQUNvTixXQUFXO1VBQy9DOztVQUVBN0gsV0FBVyxDQUFDdUMsVUFBVSxHQUFHdkUsS0FBSztRQUNsQyxDQUFDO1FBQ0ksSUFBS29DLFFBQVEsQ0FBQ3dILGlCQUFpQixJQUFLaEosY0FBYyxDQUFDM0MsVUFBVSxDQUFDZ0MsR0FBRyxDQUFDLEdBQUcrQixXQUFXLENBQUMzQyxNQUFPLEVBQUc7O1VBRTVGMkMsV0FBVyxDQUFDdUMsVUFBVSxHQUFHdEUsR0FBRztVQUM1QitCLFdBQVcsQ0FBQzBDLFFBQVEsR0FBR2pJLFFBQVEsQ0FBQ29OLFdBQVc7UUFDL0MsQ0FBQztRQUNJO1VBQ0Q3SCxXQUFXLENBQUMwQyxRQUFRLEdBQUdqSSxRQUFRLENBQUM2TixTQUFTO1FBQzdDO01BQ0o7O01BRUF0SCxVQUFVLEdBQUcsSUFBSTtJQUNyQjtFQUNKLENBQUM7O0VBRUQsSUFBSSxDQUFDZ1UsbUJBQW1CLEdBQUcsVUFBUzdWLE1BQU0sRUFBRTtJQUN4QyxJQUFJLENBQUNBLE1BQU0sRUFBRTtNQUNUO0lBQ0o7O0lBRUEsSUFBSVAsY0FBYyxHQUFHTyxNQUFNLENBQUNQLGNBQWM7SUFDMUNvQixXQUFXLENBQUNwQixjQUFjLEdBQUdBLGNBQWM7SUFDM0NvQixXQUFXLENBQUMwRSxXQUFXLEdBQUcsS0FBSzs7SUFFL0I7SUFDQTFFLFdBQVcsQ0FBQzNDLE1BQU0sR0FBRyxJQUFJLENBQUNzSyxlQUFlLENBQUMvSSxjQUFjLENBQUM7SUFDekRvQixXQUFXLENBQUMwQyxRQUFRLEdBQUdqSSxRQUFRLENBQUNrWixZQUFZO0lBQzVDM1QsV0FBVyxDQUFDdUMsVUFBVSxHQUFHM0QsY0FBYztJQUN2Q29DLFVBQVUsR0FBRyxJQUFJO0VBQ3JCLENBQUM7O0VBRUQsSUFBSSxDQUFDaVUsWUFBWSxHQUFHLFlBQVc7SUFDM0JqVixXQUFXLENBQUNrVixVQUFVLEdBQUcsS0FBSzs7SUFFOUI7SUFDQSxJQUFJbFUsVUFBVSxFQUFFO01BQ1osSUFBSWhCLFdBQVcsQ0FBQzBDLFFBQVEsS0FBS2pJLFFBQVEsQ0FBQzZOLFNBQVMsRUFBRTtRQUM3QyxNQUFNcUQsSUFBSSxHQUFHM0wsV0FBVyxDQUFDcUMsUUFBUTtRQUNqQyxNQUFNekUsRUFBRSxHQUFHK04sSUFBSSxDQUFDekQsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUMzQixNQUFNckssRUFBRSxHQUFHOE4sSUFBSSxDQUFDekQsUUFBUSxDQUFDLENBQUMsQ0FBQzs7UUFFM0IsSUFBSWlOLFFBQVEsR0FBRyxJQUFJaFosS0FBSyxDQUFDQyxPQUFPLENBQUMsQ0FBQ3dCLEVBQUUsQ0FBQ3BDLENBQUMsR0FBR3FDLEVBQUUsQ0FBQ3JDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ29DLEVBQUUsQ0FBQ25DLENBQUMsR0FBR29DLEVBQUUsQ0FBQ3BDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ21DLEVBQUUsQ0FBQ2xDLENBQUMsR0FBR21DLEVBQUUsQ0FBQ25DLENBQUMsSUFBSSxDQUFDLENBQUM7O1FBRXpGLElBQUkwWixTQUFTLEdBQUduVixPQUFPLENBQUNzUyxJQUFJLENBQUM4QyxlQUFlLENBQUMsQ0FBQztRQUM5QyxJQUFJRCxTQUFTLGFBQVRBLFNBQVMsZUFBVEEsU0FBUyxDQUFFbFcsTUFBTSxFQUFFO1VBQ25CLEtBQUssSUFBSUksQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFDOFYsU0FBUyxDQUFDbFcsTUFBTSxFQUFFLEVBQUVJLENBQUMsRUFBRTtZQUNyQyxNQUFNMEcsQ0FBQyxHQUFHb1AsU0FBUyxDQUFDOVYsQ0FBQyxDQUFDO1lBQ3RCLE1BQU03QyxHQUFHLEdBQUcwWSxRQUFRLENBQUMzWixDQUFDLEdBQUN3SyxDQUFDLENBQUN4SyxDQUFDLEdBQUcyWixRQUFRLENBQUMxWixDQUFDLEdBQUN1SyxDQUFDLENBQUN2SyxDQUFDLEdBQUcwWixRQUFRLENBQUN6WixDQUFDLEdBQUNzSyxDQUFDLENBQUN0SyxDQUFDLEdBQUdzSyxDQUFDLENBQUNzUCxDQUFDO1lBQ2xFLElBQUk3WSxHQUFHLEdBQUMsSUFBSSxFQUFFO2NBQ1Y7Y0FDQTtZQUNKO1VBQ0o7UUFDSjs7UUFFQSxJQUFJdUQsV0FBVyxDQUFDcEIsY0FBYyxDQUFDM0MsVUFBVSxDQUFDa1osUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHblYsV0FBVyxDQUFDM0MsTUFBTSxFQUFFO1VBQzFFMkMsV0FBVyxDQUFDdUMsVUFBVSxHQUFHNFMsUUFBUTtVQUNqQ25WLFdBQVcsQ0FBQzBDLFFBQVEsR0FBR2pJLFFBQVEsQ0FBQzhhLGFBQWE7UUFDakQ7TUFDSjtJQUNKO0VBQ0osQ0FBQzs7RUFFRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHLFVBQVNDLGVBQWUsRUFBRTtJQUM5Q3pWLFdBQVcsQ0FBQ3lWLGVBQWUsR0FBR0EsZUFBZTtFQUNqRCxDQUFDOztFQUVELElBQUksQ0FBQ2pCLGlCQUFpQixHQUFHLFVBQVNqTCxJQUFJLEVBQUU7SUFDcEMsTUFBTXJCLFFBQVEsR0FBR3FCLElBQUksQ0FBQ3JCLFFBQVE7SUFDOUIsS0FBSyxJQUFJNUksQ0FBQyxHQUFHNEksUUFBUSxDQUFDaEosTUFBTSxHQUFHLENBQUMsRUFBRUksQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxFQUFFLEVBQUU7TUFDMUM0SSxRQUFRLENBQUNpRyxNQUFNLENBQUM3TyxDQUFDLEVBQUUsQ0FBQyxFQUFFNEksUUFBUSxDQUFDNUksQ0FBQyxDQUFDLENBQUM7SUFDdEM7RUFDSixDQUFDOztFQUVELElBQUksQ0FBQ3FJLGVBQWUsR0FBRyxVQUFTOUwsS0FBSyxFQUFFOztJQUVuQyxJQUFJNlosTUFBTSxHQUFHelYsT0FBTyxDQUFDMFYsVUFBVTtJQUMvQixJQUFJQyxNQUFNLEdBQUdGLE1BQU0sQ0FBQ0csU0FBUyxDQUFDLENBQUM7SUFDL0IsSUFBSXBRLFFBQVEsR0FBR2lRLE1BQU0sQ0FBQ0ksV0FBVyxDQUFDLENBQUM7O0lBRW5DLElBQUk5UCxDQUFDLEdBQUduSyxLQUFLLENBQUNpQyxLQUFLLENBQUMsQ0FBQzs7SUFFckIsSUFBSXhCLFFBQVEsR0FBR3NaLE1BQU0sQ0FBQ0csYUFBYSxHQUFHL1AsQ0FBQyxDQUFDNEssR0FBRyxDQUFDbkwsUUFBUSxDQUFDLENBQUN2RyxNQUFNLENBQUMsQ0FBQztJQUN4RHdXLE1BQU0sQ0FBQ00sWUFBWSxDQUFDLENBQUMsQ0FBQzlXLE1BQU0sQ0FBQyxDQUFDOztJQUVwQyxJQUFJK1csR0FBRyxHQUFHUCxNQUFNLENBQUNRLGNBQWMsQ0FBQyxDQUFDO0lBQ2pDLElBQUlDLFdBQVcsR0FBRyxHQUFHLEdBQUc3WixRQUFRLEdBQUduQixJQUFJLENBQUNpYixHQUFHLENBQUNqYSxLQUFLLENBQUNoQixJQUFJLENBQUNrYixRQUFRLENBQUNKLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQzs7SUFFM0UsSUFBSUssUUFBUSxHQUFHWixNQUFNLENBQUNhLGlCQUFpQixDQUFDLENBQUM7SUFDekMsSUFBSUMsT0FBTyxHQUFHLElBQUksQ0FBQ0MsU0FBUyxDQUFDLENBQUM7SUFDOUIsSUFBSUMsZ0JBQWdCLEdBQUdGLE9BQU8sQ0FBQ0UsZ0JBQWdCLElBQUksQ0FBQztJQUNwRCxJQUFJclosTUFBTSxHQUFHLElBQUksQ0FBQ2tFLG9CQUFvQixHQUFHNFUsV0FBVyxJQUFJRyxRQUFRLENBQUNLLE1BQU0sR0FBR0QsZ0JBQWdCLENBQUM7O0lBRTNGLE9BQU9yWixNQUFNO0VBQ2pCLENBQUM7O0VBRUQsSUFBSSxDQUFDdVosZ0JBQWdCLEdBQUcsWUFBWTtJQUNoQzlWLFdBQVcsR0FBRyxJQUFJO0lBQ2xCLE9BQU8sS0FBSztFQUNoQixDQUFDOztFQUVELElBQUksQ0FBQytWLGNBQWMsR0FBRyxZQUFZO0lBQzlCL1YsV0FBVyxHQUFHLEtBQUs7SUFDbkIsT0FBTyxLQUFLO0VBQ2hCLENBQUM7O0VBRUQsSUFBSSxDQUFDZ1csZUFBZSxHQUFHLFVBQVVDLEtBQUssRUFBRTs7SUFFcEMsSUFBSWpXLFdBQVc7SUFDWCxPQUFPLEtBQUs7O0lBRWhCLElBQUksQ0FBQ2tXLFdBQVcsQ0FBQztNQUNieGIsQ0FBQyxFQUFFdWIsS0FBSyxDQUFDRSxPQUFPO01BQ2hCeGIsQ0FBQyxFQUFFc2IsS0FBSyxDQUFDRztJQUNiLENBQUMsQ0FBQzs7SUFFRixPQUFPLEtBQUs7RUFDaEIsQ0FBQzs7RUFFRCxJQUFJLENBQUNDLGVBQWUsR0FBRyxVQUFTSixLQUFLLEVBQUU7O0lBRW5DLE9BQU8sSUFBSSxDQUFDRCxlQUFlLENBQUNDLEtBQUssQ0FBQztFQUN0QyxDQUFDOztFQUVELElBQUksQ0FBQ0ssZUFBZSxHQUFHLFVBQVVMLEtBQUssRUFBRTs7SUFFcEMsSUFBSW5jLEVBQUUsQ0FBQzRHLGNBQWMsQ0FBQyxDQUFDLEVBQUU7TUFDckIsUUFBUXVWLEtBQUssQ0FBQzNaLElBQUk7O1FBRWQsS0FBSyxPQUFPO1VBQ1IyRCxXQUFXLEdBQUcsSUFBSTtVQUNsQixJQUFJLENBQUNpVyxXQUFXLENBQUMsRUFBQ3hiLENBQUMsRUFBRXViLEtBQUssQ0FBQ0UsT0FBTyxFQUFFeGIsQ0FBQyxFQUFFc2IsS0FBSyxDQUFDRyxPQUFPLEVBQUMsQ0FBQztVQUN0RDs7UUFFSixLQUFLLFNBQVM7VUFDVixJQUFJLENBQUNGLFdBQVcsQ0FBQyxFQUFDeGIsQ0FBQyxFQUFFdWIsS0FBSyxDQUFDRSxPQUFPLEVBQUV4YixDQUFDLEVBQUVzYixLQUFLLENBQUNHLE9BQU8sRUFBQyxDQUFDO1VBQ3REblcsV0FBVyxHQUFHLEtBQUs7VUFDbkI7TUFDUjtJQUNKO0lBQ0EsT0FBTyxLQUFLOztFQUVoQixDQUFDOztFQUVELElBQUksQ0FBQ3NXLGFBQWEsR0FBRyxVQUFVTixLQUFLO0VBQ3BDO0lBQ0ksSUFBSW5jLEVBQUUsQ0FBQzRHLGNBQWMsQ0FBQyxDQUFDLEVBQUU7TUFDckIsSUFBSVQsV0FBVyxFQUFFO1FBQ2IsUUFBUWdXLEtBQUssQ0FBQzNaLElBQUk7O1VBRWQsS0FBSyxXQUFXO1VBQ2hCLEtBQUssVUFBVTtZQUNYLElBQUksQ0FBQzRaLFdBQVcsQ0FBQyxFQUFDeGIsQ0FBQyxFQUFFdWIsS0FBSyxDQUFDRSxPQUFPLEVBQUV4YixDQUFDLEVBQUVzYixLQUFLLENBQUNHLE9BQU8sRUFBQyxDQUFDO1lBQ3REOztVQUVKLEtBQUssU0FBUztZQUNWLElBQUksQ0FBQ0YsV0FBVyxDQUFDLEVBQUN4YixDQUFDLEVBQUV1YixLQUFLLENBQUNFLE9BQU8sRUFBRXhiLENBQUMsRUFBRXNiLEtBQUssQ0FBQ0csT0FBTyxFQUFDLENBQUM7WUFDdERuVyxXQUFXLEdBQUcsS0FBSztZQUNuQjs7VUFFSixLQUFLLFlBQVk7VUFDakIsS0FBSyxXQUFXO1VBQ2hCLEtBQUssVUFBVTtZQUNYO1FBQ1I7TUFDSjtJQUNKOztJQUVBLE9BQU8sS0FBSztFQUNoQixDQUFDOztFQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJLElBQUksQ0FBQ3VXLFdBQVcsR0FBRyxVQUFTQyxhQUFhLEVBQUU7SUFDdkMsT0FBTyxJQUFJLENBQUNQLFdBQVcsQ0FBQ08sYUFBYSxDQUFDO0VBQzFDLENBQUM7O0VBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0ksSUFBSSxDQUFDUCxXQUFXLEdBQUcsVUFBU08sYUFBYSxFQUFFLEtBQUFDLGFBQUEsRUFBQUMsYUFBQTs7SUFFdkMsSUFBSSxDQUFDM1UsWUFBWSxDQUFDLENBQUM7O0lBRW5CLElBQUkzRCxNQUFNLEdBQUdjLE9BQU8sQ0FBQ3NTLElBQUksQ0FBQ21GLGVBQWUsQ0FBQ0gsYUFBYSxDQUFDL2IsQ0FBQyxFQUFFK2IsYUFBYSxDQUFDOWIsQ0FBQyxFQUFFLEtBQUssQ0FBQzs7SUFFbEYsSUFBSSxDQUFDMEQsTUFBTSxJQUFJK0IsWUFBWSxFQUFFO01BQ3pCLElBQUl5VyxLQUFLLEdBQUcxWCxPQUFPLENBQUNzUyxJQUFJLENBQUNxRixnQkFBZ0IsQ0FBQ0wsYUFBYSxDQUFDL2IsQ0FBQyxFQUFFK2IsYUFBYSxDQUFDOWIsQ0FBQyxDQUFDO01BQzNFLElBQUlJLEtBQUssR0FBR29FLE9BQU8sQ0FBQ3NTLElBQUksQ0FBQ3NGLHVCQUF1QixDQUFDRixLQUFLLENBQUM7TUFDdkR4WSxNQUFNLEdBQUcsRUFBRVAsY0FBYyxFQUFHL0MsS0FBSyxDQUFDLENBQUM7SUFDdkM7O0lBRUEsSUFBSSxDQUFDc0QsTUFBTSxJQUFJLENBQUNBLE1BQU0sQ0FBQ1AsY0FBYztJQUNqQyxPQUFPLEtBQUs7O0lBRWhCLE1BQU1rWixTQUFTLEdBQUcsRUFBQU4sYUFBQSxHQUFBclksTUFBTSxDQUFDOEUsS0FBSyxjQUFBdVQsYUFBQSx1QkFBWkEsYUFBQSxDQUFjTSxTQUFTLENBQUMsQ0FBQyxLQUFLN1gsT0FBTyxDQUFDc1MsSUFBSSxDQUFDQyxJQUFJLE1BQUFpRixhQUFBLEdBQUl4WCxPQUFPLENBQUNnRSxLQUFLLGNBQUF3VCxhQUFBLHVCQUFiQSxhQUFBLENBQWVLLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDaEc7SUFDQSxJQUFJM1ksTUFBTSxDQUFDZ0YsSUFBSSxFQUFFO01BQ2IsSUFBSSxDQUFDTixVQUFVLENBQUMxRSxNQUFNLENBQUM7SUFDM0I7SUFDQTtJQUFBLEtBQ0ssSUFBSSxDQUFDQSxNQUFNLENBQUM0RSxJQUFJLElBQUk1RSxNQUFNLENBQUM0RSxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMrVCxTQUFTLEVBQUU7TUFDdkQsSUFBSSxDQUFDN0YsVUFBVSxDQUFDOVMsTUFBTSxDQUFDO0lBQzNCO0lBQ0E7SUFBQSxLQUNLO01BQ0QsTUFBTTRZLFdBQVcsR0FBRzdXLFlBQVksSUFBSTRXLFNBQVM7TUFDN0MsSUFBSUMsV0FBVyxFQUFFO1FBQ2IsSUFBSSxDQUFDL0MsbUJBQW1CLENBQUM3VixNQUFNLENBQUM7TUFDcEM7SUFDSjs7SUFFQSxJQUFJLENBQUM4VixZQUFZLENBQUMsQ0FBQzs7SUFFbkIsSUFBSTlULFdBQVcsSUFBSSxDQUFDQSxXQUFXLENBQUNuQixXQUFXLENBQUMsRUFBRTtNQUMxQyxJQUFJLENBQUM4QyxZQUFZLENBQUMsQ0FBQztNQUNuQixPQUFPLEtBQUs7SUFDaEI7O0lBRUEsT0FBTyxJQUFJO0VBQ2YsQ0FBQztBQUNMOztBQUVBbEksRUFBRSxDQUFDb2Qsa0JBQWtCLENBQUNwWSxJQUFJLENBQUNDLE9BQU8sQ0FBQ0YsU0FBUyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQXV0b2Rlc2suRXh0ZW5zaW9ucy8uL2V4dGVuc2lvbnMvU25hcHBpbmcvU25hcHBlci5qcz85MWM3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgTnVsbFNuYXBwZXJJbmRpY2F0b3IsIFNuYXBwZXJJbmRpY2F0b3IgfSBmcm9tIFwiLi9TbmFwcGVySW5kaWNhdG9yLmpzXCI7XG5pbXBvcnQgeyBuZWFyZXN0UG9pbnRPbkNpcmN1bGFyQXJjLCBpbnRlcnNlY3RMaW5lcyB9IGZyb20gXCIuL1NuYXBNYXRoLmpzXCI7XG5cbmNvbnN0IE1lYXN1cmVDb21tb24gPSBBdXRvZGVzay5WaWV3aW5nLk1lYXN1cmVDb21tb247XG5jb25zdCBFUFNJTE9OID0gTWVhc3VyZUNvbW1vbi5FUFNJTE9OO1xuY29uc3QgU25hcFR5cGUgPSBNZWFzdXJlQ29tbW9uLlNuYXBUeXBlO1xuY29uc3QgU25hcFJlc3VsdCA9IE1lYXN1cmVDb21tb24uU25hcFJlc3VsdDtcblxudmFyIFNOQVBfUFJFQ0lTSU9OID0gMC4wMDE7XG5cbmNvbnN0IGF2ID0gQXV0b2Rlc2suVmlld2luZztcbmNvbnN0IGF2cCA9IGF2LlByaXZhdGU7XG5jb25zdCBWZXJ0ZXhCdWZmZXJSZWFkZXIgPSBhdnAuVmVydGV4QnVmZmVyUmVhZGVyO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIC0gRmlyc3QgdmFsdWUgdG8gY29tcGFyZVxuICogQHBhcmFtIHtudW1iZXJ9IGIgLSBTZWNvbmQgdmFsdWUgdG8gY29tcGFyZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbFdpdGhQcmVjaXNpb24oYSwgYikge1xuICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgPD0gU05BUF9QUkVDSVNJT047XG59XG5cbi8qKlxuICogQXJlIHRoZSB2ZWN0b3JzIGVxdWFsIHdpdGhpbiBTTkFQX1BSRUNJU0lPTj9cbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gdjEgLSB2ZWN0b3JcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gdjIgLSB2ZWN0b3JcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgd2hlbiB0aGV5IGFyZSBlcXVhbFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbFZlY3RvcnNXaXRoUHJlY2lzaW9uKHYxLCB2Mikge1xuICAgIHJldHVybiBNYXRoLmFicyh2MS54IC0gdjIueCkgPD0gU05BUF9QUkVDSVNJT05cbiAgICAgICAgJiYgTWF0aC5hYnModjEueSAtIHYyLnkpIDw9IFNOQVBfUFJFQ0lTSU9OXG4gICAgICAgICYmIE1hdGguYWJzKHYxLnogLSB2Mi56KSA8PSBTTkFQX1BSRUNJU0lPTjtcbn1cblxuLyoqXG4gKiBBcmUgdGhlIHZlY3RvcnMgaW52ZXJzZSBvZiBlYWNoIG90aGVyIHdpdGhpbiBTTkFQX1BSRUNJU0lPTj9cbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gdjEgLSB2ZWN0b3JcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gdjIgLSB2ZWN0b3JcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgd2hlbiB0aGV5IGFyZSBpbnZlcnNlIG9mIGVhY2ggb3RoZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzSW52ZXJzZVZlY3RvcnNXaXRoUHJlY2lzaW9uKHYxLCB2Mikge1xuICAgIHJldHVybiBNYXRoLmFicyh2MS54ICsgdjIueCkgPD0gU05BUF9QUkVDSVNJT05cbiAgICAgICAgJiYgTWF0aC5hYnModjEueSArIHYyLnkpIDw9IFNOQVBfUFJFQ0lTSU9OXG4gICAgICAgICYmIE1hdGguYWJzKHYxLnogKyB2Mi56KSA8PSBTTkFQX1BSRUNJU0lPTjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9IHBvaW50IC0gUG9pbnRcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gbGluZVN0YXJ0IC0gU3RhcnQgb2YgdGhlIGxpbmVcbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gbGluZUVuZCAtIEVuZCBvZiB0aGUgbGluZVxuICogQHJldHVybnMge251bWJlcn0gLSBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIHRoZSBsaW5lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkaXN0YW5jZVBvaW50VG9MaW5lKHBvaW50LCBsaW5lU3RhcnQsIGxpbmVFbmQpIHtcblxuICAgIGlmIChsaW5lU3RhcnQuZXF1YWxzKGxpbmVFbmQpKSB7IC8vIERlZ2VuZXJhdGUgbGluZVxuICAgICAgICByZXR1cm4gcG9pbnQuZGlzdGFuY2VUbyhsaW5lU3RhcnQpO1xuICAgIH1cblxuICAgIHZhciBYMCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIFgxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgZGlzdGFuY2U7XG4gICAgdmFyIHBhcmFtO1xuXG4gICAgWDAuc3ViVmVjdG9ycyhsaW5lU3RhcnQsIHBvaW50KTtcbiAgICBYMS5zdWJWZWN0b3JzKGxpbmVFbmQsIGxpbmVTdGFydCk7XG4gICAgcGFyYW0gPSBYMC5kb3QoWDEpO1xuICAgIFgwLnN1YlZlY3RvcnMobGluZUVuZCwgbGluZVN0YXJ0KTtcbiAgICBwYXJhbSA9IC1wYXJhbSAvIFgwLmRvdChYMCk7XG5cbiAgICBpZiAocGFyYW0gPCAwKSB7XG4gICAgICAgIGRpc3RhbmNlID0gcG9pbnQuZGlzdGFuY2VUbyhsaW5lU3RhcnQpO1xuICAgIH0gZWxzZSBpZiAocGFyYW0gPiAxKSB7XG4gICAgICAgIGRpc3RhbmNlID0gcG9pbnQuZGlzdGFuY2VUbyhsaW5lRW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBYMC5zdWJWZWN0b3JzKHBvaW50LCBsaW5lU3RhcnQpO1xuICAgICAgICBYMS5zdWJWZWN0b3JzKHBvaW50LCBsaW5lRW5kKTtcbiAgICAgICAgWDAuY3Jvc3MoWDEpO1xuICAgICAgICBYMS5zdWJWZWN0b3JzKGxpbmVFbmQsIGxpbmVTdGFydCk7XG5cbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoWDAuZG90KFgwKSkgLyBNYXRoLnNxcnQoWDEuZG90KFgxKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3RhbmNlO1xufVxuXG5jb25zdCBTbmFwQ2FuZGlkYXRlVHlwZSA9IHtcbiAgICBVbmtub3duOiAgICAgICAwLFxuICAgIExpbmU6ICAgICAgICAgIDEsXG4gICAgQ2lyY3VsYXJBcmM6ICAgMixcbiAgICBFbGxpcHRpY2FsQXJjOiAzXG59O1xuXG4vLyBBIFNuYXBDYW5kaWRhdGUgcmVmZXJlbmNlcyBhIHNpbmdsZSBzZWdtZW50IChsaW5lIG9yIGFyYykgdGhhdCB3ZSBjb3VsZCBzbmFwIHRvLlxuY2xhc3MgU25hcENhbmRpZGF0ZSB7XG4gICAgY29uc3RydWN0b3Iodmlld3BvcnRJZCkge1xuXG4gICAgICAgIHRoaXMudHlwZSA9IFNuYXBDYW5kaWRhdGVUeXBlLlVua25vd247XG4gICAgICAgIHRoaXMudmlld3BvcnRJZCA9IHZpZXdwb3J0SWQ7XG5cbiAgICAgICAgLy8gMmQgZGlzdGFuY2UgYmV0d2VlbiBvcmlnaW5hbCAodW5zbmFwcGVkKSBwb3NpdGlvbiBhbmQgdGhlIGdlb21ldHJ5IG9mIHRoaXMgY2FuZGlkYXRlLlxuICAgICAgICB0aGlzLmRpc3RhbmNlID0gMDtcblxuICAgICAgICAvLyB7VmVjdG9yMn0gU3RhcnQvRW5kcG9pbnQgLSBvbmx5IGZvciBsaW5lIHNlZ21lbnRzXG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5saW5lRW5kICAgPSBudWxsO1xuXG4gICAgICAgIC8vIEZpeGVkIHJhZGl1cyAtIG9ubHkgZm9yIENpcmN1bGFyQXJjc1xuICAgICAgICB0aGlzLnJhZGl1cyA9IDA7XG5cbiAgICAgICAgLy8gU2VwYXJhdGUgcmFkaWkgLSBvbmx5IGZvciBlbGxpcHNlIGFyY3NcbiAgICAgICAgdGhpcy5yYWRpdXNYID0gMDsgLy8gPSBtYWpvciByYWRpdXMgLSBieSBjb252ZW50aW9uXG4gICAgICAgIHRoaXMucmFkaXVzWSA9IDA7XG5cbiAgICAgICAgLy8gQ2VudGVyIHBvaW50IGFzIFZlY3RvcjIgKGZvciBhcmNzKVxuICAgICAgICB0aGlzLmNlbnRlciA9IG51bGw7XG5cbiAgICAgICAgLy8gU3RhcnQvZW5kIGFuZ2xlIGZvciBhcmNzOiBDY3cgYW5nbGUgaW4gcmFkaWFucy4gQW5nbGUgMCBjb3JyZXNwb25kcyB0byBkaXJlY3Rpb24geCsuXG4gICAgICAgIHRoaXMuc3RhcnRBbmdsZSA9IDA7XG4gICAgICAgIHRoaXMuZW5kQW5nbGUgICA9IDA7XG4gICAgfVxuXG4gICAgZnJvbUxpbmUocDEsIHAyKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFNuYXBDYW5kaWRhdGVUeXBlLkxpbmU7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gcDEuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5saW5lRW5kICAgPSBwMi5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmcm9tQ2lyY3VsYXJBcmMoY2VudGVyLCByYWRpdXMsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy50eXBlICAgPSBTbmFwQ2FuZGlkYXRlVHlwZS5DaXJjdWxhckFyYztcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBjZW50ZXIuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgICAgIHRoaXMuc3RhcnQgID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kICAgID0gZW5kO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmcm9tRWxsaXB0aWNhbEFyYyhjZW50ZXIsIHJhZGl1c1gsIHJhZGl1c1ksIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy50eXBlID0gU25hcENhbmRpZGF0ZVR5cGUuRWxsaXB0aWNhbEFyYztcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBjZW50ZXIuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5yYWRpdXNYID0gcmFkaXVzWDtcbiAgICAgICAgdGhpcy5yYWRpdXNZID0gcmFkaXVzWTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaXNMaW5lKCkgICAgICAgICAgeyByZXR1cm4gdGhpcy50eXBlID09PSBTbmFwQ2FuZGlkYXRlVHlwZS5MaW5lOyB9XG4gICAgaXNDaXJjdWxhckFyYygpICAgeyByZXR1cm4gdGhpcy50eXBlID09PSBTbmFwQ2FuZGlkYXRlVHlwZS5DaXJ1bGFyQXJjOyB9XG4gICAgaXNFbGxpcHRpY2FsQXJjKCkgeyByZXR1cm4gdGhpcy50eXBlID09PSBTbmFwQ2FuZGlkYXRlVHlwZS5FbGxpcHRpY2FsQXJjOyB9XG5cbiAgICAvLyBDaGVja3MgaWYgdGhlIHNuYXBHZW9tZXRyeSBvZiB0aGlzIGNhbmRpZGF0ZSBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBvbmUuXG4gICAgLy8gIEBwYXJhbSB7U25hcENhbmRpZGF0ZX0gb3RoZXJcbiAgICAvLyAgQHBhcmFtIHtWZWN0b3IyfSBbb3B0aW9uYWxUYXJnZXRdXG4gICAgLy8gIEByZXR1cm5zIHtUSFJFRS5WZWN0b3IyfG51bGx9IFJldHVybnMgaW50ZXJzZWN0aW9uIHBvaW50IGlmIHRoZXJlIGlzIG9uZS5cbiAgICBnZXRJbnRlcnNlY3Rpb24ob3RoZXIsIG9wdGlvbmFsVGFyZ2V0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNMaW5lKCkgJiYgb3RoZXIuaXNMaW5lKCkpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIGRvIHRoZSBpbnRlcnNlY3Rpb25zIG9uIHRoZSB3aG9sZSBsaW5lIC0gbm90IGp1c3QgdGhlIGludGVyc2VjdGlvbnMuXG4gICAgICAgICAgICAvLyBSZWFzb24gaXM6XG4gICAgICAgICAgICAvLyAgYSkgT3RoZXJ3aXNlLCBpdCB3b3VsZCBub3Qgc25hcCBpZiB5b3UgYXJlIHNsaWdodGx5IG91dGxpbmUgb2Ygb25lIGxpbmUgc2VnbWVudFxuICAgICAgICAgICAgLy8gIGIpIEJ5IGRlZmluaXRpb24sIHdlIGdldCBvbmx5IHZlcnkgY2xvc2Ugc2VnbWVudCBjYW5kaWRhdGVzIGFueXdheVxuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdExpbmVzKHRoaXMubGluZVN0YXJ0LCB0aGlzLmxpbmVFbmQsIG90aGVyLmxpbmVTdGFydCwgb3RoZXIubGluZUVuZCwgZmFsc2UsIG9wdGlvbmFsVGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IEN1cnJlbnRseSwgd2Ugb25seSBzdXBwb3J0IHNuYXBwaW5nIHRvIGxpbmUtbGluZSBpbnRlcnNlY3Rpb25zXG4gICAgfVxufVxuXG4vLyBDaGVja3MgaWYgd2UgY2FuIHNuYXAgdG8gYW4gaW50ZXJzZWN0aW9uIG9mIHR3byBjbG9zZSBzZWdtZW50cyAoZWFjaCBjYW4gYmUgYSBsaW5lIG9yIGFyY3MpLlxuLy8gIEBwYXJhbSB7U25hcENhbmRpZGF0ZVtdfSBjYW5kaWRhdGVzICAgICAtIFNuYXAgY2FuZGlkYXRlIGdlb21ldHJpZXMgY29sbGVjdGVkIGluIEdlb21ldHJ5Q2FsbGJhY2suIEFzc3VtZWQgdG8gYmUgd2l0aGluIHNuYXBSYWRpdXMuXG4vLyAgQHBhcmFtIHtUUkVFLlZlY3RvcjN9ICAgIGludGVyc2VjdFBvaW50IC0gVW5zbmFwcGVkIG9yaWdpbmFsIHBvc2l0aW9uXG4vLyAgQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgIHNuYXBSYWRpdXNcbi8vICBAcmV0dXJucyB7T2JqZWN0fG51bGx9IElmIGFuIGludGVyc2VjdGlvbiBzbmFwIGlzIGZvdW5kLCB0aGUgcmVzdWx0IGNvbnRhaW5zOlxuLy8gICAgICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRJZCAgLy8gbnVtYmVyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBQb2ludCAgIC8vIChUSFJFRS5WZWN0b3IzKVxuLy8gICAgICAgICAgICAgICAgICAgIH1cbmNvbnN0IGZpbmRJbnRlcnNlY3Rpb25TbmFwID0gKGNhbmRpZGF0ZXMsIGludGVyc2VjdFBvaW50LCBzbmFwUmFkaXVzKSA9PiB7XG5cbiAgICAvLyBTb3J0IHNuYXBwaW5nIGNhbmRpZGF0ZXMgYnkgaW5jcmVhc2luZyBkaXN0YW5jZVxuICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCB3ZSBqdXN0IG5lZWQgdGhlIGJlc3QgdHdvIG9uZXMuIEJ1dCB0aGUgbnVtYmVyIG9mIGNhbmRpZGF0ZXMgd2l0aGluIHRoZSBzbmFwcGluZ1xuICAgIC8vIGRpc3RhbmNlIGlzIGdlbmVyYWxseSBzbWFsbCBhbnl3YXkgLSBhbmQgd29ya2luZyB3aXRoIGEgc29ydGVkIGFycmF5IGlzIG1vcmUgZmxleGlibGUgdG8gaW5jcmVtZW50YWxseVxuICAgIC8vIG1ha2UgdGhlIHNuYXBwaW5nIHNtYXJ0ZXIgbGF0ZXIuXG4gICAgY29uc3QgYnlEaXN0YW5jZSA9IChjYSwgY2IpID0+IGNhLmRpc3RhbmNlIC0gY2IuZGlzdGFuY2U7XG4gICAgY2FuZGlkYXRlcy5zb3J0KGJ5RGlzdGFuY2UpO1xuXG4gICAgLy8gU3RvcCBoZXJlIGlmIHdlIGRvbid0IGhhdmUgZW5vdWdoIGNhbmRpZGF0ZXMgZm9yIGFuIGludGVyc2VjdGlvblxuICAgIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gSW5pdCByZXN1bHQgb2JqZWN0XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAvLyBKdXN0IHVzZSB0aGUgb25lIG9mIHRoZSBmaXJzdCBjYW5kaWRhdGUuIFRoZXJlIGlzIG5vIHVuaXF1ZSB2aWV3cG9ydElkIHdoZW4gdXNpbmcgYW4gaW50ZXJzZWN0aW9uLlxuICAgICAgICB2aWV3cG9ydElkOiBjYW5kaWRhdGVzWzBdLnZpZXdwb3J0SWQsXG5cbiAgICAgICAgLy8gU25hcHBpbmcgaGFwcGVucyBpbiAyZCAtIHNvIHdlIHNldCB6IGluIGFkdmFuY2UgYW5kIGp1c3Qga2VlcCB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgICAgIC8vIE5vdGU6IFNuYXBwZXIgZ2VuZXJhbGx5IG5lZWRzIHNvbWUgcmV2aXNpb24gaWYgd2UgdXNlIGl0IGZvciBwbGFuZXMgdGhhdCBhcmUgbm90IHBlcnBlbmRpY3VsYXIgdG8gdGhlIHZpZXdpbmcgZGlyZWN0aW9uLlxuICAgICAgICBzbmFwUG9pbnQ6ICBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCBpbnRlcnNlY3RQb2ludC56KVxuICAgIH07XG5cbiAgICAvLyBDaGVjayBmb3IgYW55IGNhbmRpZGF0ZSB0aGF0IGludGVyc2VjdHMgd2l0aCB0aGUgY2xvc2VzdCBvbmUgd2UgZm91bmRcbiAgICBjb25zdCBmaXJzdCA9IGNhbmRpZGF0ZXNbMF07XG4gICAgZm9yIChsZXQgaT0xOyBpPGNhbmRpZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gY2FuZGlkYXRlc1tpXTtcblxuICAgICAgICAvLyBEbyBpbnRlcnNlY3Rpb24gdGVzdC4gSWYgZm91bmQsIHdyaXRlIGl0IHRvIHJlc3VsdC5zbmFwUG9pbnRcbiAgICAgICAgY29uc3QgZm91bmQgPSBmaXJzdC5nZXRJbnRlcnNlY3Rpb24oc2Vjb25kLCByZXN1bHQuc25hcFBvaW50KTtcbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBmb3VuZCBhbiBpbnRlcnNlY3Rpb24uIEFsdGhvdWdoIHdlIGFzc3VtZSBhbGwgY2FuZGlkYXRlcyB0byBiZSB3aXRoaW5cbiAgICAgICAgLy8gc25hcCByYWRpdXMgYWxyZWFkeSwgdGhlIGludGVyc2VjdGlvbiBtYXkgc3RpbGwgYmUgc29tZXdoZXJlIGVsc2UuXG4gICAgICAgIC8vID0+IENoZWNrIGlmIGludGVyc2VjdGlvbiBpcyBzdGlsbCB3aXRoaW4gdGhlIHNuYXBSYWRpdXMuXG4gICAgICAgIGNvbnN0IGRpc3QgPSBUSFJFRS5WZWN0b3IyLnByb3RvdHlwZS5kaXN0YW5jZVRvLmNhbGwocmVzdWx0LnNuYXBQb2ludCwgaW50ZXJzZWN0UG9pbnQpO1xuICAgICAgICBpZiAoZGlzdCA8IHNuYXBSYWRpdXMpIHtcbiAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgdmFsaWQgaW50ZXJzZWN0aW9uIHNuYXBcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKlxuICogQSB0b29sIHRoYXQgbGV0cyB1c2VycyBhdHRhY2ggcG9pbnRlciBldmVudHMgdG8gdmVydGljZXMgYW5kIGVkZ2VzLiBJdCBzdXBwb3J0cyAyRCBhbmQgM0QgbW9kZWxzLlxuICpcbiAqIEBwYXJhbSB7Vmlld2VyM0R9IHZpZXdlciAtIFZpZXdlciBpbnN0YW5jZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBDb25maWd1cmF0aW9ucyBmb3IgdGhlIGV4dGVuc2lvblxuICogQG1lbWJlcm9mIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5TbmFwcGluZ1xuICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5TbmFwcGluZy5TbmFwcGVyXG4gKiBAY2xhc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNuYXBwZXIodmlld2VyLCBvcHRpb25zKSB7XG5cbiAgICB2YXIgX3NuYXBSZXN1bHQgPSBuZXcgU25hcFJlc3VsdCgpO1xuXG4gICAgdmFyIF92aWV3ZXIgPSB2aWV3ZXI7XG4gICAgdGhpcy5zZXRHbG9iYWxNYW5hZ2VyKHZpZXdlci5nbG9iYWxNYW5hZ2VyKTtcblxuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIF9uYW1lcztcblxuICAgIGlmIChfb3B0aW9ucy5tYXJrdXBNb2RlKSB7XG4gICAgICAgIF9uYW1lcyA9IFtcInNuYXBwZXItbWFya3VwXCJdO1xuICAgIH0gZWxzZSBpZiAoX29wdGlvbnMudG9vbE5hbWUpIHtcbiAgICAgICAgLy8gQWxsb3cgdG9vbHMgdG8gdXNlIHRoZWlyIG93biBzbmFwcGVyXG4gICAgICAgIF9uYW1lcyA9IFtfb3B0aW9ucy50b29sTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX25hbWVzID0gW1wic25hcHBlclwiXTtcbiAgICB9XG5cbiAgICB2YXIgX3ByaW9yaXR5ID0gNjA7XG5cbiAgICB2YXIgX2FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgdmFyIF9kaXN0YW5jZVRvRWRnZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIF9kaXN0YW5jZVRvVmVydGV4ID0gbnVsbDtcblxuICAgIHZhciBfaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgIHZhciBfaXNQcmVzc2luZyA9IGZhbHNlO1xuICAgIHZhciBfaXNTbmFwcGVkID0gZmFsc2U7XG5cbiAgICB2YXIgX2ZvcmNlZFZwSWQgPSBudWxsOyAvLyB0aGUgdmlld3BvcnQgaW5kZXggb2YgdGhlIGZpcnN0IHNlbGVjdGlvbiBmb3IgMkRcblxuICAgIHZhciBfc25hcFRvUGl4ZWwgPSBmYWxzZTtcblxuICAgIHZhciBfc25hcEZpbHRlciA9IG51bGw7IC8vIE9wdGlvbmFsIHNuYXBwaW5nIGZpbHRlciwgYmFzZWQgb24gc25hcFJlc3VsdC4gKHNuYXBSZXN1bHQpID0+IGJvb2xlYW4uXG5cbiAgICB0aGlzLmluZGljYXRvciA9IG5ldyBTbmFwcGVySW5kaWNhdG9yKHZpZXdlciwgdGhpcyk7XG5cbiAgICB0aGlzLm1hcmt1cE1vZGUgPSBfb3B0aW9ucy5tYXJrdXBNb2RlO1xuICAgIHRoaXMucmVuZGVyU25hcHBlZEdlb21ldHJ5ID0gX29wdGlvbnMucmVuZGVyU25hcHBlZEdlb21ldHJ5O1xuICAgIHRoaXMucmVuZGVyU25hcHBlZFRvcG9sb2d5ID0gX29wdGlvbnMucmVuZGVyU25hcHBlZFRvcG9sb2d5O1xuXG4gICAgLy9Ob3RpY2U6IFRoZSBwaXhlbFNpemUgc2hvdWxkIGNvcnJlc3BvbmQgdG8gdGhlIGFtb3VudCBvZiBwaXhlbHMgcGVyIGxpbmUgaW4gaWRBdFBpeGVscywgdGhlIHNoYXBlIG9mXG4gICAgLy9kZXRlY3Rpb24gYXJlYSBpcyBzcXVhcmUgaW4gaWRBdFBpeGVscywgYnV0IGNpcmNsZSBpbiBzbmFwcGVyLCBzaG91bGQgbWFrZSB0aGVpciBhcmVhcyBtYXRjaCByb3VnaGx5LlxuICAgIHRoaXMuZGV0ZWN0UmFkaXVzSW5QaXhlbHMgPSBhdi5pc01vYmlsZURldmljZSgpID8gNTAgOiAxMDtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIHdoZW4gdGhlIHRvb2wgaXMgYWN0aXZlXG4gICAgICpcbiAgICAgKiBAYWxpYXMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLlNuYXBwaW5nLlNuYXBwZXIjaXNBY3RpdmVcbiAgICAgKi9cbiAgICB0aGlzLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfYWN0aXZlO1xuICAgIH07XG5cbiAgICB0aGlzLmdldE5hbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbmFtZXM7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0TmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX25hbWVzWzBdO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFByaW9yaXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcHJpb3JpdHk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBpbnRlcmNlcHRpbmcgcG9pbnRlciBldmVudHMuXG4gICAgICogSW52b2tlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSB7QGxpbmsgVG9vbENvbnRyb2xsZXJ9LlxuICAgICAqXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5TbmFwcGluZy5TbmFwcGVyI2FjdGl2YXRlXG4gICAgICovXG4gICAgdGhpcy5hY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBfYWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5pbmRpY2F0b3IuaXNOdWxsKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kaWNhdG9yID0gbmV3IFNuYXBwZXJJbmRpY2F0b3Iodmlld2VyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIGludGVyY2VwdGluZyBwb2ludGVyIGV2ZW50cy5cbiAgICAgKiBJbnZva2VkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIHtAbGluayBUb29sQ29udHJvbGxlcn0uXG4gICAgICpcbiAgICAgKiBAYWxpYXMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLlNuYXBwaW5nLlNuYXBwZXIjZGVhY3RpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBfYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCF0aGlzLmluZGljYXRvci5pc051bGwoKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRpY2F0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbmRpY2F0b3IgPSBuZXcgTnVsbFNuYXBwZXJJbmRpY2F0b3IoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmNvcHlSZXN1bHRzID0gZnVuY3Rpb24oZGVzdGlueSkge1xuICAgICAgICBfc25hcFJlc3VsdC5jb3B5VG8oZGVzdGlueSk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RWRnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NuYXBSZXN1bHQuZ2VvbUVkZ2U7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0VmVydGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc25hcFJlc3VsdC5nZW9tVmVydGV4O1xuICAgIH07XG5cbiAgICB0aGlzLmdldEdlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc25hcFJlc3VsdC5nZXRHZW9tZXRyeSgpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NuYXBSZXN1bHQuZ2VvbVR5cGU7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0SW50ZXJzZWN0UG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50O1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtTbmFwUmVzdWx0fSBUaGUgc25hcHBpbmcgc3RhdHVzIG9mIHRoZSBsYXN0IHBvaW50ZXIgZXZlbnQgcGVyZm9ybWVkLlxuICAgICAqXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5TbmFwcGluZy5TbmFwcGVyI2dldFNuYXBSZXN1bHRcbiAgICAgKi9cbiAgICB0aGlzLmdldFNuYXBSZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwUmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgdG9vbCdzIGxhc3QgdXBkYXRlIHJlc3VsdGVkIG9uIGEgc25hcC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIHdoZW4gdGhlIGxhc3QgcG9pbnRlciBldmVudCBnb3Qgc25hcHBlZC5cbiAgICAgKlxuICAgICAqIEBhbGlhcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuU25hcHBpbmcuU25hcHBlciNpc1NuYXBwZWRcbiAgICAgKi9cbiAgICB0aGlzLmlzU25hcHBlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2lzU25hcHBlZDtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhclNuYXBwZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX3NuYXBSZXN1bHQuY2xlYXIoKTtcbiAgICAgICAgX2lzU25hcHBlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFZpZXdwb3J0SWQgPSBmdW5jdGlvbih2cElkKSB7XG4gICAgICAgIF9mb3JjZWRWcElkID0gdnBJZDtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRTbmFwVG9QaXhlbCA9IGZ1bmN0aW9uKGVuYWJsZSkge1xuICAgICAgICBfc25hcFRvUGl4ZWwgPSBlbmFibGU7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0U25hcFRvUGl4ZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zbmFwVG9QaXhlbDtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRTbmFwVG9BcmMgPSBmdW5jdGlvbihlbmFibGUpIHtcbiAgICAgICAgX3NuYXBSZXN1bHQuc25hcFRvQXJjID0gZW5hYmxlO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFNuYXBUb0FyYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NuYXBSZXN1bHQuc25hcFRvQXJjO1xuICAgIH07XG5cbiAgICB0aGlzLnNldEFyYyA9IGZ1bmN0aW9uKGlzQXJjKSB7XG4gICAgICAgIF9zbmFwUmVzdWx0LmlzQXJjID0gaXNBcmM7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0QXJjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc25hcFJlc3VsdC5pc0FyYztcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRTbmFwRmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICBfc25hcEZpbHRlciA9IGZpbHRlcjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogM0QgU25hcHBpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXN1bHQgLVJlc3VsdCBvZiBIaXQgVGVzdC5cbiAgICAgKi9cbiAgICB0aGlzLnNuYXBwaW5nM0QgPSBmdW5jdGlvbihyZXN1bHQpIHtcblxuICAgICAgICBfc25hcFJlc3VsdC5zbmFwTm9kZSA9IHJlc3VsdC5kYklkO1xuICAgICAgICBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCA9IHJlc3VsdC5pbnRlcnNlY3RQb2ludDtcbiAgICAgICAgX3NuYXBSZXN1bHQubW9kZWxJZCA9IHJlc3VsdC5tb2RlbCA/IHJlc3VsdC5tb2RlbC5pZCA6IG51bGw7XG5cbiAgICAgICAgdmFyIGZhY2UgPSByZXN1bHQuZmFjZTtcblxuICAgICAgICBpZiAoIXJlc3VsdC5tb2RlbCB8fCByZXN1bHQuZnJhZ0lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNvbWUgbm9uLW1vZGVsIGdlb21ldHJ5IHdhcyBoaXRcbiAgICAgICAgICAgIGlmIChyZXN1bHQub2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0IHdhcyBhIG1lc2gsIHRyeSB0byBzbmFwIHRvIGl0XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNoU25hcHBpbmcoZmFjZSwgcmVzdWx0Lm9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZnJhZ0lkcztcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5mcmFnSWQubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmcmFnSWRzID0gW3Jlc3VsdC5mcmFnSWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFnSWRzID0gcmVzdWx0LmZyYWdJZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhpcyBpcyBmb3IgRnVzaW9uICYgQVRGIG1vZGVsIHdpdGggdG9wb2xvZ3kgZGF0YVxuICAgICAgICAgICAgX3NuYXBSZXN1bHQuaGFzVG9wb2xvZ3kgPSByZXN1bHQubW9kZWwuaGFzVG9wb2xvZ3koKTtcbiAgICAgICAgICAgIGlmKF9zbmFwUmVzdWx0Lmhhc1RvcG9sb2d5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIEZvciBtaXhlZCBtb2RlIChzb21lIGVudGl0aWVzIGhhdmUgdG9wbywgYW5kIHNvbWUgb3RoZXJzIGRvbid0KSxcbiAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgZnVydGhlciBjaGVjayB0aGUgc2VsZWN0ZWQgZnJhZ0lkIGhhcyB2YWxpZCB0b3BvbG9neSBiZWZvcmUgZ28gd2l0aCBzbmFwcGluZzNEd2l0aFRvcG9sb2d5LlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmcmFnSWRzLmxlbmd0aDsgKytmaSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFnSWQgPSBmcmFnSWRzW2ZpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcG9JbmRleCA9IHJlc3VsdC5tb2RlbC5nZXRUb3BvSW5kZXgoZnJhZ0lkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcG9sb2d5ID0gcmVzdWx0Lm1vZGVsLmdldFRvcG9sb2d5KHRvcG9JbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRvcG9sb2d5ID09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuaGFzVG9wb2xvZ3kgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmIChfc25hcFJlc3VsdC5oYXNUb3BvbG9neSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc25hcHBpbmczRHdpdGhUb3BvbG9neShmYWNlLCBmcmFnSWRzLCByZXN1bHQubW9kZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBwaW5nM0R0b01lc2goZmFjZSwgZnJhZ0lkcywgcmVzdWx0Lm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHNldHMgYSB2ZXJ0ZXggKFZlY3RvcjMgb3IgTG12VmVjdG9yMykgdG8gdGhlIGRhdGEgcmVhZCBmcm9tIGEgdmVydGV4IGJ1ZmZlciBhdCBpZHhcbiAgICAgKiBTaWduYXR1cmU6IGZ1bmMoaWR4LCB2ZXJ0ZXgpIC0+IHZlcnRleFxuICAgICAqICAgICAgICAgICAgaWYgdmVydGV4IGlzIG51bGwvdW5kZWZpbmVkLCBhIG5ldyBUSFJFRS5WZWN0b3IzIGlzIGNyZWF0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5IC0gdGhlIGdlb21ldHJ5IG9mIG1lc2hcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICB0aGlzLm1ha2VSZWFkVmVydGV4RnVuYyA9IGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgICAgICBsZXQgcG9zaXRpb25zLCBzdHJpZGU7XG4gICAgICAgIC8vIEdldCB0aGUgb2Zmc2V0IHRvIHBvc2l0aW9ucyBpbiB0aGUgYnVmZmVyLiBCZSBjYXJlZnVsLCAyRCBidWZmZXJzXG4gICAgICAgIC8vIGRvbid0IHVzZSB0aGUgJ3Bvc2l0aW9uJyBhdHRyaWJ1dGUgZm9yIHBvc2l0aW9ucy4gUmVqZWN0IHRob3NlLlxuICAgICAgICAvLyBtZXNoZXMgdXNlIHZibGF5b3V0IGZvciBkZXNjcmliaW5nIHRoZSBidWZmZXIgc3RydWN0dXJlLCBCdWZmZXJHZW9tZXRyeSB1c2VzIGF0dHJpYnV0ZXMueHhcbiAgICAgICAgbGV0IHBvZmZzZXQ7XG5cbiAgICAgICAgaWYgKGdlb21ldHJ5LnZibGF5b3V0KSB7XG4gICAgICAgICAgICBpZiAoIWdlb21ldHJ5LnZibGF5b3V0LnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307ICAgICAvLyBObyBwb3NpdGlvbnMsIHdoYXQgdG8gZG8/P1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9mZnNldCA9IGdlb21ldHJ5LnZibGF5b3V0LnBvc2l0aW9uLm9mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy5wb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307ICAgICAvLyBObyBwb3NpdGlvbnMsIHdoYXQgdG8gZG8/P1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9mZnNldCA9IGF0dHJpYnV0ZXMucG9zaXRpb24ub2Zmc2V0IHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBwb3NpdGlvbnMgPSBnZW9tZXRyeS52YiA/IGdlb21ldHJ5LnZiIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgICAgICAgc3RyaWRlID0gZ2VvbWV0cnkudmIgPyBnZW9tZXRyeS52YnN0cmlkZSA6IDM7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGlkeCwgdikge1xuICAgICAgICAgICAgY29uc3QgcCA9IGlkeCAqIHN0cmlkZSArIHBvZmZzZXQ7XG4gICAgICAgICAgICB2ID0gdiB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgdi5zZXQoXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zW3BdLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uc1twICsgMV0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zW3AgKyAyXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTbmFwcGluZyBvcmRlciBpczogMXN0IHZlcnRpY2VzLCAybmQgZWRnZXMsIDNyZCBhbmQgZmluYWwgZmFjZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmFjZVxuICAgICAqIEBwYXJhbSBmcmFnSWRzXG4gICAgICogQHBhcmFtIG1vZGVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNuYXBwaW5nM0R3aXRoVG9wb2xvZ3kgPSBmdW5jdGlvbihmYWNlLCBmcmFnSWRzLCBtb2RlbCkge1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWRnZSB0b3BvbG9neSBkYXRhIG1heSBiZSBpbiBvdGhlciBmcmFnbWVudHMgd2l0aCBzYW1lIGRiSWQsIG5lZWQgdG8gaXRlcmF0ZSBhbGwgb2YgdGhlbS5cbiAgICAgICAgaWYgKF9zbmFwUmVzdWx0LnNuYXBOb2RlKSB7XG4gICAgICAgICAgICBmcmFnSWRzID0gW107XG5cbiAgICAgICAgICAgIG1vZGVsLmdldERhdGEoKS5pbnN0YW5jZVRyZWUuZW51bU5vZGVGcmFnbWVudHMoX3NuYXBSZXN1bHQuc25hcE5vZGUsIGZ1bmN0aW9uKGZyYWdJZCkge1xuICAgICAgICAgICAgICAgIGZyYWdJZHMucHVzaChmcmFnSWQpO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBfc25hcFJlc3VsdC5nZW9tRmFjZSA9IF9zbmFwUmVzdWx0Lmdlb21FZGdlID0gX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IG51bGw7XG4gICAgICAgIF9kaXN0YW5jZVRvRWRnZSA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZyYWdJZHMubGVuZ3RoOyArK2ZpKSB7XG5cbiAgICAgICAgICAgIHZhciBmcmFnSWQgPSBmcmFnSWRzW2ZpXTtcblxuICAgICAgICAgICAgY29uc3QgbWF0cml4V29ybGQgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgICAgICAgICAgbW9kZWwuZ2V0RnJhZ21lbnRMaXN0KCk/LmdldFdvcmxkTWF0cml4KGZyYWdJZCwgbWF0cml4V29ybGQpO1xuICAgICAgICAgICAgdmFyIGdlb21ldHJ5ID0gbW9kZWwuZ2V0RnJhZ21lbnRMaXN0KCk/LmdldEdlb21ldHJ5KGZyYWdJZCk7XG5cbiAgICAgICAgICAgIHZhciB0b3BvSW5kZXggPSBtb2RlbC5nZXRUb3BvSW5kZXgoZnJhZ0lkKTtcbiAgICAgICAgICAgIHZhciB0b3BvbG9neSA9IG1vZGVsLmdldFRvcG9sb2d5KHRvcG9JbmRleCk7XG4gICAgICAgICAgICAvLyBGb3IgQVRGIG1lcmdlZCBEQklEIHNjZW5hcmlvLCBwYXJ0IG9mIG1lcmdlZCBlbnRpdGllcyBtYXkgaGF2ZSBubyB0b3BvbG9neS5cbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBza2lwIHRoaXMgY2FzZSBmb3IgZmFjZSBhbmQgZWRnZSB0b3BvbG9neSBtZWFzdXJlbWVudC5cbiAgICAgICAgICAgIGlmKHRvcG9sb2d5ID09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGZhY2VzVG9wb2xvZ3kgPSB0b3BvbG9neS5mYWNlcztcbiAgICAgICAgICAgIHZhciBlZGdlc1RvcG9sb2d5ID0gdG9wb2xvZ3kuZWRnZXM7XG5cbiAgICAgICAgICAgIGlmICghX3NuYXBSZXN1bHQuZ2VvbUZhY2UpIHtcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tRmFjZSA9IHRoaXMuZmFjZVNuYXBwaW5nV2l0aFRvcG9sb2d5KGZhY2UsIGdlb21ldHJ5LCBmYWNlc1RvcG9sb2d5LCB7bWF0cml4V29ybGR9KTtcblxuICAgICAgICAgICAgICAgIGlmIChfc25hcFJlc3VsdC5nZW9tRmFjZSkge1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tRmFjZS5mcmFnSWQgPSBmcmFnSWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KG1hdHJpeFdvcmxkKTtcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5mYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwuYXBwbHlNYXRyaXgzKG5vcm1hbE1hdHJpeCkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gaXRlcmF0ZSBhbGwgZnJhZ3Mgd2l0aCBzYW1lIGRiSWQsIGJlY2F1c2Ugd2hlbiBtZXNoZXMgYXJlIGF0dGFjaGVkIHdpdGggZWFjaCBvdGhlcixcbiAgICAgICAgICAgIC8vIGVkZ2UtdG9wb2xvZ3kgZGF0YSB3aWxsIG9ubHkgYmUgb24gb25lIG1lc2guXG4gICAgICAgICAgICB0aGlzLmVkZ2VTbmFwcGluZ1dpdGhUb3BvbG9neShfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCwgZ2VvbWV0cnksIGVkZ2VzVG9wb2xvZ3ksIHttYXRyaXhXb3JsZH0pO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfc25hcFJlc3VsdC5nZW9tVmVydGV4ID0gdGhpcy52ZXJ0ZXhTbmFwcGluZ1dpdGhUb3BvbG9neShfc25hcFJlc3VsdC5nZW9tRWRnZSwgX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgICAgIGlmIChfc25hcFJlc3VsdC5nZW9tRmFjZSkge1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggb25lIHNob3VsZCBiZSBkcmF3bjogZmFjZSAsIGVkZ2Ugb3IgdmVydGV4XG4gICAgICAgICAgICBfc25hcFJlc3VsdC5yYWRpdXMgPSB0aGlzLnNldERldGVjdFJhZGl1cyhfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCk7XG5cbiAgICAgICAgICAgIGlmICgoX29wdGlvbnMuZm9yY2VTbmFwVmVydGljZXMgfHwgX2Rpc3RhbmNlVG9WZXJ0ZXggPCBfc25hcFJlc3VsdC5yYWRpdXMpICYmIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKF9vcHRpb25zLmZvcmNlU25hcEVkZ2VzIHx8IF9kaXN0YW5jZVRvRWRnZSA8IF9zbmFwUmVzdWx0LnJhZGl1cykgJiYgX3NuYXBSZXN1bHQuZ2VvbUVkZ2UpIHtcblxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmVkZ2VJc0NpcmNsZShfc25hcFJlc3VsdC5nZW9tRWRnZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbnRlcikge1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5jaXJjdWxhckFyY0NlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuY2lyY3VsYXJBcmNSYWRpdXMgPSBjZW50ZXIuZGlzdGFuY2VUbyhfc25hcFJlc3VsdC5nZW9tRWRnZS52ZXJ0aWNlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21FZGdlLmNlbnRlciA9IF9zbmFwUmVzdWx0LmNpcmN1bGFyQXJjQ2VudGVyO1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tRWRnZS5yYWRpdXMgPSBfc25hcFJlc3VsdC5jaXJjdWxhckFyY1JhZGl1cztcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX0NJUkNVTEFSQVJDO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmVkZ2VJc0N1cnZlZChfc25hcFJlc3VsdC5nZW9tRWRnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX0NVUlZFREVER0U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfRURHRTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmFjZUlzQ3VydmVkKF9zbmFwUmVzdWx0Lmdlb21GYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfQ1VSVkVERkFDRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9GQUNFO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaXNTbmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm1lc2hTbmFwcGluZyA9IGZ1bmN0aW9uKGZhY2UsIHtnZW9tZXRyeSwgbWF0cml4V29ybGR9KSB7XG5cbiAgICAgICAgLy8gSGFuZGxlIDNEIGxpbmUgZ2VvbWV0cnlcbiAgICAgICAgY29uc3QgaXNMaW5lID0gZ2VvbWV0cnkuaXNMaW5lcyB8fCBnZW9tZXRyeS5pc1dpZGVMaW5lcztcbiAgICAgICAgaWYgKGlzTGluZSAmJiBmYWNlKSB7XG5cbiAgICAgICAgICAgIC8vIEZvciBsaW5lIG1lc2hlcywgZmFjZSBpcyBhIGxpbmUge2EsIGJ9IGluc3RlYWQgb2YgYSBGYWNlMyBpbnN0YW5jZSAoc2VlIGxpbmVSYXlDYXN0KC4uKSBpbiBWQkludGVyc2VjdG9yLmpzLFxuICAgICAgICAgICAgLy8gd2hlcmUgYSwgYiBhcmUgdmVydGV4IGluZGljZXMgaW50byB0aGUgbGluZSBtZXNoIHZlcnRleCBhcnJheS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBOb3RlOiBVbmxpa2UgZWRnZSBpbnRlcnNlY3Rpb24gZm9yIGZhY2VzLCB3ZSBqdXN0IHVzZSB0aGUgbGluZSBzZWdtZW50IGl0c2VsZiBhbmQgZG9uJ3Qgc2VhcmNoIGZvciB0b3BvbG9neVxuICAgICAgICAgICAgLy8gICAgICAgb2YgY29ubmVjdGVkIGxpbmUgc2VnbWVudHMgdG8gaWRlbnRpZnkgcG9seWxpbmVzIGFzIG9uZSBpdGVtLiBJZiB3ZSBuZWVkIHRoaXMsIHdlIGhhdmUgdG8gYWRkIHRoZSBjb3JyZXNwb25kaW5nIGNvZGUgZmlyc3QuXG4gICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tRWRnZSA9IHRoaXMuZXh0cmFjdExpbmVHZW9tZXRyeShmYWNlLCBnZW9tZXRyeSk7XG4gICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tRWRnZS5hcHBseU1hdHJpeDQobWF0cml4V29ybGQpO1xuXG4gICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVmVydGV4ID0gdGhpcy52ZXJ0ZXhTbmFwcGluZyhfc25hcFJlc3VsdC5nZW9tRWRnZSwgX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgICAgICAgICBfc25hcFJlc3VsdC5yYWRpdXMgPSB0aGlzLnNldERldGVjdFJhZGl1cyhfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCk7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBvbmUgc2hvdWxkIGJlIGRyYXduOiBlZGdlIG9yIHZlcnRleFxuICAgICAgICAgICAgaWYgKChfb3B0aW9ucy5mb3JjZVNuYXBWZXJ0aWNlcyB8fCAoX2Rpc3RhbmNlVG9WZXJ0ZXggPCBfc25hcFJlc3VsdC5yYWRpdXMpKSkge1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9WRVJURVg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBTaW5jZSB3ZSBnb3QgdGhlIGVkZ2UgYXMgaGl0IHJlc3VsdCwgd2UgY2FuIGFscmVhZHkgYXNzdW1lIHRoZSBpbnRlcnNlY3Rpb24gdG8gYmUgY2xvc2UgdG8gdGhlIGxpbmUuXG4gICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX0VER0U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9pc1NuYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RlIHRoYXQgZmFjZSBtYXkgYWxzbyBiZSBhIGxpbmUge2EsIGJ9IChzZWUgbGluZVJheUNhc3QoLi4pIGluIFZCSW50ZXJzZWN0b3IuanNcbiAgICAgICAgaWYgKGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMykge1xuICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbUZhY2UgPSB0aGlzLmZhY2VTbmFwcGluZyhmYWNlLCBnZW9tZXRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV9zbmFwUmVzdWx0Lmdlb21GYWNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIF9zbmFwUmVzdWx0Lmdlb21GYWNlLmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG4gICAgICAgIF9zbmFwUmVzdWx0Lmdlb21FZGdlID0gdGhpcy5lZGdlU25hcHBpbmcoX3NuYXBSZXN1bHQuZ2VvbUZhY2UsIF9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50KTtcbiAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IHRoaXMudmVydGV4U25hcHBpbmcoX3NuYXBSZXN1bHQuZ2VvbUVkZ2UsIF9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50KTtcblxuICAgICAgICB2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgobWF0cml4V29ybGQpO1xuICAgICAgICBfc25hcFJlc3VsdC5mYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwuYXBwbHlNYXRyaXgzKG5vcm1hbE1hdHJpeCkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgX3NuYXBSZXN1bHQucmFkaXVzID0gdGhpcy5zZXREZXRlY3RSYWRpdXMoX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCBvbmUgc2hvdWxkIGJlIGRyYXduOiBmYWNlLCBlZGdlIG9yIHZlcnRleFxuICAgICAgICBpZiAoKF9vcHRpb25zLmZvcmNlU25hcFZlcnRpY2VzIHx8IChfZGlzdGFuY2VUb1ZlcnRleCA8IF9zbmFwUmVzdWx0LnJhZGl1cykpKSB7XG4gICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9vcHRpb25zLmZvcmNlU25hcEVkZ2VzIHx8IChfZGlzdGFuY2VUb0VkZ2UgPCBfc25hcFJlc3VsdC5yYWRpdXMpKSB7XG4gICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfRURHRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9GQUNFO1xuICAgICAgICB9XG5cbiAgICAgICAgX2lzU25hcHBlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB0aGlzLnNuYXBwaW5nM0R0b01lc2ggPSBmdW5jdGlvbihmYWNlLCBmcmFnSWRzLCBtb2RlbCkge1xuICAgICAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgZnJhZ0lkcy5sZW5ndGg7ICsrZmkpIHtcblxuICAgICAgICAgICAgdmFyIGZyYWdJZCA9IGZyYWdJZHNbZmldO1xuXG5cbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbW9kZWwuZ2V0RnJhZ21lbnRMaXN0KCkuZ2V0R2VvbWV0cnkoZnJhZ0lkKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeFdvcmxkID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgICAgICAgIG1vZGVsLmdldEZyYWdtZW50TGlzdCgpLmdldFdvcmxkTWF0cml4KGZyYWdJZCwgbWF0cml4V29ybGQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tZXNoU25hcHBpbmcoZmFjZSwge2dlb21ldHJ5LCBtYXRyaXhXb3JsZH0pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5mYWNlU25hcHBpbmdXaXRoVG9wb2xvZ3kgPSBmdW5jdGlvbihmYWNlLCBnZW9tZXRyeSwgZmFjZXNUb3BvbG9neSwge21hdHJpeFdvcmxkfSkge1xuXG4gICAgICAgIHZhciB2QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciB2QiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgY29uc3QgZ2VvbSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXG4gICAgICAgIGlmIChnZW9tZXRyeS5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIGZhY2UgdG9wb2xvZ3kgbGlzdCB3aGljaCBpbmNsdWRlcyB0aGUgaW50ZXJzZWN0IGZhY2UodHJpYW5nbGUpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZhY2VzVG9wb2xvZ3kubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRleExpc3QgPSBmYWNlc1RvcG9sb2d5W2ldLmluZGV4TGlzdDtcbiAgICAgICAgICAgICAgICB2YXIgZmFjZUlkID0gZmFjZXNUb3BvbG9neVtpXS5pZDtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICg7IGogPCBpbmRleExpc3QubGVuZ3RoOyBqICs9IDMpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmFjZS5hID09PSBpbmRleExpc3Rbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZmFjZS5iID09PSBpbmRleExpc3RbaiArIDFdICYmIGZhY2UuYyA9PT0gaW5kZXhMaXN0W2ogKyAyXSkgfHwgKGZhY2UuYiA9PT0gaW5kZXhMaXN0W2ogKyAyXSAmJiBmYWNlLmMgPT09IGluZGV4TGlzdFtqICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmFjZS5hID09PSBpbmRleExpc3RbaiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZhY2UuYiA9PT0gaW5kZXhMaXN0W2pdICYmIGZhY2UuYyA9PT0gaW5kZXhMaXN0W2ogKyAyXSkgfHwgKGZhY2UuYiA9PT0gaW5kZXhMaXN0W2ogKyAyXSAmJiBmYWNlLmMgPT09IGluZGV4TGlzdFtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmYWNlLmEgPT09IGluZGV4TGlzdFtqICsgMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZmFjZS5iID09PSBpbmRleExpc3Rbal0gJiYgZmFjZS5jID09PSBpbmRleExpc3RbaiArIDFdKSB8fCAoZmFjZS5iID09PSBpbmRleExpc3RbaiArIDFdICYmIGZhY2UuYyA9PT0gaW5kZXhMaXN0W2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGogPCBpbmRleExpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGkgPCBmYWNlc1RvcG9sb2d5Lmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZFZlcnRleCA9IHRoaXMubWFrZVJlYWRWZXJ0ZXhGdW5jKGdlb21ldHJ5KTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kZXhMaXN0Lmxlbmd0aDsgaiArPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRWZXJ0ZXgoaW5kZXhMaXN0W2pdLCB2QSk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRWZXJ0ZXgoaW5kZXhMaXN0W2ogKyAxXSwgdkIpO1xuICAgICAgICAgICAgICAgICAgICByZWFkVmVydGV4KGluZGV4TGlzdFtqICsgMl0sIHZDKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2SW5kZXggPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGdlb20uZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTModkluZGV4LCB2SW5kZXggKyAxLCB2SW5kZXggKyAyKSk7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2godkEuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2godkIuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2godkMuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdlb20udmVydGljZXMgPSB2ZXJ0aWNlcztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgZ2VvbS5mYWNlSWQgPSBmYWNlSWQ7XG4gICAgICAgICAgICBnZW9tLmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG4gICAgICAgICAgICByZXR1cm4gZ2VvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBjbG9zZXN0IGZhY2UgbmV4dCB0byB0aGUgY2FzdCByYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VEhSRUUuRmFjZTN9IGZhY2UgLSB0aGUgaW50ZXJzZWN0IHRyaWFuZ2xlIG9mIEhpdCBUZXN0LlxuICAgICAqIEBwYXJhbSB7QnVmZmVyR2VvbWV0cnl9IGdlb21ldHJ5IC0gdGhlIGdlb21ldHJ5IG9mIG1lc2hcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5mYWNlU25hcHBpbmcgPSBmdW5jdGlvbihmYWNlLCBnZW9tZXRyeSkge1xuXG4gICAgICAgIHZhciB2QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciB2QiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgY29uc3QgZ2VvbSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpOyAvL0dlb21ldHJ5IHdoaWNoIGluY2x1ZGVzIGFsbCB0aGUgdHJpYW5nbGVzIG9uIHRoZSBzYW1lIHBsYW5lLlxuXG4gICAgICAgIGxldCBpbmRpY2VzO1xuICAgICAgICAvLyBAdG9kbzogLmliIG1pZ2h0IG5vdCBiZSB0aGVyZSBhcyBleHBlY3RlZCwgZS5nLiwgdGhlIHNlY3Rpb24gdG9vbCBzZWVtcyB0byBjcmVhdGUgaW5jb21wbGV0ZS9ub24tY29uZm9ybWluZyBnZW9tZXRyaWVzLlxuICAgICAgICBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXggJiYgKGdlb21ldHJ5LmluZGV4LmFycmF5IHx8IGdlb21ldHJ5LmliKTtcblxuICAgICAgICB2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuICAgICAgICBpZiAoICFvZmZzZXRzIHx8IG9mZnNldHMubGVuZ3RoID09PSAwKSB7XG5cbiAgICAgICAgICAgIGxldCBwb3NpdGlvbnM7XG4gICAgICAgICAgICAvLyBAdG9kbzogLnZiIG1pZ2h0IG5vdCBiZSB0aGVyZSBhcyBleHBlY3RlZCwgZS5nLiwgdGhlIHNlY3Rpb24gdG9vbCBzZWVtcyB0byBjcmVhdGUgaW5jb21wbGV0ZS9ub24tY29uZm9ybWluZyBnZW9tZXRyaWVzLlxuICAgICAgICAgICAgcG9zaXRpb25zID0gZ2VvbWV0cnkudmIgPz8gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgICAgICAgICAgIG9mZnNldHMgPSBbeyBzdGFydDogMCwgY291bnQ6IGluZGljZXMgPyBpbmRpY2VzLmxlbmd0aCA6IHBvc2l0aW9ucy5sZW5ndGgsIGluZGV4OiAwIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVhZFZlcnRleCA9IHRoaXMubWFrZVJlYWRWZXJ0ZXhGdW5jKGdlb21ldHJ5KTtcblxuICAgICAgICBjb25zdCB2YSA9IHJlYWRWZXJ0ZXgoZmFjZS5hKTtcblxuICAgICAgICBmb3IgKHZhciBvaSA9IDA7IG9pIDwgb2Zmc2V0cy5sZW5ndGg7ICsrb2kpIHtcblxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0c1tvaV0uc3RhcnQ7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBvZmZzZXRzW29pXS5jb3VudDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgICBpbmRleCA9IG9mZnNldHNbb2ldLmluZGV4O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpICs9IDMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBhID0gaW5kZXggKyAoaW5kaWNlcyA/IGluZGljZXNbaV0gOiBpKTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGluZGV4ICsgKGluZGljZXMgPyBpbmRpY2VzW2kgKyAxXSA6IGkgKyAxKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGluZGV4ICsgKGluZGljZXMgPyBpbmRpY2VzW2kgKyAyXSA6IGkgKyAyKTtcblxuICAgICAgICAgICAgICAgIHJlYWRWZXJ0ZXgoYSwgdkEpO1xuICAgICAgICAgICAgICAgIHJlYWRWZXJ0ZXgoYiwgdkIpO1xuICAgICAgICAgICAgICAgIHJlYWRWZXJ0ZXgoYywgdkMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZhY2VOb3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgICAgIFRIUkVFLlRyaWFuZ2xlLmdldE5vcm1hbCh2QSwgdkIsIHZDLCBmYWNlTm9ybWFsKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0VxdWFsVmVjdG9yc1dpdGhQcmVjaXNpb24oZmFjZU5vcm1hbCwgZmFjZS5ub3JtYWwpICYmIGlzRXF1YWxXaXRoUHJlY2lzaW9uKGZhY2VOb3JtYWwuZG90KHZBKSwgZmFjZS5ub3JtYWwuZG90KHZhKSkpXG4gICAgICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZJbmRleCA9IGdlb20udmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBnZW9tLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKHZJbmRleCwgdkluZGV4ICsgMSwgdkluZGV4ICsgMikpO1xuICAgICAgICAgICAgICAgICAgICBnZW9tLnZlcnRpY2VzLnB1c2godkEuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGdlb20udmVydGljZXMucHVzaCh2Qi5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbS52ZXJ0aWNlcy5wdXNoKHZDLmNsb25lKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnZW9tLnZlcnRpY2VzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJpYW5nbGVzT25TYW1lRmFjZShnZW9tLCBmYWNlLCByZWFkVmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZCB0cmlhbmdsZXMgb24gdGhlIHNhbWUgZmFjZSB3aXRoIHRoZSB0cmlhbmdsZSBpbnRlcnNlY3RlZCB3aXRoIHRoZSBjYXN0IHJheVxuICAgICAqXG4gICAgICogQHBhcmFtIGdlb20gLUdlb21ldHJ5IHdoaWNoIGluY2x1ZGVzIGFsbCB0aGUgdHJpYW5nbGVzIG9uIHRoZSBzYW1lIHBsYW5lLlxuICAgICAqIEBwYXJhbSBmYWNlIC1UcmlhbmdsZSB3aGljaCBpbnRlcnNlY3RzIHdpdGggdGhlIGNhc3QgcmF5LlxuICAgICAqIEBwYXJhbSByZWFkVmVydGV4Q0IgLUFjY2Vzc29yIGZ1bmN0aW9uIHRvIHJlYWQgdmVydGV4IGRhdGEgKHNlZSBtYWtlUmVhZFZlcnRleEZ1bmMpXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZ2V0VHJpYW5nbGVzT25TYW1lRmFjZSA9IGZ1bmN0aW9uKGdlb20sIGZhY2UsIHJlYWRWZXJ0ZXhDQikge1xuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IGdlb20udmVydGljZXM7XG5cbiAgICAgICAgY29uc3QgZmFjZVZlcnRleDEgPSByZWFkVmVydGV4Q0IoZmFjZS5hKTtcbiAgICAgICAgY29uc3QgZmFjZVZlcnRleDIgPSByZWFkVmVydGV4Q0IoZmFjZS5iKTtcbiAgICAgICAgY29uc3QgZmFjZVZlcnRleDMgPSByZWFkVmVydGV4Q0IoZmFjZS5jKTtcblxuICAgICAgICBjb25zdCBpbnRlcnNlY3RGYWNlID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbiAgICAgICAgY29uc3QgcHJlY2lzaW9uUG9pbnRzID0gNTsgLy8gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCBlZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcblxuICAgICAgICAvLyBCdWlsZCB0cmlhbmdsZSBsaXN0XG4gICAgICAgIC8vIEVhY2ggdHJpYW5nbGUgd2lsbCBjb250YWluIGEgbGlzdCBvZiBpdHMgMyBlZGdlc1xuICAgICAgICAvLyBBbHNvIG1haW50YWluIGFuIGVkZ2UgbWFwLCBwb2ludGluZyB0byB0aGUgdHJpYW5nbGVzIGluZGljZXMgdGhhdCBjb250YWluIGl0XG4gICAgICAgIGNvbnN0IHRyaWFuZ2xlc0FyciA9IFtdO1xuICAgICAgICBjb25zdCBlZGdlc01hcCA9IHt9O1xuICAgICAgICBsZXQgZmlyc3RUcmlhbmdsZSA9IC0xOyAvLyBXaWxsIHBvaW50IHRvIGluZGV4IG9mIHBhc3NlZCBmYWNlIHBhcmFtZXRlclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAvLyBmb3IgZWFjaCB0cmlhbmdsZVxuICAgICAgICAgICAgY29uc3QgdkEgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHZCID0gdmVydGljZXNbaSArIDFdO1xuICAgICAgICAgICAgY29uc3QgdkMgPSB2ZXJ0aWNlc1tpICsgMl07XG5cbiAgICAgICAgICAgIGlmIChmaXJzdFRyaWFuZ2xlIDwgMCAmJiBmYWNlVmVydGV4MS5lcXVhbHModkEpICYmIGZhY2VWZXJ0ZXgyLmVxdWFscyh2QikgJiYgZmFjZVZlcnRleDMuZXF1YWxzKHZDKSkge1xuICAgICAgICAgICAgICAgIGZpcnN0VHJpYW5nbGUgPSBpIC8gMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IFtcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHZBLnggKiBwcmVjaXNpb24pICsgJ18nICsgTWF0aC5yb3VuZCh2QS55ICogcHJlY2lzaW9uKSArICdfJyArIE1hdGgucm91bmQodkEueiAqIHByZWNpc2lvbiksXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCh2Qi54ICogcHJlY2lzaW9uKSArICdfJyArIE1hdGgucm91bmQodkIueSAqIHByZWNpc2lvbikgKyAnXycgKyBNYXRoLnJvdW5kKHZCLnogKiBwcmVjaXNpb24pLFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQodkMueCAqIHByZWNpc2lvbikgKyAnXycgKyBNYXRoLnJvdW5kKHZDLnkgKiBwcmVjaXNpb24pICsgJ18nICsgTWF0aC5yb3VuZCh2Qy56ICogcHJlY2lzaW9uKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHRyaWFuZ2xlID0geyBlZGdlczogW10gfTtcblxuICAgICAgICAgICAgLy8gRWRnZSBtYXAgdXBkYXRlXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleTEgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleTIgPSBrZXlzWyhqICsgMSkgJSAzXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFZGdlID0ga2V5MSArICdfJyArIGtleTI7XG4gICAgICAgICAgICAgICAgbGV0IGVkZ2UgPSBlZGdlc01hcFtkZWZhdWx0RWRnZV0gfHwgZWRnZXNNYXBba2V5MiArICdfJyArIGtleTFdO1xuICAgICAgICAgICAgICAgIGlmICghZWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGVkZ2UgaGFzbid0IGJlZW4gYWRkZWQgYmVmb3JlLCBhZGQgaXQgbm93XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UgPSBlZGdlc01hcFtkZWZhdWx0RWRnZV0gPSB7IHRyaWFuZ2xlczogW10gfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgZWRnZSB0byBjdXJyZW50IHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgdHJpYW5nbGUuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgY3VycmVudCB0cmlhbmdsZSB0byBlZGdlXG4gICAgICAgICAgICAgICAgZWRnZS50cmlhbmdsZXMucHVzaChpIC8gMyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlc0Fyci5wdXNoKHRyaWFuZ2xlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaXJzdFRyaWFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCRlMgc2VhcmNoIGZvciBuZWlnaGJvdXJpbmcgdHJpYW5nbGVzXG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW2ZpcnN0VHJpYW5nbGVdO1xuICAgICAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBjb25uZWN0ZWRGYWNlcyA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RmFjZSA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIGlmICh2aXNpdGVkLmhhcyhjdXJyZW50RmFjZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlzaXRlZC5hZGQoY3VycmVudEZhY2UpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhpcyBmYWNlIHRvIHRoZSBsaXN0IG9mIGNvbm5lY3RlZCBmYWNlc1xuICAgICAgICAgICAgY29ubmVjdGVkRmFjZXMucHVzaChjdXJyZW50RmFjZSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhbGwgbmVpZ2hib3JpbmcgZmFjZXMgdG8gdGhlIHF1ZXVlXG4gICAgICAgICAgICBjb25zdCB0cmlhbmdsZSA9IHRyaWFuZ2xlc0FycltjdXJyZW50RmFjZV07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdHJpYW5nbGUuZWRnZXMpIHtcbiAgICAgICAgICAgICAgICBlZGdlLnRyaWFuZ2xlcy5mb3JFYWNoKHQgPT4gdCAhPT0gY3VycmVudEZhY2UgJiYgcXVldWUucHVzaCh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb3B5IHJlc3VsdHMgb2YgdGhlIGFjdHVhbCB2ZXJ0aWNlcyBpbiB0aGUgY29ubmVjdGVkIGZhY2VzXG4gICAgICAgIC8vIFNpbmNlIHZlcnRpY2VzIGFyZSBhbHJlYWR5IGNsb25lZCBpbiBmYWNlU25hcHBpbmcsIHRoZXJlJ3Mgbm8gbmVlZCB0byBjbG9uZSB0aGVtIGFnYWluXG4gICAgICAgIGNvbnN0IGZpbmFsVmVydGljZXMgPSBbXTtcbiAgICAgICAgbGV0IHZJbmRleCA9IDA7XG4gICAgICAgIGNvbm5lY3RlZEZhY2VzLmZvckVhY2goZmFjZUlkeCA9PiB7XG4gICAgICAgICAgICBpbnRlcnNlY3RGYWNlLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKHZJbmRleCsrLCB2SW5kZXgrKywgdkluZGV4KyspKTtcbiAgICAgICAgICAgIGZpbmFsVmVydGljZXMucHVzaCh2ZXJ0aWNlc1tmYWNlSWR4ICogM10pO1xuICAgICAgICAgICAgZmluYWxWZXJ0aWNlcy5wdXNoKHZlcnRpY2VzW2ZhY2VJZHggKiAzICsgMV0pO1xuICAgICAgICAgICAgZmluYWxWZXJ0aWNlcy5wdXNoKHZlcnRpY2VzW2ZhY2VJZHggKiAzICsgMl0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpbnRlcnNlY3RGYWNlLnZlcnRpY2VzID0gZmluYWxWZXJ0aWNlcztcblxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0RmFjZTtcbiAgICB9O1xuXG4gICAgdGhpcy5lZGdlU25hcHBpbmdXaXRoVG9wb2xvZ3kgPSBmdW5jdGlvbihpbnRlcnNlY3RQb2ludCwgZ2VvbWV0cnksIGVkZ2VzVG9wb2xvZ3ksIHttYXRyaXhXb3JsZH0pIHtcblxuICAgICAgICBjb25zdCBlZGdlR2VvbSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpOyAvL0dlb21ldHJ5IHdoaWNoIGluY2x1ZGVzIGFsbCB0aGUgdHJpYW5nbGVzIG9uIHRoZSBzYW1lIHBsYW5lLlxuICAgICAgICB2YXIgbWluRGlzdFRvcG9JbmRleDtcbiAgICAgICAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgIHZhciB2QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZhciB2QiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4ICE9PSB1bmRlZmluZWQgJiYgZWRnZXNUb3BvbG9neSAhPSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgY29uc3QgcmVhZFZlcnRleCA9IHRoaXMubWFrZVJlYWRWZXJ0ZXhGdW5jKGdlb21ldHJ5KTtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIGVkZ2UgdG9wb2xvZ3kgbGlzdCB3aGljaCBpbmNsdWRlcyB0aGUgbmVhcmVzdCBlZGdlIHNlZ21lbnQgdG8gdGhlIGludGVyc2VjdCBwb2ludFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlc1RvcG9sb2d5Lmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhMaXN0ID0gZWRnZXNUb3BvbG9neVtpXS5pbmRleExpc3Q7XG4gICAgICAgICAgICAgICAgLy8gSW4gZWRnZXMgdG9wb2xvZ3kgaW5kZXggbGlzdCB0aGUgdHlwZSBpcyBMaW5lU3RyaXBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluZGV4TGlzdC5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZFZlcnRleChpbmRleExpc3Rbal0sIHZBKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZFZlcnRleChpbmRleExpc3RbaiArIDFdLCB2Qik7XG5cbiAgICAgICAgICAgICAgICAgICAgdkEuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcbiAgICAgICAgICAgICAgICAgICAgdkIuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGRpc3RhbmNlUG9pbnRUb0xpbmUoaW50ZXJzZWN0UG9pbnQsIHZBLCB2Qik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5EaXN0VG9wb0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pbkRpc3RUb3BvSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpbmRleExpc3QgPSBlZGdlc1RvcG9sb2d5W21pbkRpc3RUb3BvSW5kZXhdLmluZGV4TGlzdDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGluZGV4TGlzdC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdkswID0gcmVhZFZlcnRleChpbmRleExpc3Rba10pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2SzEgPSByZWFkVmVydGV4KGluZGV4TGlzdFtrICsgMV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VHZW9tLnZlcnRpY2VzLnB1c2godkswKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gbWFrZSB0aGUgbGluZSdzIHR5cGUgdG8gTGluZVBpZWNlcyB3aGljaCBpcyB1c2VkIGJ5IGRyYXdMaW5lIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VHZW9tLnZlcnRpY2VzLnB1c2godksxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2Rpc3RhbmNlVG9FZGdlID49IG1pbkRpc3QgJiYgZWRnZUdlb20udmVydGljZXMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBfZGlzdGFuY2VUb0VkZ2UgPSBtaW5EaXN0O1xuICAgICAgICAgICAgZWRnZUdlb20uYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcbiAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21FZGdlID0gZWRnZUdlb207XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IEVkZ2UgZ2VvbWV0cnkgZm9yIHRoZSBjYXNlIHRoYXQgdGhlIGhpdHRlc3QgcmVzdWx0IGNvbnRhaW5lZCBhIDNEIGxpbmVzLiBGb3IgdGhpcyBjYXNlLCB3ZSBoYXZlIG5vIEZhY2UzLCBzb1xuICAgICAqIHRoYXQgZmFjZVNuYXBwaW5nIGFuZCBlZGdlU25hcHBpbmcgZG9uJ3Qgd29yay5cbiAgICAgKlxuICAgICAqICBAcGFyYW0ge09iamVjdH0gICAgICAgICBlZGdlICAgICAtIHthLCBifSB3aXRoIHZlcnRleCBpbmRpY2VzIGEsYiBvZiBsaW5lU3RhcnQvbGluZUVuZCB2ZXJ0ZXhcbiAgICAgKiAgQHBhcmFtIHtHZW9tZXRyeUJ1ZmZlcn0gZ2VvbWV0cnlcbiAgICAgKiAgQHJldHVybnMge1RIUkVFLkdlb21ldHJ5fFRIUkVFLkJ1ZmZlckdlb21ldHJ5fSBHZW9tZXRyeSB3aXRoIHNpbXBsZSBsaW5lXG4gICAgICovXG4gICAgdGhpcy5leHRyYWN0TGluZUdlb21ldHJ5ID0gZnVuY3Rpb24oZWRnZSwgZ2VvbWV0cnkpIHtcblxuICAgICAgICBjb25zdCByZWFkVmVydGV4ID0gdGhpcy5tYWtlUmVhZFZlcnRleEZ1bmMoZ2VvbWV0cnkpO1xuICAgICAgICBjb25zdCB2YSA9IHJlYWRWZXJ0ZXgoZWRnZS5hKTtcbiAgICAgICAgY29uc3QgdmIgPSByZWFkVmVydGV4KGVkZ2UuYik7XG5cbiAgICAgICAgY29uc3QgZWRnZUdlb20gPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICAgICAgZWRnZUdlb20udmVydGljZXMucHVzaCh2YSwgdmIpO1xuICAgICAgICByZXR1cm4gZWRnZUdlb207XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNsb3Nlc3QgZWRnZSBuZXh0IHRvIHRoZSBpbnRlcnNlY3QgcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmYWNlIC1GYWNlIHdoaWNoIGlzIGZvdW5kIGJ5IGZhY2VTbmFwcGluZy5cbiAgICAgKiBAcGFyYW0gaW50ZXJzZWN0UG9pbnQgLUludGVyc2VjdFBvaW50IGJldHdlZW4gY2FzdCByYXkgYW5kIGZhY2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZWRnZVNuYXBwaW5nID0gZnVuY3Rpb24oZmFjZSwgaW50ZXJzZWN0UG9pbnQpIHtcblxuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICBjb25zdCB2ZXJ0aWNlc0xlbmd0aCA9IGZhY2UudmVydGljZXMubGVuZ3RoO1xuICAgICAgICB2YXIgaXNFZGdlXzEyID0gdHJ1ZTtcbiAgICAgICAgdmFyIGlzRWRnZV8xMyA9IHRydWU7XG4gICAgICAgIHZhciBpc0VkZ2VfMjMgPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXNMZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgY29uc3QgcGkwID0gZmFjZS52ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHBpMSA9IGZhY2UudmVydGljZXNbaSArIDFdO1xuICAgICAgICAgICAgY29uc3QgcGkyID0gZmFjZS52ZXJ0aWNlc1tpICsgMl07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmVydGljZXNMZW5ndGg7IGogKz0gMykge1xuICAgICAgICAgICAgICAgIGlmICggaSAhPT0gaiApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGowID0gZmFjZS52ZXJ0aWNlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGoxID0gZmFjZS52ZXJ0aWNlc1tqICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBqMiA9IGZhY2UudmVydGljZXNbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBlZGdlIDEyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocGkwLmVxdWFscyhwajApIHx8IHBpMC5lcXVhbHMocGoxKSB8fCBwaTAuZXF1YWxzKHBqMikpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAocGkxLmVxdWFscyhwajApIHx8IHBpMS5lcXVhbHMocGoxKSB8fCBwaTEuZXF1YWxzKHBqMikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VkZ2VfMTIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBlZGdlIDEzXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGVkZ2UgMTJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwaTAuZXF1YWxzKHBqMCkgfHwgcGkwLmVxdWFscyhwajEpIHx8IHBpMC5lcXVhbHMocGoyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChwaTIuZXF1YWxzKHBqMCkgfHwgcGkyLmVxdWFscyhwajEpIHx8IHBpMi5lcXVhbHMocGoyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRWRnZV8xMyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGVkZ2UgMjNcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWRnZSAxMlxuICAgICAgICAgICAgICAgICAgICBpZiAoKHBpMS5lcXVhbHMocGowKSB8fCBwaTEuZXF1YWxzKHBqMSkgfHwgcGkxLmVxdWFscyhwajIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHBpMi5lcXVhbHMocGowKSB8fCBwaTIuZXF1YWxzKHBqMSkgfHwgcGkyLmVxdWFscyhwajIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNFZGdlXzIzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0VkZ2VfMTIpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBpMC5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBpMS5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VkZ2VfMTMpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBpMC5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBpMi5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0VkZ2VfMjMpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBpMS5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHBpMi5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXNFZGdlXzEyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlzRWRnZV8xMyA9IHRydWU7XG4gICAgICAgICAgICBpc0VkZ2VfMjMgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvL3JldHVybiBsaW5lR2VvbTtcblxuICAgICAgICBjb25zdCBlZGdlVmVydGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZWRnZUdlb20gPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICAgICAgdmFyIG1pbkRpc3RJbmRleDtcbiAgICAgICAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdmVydGljZXMubGVuZ3RoOyBrICs9IDIpIHtcblxuICAgICAgICAgICAgdmFyIGRpc3QgPSBkaXN0YW5jZVBvaW50VG9MaW5lKGludGVyc2VjdFBvaW50LCB2ZXJ0aWNlc1trXSwgdmVydGljZXNbayArIDFdKTtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgbWluRGlzdEluZGV4ID0gaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZWRnZVZlcnRpY2VzLnB1c2godmVydGljZXNbIG1pbkRpc3RJbmRleCBdLmNsb25lKCkpO1xuICAgICAgICBlZGdlVmVydGljZXMucHVzaCh2ZXJ0aWNlc1sgbWluRGlzdEluZGV4ICsgMSBdLmNsb25lKCkpO1xuXG4gICAgICAgIGNvbnN0IGxpbmVHZW9tID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgICAgIGxpbmVHZW9tLnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgICAgIGVkZ2VHZW9tLnZlcnRpY2VzID0gdGhpcy5nZXRDb25uZWN0ZWRMaW5lU2VnbWVudHNPblNhbWVMaW5lKGxpbmVHZW9tLCBlZGdlVmVydGljZXMpO1xuXG4gICAgICAgIF9kaXN0YW5jZVRvRWRnZSA9IG1pbkRpc3Q7XG5cbiAgICAgICAgcmV0dXJuIGVkZ2VHZW9tO1xuICAgIH07XG5cbiAgICB0aGlzLmdldENvbm5lY3RlZExpbmVTZWdtZW50c09uU2FtZUxpbmUgPSBmdW5jdGlvbihsaW5lR2VvbSwgZWRnZVZlcnRpY2VzKSB7XG5cbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBsaW5lR2VvbS52ZXJ0aWNlcy5zbGljZSgpO1xuICAgICAgICB2YXIgdmEgPSBlZGdlVmVydGljZXNbMF07XG4gICAgICAgIHZhciB2YiA9IGVkZ2VWZXJ0aWNlc1sxXTtcblxuICAgICAgICB2YXIgdkNvdW50ID0gW107XG5cbiAgICAgICAgZG8ge1xuXG4gICAgICAgICAgICB2Q291bnQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2ZXJ0aWNlcy5sZW5ndGg7IGogKz0gMikge1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGxpbmUgd2hpY2ggaGFzIG1pbiBkaXN0YW5jZSB0byBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgICAgICAgICBpZiAodmVydGljZXNbal0uZXF1YWxzKHZhKSAmJiB2ZXJ0aWNlc1tqICsgMV0uZXF1YWxzKHZiKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZWRnZVZlcnRpY2VzLmxlbmd0aDsgayArPSAyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGxpbmUgc2VnbWVudHMgd2hpY2ggYXJlIGNvbm5lY3RlZCBvbiB0aGUgc2FtZSBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1tqXS5lcXVhbHMoZWRnZVZlcnRpY2VzW2tdKSB8fCB2ZXJ0aWNlc1tqICsgMV0uZXF1YWxzKGVkZ2VWZXJ0aWNlc1trXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzW2pdLmVxdWFscyhlZGdlVmVydGljZXNbayArIDFdKSB8fCB2ZXJ0aWNlc1tqICsgMV0uZXF1YWxzKGVkZ2VWZXJ0aWNlc1trICsgMV0pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBWMCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgVjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBWMC5zdWJWZWN0b3JzKGVkZ2VWZXJ0aWNlc1trXSwgIGVkZ2VWZXJ0aWNlc1trICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgVjAubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBWMS5zdWJWZWN0b3JzKHZlcnRpY2VzW2pdLHZlcnRpY2VzW2ogKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBWMS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoVjAuZXF1YWxzKFYxKSB8fCBWMC5lcXVhbHMoVjEubmVnYXRlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcXVhbFZlY3RvcnNXaXRoUHJlY2lzaW9uKFYwLCBWMSkgfHwgaXNJbnZlcnNlVmVjdG9yc1dpdGhQcmVjaXNpb24oVjAsIFYxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZDb3VudC5wdXNoKGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGNpID0gdkNvdW50Lmxlbmd0aCAtIDE7IGNpID49IDA7IC0tY2kpIHtcblxuICAgICAgICAgICAgICAgIGVkZ2VWZXJ0aWNlcy5wdXNoKHZlcnRpY2VzWyB2Q291bnRbY2ldIF0pO1xuICAgICAgICAgICAgICAgIGVkZ2VWZXJ0aWNlcy5wdXNoKHZlcnRpY2VzWyB2Q291bnRbY2ldICsgMSBdKTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5zcGxpY2UodkNvdW50W2NpXSwgMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSB3aGlsZSAodkNvdW50Lmxlbmd0aCA+IDApO1xuXG4gICAgICAgIHJldHVybiBlZGdlVmVydGljZXM7XG5cbiAgICB9O1xuXG4gICAgdGhpcy52ZXJ0ZXhTbmFwcGluZ1dpdGhUb3BvbG9neSA9IGZ1bmN0aW9uKGVkZ2UsIGludGVyc2VjdFBvaW50KSB7XG5cbiAgICAgICAgdmFyIG1pbkRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICB2YXIgcG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGdlLnZlcnRpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZWRnZS52ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGVkZ2UudmVydGljZXNbZWRnZS52ZXJ0aWNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBkaXN0MSA9IGludGVyc2VjdFBvaW50LmRpc3RhbmNlVG8oc3RhcnQpO1xuICAgICAgICAgICAgdmFyIGRpc3QyID0gaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhlbmQpO1xuXG4gICAgICAgICAgICBpZiAoZGlzdDEgPD0gZGlzdDIpIHtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDE7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBzdGFydC5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWluRGlzdCA9IGRpc3QyO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gZW5kLmNsb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZGlzdGFuY2VUb1ZlcnRleCA9IG1pbkRpc3Q7XG5cbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBjbG9zZXN0IHZlcnRleCBuZXh0IHRvIHRoZSBpbnRlcnNlY3QgcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGdlIC1FZGdlIHdoaWNoIGlzIGZvdW5kIGJ5IGVkZ2VTbmFwcGluZy5cbiAgICAgKiBAcGFyYW0gaW50ZXJzZWN0UG9pbnQgLUludGVyc2VjdFBvaW50IGJldHdlZW4gY2FzdCByYXkgYW5kIGZhY2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4U25hcHBpbmcgPSBmdW5jdGlvbihlZGdlLCBpbnRlcnNlY3RQb2ludCkge1xuXG4gICAgICAgIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIHBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgY29uc3QgdmVydGljZXNMZW5ndGggPSBlZGdlLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHB0ID0gZWRnZS52ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVRvKHB0KTtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0IC0gU05BUF9QUkVDSVNJT04pIHtcblxuICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcHQuY2xvbmUoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2Rpc3RhbmNlVG9WZXJ0ZXggPSBtaW5EaXN0O1xuXG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBpcyBvbmx5IGEgd29ya2Fyb3VuZCB0byBkZXRlY3QgaWYgYW4gZWRnZSBpcyBjaXJjbGVcbiAgICB0aGlzLmVkZ2VJc0NpcmNsZSA9IGZ1bmN0aW9uKGVkZ2UpIHtcblxuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IGVkZ2UudmVydGljZXM7XG5cbiAgICAgICAgLy8gRXhjbHVkZSBzcXVhcmVzIGFuZCByZWd1bGFyIHBvbHlnb25zXG4gICAgICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydCA9IHZlcnRpY2VzWzBdO1xuICAgICAgICBjb25zdCBlbmQgPSB2ZXJ0aWNlc1t2ZXJ0aWNlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoc3RhcnQuZXF1YWxzKGVuZCkpIHtcblxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGNlbnRlci5hZGQodmVydGljZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VudGVyLmRpdmlkZVNjYWxhcih2ZXJ0aWNlcy5sZW5ndGggLyAyLjApO1xuXG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gY2VudGVyLmRpc3RhbmNlVG8oc3RhcnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjZW50ZXIuZGlzdGFuY2VUbyh2ZXJ0aWNlc1tpXSkgLSByYWRpdXMpIDw9IFNOQVBfUFJFQ0lTSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5lZGdlSXNDdXJ2ZWQgPSBmdW5jdGlvbiAoZWRnZSkge1xuXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gZWRnZS52ZXJ0aWNlcztcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB2ZXJ0aWNlc1swXTtcbiAgICAgICAgY29uc3QgZW5kID0gdmVydGljZXNbdmVydGljZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnQuZXF1YWxzKGVuZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIFYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIGxldCBwaTA7XG4gICAgICAgICAgICBsZXQgcGkxID0gdmVydGljZXNbMV07XG5cbiAgICAgICAgICAgIFYxLnN1YlZlY3RvcnMoc3RhcnQsIHBpMSk7XG5cbiAgICAgICAgICAgIHZhciBWMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgcGkwID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICAgICAgcGkxID0gdmVydGljZXNbaSArIGldO1xuICAgICAgICAgICAgICAgIFYyLnN1YlZlY3RvcnMocGkwLCBwaTEpO1xuICAgICAgICAgICAgICAgIGlmICghaXNFcXVhbFZlY3RvcnNXaXRoUHJlY2lzaW9uKFYxLCBWMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBnZW9tZXRyeSBpcyBjdXJ2ZWRcbiAgICAgKiBAcGFyYW0ge1RIUkVFLkJ1ZmZlckdlb21ldHJ5fSBmYWNlIFRoZSBnZW9tZXRyeVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBhbnkgb2YgdGhlIGZhY2VzIGNvbXBvc2luZyB0aGUgZ2VvbWV0cnkgaXMgY3VydmVkXG4gICAgICovXG4gICAgdGhpcy5mYWNlSXNDdXJ2ZWQgPSBmdW5jdGlvbiAoZmFjZSkge1xuXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gZmFjZS52ZXJ0aWNlcztcbiAgICAgICAgY29uc3QgZmFjZXMgPSBmYWNlLmZhY2VzO1xuXG4gICAgICAgIGlmIChmYWNlcy5sZW5ndGggPD0gMSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICB2YXIgZk4xID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgY29uc3QgdkExID0gdmVydGljZXNbZmFjZXNbMF0uYV07XG4gICAgICAgIFRIUkVFLlRyaWFuZ2xlLmdldE5vcm1hbCh2ZXJ0aWNlc1tmYWNlc1swXS5hXSwgdmVydGljZXNbZmFjZXNbMF0uYl0sIHZlcnRpY2VzW2ZhY2VzWzBdLmNdLCBmTjEpO1xuXG4gICAgICAgIHZhciBmTjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGZhY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2QTIgPSB2ZXJ0aWNlc1tmYWNlc1tpXS5hXTtcbiAgICAgICAgICAgIFRIUkVFLlRyaWFuZ2xlLmdldE5vcm1hbCh2ZXJ0aWNlc1tmYWNlc1tpXS5hXSwgdmVydGljZXNbZmFjZXNbaV0uYl0sIHZlcnRpY2VzW2ZhY2VzW2ldLmNdLCBmTjIpO1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsVmVjdG9yc1dpdGhQcmVjaXNpb24oZk4xLCBmTjIpIHx8ICFpc0VxdWFsV2l0aFByZWNpc2lvbihmTjEuZG90KHZBMSksIGZOMi5kb3QodkEyKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5hbmdsZVZlY3RvcjIgPSBmdW5jdGlvbih2ZWN0b3IpIHtcblxuICAgICAgICBpZiAodmVjdG9yLnggPiAwICYmIHZlY3Rvci55ID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4odmVjdG9yLnkgLyB2ZWN0b3IueCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmVjdG9yLnggPj0gMCAmJiB2ZWN0b3IueSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4odmVjdG9yLnkgLyB2ZWN0b3IueCkgKyBNYXRoLlBJICogMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ZWN0b3IueCA8IDAgJiYgdmVjdG9yLnkgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYXRhbih2ZWN0b3IueSAvIHZlY3Rvci54KSArIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmVjdG9yLnggPD0gMCAmJiB2ZWN0b3IueSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4odmVjdG9yLnkgLyB2ZWN0b3IueCkgKyBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7IC8vIHggPSAwLCB5ID0gMFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ3JlYXRlcyBhIFRIUkVFLkdlb21ldHJ5IHRoYXQgcmVwcmVzZW50cyBhbiBhcHByb3hpbWF0aW9uIG9mIGEgZ2l2ZW4gZWxsaXB0aWNhbCBhcmMgaW4ge3o9MH0gcGxhbmUuXG4gICAgLy8gUG9pbnRzIGFyZSBvYnRhaW5lZCBieSBieSB1bmlmb3JtIHNhbXBsaW5nIG9mIGEgZ2l2ZW4gZWxsaXB0aWNhbCBhcmMuXG4gICAgLy8gIEBwYXJhbSB7bnVtYmVyfSBudW1Qb2ludHMgLSBUaGUgbGVuZ3RoIG51bWJlciBvZiBwb2ludHMgdGhhdCB0aGUgb3V0cHV0IGdlb21ldHJ5IHdpbGwgY29udGFpbi4gc2VnbWVudHMgaW4gd2hpY2ggd2Ugc3ViZGl2aWRlIHRoZSBhcmMuIFJlc3VsdGluZyBwb2ludCBjb3VudCBpcyBudW1TZWdtZW50cysxLlxuICAgIC8vIFNlZSBnZXRFbGxpcHNlQXJjUG9pbnQoKSBmb3IgcGFyYW0gZGV0YWlscy5cbiAgICBjb25zdCBjcmVhdGVFbGxpcHRpY2FsQXJjR2VvbWV0cnkgPSAoY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBudW1Qb2ludHMpID0+IHtcbiAgICAgICAgbGV0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxudW1Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsMCwwKTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBpLyhudW1Qb2ludHMtMSk7XG4gICAgICAgICAgICBBdXRvZGVzay5FeHRlbnNpb25zLkNvbXBHZW9tLmdldEVsbGlwc2VBcmNQb2ludCh0LCBjeCwgY3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIDAuMCwgcCk7XG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtWaWV3ZXIzRH0gdmlld2VyIC0gVmlld2VyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHNuYXBwZXJcbiAgICAgKiBAcGFyYW0gYURldGVjdFJhZGl1c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gR2VvbWV0cnlDYWxsYmFjayh2aWV3ZXIsIHNuYXBwZXIsIGFEZXRlY3RSYWRpdXMpIHtcbiAgICAgICAgdGhpcy52aWV3ZXIgPSB2aWV3ZXI7XG4gICAgICAgIHRoaXMuc25hcHBlciA9IHNuYXBwZXI7XG5cbiAgICAgICAgdGhpcy5saW5lR2VvbSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgICAgICB0aGlzLmNpcmN1bGFyQXJjID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaXJjdWxhckFyY0NlbnRlcjtcbiAgICAgICAgdGhpcy5jaXJjdWxhckFyY1JhZGl1cztcbiAgICAgICAgdGhpcy5lbGxpcHRpY2FsQXJjID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbGxpcHRpY2FsQXJjQ2VudGVyO1xuXG4gICAgICAgIHRoaXMubWluRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgdGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICAgIHRoaXMudnBJZExpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLnZwSWRDaXJjdWxhciA9IG51bGw7XG4gICAgICAgIHRoaXMudnBJZEVsbGlwdGljYWwgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZGV0ZWN0UmFkaXVzID0gYURldGVjdFJhZGl1cztcblxuICAgICAgICAvLyBDb2xsZWN0cyBjYW5kaWRhdGUgc2VnbWVudHMgdGhhdCB3ZSBjYW4gc25hcCB0by5cbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIGFsbG93IHNuYXBwaW5nIHRvIHNlZ21lbnQgaW50ZXJzZWN0aW9ucy5cbiAgICAgICAgdGhpcy5zbmFwQ2FuZGlkYXRlcyA9IFtdOyAvLyB7U25hcHBpbmdDYW5kaWRhdGVbXX1cbiAgICB9XG5cbiAgICBHZW9tZXRyeUNhbGxiYWNrLnByb3RvdHlwZS5vbkxpbmVTZWdtZW50ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHZwSWQpIHtcbiAgICAgICAgdmFyIGludGVyc2VjdFBvaW50ID0gdGhpcy5zbmFwcGVyLmdldEludGVyc2VjdFBvaW50KCk7XG4gICAgICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKHgxLCB5MSwgaW50ZXJzZWN0UG9pbnQueik7XG4gICAgICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKHgyLCB5MiwgaW50ZXJzZWN0UG9pbnQueik7XG5cbiAgICAgICAgLy8gTE1WLTU1MTU6IEFwcGx5IHRoZSBzdXBwbGllZCBtYXRyaXggdG8gdGhlIGxpbmUgdmVjdG9yJ3NcbiAgICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgICAgICB2MS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXgpO1xuICAgICAgICAgICAgdjIuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNraXAgc2VnbWVudHMgb3V0c2lkZSBkZXRlY3RSYWRpdXNcbiAgICAgICAgdmFyIGRpc3QgPSBkaXN0YW5jZVBvaW50VG9MaW5lKGludGVyc2VjdFBvaW50LCB2MSwgdjIpO1xuICAgICAgICBpZiAoZGlzdCA+IHRoaXMuZGV0ZWN0UmFkaXVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2xsZWN0IHNuYXAgY2FuZGlkYXRlXG4gICAgICAgIHRoaXMuc25hcENhbmRpZGF0ZXMucHVzaChuZXcgU25hcENhbmRpZGF0ZSh2cElkLCBkaXN0KS5mcm9tTGluZSh2MSwgdjIpKTtcblxuICAgICAgICAvLyBUcmFjayBtaW5EaXN0IGFuZCBsaW5lR2VvbWV0cnkgZm9yIGJlc3QgaGl0IHNvIGZhclxuICAgICAgICBpZiAoZGlzdCA8IHRoaXMubWluRGlzdCkge1xuICAgICAgICAgICAgdGhpcy5saW5lR2VvbS52ZXJ0aWNlcy5zcGxpY2UoMCwgMiwgdjEsIHYyKTtcbiAgICAgICAgICAgIHRoaXMubWluRGlzdCA9IGRpc3Q7XG5cbiAgICAgICAgICAgIHRoaXMudnBJZExpbmUgPSB2cElkO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEdlb21ldHJ5Q2FsbGJhY2sucHJvdG90eXBlLm9uQ2lyY3VsYXJBcmMgPSBmdW5jdGlvbihjeCwgY3ksIHN0YXJ0LCBlbmQsIHJhZGl1cywgdnBJZCkge1xuICAgICAgICB2YXIgaW50ZXJzZWN0UG9pbnQgPSB0aGlzLnNuYXBwZXIuZ2V0SW50ZXJzZWN0UG9pbnQoKTtcbiAgICAgICAgdmFyIHBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoaW50ZXJzZWN0UG9pbnQueCwgaW50ZXJzZWN0UG9pbnQueSk7XG5cbiAgICAgICAgdmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IyKGN4LCBjeSk7XG4gICAgICAgIHBvaW50LnN1YihjZW50ZXIpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgY2xvc2VzdCBwb2ludCBvbiBhcmNcbiAgICAgICAgY29uc3QgcG9pbnRPbkFyYyA9IG5lYXJlc3RQb2ludE9uQ2lyY3VsYXJBcmMoaW50ZXJzZWN0UG9pbnQsIGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kKTtcbiAgICAgICAgY29uc3QgZGlzdCAgICAgICA9IHBvaW50T25BcmMuZGlzdGFuY2VUbyhpbnRlcnNlY3RQb2ludCk7IC8vIDJEIGRpc3RhbmNlXG5cbiAgICAgICAgLy8gQ29sbGVjdCBzbmFwIGNhbmRpZGF0ZVxuICAgICAgICB0aGlzLnNuYXBDYW5kaWRhdGVzLnB1c2gobmV3IFNuYXBDYW5kaWRhdGUodnBJZCwgZGlzdCkuZnJvbUNpcmN1bGFyQXJjKGNlbnRlciwgcmFkaXVzLCBzdGFydCwgZW5kKSk7XG5cbiAgICAgICAgLy8gU2tpcCBhcmNzIG91dHNpZGUgZGV0ZWN0UmFkaXVzXG4gICAgICAgIGlmIChkaXN0ID4gdGhpcy5kZXRlY3RSYWRpdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGdldCByaWQgb2YgdGhlIENpcmNsZUdlb21ldHJ5IHN0dWZmIGJlbG93LCBiZWNhdXNlIHdlIGNvbXB1dGVkIHRoZSBzbmFwUG9pbnQgYWJvdmUgYWxyZWFkeS5cbiAgICAgICAgLy8gICAgICAgQnV0IHRoaXMgbmVlZHMgc29tZSByZWZhY3RvcmluZywgYmVjYXVzZSB0aGUgR2VvbWV0cnkgaXMgcGFzc2VkIGFyb3VuZCBvdXRzaWRlIG9mIHNuYXBwZXIuXG5cbiAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5zbmFwcGVyLmFuZ2xlVmVjdG9yMihwb2ludCk7XG5cbiAgICAgICAgbGV0IGFyYztcbiAgICAgICAgaWYgKGVuZCA+IHN0YXJ0ICYmIGFuZ2xlID49IHN0YXJ0ICYmIGFuZ2xlIDw9IGVuZCkge1xuICAgICAgICAgICAgYXJjID0gbmV3IFRIUkVFLkNpcmNsZUdlb21ldHJ5KHJhZGl1cywgMTAwLCBzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVuZCA8IHN0YXJ0ICYmIChhbmdsZSA+PSBzdGFydCB8fCBhbmdsZSA8PSBlbmQpKSB7XG4gICAgICAgICAgICBhcmMgPSBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkocmFkaXVzLCAxMDAsIHN0YXJ0LCBNYXRoLlBJICogMiAtIHN0YXJ0ICsgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyYy52ZXJ0aWNlcy5zcGxpY2UoMCwgMSk7XG5cbiAgICAgICAgYXJjLmFwcGx5TWF0cml4NChuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbihjeCwgY3ksIGludGVyc2VjdFBvaW50LnopKTtcbiAgICAgICAgdGhpcy5jaXJjdWxhckFyYyA9IGFyYztcbiAgICAgICAgdGhpcy5jaXJjdWxhckFyY0NlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKGN4LCBjeSwgaW50ZXJzZWN0UG9pbnQueik7XG4gICAgICAgIHRoaXMuY2lyY3VsYXJBcmNSYWRpdXMgPSByYWRpdXM7XG5cbiAgICAgICAgdGhpcy5zbmFwUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMyhwb2ludE9uQXJjLngsIHBvaW50T25BcmMueSwgaW50ZXJzZWN0UG9pbnQueik7XG5cbiAgICAgICAgdGhpcy52cElkQ2lyY3VsYXIgPSB2cElkO1xuICAgIH07XG5cbiAgICBHZW9tZXRyeUNhbGxiYWNrLnByb3RvdHlwZS5vbkVsbGlwdGljYWxBcmMgPSBmdW5jdGlvbihjeCwgY3ksIHN0YXJ0LCBlbmQsIG1ham9yLCBtaW5vciwgdGlsdCwgdnBJZCkge1xuICAgICAgICB2YXIgaW50ZXJzZWN0UG9pbnQgPSB0aGlzLnNuYXBwZXIuZ2V0SW50ZXJzZWN0UG9pbnQoKTtcbiAgICAgICAgdmFyIHBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoaW50ZXJzZWN0UG9pbnQueCwgaW50ZXJzZWN0UG9pbnQueSk7XG5cbiAgICAgICAgdmFyIG1ham9yMSA9IG1ham9yIC0gdGhpcy5kZXRlY3RSYWRpdXM7XG4gICAgICAgIHZhciBtaW5vcjEgPSBtaW5vciAtIHRoaXMuZGV0ZWN0UmFkaXVzO1xuICAgICAgICB2YXIgbWFqb3IyID0gbWFqb3IgKyB0aGlzLmRldGVjdFJhZGl1cztcbiAgICAgICAgdmFyIG1pbm9yMiA9IG1pbm9yICsgdGhpcy5kZXRlY3RSYWRpdXM7XG5cbiAgICAgICAgdmFyIGVxdWF0aW9uMSA9IChwb2ludC54IC0gY3gpICogKHBvaW50LnggLSBjeCkgLyAobWFqb3IxICogbWFqb3IxKSArIChwb2ludC55IC0gY3kpICogKHBvaW50LnkgLSBjeSkgLyAobWlub3IxICogbWlub3IxKTtcbiAgICAgICAgdmFyIGVxdWF0aW9uMiA9IChwb2ludC54IC0gY3gpICogKHBvaW50LnggLSBjeCkgLyAobWFqb3IyICogbWFqb3IyKSArIChwb2ludC55IC0gY3kpICogKHBvaW50LnkgLSBjeSkgLyAobWlub3IyICogbWlub3IyKTtcblxuICAgICAgICB2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoY3gsIGN5KTtcbiAgICAgICAgcG9pbnQuc3ViKGNlbnRlcik7XG4gICAgICAgIHBvaW50LnggKj0gbWlub3I7XG4gICAgICAgIHBvaW50LnkgKj0gbWFqb3I7XG4gICAgICAgIHZhciBhbmdsZSA9IHRoaXMuc25hcHBlci5hbmdsZVZlY3RvcjIocG9pbnQpO1xuXG4gICAgICAgIGlmIChlbmQgPiBNYXRoLlBJICogMikge1xuICAgICAgICAgICAgZW5kID0gTWF0aC5QSSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXF1YXRpb24xID49IDEgJiYgZXF1YXRpb24yIDw9IDEpIHtcblxuICAgICAgICAgICAgaWYgKChlbmQgPiBzdGFydCAmJiBhbmdsZSA+PSBzdGFydCAmJiBhbmdsZSA8PSBlbmQpIHx8IChlbmQgPCBzdGFydCAmJiAoYW5nbGUgPj0gc3RhcnQgfHwgYW5nbGUgPD0gZW5kKSkpe1xuICAgICAgICAgICAgICAgIHZhciBhcmMgPSBjcmVhdGVFbGxpcHRpY2FsQXJjR2VvbWV0cnkoY3gsIGN5LCBtYWpvciwgbWlub3IsIHN0YXJ0LCBlbmQsIDUwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxXaXRoUHJlY2lzaW9uKGVuZCAtIHN0YXJ0LCBNYXRoLlBJICogMikpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhcmMudmVydGljZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyYy5hcHBseU1hdHJpeDQobmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oMCwgMCwgaW50ZXJzZWN0UG9pbnQueikpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIGdlb21ldHJ5IGFuZCBzbmFwcGVkIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgc2FtZSB3YXkgaGVyZSBhcyBpbiBnZXRTbmFwUmVzdWx0UG9zaXRpb24oKS4gVGhpcyB3aWxsIGJlIHJlcGxhY2VkIGxhdGVyIGJ5IGEgbW9yZSBhY2N1cmF0ZSBzb2x1dGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBuZWFyZXN0UG9pbnQgPSBNZWFzdXJlQ29tbW9uLm5lYXJlc3RWZXJ0ZXhJblZlcnRleFRvRWRnZShpbnRlcnNlY3RQb2ludCwgYXJjKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0ID0gVEhSRUUuVmVjdG9yMi5wcm90b3R5cGUuZGlzdGFuY2VUby5jYWxsKG5lYXJlc3RQb2ludCwgaW50ZXJzZWN0UG9pbnQpOyAvLyBvbmx5IGluIHgveVxuXG4gICAgICAgICAgICAgICAgLy8gQ29sbGVjdCBzbmFwIGNhbmRpZGF0ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IyKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zbmFwQ2FuZGlkYXRlcy5wdXNoKG5ldyBTbmFwQ2FuZGlkYXRlKHZwSWQsIGRpc3QpLm1ha2VFbGxpcHRpY2FsQXJjKGNlbnRlciwgbWFqb3IsIG1pbm9yLCBzdGFydCwgZW5kKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUb2RvOiBVbmxpa2UgZm9yIGxpbmUtc2VnbWVudHMsIGFyY3MgYXJlIGN1cnJlbnRseSBjb2xsZWN0ZWQgYnkgXCJsYXN0IG9uZSB3aW5zXCIgcnVsZSBieSB0aGUgY29kZSBmb3Igc2luZ2xlLXNuYXBwaW5nLlxuICAgICAgICAgICAgICAgIC8vICAgICAgIFdlIHNob3VsZCBjb25zaWRlciB0aGUgZGlzdGFuY2UgaGVyZSBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgIHRoaXMuZWxsaXB0aWNhbEFyYyA9IGFyYztcbiAgICAgICAgICAgICAgICB0aGlzLmVsbGlwdGljYWxBcmNDZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMyhjeCwgY3ksIGludGVyc2VjdFBvaW50LnopO1xuXG4gICAgICAgICAgICAgICAgdGhpcy52cElkRWxsaXB0aWNhbCA9IHZwSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgbWF0cml4IHRvIGlkZW50aXR5IGlmIG1hdHJpeCBpcyBub3Qgc3VwcGxpZWQ7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RIUkVFLk1hdHJpeDR9IG1hdHJpeCAtIE1hdHJpeCB0byBzZXRcbiAgICAgKi9cbiAgICBHZW9tZXRyeUNhbGxiYWNrLnByb3RvdHlwZS5zZXRNYXRyaXggPSBmdW5jdGlvbiAobWF0cml4KSB7XG4gICAgICAgIHRoaXMubWF0cml4ID0gbWF0cml4IHx8IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNuYXAgdG8gYSAyRCBtb2RlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgIGhpdFJlc3VsdCAtIGEgcmVzdWx0IG9mIGEgcmF5IGludGVyc2VjdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgICBbb3B0aW9uc10gLSBPcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICBbb3B0aW9ucy5lbnVtU2VnbWVudHNdIC0gRW51bWVyYXRlcyBhbGwgc2VnbWVudHMgd2l0aGluIGEgZ2l2ZW4gYmJveCBpbiBtb2RlbC1zcGFjZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuc25hcHBpbmcyRCA9IGZ1bmN0aW9uIChoaXRSZXN1bHQsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghaGl0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoaXRSZXN1bHQgaXMgYSByZXN1bHQgb2YgYSByYXkgaW50ZXJzZWN0aW9uLiBpdCBtYXkgY29udGFpbiB0aGUgZm9sbG93aW5nOlxuICAgICAgICBsZXQge1xuICAgICAgICAgICAgZGJJZCxcbiAgICAgICAgICAgIGZyYWdJZCxcbiAgICAgICAgICAgIGludGVyc2VjdFBvaW50LFxuICAgICAgICAgICAgbW9kZWwgPSBfdmlld2VyLm1vZGVsXG4gICAgICAgIH0gPSBoaXRSZXN1bHQ7XG5cbiAgICAgICAgaWYgKG1vZGVsLmlzM2QoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9zbmFwUmVzdWx0Lm1vZGVsSWQgPSBoaXRSZXN1bHQubW9kZWwgPyBoaXRSZXN1bHQubW9kZWwuaWQgOiBudWxsO1xuICAgICAgICBfc25hcFJlc3VsdC5oYXNUb3BvbG9neSA9IGZhbHNlO1xuICAgICAgICBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCA9IGludGVyc2VjdFBvaW50O1xuXG4gICAgICAgIGxldCB0ciwgc2NhbGUgPSAxO1xuXG4gICAgICAgIC8vIFRoZSBtb2RlbCB0aGF0IHdlIGFyZSB0cnlpbmcgdG8gc25hcCBpcyAyRCwgYnV0IHRoZSB2aWV3ZXIgaXMgM0QuIEl0IG1lYW5zIHRoYXQgd2UgYXJlIGluIGh5cGVybW9kZWxpbmcgc2NlbmFyaW8hXG4gICAgICAgIC8vIEZvciB0aGF0LCB3ZSdsbCBuZWVkIHRvIGFwcGx5IHRoZSBpbnZlcnNlZCB0cmFuc2Zvcm0gb2YgdGhlIDJEIG1vZGVsIHRvIHRoZSBpbnRlcnNlY3QgcG9pbnQgZmlyc3QsIGluIG9yZGVyIHRvIGdldCBpdCBpbiBsb2NhbCBtb2RlbCBjb29yZHMuXG4gICAgICAgIGlmICghX3ZpZXdlci5pbXBsLmlzMmQpIHtcbiAgICAgICAgICAgIHRyID0gbW9kZWwuZ2V0TW9kZWxUb1ZpZXdlclRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHRyYW5zZm9ybSwgbW92ZSBwb2ludCB0byBvcmlnaW5hbCBsb2NhdGlvbiBpbiBzaGVldCAod2lsbCBiZSByZXN0b3JlZCBhdCB0aGUgZW5kKVxuICAgICAgICAgICAgaWYgKHRyKSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSB0ci5nZXRNYXhTY2FsZU9uQXhpcygpO1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50ID0gaW50ZXJzZWN0UG9pbnQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQobW9kZWwuZ2V0SW52ZXJzZU1vZGVsVG9WaWV3ZXJUcmFuc2Zvcm0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggb25lIHNob3VsZCBiZSBkcmF3bjogbGluZSwgY2lyY3VsYXIgYXJjIG9yIGVsbGlwdGljYWwgYXJjXG4gICAgICAgIC8vIFVzZSB0aGUgdW4tdHJhbnNmb3JtZWQgcG9pbnQsIGJ1dCBzY2FsZSBkb3duIHRoZSByYWRpdXMgYmVjYXVzZSB3ZSBhcmUgY29tcGFyaW5nIHdpdGggdGhlIHVuc2NhbGVkIGdlb21ldHJ5XG4gICAgICAgIF9zbmFwUmVzdWx0LnJhZGl1cyA9IHRoaXMuc2V0RGV0ZWN0UmFkaXVzKGludGVyc2VjdFBvaW50KSAvIHNjYWxlO1xuXG4gICAgICAgIC8vIEdlb21ldHJ5IHNuYXBwaW5nIGlzIG9ubHkgcG9zc2libGUgaWYgYSBmcmFnbWVudCBsaXN0IGlzIGF2YWlsYWJsZSB0byBvYnRhaW4gZ2VvbWV0cnkgcGVyIGZyYWdtZW50LlxuICAgICAgICB2YXIgc3VwcG9ydHNHZW9tU25hcHBpbmcgPSAobW9kZWwuZ2V0RnJhZ21lbnRMaXN0KCkhPW51bGwpO1xuICAgICAgICBpZiAoIXN1cHBvcnRzR2VvbVNuYXBwaW5nKSB7XG5cbiAgICAgICAgICAgIC8vIElmIG5vIHNuYXBwaW5nIGlzIGF2YWlsYWJsZSwganVzdCBhY2NlcHQgdGhlIGhpdHBvaW50IGFzIGEgdmVydGV4IGhpdC4gVGhpcyBhbGxvd3MgdG8gbWVhc3VyZVxuICAgICAgICAgICAgLy8gZGlzdGFuY2VzIGJldHdlZW4gYXJiaXRyYXJ5IHBvaW50cyBpbiByYXN0ZXJzLlxuICAgICAgICAgICAgX2lzU25hcHBlZCA9IHRydWU7XG4gICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IGludGVyc2VjdFBvaW50OyAvLyBVc2UgdGhlIHVuLXRyYW5zZm9ybWVkIHBvaW50XG4gICAgICAgICAgICB0ciAmJl9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NCh0cik7IC8vIFJlc3RvcmUgdG8gb3JpZ2luYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIGdjID0gbmV3IEdlb21ldHJ5Q2FsbGJhY2soX3ZpZXdlciwgdGhpcywgX3NuYXBSZXN1bHQucmFkaXVzKTtcblxuICAgICAgICAvLyBQZXJmb3JtcyAyRCBzbmFwcGluZyB0byBzZWdtZW50cyBiYXNlZCBvbiBhbiBlbnVtU2VnbWVudHMoKSBjYWxsYmFjaywgd2hpY2ggZW51bWVyYXRlcyBhbGwgc2VnbWVudHNcbiAgICAgICAgLy8gd2l0aGluIGluIGEgZ2l2ZW4gYmJveCBpbiBtb2RlbC1zcGFjZS5cbiAgICAgICAgaWYgKG9wdGlvbnMuZW51bVNlZ21lbnRzKSB7XG4gICAgICAgICAgICAvLyBlbnVtIGFsbCBzZWdtZW50cyB3aXRoaW4gdGhlIHNuYXBSYWRpdXMgYXJvdW5kIGludGVyc2VjdFBvaW50XG4gICAgICAgICAgICBjb25zdCBtaW54ID0gX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQueCAtIF9zbmFwUmVzdWx0LnJhZGl1cztcbiAgICAgICAgICAgIGNvbnN0IG1pbnkgPSBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludC55IC0gX3NuYXBSZXN1bHQucmFkaXVzO1xuICAgICAgICAgICAgY29uc3QgbWF4eCA9IF9zbmFwUmVzdWx0LmludGVyc2VjdFBvaW50LnggKyBfc25hcFJlc3VsdC5yYWRpdXM7XG4gICAgICAgICAgICBjb25zdCBtYXh5ID0gX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQueSArIF9zbmFwUmVzdWx0LnJhZGl1cztcblxuICAgICAgICAgICAgb3B0aW9ucy5lbnVtU2VnbWVudHMobWlueCwgbWlueSwgbWF4eCwgbWF4eSwgZ2MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVndWxhciBzbmFwcGluZyAtIHNuYXAgdG8gdGhlIDJEIG1vZGVsJ3MgZ2VvbWV0cnkuXG4gICAgICAgICAgICB2YXIgZnJhZ0lkcyA9IGZyYWdJZDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmcmFnSWRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gTE1WLTYwODIgRG8gbm90IHJldHVybiBvdXQgaWYgdGhlIHNuYXAgdG8gcGl4ZWwgZmxhZyAoZnJlZSBtZWFzdXJlKSBpcyBlbmFibGVkLlxuICAgICAgICAgICAgICAgIGlmICghX3NuYXBUb1BpeGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhZ0lkcyA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShmcmFnSWRzKSkge1xuICAgICAgICAgICAgICAgIGZyYWdJZHMgPSBbZnJhZ0lkc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmcmFnSWRzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc2ggPSBfdmlld2VyLmltcGwuZ2V0UmVuZGVyUHJveHkobW9kZWwsIGZyYWdJZHNbZmldKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzaD8uZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2Muc2V0TWF0cml4KG1lc2gubWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmJyID0gbmV3IFZlcnRleEJ1ZmZlclJlYWRlcihtZXNoLmdlb21ldHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgdmJyLmVudW1HZW9tc0Zvck9iamVjdChtb2RlbC5yZXZlcnNlTWFwRGJJZEZvcjJEKGRiSWQpLCBnYyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgbWF0cml4IGJhY2sgdG8gaWRlbnRpdHkgYWZ0ZXIgcHJvY2Vzc2luZyBhIG1lc2hcbiAgICAgICAgICAgICAgICAgICAgZ2Muc2V0TWF0cml4KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQgY29udGFpbnMgdGhlIHBvc3NpYmx5IHRyYW5zZm9ybWVkIHBvaW50XG4gICAgICAgIHRoaXMuZmluaXNoU25hcHBpbmcyRChnYywgX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgICAgIC8vIFNuYXAgdGhlIHVuc25hcHBlZCBwb2ludCBvbmx5IGlmIHRoZSBzbmFwcGluZyBmYWlsc1xuICAgICAgICBpZighX2lzU25hcHBlZCAmJiBfc25hcFRvUGl4ZWwpIHtcbiAgICAgICAgICAgIF9pc1NuYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5SQVNURVJfUElYRUw7XG4gICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVmVydGV4ID0gX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgYXBwbHkgdGhlIHRyYW5zZm9ybSBtYXRyaXggb24gdGhlIHJlc3VsdHMsIHNvIHdlJ2xsIGdldCB0aGUgcmVzdWx0cyBpbiB0aGVpciBmaW5hbCB0cmFuc2Zvcm1lZCBwb3NpdGlvbi5cbiAgICAgICAgaWYgKHRyKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IF9zbmFwUmVzdWx0Lmdlb21FZGdlPy52ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IF9zbmFwUmVzdWx0Lmdlb21FZGdlPy52ZXJ0aWNlc1sxXTtcblxuICAgICAgICAgICAgbGV0IHJlc3VsdHMgPSBbX3NuYXBSZXN1bHQuc25hcFBvaW50LCBfc25hcFJlc3VsdC5nZW9tVmVydGV4LCBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCwgX3NuYXBSZXN1bHQuY2lyY3VsYXJBcmNDZW50ZXIsXG4gICAgICAgICAgICAgICAgc3RhcnQsIGVuZF07XG4gICAgICAgICAgICAvLyBSZW1vdmUgdW5kZWZpbmVkIGFuZCBwb3NzaWJseSBzaGFyZWQgdmVjdG9yc1xuICAgICAgICAgICAgcmVzdWx0cyA9IFsuLi5uZXcgU2V0KHJlc3VsdHMuZmlsdGVyKG4gPT4gbikpXTtcbiAgICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaChyZXMgPT4gcmVzLmFwcGx5TWF0cml4NCh0cikpO1xuICAgICAgICAgICAgaWYgKF9zbmFwUmVzdWx0LmNpcmN1bGFyQXJjUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuY2lyY3VsYXJBcmNSYWRpdXMgKj0gc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc25hcFJlc3VsdC5yYWRpdXMgKj0gc2NhbGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQnkgZGVmYXVsdCwgc25hcHBlciBvbmx5IGNvbnNpZGVycyBtb2RlbCBnZW9tZXRyeSB0aGF0IGlzIHdyaXR0ZW4gdG8gSUQgYnVmZmVyLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgdGhlIDJEIHNuYXBwaW5nIG9uIGEgc2V0IG9mIGdpdmVuIDJEIG1lc2hlcyBpbnN0ZWFkLiBJdCB3b3JrcyBzaW1pbGFyIHRvIHNuYXBwaW5nMkQoKSBidXRcbiAgICAvLyBlbnVtZXJhdGVzIHRoZSBnaXZlbiBtZXNoZXMgaW5zdGVhZCBvZiBnZXR0aW5nIHRoZW0gZnJvbSB0aGUgZnJhZ21lbnQgbGlzdC5cbiAgICAvL1xuICAgIC8vICBAcGFyYW0ge1RIUkVFLlZlY3RvcjN9ICAgICAgICAgICAgICAgICBpbnRlcnNlY3RQb2ludCAtIGNsaWNrIHBvc2l0aW9uIGluIHdvcmxkLWNvb3Jkc1xuICAgIC8vICBAcGFyYW0ge2Z1bmN0aW9uKGRiSWQsIGxheWVySWQsIHZwSWQpfSBmaWx0ZXIgLSBEZWZpbmVzIHN1YnNldCBvZiBwcmltaXRpdmVzIHRvIGJlIGNvbnNpZGVyZWQuXG4gICAgLy8gIEBwYXJhbSB7VEhSRUUuTWVzaFtdfSAgICAgICAgICAgICAgICAgIG1lc2hlcyAtIFRoZSB0cmlhbmd1bGF0ZWQgMkQgc2hhcGVzIHRvIGJlIGNoZWNrZWQgZm9yIHNuYXBwaW5nXG4gICAgLy8gIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICAgICAgIFtkZXRlY3RSYWRpdXNdIC0gU2FtZSBjb29yZGluYXRlIHN5c3RlbSBhcyB0aGUgZ2l2ZW4gZ2VvbWV0cnkuIFJlcXVpcmVkIGlmIGdlb21ldHJ5IGlzIG5vdCBpbiB3b3JsZC1jb29yZHMuXG5cbiAgICB0aGlzLnNuYXBwaW5nMkRPdmVybGF5ID0gZnVuY3Rpb24oaW50ZXJzZWN0UG9pbnQsIG1lc2hlcywgZmlsdGVyLCBkZXRlY3RSYWRpdXMpIHtcbiAgICAgICAgX3NuYXBSZXN1bHQuaGFzVG9wb2xvZ3kgPSBmYWxzZTtcbiAgICAgICAgX3NuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQgPSBpbnRlcnNlY3RQb2ludDtcbiAgICAgICAgX3NuYXBSZXN1bHQucmFkaXVzID0gZGV0ZWN0UmFkaXVzIHx8IHRoaXMuc2V0RGV0ZWN0UmFkaXVzKGludGVyc2VjdFBvaW50KTtcblxuICAgICAgICB2YXIgZ2MgPSBuZXcgR2VvbWV0cnlDYWxsYmFjayhfdmlld2VyLCB0aGlzLCBfc25hcFJlc3VsdC5yYWRpdXMpO1xuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxtZXNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXNoID0gbWVzaGVzW2ldO1xuICAgICAgICAgICAgdmFyIHZiciA9IG5ldyBWZXJ0ZXhCdWZmZXJSZWFkZXIobWVzaC5nZW9tZXRyeSk7XG4gICAgICAgICAgICB2YnIuZW51bUdlb21zKGZpbHRlciwgZ2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maW5pc2hTbmFwcGluZzJEKGdjLCBpbnRlcnNlY3RQb2ludCk7XG4gICAgfTtcblxuICAgIC8vIEZpbmlzaCAyRCBzbmFwcGluZyBvcGVyYXRpb24gLSBhc3N1bWluZyB0aGF0IGFsbCBjYW5kaWRhdGUgZ2VvbWV0cnkgZm9yIHNuYXBwaW5nIGhhcyBiZWVuIHByb2Nlc3NlZCBieSB0aGUgZ2VvbWV0cnlDYWxsYmFjayBnYyBhbHJlYWR5LlxuICAgIHRoaXMuZmluaXNoU25hcHBpbmcyRCA9IGZ1bmN0aW9uKGdjLCBpbnRlcnNlY3RQb2ludCkge1xuXG4gICAgICAgIC8vIFdoZW4gcmVzdHJpY3RpbmcgdG8gYSBzaW5nbGUgdmlld3BvcnQsIGV4Y2x1ZGUgY2FuZGlkYXRlcyBvZiBhbGwgb3RoZXIgdmlld3BvcnRzXG4gICAgICAgIGlmIChfZm9yY2VkVnBJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaXNTYW1lVmlld3BvcnQgPSBjID0+IChjLnZpZXdwb3J0SWQgPT09IF9mb3JjZWRWcElkKTtcbiAgICAgICAgICAgIGdjLnNuYXBDYW5kaWRhdGVzID0gZ2Muc25hcENhbmRpZGF0ZXMuZmlsdGVyKGlzU2FtZVZpZXdwb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiBzbmFwIHRvIGFuIGludGVyc2VjdGlvbiBvZiB0d28gY2xvc2Ugc2VnbWVudHNcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0U25hcCA9IGZpbmRJbnRlcnNlY3Rpb25TbmFwKGdjLnNuYXBDYW5kaWRhdGVzLCBpbnRlcnNlY3RQb2ludCwgZ2MuZGV0ZWN0UmFkaXVzKTtcbiAgICAgICAgaWYgKGludGVyc2VjdFNuYXApIHtcbiAgICAgICAgICAgIF9zbmFwUmVzdWx0LnZpZXdwb3J0SW5kZXgyZCA9IGludGVyc2VjdFNuYXAudmlld3BvcnRJZDtcbiAgICAgICAgICAgIF9zbmFwUmVzdWx0LnNuYXBQb2ludCA9IGludGVyc2VjdFNuYXAuc25hcFBvaW50O1xuICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX0lOVEVSU0VDVElPTjtcbiAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXggPSBpbnRlcnNlY3RTbmFwLnNuYXBQb2ludDtcbiAgICAgICAgICAgIF9pc1NuYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdjLmNpcmN1bGFyQXJjKSB7XG5cbiAgICAgICAgICAgIF9zbmFwUmVzdWx0LnZpZXdwb3J0SW5kZXgyZCA9IGdjLnZwSWRDaXJjdWxhcjtcblxuICAgICAgICAgICAgX3NuYXBSZXN1bHQuc25hcFBvaW50ID0gZ2Muc25hcFBvaW50O1xuXG4gICAgICAgICAgICAvLyBPbmx5IHNuYXAgdGhlIGdlb21ldHJpZXMgd2hpY2ggYmVsb25nIHRvIHRoZSBzYW1lIHZpZXdwb3J0IGFzIHRoZSBmaXJzdCBzZWxlY3Rpb25cbiAgICAgICAgICAgIGlmIChfZm9yY2VkVnBJZCAhPT0gbnVsbCAmJiBfZm9yY2VkVnBJZCAhPT0gX3NuYXBSZXN1bHQudmlld3BvcnRJbmRleDJkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnYy5jaXJjdWxhckFyYy52ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGdjLmNpcmN1bGFyQXJjLnZlcnRpY2VzW2djLmNpcmN1bGFyQXJjLnZlcnRpY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhzdGFydCkgPCBfc25hcFJlc3VsdC5yYWRpdXMpIHtcblxuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhlbmQpIDwgX3NuYXBSZXN1bHQucmFkaXVzKSB7XG5cbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVmVydGV4ID0gZW5kO1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9WRVJURVg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMubGluZVN0cmlwVG9QaWVjZXMoZ2MuY2lyY3VsYXJBcmMpO1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21FZGdlID0gZ2MuY2lyY3VsYXJBcmM7XG4gICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuY2lyY3VsYXJBcmNDZW50ZXIgPSBnYy5jaXJjdWxhckFyY0NlbnRlcjtcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5jaXJjdWxhckFyY1JhZGl1cyA9IGdjLmNpcmN1bGFyQXJjUmFkaXVzO1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9DSVJDVUxBUkFSQztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2lzU25hcHBlZCA9IHRydWU7XG5cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdjLmVsbGlwdGljYWxBcmMpIHtcblxuICAgICAgICAgICAgX3NuYXBSZXN1bHQudmlld3BvcnRJbmRleDJkID0gZ2MudnBJZEVsbGlwdGljYWw7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgc25hcCB0aGUgZ2VvbWV0cmllcyB3aGljaCBiZWxvbmcgdG8gdGhlIHNhbWUgdmlld3BvcnQgYXMgdGhlIGZpcnN0IHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKF9mb3JjZWRWcElkICE9PSBudWxsICYmIF9mb3JjZWRWcElkICE9PSBfc25hcFJlc3VsdC52aWV3cG9ydEluZGV4MmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGdjLmVsbGlwdGljYWxBcmMudmVydGljZXNbMF07XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBnYy5lbGxpcHRpY2FsQXJjLnZlcnRpY2VzW2djLmVsbGlwdGljYWxBcmMudmVydGljZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhzdGFydCkgPCBfc25hcFJlc3VsdC5yYWRpdXMpIHtcblxuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhlbmQpIDwgX3NuYXBSZXN1bHQucmFkaXVzKSB7XG5cbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVmVydGV4ID0gZW5kO1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9WRVJURVg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHRoaXMubGluZVN0cmlwVG9QaWVjZXMoZ2MuZWxsaXB0aWNhbEFyYyk7XG4gICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbUVkZ2UgPSBnYy5lbGxpcHRpY2FsQXJjO1xuICAgICAgICAgICAgICAgIC8vIEJlZm9yZSB3ZSBoYXZlIG1lYXN1cmUgZGVzaWduIGZvciBlbGxpcHRpY2FsIGFyYywgbWVhc3VyZSB0aGUgY2VudGVyIGZvciBub3dcbiAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5jaXJjdWxhckFyY0NlbnRlciA9IGdjLmVsbGlwdGljYWxBcmNDZW50ZXI7XG4gICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuY2lyY3VsYXJBcmNSYWRpdXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9DSVJDVUxBUkFSQztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2lzU25hcHBlZCA9IHRydWU7XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZ2MubGluZUdlb20gaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSAmJiBnYy5saW5lR2VvbS52ZXJ0aWNlcy5sZW5ndGgpIHx8XG4gICAgICAgICAgICAoZ2MubGluZUdlb20uZ2V0QXR0cmlidXRlICYmIGdjLmxpbmVHZW9tLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKS5jb3VudCkpIHtcblxuICAgICAgICAgICAgX3NuYXBSZXN1bHQudmlld3BvcnRJbmRleDJkID0gZ2MudnBJZExpbmU7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgc25hcCB0aGUgZ2VvbWV0cmllcyB3aGljaCBiZWxvbmcgdG8gdGhlIHNhbWUgdmlld3BvcnQgYXMgdGhlIGZpcnN0IHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKF9mb3JjZWRWcElkICE9PSBudWxsICYmIF9mb3JjZWRWcElkICE9PSBfc25hcFJlc3VsdC52aWV3cG9ydEluZGV4MmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBBbHdheXMgZXhwb3NlIGVkZ2Ugc2VnbWVudCAtIG5vIG1hdHRlciB3aGV0aGVyIHdlIHNuYXAgdG8gdGhlIGVkZ2Ugb3Igb25lIG9mIGl0cyB2ZXJ0aWNlcy5cbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIGNvbWJpbmUgaXQgd2l0aCBvdGhlciBzbmFwIGNvbnN0cmFpbnRzIGxhdGVyIC0gYXMgZG9uZSBieSBFZGl0MkQuXG4gICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tRWRnZSA9IGdjLmxpbmVHZW9tO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnYy5saW5lR2VvbS52ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGdjLmxpbmVHZW9tLnZlcnRpY2VzWzFdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrdXBNb2RlKSB7ICAvLyBNYXJrdXAgbW9kZVxuICAgICAgICAgICAgICAgIHZhciBtaWQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICAgICAgICAgIG1pZC5hZGRWZWN0b3JzKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIG1pZC5kaXZpZGVTY2FsYXIoMik7XG4gICAgICAgICAgICAgICAgdmFyIG1kID0gaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VUbyhtaWQpO1xuICAgICAgICAgICAgICAgIHZhciBzZCA9IGludGVyc2VjdFBvaW50LmRpc3RhbmNlVG8oc3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciBlZCA9IGludGVyc2VjdFBvaW50LmRpc3RhbmNlVG8oZW5kKTtcblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGl0IGZvciBzbmFwcGluZyB0byBwYXJhbGxlbC9wZXJwZW5kaWN1bGFyIG9mIHVuZGVybHlpbmcgdmVjdG9yc1xuICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21FZGdlID0gZ2MubGluZUdlb207XG5cbiAgICAgICAgICAgICAgICBpZiAobWQgPCBfc25hcFJlc3VsdC5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IG1pZDtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX1ZFUlRFWDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2QgPCBfc25hcFJlc3VsdC5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlZCA8IF9zbmFwUmVzdWx0LnJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVmVydGV4ID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfVkVSVEVYO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX0VER0U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2lyY2xlIGNlbnRlclxuICAgICAgICAgICAgICAgIGlmIChzdGFydC5kaXN0YW5jZVRvKGVuZCkgPCBFUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9DSVJDTEVfQ0VOVEVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAgLy8gTWVhc3VyZSBtb2RlXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdFBvaW50LmRpc3RhbmNlVG8oc3RhcnQpIDwgX3NuYXBSZXN1bHQucmFkaXVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0LmRpc3RhbmNlVG8oZW5kKSA8IEVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9DSVJDTEVfQ0VOVEVSO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVR5cGUgPSBTbmFwVHlwZS5TTkFQX1ZFUlRFWDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKF9vcHRpb25zLmZvcmNlU25hcFZlcnRpY2VzIHx8IChpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVRvKGVuZCkgPCBfc25hcFJlc3VsdC5yYWRpdXMpKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21WZXJ0ZXggPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIF9zbmFwUmVzdWx0Lmdlb21UeXBlID0gU25hcFR5cGUuU05BUF9WRVJURVg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfRURHRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9pc1NuYXBwZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc25hcHBpbmdSYXN0ZXJQaXhlbCA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGludGVyc2VjdFBvaW50ID0gcmVzdWx0LmludGVyc2VjdFBvaW50O1xuICAgICAgICBfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCA9IGludGVyc2VjdFBvaW50O1xuICAgICAgICBfc25hcFJlc3VsdC5oYXNUb3BvbG9neSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCBvbmUgc2hvdWxkIGJlIGRyYXduOiBsaW5lLCBjaXJjdWxhciBhcmMgb3IgZWxsaXB0aWNhbCBhcmNcbiAgICAgICAgX3NuYXBSZXN1bHQucmFkaXVzID0gdGhpcy5zZXREZXRlY3RSYWRpdXMoaW50ZXJzZWN0UG9pbnQpO1xuICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlJBU1RFUl9QSVhFTDtcbiAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IGludGVyc2VjdFBvaW50O1xuICAgICAgICBfaXNTbmFwcGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5zbmFwTWlkcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX3NuYXBSZXN1bHQuaXNNaWRwb2ludCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNuYXAgbWlkcG9pbnQgZm9yIGVkZ2VcbiAgICAgICAgaWYgKF9pc1NuYXBwZWQpIHtcbiAgICAgICAgICAgIGlmIChfc25hcFJlc3VsdC5nZW9tVHlwZSA9PT0gU25hcFR5cGUuU05BUF9FREdFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRnZSA9IF9zbmFwUmVzdWx0Lmdlb21FZGdlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHAxID0gZWRnZS52ZXJ0aWNlc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwMiA9IGVkZ2UudmVydGljZXNbMV07XG5cbiAgICAgICAgICAgICAgICB2YXIgbWlkcG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygocDEueCArIHAyLngpIC8gMiwgKHAxLnkgKyBwMi55KSAvIDIsIChwMS56ICsgcDIueikgLyAyKTtcblxuICAgICAgICAgICAgICAgIHZhciBjdXRQbGFuZXMgPSBfdmlld2VyLmltcGwuZ2V0QWxsQ3V0UGxhbmVzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1dFBsYW5lcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpPGN1dFBsYW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IGN1dFBsYW5lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvdCA9IG1pZHBvaW50LngqcC54ICsgbWlkcG9pbnQueSpwLnkgKyBtaWRwb2ludC56KnAueiArIHAudztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb3Q+MWUtNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc2NhcmQgbWlkcG9pbnQgaWYgY2xpcHBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludC5kaXN0YW5jZVRvKG1pZHBvaW50KSA8IDIgKiBfc25hcFJlc3VsdC5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NuYXBSZXN1bHQuZ2VvbVZlcnRleCA9IG1pZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICBfc25hcFJlc3VsdC5nZW9tVHlwZSA9IFNuYXBUeXBlLlNOQVBfTUlEUE9JTlQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc2V0UGVycGVuZGljdWxhciA9IGZ1bmN0aW9uKGlzUGVycGVuZGljdWxhcikge1xuICAgICAgICBfc25hcFJlc3VsdC5pc1BlcnBlbmRpY3VsYXIgPSBpc1BlcnBlbmRpY3VsYXI7XG4gICAgfTtcblxuICAgIHRoaXMubGluZVN0cmlwVG9QaWVjZXMgPSBmdW5jdGlvbihnZW9tKSB7XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gZ2VvbS52ZXJ0aWNlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IHZlcnRpY2VzLmxlbmd0aCAtIDI7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZlcnRpY2VzLnNwbGljZShpLCAwLCB2ZXJ0aWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5zZXREZXRlY3RSYWRpdXMgPSBmdW5jdGlvbihwb2ludCkge1xuXG4gICAgICAgIHZhciBuYXZhcGkgPSBfdmlld2VyLm5hdmlnYXRpb247XG4gICAgICAgIHZhciBjYW1lcmEgPSBuYXZhcGkuZ2V0Q2FtZXJhKCk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG5hdmFwaS5nZXRQb3NpdGlvbigpO1xuXG4gICAgICAgIHZhciBwID0gcG9pbnQuY2xvbmUoKTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBjYW1lcmEuaXNQZXJzcGVjdGl2ZSA/IHAuc3ViKHBvc2l0aW9uKS5sZW5ndGgoKVxuICAgICAgICAgICAgOiBuYXZhcGkuZ2V0RXllVmVjdG9yKCkubGVuZ3RoKCk7XG5cbiAgICAgICAgdmFyIGZvdiA9IG5hdmFwaS5nZXRWZXJ0aWNhbEZvdigpO1xuICAgICAgICB2YXIgd29ybGRIZWlnaHQgPSAyLjAgKiBkaXN0YW5jZSAqIE1hdGgudGFuKFRIUkVFLk1hdGguZGVnVG9SYWQoZm92ICogMC41KSk7XG5cbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gbmF2YXBpLmdldFNjcmVlblZpZXdwb3J0KCk7XG4gICAgICAgIHZhciBfd2luZG93ID0gdGhpcy5nZXRXaW5kb3coKTtcbiAgICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSBfd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuZGV0ZWN0UmFkaXVzSW5QaXhlbHMgKiB3b3JsZEhlaWdodCAvICh2aWV3cG9ydC5oZWlnaHQgKiBkZXZpY2VQaXhlbFJhdGlvKTtcblxuICAgICAgICByZXR1cm4gcmFkaXVzO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZUJ1dHRvbkRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZUJ1dHRvblVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgaWYgKF9pc0RyYWdnaW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUoe1xuICAgICAgICAgICAgeDogZXZlbnQuY2FudmFzWCxcbiAgICAgICAgICAgIHk6IGV2ZW50LmNhbnZhc1lcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZVNpbmdsZVRhcCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVQcmVzc0hvbGQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICBpZiAoYXYuaXNNb2JpbGVEZXZpY2UoKSkge1xuICAgICAgICAgICAgc3dpdGNoKCBldmVudC50eXBlIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgX2lzUHJlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKHt4OiBldmVudC5jYW52YXNYLCB5OiBldmVudC5jYW52YXNZfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInByZXNzdXBcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlTW92ZSh7eDogZXZlbnQuY2FudmFzWCwgeTogZXZlbnQuY2FudmFzWX0pO1xuICAgICAgICAgICAgICAgICAgICBfaXNQcmVzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVHZXN0dXJlID0gZnVuY3Rpb24oIGV2ZW50IClcbiAgICB7XG4gICAgICAgIGlmIChhdi5pc01vYmlsZURldmljZSgpKSB7XG4gICAgICAgICAgICBpZiAoX2lzUHJlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goIGV2ZW50LnR5cGUgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRyYWdzdGFydFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZHJhZ21vdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZU1vdmUoe3g6IGV2ZW50LmNhbnZhc1gsIHk6IGV2ZW50LmNhbnZhc1l9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkcmFnZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKHt4OiBldmVudC5jYW52YXNYLCB5OiBldmVudC5jYW52YXNZfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXNQcmVzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBpbmNoc3RhcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBpbmNobW92ZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGluY2hlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciB0byBtb3VzZSBtb3ZlIGV2ZW50cywgdXNlZCB0byBzbmFwIGluIG1hcmt1cCBlZGl0IG1vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW91c2VQb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKG1vdXNlUG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25Nb3VzZU1vdmUobW91c2VQb3NpdGlvbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgdG8gbW91c2UgbW92ZSBldmVudHMsIHVzZWQgdG8gc25hcCBpbiBtYXJrdXAgZWRpdCBtb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vdXNlUG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMub25Nb3VzZU1vdmUgPSBmdW5jdGlvbihtb3VzZVBvc2l0aW9uKSB7XG5cbiAgICAgICAgdGhpcy5jbGVhclNuYXBwZWQoKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gX3ZpZXdlci5pbXBsLnNuYXBwaW5nSGl0VGVzdChtb3VzZVBvc2l0aW9uLngsIG1vdXNlUG9zaXRpb24ueSwgZmFsc2UpO1xuXG4gICAgICAgIGlmICghcmVzdWx0ICYmIF9zbmFwVG9QaXhlbCkge1xuICAgICAgICAgICAgdmFyIHZwVmVjID0gX3ZpZXdlci5pbXBsLmNsaWVudFRvVmlld3BvcnQobW91c2VQb3NpdGlvbi54LCBtb3VzZVBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgbGV0IHBvaW50ID0gX3ZpZXdlci5pbXBsLmludGVyc2VjdEdyb3VuZFZpZXdwb3J0KHZwVmVjKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHsgaW50ZXJzZWN0UG9pbnQgOiBwb2ludCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC5pbnRlcnNlY3RQb2ludClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjb25zdCBpc0xlYWZsZXQgPSByZXN1bHQubW9kZWw/LmlzTGVhZmxldCgpIHx8IChfdmlld2VyLmltcGwuaXMyZCAmJiBfdmlld2VyLm1vZGVsPy5pc0xlYWZsZXQoKSk7XG4gICAgICAgIC8vIDNEIFNuYXBwaW5nXG4gICAgICAgIGlmIChyZXN1bHQuZmFjZSkge1xuICAgICAgICAgICAgdGhpcy5zbmFwcGluZzNEKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMkQgU25hcHBpbmdcbiAgICAgICAgZWxzZSBpZiAoKHJlc3VsdC5kYklkIHx8IHJlc3VsdC5kYklkID09PSAwKSAmJiAhaXNMZWFmbGV0KSB7XG4gICAgICAgICAgICB0aGlzLnNuYXBwaW5nMkQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQaXhlbCBTbmFwcGluZ1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUGl4ZWxTbmFwID0gX3NuYXBUb1BpeGVsIHx8IGlzTGVhZmxldDtcbiAgICAgICAgICAgIGlmIChpc1BpeGVsU25hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc25hcHBpbmdSYXN0ZXJQaXhlbChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zbmFwTWlkcG9pbnQoKTtcblxuICAgICAgICBpZiAoX3NuYXBGaWx0ZXIgJiYgIV9zbmFwRmlsdGVyKF9zbmFwUmVzdWx0KSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclNuYXBwZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5cbmF2Lkdsb2JhbE1hbmFnZXJNaXhpbi5jYWxsKFNuYXBwZXIucHJvdG90eXBlKTtcbiJdLCJuYW1lcyI6WyJOdWxsU25hcHBlckluZGljYXRvciIsIlNuYXBwZXJJbmRpY2F0b3IiLCJuZWFyZXN0UG9pbnRPbkNpcmN1bGFyQXJjIiwiaW50ZXJzZWN0TGluZXMiLCJNZWFzdXJlQ29tbW9uIiwiQXV0b2Rlc2siLCJWaWV3aW5nIiwiRVBTSUxPTiIsIlNuYXBUeXBlIiwiU25hcFJlc3VsdCIsIlNOQVBfUFJFQ0lTSU9OIiwiYXYiLCJhdnAiLCJQcml2YXRlIiwiVmVydGV4QnVmZmVyUmVhZGVyIiwiaXNFcXVhbFdpdGhQcmVjaXNpb24iLCJhIiwiYiIsIk1hdGgiLCJhYnMiLCJpc0VxdWFsVmVjdG9yc1dpdGhQcmVjaXNpb24iLCJ2MSIsInYyIiwieCIsInkiLCJ6IiwiaXNJbnZlcnNlVmVjdG9yc1dpdGhQcmVjaXNpb24iLCJkaXN0YW5jZVBvaW50VG9MaW5lIiwicG9pbnQiLCJsaW5lU3RhcnQiLCJsaW5lRW5kIiwiZXF1YWxzIiwiZGlzdGFuY2VUbyIsIlgwIiwiVEhSRUUiLCJWZWN0b3IzIiwiWDEiLCJkaXN0YW5jZSIsInBhcmFtIiwic3ViVmVjdG9ycyIsImRvdCIsImNyb3NzIiwic3FydCIsIlNuYXBDYW5kaWRhdGVUeXBlIiwiVW5rbm93biIsIkxpbmUiLCJDaXJjdWxhckFyYyIsIkVsbGlwdGljYWxBcmMiLCJTbmFwQ2FuZGlkYXRlIiwiY29uc3RydWN0b3IiLCJ2aWV3cG9ydElkIiwidHlwZSIsInJhZGl1cyIsInJhZGl1c1giLCJyYWRpdXNZIiwiY2VudGVyIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiZnJvbUxpbmUiLCJwMSIsInAyIiwiY2xvbmUiLCJmcm9tQ2lyY3VsYXJBcmMiLCJzdGFydCIsImVuZCIsImZyb21FbGxpcHRpY2FsQXJjIiwiaXNMaW5lIiwiaXNDaXJjdWxhckFyYyIsIkNpcnVsYXJBcmMiLCJpc0VsbGlwdGljYWxBcmMiLCJnZXRJbnRlcnNlY3Rpb24iLCJvdGhlciIsIm9wdGlvbmFsVGFyZ2V0IiwiZmluZEludGVyc2VjdGlvblNuYXAiLCJjYW5kaWRhdGVzIiwiaW50ZXJzZWN0UG9pbnQiLCJzbmFwUmFkaXVzIiwiYnlEaXN0YW5jZSIsImNhIiwiY2IiLCJzb3J0IiwibGVuZ3RoIiwicmVzdWx0Iiwic25hcFBvaW50IiwiZmlyc3QiLCJpIiwic2Vjb25kIiwiZm91bmQiLCJkaXN0IiwiVmVjdG9yMiIsInByb3RvdHlwZSIsImNhbGwiLCJTbmFwcGVyIiwidmlld2VyIiwib3B0aW9ucyIsIl9zbmFwUmVzdWx0IiwiX3ZpZXdlciIsInNldEdsb2JhbE1hbmFnZXIiLCJnbG9iYWxNYW5hZ2VyIiwiX29wdGlvbnMiLCJfbmFtZXMiLCJtYXJrdXBNb2RlIiwidG9vbE5hbWUiLCJfcHJpb3JpdHkiLCJfYWN0aXZlIiwiX2Rpc3RhbmNlVG9FZGdlIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiX2Rpc3RhbmNlVG9WZXJ0ZXgiLCJfaXNEcmFnZ2luZyIsIl9pc1ByZXNzaW5nIiwiX2lzU25hcHBlZCIsIl9mb3JjZWRWcElkIiwiX3NuYXBUb1BpeGVsIiwiX3NuYXBGaWx0ZXIiLCJpbmRpY2F0b3IiLCJyZW5kZXJTbmFwcGVkR2VvbWV0cnkiLCJyZW5kZXJTbmFwcGVkVG9wb2xvZ3kiLCJkZXRlY3RSYWRpdXNJblBpeGVscyIsImlzTW9iaWxlRGV2aWNlIiwiaXNBY3RpdmUiLCJnZXROYW1lcyIsImdldE5hbWUiLCJnZXRQcmlvcml0eSIsImFjdGl2YXRlIiwiaXNOdWxsIiwiZGVhY3RpdmF0ZSIsImRlc3Ryb3kiLCJjb3B5UmVzdWx0cyIsImRlc3RpbnkiLCJjb3B5VG8iLCJnZXRFZGdlIiwiZ2VvbUVkZ2UiLCJnZXRWZXJ0ZXgiLCJnZW9tVmVydGV4IiwiZ2V0R2VvbWV0cnkiLCJnZXRHZW9tZXRyeVR5cGUiLCJnZW9tVHlwZSIsImdldEludGVyc2VjdFBvaW50IiwiZ2V0U25hcFJlc3VsdCIsImlzU25hcHBlZCIsImNsZWFyU25hcHBlZCIsImNsZWFyIiwic2V0Vmlld3BvcnRJZCIsInZwSWQiLCJzZXRTbmFwVG9QaXhlbCIsImVuYWJsZSIsImdldFNuYXBUb1BpeGVsIiwic2V0U25hcFRvQXJjIiwic25hcFRvQXJjIiwiZ2V0U25hcFRvQXJjIiwic2V0QXJjIiwiaXNBcmMiLCJnZXRBcmMiLCJzZXRTbmFwRmlsdGVyIiwiZmlsdGVyIiwic25hcHBpbmczRCIsInNuYXBOb2RlIiwiZGJJZCIsIm1vZGVsSWQiLCJtb2RlbCIsImlkIiwiZmFjZSIsImZyYWdJZCIsInVuZGVmaW5lZCIsIm9iamVjdCIsIk1lc2giLCJtZXNoU25hcHBpbmciLCJmcmFnSWRzIiwiaGFzVG9wb2xvZ3kiLCJmaSIsInRvcG9JbmRleCIsImdldFRvcG9JbmRleCIsInRvcG9sb2d5IiwiZ2V0VG9wb2xvZ3kiLCJzbmFwcGluZzNEd2l0aFRvcG9sb2d5Iiwic25hcHBpbmczRHRvTWVzaCIsIm1ha2VSZWFkVmVydGV4RnVuYyIsImdlb21ldHJ5IiwiYXR0cmlidXRlcyIsInBvc2l0aW9ucyIsInN0cmlkZSIsInBvZmZzZXQiLCJ2YmxheW91dCIsInBvc2l0aW9uIiwib2Zmc2V0IiwidmIiLCJhcnJheSIsInZic3RyaWRlIiwiaWR4IiwidiIsInAiLCJzZXQiLCJnZXREYXRhIiwiaW5zdGFuY2VUcmVlIiwiZW51bU5vZGVGcmFnbWVudHMiLCJwdXNoIiwiZ2VvbUZhY2UiLCJfbW9kZWwkZ2V0RnJhZ21lbnRMaXMiLCJfbW9kZWwkZ2V0RnJhZ21lbnRMaXMyIiwibWF0cml4V29ybGQiLCJNYXRyaXg0IiwiZ2V0RnJhZ21lbnRMaXN0IiwiZ2V0V29ybGRNYXRyaXgiLCJmYWNlc1RvcG9sb2d5IiwiZmFjZXMiLCJlZGdlc1RvcG9sb2d5IiwiZWRnZXMiLCJmYWNlU25hcHBpbmdXaXRoVG9wb2xvZ3kiLCJub3JtYWxNYXRyaXgiLCJNYXRyaXgzIiwiZ2V0Tm9ybWFsTWF0cml4IiwiZmFjZU5vcm1hbCIsIm5vcm1hbCIsImFwcGx5TWF0cml4MyIsIm5vcm1hbGl6ZSIsImVkZ2VTbmFwcGluZ1dpdGhUb3BvbG9neSIsInZlcnRleFNuYXBwaW5nV2l0aFRvcG9sb2d5Iiwic2V0RGV0ZWN0UmFkaXVzIiwiZm9yY2VTbmFwVmVydGljZXMiLCJTTkFQX1ZFUlRFWCIsImZvcmNlU25hcEVkZ2VzIiwiZWRnZUlzQ2lyY2xlIiwiY2lyY3VsYXJBcmNDZW50ZXIiLCJjaXJjdWxhckFyY1JhZGl1cyIsInZlcnRpY2VzIiwiU05BUF9DSVJDVUxBUkFSQyIsImVkZ2VJc0N1cnZlZCIsIlNOQVBfQ1VSVkVERURHRSIsIlNOQVBfRURHRSIsImZhY2VJc0N1cnZlZCIsIlNOQVBfQ1VSVkVERkFDRSIsIlNOQVBfRkFDRSIsIl9yZWYiLCJpc0xpbmVzIiwiaXNXaWRlTGluZXMiLCJleHRyYWN0TGluZUdlb21ldHJ5IiwiYXBwbHlNYXRyaXg0IiwidmVydGV4U25hcHBpbmciLCJGYWNlMyIsImZhY2VTbmFwcGluZyIsImVkZ2VTbmFwcGluZyIsIl9yZWYyIiwidkEiLCJ2QiIsInZDIiwiZ2VvbSIsIkdlb21ldHJ5IiwiaW5kZXgiLCJpbmRleExpc3QiLCJmYWNlSWQiLCJqIiwiYyIsInJlYWRWZXJ0ZXgiLCJ2SW5kZXgiLCJpbmRpY2VzIiwiaWIiLCJvZmZzZXRzIiwiZ3JvdXBzIiwiY291bnQiLCJ2YSIsIm9pIiwiVHJpYW5nbGUiLCJnZXROb3JtYWwiLCJnZXRUcmlhbmdsZXNPblNhbWVGYWNlIiwicmVhZFZlcnRleENCIiwiZmFjZVZlcnRleDEiLCJmYWNlVmVydGV4MiIsImZhY2VWZXJ0ZXgzIiwiaW50ZXJzZWN0RmFjZSIsInByZWNpc2lvblBvaW50cyIsInByZWNpc2lvbiIsInBvdyIsInRyaWFuZ2xlc0FyciIsImVkZ2VzTWFwIiwiZmlyc3RUcmlhbmdsZSIsImtleXMiLCJyb3VuZCIsInRyaWFuZ2xlIiwia2V5MSIsImtleTIiLCJkZWZhdWx0RWRnZSIsImVkZ2UiLCJ0cmlhbmdsZXMiLCJxdWV1ZSIsInZpc2l0ZWQiLCJTZXQiLCJjb25uZWN0ZWRGYWNlcyIsImN1cnJlbnRGYWNlIiwic2hpZnQiLCJoYXMiLCJhZGQiLCJmb3JFYWNoIiwidCIsImZpbmFsVmVydGljZXMiLCJmYWNlSWR4IiwiX3JlZjMiLCJlZGdlR2VvbSIsIm1pbkRpc3RUb3BvSW5kZXgiLCJtaW5EaXN0IiwiayIsInZLMCIsInZLMSIsInZlcnRpY2VzTGVuZ3RoIiwiaXNFZGdlXzEyIiwiaXNFZGdlXzEzIiwiaXNFZGdlXzIzIiwicGkwIiwicGkxIiwicGkyIiwicGowIiwicGoxIiwicGoyIiwiZWRnZVZlcnRpY2VzIiwibWluRGlzdEluZGV4IiwibGluZUdlb20iLCJnZXRDb25uZWN0ZWRMaW5lU2VnbWVudHNPblNhbWVMaW5lIiwic2xpY2UiLCJ2Q291bnQiLCJWMCIsIlYxIiwiY2kiLCJzcGxpY2UiLCJkaXN0MSIsImRpc3QyIiwicHQiLCJkaXZpZGVTY2FsYXIiLCJWMiIsImZOMSIsInZBMSIsImZOMiIsInZBMiIsImFuZ2xlVmVjdG9yMiIsInZlY3RvciIsImF0YW4iLCJQSSIsImNyZWF0ZUVsbGlwdGljYWxBcmNHZW9tZXRyeSIsImN4IiwiY3kiLCJyeCIsInJ5IiwibnVtUG9pbnRzIiwiRXh0ZW5zaW9ucyIsIkNvbXBHZW9tIiwiZ2V0RWxsaXBzZUFyY1BvaW50IiwiR2VvbWV0cnlDYWxsYmFjayIsInNuYXBwZXIiLCJhRGV0ZWN0UmFkaXVzIiwiY2lyY3VsYXJBcmMiLCJlbGxpcHRpY2FsQXJjIiwiZWxsaXB0aWNhbEFyY0NlbnRlciIsIm1hdHJpeCIsInZwSWRMaW5lIiwidnBJZENpcmN1bGFyIiwidnBJZEVsbGlwdGljYWwiLCJkZXRlY3RSYWRpdXMiLCJzbmFwQ2FuZGlkYXRlcyIsIm9uTGluZVNlZ21lbnQiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIm9uQ2lyY3VsYXJBcmMiLCJzdWIiLCJwb2ludE9uQXJjIiwiYW5nbGUiLCJhcmMiLCJDaXJjbGVHZW9tZXRyeSIsIm1ha2VUcmFuc2xhdGlvbiIsIm9uRWxsaXB0aWNhbEFyYyIsIm1ham9yIiwibWlub3IiLCJ0aWx0IiwibWFqb3IxIiwibWlub3IxIiwibWFqb3IyIiwibWlub3IyIiwiZXF1YXRpb24xIiwiZXF1YXRpb24yIiwicG9wIiwibmVhcmVzdFBvaW50IiwibmVhcmVzdFZlcnRleEluVmVydGV4VG9FZGdlIiwibWFrZUVsbGlwdGljYWxBcmMiLCJzZXRNYXRyaXgiLCJzbmFwcGluZzJEIiwiaGl0UmVzdWx0IiwiYXJndW1lbnRzIiwiaXMzZCIsInRyIiwic2NhbGUiLCJpbXBsIiwiaXMyZCIsImdldE1vZGVsVG9WaWV3ZXJUcmFuc2Zvcm0iLCJnZXRNYXhTY2FsZU9uQXhpcyIsImdldEludmVyc2VNb2RlbFRvVmlld2VyVHJhbnNmb3JtIiwic3VwcG9ydHNHZW9tU25hcHBpbmciLCJnYyIsImVudW1TZWdtZW50cyIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJBcnJheSIsImlzQXJyYXkiLCJtZXNoIiwiZ2V0UmVuZGVyUHJveHkiLCJ2YnIiLCJlbnVtR2VvbXNGb3JPYmplY3QiLCJyZXZlcnNlTWFwRGJJZEZvcjJEIiwiZmluaXNoU25hcHBpbmcyRCIsIlJBU1RFUl9QSVhFTCIsIl9zbmFwUmVzdWx0JGdlb21FZGdlIiwiX3NuYXBSZXN1bHQkZ2VvbUVkZ2UyIiwicmVzdWx0cyIsIm4iLCJyZXMiLCJzbmFwcGluZzJET3ZlcmxheSIsIm1lc2hlcyIsImVudW1HZW9tcyIsImlzU2FtZVZpZXdwb3J0IiwiaW50ZXJzZWN0U25hcCIsInZpZXdwb3J0SW5kZXgyZCIsIlNOQVBfSU5URVJTRUNUSU9OIiwibGluZVN0cmlwVG9QaWVjZXMiLCJnZXRBdHRyaWJ1dGUiLCJtaWQiLCJhZGRWZWN0b3JzIiwibWQiLCJzZCIsImVkIiwiU05BUF9DSVJDTEVfQ0VOVEVSIiwic25hcHBpbmdSYXN0ZXJQaXhlbCIsInNuYXBNaWRwb2ludCIsImlzTWlkcG9pbnQiLCJtaWRwb2ludCIsImN1dFBsYW5lcyIsImdldEFsbEN1dFBsYW5lcyIsInciLCJTTkFQX01JRFBPSU5UIiwic2V0UGVycGVuZGljdWxhciIsImlzUGVycGVuZGljdWxhciIsIm5hdmFwaSIsIm5hdmlnYXRpb24iLCJjYW1lcmEiLCJnZXRDYW1lcmEiLCJnZXRQb3NpdGlvbiIsImlzUGVyc3BlY3RpdmUiLCJnZXRFeWVWZWN0b3IiLCJmb3YiLCJnZXRWZXJ0aWNhbEZvdiIsIndvcmxkSGVpZ2h0IiwidGFuIiwiZGVnVG9SYWQiLCJ2aWV3cG9ydCIsImdldFNjcmVlblZpZXdwb3J0IiwiX3dpbmRvdyIsImdldFdpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJoZWlnaHQiLCJoYW5kbGVCdXR0b25Eb3duIiwiaGFuZGxlQnV0dG9uVXAiLCJoYW5kbGVNb3VzZU1vdmUiLCJldmVudCIsIm9uTW91c2VNb3ZlIiwiY2FudmFzWCIsImNhbnZhc1kiLCJoYW5kbGVTaW5nbGVUYXAiLCJoYW5kbGVQcmVzc0hvbGQiLCJoYW5kbGVHZXN0dXJlIiwib25Nb3VzZURvd24iLCJtb3VzZVBvc2l0aW9uIiwiX3Jlc3VsdCRtb2RlbCIsIl92aWV3ZXIkbW9kZWwiLCJzbmFwcGluZ0hpdFRlc3QiLCJ2cFZlYyIsImNsaWVudFRvVmlld3BvcnQiLCJpbnRlcnNlY3RHcm91bmRWaWV3cG9ydCIsImlzTGVhZmxldCIsImlzUGl4ZWxTbmFwIiwiR2xvYmFsTWFuYWdlck1peGluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./extensions/Snapping/Snapper.js\n");

/***/ }),

/***/ "./extensions/Snapping/SnapperIndicator.js":
/*!*************************************************!*\
  !*** ./extensions/Snapping/SnapperIndicator.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullSnapperIndicator: () => (/* binding */ NullSnapperIndicator),\n/* harmony export */   SnapperIndicator: () => (/* binding */ SnapperIndicator),\n/* harmony export */   getXYZFromPos: () => (/* binding */ getXYZFromPos)\n/* harmony export */ });\nconst MeasureCommon = Autodesk.Viewing.MeasureCommon;\nconst isEqualVectors = MeasureCommon.isEqualVectors;\nconst EPSILON = MeasureCommon.EPSILON;\nconst SnapType = MeasureCommon.SnapType;\n\nconst NO_OVERLAY = 0;\nconst FACE_OVERLAY = 1;\nconst EDGE_OVERLAY = 2;\nconst POINT_OVERLAY = 3;\n\nconst GEOMETRIES_OVERLAY = 'MeasureTool-snapper-geometries';\nconst INDICATOR_OVERLAY = 'MeasureTool-snapper-indicator';\n\nconst _geometryLineWidth = 0.3;\nconst _indicatorLineWidth = 0.2;\nconst _indicatorSize = 1.2;\nconst _indicatorColor = 0xff7700;\nconst _geometryColor = 0x00CC00;\n\nlet _point = null;\n\nconst tmpVec3 = new THREE.Vector3();\n/**\n *\n * @param {BufferAttribute} positionAttribute\n * @param {number} idx\n * @returns {THREE.Vector3} Vector3 corresponding to the indicated index. The returned value will be overriden by\n * subsequent calls\n */\nfunction getXYZFromPos(positionAttribute, idx) {\n  tmpVec3.x = positionAttribute.getX(idx);\n  tmpVec3.y = positionAttribute.getY(idx);\n  tmpVec3.z = positionAttribute.getZ(idx);\n  return tmpVec3;\n}\n\nclass NullSnapperIndicator {\n  isNull() {\n    return true;\n  }\n\n  render() {}\n  removeOverlay(overlayName) {}\n  clearOverlay(overlayName) {}\n  clearOverlays() {}\n  addOverlay(overlayName, mesh) {}\n  drawFace(geom, material, overlayName) {}\n  cylinderMesh(pointX, pointY, material, width) {\n    return new THREE.Mesh();\n  }\n  renderGeometry(snapResult) {}\n  renderVertexIndicator(snapResult) {}\n  renderMidpointIndicator(snapResult) {}\n  renderEdgeIndicator(snapResult) {}\n  renderCircleIndicator(snapResult) {}\n  renderPerpendicular(snapResult) {}\n  renderPixelIndicator(snapResult) {}\n  renderIndicator(snapResult) {}\n  drawLine(geom, material, width, overlayName) {}\n  drawPoint(point, material, overlayName) {}\n  drawCircle(point, material, overlayName) {}\n  setScale(point) {\n    return 1;\n  }\n  setPointScale(pointMesh) {}\n  setCircleScale(torusMesh) {}\n  setEdgeScale(cylinderMesh) {}\n  updatePointScale(overlayName) {}\n  updateEdgeScale(overlayName) {}\n  onCameraChange() {}\n  destroy() {}\n}\n\nclass SnapperIndicator extends NullSnapperIndicator {\n  constructor(viewer, snapper) {\n    super();\n\n    this.viewer = viewer;\n    this.snapper = snapper;\n    this.overlayType = NO_OVERLAY;\n    this.previewsIntersectPoint = null;\n\n    this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n    this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n    this.geometryMaterial = new THREE.MeshPhongMaterial({\n      color: _geometryColor,\n      opacity: 0.5,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false,\n      side: THREE.DoubleSide\n    });\n\n    this.indicatorMaterial = new THREE.MeshBasicMaterial({\n      color: _indicatorColor,\n      opacity: 1,\n      transparent: false,\n      depthTest: false,\n      depthWrite: false,\n      side: THREE.DoubleSide\n    });\n  }\n\n  isNull() {\n    return false;\n  }\n\n  render() {\n\n    const snapResult = this.snapper.getSnapResult();\n\n    if (!isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {\n      this.clearOverlay(GEOMETRIES_OVERLAY);\n    }\n\n    this.clearOverlay(INDICATOR_OVERLAY);\n\n    if (snapResult.isEmpty())\n    return;\n\n    if (this.snapper.renderSnappedGeometry ||\n    snapResult.hasTopology && this.snapper.renderSnappedTopology) {\n      this.renderGeometry(snapResult);\n    }\n    this.renderIndicator(snapResult);\n\n    this.previewsIntersectPoint = snapResult.intersectPoint.clone();\n  }\n\n  removeOverlay(overlayName) {\n\n    this.viewer.impl.clearOverlay(overlayName, true);\n    this.viewer.impl.removeOverlayScene(overlayName);\n\n  }\n\n  clearOverlay(overlayName) {\n\n    this.removeOverlay(overlayName);\n    this.viewer.impl.createOverlayScene(overlayName);\n\n  }\n\n  clearOverlays() {\n\n    this.removeOverlay(GEOMETRIES_OVERLAY);\n    this.viewer.impl.createOverlayScene(GEOMETRIES_OVERLAY);\n\n    this.removeOverlay(INDICATOR_OVERLAY);\n    this.viewer.impl.createOverlayScene(INDICATOR_OVERLAY);\n\n    this.previewsIntersectPoint = null;\n\n  }\n\n  addOverlay(overlayName, mesh) {\n\n    this.viewer.impl.addOverlay(overlayName, mesh);\n\n  }\n\n  /**\n   * Draw the planar face\n   * @param geom - Geometry which needs to be draw.\n   * @param material - Material for the geometry.\n   * @param overlayName - Name of the overlay.\n   */\n  drawFace(geom, material, overlayName) {\n\n    const snapperPlane = new THREE.Mesh(geom, material, true);\n\n    if (overlayName === GEOMETRIES_OVERLAY) {\n      this.overlayType = FACE_OVERLAY;\n    }\n\n    this.addOverlay(overlayName, snapperPlane);\n\n  }\n\n  cylinderMesh(pointX, pointY, material, width) {\n\n    const direction = new THREE.Vector3().subVectors(pointY, pointX);\n    const orientation = new THREE.Matrix4();\n    orientation.lookAt(pointX, pointY, new THREE.Object3D().up);\n    orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,\n    0, 0, 1, 0,\n    0, -direction.length(), 0, 0,\n    0, 0, 0, 1));\n\n    width = width || 0.5;\n    let cylinder = new THREE.CylinderGeometry(width, width, 1.0, 8, 1, true);\n    const edge = new THREE.Mesh(cylinder, material);\n    cylinder = null;\n\n    edge.applyMatrix4(orientation);\n    edge.position.x = (pointY.x + pointX.x) / 2;\n    edge.position.y = (pointY.y + pointX.y) / 2;\n    edge.position.z = (pointY.z + pointX.z) / 2;\n    return edge;\n  }\n\n  renderGeometry(snapResult) {\n\n    if (isEqualVectors(this.previewsIntersectPoint, snapResult.intersectPoint, EPSILON)) {\n      return;\n    }\n\n    switch (snapResult.geomType) {\n      case SnapType.SNAP_VERTEX:\n        SnapType.RASTER_PIXEL;\n        this.drawPoint(snapResult.geomVertex, this.geometryMaterial, GEOMETRIES_OVERLAY);\n        break;\n\n      case SnapType.SNAP_EDGE:\n      case SnapType.SNAP_CURVEDEDGE:\n      case SnapType.SNAP_CIRCULARARC:\n      case SnapType.SNAP_MIDPOINT:\n        this.drawLine(snapResult.geomEdge, this.geometryMaterial, _geometryLineWidth, GEOMETRIES_OVERLAY);\n        break;\n\n      case SnapType.SNAP_FACE:\n      case SnapType.SNAP_CURVEDFACE:\n        this.drawFace(snapResult.geomFace, this.geometryMaterial, GEOMETRIES_OVERLAY);\n        break;\n    }\n  }\n\n  /**\n   * Renders a square around the given snap result.\n   * Is used when youre snapping on a vertex, intersection, circular\n   * arc on a F2D sheet, and the curved face.\n   * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n   */\n  renderVertexIndicator(snapResult) {\n\n    const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n    const scale = this.setScale(pos);\n    const length = _indicatorSize * scale;\n\n    const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n    const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n    const geom = new THREE.BufferGeometry();\n\n    const vertices = [];\n    const p = new THREE.Vector3();\n\n    // Upper line\n    p.addVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.subVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[1] = p.clone();\n\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Bottom line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Left line\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.subVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Right line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.addVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  }\n\n  /**\n   * Renders a triangle around the given snap result\n   * on a midpoint\n   * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n   */\n  renderMidpointIndicator(snapResult) {\n\n    const pos = snapResult.geomVertex;\n    const scale = this.setScale(pos);\n    const length = _indicatorSize * scale;\n\n    const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n    const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n    const geom = new THREE.BufferGeometry();\n    const vertices = [];\n    const p = new THREE.Vector3();\n\n    // Bottom line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Left line\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.addVectors(pos, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Right line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.addVectors(pos, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  }\n\n  /**\n   * Renders an upside-down Y around the given snap result\n   * on an edge or a curved edge..\n   * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n   */\n  renderEdgeIndicator(snapResult) {\n\n    const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n    const scale = this.setScale(pos);\n    const length = _indicatorSize * scale;\n\n    const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n    const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n    const geom = new THREE.BufferGeometry();\n    const vertices = [];\n    const p = new THREE.Vector3();\n\n    // Bottom line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Left line\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Right line\n    p.addVectors(pos, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  }\n\n  /**\n   * Renders an circle on a center of a circle\n   * and circular arc for other than F2D sheets.\n   * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n   */\n  renderCircleIndicator(snapResult) {\n\n    const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n    this.drawCircle(pos, this.indicatorMaterial, INDICATOR_OVERLAY);\n\n  }\n\n  /**\n   * Renders an right-angle ( |_ ) indicator around the given snap result\n   * when the result is perpendicular.\n   * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n   */\n  renderPerpendicular(snapResult) {\n\n    const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n    const scale = this.setScale(pos);\n    const length = _indicatorSize * scale;\n\n    const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n    const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n    const geom = new THREE.BufferGeometry();\n    const vertices = [];\n    const p = new THREE.Vector3();\n\n    // Upper line\n    vertices[0] = pos.clone();\n    p.subVectors(pos, rightVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Bottom line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Left line\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    p.subVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Right line\n    vertices[0] = pos.clone();\n    p.subVectors(pos, upVec);\n    vertices[1] = p.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  }\n\n  /**\n   * Renders an X around the given snap result.\n   * Usually shown when using \"Free Measure\" mode is enabled.\n   * @param {Autodesk.Viewing.MeasureCommon.SnapResult} snapResult\n   */\n  renderPixelIndicator(snapResult) {\n\n    const pos = MeasureCommon.getSnapResultPosition(snapResult, this.viewer);\n    const scale = this.setScale(pos);\n    const length = _indicatorSize * scale;\n\n    const rightVec = this.viewer.navigation.getCameraRightVector().multiplyScalar(length);\n    const upVec = this.viewer.navigation.getCameraUpVector().multiplyScalar(length);\n\n    const geom = new THREE.BufferGeometry();\n    const vertices = [];\n    const p = new THREE.Vector3();\n\n    // Top-left line\n    p.subVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Top-right line\n    p.addVectors(pos, rightVec);\n    p.addVectors(p, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Bottom-right line\n    p.addVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n    // Bottom-left line\n    p.subVectors(pos, rightVec);\n    p.subVectors(p, upVec);\n    vertices[0] = p.clone();\n    vertices[1] = pos.clone();\n    geom.setFromPoints(vertices);\n    this.drawLine(geom, this.indicatorMaterial, _indicatorLineWidth, INDICATOR_OVERLAY);\n\n  }\n\n  renderIndicator(snapResult) {\n\n    if (snapResult.isPerpendicular) {\n      this.renderPerpendicular(snapResult);\n      return;\n    }\n\n    if (snapResult.snapToArc) {\n      if (snapResult.isArc && snapResult.geomType === SnapType.SNAP_CIRCULARARC && this.viewer.model.is2d() && !this.viewer.model.isPdf()) {\n        this.renderVertexIndicator(snapResult);\n      }\n      return;\n    }\n\n\n    switch (snapResult.geomType) {\n      case SnapType.SNAP_VERTEX:\n      case SnapType.SNAP_INTERSECTION:\n        this.renderVertexIndicator(snapResult);\n        break;\n\n      case SnapType.SNAP_MIDPOINT:\n        this.renderMidpointIndicator(snapResult);\n        break;\n\n      case SnapType.SNAP_CIRCLE_CENTER:\n        this.renderCircleIndicator(snapResult);\n        break;\n\n      case SnapType.SNAP_EDGE:\n      case SnapType.SNAP_CURVEDEDGE:\n        this.renderEdgeIndicator(snapResult);\n        break;\n\n      case SnapType.SNAP_CIRCULARARC:\n        if (this.viewer.model.is2d()) {\n          this.renderVertexIndicator(snapResult);\n        } else {\n          this.renderCircleIndicator(snapResult);\n        }\n        break;\n\n      case SnapType.SNAP_FACE:\n      case SnapType.SNAP_CURVEDFACE:\n        this.renderVertexIndicator(snapResult);\n        break;\n\n      case SnapType.RASTER_PIXEL:\n        this.renderPixelIndicator(snapResult);\n        break;\n    }\n  }\n\n  /**\n   * Draws a line in an overlyay\n   * @param {THREE.Geometry|THREE.BufferGeometry} geom\n   * @param {THREE.Material} material\n   * @param {number} width\n   * @param {string} overlayName\n   */\n  drawLine(geom, material, width, overlayName) {\n\n    // Line Pieces\n    if (overlayName === GEOMETRIES_OVERLAY) {\n      this.overlayType = EDGE_OVERLAY;\n    }\n\n    let verticesLength, geomPos;\n    if (geom instanceof THREE.Geometry) {\n      console.warn('SnapperIndicator.drawLine(geom, material, width, overlayName): THREE.Geometry has been depecrated and the geom argument should use a THREE.BufferGeometry instead');\n      verticesLength = geom.vertices.length;\n    } else {\n      geomPos = geom.getAttribute('position');\n      verticesLength = geomPos.count;\n    }\n    for (let i = 0; i < verticesLength; i += 2) {\n      let cylinder;\n      if (geom instanceof THREE.Geometry) {\n        cylinder = this.cylinderMesh(geom.vertices[i], geom.vertices[i + 1], material, width);\n      } else {\n        cylinder = this.cylinderMesh(getXYZFromPos(geomPos, i).clone(), getXYZFromPos(geomPos, i + 1).clone(), material, width);\n      }\n      this.setEdgeScale(cylinder);\n      this.addOverlay(overlayName, cylinder);\n    }\n  }\n\n  drawPoint(point, material, overlayName) {\n\n    // Because every point is snappable in PDFs, don't display the green dot for PDFs.\n    if (this.viewer.model.isLeaflet()) {\n      return;\n    }\n\n    if (!_point)\n    _point = new THREE.SphereGeometry(1.0);\n\n    const pointMesh = new THREE.Mesh(_point, material);\n    pointMesh.position.set(point.x, point.y, point.z);\n\n    this.setPointScale(pointMesh);\n\n    if (overlayName === GEOMETRIES_OVERLAY) {\n      this.overlayType = POINT_OVERLAY;\n    }\n\n    this.addOverlay(overlayName, pointMesh);\n\n  }\n\n  drawCircle(point, material, overlayName) {\n\n    let torus = new THREE.TorusGeometry(_indicatorSize, _indicatorLineWidth, 2, 20);\n    const torusMesh = new THREE.Mesh(torus, material);\n    torusMesh.lookAt(this.viewer.navigation.getEyeVector().normalize());\n    torus = null;\n\n    torusMesh.position.set(point.x, point.y, point.z);\n\n    this.setCircleScale(torusMesh);\n\n    this.addOverlay(overlayName, torusMesh);\n\n  }\n\n  setScale(point) {\n\n    const pixelSize = 5;\n\n    const navapi = this.viewer.navigation;\n    const camera = navapi.getCamera();\n    const position = navapi.getPosition();\n\n    const p = point.clone();\n\n    const distance = camera.isPerspective ? p.sub(position).length() :\n    navapi.getEyeVector().length();\n\n    const fov = navapi.getVerticalFov();\n    const worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));\n\n    const viewport = navapi.getScreenViewport();\n    const scale = pixelSize * worldHeight / viewport.height;\n\n    return scale;\n  }\n\n  setPointScale(pointMesh) {\n\n    const scale = this.setScale(pointMesh.position);\n    pointMesh.scale.x = scale;\n    pointMesh.scale.y = scale;\n    pointMesh.scale.z = scale;\n\n  }\n\n  setCircleScale(torusMesh) {\n\n    const scale = this.setScale(torusMesh.position);\n    torusMesh.scale.x = scale;\n    torusMesh.scale.y = scale;\n  }\n\n  setEdgeScale(cylinderMesh) {\n\n    const scale = this.setScale(cylinderMesh.position);\n    cylinderMesh.scale.x = scale;\n    cylinderMesh.scale.z = scale;\n  }\n\n  updatePointScale(overlayName) {\n\n    if (this.overlayType !== POINT_OVERLAY)\n    return;\n\n    const overlay = this.viewer.impl.overlayScenes[overlayName];\n    if (overlay) {\n      const scene = overlay.scene;\n\n      for (let i = 0; i < scene.children.length; i++) {\n        const pointMesh = scene.children[i];\n        if (pointMesh) {\n\n          this.setPointScale(pointMesh);\n        }\n      }\n    }\n  }\n\n  updateEdgeScale(overlayName) {\n\n    if (this.overlayType !== EDGE_OVERLAY)\n    return;\n\n    const overlay = this.viewer.impl.overlayScenes[overlayName];\n    if (overlay) {\n      const scene = overlay.scene;\n\n      for (let i = 0; i < scene.children.length; i++) {\n        const cylinderMesh = scene.children[i];\n        if (cylinderMesh) {\n\n          this.setEdgeScale(cylinderMesh);\n        }\n      }\n    }\n  }\n\n  onCameraChange() {\n\n    this.updatePointScale(GEOMETRIES_OVERLAY);\n    this.updateEdgeScale(GEOMETRIES_OVERLAY);\n\n    // if (!this.snapper.markupMode) {\n    this.render();\n    // }\n  }\n\n  destroy() {\n\n    this.removeOverlay(GEOMETRIES_OVERLAY);\n    this.removeOverlay(INDICATOR_OVERLAY);\n\n    if (_point) {\n      _point.dispose();\n      _point = null;\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1NuYXBwaW5nL1NuYXBwZXJJbmRpY2F0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBTUEsYUFBYSxHQUFHQyxRQUFRLENBQUNDLE9BQU8sQ0FBQ0YsYUFBYTtBQUNwRCxNQUFNRyxjQUFjLEdBQUdILGFBQWEsQ0FBQ0csY0FBYztBQUNuRCxNQUFNQyxPQUFPLEdBQUdKLGFBQWEsQ0FBQ0ksT0FBTztBQUNyQyxNQUFNQyxRQUFRLEdBQUdMLGFBQWEsQ0FBQ0ssUUFBUTs7QUFFdkMsTUFBTUMsVUFBVSxHQUFHLENBQUM7QUFDcEIsTUFBTUMsWUFBWSxHQUFHLENBQUM7QUFDdEIsTUFBTUMsWUFBWSxHQUFHLENBQUM7QUFDdEIsTUFBTUMsYUFBYSxHQUFHLENBQUM7O0FBRXZCLE1BQU1DLGtCQUFrQixHQUFHLGdDQUFnQztBQUMzRCxNQUFNQyxpQkFBaUIsR0FBRywrQkFBK0I7O0FBRXpELE1BQU1DLGtCQUFrQixHQUFHLEdBQUc7QUFDOUIsTUFBTUMsbUJBQW1CLEdBQUcsR0FBRztBQUMvQixNQUFNQyxjQUFjLEdBQUcsR0FBRztBQUMxQixNQUFNQyxlQUFlLEdBQUcsUUFBUTtBQUNoQyxNQUFNQyxjQUFjLEdBQUcsUUFBUTs7QUFFL0IsSUFBSUMsTUFBTSxHQUFHLElBQUk7O0FBRWpCLE1BQU1DLE9BQU8sR0FBRyxJQUFJQyxLQUFLLENBQUNDLE9BQU8sQ0FBQyxDQUFDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0MsYUFBYUEsQ0FBQ0MsaUJBQWlCLEVBQUVDLEdBQUcsRUFBRTtFQUNsREwsT0FBTyxDQUFDTSxDQUFDLEdBQUdGLGlCQUFpQixDQUFDRyxJQUFJLENBQUNGLEdBQUcsQ0FBQztFQUN2Q0wsT0FBTyxDQUFDUSxDQUFDLEdBQUdKLGlCQUFpQixDQUFDSyxJQUFJLENBQUNKLEdBQUcsQ0FBQztFQUN2Q0wsT0FBTyxDQUFDVSxDQUFDLEdBQUdOLGlCQUFpQixDQUFDTyxJQUFJLENB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QUN1QixZQUFZLENBQUN2QixZQUFZLENBQUM7UUFDbkM7TUFDSjtJQUNKO0VBQ0o7O0VBRUEwQixjQUFjQSxDQUFBLEVBQUc7O0lBRWIsSUFBSSxDQUFDRixnQkFBZ0IsQ0FBQ3hELGtCQUFrQixDQUFDO0lBQ3pDLElBQUksQ0FBQ3lELGVBQWUsQ0FBQ3pELGtCQUFrQixDQUFDOztJQUV4QztJQUNJLElBQUksQ0FBQ3NCLE1BQU0sQ0FBQyxDQUFDO0lBQ2pCO0VBQ0o7O0VBRUFxQyxPQUFPQSxDQUFBLEVBQUc7O0lBRU4sSUFBSSxDQUFDcEMsYUFBYSxDQUFDdkIsa0JBQWtCLENBQUM7SUFDdEMsSUFBSSxDQUFDdUIsYUFBYSxDQUFDdEIsaUJBQWlCLENBQUM7O0lBRXJDLElBQUlNLE1BQU0sRUFBRTtNQUNSQSxNQUFNLENBQUNxSyxPQUFPLENBQUMsQ0FBQztNQUNoQnJLLE1BQU0sR0FBRyxJQUFJO0lBQ2pCO0VBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL0F1dG9kZXNrLkV4dGVuc2lvbnMvLi9leHRlbnNpb25zL1NuYXBwaW5nL1NuYXBwZXJJbmRpY2F0b3IuanM/NTZlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNZWFzdXJlQ29tbW9uID0gQXV0b2Rlc2suVmlld2luZy5NZWFzdXJlQ29tbW9uO1xuY29uc3QgaXNFcXVhbFZlY3RvcnMgPSBNZWFzdXJlQ29tbW9uLmlzRXF1YWxWZWN0b3JzO1xuY29uc3QgRVBTSUxPTiA9IE1lYXN1cmVDb21tb24uRVBTSUxPTjtcbmNvbnN0IFNuYXBUeXBlID0gTWVhc3VyZUNvbW1vbi5TbmFwVHlwZTtcblxuY29uc3QgTk9fT1ZFUkxBWSA9IDA7XG5jb25zdCBGQUNFX09WRVJMQVkgPSAxO1xuY29uc3QgRURHRV9PVkVSTEFZID0gMjtcbmNvbnN0IFBPSU5UX09WRVJMQVkgPSAzO1xuXG5jb25zdCBHRU9NRVRSSUVTX09WRVJMQVkgPSAnTWVhc3VyZVRvb2wtc25hcHBlci1nZW9tZXRyaWVzJztcbmNvbnN0IElORElDQVRPUl9PVkVSTEFZID0gJ01lYXN1cmVUb29sLXNuYXBwZXItaW5kaWNhdG9yJztcblxuY29uc3QgX2dlb21ldHJ5TGluZVdpZHRoID0gMC4zO1xuY29uc3QgX2luZGljYXRvckxpbmVXaWR0aCA9IDAuMjtcbmNvbnN0IF9pbmRpY2F0b3JTaXplID0gMS4yO1xuY29uc3QgX2luZGljYXRvckNvbG9yID0gMHhmZjc3MDA7XG5jb25zdCBfZ2VvbWV0cnlDb2xvciA9IDB4MDBDQzAwO1xuXG5sZXQgX3BvaW50ID0gbnVsbDtcblxuY29uc3QgdG1wVmVjMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4vKipcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlckF0dHJpYnV0ZX0gcG9zaXRpb25BdHRyaWJ1dGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAqIEByZXR1cm5zIHtUSFJFRS5WZWN0b3IzfSBWZWN0b3IzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGluZGljYXRlZCBpbmRleC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgb3ZlcnJpZGVuIGJ5XG4gKiBzdWJzZXF1ZW50IGNhbGxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRYWVpGcm9tUG9zKHBvc2l0aW9uQXR0cmlidXRlLCBpZHgpIHtcbiAgICB0bXBWZWMzLnggPSBwb3NpdGlvbkF0dHJpYnV0ZS5nZXRYKGlkeCk7XG4gICAgdG1wVmVjMy55ID0gcG9zaXRpb25BdHRyaWJ1dGUuZ2V0WShpZHgpO1xuICAgIHRtcFZlYzMueiA9IHBvc2l0aW9uQXR0cmlidXRlLmdldFooaWR4KTtcbiAgICByZXR1cm4gdG1wVmVjMztcbn1cblxuZXhwb3J0IGNsYXNzIE51bGxTbmFwcGVySW5kaWNhdG9yIHtcbiAgICBpc051bGwoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHt9XG4gICAgcmVtb3ZlT3ZlcmxheShvdmVybGF5TmFtZSkge31cbiAgICBjbGVhck92ZXJsYXkob3ZlcmxheU5hbWUpIHt9XG4gICAgY2xlYXJPdmVybGF5cygpIHt9XG4gICAgYWRkT3ZlcmxheShvdmVybGF5TmFtZSwgbWVzaCkge31cbiAgICBkcmF3RmFjZShnZW9tLCBtYXRlcmlhbCwgb3ZlcmxheU5hbWUpIHt9XG4gICAgY3lsaW5kZXJNZXNoKHBvaW50WCwgcG9pbnRZLCBtYXRlcmlhbCwgd2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NZXNoKCk7XG4gICAgfVxuICAgIHJlbmRlckdlb21ldHJ5KHNuYXBSZXN1bHQpIHt9XG4gICAgcmVuZGVyVmVydGV4SW5kaWNhdG9yKHNuYXBSZXN1bHQpIHt9XG4gICAgcmVuZGVyTWlkcG9pbnRJbmRpY2F0b3Ioc25hcFJlc3VsdCkge31cbiAgICByZW5kZXJFZGdlSW5kaWNhdG9yKHNuYXBSZXN1bHQpIHt9XG4gICAgcmVuZGVyQ2lyY2xlSW5kaWNhdG9yKHNuYXBSZXN1bHQpIHt9XG4gICAgcmVuZGVyUGVycGVuZGljdWxhcihzbmFwUmVzdWx0KSB7fVxuICAgIHJlbmRlclBpeGVsSW5kaWNhdG9yKHNuYXBSZXN1bHQpIHt9XG4gICAgcmVuZGVySW5kaWNhdG9yKHNuYXBSZXN1bHQpIHt9XG4gICAgZHJhd0xpbmUoZ2VvbSwgbWF0ZXJpYWwsIHdpZHRoLCBvdmVybGF5TmFtZSkge31cbiAgICBkcmF3UG9pbnQocG9pbnQsIG1hdGVyaWFsLCBvdmVybGF5TmFtZSkge31cbiAgICBkcmF3Q2lyY2xlKHBvaW50LCBtYXRlcmlhbCwgb3ZlcmxheU5hbWUpIHt9XG4gICAgc2V0U2NhbGUocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHNldFBvaW50U2NhbGUocG9pbnRNZXNoKSB7fVxuICAgIHNldENpcmNsZVNjYWxlKHRvcnVzTWVzaCkge31cbiAgICBzZXRFZGdlU2NhbGUoY3lsaW5kZXJNZXNoKSB7fVxuICAgIHVwZGF0ZVBvaW50U2NhbGUob3ZlcmxheU5hbWUpIHt9XG4gICAgdXBkYXRlRWRnZVNjYWxlKG92ZXJsYXlOYW1lKSB7fVxuICAgIG9uQ2FtZXJhQ2hhbmdlKCkge31cbiAgICBkZXN0cm95KCkge31cbn1cblxuZXhwb3J0IGNsYXNzIFNuYXBwZXJJbmRpY2F0b3IgZXh0ZW5kcyBOdWxsU25hcHBlckluZGljYXRvciB7XG4gICAgY29uc3RydWN0b3Iodmlld2VyLCBzbmFwcGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy52aWV3ZXIgPSB2aWV3ZXI7XG4gICAgICAgIHRoaXMuc25hcHBlciA9IHNuYXBwZXI7XG4gICAgICAgIHRoaXMub3ZlcmxheVR5cGUgPSBOT19PVkVSTEFZO1xuICAgICAgICB0aGlzLnByZXZpZXdzSW50ZXJzZWN0UG9pbnQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMudmlld2VyLmltcGwuY3JlYXRlT3ZlcmxheVNjZW5lKEdFT01FVFJJRVNfT1ZFUkxBWSk7XG4gICAgICAgIHRoaXMudmlld2VyLmltcGwuY3JlYXRlT3ZlcmxheVNjZW5lKElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICB0aGlzLmdlb21ldHJ5TWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoe1xuICAgICAgICAgICAgY29sb3I6IF9nZW9tZXRyeUNvbG9yLFxuICAgICAgICAgICAgb3BhY2l0eTogMC41LFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgICAgY29sb3I6IF9pbmRpY2F0b3JDb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlzTnVsbCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcblxuICAgICAgICBjb25zdCBzbmFwUmVzdWx0ID0gdGhpcy5zbmFwcGVyLmdldFNuYXBSZXN1bHQoKTtcblxuICAgICAgICBpZiAoIWlzRXF1YWxWZWN0b3JzKHRoaXMucHJldmlld3NJbnRlcnNlY3RQb2ludCwgc25hcFJlc3VsdC5pbnRlcnNlY3RQb2ludCwgRVBTSUxPTikpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJPdmVybGF5KEdFT01FVFJJRVNfT1ZFUkxBWSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsZWFyT3ZlcmxheShJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICAgICAgaWYgKHNuYXBSZXN1bHQuaXNFbXB0eSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0aGlzLnNuYXBwZXIucmVuZGVyU25hcHBlZEdlb21ldHJ5IHx8XG4gICAgICAgICAgICAoc25hcFJlc3VsdC5oYXNUb3BvbG9neSAmJiB0aGlzLnNuYXBwZXIucmVuZGVyU25hcHBlZFRvcG9sb2d5KSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJHZW9tZXRyeShzbmFwUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlckluZGljYXRvcihzbmFwUmVzdWx0KTtcblxuICAgICAgICB0aGlzLnByZXZpZXdzSW50ZXJzZWN0UG9pbnQgPSBzbmFwUmVzdWx0LmludGVyc2VjdFBvaW50LmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlT3ZlcmxheShvdmVybGF5TmFtZSkge1xuXG4gICAgICAgIHRoaXMudmlld2VyLmltcGwuY2xlYXJPdmVybGF5KG92ZXJsYXlOYW1lLCB0cnVlKTtcbiAgICAgICAgdGhpcy52aWV3ZXIuaW1wbC5yZW1vdmVPdmVybGF5U2NlbmUob3ZlcmxheU5hbWUpO1xuXG4gICAgfVxuXG4gICAgY2xlYXJPdmVybGF5KG92ZXJsYXlOYW1lKSB7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVPdmVybGF5KG92ZXJsYXlOYW1lKTtcbiAgICAgICAgdGhpcy52aWV3ZXIuaW1wbC5jcmVhdGVPdmVybGF5U2NlbmUob3ZlcmxheU5hbWUpO1xuXG4gICAgfVxuXG4gICAgY2xlYXJPdmVybGF5cygpIHtcblxuICAgICAgICB0aGlzLnJlbW92ZU92ZXJsYXkoR0VPTUVUUklFU19PVkVSTEFZKTtcbiAgICAgICAgdGhpcy52aWV3ZXIuaW1wbC5jcmVhdGVPdmVybGF5U2NlbmUoR0VPTUVUUklFU19PVkVSTEFZKTtcblxuICAgICAgICB0aGlzLnJlbW92ZU92ZXJsYXkoSU5ESUNBVE9SX09WRVJMQVkpO1xuICAgICAgICB0aGlzLnZpZXdlci5pbXBsLmNyZWF0ZU92ZXJsYXlTY2VuZShJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICAgICAgdGhpcy5wcmV2aWV3c0ludGVyc2VjdFBvaW50ID0gbnVsbDtcblxuICAgIH1cblxuICAgIGFkZE92ZXJsYXkgKG92ZXJsYXlOYW1lLCBtZXNoKSB7XG5cbiAgICAgICAgdGhpcy52aWV3ZXIuaW1wbC5hZGRPdmVybGF5KG92ZXJsYXlOYW1lLCBtZXNoKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIHBsYW5hciBmYWNlXG4gICAgICogQHBhcmFtIGdlb20gLSBHZW9tZXRyeSB3aGljaCBuZWVkcyB0byBiZSBkcmF3LlxuICAgICAqIEBwYXJhbSBtYXRlcmlhbCAtIE1hdGVyaWFsIGZvciB0aGUgZ2VvbWV0cnkuXG4gICAgICogQHBhcmFtIG92ZXJsYXlOYW1lIC0gTmFtZSBvZiB0aGUgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBkcmF3RmFjZShnZW9tLCBtYXRlcmlhbCwgb3ZlcmxheU5hbWUpIHtcblxuICAgICAgICBjb25zdCBzbmFwcGVyUGxhbmUgPSBuZXcgVEhSRUUuTWVzaChnZW9tLCBtYXRlcmlhbCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKG92ZXJsYXlOYW1lID09PSBHRU9NRVRSSUVTX09WRVJMQVkpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVR5cGUgPSBGQUNFX09WRVJMQVk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZE92ZXJsYXkob3ZlcmxheU5hbWUsIHNuYXBwZXJQbGFuZSk7XG5cbiAgICB9XG5cbiAgICBjeWxpbmRlck1lc2gocG9pbnRYLCBwb2ludFksIG1hdGVyaWFsLCB3aWR0aCkge1xuXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuc3ViVmVjdG9ycyhwb2ludFksIHBvaW50WCk7XG4gICAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgICAgb3JpZW50YXRpb24ubG9va0F0KHBvaW50WCwgcG9pbnRZLCBuZXcgVEhSRUUuT2JqZWN0M0QoKS51cCk7XG4gICAgICAgIG9yaWVudGF0aW9uLm11bHRpcGx5KG5ldyBUSFJFRS5NYXRyaXg0KCkuc2V0KDEsIDAsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAxLCAwLFxuICAgICAgICAgICAgMCwgLWRpcmVjdGlvbi5sZW5ndGgoKSwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEpKTtcblxuICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IDAuNTtcbiAgICAgICAgbGV0IGN5bGluZGVyID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkod2lkdGgsIHdpZHRoLCAxLjAsIDgsIDEsIHRydWUpO1xuICAgICAgICBjb25zdCBlZGdlID0gbmV3IFRIUkVFLk1lc2goY3lsaW5kZXIsIG1hdGVyaWFsKTtcbiAgICAgICAgY3lsaW5kZXIgPSBudWxsO1xuXG4gICAgICAgIGVkZ2UuYXBwbHlNYXRyaXg0KG9yaWVudGF0aW9uKTtcbiAgICAgICAgZWRnZS5wb3NpdGlvbi54ID0gKHBvaW50WS54ICsgcG9pbnRYLngpIC8gMjtcbiAgICAgICAgZWRnZS5wb3NpdGlvbi55ID0gKHBvaW50WS55ICsgcG9pbnRYLnkpIC8gMjtcbiAgICAgICAgZWRnZS5wb3NpdGlvbi56ID0gKHBvaW50WS56ICsgcG9pbnRYLnopIC8gMjtcbiAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgfVxuXG4gICAgcmVuZGVyR2VvbWV0cnkoc25hcFJlc3VsdCkge1xuXG4gICAgICAgIGlmIChpc0VxdWFsVmVjdG9ycyh0aGlzLnByZXZpZXdzSW50ZXJzZWN0UG9pbnQsIHNuYXBSZXN1bHQuaW50ZXJzZWN0UG9pbnQsIEVQU0lMT04pKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoc25hcFJlc3VsdC5nZW9tVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX1ZFUlRFWDpcbiAgICAgICAgICAgICAgICAgU25hcFR5cGUuUkFTVEVSX1BJWEVMO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1BvaW50KHNuYXBSZXN1bHQuZ2VvbVZlcnRleCwgdGhpcy5nZW9tZXRyeU1hdGVyaWFsLCBHRU9NRVRSSUVTX09WRVJMQVkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNuYXBUeXBlLlNOQVBfRURHRTpcbiAgICAgICAgICAgIGNhc2UgU25hcFR5cGUuU05BUF9DVVJWRURFREdFOlxuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX0NJUkNVTEFSQVJDOlxuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX01JRFBPSU5UOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xpbmUoc25hcFJlc3VsdC5nZW9tRWRnZSwgdGhpcy5nZW9tZXRyeU1hdGVyaWFsLCBfZ2VvbWV0cnlMaW5lV2lkdGgsIEdFT01FVFJJRVNfT1ZFUkxBWSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU25hcFR5cGUuU05BUF9GQUNFOlxuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX0NVUlZFREZBQ0U6XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3RmFjZShzbmFwUmVzdWx0Lmdlb21GYWNlLCB0aGlzLmdlb21ldHJ5TWF0ZXJpYWwsIEdFT01FVFJJRVNfT1ZFUkxBWSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgc3F1YXJlIGFyb3VuZCB0aGUgZ2l2ZW4gc25hcCByZXN1bHQuXG4gICAgICogSXMgdXNlZCB3aGVuIHlvdeKAmXJlIHNuYXBwaW5nIG9uIGEgdmVydGV4LCBpbnRlcnNlY3Rpb24sIGNpcmN1bGFyXG4gICAgICogYXJjIG9uIGEgRjJEIHNoZWV0LCBhbmQgdGhlIGN1cnZlZCBmYWNlLlxuICAgICAqIEBwYXJhbSB7QXV0b2Rlc2suVmlld2luZy5NZWFzdXJlQ29tbW9uLlNuYXBSZXN1bHR9IHNuYXBSZXN1bHRcbiAgICAgKi9cbiAgICByZW5kZXJWZXJ0ZXhJbmRpY2F0b3Ioc25hcFJlc3VsdCkge1xuXG4gICAgICAgIGNvbnN0IHBvcyA9IE1lYXN1cmVDb21tb24uZ2V0U25hcFJlc3VsdFBvc2l0aW9uKHNuYXBSZXN1bHQsIHRoaXMudmlld2VyKTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNldFNjYWxlKHBvcyk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IF9pbmRpY2F0b3JTaXplICogc2NhbGU7XG5cbiAgICAgICAgY29uc3QgcmlnaHRWZWMgPSB0aGlzLnZpZXdlci5uYXZpZ2F0aW9uLmdldENhbWVyYVJpZ2h0VmVjdG9yKCkubXVsdGlwbHlTY2FsYXIobGVuZ3RoKTtcbiAgICAgICAgY29uc3QgdXBWZWMgPSB0aGlzLnZpZXdlci5uYXZpZ2F0aW9uLmdldENhbWVyYVVwVmVjdG9yKCkubXVsdGlwbHlTY2FsYXIobGVuZ3RoKTtcblxuICAgICAgICBjb25zdCBnZW9tID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLy8gVXBwZXIgbGluZVxuICAgICAgICBwLmFkZFZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuYWRkVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzBdID0gcC5jbG9uZSgpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuYWRkVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuXG4gICAgICAgIGdlb20uc2V0RnJvbVBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZ2VvbSwgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgX2luZGljYXRvckxpbmVXaWR0aCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgICAgIC8vIEJvdHRvbSBsaW5lXG4gICAgICAgIHAuYWRkVmVjdG9ycyhwb3MsIHJpZ2h0VmVjKTtcbiAgICAgICAgcC5zdWJWZWN0b3JzKHAsIHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMF0gPSBwLmNsb25lKCk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwb3MsIHJpZ2h0VmVjKTtcbiAgICAgICAgcC5zdWJWZWN0b3JzKHAsIHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMV0gPSBwLmNsb25lKCk7XG4gICAgICAgIGdlb20uc2V0RnJvbVBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZ2VvbSwgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgX2luZGljYXRvckxpbmVXaWR0aCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgICAgIC8vIExlZnQgbGluZVxuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzBdID0gcC5jbG9uZSgpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuYWRkVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICAvLyBSaWdodCBsaW5lXG4gICAgICAgIHAuYWRkVmVjdG9ycyhwb3MsIHJpZ2h0VmVjKTtcbiAgICAgICAgcC5zdWJWZWN0b3JzKHAsIHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMF0gPSBwLmNsb25lKCk7XG4gICAgICAgIHAuYWRkVmVjdG9ycyhwb3MsIHJpZ2h0VmVjKTtcbiAgICAgICAgcC5hZGRWZWN0b3JzKHAsIHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMV0gPSBwLmNsb25lKCk7XG4gICAgICAgIGdlb20uc2V0RnJvbVBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZ2VvbSwgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgX2luZGljYXRvckxpbmVXaWR0aCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHRyaWFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gc25hcCByZXN1bHRcbiAgICAgKiBvbiBhIG1pZHBvaW50XG4gICAgICogQHBhcmFtIHtBdXRvZGVzay5WaWV3aW5nLk1lYXN1cmVDb21tb24uU25hcFJlc3VsdH0gc25hcFJlc3VsdFxuICAgICAqL1xuICAgIHJlbmRlck1pZHBvaW50SW5kaWNhdG9yKHNuYXBSZXN1bHQpIHtcblxuICAgICAgICBjb25zdCBwb3MgPSBzbmFwUmVzdWx0Lmdlb21WZXJ0ZXg7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zZXRTY2FsZShwb3MpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBfaW5kaWNhdG9yU2l6ZSAqIHNjYWxlO1xuXG4gICAgICAgIGNvbnN0IHJpZ2h0VmVjID0gdGhpcy52aWV3ZXIubmF2aWdhdGlvbi5nZXRDYW1lcmFSaWdodFZlY3RvcigpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHVwVmVjID0gdGhpcy52aWV3ZXIubmF2aWdhdGlvbi5nZXRDYW1lcmFVcFZlY3RvcigpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XG5cbiAgICAgICAgY29uc3QgZ2VvbSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICBjb25zdCBwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICAvLyBCb3R0b20gbGluZVxuICAgICAgICBwLmFkZFZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzBdID0gcC5jbG9uZSgpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICAvLyBMZWZ0IGxpbmVcbiAgICAgICAgcC5zdWJWZWN0b3JzKHBvcywgcmlnaHRWZWMpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocCwgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1swXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgcC5hZGRWZWN0b3JzKHBvcywgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1sxXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgZ2VvbS5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy5kcmF3TGluZShnZW9tLCB0aGlzLmluZGljYXRvck1hdGVyaWFsLCBfaW5kaWNhdG9yTGluZVdpZHRoLCBJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICAgICAgLy8gUmlnaHQgbGluZVxuICAgICAgICBwLmFkZFZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzBdID0gcC5jbG9uZSgpO1xuICAgICAgICBwLmFkZFZlY3RvcnMocG9zLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW4gdXBzaWRlLWRvd24gWSBhcm91bmQgdGhlIGdpdmVuIHNuYXAgcmVzdWx0XG4gICAgICogb24gYW4gZWRnZSBvciBhIGN1cnZlZCBlZGdlLi5cbiAgICAgKiBAcGFyYW0ge0F1dG9kZXNrLlZpZXdpbmcuTWVhc3VyZUNvbW1vbi5TbmFwUmVzdWx0fSBzbmFwUmVzdWx0XG4gICAgICovXG4gICAgcmVuZGVyRWRnZUluZGljYXRvcihzbmFwUmVzdWx0KSB7XG5cbiAgICAgICAgY29uc3QgcG9zID0gTWVhc3VyZUNvbW1vbi5nZXRTbmFwUmVzdWx0UG9zaXRpb24oc25hcFJlc3VsdCwgdGhpcy52aWV3ZXIpO1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2V0U2NhbGUocG9zKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gX2luZGljYXRvclNpemUgKiBzY2FsZTtcblxuICAgICAgICBjb25zdCByaWdodFZlYyA9IHRoaXMudmlld2VyLm5hdmlnYXRpb24uZ2V0Q2FtZXJhUmlnaHRWZWN0b3IoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuICAgICAgICBjb25zdCB1cFZlYyA9IHRoaXMudmlld2VyLm5hdmlnYXRpb24uZ2V0Q2FtZXJhVXBWZWN0b3IoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuXG4gICAgICAgIGNvbnN0IGdlb20gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLy8gQm90dG9tIGxpbmVcbiAgICAgICAgcC5hZGRWZWN0b3JzKHBvcywgcmlnaHRWZWMpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocCwgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1swXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgdmVydGljZXNbMV0gPSBwb3MuY2xvbmUoKTtcbiAgICAgICAgZ2VvbS5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy5kcmF3TGluZShnZW9tLCB0aGlzLmluZGljYXRvck1hdGVyaWFsLCBfaW5kaWNhdG9yTGluZVdpZHRoLCBJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICAgICAgLy8gTGVmdCBsaW5lXG4gICAgICAgIHAuc3ViVmVjdG9ycyhwb3MsIHJpZ2h0VmVjKTtcbiAgICAgICAgcC5zdWJWZWN0b3JzKHAsIHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMF0gPSBwLmNsb25lKCk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcG9zLmNsb25lKCk7XG4gICAgICAgIGdlb20uc2V0RnJvbVBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZ2VvbSwgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgX2luZGljYXRvckxpbmVXaWR0aCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgICAgIC8vIFJpZ2h0IGxpbmVcbiAgICAgICAgcC5hZGRWZWN0b3JzKHBvcywgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1swXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgdmVydGljZXNbMV0gPSBwb3MuY2xvbmUoKTtcbiAgICAgICAgZ2VvbS5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy5kcmF3TGluZShnZW9tLCB0aGlzLmluZGljYXRvck1hdGVyaWFsLCBfaW5kaWNhdG9yTGluZVdpZHRoLCBJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGFuIGNpcmNsZSBvbiBhIGNlbnRlciBvZiBhIGNpcmNsZVxuICAgICAqIGFuZCBjaXJjdWxhciBhcmMgZm9yIG90aGVyIHRoYW4gRjJEIHNoZWV0cy5cbiAgICAgKiBAcGFyYW0ge0F1dG9kZXNrLlZpZXdpbmcuTWVhc3VyZUNvbW1vbi5TbmFwUmVzdWx0fSBzbmFwUmVzdWx0XG4gICAgICovXG4gICAgcmVuZGVyQ2lyY2xlSW5kaWNhdG9yKHNuYXBSZXN1bHQpe1xuXG4gICAgICAgIGNvbnN0IHBvcyA9IE1lYXN1cmVDb21tb24uZ2V0U25hcFJlc3VsdFBvc2l0aW9uKHNuYXBSZXN1bHQsIHRoaXMudmlld2VyKTtcbiAgICAgICAgdGhpcy5kcmF3Q2lyY2xlKHBvcywgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiByaWdodC1hbmdsZSAoIHxfICkgaW5kaWNhdG9yIGFyb3VuZCB0aGUgZ2l2ZW4gc25hcCByZXN1bHRcbiAgICAgKiB3aGVuIHRoZSByZXN1bHQgaXMgcGVycGVuZGljdWxhci5cbiAgICAgKiBAcGFyYW0ge0F1dG9kZXNrLlZpZXdpbmcuTWVhc3VyZUNvbW1vbi5TbmFwUmVzdWx0fSBzbmFwUmVzdWx0XG4gICAgICovXG4gICAgcmVuZGVyUGVycGVuZGljdWxhcihzbmFwUmVzdWx0KSB7XG5cbiAgICAgICAgY29uc3QgcG9zID0gTWVhc3VyZUNvbW1vbi5nZXRTbmFwUmVzdWx0UG9zaXRpb24oc25hcFJlc3VsdCwgdGhpcy52aWV3ZXIpO1xuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2V0U2NhbGUocG9zKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gX2luZGljYXRvclNpemUgKiBzY2FsZTtcblxuICAgICAgICBjb25zdCByaWdodFZlYyA9IHRoaXMudmlld2VyLm5hdmlnYXRpb24uZ2V0Q2FtZXJhUmlnaHRWZWN0b3IoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuICAgICAgICBjb25zdCB1cFZlYyA9IHRoaXMudmlld2VyLm5hdmlnYXRpb24uZ2V0Q2FtZXJhVXBWZWN0b3IoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuXG4gICAgICAgIGNvbnN0IGdlb20gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLy8gVXBwZXIgbGluZVxuICAgICAgICB2ZXJ0aWNlc1swXSA9IHBvcy5jbG9uZSgpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICAvLyBCb3R0b20gbGluZVxuICAgICAgICBwLmFkZFZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzBdID0gcC5jbG9uZSgpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuc3ViVmVjdG9ycyhwLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICAvLyBMZWZ0IGxpbmVcbiAgICAgICAgcC5zdWJWZWN0b3JzKHBvcywgcmlnaHRWZWMpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocCwgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1swXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgcC5zdWJWZWN0b3JzKHBvcywgcmlnaHRWZWMpO1xuICAgICAgICBwLmFkZFZlY3RvcnMocCwgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1sxXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgZ2VvbS5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy5kcmF3TGluZShnZW9tLCB0aGlzLmluZGljYXRvck1hdGVyaWFsLCBfaW5kaWNhdG9yTGluZVdpZHRoLCBJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICAgICAgLy8gUmlnaHQgbGluZVxuICAgICAgICB2ZXJ0aWNlc1swXSA9IHBvcy5jbG9uZSgpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocG9zLCB1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcC5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW4gWCBhcm91bmQgdGhlIGdpdmVuIHNuYXAgcmVzdWx0LlxuICAgICAqIFVzdWFsbHkgc2hvd24gd2hlbiB1c2luZyBcIkZyZWUgTWVhc3VyZVwiIG1vZGUgaXMgZW5hYmxlZC5cbiAgICAgKiBAcGFyYW0ge0F1dG9kZXNrLlZpZXdpbmcuTWVhc3VyZUNvbW1vbi5TbmFwUmVzdWx0fSBzbmFwUmVzdWx0XG4gICAgICovXG4gICAgcmVuZGVyUGl4ZWxJbmRpY2F0b3Ioc25hcFJlc3VsdCkge1xuXG4gICAgICAgIGNvbnN0IHBvcyA9IE1lYXN1cmVDb21tb24uZ2V0U25hcFJlc3VsdFBvc2l0aW9uKHNuYXBSZXN1bHQsIHRoaXMudmlld2VyKTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNldFNjYWxlKHBvcyk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IF9pbmRpY2F0b3JTaXplICogc2NhbGU7XG5cbiAgICAgICAgY29uc3QgcmlnaHRWZWMgPSB0aGlzLnZpZXdlci5uYXZpZ2F0aW9uLmdldENhbWVyYVJpZ2h0VmVjdG9yKCkubXVsdGlwbHlTY2FsYXIobGVuZ3RoKTtcbiAgICAgICAgY29uc3QgdXBWZWMgPSB0aGlzLnZpZXdlci5uYXZpZ2F0aW9uLmdldENhbWVyYVVwVmVjdG9yKCkubXVsdGlwbHlTY2FsYXIobGVuZ3RoKTtcblxuICAgICAgICBjb25zdCBnZW9tID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIC8vIFRvcC1sZWZ0IGxpbmVcbiAgICAgICAgcC5zdWJWZWN0b3JzKHBvcywgcmlnaHRWZWMpO1xuICAgICAgICBwLmFkZFZlY3RvcnMocCx1cFZlYyk7XG4gICAgICAgIHZlcnRpY2VzWzBdID0gcC5jbG9uZSgpO1xuICAgICAgICB2ZXJ0aWNlc1sxXSA9IHBvcy5jbG9uZSgpO1xuICAgICAgICBnZW9tLnNldEZyb21Qb2ludHModmVydGljZXMpO1xuICAgICAgICB0aGlzLmRyYXdMaW5lKGdlb20sIHRoaXMuaW5kaWNhdG9yTWF0ZXJpYWwsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICAvLyBUb3AtcmlnaHQgbGluZVxuICAgICAgICBwLmFkZFZlY3RvcnMocG9zLCByaWdodFZlYyk7XG4gICAgICAgIHAuYWRkVmVjdG9ycyhwLHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMF0gPSBwLmNsb25lKCk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcG9zLmNsb25lKCk7XG4gICAgICAgIGdlb20uc2V0RnJvbVBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZ2VvbSwgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgX2luZGljYXRvckxpbmVXaWR0aCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgICAgIC8vIEJvdHRvbS1yaWdodCBsaW5lXG4gICAgICAgIHAuYWRkVmVjdG9ycyhwb3MsIHJpZ2h0VmVjKTtcbiAgICAgICAgcC5zdWJWZWN0b3JzKHAsIHVwVmVjKTtcbiAgICAgICAgdmVydGljZXNbMF0gPSBwLmNsb25lKCk7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gcG9zLmNsb25lKCk7XG4gICAgICAgIGdlb20uc2V0RnJvbVBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMuZHJhd0xpbmUoZ2VvbSwgdGhpcy5pbmRpY2F0b3JNYXRlcmlhbCwgX2luZGljYXRvckxpbmVXaWR0aCwgSU5ESUNBVE9SX09WRVJMQVkpO1xuXG4gICAgICAgIC8vIEJvdHRvbS1sZWZ0IGxpbmVcbiAgICAgICAgcC5zdWJWZWN0b3JzKHBvcywgcmlnaHRWZWMpO1xuICAgICAgICBwLnN1YlZlY3RvcnMocCwgdXBWZWMpO1xuICAgICAgICB2ZXJ0aWNlc1swXSA9IHAuY2xvbmUoKTtcbiAgICAgICAgdmVydGljZXNbMV0gPSBwb3MuY2xvbmUoKTtcbiAgICAgICAgZ2VvbS5zZXRGcm9tUG9pbnRzKHZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy5kcmF3TGluZShnZW9tLCB0aGlzLmluZGljYXRvck1hdGVyaWFsLCBfaW5kaWNhdG9yTGluZVdpZHRoLCBJTkRJQ0FUT1JfT1ZFUkxBWSk7XG5cbiAgICB9XG5cbiAgICByZW5kZXJJbmRpY2F0b3Ioc25hcFJlc3VsdCkge1xuXG4gICAgICAgIGlmIChzbmFwUmVzdWx0LmlzUGVycGVuZGljdWxhcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJQZXJwZW5kaWN1bGFyKHNuYXBSZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoc25hcFJlc3VsdC5zbmFwVG9BcmMpIHtcbiAgICAgICAgICAgIGlmKHNuYXBSZXN1bHQuaXNBcmMgJiYgc25hcFJlc3VsdC5nZW9tVHlwZSA9PT0gU25hcFR5cGUuU05BUF9DSVJDVUxBUkFSQyAmJiB0aGlzLnZpZXdlci5tb2RlbC5pczJkKCkgJiYgIXRoaXMudmlld2VyLm1vZGVsLmlzUGRmKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZlcnRleEluZGljYXRvcihzbmFwUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgc3dpdGNoIChzbmFwUmVzdWx0Lmdlb21UeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNuYXBUeXBlLlNOQVBfVkVSVEVYOlxuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX0lOVEVSU0VDVElPTjpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZlcnRleEluZGljYXRvcihzbmFwUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX01JRFBPSU5UOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTWlkcG9pbnRJbmRpY2F0b3Ioc25hcFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU25hcFR5cGUuU05BUF9DSVJDTEVfQ0VOVEVSOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ2lyY2xlSW5kaWNhdG9yKHNuYXBSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNuYXBUeXBlLlNOQVBfRURHRTpcbiAgICAgICAgICAgIGNhc2UgU25hcFR5cGUuU05BUF9DVVJWRURFREdFOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRWRnZUluZGljYXRvcihzbmFwUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbmFwVHlwZS5TTkFQX0NJUkNVTEFSQVJDOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdlci5tb2RlbC5pczJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJWZXJ0ZXhJbmRpY2F0b3Ioc25hcFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDaXJjbGVJbmRpY2F0b3Ioc25hcFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNuYXBUeXBlLlNOQVBfRkFDRTpcbiAgICAgICAgICAgIGNhc2UgU25hcFR5cGUuU05BUF9DVVJWRURGQUNFOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVmVydGV4SW5kaWNhdG9yKHNuYXBSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNuYXBUeXBlLlJBU1RFUl9QSVhFTDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclBpeGVsSW5kaWNhdG9yKHNuYXBSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBsaW5lIGluIGFuIG92ZXJseWF5XG4gICAgICogQHBhcmFtIHtUSFJFRS5HZW9tZXRyeXxUSFJFRS5CdWZmZXJHZW9tZXRyeX0gZ2VvbVxuICAgICAqIEBwYXJhbSB7VEhSRUUuTWF0ZXJpYWx9IG1hdGVyaWFsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG92ZXJsYXlOYW1lXG4gICAgICovXG4gICAgZHJhd0xpbmUoZ2VvbSwgbWF0ZXJpYWwsIHdpZHRoLCBvdmVybGF5TmFtZSkge1xuXG4gICAgICAgIC8vIExpbmUgUGllY2VzXG4gICAgICAgIGlmIChvdmVybGF5TmFtZSA9PT0gR0VPTUVUUklFU19PVkVSTEFZKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlUeXBlID0gRURHRV9PVkVSTEFZO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHZlcnRpY2VzTGVuZ3RoLCBnZW9tUG9zO1xuICAgICAgICBpZiAoZ2VvbSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oICdTbmFwcGVySW5kaWNhdG9yLmRyYXdMaW5lKGdlb20sIG1hdGVyaWFsLCB3aWR0aCwgb3ZlcmxheU5hbWUpOiBUSFJFRS5HZW9tZXRyeSBoYXMgYmVlbiBkZXBlY3JhdGVkIGFuZCB0aGUgZ2VvbSBhcmd1bWVudCBzaG91bGQgdXNlIGEgVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZCcgKTtcbiAgICAgICAgICAgIHZlcnRpY2VzTGVuZ3RoID0gZ2VvbS52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZW9tUG9zID0gZ2VvbS5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgICAgICAgICB2ZXJ0aWNlc0xlbmd0aCA9IGdlb21Qb3MuY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlc0xlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgY3lsaW5kZXI7XG4gICAgICAgICAgICBpZiAoZ2VvbSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5KSB7XG4gICAgICAgICAgICAgICAgY3lsaW5kZXIgPSB0aGlzLmN5bGluZGVyTWVzaChnZW9tLnZlcnRpY2VzW2ldLCBnZW9tLnZlcnRpY2VzW2kgKyAxXSwgbWF0ZXJpYWwsIHdpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3lsaW5kZXIgPSB0aGlzLmN5bGluZGVyTWVzaChnZXRYWVpGcm9tUG9zKGdlb21Qb3MsIGkpLmNsb25lKCksIGdldFhZWkZyb21Qb3MoZ2VvbVBvcywgaSArIDEpLmNsb25lKCksIG1hdGVyaWFsLCB3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEVkZ2VTY2FsZShjeWxpbmRlcik7XG4gICAgICAgICAgICB0aGlzLmFkZE92ZXJsYXkob3ZlcmxheU5hbWUsIGN5bGluZGVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRyYXdQb2ludChwb2ludCwgbWF0ZXJpYWwsIG92ZXJsYXlOYW1lKSB7XG5cbiAgICAgICAgLy8gQmVjYXVzZSBldmVyeSBwb2ludCBpcyBzbmFwcGFibGUgaW4gUERGcywgZG9uJ3QgZGlzcGxheSB0aGUgZ3JlZW4gZG90IGZvciBQREZzLlxuICAgICAgICBpZiAodGhpcy52aWV3ZXIubW9kZWwuaXNMZWFmbGV0KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghX3BvaW50KVxuICAgICAgICAgICAgX3BvaW50ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDEuMCk7XG5cbiAgICAgICAgY29uc3QgcG9pbnRNZXNoID0gbmV3IFRIUkVFLk1lc2goX3BvaW50LCBtYXRlcmlhbCk7XG4gICAgICAgIHBvaW50TWVzaC5wb3NpdGlvbi5zZXQocG9pbnQueCwgcG9pbnQueSwgcG9pbnQueik7XG5cbiAgICAgICAgdGhpcy5zZXRQb2ludFNjYWxlKHBvaW50TWVzaCk7XG5cbiAgICAgICAgaWYgKG92ZXJsYXlOYW1lID09PSBHRU9NRVRSSUVTX09WRVJMQVkpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVR5cGUgPSBQT0lOVF9PVkVSTEFZO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRPdmVybGF5KG92ZXJsYXlOYW1lLCBwb2ludE1lc2gpO1xuXG4gICAgfVxuXG4gICAgZHJhd0NpcmNsZShwb2ludCwgbWF0ZXJpYWwsIG92ZXJsYXlOYW1lKSB7XG5cbiAgICAgICAgbGV0IHRvcnVzID0gbmV3IFRIUkVFLlRvcnVzR2VvbWV0cnkoX2luZGljYXRvclNpemUsIF9pbmRpY2F0b3JMaW5lV2lkdGgsIDIsIDIwKTtcbiAgICAgICAgY29uc3QgdG9ydXNNZXNoID0gbmV3IFRIUkVFLk1lc2godG9ydXMsIG1hdGVyaWFsKTtcbiAgICAgICAgdG9ydXNNZXNoLmxvb2tBdCh0aGlzLnZpZXdlci5uYXZpZ2F0aW9uLmdldEV5ZVZlY3RvcigpLm5vcm1hbGl6ZSgpKTtcbiAgICAgICAgdG9ydXMgPSBudWxsO1xuXG4gICAgICAgIHRvcnVzTWVzaC5wb3NpdGlvbi5zZXQocG9pbnQueCwgcG9pbnQueSwgcG9pbnQueik7XG5cbiAgICAgICAgdGhpcy5zZXRDaXJjbGVTY2FsZSh0b3J1c01lc2gpO1xuXG4gICAgICAgIHRoaXMuYWRkT3ZlcmxheShvdmVybGF5TmFtZSwgdG9ydXNNZXNoKTtcblxuICAgIH1cblxuICAgIHNldFNjYWxlKHBvaW50KSB7XG5cbiAgICAgICAgY29uc3QgcGl4ZWxTaXplID0gNTtcblxuICAgICAgICBjb25zdCBuYXZhcGkgPSB0aGlzLnZpZXdlci5uYXZpZ2F0aW9uO1xuICAgICAgICBjb25zdCBjYW1lcmEgPSBuYXZhcGkuZ2V0Q2FtZXJhKCk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbmF2YXBpLmdldFBvc2l0aW9uKCk7XG5cbiAgICAgICAgY29uc3QgcCA9IHBvaW50LmNsb25lKCk7XG5cbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBjYW1lcmEuaXNQZXJzcGVjdGl2ZSA/IHAuc3ViKHBvc2l0aW9uKS5sZW5ndGgoKVxuICAgICAgICAgICAgOiBuYXZhcGkuZ2V0RXllVmVjdG9yKCkubGVuZ3RoKCk7XG5cbiAgICAgICAgY29uc3QgZm92ID0gbmF2YXBpLmdldFZlcnRpY2FsRm92KCk7XG4gICAgICAgIGNvbnN0IHdvcmxkSGVpZ2h0ID0gMi4wICogZGlzdGFuY2UgKiBNYXRoLnRhbihUSFJFRS5NYXRoLmRlZ1RvUmFkKGZvdiAqIDAuNSkpO1xuXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gbmF2YXBpLmdldFNjcmVlblZpZXdwb3J0KCk7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gcGl4ZWxTaXplICogd29ybGRIZWlnaHQgLyB2aWV3cG9ydC5oZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cblxuICAgIHNldFBvaW50U2NhbGUocG9pbnRNZXNoKSB7XG5cbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNldFNjYWxlKHBvaW50TWVzaC5wb3NpdGlvbik7XG4gICAgICAgIHBvaW50TWVzaC5zY2FsZS54ID0gc2NhbGU7XG4gICAgICAgIHBvaW50TWVzaC5zY2FsZS55ID0gc2NhbGU7XG4gICAgICAgIHBvaW50TWVzaC5zY2FsZS56ID0gc2NhbGU7XG5cbiAgICB9XG5cbiAgICBzZXRDaXJjbGVTY2FsZSh0b3J1c01lc2gpIHtcblxuICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuc2V0U2NhbGUodG9ydXNNZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgdG9ydXNNZXNoLnNjYWxlLnggPSBzY2FsZTtcbiAgICAgICAgdG9ydXNNZXNoLnNjYWxlLnkgPSBzY2FsZTtcbiAgICB9XG5cbiAgICBzZXRFZGdlU2NhbGUoY3lsaW5kZXJNZXNoKSB7XG5cbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLnNldFNjYWxlKGN5bGluZGVyTWVzaC5wb3NpdGlvbik7XG4gICAgICAgIGN5bGluZGVyTWVzaC5zY2FsZS54ID0gc2NhbGU7XG4gICAgICAgIGN5bGluZGVyTWVzaC5zY2FsZS56ID0gc2NhbGU7XG4gICAgfVxuXG4gICAgdXBkYXRlUG9pbnRTY2FsZShvdmVybGF5TmFtZSkge1xuXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXlUeXBlICE9PSBQT0lOVF9PVkVSTEFZKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IG92ZXJsYXkgPSB0aGlzLnZpZXdlci5pbXBsLm92ZXJsYXlTY2VuZXNbb3ZlcmxheU5hbWVdO1xuICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgY29uc3Qgc2NlbmUgPSBvdmVybGF5LnNjZW5lO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjZW5lLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRNZXNoID0gc2NlbmUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50TWVzaCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9pbnRTY2FsZShwb2ludE1lc2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUVkZ2VTY2FsZShvdmVybGF5TmFtZSkge1xuXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXlUeXBlICE9PSBFREdFX09WRVJMQVkpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgb3ZlcmxheSA9IHRoaXMudmlld2VyLmltcGwub3ZlcmxheVNjZW5lc1tvdmVybGF5TmFtZV07XG4gICAgICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgICAgICBjb25zdCBzY2VuZSA9IG92ZXJsYXkuc2NlbmU7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NlbmUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjeWxpbmRlck1lc2ggPSBzY2VuZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY3lsaW5kZXJNZXNoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFZGdlU2NhbGUoY3lsaW5kZXJNZXNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNhbWVyYUNoYW5nZSgpIHtcblxuICAgICAgICB0aGlzLnVwZGF0ZVBvaW50U2NhbGUoR0VPTUVUUklFU19PVkVSTEFZKTtcbiAgICAgICAgdGhpcy51cGRhdGVFZGdlU2NhbGUoR0VPTUVUUklFU19PVkVSTEFZKTtcblxuICAgICAgICAvLyBpZiAoIXRoaXMuc25hcHBlci5tYXJrdXBNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAvLyB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcblxuICAgICAgICB0aGlzLnJlbW92ZU92ZXJsYXkoR0VPTUVUUklFU19PVkVSTEFZKTtcbiAgICAgICAgdGhpcy5yZW1vdmVPdmVybGF5KElORElDQVRPUl9PVkVSTEFZKTtcblxuICAgICAgICBpZiAoX3BvaW50KSB7XG4gICAgICAgICAgICBfcG9pbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgX3BvaW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJNZWFzdXJlQ29tbW9uIiwiQXV0b2Rlc2siLCJWaWV3aW5nIiwiaXNFcXVhbFZlY3RvcnMiLCJFUFNJTE9OIiwiU25hcFR5cGUiLCJOT19PVkVSTEFZIiwiRkFDRV9PVkVSTEFZIiwiRURHRV9PVkVSTEFZIiwiUE9JTlRfT1ZFUkxBWSIsIkdFT01FVFJJRVNfT1ZFUkxBWSIsIklORElDQVRPUl9PVkVSTEFZIiwiX2dlb21ldHJ5TGluZVdpZHRoIiwiX2luZGljYXRvckxpbmVXaWR0aCIsIl9pbmRpY2F0b3JTaXplIiwiX2luZGljYXRvckNvbG9yIiwiX2dlb21ldHJ5Q29sb3IiLCJfcG9pbnQiLCJ0bXBWZWMzIiwiVEhSRUUiLCJWZWN0b3IzIiwiZ2V0WFlaRnJvbVBvcyIsInBvc2l0aW9uQXR0cmlidXRlIiwiaWR4IiwieCIsImdldFgiLCJ5IiwiZ2V0WSIsInoiLCJnZXRaIiwiTnVsbFNuYXBwZXJJbmRpY2F0b3IiLCJpc051bGwiLCJyZW5kZXIiLCJyZW1vdmVPdmVybGF5Iiwib3ZlcmxheU5hbWUiLCJjbGVhck92ZXJsYXkiLCJjbGVhck92ZXJsYXlzIiwiYWRkT3ZlcmxheSIsIm1lc2giLCJkcmF3RmFjZSIsImdlb20iLCJtYXRlcmlhbCIsImN5bGluZGVyTWVzaCIsInBvaW50WCIsInBvaW50WSIsIndpZHRoIiwiTWVzaCIsInJlbmRlckdlb21ldHJ5Iiwic25hcFJlc3VsdCIsInJlbmRlclZlcnRleEluZGljYXRvciIsInJlbmRlck1pZHBvaW50SW5kaWNhdG9yIiwicmVuZGVyRWRnZUluZGljYXRvciIsInJlbmRlckNpcmNsZUluZGljYXRvciIsInJlbmRlclBlcnBlbmRpY3VsYXIiLCJyZW5kZXJQaXhlbEluZGljYXRvciIsInJlbmRlckluZGljYXRvciIsImRyYXdMaW5lIiwiZHJhd1BvaW50IiwicG9pbnQiLCJkcmF3Q2lyY2xlIiwic2V0U2NhbGUiLCJzZXRQb2ludFNjYWxlIiwicG9pbnRNZXNoIiwic2V0Q2lyY2xlU2NhbGUiLCJ0b3J1c01lc2giLCJzZXRFZGdlU2NhbGUiLCJ1cGRhdGVQb2ludFNjYWxlIiwidXBkYXRlRWRnZVNjYWxlIiwib25DYW1lcmFDaGFuZ2UiLCJkZXN0cm95IiwiU25hcHBlckluZGljYXRvciIsImNvbnN0cnVjdG9yIiwidmlld2VyIiwic25hcHBlciIsIm92ZXJsYXlUeXBlIiwicHJldmlld3NJbnRlcnNlY3RQb2ludCIsImltcGwiLCJjcmVhdGVPdmVybGF5U2NlbmUiLCJnZW9tZXRyeU1hdGVyaWFsIiwiTWVzaFBob25nTWF0ZXJpYWwiLCJjb2xvciIsIm9wYWNpdHkiLCJ0cmFuc3BhcmVudCIsImRlcHRoVGVzdCIsImRlcHRoV3JpdGUiLCJzaWRlIiwiRG91YmxlU2lkZSIsImluZGljYXRvck1hdGVyaWFsIiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJnZXRTbmFwUmVzdWx0IiwiaW50ZXJzZWN0UG9pbnQiLCJpc0VtcHR5IiwicmVuZGVyU25hcHBlZEdlb21ldHJ5IiwiaGFzVG9wb2xvZ3kiLCJyZW5kZXJTbmFwcGVkVG9wb2xvZ3kiLCJjbG9uZSIsInJlbW92ZU92ZXJsYXlTY2VuZSIsInNuYXBwZXJQbGFuZSIsImRpcmVjdGlvbiIsInN1YlZlY3RvcnMiLCJvcmllbnRhdGlvbiIsIk1hdHJpeDQiLCJsb29rQXQiLCJPYmplY3QzRCIsInVwIiwibXVsdGlwbHkiLCJzZXQiLCJsZW5ndGgiLCJjeWxpbmRlciIsIkN5bGluZGVyR2VvbWV0cnkiLCJlZGdlIiwiYXBwbHlNYXRyaXg0IiwicG9zaXRpb24iLCJnZW9tVHlwZSIsIlNOQVBfVkVSVEVYIiwiUkFTVEVSX1BJWEVMIiwiZ2VvbVZlcnRleCIsIlNOQVBfRURHRSIsIlNOQVBfQ1VSVkVERURHRSIsIlNOQVBfQ0lSQ1VMQVJBUkMiLCJTTkFQX01JRFBPSU5UIiwiZ2VvbUVkZ2UiLCJTTkFQX0ZBQ0UiLCJTTkFQX0NVUlZFREZBQ0UiLCJnZW9tRmFjZSIsInBvcyIsImdldFNuYXBSZXN1bHRQb3NpdGlvbiIsInNjYWxlIiwicmlnaHRWZWMiLCJuYXZpZ2F0aW9uIiwiZ2V0Q2FtZXJhUmlnaHRWZWN0b3IiLCJtdWx0aXBseVNjYWxhciIsInVwVmVjIiwiZ2V0Q2FtZXJhVXBWZWN0b3IiLCJCdWZmZXJHZW9tZXRyeSIsInZlcnRpY2VzIiwicCIsImFkZFZlY3RvcnMiLCJzZXRGcm9tUG9pbnRzIiwiaXNQZXJwZW5kaWN1bGFyIiwic25hcFRvQXJjIiwiaXNBcmMiLCJtb2RlbCIsImlzMmQiLCJpc1BkZiIsIlNOQVBfSU5URVJTRUNUSU9OIiwiU05BUF9DSVJDTEVfQ0VOVEVSIiwidmVydGljZXNMZW5ndGgiLCJnZW9tUG9zIiwiR2VvbWV0cnkiLCJjb25zb2xlIiwid2FybiIsImdldEF0dHJpYnV0ZSIsImNvdW50IiwiaSIsImlzTGVhZmxldCIsIlNwaGVyZUdlb21ldHJ5IiwidG9ydXMiLCJUb3J1c0dlb21ldHJ5IiwiZ2V0RXllVmVjdG9yIiwibm9ybWFsaXplIiwicGl4ZWxTaXplIiwibmF2YXBpIiwiY2FtZXJhIiwiZ2V0Q2FtZXJhIiwiZ2V0UG9zaXRpb24iLCJkaXN0YW5jZSIsImlzUGVyc3BlY3RpdmUiLCJzdWIiLCJmb3YiLCJnZXRWZXJ0aWNhbEZvdiIsIndvcmxkSGVpZ2h0IiwiTWF0aCIsInRhbiIsImRlZ1RvUmFkIiwidmlld3BvcnQiLCJnZXRTY3JlZW5WaWV3cG9ydCIsImhlaWdodCIsIm92ZXJsYXkiLCJvdmVybGF5U2NlbmVzIiwic2NlbmUiLCJjaGlsZHJlbiIsImRpc3Bvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./extensions/Snapping/SnapperIndicator.js\n");

/***/ }),

/***/ "./extensions/Snapping/index.js":
/*!**************************************!*\
  !*** ./extensions/Snapping/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar av = Autodesk.Viewing;\n\n/**\n * @namespace Autodesk.Viewing.Extensions.Snapping\n */\nvar namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Snapping');\n\n/**\n * @param m\n * @param ns\n * @private\n */\nfunction _export(m, ns) {\n  for (var prop in m) {\n    if (Object.prototype.hasOwnProperty.call(m, prop)) {\n      //Export directly into the module (e.g. for node.js use, where LMV is used via require instead from global namespace)\n      module.exports[prop] = m[prop];\n\n      //Export into the desired viewer namespace\n      ns[prop] = m[prop];\n    }\n  }\n}\n\n_export(__webpack_require__(/*! ./SnapMath.js */ \"./extensions/Snapping/SnapMath.js\"), namespace);\n_export(__webpack_require__(/*! ./Snapper.js */ \"./extensions/Snapping/Snapper.js\"), namespace);\n_export(__webpack_require__(/*! ./SnapperIndicator.js */ \"./extensions/Snapping/SnapperIndicator.js\"), namespace);\n\n\n/**\n * Utility extension that provides access to the {@link Autodesk.Viewing.Extensions.Snapping.Snapper} tool.\n *\n * The extension id is: `Autodesk.Snapping`\n *\n * @example\n *   viewer.loadExtension('Autodesk.Snapping')\n *\n * @memberof Autodesk.Viewing.Extensions\n * @alias Autodesk.Viewing.Extensions.SnappingExtension\n * @see {@link Autodesk.Viewing.Extension} for common inherited methods.\n * @class\n */\nclass SnappingExtension extends av.Extension {\n\n  /**\n   * @param {Viewer3D} viewer - Viewer instance\n   * @param {object} options - Configurations for the extension\n   * @alias Autodesk.Viewing.Extensions.SnappingExtension\n   * @class\n   */\n  constructor(viewer, options) {\n    super(viewer, options);\n  }\n\n  /**\n   * Load the extension.\n   *\n   * @returns {Promise} that resolves when dependent extension finishes loading.\n   *\n   * @alias Autodesk.Viewing.Extensions.SnappingExtension#load\n   */\n  load() {\n    // Load the required dependency (and return the pending load as the load completion Promise)\n    return this.viewer.loadExtension('Autodesk.CompGeom');\n  }\n\n  /**\n   * Unloads the extension.\n   * It does not unload dependent extensions.\n   *\n   * @returns {boolean} Always returns true\n   *\n   * @alias Autodesk.Viewing.Extensions.SnappingExtension#unload\n   */\n  unload() {return true;}\n\n\n  /**\n   * Unused method.\n   *\n   * @returns {boolean} Always returns true\n   *\n   * @alias Autodesk.Viewing.Extensions.SnappingExtension#activate\n   */\n  activate() {return true;}\n\n  /**\n   * Unused method.\n   *\n   * @returns {boolean} Always returns false\n   *\n   * @alias Autodesk.Viewing.Extensions.SnappingExtension#deactivate\n   */\n  deactivate() {return false;}\n}\n\n// The ExtensionManager requires an extension to be registered.\nav.theExtensionManager.registerExtension('Autodesk.Snapping', SnappingExtension);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leHRlbnNpb25zL1NuYXBwaW5nL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFDQSxJQUFJQSxFQUFFLEdBQUdDLFFBQVEsQ0FBQ0MsT0FBTzs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsSUFBSUMsU0FBUyxHQUFHQyxpQkFBaUIsQ0FBQyxzQ0FBc0MsQ0FBQzs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLE9BQU9BLENBQUNDLENBQUMsRUFBRUMsRUFBRSxFQUFFO0VBQ3BCLEtBQUssSUFBSUMsSUFBSSxJQUFJRixDQUFDLEVBQUU7SUFDaEIsSUFBSUcsTUFBTSxDQUFDQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDTixDQUFDLEVBQUVFLElBQUksQ0FBQyxFQUFFO01BQy9DO01BQ0FLLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDTixJQUFJLENBQUMsR0FBR0YsQ0FBQyxDQUFDRSxJQUFJLENBQUM7O01BRTlCO01BQ0FELEVBQUUsQ0FBQ0MsSUFBSSxDQUFDLEdBQUdGLENBQUMsQ0FBQ0UsSUFBSSxDQUFDO0lBQ3RCO0VBQ0o7QUFDSjs7QUFFQUgsT0FBTyxDQUFDVSxtQkFBTyxDQUFDLHdEQUFlLENBQUMsRUFBRVosU0FBUyxDQUFDO0FBQzVDRSxPQUFPLENBQUNVLG1CQUFPLENBQUMsc0RBQWMsQ0FBQyxFQUFFWixTQUFTLENBQUM7QUFDM0NFLE9BQU8sQ0FBQ1UsbUJBQU8sQ0FBQyx3RUFBdUIsQ0FBQyxFQUFFWixTQUFTLENBQUM7OztBQUdwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1hLGlCQUFpQixTQUFTaEIsRUFBRSxDQUFDaUIsU0FBUyxDQUFDOztFQUV6QztBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsV0FBV0EsQ0FBQ0MsTUFBTSxFQUFFQyxPQUFPLEVBQUU7SUFDekIsS0FBSyxDQUFDRCxNQUFNLEVBQUVDLE9BQU8sQ0FBQztFQUMxQjs7RUFFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxJQUFJQSxDQUFBLEVBQUc7SUFDSDtJQUNBLE9BQU8sSUFBSSxDQUFDRixNQUFNLENBQUNHLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQztFQUN6RDs7RUFFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLE1BQU1BLENBQUEsRUFBRyxDQUFFLE9BQU8sSUFBSSxDQUFFOzs7RUFHeEI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsUUFBUUEsQ0FBQSxFQUFHLENBQUUsT0FBTyxJQUFJLENBQUU7O0VBRTFCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLFVBQVVBLENBQUEsRUFBRyxDQUFFLE9BQU8sS0FBSyxDQUFFO0FBQ2pDOztBQUVBO0FBQ0F6QixFQUFFLENBQUMwQixtQkFBbUIsQ0FBQ0MsaUJBQWlCLENBQUMsbUJBQW1CLEVBQUVYLGlCQUFpQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQXV0b2Rlc2suRXh0ZW5zaW9ucy8uL2V4dGVuc2lvbnMvU25hcHBpbmcvaW5kZXguanM/Y2JhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBhdiA9IEF1dG9kZXNrLlZpZXdpbmc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuU25hcHBpbmdcbiAqL1xudmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrTmFtZXNwYWNlKCdBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuU25hcHBpbmcnKTtcblxuLyoqXG4gKiBAcGFyYW0gbVxuICogQHBhcmFtIG5zXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZXhwb3J0KG0sIG5zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBtKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobSwgcHJvcCkpIHtcbiAgICAgICAgICAgIC8vRXhwb3J0IGRpcmVjdGx5IGludG8gdGhlIG1vZHVsZSAoZS5nLiBmb3Igbm9kZS5qcyB1c2UsIHdoZXJlIExNViBpcyB1c2VkIHZpYSByZXF1aXJlIGluc3RlYWQgZnJvbSBnbG9iYWwgbmFtZXNwYWNlKVxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHNbcHJvcF0gPSBtW3Byb3BdO1xuXG4gICAgICAgICAgICAvL0V4cG9ydCBpbnRvIHRoZSBkZXNpcmVkIHZpZXdlciBuYW1lc3BhY2VcbiAgICAgICAgICAgIG5zW3Byb3BdID0gbVtwcm9wXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuX2V4cG9ydChyZXF1aXJlKFwiLi9TbmFwTWF0aC5qc1wiKSwgbmFtZXNwYWNlKTtcbl9leHBvcnQocmVxdWlyZShcIi4vU25hcHBlci5qc1wiKSwgbmFtZXNwYWNlKTtcbl9leHBvcnQocmVxdWlyZShcIi4vU25hcHBlckluZGljYXRvci5qc1wiKSwgbmFtZXNwYWNlKTtcblxuXG4vKipcbiAqIFV0aWxpdHkgZXh0ZW5zaW9uIHRoYXQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSB7QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLlNuYXBwaW5nLlNuYXBwZXJ9IHRvb2wuXG4gKlxuICogVGhlIGV4dGVuc2lvbiBpZCBpczogYEF1dG9kZXNrLlNuYXBwaW5nYFxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHZpZXdlci5sb2FkRXh0ZW5zaW9uKCdBdXRvZGVzay5TbmFwcGluZycpXG4gKlxuICogQG1lbWJlcm9mIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9uc1xuICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5TbmFwcGluZ0V4dGVuc2lvblxuICogQHNlZSB7QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb259IGZvciBjb21tb24gaW5oZXJpdGVkIG1ldGhvZHMuXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgU25hcHBpbmdFeHRlbnNpb24gZXh0ZW5kcyBhdi5FeHRlbnNpb24ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtWaWV3ZXIzRH0gdmlld2VyIC0gVmlld2VyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBDb25maWd1cmF0aW9ucyBmb3IgdGhlIGV4dGVuc2lvblxuICAgICAqIEBhbGlhcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuU25hcHBpbmdFeHRlbnNpb25cbiAgICAgKiBAY2xhc3NcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2aWV3ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIodmlld2VyLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBleHRlbnNpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB3aGVuIGRlcGVuZGVudCBleHRlbnNpb24gZmluaXNoZXMgbG9hZGluZy5cbiAgICAgKlxuICAgICAqIEBhbGlhcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuU25hcHBpbmdFeHRlbnNpb24jbG9hZFxuICAgICAqL1xuICAgIGxvYWQoKSB7XG4gICAgICAgIC8vIExvYWQgdGhlIHJlcXVpcmVkIGRlcGVuZGVuY3kgKGFuZCByZXR1cm4gdGhlIHBlbmRpbmcgbG9hZCBhcyB0aGUgbG9hZCBjb21wbGV0aW9uIFByb21pc2UpXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdlci5sb2FkRXh0ZW5zaW9uKCdBdXRvZGVzay5Db21wR2VvbScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVubG9hZHMgdGhlIGV4dGVuc2lvbi5cbiAgICAgKiBJdCBkb2VzIG5vdCB1bmxvYWQgZGVwZW5kZW50IGV4dGVuc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQWx3YXlzIHJldHVybnMgdHJ1ZVxuICAgICAqXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5TbmFwcGluZ0V4dGVuc2lvbiN1bmxvYWRcbiAgICAgKi9cbiAgICB1bmxvYWQoKSB7IHJldHVybiB0cnVlOyB9XG5cblxuICAgIC8qKlxuICAgICAqIFVudXNlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQWx3YXlzIHJldHVybnMgdHJ1ZVxuICAgICAqXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5TbmFwcGluZ0V4dGVuc2lvbiNhY3RpdmF0ZVxuICAgICAqL1xuICAgIGFjdGl2YXRlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgLyoqXG4gICAgICogVW51c2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBBbHdheXMgcmV0dXJucyBmYWxzZVxuICAgICAqXG4gICAgICogQGFsaWFzIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5TbmFwcGluZ0V4dGVuc2lvbiNkZWFjdGl2YXRlXG4gICAgICovXG4gICAgZGVhY3RpdmF0ZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbi8vIFRoZSBFeHRlbnNpb25NYW5hZ2VyIHJlcXVpcmVzIGFuIGV4dGVuc2lvbiB0byBiZSByZWdpc3RlcmVkLlxuYXYudGhlRXh0ZW5zaW9uTWFuYWdlci5yZWdpc3RlckV4dGVuc2lvbignQXV0b2Rlc2suU25hcHBpbmcnLCBTbmFwcGluZ0V4dGVuc2lvbik7XG5cbiJdLCJuYW1lcyI6WyJhdiIsIkF1dG9kZXNrIiwiVmlld2luZyIsIm5hbWVzcGFjZSIsIkF1dG9kZXNrTmFtZXNwYWNlIiwiX2V4cG9ydCIsIm0iLCJucyIsInByb3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIlNuYXBwaW5nRXh0ZW5zaW9uIiwiRXh0ZW5zaW9uIiwiY29uc3RydWN0b3IiLCJ2aWV3ZXIiLCJvcHRpb25zIiwibG9hZCIsImxvYWRFeHRlbnNpb24iLCJ1bmxvYWQiLCJhY3RpdmF0ZSIsImRlYWN0aXZhdGUiLCJ0aGVFeHRlbnNpb25NYW5hZ2VyIiwicmVnaXN0ZXJFeHRlbnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./extensions/Snapping/index.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./extensions/Snapping/index.js");
/******/ 	Autodesk.Extensions.Snapping = __webpack_exports__;
/******/ 	
/******/ })()
;